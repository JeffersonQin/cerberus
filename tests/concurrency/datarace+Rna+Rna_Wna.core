{- In every execution the first non-atomic load races with the non-atomic write. 
   This program proved an earlier version of our datarace detection wrong. In that 
   version we only checked for dataraces with the hb-latest action to that location,
   which means that in the execution where thread 1 executed before thread 2 the datarace
   was not detected.
-}

{-
fun main () : [integer] :=
  x <- create(signed int);
  store(signed int, x, 0);
  {{{
       load(signed int, x)
  |||
       load(signed int, x);
       store(signed int, x, 1)
  }}};
  kill(x);
  ret 0
-}
proc main () : eff integer :=
  let strong x = create(<alignof>("signed int"), "signed int") in
  let strong _ = store("signed int", x, 0) in
  let strong _ = par(
    let strong _ = load("signed int", x) in
    return (unit)
    end
  ,
    let strong _ = load("signed int", x) in
    let strong _ = store("signed int", x, 1) in
    return(unit)
    end end 
  ) in
  let strong _ = kill(x) in
  return(0)
  end end end end
