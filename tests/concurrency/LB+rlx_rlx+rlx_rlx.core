{- LB+rlx_rlx+rlx_rlx Load Buffering, with relaxed loads and stores The
   values of a1 and a2 can both be 1. They can also be both 0, or one of
   them can be 1.  An exhaustive execution of this program should
   therefore return the values 0, 1, 2 and 3.  -}

fun main () : [integer] :=
  let strong x = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _ = store("_Atomic(signed int)", x, 0) in
  let strong y = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _ = store("_Atomic(signed int)", y, 0) in
  let strong (a1, a2) = par(
    let strong a1 = load("_Atomic(signed int)", x, relaxed) in
    let strong _ = store("_Atomic(signed int)", y, 1, relaxed) in
    return (a1)
    end end
  ,
    let strong a2 = load("_Atomic(signed int)", y, relaxed) in
    let strong _ = store("_Atomic(signed int)", x, 1, relaxed) in
    return (a2)
    end end
  ) in
  let strong _ = kill(x) in
  let strong _ = kill(y) in
  return(a1 + (2 * a2))
  end end end end end end end
