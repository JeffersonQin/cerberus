{- The loads are allowed to both read 0, which means there is a cycle
   in mo union hb.  The total set of allowed outcomes is 0, 1, 2, 3.
   -}

{-
fun main () : [integer] :=
  x <- create(_Atomic(signed int));
  y <- create(_Atomic(signed int));
  (a1, a2) <- {{{
      store(_Atomic(signed int), x, 0, release);
      store(_Atomic(signed int), y, 1, release);
      load(_Atomic(signed int), y, acquire)
  |||
      store(_Atomic(signed int), y, 0, release);
      store(_Atomic(signed int), x, 1, release);
      load(_Atomic(signed int), x, acquire)
  }}};
  kill(x);
  kill(y);
  ret a1 + (2 * a2)
-}
fun main () : [integer] :=
  let strong x = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong y = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong (a1, a2) = par(
    let strong _ = store("_Atomic(signed int)", x, 0, release) in
    let strong _ = store("_Atomic(signed int)", y, 1, release) in
    let strong ret = load("_Atomic(signed int)", y, acquire) in
    return (ret)
    end end end
  ,
    let strong _ = store("_Atomic(signed int)", y, 0, release) in
    let strong _ = store("_Atomic(signed int)", x, 1, release) in
    let strong ret = load("_Atomic(signed int)", x, acquire) in
    return (ret)
    end end end
  ) in
  let strong _ = kill(x) in
  let strong _ = kill(y) in
  return(a1 + (2 * a2))
  end end end end end
