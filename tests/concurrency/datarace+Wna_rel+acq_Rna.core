{- There is a datarace between the store and load to x. However, when
the load of y reads the value 1, it synchronizes with the first thread
and in those executions there is no datarace. The total set of
outcomes is therefore 0 (defined), and data_race (undefined). -}

{-
fun main () : [integer] :=
  x <- create(signed int);
  y <- create(_Atomic(signed int));
  store(signed int, x, 0);
  store(signed int, y, 0);
  (a, b) <- {{{
       store(signed int, x, 1);
       store(_Atomic(signed int), y, 1, release)
  |||
       load(_Atomic(signed int), y, acquire);
       load(signed int, x)
  }}};
  kill(x);
  kill(y);
  ret b
-}
fun main () : [integer] :=
  let strong x = create(<alignof>("signed int"), "signed int") in
  let strong y = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _ = store("signed int", x, 0) in
  let strong _ = store("signed int", y, 0) in
  let strong (_, b) = par(
    let strong _ = store("signed int", x, 1) in
    let strong _ = store("_Atomic(signed int)", y, 1, release) in
    return (())
    end end
  ,
    let strong _   = load("_Atomic(signed int)", y, acquire) in
    let strong ret = load("signed int", x) in
    return(ret)
    end end
  ) in
  let strong _ = kill(x) in
  let strong _ = kill(y) in
  return(b)
  end end end end end end end
