{- MP+na_rel+acq_na Message Passing, of data held in non-atomic x,
   with release/acquire synchronisation on y.  If the value of a1 is
   1, then the value of a2 should also be 1.  An exhaustive execution
   of this program should therefore return the value 1 and 2, but not
   0.  -}

{-
fun main () : [integer] :=
  x <- create(signed int);
  store(signed int, x, 0);
  y <- create(_Atomic(signed int));
  store(signed int, y, 0);
  (foo, a2) <- {{{
       store(signed int, x, 1);
       store(_Atomic(signed int), y, 1, release)
  |||
       a1 <- load(_Atomic(signed int), y, acquire);
       (if a1 = 1 then       
           load(signed int, x)
        else
           2)
  }}};
  kill(x);
  kill(y);
  ret a2
-}
fun main () : [integer] :=
  let strong x = create(<alignof>("signed int"), "signed int") in
  let strong _ = store("signed int", x, 0) in
  let strong y = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _ = store("signed int", y, 0) in
  let strong (_, a2) = par(
    let strong _ = store("signed int", x, 1) in
    let strong _ = store("_Atomic(signed int)", y, 1, release) in
    return (())
    end end
  ,
    let strong a1 = load("_Atomic(signed int)", y, acquire) in
    if a1 = 1 then
      let strong ret = load("signed int", x) in
      return(ret)
      end
    else
      return (2)
    end
    end
  ) in
  let strong _ = kill(x) in
  let strong _ = kill(y) in
  return(a2)
  end end end end end end end
