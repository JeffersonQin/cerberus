{- The reading threads have to see the writes to x and y in the same
order. An exhaustive execution will therefore produce the values 0-15,
except 5. This contrasts with the test with release/acquire
atomics where the two reading threads do not have to see the writes in
the same order. -}

{-
fun main () : [integer] :=
  x <- create(_Atomic(signed int));
  y <- create(_Atomic(signed int));
  store(_Atomic(signed int), x, 0);
  store(_Atomic(signed int), y, 0);
  (foo1, foo2, a, b) <- {{{
      store(_Atomic(signed int), x, 1, seq_cst)
  |||
      store(_Atomic(signed int), y, 1, seq_cst)
  |||
      ax <- load(_Atomic(signed int), x, seq_cst);
      ay <- load(_Atomic(signed int), y, seq_cst);
      ax + (2 * ay)
  |||
      by <- load(_Atomic(signed int), y, seq_cst);
      bx <- load(_Atomic(signed int), x, seq_cst);
      by + (2 * bx)
  }}};
  kill(x);
  kill(y);
  ret a + (4 * b)
-}
fun main () : [integer] :=
  let strong x = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong y = create(<alignof>("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _ = store("_Atomic(signed int)", x, 0) in
  let strong _ = store("_Atomic(signed int)", y, 0) in
  let strong (_, _, a, b) = par(
      let strong _ = store("_Atomic(signed int)", x, 1, seq_cst) in
      return(unit)
      end
  ,
      let strong _ = store("_Atomic(signed int)", y, 1, seq_cst) in
      return(unit)
      end
  ,
      let strong ax = load("_Atomic(signed int)", x, seq_cst) in
      let strong ay = load("_Atomic(signed int)", y, seq_cst) in
      return(ax + (2 * ay))
      end end
  ,
      let strong by = load("_Atomic(signed int)", y, seq_cst) in
      let strong bx = load("_Atomic(signed int)", x, seq_cst) in
      return(by + (2 * bx))
      end end
  ) in
  let strong _ = kill(x) in
  let strong _ = kill(y) in
  return(a + (4 * b))
  end end end end end end end
