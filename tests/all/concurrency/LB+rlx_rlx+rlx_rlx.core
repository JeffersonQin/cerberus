{- LB+rlx_rlx+rlx_rlx Load Buffering, with relaxed loads and stores The
   values of a1 and a2 can both be 1. They can also be both 0, or one of
   them can be 1.  An exhaustive execution of this program should
   therefore return the values 0, 1, 2 and 3.  -}

proc main () : eff integer :=
  let strong x: pointer = create(Ivalignof("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _          = store("_Atomic(signed int)", x, Specified(0))                   in
  let strong y: pointer = create(Ivalignof("_Atomic(signed int)"), "_Atomic(signed int)") in
  let strong _          = store("_Atomic(signed int)", y, Specified(0))                   in
  let strong (_a1: loaded integer, _a2: loaded integer) = par(
    let strong a1: loaded integer = load("_Atomic(signed int)", x, relaxed)                in
    let strong _                  = store("_Atomic(signed int)", y, Specified(1), relaxed) in
    return (a1)
  ,
    let strong a2: loaded integer = load("_Atomic(signed int)", y, relaxed)                in
    let strong _                  = store("_Atomic(signed int)", x, Specified(1), relaxed) in
    return (a2)
  ) in
  let strong _ = kill(x) in
  let strong _ = kill(y) in
  return(case (_a1, _a2) of
    | (Specified(a1: integer), Specified(a2: integer)) =>
        Specified(a1 + (2 * a2))
    | _ =>
        Unspecified("signed int")
  end)
