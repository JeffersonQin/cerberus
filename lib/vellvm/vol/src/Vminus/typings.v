(* generated by Ott 0.20.1 from: syntax.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.

Require Import Metatheory.
Require Import syntax.
Require Import infrastructure.
Require Import ListSet.
Require Import analysis.

Module VMtypings.
Import VMsyntax.
Import VMinfra.



(** definitions *)

(* defns Jwf_value *)
Inductive wf_value : fdef -> value -> Prop :=    (* defn wf_value *)
 | wf_value_const : forall (fdef5:fdef) (const5:const),
     wf_value fdef5 (value_const const5)
 | wf_value_id : forall (fdef5:fdef) (id5:id),
      lookupIDFromFdef  fdef5   id5  = Some tt  ->
     wf_value fdef5 (value_id id5).
(** definitions *)

(* defns Jwf_operand *)
Inductive wf_operand : fdef -> block -> insn -> id -> Prop :=    (* defn wf_operand *)
 | wf_operand_intro : forall (fdef5:fdef) (block5:block) (insn5:insn) (id':id) (ids5:ids) (block':block),
      insnInFdefBlockB  insn5   fdef5   block5  = true  ->
      getInsnOperands  insn5  =  ids5  ->
      ( set_In  id'   ids5 )  ->
      lookupBlockViaIDFromFdef  fdef5   id'  =   (Some  block' )   ->
      (notT (  isPhiNode  insn5  ))  ->
      (    insnDominates  id'   insn5   block5   \/   blockStrictDominates  fdef5   block'   block5    \/   (  (not (  (  isReachableFromEntry  fdef5   block5  )  ))  )   )  ->
     wf_operand fdef5 block5 insn5 id'.

(* auxiliary list types for defns *)
Inductive
list_id : Set :=
   Nil_list_id : list_id
 | Cons_list_id : id -> list_id -> list_id.

Fixpoint map_list_id (A:Set) (f:id->A) (l0:list_id) {struct l0} : list A :=
  match l0 with
  | Nil_list_id => nil
  | Cons_list_id h tl_ => cons (f h) (map_list_id A f tl_)
  end.
Implicit Arguments map_list_id.

Fixpoint make_list_id (l0:list id) : list_id :=
  match l0 with
  | nil  => Nil_list_id
  | cons h tl_ => Cons_list_id h (make_list_id tl_)
  end.

Fixpoint unmake_list_id (l0:list_id) :  list id :=
  match l0 with
  | Nil_list_id => nil
  | Cons_list_id h tl_ =>  cons h (unmake_list_id tl_)
  end.

Fixpoint nth_list_id (n:nat) (l0:list_id) {struct n} : option id :=
  match n,l0 with
  | O, Cons_list_id h tl_ => Some h 
  | O, other => None
  | S m, Nil_list_id => None
  | S m, Cons_list_id h tl_ => nth_list_id m tl_
  end.
Implicit Arguments nth_list_id.

Fixpoint app_list_id (l0 m:list_id) {struct l0} : list_id :=
  match l0 with
  | Nil_list_id => m
  | Cons_list_id h tl_ => Cons_list_id h (app_list_id tl_ m)
  end.


Inductive
list_fdef_block_insn_id : Set :=
   Nil_list_fdef_block_insn_id : list_fdef_block_insn_id
 | Cons_list_fdef_block_insn_id : fdef -> block -> insn -> id -> list_fdef_block_insn_id -> list_fdef_block_insn_id.

Fixpoint map_list_fdef_block_insn_id (A:Set) (f:fdef->block->insn->id->A) (l0:list_fdef_block_insn_id) {struct l0} : list A :=
  match l0 with
  | Nil_list_fdef_block_insn_id => nil
  | Cons_list_fdef_block_insn_id h0 h1 h2 h3 tl_ => cons (f h0 h1 h2 h3) (map_list_fdef_block_insn_id A f tl_)
  end.
Implicit Arguments map_list_fdef_block_insn_id.

Fixpoint make_list_fdef_block_insn_id (l0:list (fdef*block*insn*id)) : list_fdef_block_insn_id :=
  match l0 with
  | nil  => Nil_list_fdef_block_insn_id
  | cons (h0,h1,h2,h3) tl_ => Cons_list_fdef_block_insn_id h0 h1 h2 h3 (make_list_fdef_block_insn_id tl_)
  end.

Fixpoint unmake_list_fdef_block_insn_id (l0:list_fdef_block_insn_id) :  list (fdef*block*insn*id) :=
  match l0 with
  | Nil_list_fdef_block_insn_id => nil
  | Cons_list_fdef_block_insn_id h0 h1 h2 h3 tl_ =>  cons (h0,h1,h2,h3) (unmake_list_fdef_block_insn_id tl_)
  end.

Fixpoint nth_list_fdef_block_insn_id (n:nat) (l0:list_fdef_block_insn_id) {struct n} : option (fdef*block*insn*id) :=
  match n,l0 with
  | O, Cons_list_fdef_block_insn_id h0 h1 h2 h3 tl_ => Some (h0,h1,h2,h3) 
  | O, other => None
  | S m, Nil_list_fdef_block_insn_id => None
  | S m, Cons_list_fdef_block_insn_id h0 h1 h2 h3 tl_ => nth_list_fdef_block_insn_id m tl_
  end.
Implicit Arguments nth_list_fdef_block_insn_id.

Fixpoint app_list_fdef_block_insn_id (l0 m:list_fdef_block_insn_id) {struct l0} : list_fdef_block_insn_id :=
  match l0 with
  | Nil_list_fdef_block_insn_id => m
  | Cons_list_fdef_block_insn_id h0 h1 h2 h3 tl_ => Cons_list_fdef_block_insn_id h0 h1 h2 h3 (app_list_fdef_block_insn_id tl_ m)
  end.


(** definitions *)

(* defns Jwf_insn_base *)
Inductive wf_insn_base : fdef -> block -> insn -> Prop :=    (* defn wf_insn_base *)
 | wf_insn_base_intro : forall (id_list:list_id) (fdef5:fdef) (block5:block) (insn5:insn) (ids5:ids),
      insnInFdefBlockB  insn5   fdef5   block5  = true  ->
      getInsnOperands  insn5  =  ids5  ->
      ids5  = unmake_list_id  id_list  ->
     (wf_operand_list (make_list_fdef_block_insn_id (map_list_id (fun (id_:id) => (fdef5,block5,insn5,id_)) id_list))) ->
     wf_insn_base fdef5 block5 insn5
with wf_operand_list : list_fdef_block_insn_id -> Prop :=
 | Nil_wf_operand_list : wf_operand_list Nil_list_fdef_block_insn_id
 | Cons_wf_operand_list : forall (fdef5:fdef) (block5:block) (insn5:insn) (id_:id) (l':list_fdef_block_insn_id),
      ((wf_operand fdef5 block5 insn5 id_)) -> wf_operand_list l' ->
      wf_operand_list (Cons_list_fdef_block_insn_id fdef5 block5 insn5 id_ l').

(* auxiliary list types for defns *)
Inductive
list_fdef_value : Set :=
   Nil_list_fdef_value : list_fdef_value
 | Cons_list_fdef_value : fdef -> value -> list_fdef_value -> list_fdef_value.

Fixpoint map_list_fdef_value (A:Set) (f:fdef->value->A) (l0:list_fdef_value) {struct l0} : list A :=
  match l0 with
  | Nil_list_fdef_value => nil
  | Cons_list_fdef_value h0 h1 tl_ => cons (f h0 h1) (map_list_fdef_value A f tl_)
  end.
Implicit Arguments map_list_fdef_value.

Fixpoint make_list_fdef_value (l0:list (fdef*value)) : list_fdef_value :=
  match l0 with
  | nil  => Nil_list_fdef_value
  | cons (h0,h1) tl_ => Cons_list_fdef_value h0 h1 (make_list_fdef_value tl_)
  end.

Fixpoint unmake_list_fdef_value (l0:list_fdef_value) :  list (fdef*value) :=
  match l0 with
  | Nil_list_fdef_value => nil
  | Cons_list_fdef_value h0 h1 tl_ =>  cons (h0,h1) (unmake_list_fdef_value tl_)
  end.

Fixpoint nth_list_fdef_value (n:nat) (l0:list_fdef_value) {struct n} : option (fdef*value) :=
  match n,l0 with
  | O, Cons_list_fdef_value h0 h1 tl_ => Some (h0,h1) 
  | O, other => None
  | S m, Nil_list_fdef_value => None
  | S m, Cons_list_fdef_value h0 h1 tl_ => nth_list_fdef_value m tl_
  end.
Implicit Arguments nth_list_fdef_value.

Fixpoint app_list_fdef_value (l0 m:list_fdef_value) {struct l0} : list_fdef_value :=
  match l0 with
  | Nil_list_fdef_value => m
  | Cons_list_fdef_value h0 h1 tl_ => Cons_list_fdef_value h0 h1 (app_list_fdef_value tl_ m)
  end.


(** definitions *)

(* defns Jwf_insn *)
Inductive wf_insn : fdef -> block -> insn -> Prop :=    (* defn wf_insn *)
 | wf_insn_return : forall (fdef5:fdef) (block5:block) (id5:id) (value5:value),
     wf_value fdef5 value5 ->
     wf_insn_base fdef5 block5 (insn_terminator (insn_return id5 value5)) ->
     wf_insn fdef5 block5 (insn_terminator (insn_return id5 value5))
 | wf_insn_br : forall (fdef5:fdef) (block_5:block) (id5:id) (value5:value) (l1 l2:l) (block1 block2:block),
     wf_value fdef5 value5 ->
      lookupBlockViaLabelFromFdef  fdef5   l1  =   (Some  block1 )   ->
      lookupBlockViaLabelFromFdef  fdef5   l2  =   (Some  block2 )   ->
      (not (  (  l1  =  l2  )  ))  ->
     wf_insn_base fdef5 block_5 (insn_terminator (insn_br id5 value5 l1 l2)) ->
     wf_insn fdef5 block_5 (insn_terminator (insn_br id5 value5 l1 l2))
 | wf_insn_br_uncond : forall (fdef5:fdef) (block5:block) (id5:id) (l5:l),
      lookupBlockViaLabelFromFdef  fdef5   l5  =   (Some  block5 )   ->
     wf_insn_base fdef5 block5 (insn_terminator (insn_br_uncond id5 l5)) ->
     wf_insn fdef5 block5 (insn_terminator (insn_br_uncond id5 l5))
 | wf_insn_bop : forall (fdef5:fdef) (block5:block) (id5:id) (bop5:bop) (value1 value2:value),
     wf_value fdef5 value1 ->
     wf_value fdef5 value2 ->
     wf_insn_base fdef5 block5 (insn_cmd (insn_bop id5 bop5 value1 value2)) ->
     wf_insn fdef5 block5 (insn_cmd (insn_bop id5 bop5 value1 value2))
 | wf_insn_icmp : forall (fdef5:fdef) (block5:block) (id5:id) (cond5:cond) (value1 value2:value),
     wf_value fdef5 value1 ->
     wf_value fdef5 value2 ->
     wf_insn_base fdef5 block5 (insn_cmd (insn_icmp id5 cond5 value1 value2)) ->
     wf_insn fdef5 block5 (insn_cmd (insn_icmp id5 cond5 value1 value2))
 | wf_insn_phi : forall (value_l_list:list_value_l) (fdef5:fdef) (block5:block) (id5:id),
     (wf_value_list (make_list_fdef_value (map_list_value_l (fun (value_:value) (l_:l) => (fdef5,value_)) value_l_list))) ->
     insnInFdefBlockB (insn_phinode (insn_phi id5 value_l_list)) fdef5 block5 = true  ->
     wf_phinode fdef5 block5 (insn_phi id5 value_l_list)  ->
     wf_insn fdef5 block5 (insn_phinode (insn_phi id5 value_l_list))
with wf_value_list : list_fdef_value -> Prop :=
 | Nil_wf_value_list : wf_value_list Nil_list_fdef_value
 | Cons_wf_value_list : forall (fdef5:fdef) (value_:value) (l':list_fdef_value),
      ((wf_value fdef5 value_)) -> wf_value_list l' ->
      wf_value_list (Cons_list_fdef_value fdef5 value_ l').
(** definitions *)

(* defns Jwf_cmds *)
Inductive wf_cmds : fdef -> block -> cmds -> Prop :=    (* defn wf_cmds *)
 | wf_cmds_nil : forall (fdef5:fdef) (block5:block),
     wf_cmds fdef5 block5  nil 
 | wf_cmds_cons : forall (fdef5:fdef) (block5:block) (cmd5:cmd) (cmds5:cmds),
     wf_insn fdef5 block5 (insn_cmd cmd5) ->
     wf_cmds fdef5 block5 cmds5 ->
     wf_cmds fdef5 block5  ( cmd5 :: cmds5 ) .
(** definitions *)

(* defns Jwf_phinodes *)
Inductive wf_phinodes : fdef -> block -> phinodes -> Prop :=    (* defn wf_phinodes *)
 | wf_phinodes_nil : forall (fdef5:fdef) (block5:block),
     wf_phinodes fdef5 block5  nil 
 | wf_phinodes_cons : forall (fdef5:fdef) (block5:block) (phinode5:phinode) (phinodes5:phinodes),
     wf_insn fdef5 block5 (insn_phinode phinode5) ->
     wf_phinodes fdef5 block5 phinodes5 ->
     wf_phinodes fdef5 block5  ( phinode5 :: phinodes5 ) .
(** definitions *)

(* defns Jwf_block *)
Inductive wf_block : fdef -> block -> Prop :=    (* defn wf_block *)
 | wf_block_intro : forall (fdef5:fdef) (l5:l) (phinodes5:phinodes) (cmds5:cmds) (terminator5:terminator),
      blockInFdefB   (block_intro l5 phinodes5 cmds5 terminator5)    fdef5  = true  ->
     wf_phinodes fdef5  (block_intro l5 phinodes5 cmds5 terminator5)  phinodes5 ->
     wf_cmds fdef5  (block_intro l5 phinodes5 cmds5 terminator5)  cmds5 ->
     wf_insn fdef5  (block_intro l5 phinodes5 cmds5 terminator5)  (insn_terminator terminator5) ->
     wf_block fdef5 (block_intro l5 phinodes5 cmds5 terminator5).
(** definitions *)

(* defns Jwf_blocks *)
Inductive wf_blocks : fdef -> blocks -> Prop :=    (* defn wf_blocks *)
 | wf_blocks_nil : forall (fdef5:fdef),
     wf_blocks fdef5  nil 
 | wf_blocks_cons : forall (fdef5:fdef) (block5:block) (blocks5:blocks),
     wf_block fdef5 block5 ->
     wf_blocks fdef5 blocks5 ->
     wf_blocks fdef5  ( block5 :: blocks5 ) .
(** definitions *)

(* defns Jwf_fdef *)
Inductive wf_fdef : fdef -> Prop :=    (* defn wf_fdef *)
 | wf_fdef_intro : forall (blocks5:blocks) (block5:block) (usedef_block5:usedef_block),
      getEntryBlock   (fdef_intro blocks5)   =   (Some  block5 )   ->
     genBlockUseDef_fdef (fdef_intro blocks5) = usedef_block5  ->
     hasNonePredecessor block5 usedef_block5 = true  ->
     wf_blocks (fdef_intro blocks5) blocks5 ->
      uniqFdef   (fdef_intro blocks5)   ->
     wf_fdef (fdef_intro blocks5).

End VMtypings.



(*
*** Local Variables: ***
*** coq-prog-name: "coqtop" ***
*** coq-prog-args: ("-emacs-U" "-I" "~/SVN/sol/vol/src/Vellvm/monads" "-I" "~/SVN/sol/vol/src/Vellvm/ott" "-I" "~/SVN/sol/vol/src/Vellvm/compcert" "-I" "~/SVN/sol/theory/metatheory_8.3") ***
*** End: ***
*)



