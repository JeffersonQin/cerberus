// C11.cat w/o locks, SC, consume, UR

let sb = po | I * (M \ I)
let mo = co

//let cacq = acq | (sc & (R | F)) | acq_rel | (F & con)
// no consume
let cacq = [ACQ | (SC & (R | F)) | ACQ_REL]

//let crel = rel | (sc & (W | F)) | acq_rel
let crel = [REL | (SC & (R | F)) | ACQ_REL]

//let ccon = R & con				   	   

//let fr = rf^-1 ; mo
let fr = rf_inv ; mo

//let dd = (data | addr)+

let fsb = [F] ; sb
let sbf = sb ; [F]

//(* release_acquire_fenced_synchronizes_with,
//   hypothetical_release_sequence_set,
//   release_sequence_set *)

//(* OLD: let rs = [crel] ; fsb? ; [A & W] ;
//	 (((mo ; [rmw]) | coi) & ~(coe ; [!rmw] ; mo))? *)

//let rs_prime = int(_ * _) | (_ * (R & W))
let rs_prime = int | (U * (R & W))
let rs = mo & (rs_prime \ ((mo \ rs_prime) ; mo))
		       
//(* OLD: let swra = ext (rs ; rf ; [A] ; sbf? ; [cacq]) *)
//let swra = ext ([crel] ; fsb? ; [A & W] ; rs? ; rf ; [R & A] ; sbf? ; [cacq])

//let swra = (crel ; fsb ? ; [A & W] ; rs ? ; rf ; [R & A] ; sbf ? ; cacq) & ext

let swra_head = crel ; fsb ? ; [A & W]
let swra_mid = [A & W] ; rs ? ; rf ; [R & A]
let swra_tail = [R & A] ; sbf ? ; cacq
let swra = (swra_head ; swra_mid ; swra_tail) & ext

//let swul = ext ([ul] ; lo ; [lk])
let pp_asw = asw \ (asw ; sb)
//let sw = pp_asw | swul | swra
let sw = pp_asw | swra

//(* with_consume_cad_set,
//   dependency_ordered_before *)
//let cad = ((rf & sb) | dd)+
//let dob = (ext ([W & crel] ; fsb? ; [A & W] ; rs?; rf; [ccon])); cad?

//(* happens_before,
//   inter_thread_happens_before,
//   consistent_hb *)
//let ithbr = sw | dob | (sw ; sb)
let ithbr = sw | (sw; sb)
let ithb_prime = (ithbr | (sb ; ithbr))
//let ithb = (ithbr | (sb ; ithbr))+
let ithb = ithb_prime+
let hb = sb | ithb
acyclic hb as hb_acyclic

//(* coherent_memory_use *)
let hbl = hb & loc

//irreflexive ((rf^-1)? ; mo ; rf? ; hb) as Coh

let coh_prime = rf_inv? ; mo ; rf ? ; hb
//irreflexive ((rf_inv)? ; mo ; rf? ; hb) as Coh
irreflexive coh_prime as coh_irreflexive

//(* visible_side_effect_set *)
//let vis = ([W] ; hbl ; [R]) & ~(hbl; [W]; hbl)

// TODO: is difference correct here
let vis = ([W] ; hbl ; [R]) \ (hbl; [W]; hbl)

//(* consistent_atomic_rf *) 
let rf_prime = rf ; hb
irreflexive rf_prime as rf_irreflexive
	      
//(* consistent_non_atomic_rf  *)
//empty ((rf ; [nonatomicloc]) \ vis) as NaRf

let narf_prime = (rf ; [NA]) \ vis
empty narf_prime as nrf_empty

let rmw_prime = rf | (mo ; mo ; rf_inv) | (mo ; rf)
irreflexive rmw_prime as rmw_irreflexive

//(* locks_only_consistent_lo *)
//irreflexive (lo ; hb) as Lo1

//(* locks_only_consistent_locks *)
//irreflexive ([ls] ; lo^-1 ; [ls] ;
//  ~(lo ; [ul] ; lo)) as Lo2

//(* data_races *)
//let cnf = ((W * _) | (_ * W)) & loc
let cnf = ((W * U) | (U * W)) & loc
let dr = ext & (((cnf \ hb) \ (hb^-1)) \ (A * A))

//(* unsequenced_races *)
//let ur = int((W * M) | (M * W)) &
//         loc & ~[_] & ~(sb+) & ~((sb+)^-1)

//(* locks_only_good_mutex_use,
//   locks_only_bad_mutexes *)
//let bl = ([ls]; (sb & lo); [lk])
//         & ~(lo; [ul]; lo)

//let losbwoul = (sb & lo & ~(lo; [ul]; lo))
//let lu = [ul] &
//  ~([ul] ; losbwoul^-1 ; [ls] ; losbwoul ; [ul])

//let Simm = S \ (mo ; S)

//irreflexive (S ; hb) as S1
//irreflexive (S ; fsb? ; mo ; sbf?) as S2
//irreflexive (S ; rf^-1; [sc] ; mo) as S3
//irreflexive (Simm ; rf^-1 ; hbl ; [W]) as S4
//irreflexive (S ; fsb ; fr) as S5
//irreflexive (S ; fr ; sbf) as S6
//irreflexive (S ; fsb ; fr ; sbf) as S7

undefined_unless empty dr as dr_ub
//undefined_unless empty ur as unsequencedRace
//undefined_unless empty bl as badLock
//undefined_unless empty lu as badUnlock
