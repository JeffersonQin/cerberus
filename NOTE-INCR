Problem: Find a sequencing construct in Core allowing the elaboration of C
         expressions involving postfix increments/decrements and assignments
         with a possible unsequenced context.

About Core: The language makes explicit distinction (by typing) between
            expressions making use of the memory (object creation/kill,
            read/write) and "pure" expressions. To combine expressions, Core
            provide (un)sequencing operators making explicit the partial
            ordering over memory actions performed by Core effectful expressions.
            This order correspond to "sequence-before" for the C standard.

About increnent/decrement: An expression E++ first perform its "value
  computation" by doing two things: computing the (modifiable) lvalue
  represented by E; and then loading the value of the corresponding
  object. Then "the side effect of updating the stored value of the
  operand" is performed.  This is the only ordering information the
  standard gives: "the value computation of the result" is
  sequenced-before "the side effect of the increment". Of course it
  doesn't say what the value computation of the "result" is, and how
  it depends on the one of the operand, so what has just been
  described is my interpretation.
  
  Additionally (but we don't really think about it for now) the standard says:
    "With respect to an indeterminately-sequenced function call, the
     operation of postfix ++ is a single evaluation"

About (simple) assigmnents:
  E1 = E2  
           This expression evaluates unsequenced E1 (which is an
           lvalue) and E2, and then stores the value of E2 in the
           object represented by E1. The value of this expression is
           the "value of the left operand after the assignment",
           hence the value of E2. The action of storing the value of
           E2 in the object represented by E1 is sequenced-after the
           VALUE COMPUTATION of E2.


So for example, in the expression:

  x = y ++;

there are three actions: a load on y sequenced-before a store on y
(the actions of the increment), and a store on x which is
sequenced-after the load on y but is unsequenced with the other store.

About the comma operator:
  E1 , E2 Here the left expression is evaluated before the right
  one. And there is a "sequence-point" between the two evaluation
  which makes all the side-effects AND the value computation of E1
  sequenced before the anything of E2. Here I guess that the value
  computation of the whole expression is only the value computation of
  E2, but because of the sequence point and transitivity of sb,
  anything after the value computation of E2 is after the value
  computation of E1.

So for example, in the expression:

  x = (y++, 0)

the store on y is sequenced before the store on x.

Kayvan remarks that Justus's previous semantics for the comma operator
would have made constant propagation unsound, eg optimising z=0;
x=(x++,z) (which is ok) to z=0;x=(x++,0) (which has an unsequenced
race in Justus's semantics).  Kayvan thinks that evaluating 0 to 0
*is* a value computation, which gives the sequence point something to
work on.

NOTE: this may be annoying somewhere, because now the ordering of two
      actions can depend on something which is a pure expression in
      Core (0). And I wanted to ignoring them when thinking about the
      ordering operators. In the previous example however it doesn't
      pose a problem.


----------------------------------------------------------------------------------------------------
CURRENT ATTEMPT (WHICH KAYVAN THINKS WORKS) AT A SMALL-STEP SEM FOR "miniCore"

VALUES:
  the base constructors of the "pure stuff" constitute the "values" syntactic subset.

NOTATION: a, b, ...    are positive actions
          ~a, ~b, ...  are negative actions
          x, y, z      are pos/neg actions
          v            is a value

Actions = {create, kill, load, store}
x, y ∈ {P,N} x Actions 

Actions are labelled "positive" (P) or "negative" (N), depending on
whether they are the elaboration of a C action that should always be
ordered by a sequencing operator or not.  Hopefully negative actions
should just be the side effects of increment and assign (so so far we
only plan to use them for stores - but some stores can be positive,
e.g. a store in the right argument of a comma operator).  The dynamics
will sometimes transform negative actions into positive ones, to
record that they have been ordered.  (Though this is debatable, as it
implicitly assumes that an unsequenced couple of things end up
sequenced one way or the other in any well-defined execution - we're
not sure about whether this is safe to assume. Kayvan is annoyed
because it looks like it is but he's not sure.)

A,B ::=
 ( ... pure stuff ... )

 | skip

 | x                         positive/negative actions

 | A || B                    Unsequenced (NOTE: for readability here the operator is binary, while
                             is n-ary for real)

? | leteffweak (α1, ..., αk) = A in
 | (α1, ..., αk) ← A ; B     Weak sequenced-before: only the positive actions of A are
                             sequenced-before the actions of B. The
                             negative actions of A are unsequenced wrt
                             the actions of B. The value of the
                             expression is the value of B.

? better concrete syntax?
 | α ← a ▷ x                 Atomic sequencing: a is sequence-before before x such that the two
                             cannot be separated by a function call. The value of the expression is
                             the value of a.
 
(It's irritating that we have such baroque machinery just to cope with
increment and decrement.  This is in reasonable proximity to the
standard text, but maybe we could prove that there's an equivalent
semantics with just one action for an inc or dec?)

?? leteffstrong (α1, ..., αk) = A in B 
 | (α1, ..., αk) ← A ♦ B     sequence-point: all actions of A are sequenced-before anything in B.


For the small-step semantics we define a relation of type

  (state, core_expr) * [action] * (state, core_expr)

(Maybe it would be handy to keep enough info in the trace to calculate
an axiomatic-memory-model candidate execution?)


Memory actions (positive or negative) simply reduce to their values
and (except for load) may change the memory state:

  (s',obj) = mem_create s (...)
--------------------------------- (create)
(s, create) --create--> (s', obj)

     s' = mem_kill s (...)
-------------------------------- (kill)
(s, kill) --kill--> (s', skip)

   v = mem_load s (...)
-------------------------- (load)
(s, load) --load--> (s, v)

    s' = mem_store s (...)
-------------------------------- (store)
(s, store) --store--> (s', skip)


A positive action simply reduces according the previous rules:

 one of the rule above
----------------------- (positive)
 (s, a) --a--> (s', v)


But for a negative action, the value is discarded (this has some obvious implication on their
typing). This is motivated by the reduction rule for negative actions as the first operand of a
sequencing operator. This should be valid since negative actions correspond to the Core elaboration
of parts of a value computation (in C) so its result shouldn't be use by any other action/expression
in the Core elaboration. (TODO: I need to do the "proof")

--------------------- (negative)
(s, ~a) --ε--> (s, a)


The unsequencing-operator reductions give it an interleaving semantics, which is a bit disturbing
because this implies that operationaly unseq = indeterminately-seq. Which may be ok since I can't
find a well-defined example showing otherwise.

     (s, A) --xs--> (s', A')
--------------------------------- (lunseq)
(s, A || B) --xs--> (s', A' || B)

     (s, B) --xs--> (s', B')
--------------------------------- (runseq)
(s, A || B) --xs--> (s', A || B')


When an unseq expression is fully reduced to a value and it is the first operand of sequencing
operator, we simply do some substitution (NOTE: the symbolic names are all different and can't be
use "recursively", as we are not dealing with symbolic names for functions here, so there are no
subtility regarding the substitutions.

-------------------------------------------------------------- (value_unseq_wseq)
(s, (α1, α2) ← (v1 || v2) ; A) --ε--> (s, A[α1 \ v1, α2 \ v2])

-------------------------------------------------------------- (value_unseq_sp)
(s, (α1, α2) ← (v1 || v2) ♦ A) --ε--> (s, A[α1 \ v1, α2 \ v2])


Same thing for a single value (BS: with the n-ary version of unseq, the previous rules alreqdy take
care of that ...):

----------------------------------- (value_wseq)
(s, α ← v ; A) --ε--> (s', A[α \ v])

----------------------------------- (value_sp)
(s, α ← v ♦ A) --ε--> (s', A[α \ v])


The rule of atomic sequencing operator looks morally wrong but I am not sure what else I can do:

         (s, a) --a--> (s', v)
--------------------------------------- (aseq)
(s, α ← a ▷ y) --a--> (s', y[α \ v]; v)


The positive actions are sequenced by the weak sequencing operator and
this is already dealt with by the previous rules: we first need to
reduce them to a value before being able to reduce a wseq. But
negative actions are not sequenced, hence we can permute them with the
wseq operator (NOTE: this obviously doesn't mean a negative action
cannot be reduced before a succeding wseq operator ...): (NOTE there
is a hack here: I assume that symbolic names of type unit cannot be
used by a Core expression, hence the _) (NOTE: observe that the action
remains negative because we need transitivity of negativeness, e.g. in
x=y=z++ the store of z should be unseq wrt the store of x):

----------------------------------- (neg_wseq)
(s, _ ← ~a; A) --ε--> (s', ~a || A)


In contrast, a sequence point forces an ordering on all actions. So
we add rules for negative actions which make them positive (BS: would
need only one with the n-ary unseq ...):

---------------------------------- (neg_sp)
(s, _ ← ~a ♦ A) --ε--> (s', a ♦ A)

------------------------------------------------ (neg_lunseq_sp)
(s, _ ← (~a || A) ♦ B) --ε--> (s', (a || A) ♦ B)

    (),alpha  <- 

------------------------------------------------ (neg_runseq_sp)
(s, _ ← (A || ~a) ♦ B) --ε--> (s', (A || a) ♦ B)



----------------------------------------------------------------------------------------------------
CONJECTURE (FALSE):
  If an action is sequence-after the value computation of a lvalue expression, then it is not
  unsequenced with any action of that expression (ie. if they are side-effects in the expression,
  they must be sequenced-before by transitivity via the value computation).
NON-PROOF
  Can't really do anything better than a proof "by absence of conter-example" since the standard
  defines what is/isn't a lvalue everywhere in the text and does seem to miss some cases.
  
  Here is one of the miss cases (except if you read the K&R ...) which is however dealt
  consistantly by the compilers:
  
    (x++)++
  
  it is ill-typed occording to the compilers (gcc, clang) because the inner x++ is not a lvalue
  while the operand of a post incr/decr must be a modifiable lvalue. If that was well-typed, then
  the conjecture would be false, because the store of the inner incr would be unsequenced with
  the one of the outer incr (leading to a race).
  
  CHANGE: ahem, it's not missed the sentence "See the discussions of additive operators and 
          compound assignment for information on constraints, types, and conversions and the
          effects of operations on pointers." implies the result of a post incr/decr is not a
          lvalue because the result of += / -= are not.
  
  CHANGE2: as remarked by Mark, this is not true for lvalue of pointer type (occording to the
           compilers anyway). This means that there is a mistake in the Ott definitions of Ail's
           type system.



int x = 0, y = 1;
int z = 0;

void f() {
  z = 1;
}

int main(void) {
  (x = y++) + f() + (z ? x : x++);
  return 0;
}








RANDOM REMARK
  The expressions:
  
    x = x = x;  (1)
  
  is undefined, while the following is not (assuming x and y are distinct memory objects):
  
    x = y = x;  (2)
  
  The store performed by an assignment is not part of its value computation (this is sort of a
  guess, the standard doesn't explain anything about value computations. NOTE: kcc seems to use the
  same interpretation), and it is sequenced after the value computations of right operand of the
  assign.
  Hence in the two previous expressions, the only load on x is sequence-before the store of the
  inner assignment (on x in (1) and on y in (2))
----------------------------------------------------------------------------------------------------

EXAMPLES OF UNDEFINED EXPRESSIONS

  x + (x = 0);    racing load/store pair
  x = x = 0;      



  *(p + (y = 0)) = 1




