Problem: Find a sequencing construct in Core allowing the elaboration of C
         expressions involving postfix increments/decrements and assignments
         with a possible unsequenced context.

About Core: The language makes explicit distinction (by typing) between
            expressions making use of the memory (object creation/kill,
            read/write) and "pure" expressions. To combine expressions, Core
            provide (un)sequencing operators making explicit the partial
            ordering over memory actions performed by Core effectful expressions.
            This order correspond to "sequence-before" for the C standard.

About increnent/decrement:
  An expression E++ first perform its "value computation" by doing two things: computing the
  (modifiable) lvalue represented by E; loading the value of the corresponding object. Then
  "the side effect of updating the stored value of the operand" is performed.
  This is the only ordering information the standard gives: "the value computation of the result"
  is sequenced-before  "the side effect of the increment". Of course it doesn't say what the value
  computation of the "result" given the one of the operand, so what has just been described is my
  interpretation.
  
  Additionally (but we don't really think about it for now) the standard says:
    "With respect to an indeterminately-sequenced function call, the operation of postfix ++ is a
     single evaluation"

About (simple) assigmnents:
  E1 = E2  This expression evaluates unsequenced E1 (which is an lvalue) and E2, and then store the
           value of E2 in the object represented by E1. The value of this expression is the "the
           value of the left operand after the assignment", hence the value of E2. The action of
           storing the value of E2 in the object represented by E1 is sequenced-after the
           VALUE COMPUTATION of E2.


So for example, in the expression:

  x = y ++;

There are three actions: a load on y sequenced-before a store on y (the actions of the increment),
and a store on x which sequenced-after the load on y but is unsequenced with the other store.

About the comma operator:
  E1 , E2  Here the left expression is evaluated before the right one. And there is a
  "sequence-point" between the two evaluation which makes all the side-effects AND value
  computation of E1 sequenced before the anything of E2. Here I guess that the value computation
  the whole expression are only the value computation of E2, but because of the sequenced-point and
  transitivity of sb, anything after the value computation of E2 is after the value computation of
  E1.

So for example, in the expression:

  x = (y++, 0)

The store on y is sequenced before the store on x.


NOTE: this may be annoying somewhere, because now the ordering of two actions can depend on something
      which is a pure expression in Core (0). And I wanted to ignoring them when thinking about the
      ordering operators. In the previous example however it doesn't pose a problem.


----------------------------------------------------------------------------------------------------
CURRENT ATTEMPT TO A SMALL-STEP SEM FOR "miniCore"

x, y ∈ {P,N} x Actions (create, kill, load, store)

A,B ::=
 ( ... pure stuff ... )

 | skip

 | x                         positive/negative actions;

 | A || B                    Unsequenced (NOTE: for readability here the operator is binary, while
                             is n-ary for real);

 | (α1, ..., αk) ← A ; B     Weak sequenced-before: only the positive actions of A are
                             sequenced-before the actions of B. The value of the expression is the
                             value of B;

 | α ← a ▷ x                 Atomic sequencing: a is sequence-before before x such that the two
                             cannot be separated by a function call. The value of the expression is
                             the value of a;
 
 | (α1, ..., αk) ← A ♦ B     sequence-point: all actions of A are sequenced-before anything in B.

VALUES:
  the base constructors of the "pure stuff" constitute the "values" syntaxic subset.

NOTATION: a, b, ...    are positive actions
          ~a, ~b, ...  are negative actions
          x, y, z      are pos/neg actions
          v            is a value

For the small-step semantics we extand Core syntax with values and define a function of type:
  (state, core_expr) -> [action] -> (state, core_expr)

Memory actions (positive or negative) simply reduces to there value and may change the memory state
(all except load):

  (s',obj) = mem_create s (...)
--------------------------------- (create)
(s, create) --create--> (s', obj)

     s' = mem_kill s (...)
-------------------------------- (kill)
(s, kill) --kill--> (s', skip)

   v = mem_load s (...)
-------------------------- (load)
(s, load) --load--> (s, v)

    s' = mem_store s (...)
-------------------------------- (store)
(s, store) --store--> (s', skip)


A positive action simply reduce according the previous rules:

 one of the rule above
----------------------- (positive)
 (s, a) --a--> (s', v)


But for a negative action, the value is discarded (this has some obvious implication on their
typing). This is motivated by the reduction rule for negative actions as the first operand of a
sequencing operator. This should be valid since negative actions correspond to the Core elaboration
of parts of a value computation (in C) so its result shouldn't be use by any other action/expression
in the Core elaboration. (TODO: I need to do the "proof")

--------------------- (negative)
(s, ~a) --ε--> (s, a)


The unsequencing-operator reductions give it an interleaving semantics, which is a bit disturbing
because this implies that operationaly unseq = indeterminately-seq. Which may be ok since I can't
find a well-defined example showing otherwise.

     (s, A) --xs--> (s', A')
--------------------------------- (lunseq)
(s, A || B) --xs--> (s', A' || B)

     (s, B) --xs--> (s', B')
--------------------------------- (runseq)
(s, A || B) --xs--> (s', A || B')


When an unseq expression is fully reduced to a value and it is the first operand of sequencing
operator, we simply do some substitution (NOTE: the symbolic names are all different and can't be
use "recursively", as we are not dealing with symbolic names for functions here, so there are no
subtility regarding the substitutions.

-------------------------------------------------------------- (value_unseq_wseq)
(s, (α1, α2) ← (v1 || v2) ; A) --ε--> (s, A[α1 \ v1, α2 \ v2])

-------------------------------------------------------------- (value_unseq_sp)
(s, (α1, α2) ← (v1 || v2) ♦ A) --ε--> (s, A[α1 \ v1, α2 \ v2])


Same thing for a single value (BS: with the n-ary version of unseq, the previous rules alreqdy take
care of that ...):

----------------------------------- (value_wseq)
(s, α ← v ; A) --ε--> (s', A[α \ v])

----------------------------------- (value_sp)
(s, α ← v ♦ A) --ε--> (s', A[α \ v])


The rule of atomic sequencing operator looks morally wrong but I am not sure what else I can do:

         (s, a) --a--> (s', v)
--------------------------------------- (aseq)
(s, α ← a ▷ y) --x--> (s', y[α \ v]; v)


The positive actions are sequenced by the weak sequencing operator and this is already deal with by the
previous rules: we first need to reduce them to a value before being able to reduce a wseq. But
negative actions are not sequenced, hence we can permute them with the wseq operator (NOTE: this
obviously doesn't mean a negative action cannot be reduced before a succeding wseq operator ...):
(NOTE there is a hack here: I assume that symbolic names of type unit cannot be used by a Core
expression, hence the _) (NOTE: observe that the action remains negative):

----------------------------------- (neg_wseq)
(s, _ ← ~a; A) --ε--> (s', ~a || A)


On the contrary, a sequence-point force a ordering on all actions. So we add rules for negative
actions which make them positive (BS: would need only one with the n-ary unseq ...):

---------------------------------- (neg_sp)
(s, _ ← ~a ♦ A) --ε--> (s', a ♦ A)

------------------------------------------------ (neg_lunseq_sp)
(s, _ ← (~a || A) ♦ B) --ε--> (s', (a || A) ♦ B)

------------------------------------------------ (neg_runseq_sp)
(s, _ ← (A || ~a) ♦ B) --ε--> (s', (A || a) ♦ B)



----------------------------------------------------------------------------------------------------
CONJECTURE (FALSE):
  If an action is sequence-after the value computation of a lvalue expression, then it is not
  unsequenced with any action of that expression (ie. if they are side-effects in the expression,
  they must be sequenced-before by transitivity via the value computation).
NON-PROOF
  Can't really do anything better than a proof "by absence of conter-example" since the standard
  defines what is/isn't a lvalue everywhere in the text and does seem to miss some cases.
  
  Here is one of the miss cases (except if you read the K&R ...) which is however dealt
  consistantly by the compilers:
  
    (x++)++
  
  it is ill-typed occording to the compilers (gcc, clang) because the inner x++ is not a lvalue
  while the operand of a post incr/decr must be a modifiable lvalue. If that was well-typed, then
  the conjecture would be false, because the store of the inner incr would be unsequenced with
  the one of the outer incr (leading to a race).
  
  CHANGE: ahem, it's not missed the sentence "See the discussions of additive operators and 
          compound assignment for information on constraints, types, and conversions and the
          effects of operations on pointers." implies the result of a post incr/decr is not a
          lvalue because the result of += / -= are not.
  
  CHANGE2: as remarked by Mark, this is not true for lvalue of pointer type (occording to the
           compilers anyway). This means that there is a mistake in the Ott definitions of Ail's
           type system.



int x = 0, y = 1;
int z = 0;

void f() {
  z = 1;
}

int main(void) {
  (x = y++) + f() + (z ? x : x++);
  return 0;
}








RANDOM REMARK
  The expressions:
  
    x = x = x;  (1)
  
  is undefined, while the following is not (assuming x and y are distinct memory objects):
  
    x = y = x;  (2)
  
  The store performed by an assignment is not part of its value computation (this is sort of a
  guess, the standard doesn't explain anything about value computations. NOTE: kcc seems to use the
  same interpretation), and it is sequenced after the value computations of right operand of the
  assign.
  Hence in the two previous expressions, the only load on x is sequence-before the store of the
  inner assignment (on x in (1) and on y in (2))
----------------------------------------------------------------------------------------------------

EXAMPLES OF UNDEFINED EXPRESSIONS

  x + (x = 0);    racing load/store pair
  x = x = 0;      



  *(p + (y = 0)) = 1




