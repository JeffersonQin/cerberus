open Global

type ('a, 's, 'msg) t = 's -> ('a * 's, 'msg) Exception.t

let unit a = fun s -> Exception.unit (a, s)
let map f m =
  fun s -> Exception.bind (m s) (fun (a, s') -> Exception.unit (f a, s'))
let join mm = fun s -> Exception.bind (mm s) (fun (m, s') -> m s')
let bind m f = join (map f m)
let app  mf m = bind mf (fun f -> map f m)
let papp mf x = bind mf (fun f -> unit (f x))

let fail msg = fun _ -> Exception.fail msg
let update f = fun s -> Exception.unit ((), f s)
let modify f = fun s -> Exception.unit (f s)
let read   f = fun s -> Exception.unit (f s, s)

let run m s = m s

module Operators = struct
  let (>>=) = bind
  let (<$>) = map
  let (<*>) = app
end

let of_option msg = function
  | Some a -> unit a
  | None   -> fail msg
end

let option msg m =
  let f o =
    match o with
      | Some a -> unit a
      | None   -> fail msg
    end in
  bind m f

open Operators

let app2 mf mx my = mf <*> mx <*> my
let app3 mf mx my mz = (app2 mf mx my) <*> mz
let map2 f mx my = f <$> mx <*> my
let map3 f mx my mz = (map2 f mx my) <*> mz

let sequence ms =
  List.fold_right
    (fun m m' ->
      m  >>= fun x  ->
      m' >>= fun xs ->
      unit (x::xs)
    ) ms (unit [])

let t_list t xs = sequence (t xs)

let map_list f = t_list (List.map f)

let rec foldr_list f l a =
  match l with
    | [] -> unit a
    | x::xs -> f x a >>= fun a' -> foldr_list f xs a'
  end

let iter f l = foldr_list (fun a () -> f a) l ()
