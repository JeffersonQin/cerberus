open Ail

let lift_int f_int otherwise = function
  | BASE _ (INTEGER i) -> f_int i
  | _ -> otherwise
  end

let is_unsigned_int = function
  | BOOL       -> true
  | UNSIGNED _ -> true
  | SIGNED   _ -> false
  end

let is_signed_int = function
  | SIGNED   _ -> true
  | UNSIGNED _ -> false
  | BOOL       -> false
  end

let is_unsigned_integer = lift_int is_unsigned_int false
let is_signed_integer   = lift_int is_signed_int   false

let is_char = function
  | BASE _ CHAR -> true
  | _           -> false
  end

let is_void = function
  | BASE _ VOID -> true
  | _           -> false
  end

let is_character = function
  | BASE _ (INTEGER (UNSIGNED ICHAR)) -> true
  | BASE _ (INTEGER (SIGNED   ICHAR)) -> true
  | BASE _ CHAR -> true
  | _ -> false
  end

(* TODO No support for floating point, enumerated, structure, union or atomic
   types. *)
let is_real_floating t = false
let is_complex t = false
let is_floating t = is_real_floating t || is_complex t
let is_enumerated t = false

let is_basic t =
  is_char t
  || is_unsigned_integer t
  || is_signed_integer t
  || is_floating t

let is_integer t =
  is_char t
  || is_signed_integer t
  || is_unsigned_integer t
  || is_enumerated t

let is_real t = is_integer t || is_real_floating t
let is_arithmetic t = is_integer t || is_floating t

let is_structure t = false
let is_union t = false
let is_enum t = false
let is_atomic t = false

let is_pointer = function
  | POINTER _ _ -> true
  | _ -> false
  end

let is_function = function
  | FUNCTION _ _ -> true
  | _ -> false
  end

let is_array = function
  | ARRAY _ _ -> true
  | _ -> false
  end

let is_derived t =
  is_array t
  || is_structure t
  || is_union t
  || is_function t
  || is_pointer t
  || is_atomic t

let is_scalar t = is_arithmetic t || is_pointer t

let is_aggregate t = is_array t || is_structure t

let is_unqualified = function
  | BASE    q _ -> q = {}
  | POINTER q _ -> q = {}
  | _ -> true
  end

let is_object = function
  | FUNCTION _ _ -> false
  | _ -> true
  end

let is_complete_object t =
  match t with
  | BASE _ VOID -> false
  | _           -> is_object t
  end

let is_pointer_to_object = function
  | POINTER _ t -> is_object t
  | _ -> false
  end

let is_pointer_to_void = function
  | POINTER _ t -> is_void t
  | _ -> false
  end

let is_pointer_to_function = function
  | POINTER _ t -> is_function t
  | _ -> false
  end

let is_pointer_to_complete_object = function
  | POINTER _ t -> is_complete_object t
  | _ -> false 
  end

let compatible_basic s1 s2 = (s1 = s2)

let rec compatible type1 type2 =
  match (type1, type2) with
  | (BASE q1 s1, BASE q2 s2) ->
      compatible_basic s1 s2 && Set.equal q1 q2
  | (POINTER q1 t1, POINTER q2 t2) ->
      compatible t1 t2 && Set.equal q1 q2
  | (ARRAY t1 size1, ARRAY t2 size2) ->
      size1 = size2 && compatible t1 t2
  | (FUNCTION t1 args1, FUNCTION t2 args2) ->
      compatible t1 t2
      && List.length args1 = List.length args2
      && List.for_all2 compatible args1 args2
  | _ -> false
  end

let unqualify t =
  match t with
  | BASE _ b -> BASE {} b
  | POINTER _ t' -> POINTER {} t'
  | _ -> t
  end

let compatible_unqualified type1 type2 =
  compatible (unqualify type1) (unqualify type2)

let qualifiers = function
  | POINTER q _ -> q
  | BASE    q _ -> q
  | FUNCTION _ _ -> {}
  | ARRAY    _ _ -> {}
  end

let merge_qualifiers t1 t2 = (qualifiers t1) union (qualifiers t2)

let include_qualifiers t q =
  match t with
  | BASE q' b' -> BASE (q union q') b'
  | POINTER q' t' -> POINTER (q union q') t'
  | FUNCTION _ _ -> t
  | ARRAY    _ _ -> t
  end

let rec eq t1 t2 =
  match (t1, t2) with
  | (BASE _ b1, BASE _ b2) -> b1 = b2
  | (POINTER _ t1, POINTER _ t2) -> eq t1 t2
  | (FUNCTION t1 ts1, FUNCTION t2 ts2) ->
      eq t1 t2 && List.for_all2 eq ts1 ts2
  | (ARRAY t1 size1, ARRAY t2 size2) ->
      size1 = size2 && eq t1 t2
  | _ -> false
  end

let eq_rank i1 i2 =
  i1 = i2 || match (i1, i2) with
  | (SIGNED   b1, UNSIGNED b2) -> b1 = b2
  | (UNSIGNED b1, SIGNED   b2) -> b1 = b2
  | _ -> false
  end

let rec leq_rank i1 i2 = (eq_rank i1 i2 || lt_rank i1 i2)

(* We exploit the "linear" transitivity to avoid listing all pairs/building the
   transitive closure. *)
and lt_rank i1 i2 =
  let leq = leq_rank i1 in
  match i2 with
  | BOOL             -> false
  | SIGNED ICHAR     -> leq BOOL
  | SIGNED SHORT     -> leq (SIGNED ICHAR)
  | SIGNED INT       -> leq (SIGNED SHORT)
  | SIGNED LONG      -> leq (SIGNED INT)
  | SIGNED LONG_LONG -> leq (SIGNED LONG)
  (* Corresponding signed and unsigned integers have the same rank. *)
  | UNSIGNED b         -> lt_rank i1 (SIGNED b)
  end

let leq_prec i1 i2 =
  match (i1, i2) with
  | (BOOL, _) -> true
  | (_, BOOL) -> false
  | (SIGNED   _,  SIGNED   _) -> leq_rank i1 i2
  | (UNSIGNED _,  UNSIGNED _) -> leq_rank i1 i2
  | (SIGNED   _,  UNSIGNED _) ->
      if leq_rank i1 i2 then
        true
      else
        (* TODO Implementation defined! *)
        false
  end

let rec common_int i1 i2 =
  if i1 = i2 then i1 else
    match (i1, i2) with
    | (BOOL, _) -> i2
    | (_, BOOL) -> i1
    | (SIGNED   _, SIGNED   _) ->
        if lt_rank i1 i2 then i2 else i1
    | (UNSIGNED _, UNSIGNED _) ->
        if lt_rank i1 i2 then i2 else i1
    | (SIGNED b1, UNSIGNED _) ->
        if leq_rank i1 i2 then
          i2
        else if leq_prec i2 i1 then
          i1
        else
          UNSIGNED b1
    | _ -> common_int i2 i1
    end

let rec common t1 t2 =
  match (t1, t2) with
  | (BASE _ (INTEGER i1), BASE _ (INTEGER i2)) ->
      BASE {} (INTEGER (common_int i1 i2))
  end

let promote_int i =
  let s_int = SIGNED   INT in
  let u_int = UNSIGNED INT in
  let promoted =
    if leq_rank i s_int then (
      if leq_prec i s_int then s_int else u_int
    ) else i in
  match i with
  | SIGNED   INT -> i
  | UNSIGNED INT -> i
  (* "Other than unsigned int or signed int." *)
  | BOOL       -> promoted
  | SIGNED   _ -> promoted
  | UNSIGNED _ -> promoted
  end

let promote t =
  match t with
  | BASE q (INTEGER i) -> BASE q (INTEGER (promote_int i))
  | _ -> t
  end

let usual_arithmetic t1 t2 = common (promote t1) (promote t2)

let is_complete t =
  match t with
  | BASE     _ _ -> is_complete_object t
  | POINTER  _ _ -> is_complete_object t
  | ARRAY    _ _ -> true
  | FUNCTION _ _ -> false
  end

let is_incomplete t = not (is_complete t)

let is_const = function
  | BASE     q _ -> Cabs.CONST IN q
  | POINTER  q _ -> Cabs.CONST IN q
  | ARRAY    _ _ -> false
  | FUNCTION _ _ -> false
  end

let is_modifiable t =
  not (is_array t)
  && not (is_incomplete t)
  && not (is_const t)

let is_bool = function
  | BASE _ (INTEGER BOOL) -> true
  | _ -> false
  end

let base_of_pointer = function
  | POINTER _ t -> t
  end

let base_of_array = function
  | ARRAY t _ -> t
  end

let size_of_array = function
  | ARRAY _ s -> s
  end

let function_return = function
  | FUNCTION t _ -> t
  end

let function_parameters = function
  | FUNCTION _ ts -> ts
  end

let well_formed t = true

let composite t1 t2 = if compatible t1 t2 then Some t1 else None

let pointer_convert t =
  match t with
  | FUNCTION _  _ -> POINTER {} t
  | ARRAY    t' _ -> POINTER {} t'
  | _ -> t
  end

let lvalue_convert t =
  if is_incomplete t && not (is_array t) then None else Some (unqualify t)

let lvalue_convert' = unqualify

let is_lvalue = function
  | T_LVALUE _ -> true
  | T_EXP    _ -> false
  end

let is_unsigned_of t1 t2 =
  match (t1, t2) with
  | (BASE _ (INTEGER (SIGNED i1)), BASE _ (INTEGER (UNSIGNED i2))) -> i1 = i2
  | _ -> false
  end

let is_signed_of t1 t2 =
  match (t1, t2) with
  | (BASE _ (INTEGER (UNSIGNED i1)), BASE _ (INTEGER (SIGNED i2))) -> i1 = i2
  | _ -> false
  end
