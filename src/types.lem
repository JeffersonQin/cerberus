open Ail
open Ail_aux (* lift_int *)

(* *************************************************************************
   * Predicates over types, corresponding to the name conventions and type *
   * correspondences defined in 6.2.5.                                     *
   *************************************************************************

   [signed integer types] 6.2.5#4
   
   "(...) The standard (...) integer types are collectively called signed
    integer types."
*)
let is_signed_int = function
  | SIGNED   _ -> true
  | UNSIGNED _ -> false
  | BOOL       -> false
  end

(* [unsigned integer types] 6.2.5#6
   
   "The type *_Bool* and the unsigned integer types that correspond to the
    standard signed integer types are the `standard unsigned integer types`.
    (...) The standard (...) integer types are collectively called
    `unsigned integer types`"
   
   NOT_SUPPORTED: extended unsigned integer types
*)
let is_unsigned_int = function
  | BOOL       -> true
  | UNSIGNED _ -> true
  | SIGNED   _ -> false
  end

let is_signed_integer   = lift_int is_signed_int   false
let is_unsigned_integer = lift_int is_unsigned_int false


(* [real floating types] (6.2.5#10)
   
   "(...)"
   
   NOT_SUPPORTED
*)
let is_real_floating t = false


(* [complex types, floating types] (6.2.5#11)
   
   "(...) The real floating and complex types are collectively called the
    `floating types`."
   
   NOT_SUPPORTED
*)
let is_complex t = false
let is_floating t = is_real_floating t || is_complex t


(* (basic types) (6.2.5#14)
   
   "The type *char*, the signed and unsigned integer types, and the floating
    types are collectively called the `basic types`."
*)
let is_basic = function
  | BASIC _ CHAR -> true
  | t            -> is_unsigned_integer t || is_signed_integer t ||
                    is_floating t
  end


(* [character types] (6.2.5#15)
   
   "The three types *char*, *signed char*, and *unsigned char* are collectively
    called the `character types`. (...)"
*)
let is_character = function
  | BASIC _ CHAR                       -> true
  | BASIC _ (INTEGER (SIGNED   ICHAR)) -> true
  | BASIC _ (INTEGER (UNSIGNED ICHAR)) -> true
  | _                                  -> false
  end


(* [enumerated types] (6.2.5#16)
   
   "(...)"
   
   TODO
*)
let is_enumerated t = false


(* [integer types, real types] (6.2.5#17)
   
   "The type *char*, the signed and unsigned integer types, and the enumerated
    types are collectively called `integer types`. The integer and real floating
    types are collectively called `real types`."
*)
let is_integer = function
  | BASIC _ CHAR -> true
  | t            -> is_signed_integer t || is_unsigned_integer t ||
                    is_enumerated t
  end
let is_real t = is_integer t || is_real_floating t


(* [arithmetic types] (6.2.5#18)
   
   "Integer and floating types are collectively called `arithmetic types`.
    (...)"
*)
let is_arithmetic t = is_integer t || is_floating t


(* TODO: would be nice to get rid of this *)
let is_void = function
  | VOID _ -> true
  | _      -> false
  end










(* TODO *)
let is_structure t = false
let is_union t = false
let is_enum t = false
let is_atomic t = false

let is_pointer = function
  | POINTER _ _ -> true
  | _           -> false
  end

let is_function = function
  | FUNCTION _ _ -> true
  | _            -> false
  end

let is_array = function
  | ARRAY _ _ -> true
  | _         -> false
  end

let is_derived t =
  is_array t
  || is_structure t
  || is_union t
  || is_function t
  || is_pointer t
  || is_atomic t

let is_scalar t = is_arithmetic t || is_pointer t

let is_aggregate t = is_array t || is_structure t

let is_unqualified = function
  | BASIC    q _ -> q = {}
  | POINTER  q _ -> q = {}
  | _            -> true
  end

let is_object = function
  | FUNCTION _ _ -> false
  | _            -> true
  end

let is_complete_object t =
  match t with
  | VOID _ -> false
  | _      -> is_object t
  end

let is_pointer_to_object = function
  | POINTER _ t -> is_object t
  | _           -> false
  end

let is_pointer_to_void = function
  | POINTER _ t -> is_void t
  | _           -> false
  end

let is_pointer_to_function = function
  | POINTER _ t -> is_function t
  | _           -> false
  end

let is_pointer_to_complete_object = function
  | POINTER _ t -> is_complete_object t
  | _           -> false 
  end

let compatible_basic s1 s2 = (s1 = s2)

let rec compatible type1 type2 =
  match (type1, type2) with
  | (BASIC q1 s1, BASIC q2 s2) ->
      compatible_basic s1 s2 && Set.equal q1 q2
  | (POINTER q1 t1, POINTER q2 t2) ->
      compatible t1 t2 && Set.equal q1 q2
  | (ARRAY t1 size1, ARRAY t2 size2) ->
      size1 = size2 && compatible t1 t2
  | (FUNCTION t1 args1, FUNCTION t2 args2) ->
      compatible t1 t2
      && List.length args1 = List.length args2
      && List.for_all2 compatible args1 args2
  | _ -> false
  end

let qualifiers = function
  | POINTER  q _ -> q
  | BASIC    q _ -> q
  | FUNCTION _ _ -> {}
  | ARRAY    _ _ -> {}
  end

let merge_qualifiers t1 t2 = (qualifiers t1) union (qualifiers t2)

let include_qualifiers t q =
  match t with
  | BASIC    q' b' -> BASIC (q union q') b'
  | POINTER  q' t' -> POINTER (q union q') t'
  | FUNCTION _  _  -> t
  | ARRAY    _  _  -> t
  end

let rec unqualify t =
  let f = unqualify in
  match t with
  | BASIC   _ b  -> BASIC {} b
  | POINTER _ t' -> POINTER {} (f t')
  | _            -> Ail_rewrite.map_type f t
  end

let rec eq t1 t2 =
  match (t1, t2) with
  | (BASIC _ b1, BASIC _ b2) -> b1 = b2
  | (POINTER _ t1, POINTER _ t2) -> eq t1 t2
  | (FUNCTION t1 ts1, FUNCTION t2 ts2) ->
      eq t1 t2 && List.for_all2 eq ts1 ts2
  | (ARRAY t1 size1, ARRAY t2 size2) ->
      size1 = size2 && eq t1 t2
  | _ -> false
  end

let eq_rank i1 i2 =
  i1 = i2 || match (i1, i2) with
  | (SIGNED   b1, UNSIGNED b2) -> b1 = b2
  | (UNSIGNED b1, SIGNED   b2) -> b1 = b2
  | _ -> false
  end

let rec leq_rank i1 i2 = (eq_rank i1 i2 || lt_rank i1 i2)

(* We exploit the "linear" transitivity to avoid listing all pairs/building the
   transitive closure. *)
and lt_rank i1 i2 =
  let leq = leq_rank i1 in
  match i2 with
  | BOOL             -> false
  | SIGNED ICHAR     -> leq BOOL
  | SIGNED SHORT     -> leq (SIGNED ICHAR)
  | SIGNED INT       -> leq (SIGNED SHORT)
  | SIGNED LONG      -> leq (SIGNED INT)
  | SIGNED LONG_LONG -> leq (SIGNED LONG)
  (* Corresponding signed and unsigned integers have the same rank. *)
  | UNSIGNED b       -> lt_rank i1 (SIGNED b)
  end

let leq_prec i1 i2 =
  match (i1, i2) with
  | (BOOL      ,  _         ) -> true
  | (_         ,  BOOL      ) -> false
  | (SIGNED   _,  SIGNED   _) -> leq_rank i1 i2
  | (UNSIGNED _,  UNSIGNED _) -> leq_rank i1 i2
  | (SIGNED   _,  UNSIGNED _) ->
      if leq_rank i1 i2 then
        true
      else
        (* TODO Implementation defined! *)
        false
  end

let rec common_int i1 i2 =
  if i1 = i2 then i1 else
    match (i1, i2) with
    | (BOOL, _) -> i2
    | (_, BOOL) -> i1
    | (SIGNED   _, SIGNED   _) ->
        if lt_rank i1 i2 then i2 else i1
    | (UNSIGNED _, UNSIGNED _) ->
        if lt_rank i1 i2 then i2 else i1
    | (SIGNED b1, UNSIGNED _) ->
        if leq_rank i1 i2 then
          i2
        else if leq_prec i2 i1 then
          i1
        else
          UNSIGNED b1
    | _ -> common_int i2 i1
    end

let rec common t1 t2 =
  match (t1, t2) with
  | (BASIC _ (INTEGER i1), BASIC _ (INTEGER i2)) ->
      BASIC {} (INTEGER (common_int i1 i2))
  end

let promote_int i =
  let s_int = SIGNED   INT in
  let u_int = UNSIGNED INT in
  let promoted =
    if leq_rank i s_int then (
      if leq_prec i s_int then s_int else u_int
    ) else i in
  match i with
  | SIGNED   INT -> i
  | UNSIGNED INT -> i
  (* "Other than unsigned int or signed int." *)
  | BOOL       -> promoted
  | SIGNED   _ -> promoted
  | UNSIGNED _ -> promoted
  end

let promote t =
  match t with
  | BASIC q (INTEGER i) -> BASIC q (INTEGER (promote_int i))
  | _ -> t
  end

let usual_arithmetic t1 t2 = common (promote t1) (promote t2)

let is_complete t =
  match t with
  | BASIC    _ _ -> is_complete_object t
  | POINTER  _ _ -> is_complete_object t
  | ARRAY    _ _ -> true
  | FUNCTION _ _ -> false
  end

let is_incomplete t = not (is_complete t)

let is_const = function
  | BASIC    q _ -> Cabs.CONST IN q
  | POINTER  q _ -> Cabs.CONST IN q
  | ARRAY    _ _ -> false
  | FUNCTION _ _ -> false
  end

let is_modifiable t =
  not (is_array t)
  && not (is_incomplete t)
  && not (is_const t)

let is_bool = function
  | BASIC _ (INTEGER BOOL) -> true
  | _                      -> false
  end

let base_of_pointer = function
  | POINTER _ t -> t
  end

let base_of_array = function
  | ARRAY t _ -> t
  end

let size_of_array = function
  | ARRAY _ s -> s
  end

let function_return = function
  | FUNCTION t _ -> t
  end

let function_parameters = function
  | FUNCTION _ ts -> ts
  end

let well_formed t = true

let composite t1 t2 = if compatible t1 t2 then Some t1 else None

let pointer_convert t =
  match t with
  | FUNCTION _  _ -> POINTER {} t
  | ARRAY    t' _ -> POINTER {} t'
  | _ -> t
  end

let lvalue_convert t =
  if is_incomplete t && not (is_array t) then None else Some (unqualify t)

let lvalue_convert' = unqualify

let is_lvalue = function
  | T_LVALUE _ -> true
  | T_EXP    _ -> false
  end

let is_unsigned_of t1 t2 =
  match (t1, t2) with
  | (BASIC _ (INTEGER (SIGNED i1)), BASIC _ (INTEGER (UNSIGNED i2))) -> i1 = i2
  | _                                                                -> false
  end

let is_signed_of t1 t2 =
  match (t1, t2) with
  | (BASIC _ (INTEGER (UNSIGNED i1)), BASIC _ (INTEGER (SIGNED i2))) -> i1 = i2
  | _                                                                -> false
  end
