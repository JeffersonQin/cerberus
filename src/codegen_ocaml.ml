(* Created by Victor Gomes 2016-01-19 *)
(* It generates an Ocaml file from Core AST *)

open Util
open Pp_prelude
open Core
open AilTypes
open Defacto_memory_types
open Core_ctype
open CodegenAux

open Codegen_ocaml2

let print_label (sym, bT, ps, e) =
  !^"| A.Label (\"" ^^ print_symbol sym ^^ !^"\"," ^^^ print_params ps ^^^ !^") ->\n"
    ^^ print_expr e

  (*
    (* TODO: Not sure of this hack! *)
  print_let true
    (print_symbol sym) 
    (print_params ps)
    (!^"Continuation.shift (fun _ -> " ^^^ print_expr e ^^^ !^")") P.empty
*)
let print_labels e =
  get_labels e []
  |> List.fold_left (fun acc lab -> acc ^^ print_label lab) P.empty


let print_funs funs =
  Pmap.fold (fun sym decl acc ->
    acc ^//^ !^"and" ^^^
    match decl with
    | Fun  (bTy, params, pe) ->
      print_function (print_symbol sym) params (print_base_type bTy)
        (print_pure_expr pe)
    | Proc (bTy, params, e) ->
      print_eff_function (print_symbol sym ^^^ print_symbol Transform.default) params
        (P.parens (print_base_type bTy) ^^^ !^"M.memM")
        (Transform.print_transformed e bTy)
        (*
        (print_labels e ^^ print_expr e)
           *)
        (*
        (
          !^"let rec goto k =\n"
            ^^ !^"try\nlet _ = k() in\n"
            ^^ print_expr e
            ^^ !^"\nwith\n"
            ^^ print_labels e
            ^^ !^"\n| _ -> raise (A.Error \"no catch\")\n"
            ^^ !^"\nin goto (fun x -> x)"
        )
           *)
  ) funs P.empty

let print_head filename =
  !^"(* Generated by Cerberus from" ^^^ !^filename ^^ !^" *)" ^//^
  !^"module A = CodegenAux" ^/^
  !^"module M = Mem" ^/^
  !^"module I = Mem.Impl" ^/^
  !^"module T = AilTypes" ^/^
  !^"module C = Core_ctype" ^/^
  !^"module O = Util.Option" ^//^
  !^"let (>>=) = Mem.bind2" ^//^
  (*
  !^"let (>>=) = Continuation.bind" ^//^
     *)
  !^"let _std_function_printf x y = (A.value [(I.IV (I.Prov_none, \
                            I.IVconcrete (Nat_big_num.of_string \"0\")))])" ^/^
  !^"let kill x = A.value ()"

let print_foot = 
    !^"A.quit main"

(* Generate Ocaml *)
let generate_ocaml core =
  let globals acc (sym, coreTy, e) =
    acc ^^ !^"and" ^^^ print_eff_function (print_symbol sym) []
      (print_base_type coreTy) (print_expr e)
  in
    print_impls core.impl ^^
    print_funs core.stdlib ^//^
    List.fold_left globals P.empty core.globs ^^
    print_funs core.funs ^^ P.semi ^^ P.semi

let compile filename core =
  let fl = Filename.chop_extension filename in
  let fl_ml = fl ^ ".ml" in
  let oc = open_out fl_ml in
  begin
    P.ToChannel.pretty 1. 80 oc
      (print_head filename ^^ generate_ocaml core ^//^ print_foot);
    close_out oc;
    Exception.return0 0
  end
