open Global

type ('a, 'msg) t =
  | Result of 'a
  | Exception of 'msg

let bind m k =
  match m with
    | Result a -> k a
    | Exception  s -> Exception s
  end

let rbind k m = bind m k

let unit a = Result a
let throw m = Exception m
let fail = throw
let join m = bind m (fun x -> x)

let map f m = bind m (unit -| f)
let app mf m = bind mf (fun f -> map f m)

let catch = function
  | Result    _ -> None
  | Exception m -> Some m
  end

let of_option m = function
  | Some a -> unit a
  | None   -> throw m
end

let to_bool = function
  | Result    _ -> true
  | Exception _ -> false
end

module Operators = struct
  let (>>=) = bind
end

open Operators

let map2 f mx my    = app (map f mx) my
let map3 f mx my mz = app (map2 f mx my) mz

let sequence ms =
  List.fold_right
    (fun m m' ->
      m  >>= fun x  ->
      m' >>= fun xs ->
      unit (x::xs)
    ) ms (unit [])
let t_list t xs = sequence (t xs)
let map_list f = t_list (List.map f)

let sequence_map mmap =
  Pmap.fold (fun k m mm->
    m  >>= fun x   ->
    mm >>= fun map ->
    unit (Pmap.add k x map)
  ) mmap (unit Pmap.empty)

let map_map f m = sequence_map (Pmap.map f m)

let inj_right f (a, b) = f b >>= fun b' -> unit (a, b')