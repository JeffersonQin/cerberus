type value = num (* TODO *)

(* Symbolic names *)
type sym = Symbol.t


(* Binary operators *)
type binop =
  (* arithmetic operators *)
  | OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpMod
  (* relational operators *)
  | OpEq
  | OpLt
  (* logical connectives *)
  | OpAnd
  | OpOr


(* Core syntax *)
type expr =
  | DEBUG of string
  
  (* pure expressions *)
  | Kconst of num
  | Ksym of sym
  | Kop of binop * expr * expr
  | Ktrue
  | Kfalse
  | Kctype of Ail.ctype
  | Klet of sym list * expr * expr
  | Kif of expr * expr * expr
  | Kcall of sym * expr list (* TODO: do we want the same symbols for Core functions? probably not. *)
  
  (* undefined behaviour and late static error *)
  | Kundef
  | Kerror
  
  (* sequence-before constructors *)
  | Kskip
  | Kseq of sym list * expr * expr
  | Kunseq of expr list
  | Kindet of expr
  | Katom of expr
  
  (* memory actions *)
  | Kcreate of Ail.ctype
  | Kalloc of sym
  | Kkill of sym
  | Kstore of Ail.ctype * sym * sym
  | Kload of Ail.ctype * sym
  | Ksame of sym * sym
  
  (* TODO: would it be better to make these become function
           part of a standard library ? *)
  | Kmax of Ail.ctype
  | Kmin of Ail.ctype
  | Ksizeof of Ail.ctype
  | Kalignof of Ail.ctype
  | Koffsetof of Ail.ctype
  | Kshift of sym * expr
  | Kconv of Ail.ctype * Ail.ctype * sym


(* Pretty printing *)
module Print = struct
  module P = Pprint

  open P.Operators
  
  let pp_keyword w = !^ ("\x1b[1;35m" ^ w ^ "\x1b[0m")
  let pp_constant c = !^ ("\x1b[35m" ^ c ^ "\x1b[0m")
  let pp_control w = !^ ("\x1b[1;36m" ^ w ^ "\x1b[0m")
  let pp_symbol a = !^ ("\x1b[34m" ^ (Symbol.to_string_pretty a) ^ "\x1b[0m")
  let pp_number n = !^ ("\x1b[33m" ^ n ^ "\x1b[0m")
  
  let optional pp = function
    | Some x -> pp x
    | None   -> P.empty
  end
  
  let pp_binop = function
    | OpAdd -> P.plus
    | OpSub -> P.minus
    | OpMul -> P.star
    | OpDiv -> P.slash
    | OpMod -> P.percent
    | OpEq  -> P.equals
    | OpLt  -> P.langle
    | OpAnd -> !^ "/\\"
    | OpOr  -> !^ "\/"
  end
  
  let rec pp_expr e =
    match e with
      | DEBUG str       -> !^ ("\x1b[1;7;31m[DEBUG]{" ^ str ^ "}\x1b[0m")
      | Kconst n        -> pp_number (string_of_num n)
      | Ksym a          -> pp_symbol a
      | Kop op e1 e2    -> P.parens (pp_expr e1) ^^^ pp_binop op ^^^ P.parens (pp_expr e2)
      | Ktrue           -> pp_constant "true"
      | Kfalse          -> pp_constant "false"
      | Kctype ty       -> Ail.Print.pp_type ty
      | Klet [] e1 e2   -> !^ "BUG: for now LET must have at least one symbol."
      | Klet [a] e1 e2  -> pp_control "let" ^^^ pp_symbol a ^^^ P.equals ^^^ pp_expr e1 ^^^
                           pp_control "in" ^^ P.break1 ^^ pp_expr e2
      | Klet _as e1 e2  -> pp_control "let" ^^^ (P.parens (P.comma_list pp_symbol _as)) ^^^ P.equals ^^^ pp_expr e1 ^^^
                           pp_control "in" ^^ P.break1 ^^ pp_expr e2
      | Kif b e1 e2     -> pp_control "if" ^^^ pp_expr b ^^^ pp_control "then" ^^
                           P.nest 2 (P.break1 ^^ pp_expr e1) ^^ P.break1 ^^
                           pp_control "else" ^^ P.nest 2 (P.break1 ^^ pp_expr e2) ^^ P.break1
      | Kcall a es      -> !^ "TODO(call)"
      | Kundef          -> pp_keyword "undef"
      | Kerror          -> pp_keyword "error"
      | Kskip           -> pp_keyword "skip"
      | Kseq [] e1 e2   -> pp_expr e1 ^^ P.semi ^^ P.break1 ^^ pp_expr e2
      | Kseq [a] e1 e2  -> pp_symbol a ^^^ !^ "<-" ^^^ pp_expr e1 ^^ P.semi ^^ P.break1 ^^ pp_expr e2
      | Kseq _as e1 e2  -> (P.parens (P.sepmap P.comma pp_symbol _as)) ^^^ !^ "<-" ^^^ pp_expr e1 ^^ P.semi ^^ P.break1 ^^
                           pp_expr e2
      | Kunseq []       -> !^ "BUG: UNSEQ must have at least two arguments (seen 0)"
      | Kunseq [_]      -> !^ "BUG: UNSEQ must have at least two arguments (seen 1)"
      | Kunseq es       ->  P.sepmap (pp_control "||") (fun x -> P.parens (pp_expr x)) es
      | Kindet e        -> P.brackets (pp_expr e)
      | Katom e         -> P.braces (pp_expr e)
      | Kcreate ty      -> pp_keyword "create" ^^ P.braces (Ail.Print.pp_type ty)
      | Kalloc a        -> pp_keyword "alloc" ^^^ pp_symbol a
      | Kkill a         -> pp_keyword "kill" ^^^ pp_symbol a
      | Kstore ty a1 a2 -> pp_keyword "store" ^^ P.braces (Ail.Print.pp_type ty) ^^^ pp_symbol a1 ^^^ pp_symbol a2
      | Kload ty a      -> pp_keyword "load" ^^ P.braces (Ail.Print.pp_type ty) ^^^ pp_symbol a
      | Ksame a1 a2     -> pp_keyword "same" ^^^ pp_symbol a1 ^^^ pp_symbol a2
      | Kmax ty         -> pp_keyword "max" ^^ P.braces (Ail.Print.pp_type ty)
      | Kmin ty         -> pp_keyword "min" ^^ P.braces (Ail.Print.pp_type ty)
      | Ksizeof ty      -> pp_keyword "sizeof" ^^ P.braces (Ail.Print.pp_type ty)
      | Kalignof ty     -> pp_keyword "alignof" ^^ P.braces (Ail.Print.pp_type ty)
      | Koffsetof ty    -> pp_keyword "offset" ^^ P.braces (Ail.Print.pp_type ty)
      | Kshift a e      -> pp_keyword "alloc" ^^^ pp_symbol a ^^^ pp_expr e
      | Kconv ty1 ty2 a -> pp_keyword "alloc" ^^ P.braces (Ail.Print.pp_type ty1 ^^ !^"\\" ^^ Ail.Print.pp_type ty2) ^^^ pp_symbol a
  end
  
  let pp_file x = pp_expr x ^^ !^ "\n"
  
  end
