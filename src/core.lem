open Global



(* Types *)
type core_base_type =
  | integer
  | boolean
  | address
  | ctype
  | unit
  | tuple of list core_base_type
  | wildcard

type core_type =
  | TyBase   of core_base_type
  | TyEffect of core_base_type


let rec string_of_core_base_type_aux l =
  match l with
    | []    -> ")"
    | [x]   -> string_of_core_base_type x
    | x::xs -> string_of_core_base_type x ^ ", " ^ string_of_core_base_type_aux xs
  end
and string_of_core_base_type baseTy =
  match baseTy with
    | integer       -> "integer"
    | boolean       -> "boolean"
    | address       -> "address"
    | ctype         -> "ctype"
    | unit          -> "unit"
    | tuple baseTys -> "(" ^ string_of_core_base_type_aux baseTys
end

let string_of_core_type = function
  | TyBase   baseTy -> string_of_core_base_type baseTy
  | TyEffect baseTy -> "[" ^ string_of_core_base_type baseTy ^ "]"
end


(* -- Syntax ------------------------------------------------------------------------------------ *)

(* Symbolic names *)
type sym = Symbol.t

(* label names *)
type label = Symbol.t


(* Binary operators *)
type binop =
  (* arithmetic operators *)
  | OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpMod
  (* relational operators *)
  | OpEq
  | OpLt
  (* logical connectives *)
  | OpAnd
  | OpOr

(* Sequencing operator *)
(*type seqop =
  (* Normal sequencing *)
  | SOpSeq
*)
  (* "Strong sequencing" for incr/decr *)
(*  | SOpSSeq *) (* WE DON'T HAVE THIS ANYMORE, MAYBE EVENT GET RID OF seqop *)


(* Polarity for actions *)
type polarity =
  | Pos
  | Neg


(* Merged pure and effectful expressions *)
type expr =
  | COMMENT of string * expr
  | DEBUG of string
  
  (* pure expressions *)
  | Kconst of num
  | Ksym of sym
  | Kop of binop * expr * expr
  | Ktrue
  | Kfalse
  | Knot of expr
  | Kctype of Ail.ctype
  | Klet of sym * expr * expr
  | Kif of expr * expr * expr
  | Kcall of sym * list expr (* TODO: do we want the same symbols for Core functions? probably not. *)
  
  (* undefined behaviour and late static error *)
  | Kundef
  | Kerror
  
  (* sequence-before constructors *)
    (* 
       Kwhile a S E S' ==>
       
       a <- S;
       while (E) do
         S'
       done
       
       S is effectful, S' may be effectful, E is pure
     *)
(*  | Kwhile of sym * expr * expr * expr *)
  
  | Kskip
  
  | Kaction of paction
  | Kunseq of list expr
  | Kwseq of list (option sym) * expr * expr
  | Ksseq of list (option sym) * expr * expr
  | Kaseq of option sym * action * paction
  
  
| Kindet of expr (* TODO:  | Kindet of num * expr *)
  | Kbound of num * expr (* boundary for indet expressions context *)
  
  | Ksame of expr * expr
  
(*
  | Kgoto of label
  | Klabel of label * expr
*)
  
  (* TODO: these are not anymore constructors, but functions *)
(*
  | Kmax of Ail.ctype
  | Kmin of Ail.ctype
  | Ksizeof of Ail.ctype
  | Kalignof of Ail.ctype
  | Koffsetof of Ail.ctype
  | Kshift of sym * expr
  | Kconv of Ail.ctype * Ail.ctype * sym
*)

and action =
  | Kcreate of expr
  | Kalloc of expr
  | Kkill of sym
  | Kstore of expr * expr * expr
  | Kload of expr * expr

and paction = polarity * action


let pcreate ty = Kaction (Pos, Kcreate ty)
let palloc e = Kaction (Pos, Kalloc e)
let pkill x = Kaction (Pos, Kkill x)
let pstore ty x n = Kaction (Pos, Kstore ty x n)
let pload ty x = Kaction (Pos, Kload ty x)


(* a Core file is just a sequence of functions *)
type file = <|
  main    : sym;
  fun_map : map sym (core_type * list (sym * core_base_type) * expr)
|>


(*
let test: file =
  let a_main    = (1, Some "main") in
  let a_f       = (2, Some "f")    in
  let main_body =
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
    Kseq [] (Kcreate signed_int)
      (Kseq [] (Kunseq [Kindet (Kcall a_f []); Kindet (Kcall a_f [])])
           (Kcreate signed_int)
           )
  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect integer, [], main_body) (Pmap.add a_f (TyEffect integer, [], Kskip) Pmap.empty) |>
*)

(* TODO: check if it is correct that only the call is indet *)
let test: file =
  let a_main    = (1, Some "main") in
  let a_f       = (2, Some "f")    in
  let a_n       = (3, Some "n")    in
  let a_m       = (4, Some "m")    in
  let f_body    = Kconst 0         in
  let main_body =
    let a1 = (5, Some "n_tmp") in
    let a2 = (6, Some "m_tmp") in
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
    Kunseq
    [
      Kwseq [Some a1; Some a2] (Kunseq [pcreate (Kctype signed_int); pcreate (Kctype signed_int)])
        (Kwseq [] (Kunseq [pstore (Kctype signed_int) (Ksym a1) (Kconst 4); pstore (Kctype signed_int) (Ksym a2) (Kconst 5)])
           (Kwseq [] (Kindet (Kcall a_f [Ksym a1; Ksym a2])) 
              (Kwseq [] (Kunseq [pkill a1; pkill a2])
                 (Kconst 0)
              )
           )
        );
      Kwseq [Some a1; Some a2] (Kunseq [pcreate (Kctype signed_int); pcreate (Kctype signed_int)])
        (Kwseq [] (Kunseq [pstore (Kctype signed_int) (Ksym a1) (Kconst 4); pstore (Kctype signed_int) (Ksym a2) (Kconst 5)])
           (Kwseq  [] (Kindet (Kcall a_f [Ksym a1; Ksym a2])) 
              (Kwseq [] (Kunseq [pkill a1; pkill a2])
                 (Kconst 0)
              )
          )
       )
    ]
  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect integer, [], main_body) (Pmap.add a_f (TyBase integer, [(a_n, address); (a_m, address)], f_body) Pmap.empty) |>




let test2: file =
  let a_main    = (1, Some "main") in
  let a_x       = (3, Some "x")    in
  let a_y       = (4, Some "y")    in
  let f_body    = Kconst 0         in
  let main_body =
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
      Kwseq [Some a_x; Some a_y] (Kunseq [pcreate (Kctype signed_int); pcreate (Kctype signed_int)])
        (Kwseq [] (Kif (Ktrue) (pstore (Kctype signed_int) (Ksym a_x) (Kconst 1))
                               (pstore (Kctype signed_int) (Ksym a_y) (Kconst 2)))
           (Kunseq [pkill a_x; pkill a_y]))

  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect integer, [], main_body) Pmap.empty |>



let test3: file =
  let a_main = (1, Some "main") in
  let a_f    = (2, Some "f") in
  let x    = (1, Some "x") in
  let y    = (2, Some "y") in
  <| main= a_main; fun_map= Pmap.add a_f    (TyEffect integer, [(x, integer); (y, integer)], Kop OpAdd (Ksym x) (Ksym y))
                           (Pmap.add a_main (TyEffect integer, [], Kcall a_f [Kconst 10; Ktrue]) Pmap.empty) |>



let test4: file =
  let a_main    = (1, Some "main") in
  let a_x       = (3, Some "x")    in
  let a_n       = (4, Some "n")    in
  let f_body    = Kconst 0         in
  let main_body =
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
      Kwseq [Some a_x] (pcreate (Kctype signed_int))
        (Klet a_n (Kconst 42)
           (Kif Ktrue
              (pstore (Kctype signed_int) (Ksym a_x) (Ksym a_n))
              Kskip
           ))
  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect unit, [], main_body) Pmap.empty |>










(* Symbolic names for the standard library functions *)
let overflow = (51, Some "overflow")
let conv_int = (52, Some "conv_int")
let conv     = (53, Some "conv")


(* [guard_zero n] = if n = 0 then undef else n  *)
let guard_zero = (54, Some "div_zero")

(* Returns the "common real type" of two given ctypes (ยง6.3.1.8) *)
let usual_arithmetic = (55, Some "usual_arithmetic")


(* the width of a C type (in bits) *)
let ctype_width     = (56, Some "ctype_width")

(* exponentiation *)
let exp     = (57, Some "exp")

(* representable(ty,n) = true iff min{ty} <= n && n <= max{ty} *)
let representable     = (58, Some "representable")

let max      = (59, Some "max")
let min      = (59, Some "min")
let sizeof   = (59, Some "sizeof")
let alignof  = (59, Some "alignof")
let offsetof = (59, Some "offsetof")
let shift    = (59, Some "shift")



(* types of the standard library functions *)
let core_stdlib =
  let f = List.fold_left (fun acc (fname, ftype) -> Pmap.add fname ftype acc) Pmap.empty in
  f [
      (overflow,         ([ctype; integer],        TyBase integer));
      (conv_int,         ([ctype; integer],        TyBase integer));
      (conv,             ([ctype; ctype; integer], TyBase integer));
      (guard_zero,       ([integer],               TyBase integer));
      (usual_arithmetic, ([ctype; ctype],          TyBase ctype));
      (ctype_width,      ([ctype],                 TyBase integer));
      (exp,              ([integer; integer],      TyBase integer));
      (representable,    ([ctype; integer],        TyBase boolean));
      (max,              ([ctype],                 TyBase integer));
      (min,              ([ctype],                 TyBase integer));
      (sizeof,           ([ctype],                 TyBase integer));
      (alignof,          ([ctype],                 TyBase integer));
      (offsetof,         ([ctype],                 TyBase integer));
      (shift,            ([address; integer],      TyBase address))
    ]


(* -- Pretty printing --------------------------------------------------------------------------- *)
module Print = struct
  module P = Pprint

  open P.Operators
  
  
  let precedence = function
    | Kconst _ -> Some 0
    | Ksym _   -> Some 0
    | Ktrue    -> Some 0
    | Kfalse   -> Some 0
    | Kctype _ -> Some 0
    | Kundef   -> Some 0
    | Kerror   -> Some 0
    | Kskip    -> Some 0
    
    | Knot _   -> Some 1
    | Kindet _ -> Some 1

    | Kaction (_, Kcreate _)    -> Some 2
    | Kaction (_, Kalloc _)     -> Some 2
    | Kaction (_, Kkill _)      -> Some 2
    | Kaction (_, Kstore _ _ _) -> Some 2
    | Kaction (_, Kload _ _)    -> Some 2
    | Ksame _ _    -> Some 2
    | Kcall _ _    -> Some 2
    
    | Kop OpMul _ _ -> Some 3
    | Kop OpDiv _ _ -> Some 3
    | Kop OpMod _ _ -> Some 3
    | Kop OpAdd _ _ -> Some 4
    | Kop OpSub _ _ -> Some 4
    | Kop OpLt  _ _ -> Some 5
    | Kop OpEq  _ _ -> Some 6
    | Kop OpAnd _ _ -> Some 7
    | Kop OpOr  _ _ -> Some 8
    
    | Kif _ _ _  -> Some 9
    | Klet _ _ _ -> Some 10

    | Kaseq _ _ _ -> Some 11
    | Kwseq _ _ _ -> Some 12
    | Ksseq _ _ _ -> Some 13
    | Kunseq _    -> Some 14

(*    | Kwhile _ _ _ _ -> None *)
    | COMMENT _ _ ->    None
    | DEBUG _ ->        None
  end

  let lt_precedence p1 p2 =
    match (p1, p2) with
      | (Some n1, Some n2) -> n1 <= n2
      | (Some _ , None   ) -> true
      | (None   , _      ) -> false
    end
  
  let pp_keyword  w = !^ ("\x1b[1;35m" ^ w ^ "\x1b[0m")
  let pp_constant c = !^ ("\x1b[35m" ^ c ^ "\x1b[0m")
  let pp_control  w = !^ ("\x1b[1;36m" ^ w ^ "\x1b[0m")
  let pp_symbol   a = !^ ("\x1b[34m" ^ (Symbol.to_string_pretty a) ^ "\x1b[0m")
  let pp_number   n = !^ ("\x1b[33m" ^ n ^ "\x1b[0m")
  
  
  let optional pp = function
    | Some x -> pp x
    | None   -> P.empty
  end
  
  
  let rec pp_core_base_type baseTy =
    match baseTy with
      | integer       -> !^ "integer"
      | boolean       -> !^ "boolean"
      | address       -> !^ "address"
      | ctype         -> !^ "ctype"
      | unit          -> !^ "unit"
      | wildcard      -> !^ "wildcard"
      | tuple baseTys -> P.parens (P.sepmap P.comma pp_core_base_type baseTys)
    end
  
  let pp_core_type = function
    | TyBase   baseTy -> pp_core_base_type baseTy
    | TyEffect baseTy -> P.brackets (pp_core_base_type baseTy)
  end
  
  let pp_binop = function
    | OpAdd -> P.plus
    | OpSub -> P.minus
    | OpMul -> P.star
    | OpDiv -> P.slash
    | OpMod -> P.percent
    | OpEq  -> P.equals
    | OpLt  -> P.langle
    | OpAnd -> !^ "/\\"
    | OpOr  -> !^ "\\/"
  end
  
  let rec pp_expr p e =
    let p' = precedence e in
    let f = P.group -| pp_expr p' in
    (if lt_precedence p' p then fun x -> x else P.parens) $
    match e with
      | COMMENT str e   -> !^ ("\x1b[1;31m--" ^ str ^ "\x1b[0m") ^^ P.break1 ^^ f e
      | DEBUG str       -> !^ ("\x1b[1;7;31m[DEBUG]{" ^ str ^ "}\x1b[0m")
      
      | Kconst n        -> pp_number (string_of_num n)
      | Ksym a          -> pp_symbol a
      | Kop op e1 e2    -> f e1 ^^^ pp_binop op ^^^ f e2
      | Ktrue           -> pp_constant "true"
      | Kfalse          -> pp_constant "false"
      | Knot e          -> pp_keyword "not" ^^^ f e
      | Kctype ty       -> Ail.Print.pp_type ty
      | Klet a e1 e2    -> pp_control "let" ^^^ pp_symbol a ^^^ P.equals ^^ 
                           P.nest 2 (P.break1 ^^ f e1 ^^^ pp_control "in")
                           ^^ P.break1 ^^ f e2
      | Kif b e1 e2     -> pp_control "if" ^^^ f b ^^^ pp_control "then" ^^
                           P.nest 2 (P.break1 ^^ f e1) ^^ P.break1 ^^
                           pp_control "else" ^^ P.nest 2 (P.break1 ^^ f e2) ^^ P.break1
      | Kcall a es      -> pp_symbol a ^^ P.parens (P.sepmap (P.comma ^^ P.space) f es)
      | Kundef          -> pp_keyword "undef"
      | Kerror          -> pp_keyword "error"
      | Kskip           -> pp_keyword "skip"

(*      | Kwhile a s1 e s2 -> pp_control "while" ^^^ pp_symbol a ^^^ !^ "<-" ^^^ f s1 ^^ P.semi ^^^ f e ^^^ pp_control "do" ^^
                            P.nest 2 (P.break1 ^^ f s2) ^^ P.break1 ^^ pp_control "done"
*)

      | Kaseq None act y     -> f (Kaction (Pos, act)) ^^^ (!^ "|>") ^^^ f (Kaction y)
      | Kaseq (Some a) act y -> pp_symbol a ^^^ !^ "<-" ^^ f (Kaction (Pos, act)) ^^^ (!^ "|>") ^^^ f (Kaction y)
      
      | Ksseq [] e1 e2  -> f e1 ^^^ (!^ "<>") ^^ P.break1 ^^ f e2
      | Ksseq [Some a] e1 e2 -> pp_symbol a ^^^ !^ "<-" ^^
                                P.nest 2 (P.break1 ^^ f e1 ^^^ (!^ "<>"))
                                ^^ P.break1 ^^ f e2
      | Ksseq [None] e1 e2  -> f e1 ^^^ (!^ "<>") ^^ P.break1 ^^ f e2
      | Ksseq _as e1 e2 -> let g x = match x with
                                       | Some x -> pp_symbol x
                                       | None   -> P.underscore
                                     end
                           in (P.parens (P.sepmap P.comma g _as)) ^^^ !^ "<-" ^^
                               P.nest 2 (P.break1 ^^ f e1 ^^^ (!^ "<>")) ^^ P.break1 ^^ f e2

      | Kwseq [] e1 e2       -> f e1 ^^^ P.semi ^^ P.break1 ^^ f e2
      | Kwseq [Some a] e1 e2 -> pp_symbol a ^^^ !^ "<-" ^^
                                P.nest 2 (P.break1 ^^ f e1 ^^^ P.semi)
                                ^^ P.break1 ^^ f e2
      | Kwseq [None] e1 e2       -> f e1 ^^^ P.semi ^^ P.break1 ^^ f e2
      | Kwseq _as e1 e2      -> let g x = match x with
                                            | Some x -> pp_symbol x
                                            | None   -> P.underscore
                                          end
                                in (P.parens (P.sepmap P.comma g _as)) ^^^ !^ "<-" ^^
                                   P.nest 2 (P.break1 ^^ f e1 ^^^ P.semi) ^^ P.break1 ^^ f e2
      | Kunseq []       -> !^ "BUG: UNSEQ must have at least two arguments (seen 0)"
      | Kunseq [_]      -> !^ "BUG: UNSEQ must have at least two arguments (seen 1)"
      | Kunseq es       ->  P.sepmap (P.space ^^ (pp_control "||") ^^ P.space) f es
      | Kindet e        -> P.brackets (f e)
      | Kaction (p, a)  -> (match p with
                              | Pos -> P.empty
                              | Neg -> P.tilde
                            end) ^^
                           (match a with
                              | Kcreate ty      -> pp_keyword "create" ^^ P.braces (f ty)
                              | Kalloc a        -> pp_keyword "alloc" ^^^ f e
                              | Kkill a         -> pp_keyword "kill" ^^^ pp_symbol a
                              | Kstore ty e1 e2 -> pp_keyword "store" ^^ P.braces (f ty) ^^^ f e1 ^^^ f e2
                              | Kload ty e      -> pp_keyword "load" ^^ P.braces (f ty) ^^^ f e
                            end)
      
      | Ksame a1 a2     -> pp_keyword "same" ^^^ f a1 ^^^ f a2
(*
      | Kmax ty         -> pp_keyword "max" ^^ P.braces (Ail.Print.pp_type ty)
      | Kmin ty         -> pp_keyword "min" ^^ P.braces (Ail.Print.pp_type ty)
      | Ksizeof ty      -> pp_keyword "sizeof" ^^ P.braces (Ail.Print.pp_type ty)
      | Kalignof ty     -> pp_keyword "alignof" ^^ P.braces (Ail.Print.pp_type ty)
      | Koffsetof ty    -> pp_keyword "offset" ^^ P.braces (Ail.Print.pp_type ty)
      | Kshift a e      -> pp_keyword "shift" ^^^ pp_symbol a ^^^ f e
      | Kconv ty1 ty2 a -> pp_keyword "conv" ^^ P.braces (Ail.Print.pp_type ty1 ^^ !^"\\" ^^ Ail.Print.pp_type ty2) ^^^ pp_symbol a
*)

(*
      | Kgoto l         -> pp_control "goto" ^^^ pp_symbol l
      | Klabel l e      -> pp_symbol l ^^ P.colon ^^^ f e
*)
  end
  
  let pp_file file =
    let pp_argument (aname, atype) = pp_symbol aname ^^ P.colon ^^^ pp_core_base_type atype in
    let f acc (fname, (ftype, args, body)) =
      acc ^^
      pp_keyword "fun" ^^^ pp_symbol fname ^^^ P.parens (P.sepmap P.comma pp_argument args) ^^ P.colon ^^^ pp_core_type ftype ^^^ P.equals ^^
      P.nest 2 (P.break1 ^^ pp_expr None body) ^^ P.break1 ^^ P.break1 in
    
    let (_, _, main_body) = Pmap.find file.main file.fun_map in (* TODO: main args *)
    List.fold_left f P.empty (Ocaml.Pmap.bindings (Ocaml.Pmap.remove file.main file.fun_map)) ^^
    pp_expr None main_body ^^ P.break1
  end
