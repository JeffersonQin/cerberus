open Global

(* TODO: this is here because of some stupid cyclic module dependency ...

         Idealy we should have a memory.lem module which would be used by
         core.lem (just for knowing mem_addr) and by core_run. But we can't
         because the memory actions have to know about the monad used by
         core_run.lem. If we had type families, StateT would do the trick *)
type mem_addr = num


(* -- Syntax ---------------------------------------------------------------- *)
type core_base_type =
  | integer
  | boolean
  | address
  | ctype
  | unit
  | tuple of list core_base_type
  | wildcard

(* Types discriminate between pure (TyBase) and effectful
   expressions (TyEffect) *)
type core_type =
  | TyBase   of core_base_type
  | TyEffect of core_base_type


(* Symbolic names *)
type sym = Symbol.t

(* continuation names *)
type ksym = Symbol.t


(* Binary operators *)
type binop =
  (* arithmetic operators *)
  | OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpMod
  (* relational operators *)
  | OpEq
  | OpLt
  (* logical connectives *)
  | OpAnd
  | OpOr


(* Polarity for actions *)
type polarity =
  | Pos
  | Neg


type expr 'a =
  (* TODO: removed these *)
  | COMMENT of string * expr 'a
  | DEBUG of string
  
  (* pure expressions *)

  | Etuple of list (expr 'a) (* TODO: may be temporary *)

  | Eskip
  | Econst of num
  | Eaddr of mem_addr
  | Esym of sym
  | Eop of binop * expr 'a * expr 'a
  | Etrue
  | Efalse
  | Enot of expr 'a
  | Ectype of Ail.ctype
  | Elet of sym * expr 'a * expr 'a
  | Eif of expr 'a * expr 'a * expr 'a
  | Ecall of sym * list (expr 'a) (* TODO: do we want the same symbol env for
                                           Core functions? probably not. *)
  (* K: I think this one is also pure *)
  | Esame of expr 'a * expr 'a

  
  (* undefined behaviour and late static error *)
  | Eundef
  | Eerror
  
  | Eaction of paction 'a
  
  (* sequencing operators *)
  | Eunseq of list (expr 'a)

  | Ewseq of list (option sym) * expr 'a * expr 'a

(*  | Ewseq of list (list (option sym) * expr 'a) * expr 'a *)
  | Esseq of list (option sym) * expr 'a * expr 'a
  | Easeq of option sym * action 'a * paction 'a
  
  (* indeterminately-sequenced expressions and boundary *)
  (* TODO: this doesn't exists after the first stage of dynamics *)
  | Eindet of expr 'a (* TODO: add unique indices *)
  | Ebound of num * expr 'a
  
  (* Continuation operators *)
  | Esave of ksym * expr 'a
  | Erun of ksym
  | Eret of expr 'a
  
  (* Non deterministic choice (resulting from indet expressions) *)
  (* TODO: this only exists for the second stage of dynamics *)
  | End of list (expr 'a)
  
  (* TODO: this should probably be added back to the syntax *)
(* | Kshift of sym * expr 'a *)
  
  (* TODO: these are not anymore constructors, but functions that need to be
           exposed by the Std library

     Kmax of Ail.ctype
     Kmin of Ail.ctype
     Ksizeof of Ail.ctype
     Kalignof of Ail.ctype
     Koffsetof of Ail.ctype
     Kconv of Ail.ctype * Ail.ctype * sym
*)

and action_ 'a =
  | Create of expr 'a
  | Alloc of expr 'a
  | Kill of expr 'a
  | Store of expr 'a * expr 'a * expr 'a
  | Load of expr 'a * expr 'a
and action 'a  = set 'a * action_ 'a
and paction 'a = polarity * action 'a


(* some aliases for positive actions *)
let pcreate ty    = Eaction (Pos, ({}, Create ty   ))
let palloc e      = Eaction (Pos, ({}, Alloc e     ))
let pkill x       = Eaction (Pos, ({}, Kill x      ))
let pstore ty x n = Eaction (Pos, ({}, Store ty x n))
let pload ty x    = Eaction (Pos, ({}, Load ty x   ))


(* a Core file is just a set of named functions *)
type file 'a = <|
  main    : sym;
  fun_map : map sym (core_type * list (sym * core_base_type) * expr 'a)
|>


let rec concat_wseq e e' =
   match e with
     | Ewseq _as e1 e2 -> Ewseq _as e1 (concat_wseq e2 e')
     | Eskip           -> e'
     | _               -> Ewseq [] e e'
  end

(* TODO: get rid of the tests once we have a Core parser. *)
(* TODO: check if it is correct that only the call is indet *)
(*
let test: file unit =
  let a_main    = (1, Some "main") in
  let a_f       = (2, Some "f")    in
  let a_n       = (3, Some "n")    in
  let a_m       = (4, Some "m")    in
  let f_body    = Econst 0         in
  let main_body =
    let a1 = (5, Some "n_tmp") in
    let a2 = (6, Some "m_tmp") in
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
    Eunseq
    [
      Ewseq [Some a1; Some a2] (Eunseq [pcreate (Ectype signed_int); pcreate (Ectype signed_int)])
        (Ewseq [] (Eunseq [pstore (Ectype signed_int) (Esym a1) (Econst 4); pstore (Ectype signed_int) (Esym a2) (Econst 5)])
           (Ewseq [] (Eindet (Ecall a_f [Esym a1; Esym a2])) 
              (Ewseq [] (Eunseq [pkill (Esym a1); pkill (Esym a2)])
                 (Econst 0)
              )
           )
        );
      Ewseq [Some a1; Some a2] (Eunseq [pcreate (Ectype signed_int); pcreate (Ectype signed_int)])
        (Ewseq [] (Eunseq [pstore (Ectype signed_int) (Esym a1) (Econst 4); pstore (Ectype signed_int) (Esym a2) (Econst 5)])
           (Ewseq  [] (Eindet (Ecall a_f [Esym a1; Esym a2])) 
              (Ewseq [] (Eunseq [pkill (Esym a1); pkill (Esym a2)])
                 (Econst 0)
              )
          )
       )
    ]
  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect integer, [], main_body) (Pmap.add a_f (TyBase integer, [(a_n, address); (a_m, address)], f_body) Pmap.empty) |>

let test2: file unit =
  let a_main    = (1, Some "main") in
  let a_x       = (3, Some "x")    in
  let a_y       = (4, Some "y")    in
  let f_body    = Econst 0         in
  let main_body =
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
      Ewseq [Some a_x; Some a_y] (Eunseq [pcreate (Ectype signed_int); pcreate (Ectype signed_int)])
        (Ewseq [] (Eif (Etrue) (pstore (Ectype signed_int) (Esym a_x) (Econst 1))
                               (pstore (Ectype signed_int) (Esym a_y) (Econst 2)))
           (Eunseq [pkill (Esym a_x); pkill (Esym a_y)]))

  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect integer, [], main_body) Pmap.empty |>

let test3: file unit =
  let a_main = (1, Some "main") in
  let a_f    = (2, Some "f") in
  let x    = (1, Some "x") in
  let y    = (2, Some "y") in
  <| main= a_main; fun_map= Pmap.add a_f    (TyEffect integer, [(x, integer); (y, integer)], Eop OpAdd (Esym x) (Esym y))
                           (Pmap.add a_main (TyEffect integer, [], Ecall a_f [Econst 10; Etrue]) Pmap.empty) |>

let test4: file unit =
  let a_main    = (1, Some "main") in
  let a_x       = (3, Some "x")    in
  let a_n       = (4, Some "n")    in
  let f_body    = Econst 0         in
  let main_body =
    let signed_int = Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
      Ewseq [Some a_x] (pcreate (Ectype signed_int))
        (Elet a_n (Econst 42)
           (Eif Etrue
              (pstore (Ectype signed_int) (Esym a_x) (Esym a_n))
              Kskip
           ))
  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect unit, [], main_body) Pmap.empty |>


(*
Elaboration of:

int main(void) {
  int x = 1, y = 2;
  x = y++ + x;
  
  return 0;
}

-}

fun main () :=
  (x, y) <- create{signed int} || create{signed int} >>
  store{signed int} x 1 || store{signed int} y 2 >>
  
  (a1, a2) <- (a3 <- load{signed int} y >> ~store{signed int} y (a3+1) >> a3) || load{signed int} x >>
  store{signed int} x (a1 + a2) >>
  0
*)
let test5: file unit =
  let a_main    = (1, Some "main") in
  let x         = (3, Some "x")    in
  let y         = (4, Some "y")    in
  let a1        = (5, Some "a1")   in
  let a2        = (6, Some "a2")   in
  let a3        = (7, Some "a3")   in
  let main_body =
    let signed_int = Ectype $ Ail.BASIC {} (Ail.INTEGER (Ail.SIGNED Ail.INT)) in
      Ewseq [Some x; Some y] (Eunseq [pcreate signed_int; pcreate signed_int])
        (Ewseq [] (Eunseq [pstore signed_int (Esym x) (Econst 1); pstore signed_int (Esym y) (Econst 2)])
           (Ewseq [Some a1; Some a2] (Eunseq [Ewseq [Some a3] (pload signed_int (Esym y))
                                                 (Ewseq [] (Eaction (Neg, ({}, Kstore signed_int (Esym y) (Eop OpAdd (Esym a3) (Econst 1)))))
                                                    (Esym a3));
                                              pload signed_int (Esym x)])
              (Ewseq [] (pstore signed_int (Esym x) (Eop OpAdd (Esym a1) (Esym a2)))
                 (Econst 0)
              )
           )
        )
  in
  <| main= a_main; fun_map= Pmap.add a_main (TyEffect integer, [], main_body) Pmap.empty |>

(*

fun fact (n : integer) : integer :=
  if n < 2 then 1
           else n * fact(n-1)

fun main : integer :=
  fact(5)
  
*)
let test_fact: file unit =
  let a_main    = (1, Some "main") in
  let a_fact    = (2, Some "fact") in
  let a_n       = (3, Some "n")    in
  let fact_body = 
    Eif (Eop OpLt (Esym a_n) (Econst 2))
        (Econst 1)
        (Eop OpMul (Esym a_n) (Ecall a_fact [Eop OpSub (Esym a_n) (Econst 1)])) in
  let main_body = Ecall a_fact [Econst 5] in
  <| main=    a_main;
     fun_map= Pmap.add a_main (TyEffect integer, [], main_body)
                (Pmap.add a_fact (TyBase integer, [(a_n, integer)], fact_body) Pmap.empty) |>
*)




(* Symbolic names for the standard library functions *)
(* TODO: this should be dynamically imported, doing it statically and manually
         is just wrong *)
let overflow = (51, Some "overflow")
let conv_int = (52, Some "conv_int")
let conv     = (53, Some "conv")


(* [guard_zero n] = if n = 0 then undef else n  *)
let guard_zero = (54, Some "div_zero")

(* Returns the "common real type" of two given ctypes (ยง6.3.1.8) *)
let usual_arithmetic = (55, Some "usual_arithmetic")


(* the width of a C type (in bits) *)
let ctype_width     = (56, Some "ctype_width")

(* exponentiation *)
let exp     = (57, Some "exp")

(* representable(ty,n) = true iff min{ty} <= n && n <= max{ty} *)
let representable     = (58, Some "representable")

let max      = (59, Some "max")
let min      = (59, Some "min")
let sizeof   = (59, Some "sizeof")
let alignof  = (59, Some "alignof")
let offsetof = (59, Some "offsetof")
let shift    = (59, Some "shift")



(* types of the standard library functions *)
(* TODO: dummy bodies for now *)
let core_stdlib : map sym (core_type * list (sym * core_base_type) * expr zero) =
  let mk_sym i name = (i, Some name) in
  let f = List.fold_left (fun acc (fname, fdef) -> Pmap.add fname fdef acc) Pmap.empty in
  f [
      (overflow,         (TyBase integer, [(mk_sym 1 "ty",  ctype); (mk_sym 2 "n",   integer)],                        Esym (mk_sym 2 "n" )));
      (conv,             (TyBase integer, [(mk_sym 1 "ty1", ctype); (mk_sym 2 "ty2", ctype); (mk_sym 3 "n", integer)], Esym (mk_sym 3 "n" )));
      (conv_int,         (TyBase integer, [(mk_sym 1 "ty",  ctype); (mk_sym 2 "n",   integer)],                        Esym (mk_sym 2 "n" )));
      (guard_zero,       (TyBase integer, [(mk_sym 1 "n", integer)],                                                   Esym (mk_sym 1 "n" )));
      (usual_arithmetic, (TyBase ctype,   [(mk_sym 1 "ty",  ctype); (mk_sym 2 "ty",  ctype)],                          Esym (mk_sym 1 "ty")));
      (ctype_width,      (TyBase integer, [(mk_sym 1 "ty",  ctype)],                                                   Econst 42           ));
      (exp,              (TyBase integer, [(mk_sym 1 "n", integer); (mk_sym 2 "m", integer)],                          Econst 42           ));
      (representable,    (TyBase boolean, [(mk_sym 1 "ty",  ctype); (mk_sym 2 "n", integer)],                          Etrue               ));
      (max,              (TyBase integer, [(mk_sym 1 "ty",  ctype)],                                                   Econst 42           ));
      (min,              (TyBase integer, [(mk_sym 1 "ty",  ctype)],                                                   Econst 42           ));
      (sizeof,           (TyBase integer, [(mk_sym 1 "ty",  ctype)],                                                   Econst 42           ));
      (alignof,          (TyBase integer, [(mk_sym 1 "ty",  ctype)],                                                   Econst 42           ));
      (offsetof,         (TyBase integer, [(mk_sym 1 "ty",  ctype)],                                                   Econst 42           ));
      (shift,            (TyBase address, [(mk_sym 1 "x", address); (mk_sym 2 "n", integer)],                          Esym (mk_sym 1 "x" )))
    ]




(* -- Pretty printing --------------------------------------------------------------------------- *)
module Print = struct
  module P = Pprint

  open P.Operators
  
  
  let precedence = function
    | Econst _      -> Some 0
    | Eaddr _       -> Some 0
    | Esym _        -> Some 0
    | Etrue         -> Some 0
    | Efalse        -> Some 0
    | Ectype _      -> Some 0
    | Kundef        -> Some 0
    | Kerror        -> Some 0
    | Kskip         -> Some 0
    | Erun _        -> Some 0
    | Enot _        -> Some 1
    | Esave _ _     -> Some 1
    | Eindet _      -> Some 1
    | Eaction _     -> Some 2
    | Esame _ _     -> Some 2
    | Ecall _ _     -> Some 2
    | Eop OpMul _ _ -> Some 3
    | Eop OpDiv _ _ -> Some 3
    | Eop OpMod _ _ -> Some 3
    | Eop OpAdd _ _ -> Some 4
    | Eop OpSub _ _ -> Some 4
    | Eop OpLt  _ _ -> Some 5
    | Eop OpEq  _ _ -> Some 6
    | Eop OpAnd _ _ -> Some 7
    | Eop OpOr  _ _ -> Some 8
    | Eif _ _ _     -> Some 9
    | Elet _ _ _    -> Some 10
    | Easeq _ _ _   -> Some 11
    | Ewseq _ _ _   -> Some 12
    | Esseq _ _ _   -> Some 13
    | Eunseq _      -> Some 14
    | COMMENT _ _   -> None
    | DEBUG _       -> None
  end
  
  let lt_precedence p1 p2 =
    match (p1, p2) with
      | (Some n1, Some n2) -> n1 <= n2
      | (Some _ , None   ) -> true
      | (None   , _      ) -> false
    end
  
  let pp_keyword  w = !^ ("\x1b[1;35m" ^ w ^ "\x1b[0m")
  let pp_constant c = !^ ("\x1b[35m" ^ c ^ "\x1b[0m")
  let pp_control  w = !^ ("\x1b[1;36m" ^ w ^ "\x1b[0m")
  let pp_symbol   a = !^ ("\x1b[34m" ^ (Symbol.to_string_pretty a) ^ "\x1b[0m")
  let pp_number   n = !^ ("\x1b[33m" ^ n ^ "\x1b[0m")
  
  
  let optional pp = function
    | Some x -> pp x
    | None   -> P.empty
  end
  
  
  let rec pp_core_base_type baseTy =
    match baseTy with
      | integer       -> !^ "integer"
      | boolean       -> !^ "boolean"
      | address       -> !^ "address"
      | ctype         -> !^ "ctype"
      | unit          -> !^ "unit"
      | wildcard      -> !^ "wildcard"
      | tuple baseTys -> P.parens (P.sepmap P.comma pp_core_base_type baseTys)
    end
  
  let pp_core_type = function
    | TyBase   baseTy -> pp_core_base_type baseTy
    | TyEffect baseTy -> P.brackets (pp_core_base_type baseTy)
  end
  
  let pp_binop = function
    | OpAdd -> P.plus
    | OpSub -> P.minus
    | OpMul -> P.star
    | OpDiv -> P.slash
    | OpMod -> P.percent
    | OpEq  -> P.equals
    | OpLt  -> P.langle
    | OpAnd -> !^ "/\\"
    | OpOr  -> !^ "\\/"
  end
  
  
  let rec pp_expr p e =
    let p' = precedence e in
    let f = P.group -| pp_expr p' in
    
    let wseq = !^ ">>" in
    let pp_wseq (_a, e) =
      let leftarrow = !^ "<-" in
      match _a with
        | []       -> f e
        | [Some a] -> pp_symbol a ^^^ leftarrow ^^ (P.align $ f e)
        | [None]   -> f e
        | _as      -> let g = function
                                | Some x -> pp_symbol x
                                | None   -> P.underscore
                              end
                      in (P.parens $ P.sepmap P.comma g _as) ^^^ leftarrow ^^ (P.align $ f e)
      end in
    
    (if lt_precedence p' p then fun x -> x else P.parens)
(*    P.parens *)
    match e with
      | COMMENT str e   -> !^ ("\x1b[1;31m--" ^ str ^ "\x1b[0m") ^^ P.break1 ^^ f e
      | DEBUG str       -> !^ ("\x1b[1;7;31m[DEBUG]{" ^ str ^ "}\x1b[0m")
      
      | Etuple es -> P.parens (P.sepmap (P.comma ^^ P.space) f es)
      
      | Econst n        -> pp_number (string_of_num n)
      | Eaddr o         -> !^ ("@" ^ string_of_num o) (* TODO: here we use the trivial mem_addr *)
      | Esym a          -> pp_symbol a
      | Eop op e1 e2    -> f e1 ^^^ pp_binop op ^^^ f e2
      | Etrue           -> pp_constant "true"
      | Efalse          -> pp_constant "false"
      | Enot e          -> pp_keyword "not" ^^^ f e
      | Ectype ty       -> Ail.Print.pp_type ty
      | Elet a e1 e2    -> pp_control "let" ^^^ pp_symbol a ^^^ P.equals ^^^
                           (P.align $ f e1) ^^^ pp_control "in" ^^ P.break1 ^^ f e2
      | Eif b e1 e2     -> pp_control "if" ^^^ f b ^^^ pp_control "then" ^^
                           P.nest 2 (P.break1 ^^ f e1) ^^ P.break1 ^^
                           pp_control "else" ^^ P.nest 2 (P.break1 ^^ f e2) ^^ P.break1
      | Ecall a es      -> pp_symbol a ^^ P.parens (P.sepmap (P.comma ^^ P.space) f es)
      | Eundef          -> pp_keyword "undef"
      | Eerror          -> pp_keyword "error"
      | Eskip           -> pp_keyword "skip"

(*      | Kwhile a s1 e s2 -> pp_control "while" ^^^ pp_symbol a ^^^ !^ "<-" ^^^ f s1 ^^ P.semi ^^^ f e ^^^ pp_control "do" ^^
                            P.nest 2 (P.break1 ^^ f s2) ^^ P.break1 ^^ pp_control "done"
*)

      | Easeq None act y     -> f (Eaction (Pos, act)) ^^^ (!^ "|>") ^^^ f (Eaction y)
      | Easeq (Some a) act y -> pp_symbol a ^^^ !^ "<-" ^^ f (Eaction (Pos, act)) ^^^ (!^ "|>") ^^^ f (Eaction y)
      
      | Esseq [] e1 e2  -> f e1 ^^^ P.semi ^^ P.break1 ^^ f e2
      | Esseq [Some a] e1 e2 -> pp_symbol a ^^^ !^ "<-" ^^
                                P.nest 2 (P.break1 ^^ f e1 ^^^ P.semi)
                                ^^ P.break1 ^^ f e2
      | Esseq [None] e1 e2  -> f e1 ^^^ P.semi ^^ P.break1 ^^ f e2
      | Esseq _as e1 e2 -> let g x = match x with
                                       | Some x -> pp_symbol x
                                       | None   -> P.underscore
                                     end
                           in (P.parens (P.sepmap P.comma g _as)) ^^^ !^ "<-" ^^
                               P.nest 2 (P.break1 ^^ f e1 ^^^ P.semi) ^^ P.break1 ^^ f e2

(*      | Ewseq es ret -> (P.sepmap (wseq ^^ P.break1) pp_wseq es) ^^^ wseq ^^ P.break1 ^^ f ret *)
      | Ewseq [] e1 e2       -> f e1 ^^^ (!^ ">>") ^^ P.break1 ^^ f e2
      | Ewseq [Some a] e1 e2 -> pp_symbol a ^^^ !^ "<-" ^^^
                                (P.align  $ f e1) ^^^ wseq ^^ P.break1 ^^ f e2
      | Ewseq [None] e1 e2   -> f e1 ^^^ (!^ ">>") ^^ P.break1 ^^ f e2
      | Ewseq _as e1 e2      -> let g x = match x with
                                            | Some x -> pp_symbol x
                                            | None   -> P.underscore
                                          end
                                in (P.parens (P.sepmap P.comma g _as)) ^^^ !^ "<-" ^^^
                                   (P.align  $ f e1) ^^^ wseq ^^ P.break1 ^^ f e2
      | Eunseq []       -> !^ "BUG: UNSEQ must have at least two arguments (seen 0)"
      | Eunseq [e]      -> !^ "BUG: UNSEQ must have at least two arguments (seen 1)" ^^ (pp_control "[-[-[") ^^ f e ^^ (pp_control "]-]-]")

      | Eunseq es       -> P.parens $ P.sepmap (P.space ^^ (pp_control "||") ^^ P.space) f es
      | Eindet e        -> P.brackets (f e)
      | Eaction (p, (bs, a)) ->
          (* TODO: we need typeclasses to be able to print annotations *)
          (* (if Set.is_empty bs then P.empty else P.langle ^^ (P.sepmap P.space pp_trace_action (Set.to_list bs)) ^^ P.rangle ^^ P.space) ^^ *)
          (match p with
            | Pos -> P.empty
            | Neg -> P.tilde
           end) ^^
          (match a with
            | Create ty      -> pp_keyword "create" ^^ P.braces (f ty)
            | Alloc a        -> pp_keyword "alloc" ^^^ f a
            | Kill e         -> pp_keyword "kill" ^^^ f e
            | Store ty e1 e2 -> pp_keyword "store" ^^ P.braces (f ty) ^^^ f e1 ^^^ f e2
            | Load ty e      -> pp_keyword "load" ^^ P.braces (f ty) ^^^ f e
           end)
      
      | Esame a1 a2     -> pp_keyword "same" ^^^ f a1 ^^^ f a2
(*
      | Kmax ty         -> pp_keyword "max" ^^ P.braces (Ail.Print.pp_type ty)
      | Kmin ty         -> pp_keyword "min" ^^ P.braces (Ail.Print.pp_type ty)
      | Ksizeof ty      -> pp_keyword "sizeof" ^^ P.braces (Ail.Print.pp_type ty)
      | Kalignof ty     -> pp_keyword "alignof" ^^ P.braces (Ail.Print.pp_type ty)
      | Koffsetof ty    -> pp_keyword "offset" ^^ P.braces (Ail.Print.pp_type ty)
      | Kshift a e      -> pp_keyword "shift" ^^^ pp_symbol a ^^^ f e
      | Kconv ty1 ty2 a -> pp_keyword "conv" ^^ P.braces (Ail.Print.pp_type ty1 ^^ !^"\\" ^^ Ail.Print.pp_type ty2) ^^^ pp_symbol a
*)
      | Esave l e      -> pp_keyword "save" ^^^ pp_symbol l ^^ P.dot ^^^ f e
      | Erun l         -> pp_keyword "run" ^^^ pp_symbol l
      | End es         -> P.brackets $ P.sepmap (P.space ^^ (pp_control ";") ^^ P.space) f es

  end
  
  let pp_file file =
    let pp_argument (aname, atype) = pp_symbol aname ^^ P.colon ^^^ pp_core_base_type atype in
    let f acc (fname, (ftype, args, body)) =
      acc ^^
      pp_keyword "fun" ^^^ pp_symbol fname ^^^ P.parens (P.sepmap P.comma pp_argument args) ^^ P.colon ^^^ pp_core_type ftype ^^^ P.equals ^^
      P.nest 2 (P.break1 ^^ pp_expr None body) ^^ P.break1 ^^ P.break1 in
    
    let (_, _, main_body) = Pmap.find file.main file.fun_map in (* TODO: main args *)
    List.fold_left f P.empty (Ocaml.Pmap.bindings (Ocaml.Pmap.remove file.main file.fun_map)) ^^
    pp_expr None main_body ^^ P.break1
  end


let string_of_expr e = Document.to_plain_string $ Print.pp_expr None e

