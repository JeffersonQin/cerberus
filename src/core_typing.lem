open Core
open Errors

(* -------------------------------------------------------------------------- *)
module Effect = struct
  type error 'a =
    | Success of 'a
    | Error of cause
  
  type sym_env = Pmap.map sym core_base_type
  type fun_env = Pmap.map sym (list core_base_type * core_type)
  
  type t 'a = State.t (error 'a) (sym_env * fun_env)
  
  let return x = State.return (Success x)
  let bind m f = State.bind m function
                                | Success x -> f x
                                | Error msg -> State.return (Error msg)
                              end
  let fmap = State.map
  
  
  module Operators = struct
    let (>>=)    = bind
    val (>>): forall 'a 'b. t 'a -> t 'b -> t 'b
    let (>>) m f = m >>= fun _ -> f
    let (<$>)    = fmap
  end
  
  let string_of_senv senv =
    List.fold_right (fun (x,_) acc -> Symbol.to_string_pretty x ^ "; " ^ acc) (Ocaml.Pmap.bindings senv) ""
  
  let get a = fun (senv, fenv) ->
      let ret = if Pmap.mem a senv then Success (Pmap.find a senv)
                                   else Error (* CORE_TYPECHECK_GET_FAILURE *)
                                              (CORE_TYPECHECK ("[get]> " ^ string_of_senv senv ^ " | " ^ Symbol.to_string_pretty a))
      in (ret, (senv,fenv))
  
  let get_fun f = fun (senv, fenv) ->
    let ret = if Pmap.mem f fenv then Success (Pmap.find f fenv)
                                 else Error (CORE_TYPECHECK_UNDECLARED_FUNCTION f)
    in (ret, (senv,fenv))
  
  let put a baseTy = fun (senv,fenv) -> (Success (), (Pmap.add a baseTy senv, fenv))
  
  let put_fun f coreTy = fun (senv,fenv) -> (Success (), (senv, Pmap.add f coreTy fenv))

  
  val fail: forall 'a. Errors.cause -> t 'a
  let fail cause       = fun env -> (Error cause, env)
  val guard: bool -> Errors.cause -> t unit
  let guard cond cause = if cond then return () else fail cause
  
  let run = State.run
  
  open Operators
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)
  
  let sequence_ ms = List.fold_right (>>) ms (return ())
  val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
  let mapM_ f _as = sequence_ (List.map f _as)
end

let ($) f x = f x

(* ---------------------------------------------------------------------------------------------- *)

module E = Effect
open E.Operators

let is_arithOp = function
  | OpAdd -> true
  | OpSub -> true
  | OpMul -> true
  | OpDiv -> true
  | OpMod -> true
  | _     -> false
end

let is_relOp = function
  | OpEq -> true
  | OpLt -> true
  | _    -> false
end

let is_connective = function
  | OpAnd -> true
  | OpOr  -> true
  | _     -> false
end

let base_type = function
  | TyBase baseTy   -> baseTy
  | TyEffect baseTy -> baseTy
  end

let base_type_to_list = function
  | tuple coreTys -> coreTys
  | coreTy        -> [coreTy]
  end

let core_type_eq coreTy1 coreTy2 =
  match (coreTy1, coreTy2) with
    | (TyBase wildcard, TyBase _) -> true
    | (TyBase _, TyBase wildcard) -> true
    | (TyEffect wildcard, TyEffect _) -> true
    | (TyEffect _, TyEffect wildcard) -> true
    | (TyBase baseTy1,   TyBase baseTy2) -> baseTy1 = baseTy2
    | (TyEffect baseTy1, TyEffect baseTy2) -> baseTy1 = baseTy2
    | _ -> false (* TODO: check *)
  end


let rec check expected_type e =
  let guard_expected ty = E.guard (expected_type = ty) (CORE_TYPECHECK_INCORRECT_EXPECTED ty expected_type) in
  match expected_type with
    | TyBase wildcard -> E.return () (* TODO: remove wildcard *)
    | _               ->
        match e with
          | COMMENT _ e -> check expected_type e
          | DEBUG msg   -> E.fail (Errors.CORE_TYPECHECK ("(check) found a DEBUG: `" ^ msg ^ "'."))
          
          | Kconst n -> guard_expected (TyBase value)
          | Ksym a -> E.get a >>= fun baseTy_a ->
                      guard_expected (TyBase baseTy_a)
          
          | Kop op e1 e2 ->
              let check_arith =
                check (TyBase value) e1 >>
                check (TyBase value) e2 >>
                guard_expected (TyBase value)   in
              let check_rel =
                check (TyBase value) e1 >>
                check (TyBase value) e2 >>
                guard_expected (TyBase boolean) in
              let check_logic =
                check (TyBase boolean) e1 >>
                check (TyBase boolean) e2 >>
                guard_expected (TyBase boolean) in
              match op with
                | OpAdd -> check_arith
                | OpSub -> check_arith
                | OpMul -> check_arith
                | OpDiv -> check_arith
                | OpMod -> check_arith
                | OpEq  -> check_rel
                | OpLt  -> check_rel
                | OpAnd -> check_logic
                | OpOr  -> check_logic
              end
          
          | Ktrue  -> guard_expected (TyBase boolean)
          | Kfalse -> guard_expected (TyBase boolean)
          | Knot e -> check (TyBase boolean) e >> guard_expected (TyBase boolean)
          
          | Kctype ty -> guard_expected (TyBase ctype)
          
          | Klet _as e1 e2 -> infer e1 >>= fun coreTy_e1 ->
                              match coreTy_e1 with
                                | TyEffect _       -> E.fail CORE_TYPECHECK_LET_EFFECT
                                | TyBase baseTy_e1 ->
                                match baseTy_e1 with
                                  | tuple baseTys -> if List.length _as <> List.length baseTys
                                                       then E.fail $ CORE_TYPECHECK_LET_INCOMPATIBLE_ARITY (List.length _as) (List.length baseTys)
                                                       else E.return ()
                                  | _             -> if List.length _as <> 1
                                                       then E.fail $ CORE_TYPECHECK_LET_INCOMPATIBLE_ARITY (List.length _as) 1
                                                       else let [a] = _as in
                                                            E.put a baseTy_e1 >>
                                                            check expected_type e2
                                end >>
                                E.fail Core_TYPECK "TODO"
                              end
          
          | Kif b e1 e2 -> check (TyBase boolean) b >>
                           check expected_type e1   >>
                           check expected_type e2

          | Kcall f args -> E.get_fun f >>= fun (baseTys_vars, coreTy_return) ->
                            if List.length args <> List.length baseTys_vars
                              then E.fail $ CORE_TYPECHECK_CALL_NUMBER_OF_ARGUMENTS (List.length args) (List.length baseTys_vars)
                              else E.mapM_ (fun (arg, baseTy) -> check (TyBase baseTy) arg) (List.combine args baseTys_vars) >>
                              guard_expected coreTy_return



          | Kundef -> E.return () (* TODO: check *)
          | Kerror -> E.return () (* TODO: check *)

          | Kskip -> guard_expected (TyBase unit)
          
          | Kseq sop _as e1 e2 -> E.fail (Errors.CORE_TYPECHECK "TODO(check seq)")
          | Kunseq es          -> E.fail (Errors.CORE_TYPECHECK "TODO(check unseq)")
          | Kindet e           -> E.fail (Errors.CORE_TYPECHECK "TODO(check indet)")

          | Kcreate ty      -> check (TyBase ctype) ty >> guard_expected (TyEffect address)
          | Kalloc n        -> check (TyBase value) n  >> guard_expected (TyEffect address)
          
          | Kkill a         -> E.get a >>= fun baseTy_sym ->
                               E.guard (baseTy_sym = address) (CORE_TYPECHECK_INCORRECT_EXPECTED (TyBase baseTy_sym) (TyBase address)) >>
                               guard_expected (TyEffect unit)
          
          | Kstore ty e1 e2 -> check (TyBase ctype)   ty >>
                               check (TyBase address) e1 >>
                               check (TyBase value)   e2 >>
                               guard_expected (TyEffect unit)
          | Kload ty e      -> check (TyBase address) e >> guard_expected (TyEffect value)

          | Ksame a1 a2 -> check (TyBase address) a1 >>
                           check (TyBase address) a2 >>
                           guard_expected (TyBase unit) (* TODO: base or effect ???? *)
        end
  end

and infer e =
  match e with
    | COMMENT _ e -> infer e
    | DEBUG msg   -> E.fail (Errors.CORE_TYPECHECK ("(infer) found a DEBUG: `" ^ msg ^ "'."))
    
   (*
    +  ------------- (const)
    +  Γ ⊢ n : value
    ----------------------------------------------------------------------------------------------*)
    | Kconst n ->
        E.return (TyBase value)
    
    
   (*
    +  (α,T) ∈ Γ
    +  ------------- (sym)
    +  Γ ⊢ α : T
    ----------------------------------------------------------------------------------------------*)
    | Ksym a   ->
        E.get a             >>= fun baseTy_a ->
        E.return (TyBase baseTy_a)
    
    
   (*
    +  Γ ⊢ e1 : value                                    Γ ⊢ e1 : boolean
    +  Γ ⊢ e2 : value   • ∈ {+,-,*,/,%,=,<}              Γ ⊢ e2 : boolean    • ∈ {∧,∨}
    +  ------------------------------------ (op_arith)   ----------------------------- (op_bool)
    +          Γ ⊢ e1 • e2 : value                           Γ ⊢ e1 • e2 : boolean
    ----------------------------------------------------------------------------------------------*)
    | Kop op e1 e2 ->
        let op_type = if is_arithOp op || is_relOp op then TyBase value
                                                      else TyBase boolean in
        check op_type e1 >>
        check op_type e2 >>
        E.return op_type
    
    
   (*
    +  ------------------ (true)    ------------------- (false)
    +  Γ ⊢ true : boolean           Γ ⊢ false : boolean
    ----------------------------------------------------------------------------------------------*)
    | Ktrue  -> E.return (TyBase boolean)
    | Kfalse -> E.return (TyBase boolean)
    
    
   (*
    +    Γ ⊢ e : boolean
    +  ------------------- (not)
    +  Γ ⊢ not e : boolean
    ----------------------------------------------------------------------------------------------*)
    | Knot e ->
        check (TyBase boolean) e  >>
        E.return (TyBase boolean)
    
    
   (*
    +  ------------- (ty)
    +  Γ ⊢ τ : ctype
    ----------------------------------------------------------------------------------------------*)
    | Kctype ty -> E.return (TyBase ctype)
    
    
   (*
    +  Γ ⊢ e1 : T1    (T1 not an effect)
    +  Γ, (α : T1) ⊢ e2 : T2
    +  --------------------------------- (let)
    +    Γ ⊢ let α = e1 in e2 : T2
    ----------------------------------------------------------------------------------------------*)
    | Klet a e1 e2 ->
        infer e1 >>= fun coreTy_e1 ->
        match coreTy_e1 with
          | TyEffect _    -> E.fail (Errors.CORE_TYPECHECK "the first argument of a let must be a \
                                                            pure expression")
          | TyBase (tuple _) -> E.fail (CORE_TYPECHECK "TODO msg: the first operand of a let cannot be a tuple")
          | TyBase baseTy    -> E.put a baseTy >>
                                infer e2
        end
    
    
   (* ---------------------------------------------------------------------------------------------
    +        Γ ⊢ b : boolean                                        Γ ⊢ b : boolean               +
    +    Γ ⊢ e1 : T    Γ ⊢ e2 : T                              Γ ⊢ e1 : T*    Γ ⊢ e2 : T          +
    +  ---------------------------- (if1)                    ----------------------------- (if2)  +
    +  Γ ⊢ if b then e1 else e2 : T                          Γ ⊢ if b then e1 else e2 : T*        +
    +                                                                                             +
    +                                                                                             +
    +        Γ ⊢ b : boolean                                        Γ ⊢ b : boolean               +
    +    Γ ⊢ e1 : T    Γ ⊢ e2 : T*                             Γ ⊢ e1 : T*    Γ ⊢ e2 : T*         +
    +  ----------------------------- (if3)                   ----------------------------- (if4)  +
    +  Γ ⊢ if b then e1 else e2 : T*                         Γ ⊢ if b then e1 else e2 : T*        +
    --------------------------------------------------------------------------------------------- *)
    | Kif b e1 e2 ->
        check (TyBase boolean) b        >>
        infer e1                        >>= fun coreTy_e1 ->
        infer e2                        >>= fun coreTy_e2 ->
        let (baseTy_e1, baseTy_e2, retTy) =
          match (coreTy_e1, coreTy_e2) with
            | (TyBase baseTy1,   TyBase baseTy2)   -> (baseTy1, baseTy2, TyBase)
            | (TyBase baseTy1,   TyEffect baseTy2) -> (baseTy1, baseTy2, TyEffect)
            | (TyEffect baseTy1, TyBase baseTy2)   -> (baseTy1, baseTy2, TyEffect)
            | (TyEffect baseTy1, TyEffect baseTy2) -> (baseTy1, baseTy2, TyEffect)
          end
        in
        E.guard (baseTy_e1 = baseTy_e2)
                Errors.CORE_TYPECHECK_IF_BRANCHES >>
        E.return (retTy baseTy_e1)
    
    
    | Kcall f args ->
        E.get_fun f >>= fun (baseTys_vars, coreTy_return) ->
        (* display an error if the wrong number of arguments is provided *)
        if List.length args <> List.length baseTys_vars
          then E.fail $ Errors.CORE_TYPECHECK_CALL_NUMBER_OF_ARGUMENTS (List.length args) (List.length baseTys_vars)
          else E.mapM_ (fun (arg, baseTy) -> check (TyBase baseTy) arg) (List.combine args baseTys_vars) >>
               E.return coreTy_return


(*
        E.mapM infer args >>= fun coreTys_args ->
        if List.length baseTys_vars <> List.length coreTys_args
          then E.fail (Errors.CORE_TYPECHECK_CALL_NUMBER_OF_ARGUMENTS)
          else E.mapM_
                 (fun (baseTy_expected, coreTy_found) ->
                    match coreTy_found with
                      | TyBase baseTy_found ->
                          if baseTy_expected = baseTy_found
                            then E.return ()
                            else E.fail (Errors.CORE_TYPECHECK_INCORRECT_EXPECTED
                                         coreTy_found (TyBase baseTy_expected))
                      | _ -> E.fail Errors.CORE_TYPECHECK_CALL_ARGUMENT_EFFECT
                  end)
                 (List.combine baseTys_vars coreTys_args) >>
               E.return coreTy_ret
*)

(*               E.return (TyBase wildcard) (* E.fail "TODO(infer call)" *) *)
    
(*
    | Kunseq es ->
      E.mapM infer es >>= fun coreTys ->
      E.return $
        List.fold_left
          (fun acc coreTy ->
             let base   x        = TyBase x   in
             let effect x        = TyEffect x in
             let (kind, baseTys) = match acc with
                                     | TyBase (tuple baseTys)   -> (base,   baseTys)
                                     | TyEffect (tuple baseTys) -> (effect, baseTys)
                                   end in
             match coreTy with
               | TyBase   baseTy -> kind (tuple (baseTy :: baseTys))
               | TyEffect baseTy -> TyEffect (tuple (baseTy :: baseTys))
             end)
          (TyBase (tuple [])) coreTys
    
*)








    
   (*
    +  ------------- (undef)    ------------- (error)
    +  Γ ⊢ undef : _            Γ ⊢ error : _
    ----------------------------------------------------------------------------------------------*)
    | Kundef -> E.return (TyBase wildcard)
    | Kerror -> E.return (TyBase wildcard)
    
    
   (*
    +  --------------- (skip)
    +  Γ ⊢ skip : unit
    ----------------------------------------------------------------------------------------------*)
    | Kskip -> E.return (TyBase unit)
    
    
   (*
    +  Γ ⊢ e1 : T1
    +  Γ, (_αs : T1) ⊢ e2 : T2
    +  ------------------------------------------------------- (let)
    +    Γ ⊢ let _αs = e1 in e2 : [the effectful version of T2 if not already effectful]
    ----------------------------------------------------------------------------------------------*)
    | Kseq sop _as e1 e2 ->
        infer e1 >>= fun coreTy_e1 ->
        let baseTys = base_type_to_list (base_type coreTy_e1) in
        let n = List.length _as in
        let m = List.length baseTys in
        if n <> m && n>0 then
          E.fail (Errors.CORE_TYPECHECK_SEQ_INCOMPATIBLE_ARITY n m)
        else
          (if n = 0 then
             E.return ()
           else
             E.mapM_ (fun (a,coreTy) -> E.put a coreTy) (List.combine _as baseTys)) >>
          infer e2 >>= fun coreTy_e2 ->
          E.return $
            match coreTy_e2 with
              | TyEffect _    -> coreTy_e2
              | TyBase baseTy -> match coreTy_e1 with
                                   | TyEffect _ -> TyEffect baseTy
                                   | TyBase _   -> coreTy_e2
                                 end
            end
    
    
   (*
    +    Γ ⊢ e1 : T1*   ...   Γ ⊢ ek : Tk*
    +  ----------------------------------- (unseq)
    +  Γ ⊢ e1 || ... || ek : T*
    ----------------------------------------------------------------------------------------------*)
    | Kunseq es ->
      E.mapM infer es >>= fun coreTys ->
      if List.exist (function TyBase _ -> true | _ -> false end) coreTys then
        E.fail Errors.CORE_TYPECHECK_UNSEQ_PURE
      else
        E.return $ TyEffect (tuple (List.map (function TyEffect b -> b end) coreTys))
(*
      E.return $
        List.fold_left
          (fun acc coreTy ->
             let base   x        = TyBase x   in
             let effect x        = TyEffect x in
             let (kind, baseTys) = match acc with
                                     | TyBase (tuple baseTys)   -> (base,   baseTys)
                                     | TyEffect (tuple baseTys) -> (effect, baseTys)
                                   end in
             match coreTy with
               | TyBase   baseTy -> kind (tuple (baseTy :: baseTys))
               | TyEffect baseTy -> TyEffect (tuple (baseTy :: baseTys))
             end)
          (TyBase (tuple [])) (List.rev coreTys)
*)
    
   (*
    +   Γ ⊢ e : T              Γ ⊢ e : T
    +  ----------- (intet)    ----------- (atom)
    +  Γ ⊢ [e] : T            Γ ⊢ {e} : T
    ----------------------------------------------------------------------------------------------*)
    | Kindet e -> infer e
    
    
   (*
    +  ------------------------ (create)
    +  Γ ⊢ create{τ} : address*
    ----------------------------------------------------------------------------------------------*)
    | Kcreate ty -> E.return (TyEffect address)
    
    
   (*
    +      Γ ⊢ e : value
    +  ---------------------- (alloc)
    +  Γ ⊢ alloc e : address*
    ----------------------------------------------------------------------------------------------*)
    | Kalloc e   ->
        check (TyBase value) e >>
        E.return (TyEffect address)
    
    
   (*
    +   Γ ⊢ e : address
    +  ------------------ (kill)
    +  Γ ⊢ kill e : unit*
    ----------------------------------------------------------------------------------------------*)
    | Kkill a ->
        E.get a                      >>= fun baseTy_a ->
        E.guard (baseTy_a = address)
                (Errors.CORE_TYPECHECK_INCORRECT_EXPECTED (TyBase baseTy_a) (TyBase address)) >>
        E.return (TyEffect unit)
    
    
   (*
    +   Γ ⊢ e1 : address    Γ ⊢ e2 : value
    +  ----------------------------------- (store)
    +      Γ ⊢ store{τ} e1 e2 : unit*
    ----------------------------------------------------------------------------------------------*)
    | Kstore ty e1 e2 ->
        check (TyBase address) e1 >>
        check (TyBase value)   e2 >>
        E.return (TyEffect unit)
    
    
   (*
    +     Γ ⊢ e : address
    +  ---------------------- (load)
    +  Γ ⊢ load{τ} e : value*
    ----------------------------------------------------------------------------------------------*)
    | Kload ty e ->
        check (TyBase address) e >>
        E.return (TyEffect value)
    
    
   (*
    +   (α1,address) ∈ Γ    (α2,address) ∈ Γ
    +  ------------------------------------- (same)
    +         Γ ⊢ same α1 α2 : unit*
    ----------------------------------------------------------------------------------------------*)

(* TODO *)
(*
    | Ksame a1 a2 ->
        E.get a1                        >>= fun baseTy_a1 ->
        E.get a2                        >>= fun baseTy_a2 ->
        E.guard (baseTy_a1 = address)
                (Errors.CORE_TYPECHECK_INCORRECT_EXPECTED (TyBase baseTy_a1) (TyBase address)) >>
        E.guard (baseTy_a2 = address)
                (Errors.CORE_TYPECHECK_INCORRECT_EXPECTED (TyBase baseTy_a2) (TyBase address)) >>
        E.return (TyEffect unit)
    
    | _ -> E.fail (Errors.CORE_TYPECHECK "TODO")
*)
  end


let typecheck file =
  let functions = Ocaml.Pmap.bindings file.fun_map in
  (* collect the symbolic names of the functions for the initial function environment. *)
  let init_fenv =
    List.fold_left (fun acc (fname, (ftype, args, _)) ->
      Pmap.add fname (List.map snd args, ftype) acc) core_stdlib functions in
  Exception.bind
    (List.fold_right
       (fun (fname, (coreTy_return, baseTys_vars, fbody)) acc ->
         Exception.bind acc (fun () ->
           match State.run (E.mapM_ (fun (a, baseTy_a) -> E.put a baseTy_a) baseTys_vars >> check coreTy_return fbody)
                           (Pmap.empty, init_fenv)
           with
             | E.Success () -> Exception.return ()
             | E.Error err  -> Exception.fail err
           end
         )
       ) (Ocaml.Pmap.bindings file.fun_map)
       (Exception.return ()))
    (fun _ -> Exception.return file)
