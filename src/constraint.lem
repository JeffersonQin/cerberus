open Global
open Symbol_state.Operators

type name    = Symbol.t
type address = Symbol.t

type constant =
  | Name of name
  | Integer of num
  | Address of address
  | Null
  | Offset of constant * constant * constant
  | Plus of constant * constant
  | Minus of constant * constant
  | Mod of constant * constant
  | Mult of constant * constant
  | Div of constant * constant
  | Pow of constant
  | BitAnd of constant * constant
  | BitOr of constant * constant
  | BitXor of constant * constant
  | BitComplement of constant
  | Fn of name * constant list

let rec fold_map_const f const i =
  let fm = fold_map_const f in
  match const with
  | Name    _ -> f const i
  | Integer _ -> f const i
  | Address _ -> f const i
  | Null      -> f const i
  | Offset c1 c2 c3 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      let (c3, i) = fm c3 i in
      f (Offset c1 c2 c3) i
  | Plus c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Plus c1 c2) i
  | Minus c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Minus c1 c2) i
  | Mod c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Mod c1 c2) i
  | Mult c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Mult c1 c2) i
  | Div c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Div c1 c2) i
  | Pow c ->
      let (c, i) = fm c i in
      f (Pow c) i
  | BitAnd c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (BitAnd c1 c2) i
  | BitOr c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (BitOr c1 c2) i
  | BitXor c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (BitXor c1 c2) i
  | BitComplement c ->
      let (c, i) = fm c i in
      f (BitComplement c) i
  | Fn s cs ->
      let (cs, i) = List.fold_left
        (fun (cs, i) c -> let (c, i) = f c i in (c::cs, i)) ([], i) cs in
      f (Fn s cs) i
  end

let rec compare_const const1 const2 =
  let (++) = Ord.compose in
  match (const1, const2) with
  | (Name n1, Name n2) ->
      Symbol.compare n1 n2
  | (Address a1, Address a2) ->
      Symbol.compare a1 a2
  | (Null, Null) -> Ord.Eq
  | (Integer i1, Integer i2) ->
      Num_.compare i1 i2
  | (Offset c1 c2 c3, Offset c1' c2' c3') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
      ++ compare_const c3 c3'
  | (Plus c1 c2, Plus c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Minus c1 c2, Minus c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Mod c1 c2, Mod c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Mult c1 c2, Mult c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Div c1 c2, Div c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Pow c1, Pow c2) ->
      compare_const c1 c2
  | (BitAnd c1 c2, BitAnd c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (BitOr c1 c2, BitOr c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (BitXor c1 c2, BitXor c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (BitComplement c1, BitComplement c2) ->
      compare_const c1 c2
  | (Fn n1 cs1, Fn n2 cs2) ->
      List.fold_left2
        (fun r c1 c2 -> r ++ compare_const c1 c2) (Symbol.compare n1 n2) cs1 cs2
  | (Name _         , _) -> Ord.Lt
  | (_, Name _         ) -> Ord.Gt
  | (Integer _      , _) -> Ord.Lt
  | (_, Integer _      ) -> Ord.Gt
  | (Address _      , _) -> Ord.Lt
  | (_, Address _      ) -> Ord.Gt
  | (Null           , _) -> Ord.Lt
  | (_, Null           ) -> Ord.Gt
  | (Offset _ _ _   , _) -> Ord.Lt
  | (_, Offset _ _ _   ) -> Ord.Gt
  | (Plus _ _       , _) -> Ord.Lt
  | (_, Plus _ _       ) -> Ord.Gt
  | (Minus _ _      , _) -> Ord.Lt
  | (_, Minus _ _      ) -> Ord.Gt
  | (Mod _ _        , _) -> Ord.Lt
  | (_, Mod _ _        ) -> Ord.Gt
  | (Mult _ _       , _) -> Ord.Lt
  | (_, Mult _ _       ) -> Ord.Gt
  | (Div _ _        , _) -> Ord.Lt
  | (_, Div _ _        ) -> Ord.Gt
  | (Pow _          , _) -> Ord.Lt
  | (_, Pow _          ) -> Ord.Gt
  | (BitAnd _ _     , _) -> Ord.Lt
  | (_, BitAnd _ _     ) -> Ord.Gt
  | (BitOr _ _      , _) -> Ord.Lt
  | (_, BitOr _ _      ) -> Ord.Gt
  | (BitXor _ _     , _) -> Ord.Lt
  | (_, BitXor _ _     ) -> Ord.Gt
  | (BitComplement _, _) -> Ord.Lt
  | (_, BitComplement _) -> Ord.Gt
  end

let rec is_ground const =
  let f = is_ground in
  match const with
  | Name    _ -> false
  | Integer _ -> true
  | Address _ -> true
  | Null      -> true
  | Offset c1 c2 c3 -> f c1 && f c2 && f c3
  | Plus   c1 c2    -> f c1 && f c2
  | Minus  c1 c2    -> f c1 && f c2
  | Mod    c1 c2    -> f c1 && f c2
  | Mult   c1 c2    -> f c1 && f c2
  | Div    c1 c2    -> f c1 && f c2
  | Pow    c        -> f c
  | BitAnd c1 c2    -> f c1 && f c2
  | BitOr  c1 c2    -> f c1 && f c2
  | BitXor c1 c2    -> f c1 && f c2
  | BitComplement c -> f c
  | Fn s cs -> List.for_all f cs
  end

type constr =
  | True
  | False
  | Eq of constant * constant
  | Le of constant * constant
  | Lt of constant * constant
  | Not of constr
  | Or of constr * constr
  | And of constr * constr
  | Implies of constr * constr
  | If of constr * constr * constr
  | ConvInt of Range.t * constr * constant

let rec fold_constr f_c constr i =
  let f = fold_constr f_c in
  match constr with
  | True  -> i
  | False -> i
  | Eq c1 c2 -> f_c c2 (f_c c1 i)
  | Le c1 c2 -> f_c c2 (f_c c1 i)
  | Lt c1 c2 -> f_c c2 (f_c c1 i)
  | Not c -> f c i
  | Or      c1 c2 -> f c2 (f c1 i)
  | And     c1 c2 -> f c2 (f c1 i)
  | Implies c1 c2 -> f c2 (f c1 i)
  | If     c1 c2 c3 -> f c3 (f c2 (f c1 i))
  | ConvInt _ c1 c2 -> f c1 (f_c c2 i)
  end

let rec fold_map_constr f f_c constr i =
  let fm = fold_map_constr f f_c in
  match constr with
  | Eq c1 c2 ->
      let (c1, i) = f_c c1 i in
      let (c2, i) = f_c c2 i in
      f (Eq c1 c2) i
  | Le c1 c2 ->
      let (c1, i) = f_c c1 i in
      let (c2, i) = f_c c2 i in
      f (Le c1 c2) i
  | Lt c1 c2 ->
      let (c1, i) = f_c c1 i in
      let (c2, i) = f_c c2 i in
      f (Lt c1 c2) i
  | Not c ->
      let (c, i) = fm c i in
      f (Not c) i
  | Or c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Or c1 c2) i
  | And c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (And c1 c2) i
  | Implies c1 c2 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      f (Implies c1 c2) i
  | If c1 c2 c3 ->
      let (c1, i) = fm c1 i in
      let (c2, i) = fm c2 i in
      let (c3, i) = fm c3 i in
      f (If c1 c2 c3) i
  | ConvInt r c1 c2 ->
      let (c1, i) = fm  c1 i in
      let (c2, i) = f_c c2 i in
      f (ConvInt r c1 c2) i
  | _ -> f constr i
  end

let rec compare_constr constr1 constr2 =
  let (++) = Ord.compose in
  match (constr1, constr2) with
  | (Eq c1 c2, Eq c1' c2') ->
      let o1 = (compare_const c1 c1' ++ compare_const c2 c2') in
      if o1 = Ord.Eq
        then o1
        else compare_const c1 c2' ++ compare_const c2 c1'
  | (Le c1 c2, Le c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Lt c1 c2, Lt c1' c2') ->
      compare_const c1 c1'
      ++ compare_const c2 c2'
  | (Not c1, Not c2) ->
      compare_constr c1 c2
  | (Or c1 c2, Or c1' c2') ->
      compare_constr c1 c1'
      ++ compare_constr c2 c2'
  | (And c1 c2, And c1' c2') ->
      compare_constr c1 c1'
      ++ compare_constr c2 c2'
  | (Implies c1 c2, Implies c1' c2') ->
      compare_constr c1 c1'
      ++ compare_constr c2 c2'
  | (If c1 c2 c3, If c1' c2' c3') ->
      compare_constr c1 c1'
      ++ compare_constr c2 c2'
      ++ compare_constr c3 c3'
  | (ConvInt _ c1 _, ConvInt _ c1' _) ->
      compare_constr c1 c1'
  | (True         , _) -> Ord.Lt
  | (_, True         ) -> Ord.Gt
  | (False        , _) -> Ord.Lt
  | (_, False        ) -> Ord.Gt
  | (Eq _ _       , _) -> Ord.Lt
  | (_, Eq _ _       ) -> Ord.Gt
  | (Le _ _       , _) -> Ord.Lt
  | (_, Le _ _       ) -> Ord.Gt
  | (Lt _ _       , _) -> Ord.Lt
  | (_, Lt _ _       ) -> Ord.Gt
  | (Not _        , _) -> Ord.Lt
  | (_, Not _        ) -> Ord.Gt
  | (Or _ _       , _) -> Ord.Lt
  | (_, Or _ _       ) -> Ord.Gt
  | (And _ _      , _) -> Ord.Lt
  | (_, And _ _      ) -> Ord.Gt
  | (Implies _ _  , _) -> Ord.Lt
  | (_, Implies _ _  ) -> Ord.Gt
  | (If _ _ _     , _) -> Ord.Lt
  | (_, If _ _ _     ) -> Ord.Gt
  end

let compare_constr_int c1 c2 = Ord.to_int (compare_constr c1 c2)

val set_compare_int : forall 'a. 'a set -> 'a set -> int
let inline {ocaml} set_compare_int = Ocaml.Pset.compare
let compare_int = set_compare_int

(* TODO compare *)
type t = constr set

let from_list cs = {c | forall (c MEM cs) | true}

let tt = True

let neq c1 c2 = Not (Eq c1 c2)
let eq c1 c2 =
  if compare_const c1 c2 = Ord.Eq then
    Eq c1 c2
  else
    Eq c2 c1
let le c1 c2 = Le c1 c2
let lt c1 c2 = Lt c1 c2
let ge c1 c2 = Le c2 c1
let gt c1 c2 = Lt c2 c1

let add t c = Set.add c t

let fresh         = Name    <$> Symbol_state.fresh
let fresh_named n = Name    <$> Symbol_state.fresh_pretty n
let fresh_address = Address <$> Symbol_state.fresh

let const i = Integer i
let fn name args = Fn name args

let zero = const 0
let one  = const 1

let null = Null

let offset c1 c2 c3 = Offset c1 c2 c3

let plus  c1 c2 = Plus  c1 c2
let minus c1 c2 = Minus c1 c2
let mult  c1 c2 = Mult  c1 c2
let div   c1 c2 = Div   c1 c2
let pow c = Pow c

let modulo c1 c2 = Mod c1 c2

let bit_and c1 c2 = BitAnd c1 c2
let bit_or  c1 c2 = BitOr  c1 c2
let bit_xor c1 c2 = BitXor c1 c2

let neg c = Not c
let conj c1 c2 = And c1 c2
let disj c1 c2 = Or c1 c2
let implies c1 c2 = Implies c1 c2
let case c c1 c2 = If c c1 c2

let conv_int r c1 c2 = ConvInt r c1 c2

let mem c t = c IN t

module Constants = struct
  let undefined  = Name Symbol.undefined
  let char_bit   = Name Symbol.char_bit

  (* Minimum and maximum  values. *)
  let char_min     = Name Symbol.char_min
  let char_max     = Name Symbol.char_max
  let schar_min    = Name Symbol.schar_min
  let schar_max    = Name Symbol.schar_max
  let uchar_max    = Name Symbol.uchar_max
  let shrt_min     = Name Symbol.shrt_min
  let shrt_max     = Name Symbol.shrt_max
  let ushrt_max    = Name Symbol.ushrt_max
  let int_min      = Name Symbol.int_min
  let int_max      = Name Symbol.int_max
  let uint_max     = Name Symbol.uint_max
  let long_min     = Name Symbol.long_min
  let long_max     = Name Symbol.long_max
  let ulong_max    = Name Symbol.ulong_max
  let llong_min    = Name Symbol.llong_min
  let llong_max    = Name Symbol.llong_max
  let ullong_max   = Name Symbol.ullong_max

  (* Byte sizes. *)
  let bool_size    = Name Symbol.bool_size
  let char_size    = Name Symbol.char_size
  let schar_size   = Name Symbol.schar_size
  let uchar_size   = Name Symbol.uchar_size
  let shrt_size    = Name Symbol.shrt_size
  let ushrt_size   = Name Symbol.ushrt_size
  let int_size     = Name Symbol.int_size
  let uint_size    = Name Symbol.uint_size
  let long_size    = Name Symbol.long_size
  let ulong_size   = Name Symbol.ulong_size
  let llong_size   = Name Symbol.llong_size
  let ullong_size  = Name Symbol.ullong_size

  (* Alignment requirements. *)
  let bool_align   = Name Symbol.bool_align
  let char_align   = Name Symbol.char_align
  let schar_align  = Name Symbol.schar_align
  let uchar_align  = Name Symbol.uchar_align
  let shrt_align   = Name Symbol.shrt_align
  let ushrt_align  = Name Symbol.ushrt_align
  let int_align    = Name Symbol.int_align
  let uint_align   = Name Symbol.uint_align
  let long_align   = Name Symbol.long_align
  let ulong_align  = Name Symbol.ulong_align
  let llong_align  = Name Symbol.llong_align
  let ullong_align = Name Symbol.ullong_align

  let return = Name Symbol.return

  let to_char  = Symbol.to_char
  let to_shrt  = Symbol.to_shrt
  let to_int   = Symbol.to_int
  let to_long  = Symbol.to_long
  let to_llong = Symbol.to_llong
end

let undef = eq one Constants.undefined

module Print = struct
  module P = Pprint
  module U = P.Unicode

  open Global
  open Pprint.Operators

  let nbraces d = P.lbrace ^^ P.group2 (P.break0 ^^ d) ^/^ P.rbrace

  let rec pp_constant_inner f_s const =
    let f = P.parens -| pp_constant_inner f_s in
    let fp = pp_constant_inner f_s in
    match const with
    | Null -> U.null
    | Name    s -> !^ (f_s s)
    | Integer i -> !^ (string_of_num i)
    |  Address s ->
        !^ "addr" ^^^ P.parens (!^ (f_s s))
    | Offset base offset size ->
        !^ "offset" ^^^ P.parens (fp base ^^ P.comma ^^^ fp offset ^^^ P.star ^^^ fp size)
    | Plus  c1 c2 -> f c1 ^^^ P.plus    ^^^ f c2
    | Minus c1 c2 -> f c1 ^^^ P.minus   ^^^ f c2
    | Mult  c1 c2 -> f c1 ^^^ P.star    ^^^ f c2
    | Mod   c1 c2 -> f c1 ^^^ P.percent ^^^ f c2
    | Div   c1 c2 -> f c1 ^^^ P.slash   ^^^ f c2
    | Pow c -> !^ "2" ^^ P.caret ^^ f c
    | BitAnd c1 c2 -> !^ "bitand" ^^^ P.parens (f c1 ^^ P.comma ^^^ f c2)
    | BitOr  c1 c2 -> !^ "bitor"  ^^^ P.parens (f c1 ^^ P.comma ^^^ f c2)
    | BitXor c1 c2 -> !^ "xor"    ^^^ P.parens (f c1 ^^ P.comma ^^^ f c2)
    | BitComplement c -> !^ "compl" ^^^ P.parens (f c)
    | Fn name args    -> !^ (f_s name)   ^^^ P.parens (P.comma_list f args)
    end

  let rec pp_constr_inner f_s constr =
    let f = P.parens -| pp_constr_inner f_s in
    let f_c = pp_constant_inner f_s in
    match constr with
    | True  -> !^ "true"
    | False -> !^ "false"
    | Eq      c1 c2 -> f_c c1 ^^^ P.equals  ^^^ f_c c2
    | Le      c1 c2 -> f_c c1 ^^^ U.le      ^^^ f_c c2
    | Lt      c1 c2 -> f_c c1 ^^^ P.langle  ^^^ f_c c2
    | Or      c1 c2 -> f   c1 ^^^ U.disj    ^^^ f   c2
    | And     c1 c2 -> f   c1 ^^^ U.conj    ^^^ f   c2
    | Implies c1 c2 -> f   c1 ^^^ U.implies ^^^ f   c2
    | Not c -> U.compl ^^^ f c
    | If c1 c2 c3 ->
        !^ "if" ^^^ f c1 ^^^ !^ "then" ^^^ f c2 ^^^ !^ "else" ^^^ f c3
    | ConvInt _ c1 _ -> pp_constr_inner f_s c1
    end

  let pp_constant_latex = pp_constant_inner Symbol.to_string_latex
  let pp_constant = pp_constant_inner Symbol.to_string_pretty
  let pp_constr = pp_constr_inner Symbol.to_string_pretty

  let rec pp t = U.conj ^^ nbraces (P.comma_list pp_constr  (Set.to_list t))

  let pp_set ts = P.sepmap P.break1 pp (Set.to_list ts)
end

module Solver = struct
  open Global

  module Cc = Congruence_closure

  let n_null = 0
  let n_offset = 1
  let n_plus = 2
  let n_minus = 3
  let n_modulo = 4
  let n_mult = 5
  let n_div = 6
  let n_pow = 7
  let n_bitand = 8
  let n_bitor = 9
  let n_bitxor = 10
  let n_bitcomplement = 11
  let n_fn = 12

  type p = <|
    t : t;
    eqs : t;
    cc : Cc.t;
    counter : num;
    int_map : (num, num) map;
    name_map : (Symbol.t, num) map;
    const_map : (num, constant) map;
    apply_map : (num * num, num) map;
  |>

  let n_fresh p =
    let n = p.counter + 1 in
    if n + 1 < Cc.size p.cc then
      (n, <|p with counter = n|>)
    else
      (* TODO grow *)
      (n, <|p with counter = n(*; cc = Cc.grow p.cc (Cc.size p.cc)*)|>)

  let convert_name p s =
    match Map_.find s p.name_map with
    | Some n -> (n, p)
    | None   ->
        let (n, p) = n_fresh p in
        (n, <|p with name_map = Pmap.add s n p.name_map|>)
    end

  let convert_addr p a =
    match Map_.find a p.name_map with
    | Some n -> (n, p)
    | None   ->
        let (n, p) = n_fresh p in
        let p = <|p with
          name_map = Pmap.add a n p.name_map;
          const_map = Pmap.add n (Address a) p.const_map
        |> in
        (n, p)
     end

  let convert_int p i =
    match Map_.find i p.int_map with
    | Some n -> (n, p)
    | None   ->
        let (n, p) = n_fresh p in
        let p = <|p with
          int_map = Pmap.add i n p.int_map;
          const_map = Pmap.add n (Integer i) p.const_map
        |> in
        (n, p)
    end

  let apply p n1 n2 =
    match Map_.find (n1, n2) p.apply_map with
    | Some n -> (n, p)
    | None   ->
        let (n, p) = n_fresh p in
        let p = <|p with
          apply_map = Pmap.add (n1, n2) n p.apply_map;
          cc = Cc.merge p.cc (Cc.Apply (n1, n2)) n
        |> in
        (n, p)
    end

  let rec convert_const c p =
    let f = convert_const in
    let f_a = apply in
    let chain i cs = List.fold_left
      (fun (n, p) c ->
        let (n', p') = f c p in
        f_a p' n n'
      ) i cs in
    let f1 n c        = chain (n, p) [c] in
    let f2 n c1 c2    = chain (n, p) [c1; c2] in
    let f3 n c1 c2 c3 = chain (n, p) [c1; c2; c3] in
    match c with
    | Null -> (n_null, p)
    | Name    n -> convert_name p n
    | Integer i -> convert_int p i
    | Address a -> convert_addr p a
    | Pow c -> f1 n_pow c
    | Plus   c1 c2 -> f2 n_plus   c1 c2
    | Minus  c1 c2 -> f2 n_minus  c1 c2
    | Mod    c1 c2 -> f2 n_modulo c1 c2
    | Mult   c1 c2 -> f2 n_mult   c1 c2
    | Div    c1 c2 -> f2 n_div    c1 c2
    | BitAnd c1 c2 -> f2 n_bitand c1 c2
    | BitOr  c1 c2 -> f2 n_bitor  c1 c2
    | BitXor c1 c2 -> f2 n_bitxor c1 c2
    | BitComplement c -> f1 n_bitcomplement c
    | Offset c1 c2 c3 ->
        let (n, p) = f3 n_offset c1 c2 c3 in
        if Pmap.mem n p.const_map then
          (n, p)
        else
          (n, <|p with const_map = Pmap.add n (Offset c1 c2 c3) p.const_map|>)
    | Fn s cs -> chain (convert_name p s) cs
    end

  let lift p f = Set.fold f p.t p
  let lift_const p f = lift p (fold_constr f)

  let init_convert p = lift_const p (fun c p -> snd (convert_const c p))

  let collect p b constr =
    match constr with
    | Eq c1 c2 ->
        let (n1, p1) = convert_const c1 p  in
        let (n2, p2) = convert_const c2 p1 in
        (true, <|p2 with
          cc = Cc.merge_constants p2.cc n1 n2;
          eqs = Set.add constr p.eqs
        |>)
    | _ -> (b, p)
    end

  let collect_eqs p = Set.fold (fun c (b, p) -> collect p b c) p.t (false, p)

  let check_unsat p = if False IN p.t then <|p with t = {False}|> else p

  let normalise_const p c =
    let (n, p) = convert_const c p in
    let (n, cc') = Cc.normalise_constant p.cc n in
    (n, <|p with cc = cc'|>)

  let simplify_const const p =
    let simplify const p =
      let replace c =
        let (n1, p1) = normalise_const p const in
        let (n2, p2) = normalise_const p1 c in
        (c, <|p2 with cc = Cc.merge_constants p.cc n1 n2|>) in
      match const with
      | Offset a (Integer 0) _ ->
          replace a
      | Offset (Offset a o1 s1) o2 s2 ->
          if compare_const s1 s2 = Ord.Eq then
            replace (Offset a (Plus o1 o2) s1)
          else (const, p)
      | Plus (Integer i1) (Integer i2) ->
          replace (Integer (i1 + i2))
      | Minus (Integer i1) (Integer i2) ->
          replace (Integer (i1 - i2))
      | Mult (Integer i1) (Integer i2) ->
          replace (Integer (i1 * i2))
      | Mod (Integer i1) (Integer i2) ->
          if i2 <> 0 then
            replace (Integer (Ocaml.Nat_num.(%) i1 i2))
          else (const, p)
      | Div (Integer i1) (Integer i2) ->
          if i2 <> 0 then
            replace (Integer (i1 / i2))
          else (const, p)
      | Pow (Integer i) ->
          replace (Integer (Ocaml.Nat_num.( ** ) 2 i))
      | Name _ ->
          let (n, p) = normalise_const p const in
          let n =
            match Map_.find n p.const_map with
            | Some n' -> n'
            | None -> const
            end in
          (n, p)
      | _ -> (const, p)
      end in
    fold_map_const simplify const p

  let simplify p =
    let simplify_constr constr p =
      let merge p c1 c2 =
        let (n1, p1) = normalise_const p c1 in
        let (n2, p2) = normalise_const p1 c2 in
        <|p2 with cc = Cc.merge_constants p.cc n1 n2|> in
      match constr with
      | Not False -> (True,  p)
      | Not True  -> (False, p)
      | Or True  _     -> (True,  p)
      | Or _     True  -> (True,  p)
      | Or False False -> (False, p)
      | Or c1    False -> (c1, p)
      | Or False c2    -> (c2, p)
      | And False _     -> (False, p)
      | And _     False -> (False, p)
      | And True  True  -> (True,  p)
      | And c1    True  -> (c1,    p)
      | And True  c2    -> (c2,    p)
      | Implies False _     -> (True,   p)
      | Implies True  c2    -> (c2,     p)
      | Implies c1    True  -> (True,   p)
      | Implies c1    False -> (Not c1, p)
      | If True  c2 _  -> (c2, p)
      | If False _  c3 -> (c3, p)
      | Le (Integer i1) (Integer i2) ->
          ((if i1 <= i2 then True else False), p) (* TODO: the parenthesis around the if are required
                                                           for a proper translation to Ocaml *)
      | Lt (Integer i1) (Integer i2) ->
          ((if i1 <  i2 then True else False), p) (* the same here. For some reason the sed in the Makefile stopped working?*)
      | Lt (Address a1) (Address a2) ->
          if a1 = a2
            then (False,  p)
            else (constr, p)
      | Lt a1 (Offset a2' (Integer i2) s2) ->
          if compare_const a1 a2' = Ord.Eq then
            if 0 < i2
              then (True, p)
              else (False, p)
          else
            match a1 with
            | Offset a1' (Integer i1) s1 ->
                if compare_const a1' a2' = Ord.Eq && compare_const s1 s2 = Ord.Eq then
                  if i1 < i2
                    then (True, p)
                    else (False, p)
                else (constr, p)
            | _ -> (constr, p)
            end
      | Eq Null (Address _) -> (False, p)
      | Eq (Address _) Null -> (False, p)
      | Eq Null (Offset _ _ _) -> (False, p)
      | Eq (Offset _ _ _) Null -> (False, p)
      | Eq (Integer i1) (Integer i2) ->
          if i1 = i2
            then (True,  p)
            else (False, p)
      | Eq (Address a1) (Address a2) ->
          if a1 = a2
            then (True,  p)
            else (False, p)
      | Eq c1 c2 ->
          let (n1, p1) = normalise_const p  c1 in
          let (n2, p2) = normalise_const p1 c2 in
          if compare_const c1 c2 = Ord.Eq then
            (True, merge p2 c1 c2)
          else
            let (b, cc') = Cc.congruent_constants p.cc n1 n2 in
            let p3 = <|p2 with cc = cc'|> in
            if b
              then (True,   p3)
              else (constr, p3)
      | Le c1 c2 ->
          let (n1, p1) = normalise_const p  c1 in
          let (n2, p2) = normalise_const p1 c2 in
          let (b, cc') = Cc.congruent_constants p.cc n1 n2 in
          let p3 = <|p2 with cc = cc'|> in
          if b
            then (True,   p3)
            else (constr, p3)
      | ConvInt r (If _ c2 _) (Integer i) ->
          if Range.in_range r i
            then (c2, p)
            else (constr, p)
      | _ -> (constr, p)
      end in
    let simplify_all = fold_map_constr simplify_constr simplify_const in
    let (p, t') = Set_.fold_map simplify_all p.t p in
    <|p with t = t'|>

  let normalise_const_map p =
    let norm p m n c =
      let (c, p) =
        match c with
        | Offset _ _ _ -> simplify_const c p
        | _            -> (c, p) 
        end in
      let (n, cc') = Cc.normalise_constant p.cc n in
      (Pmap.add n c m, <|p with cc = cc'|>) in
    let (m, p) = List.fold_left
      (fun (m, p) (n, c) -> norm p m n c)
      (Pmap.empty, p)
      (Ocaml.Pmap.bindings p.const_map) in
    <|p with const_map = m|>

  let convert = fold_constr (fun c p -> snd (convert_const c p))

  let rec simplify_loop p =
    let rewrite p = 
      normalise_const_map p
      >|> simplify
      >|> check_unsat in
    match collect_eqs (rewrite p) with
    | (true,  p) -> simplify_loop p
    | (false, p) -> p
    end

  let add_constr p constr =
    let p = convert constr p in
    snd (collect_eqs <|p with t = add p.t constr|>)

  let make t' =
    let p = <|
      t = t';
      eqs = {};
      cc = Cc.make 2048;
      counter = n_fn;
      int_map = Pmap.empty;
      name_map = Pmap.empty;
      const_map = Pmap.empty;
      apply_map = Pmap.empty;
    |> in
    simplify_loop (init_convert p)

  let complete p =
    let p = simplify_loop p in
    p.t union p.eqs

  let add_constraints p c = Set.fold (fun constr p -> add_constr p constr) c p

  let rewrite p const = simplify_const const (snd (convert_const const p))

  type address =
    | Base of Symbol.t
    | Displaced of Symbol.t * num * constant
    | NullAddress
    | NaA

  let address_aux = function
    | Address a ->
        Some (Base a)
    | Offset (Address a) (Integer i) (Name n) ->
        Some (Displaced a i (Name n))
    | Null ->
        Some NullAddress
    | _ -> None
  end

  let address p const =
    let (const, p) = rewrite p const in
    match address_aux const with
    | Some addr -> (addr, p)
    | None ->
        let (const, p) = rewrite (simplify_loop p) const in
        match address_aux const with
        | Some addr -> (addr, p)
        | None      ->
(*
            let () = print_endline "p.t:" in
            let () = Document.print (Print.pp p.t) in
            let () = print_endline "\np.eqs:" in
            let () = Document.print (Print.pp p.eqs) in
            let () = print_endline "" in
*)
            (NaA,  p)
        end
    end
end
