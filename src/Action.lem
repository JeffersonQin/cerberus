open Global

module A = Ail
module C = Constraint

type address  = C.constant
type value    = C.constant

type action =
  | Load    of A.ctype * address * value
  | Store   of A.ctype * address * value
  | FnStore of A.ctype * address * value
  | Modify  of A.ctype * address * value * value
  | Create  of A.ctype * address
  | Kill    of address
  | Id      of address
  | Same    of address * address
  | Call

type uid = Symbol.t
type t = Action of action * uid

let (<$>) = Symbol_state.Operators.(<$>)

let load     t a v   = Action (Load   t a v)   <$> Symbol_state.fresh
let store    t a v   = Action (Store  t a v)   <$> Symbol_state.fresh
let fn_store t a v   = Action (Store  t a v)   <$> Symbol_state.fresh
let modify   t a l v = Action (Modify t a l v) <$> Symbol_state.fresh
let create   t a     = Action (Create t a)     <$> Symbol_state.fresh
let kill a           = Action (Kill     a)     <$> Symbol_state.fresh
let id a             = Action (Id       a)     <$> Symbol_state.fresh
let same a a'        = Action (Same a a')      <$> Symbol_state.fresh
let call             = Action (Call)           <$> Symbol_state.fresh

let uid (Action _ id) = id

let is_call (Action a _) =
  match a with
  | Call -> true
  | _ -> false
  end

let is_access (Action a _) =
  match a with
  | Store   _ _ _   -> true
  | FnStore _ _ _   -> true
  | Load    _ _ _   -> true
  | Modify  _ _ _ _ -> true
  | _               -> false
  end

let is_fn_store (Action a _) =
  match a with
  | FnStore _ _ _ -> true
  | _             -> false
  end

let address_of (Action action _) =
  match action with
    | Store   _ a _   -> a
    | FnStore _ a _   -> a
    | Modify  _ a _ _ -> a
    | Load    _ a _   -> a
    | Id      a       -> a
(*
    | _               ->
*)
  end

let filter_store ((Action action _) as a) =
  match action with
    | FnStore _ _ _   -> Some a
    | Store   _ _ _   -> Some a
    | Modify  _ _ _ _ -> Some a
    | _               -> None 
  end

let filter_other ((Action action _) as a) =
  match action with 
    | Load _ _ _ -> Some a
    | Id   _     -> Some a
    | _          -> None 
  end

let conflicts sb ts =
  let stores = Set.filter_map filter_store ts in
  let other  = Set.filter_map filter_other ts in
  let alias a a' = C.implies (C.eq (address_of a) (address_of a')) C.undef in
  let unseq a a' = a <> a' && not ((a, a') IN sb) && not ((a', a) IN sb) in
  (* TODO Set comparison needs to be symmetric in Eq c1 c2! *)
  {alias a a' | forall (a IN stores) (a' IN stores union other) | unseq a a'}

module Print = struct
  module P = Pprint

  open P.Operators

  let pp_c = C.Print.pp_constant
  let pp_t = A.Print.pp_type
  let pp_s s = !^ (Symbol.to_string s)

  let pp_uid (Action _ uid) = pp_s uid

  let pp (Action action uid) =
    let eq = (^^^) (pp_s uid ^^^ P.colon) in
    let (^%^) d1 d2 = d1 ^^ P.comma ^^^ d2 in
    match action with
    | Load t a v ->
        eq (!^ "load")   ^^^ P.parens (pp_t t ^%^ pp_c a ^%^ pp_c v)
    | Store t a v ->
        eq (!^ "store")  ^^^ P.parens (pp_t t ^%^ pp_c a ^%^ pp_c v)
    | FnStore t a v ->
        eq (!^ "store")  ^^^ P.parens (pp_t t ^%^ pp_c a ^%^ pp_c v)
    | Modify t a l v ->
        eq (!^ "modify") ^^^ P.parens (pp_t t ^%^ pp_c a ^%^ pp_c l ^%^ pp_c v)
    | Create t a ->
        eq (!^ "create") ^^^ P.parens (pp_t t ^%^ pp_c a)
    | Kill a ->
        eq (!^ "kill")   ^^^ P.parens (pp_c a)
    | Same a1 a2 ->
        eq (!^ "same")   ^^^ P.parens (pp_c a1 ^%^ pp_c a2)
    | Id a ->
        eq (!^ "id")     ^^^ P.parens (pp_c a)
    | Call ->
        eq (!^ "call")
    end

  let pp_latex a =
    let pp_c = C.Print.pp_constant_latex in
    let pp_id (Action _ s) = !^ (Symbol.to_string_id s) in
    let pp_name (Action a _) =
      match a with
      | Load    _ _ _   -> !^ "Load"
      | Store   _ _ _   -> !^ "Store"
      | FnStore _ _ _   -> !^ "Store"
      | Modify  _ _ _ _ -> !^ "Modify"
      | Create  _ _     -> !^ "Create"
      | Kill    _       -> !^ "Kill"
      | Same    _ _     -> !^ "Same"
      | Id      _       -> !^ "Id"
      | Call            -> !^ "Call"
      end in
    let pp_args (Action a _) =
      let tt d = !^ "\\\\cc" ^^ P.braces d in
      match a with
      | Load    t a v   -> [tt (pp_t t); pp_c a; pp_c v]
      | Store   t a v   -> [tt (pp_t t); pp_c a; pp_c v]
      | FnStore t a v   -> [tt (pp_t t); pp_c a; pp_c v]
      | Modify  t a l v -> [tt (pp_t t); pp_c a; pp_c l; pp_c v]
      | Create  t a     -> [tt (pp_t t); pp_c a]
      | Kill    a       -> [pp_c a]
      | Same    a1 a2   -> [pp_c a1; pp_c a2]
      | Id      a       -> [pp_c a]
      | Call            -> []
      end in
    let pp_opts args =
      match args with
      | [] -> P.empty
      | _ -> P.parens (P.sepmap (P.comma ^^ P.space) (fun i -> i) args)
      end in
    let context name id args =
      !^ "\\\\sem" ^^ P.braces name ^^ P.underscore ^^ P.braces id
      ^^^  pp_opts args in
    context (pp_name a) (pp_id a) (pp_args a)

  let pp_dot sb =
    let sem_list = P.sep0map (P.semi ^^ P.break1) (fun i -> i) in
    let pre = !^
      "\\newcommand{\\sem}[1]{\\small{\\textsf{#1}}}\
       \\newcommand{\\cc}[1]{\\text{\\footnotesize\\ttfamily{#1}}}" in
    let style = !^ "node [shape=none]" in
    let context d =
      !^ "digraph G" ^^^ P.braces (
        sem_list ((!^ "d2tdocpreamble" ^^ P.equals ^^ P.dquotes pre)::style::d)
      ) in
    let arrow a1 a2 = pp_uid a1 ^^^ P.minus ^^ P.rangle ^^^ pp_uid a2 in
    let rd = Transitive_reduction.reduce sb in
    let d = [arrow a1 a2 | forall ((a1, a2) IN rd) | true] in
    let s = {a1 | forall ((a1, _) IN rd) | true} union {a2 | forall ((_, a2) IN rd) | true} in
    let (s, d) =
      Set.fold
        (fun (a1, a2) (s, d) -> (s union {a1; a2}, (arrow a1 a2)::d))
        rd (empty, []) in
    let def a = pp_uid a ^^^ P.brackets (
      !^ "label" ^^ P.equals ^^ P.dquotes (pp_latex a)
    ) in
    let d = Set.fold (fun a d -> def a::d) s d in
    context d    
end

let unfold (Action a _) = a

module Memory = struct
  module P = C.Process
  module T = Types
  module Tc = Type_constraint

  module Effect = struct
    module M = Symbol_state_program

    let unit = M.unit

    module Operators = struct
      let (>>=) = M.bind
    end

    let undef t msg = M.undefined (t, msg)
    let bug   = M.bug

    let foldr_list = M.foldr_list

    let of_option = M.of_option

    let conv_int t const = M.of_symbol_state (Tc.conv_int t const)
  end

  module E = Effect
  open E.Operators

  type value =
    | Indeterminate
    | Value of C.constant

  type obj =
    | Scalar of A.ctype * value
    | Array  of A.ctype * value Braun.t

  type mem = (Symbol.t, obj) map

  type t = <|p : P.p; mem : mem|>

  let address t const =
    let (addr, p') = P.address t.p const in
    (addr, <|t with p = p'|>)

  let same_size ct s = C.compare_const s (Tc.size ct) = Ord.EQ

  let is_valid t addr =
    match addr with
    | P.Base      l     -> Pmap.mem l t.mem
    | P.Displaced l i s ->
        match Map.find l t.mem with
        | Some o ->
            let (ct, length) =
              match o with
              | Scalar ct _  -> (ct, 1)
              | Array  ct vs -> (ct, Braun.size vs)
              end in
            i >= 0 && i <= length && same_size ct s
        | None -> false
        end
    | P.NullAddress -> false
    end

  let base_of = function
    | P.Base      l     -> l
    | P.Displaced l _ _ -> l
  end

  let same_base t addr1 addr2 =
    base_of addr1 = base_of addr2 && is_valid t addr1 && is_valid t addr2

  let retrieve t addr =
    match addr with
    | P.Base      l     -> E.of_option (E.undef t "Invalid address.") (Map.find l t.mem)
    | P.Displaced l i s -> E.of_option (E.undef t "Invalid address.") (Map.find l t.mem)
    | P.NullAddress     -> E.undef t "Null pointer access."
    | P.NaA             -> E.bug "Could not retrieve address."
    end

  let load_scalar t ct' v' ct v =
    if T.compatible ct ct' then
      E.unit <|t with p = P.add_constr t.p (C.eq v v')|>
    else if T.is_unsigned_of ct' ct then
      E.conv_int ct v' >>= fun (a, conv) ->
      E.unit <|t with p = P.add_constr (P.add_constr t.p conv) (C.eq v a)|>
    else if T.is_signed_of ct' ct then
      let overflow = C.implies (C.neg (Tc.in_range ct v')) C.undef in
      E.unit <|t with p = P.add_constr (P.add_constr t.p (C.eq v v')) overflow|>
    else E.undef t "Access and effective type are not compatible."

  let load_event t ct a v =
    let msg = "Tried to read an Indeterminate value." in
    let (addr, t) = address t a in
    retrieve t addr >>= function
    | Scalar _ Indeterminate ->
        E.undef t msg
    | Scalar ct' (Value v') ->
        load_scalar t ct' v' ct v
    | Array ct' vs' ->
        if T.compatible ct' ct then
          match addr with
          | P.Base _ ->
              match Braun.get vs' 0 with
              | Value v' -> load_scalar t ct' v' ct v
              | Indeterminate -> E.undef t msg
              end
          | P.Displaced _ i s ->
              if i >= 0 && i < Braun.size vs' && same_size ct' s then
                match Braun.get vs' i with
                | Value v' -> load_scalar t ct' v' ct v
                | Indeterminate -> E.undef t msg
                end
              else E.undef t "Out-of-bounds access."
          | P.NullAddress -> E.undef t "Null pointer access."
          end
        else E.undef t "Access and effective type are not compatible."
    end

  let write_scalar t ct' ct v =
    if T.compatible ct ct' then
      E.unit (Value v, t)
    else if T.is_signed_of ct' ct then
      E.conv_int ct' v >>= fun (a, conv) ->
      E.unit (Value a, <|t with p = P.add_constr t.p conv|>)
    else if T.is_unsigned_of ct' ct then
      let overflow = C.implies (C.neg (Tc.in_range ct' v)) C.undef in
      E.unit (Value v, <|t with p = P.add_constr t.p overflow|>)
    else E.undef t "Access and effective type are not compatible."

  let write_event t ct a v =
    let (addr, t) = address t a in
    retrieve t addr >>= function
    | Scalar ct' _ ->
        write_scalar t ct' ct v >>= fun (v, t) ->
        E.unit <|t with mem = Pmap.add (base_of addr) (Scalar ct' v) t.mem|>
    | Array ct' vs' ->
        if T.compatible ct' ct then
          match addr with
          | P.Base _ ->
              write_scalar t ct' ct v >>= fun (v, t) ->
              let vs = Braun.set vs' 0 v in
              E.unit <|t with mem = Pmap.add (base_of addr) (Array ct' vs) t.mem|>
          | P.Displaced _ i s ->
              if i >= 0 && i < Braun.size vs' && same_size ct' s then
                write_scalar t ct' ct v >>= fun (v, t) ->
                let vs = Braun.set vs' i v in
                E.unit <|t with mem = Pmap.add (base_of addr) (Array ct' vs) t.mem|>
              else E.undef t "Out-of-bounds access."
          end
        else E.undef t "Access and effective type are not compatible."
    end

  let event ((_, action) as a) t =
(*    Document.Print (Print.pp a); print_endline "";*)
    match action with
    | Id a ->
        let (addr, t) = address t a in
        if is_valid t addr
          then E.unit  t
          else E.undef t "Invalid address."
    | Same a1 a2 ->
        let (addr1, t) = address t a1 in
        let (addr2, t) = address t a2 in
        if same_base t addr1 addr2
          then E.unit  t
          else E.undef t "Comparing addresses of distinct object."
    | Create ct a -> 
        if T.is_scalar ct then
          let (addr, t) = address t a in
          E.unit <|t with mem = Pmap.add (base_of addr) (Scalar ct Indeterminate) t.mem|>
        else if T.is_array ct then
          let (addr, t) = address t a in
          let value = Braun.make (T.size_of_array ct) Indeterminate in
          let obj = Array (T.base_of_array ct) value in
          E.unit <|t with mem = Pmap.add (base_of addr) obj t.mem|>
        else E.bug "event"
    | Kill a ->
        let (addr, t) = address t a in
        E.unit <|t with mem = Pmap.remove (base_of addr) t.mem|>
    | Load    ct a v -> load_event  t ct a v
    | Store   ct a v -> write_event t ct a v
    | FnStore ct a v -> write_event t ct a v
    | Modify  ct a v v' ->
        load_event  t ct a v >>= fun t ->
        write_event t ct a v'
    | Call -> E.unit t
    end

  let replay p' es =
    E.foldr_list event es <|p = p'; mem = Pmap.empty|> >>= fun t ->
    E.unit (P.complete t.p)
(*
    with Undefined t ->
      P.complete (*print_endline "UNDEF";*) P.add_constr t.p C.undef
*)
end	