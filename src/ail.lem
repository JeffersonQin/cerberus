open Global

type id = Symbol.t

(* [storage duration] (6.2.4#1)
   
   "An object has a storage duration that determines its lifetime. There are
    four storage durations: static, thread, automatic, and allocated. Allocated
    storage is described in 7.22.3."
*)
type storage_duration =
  | STATIC
  | THREAD
  | AUTOMATIC
  | ALLOCATED (*TODO: see 7.22.3 *)

type integer_base_type =
  | ICHAR
  | SHORT
  | INT
  | LONG
  | LONG_LONG

type integer_type =
  | BOOL
  | SIGNED of integer_base_type
  | UNSIGNED of integer_base_type

type basic_type =
  | CHAR
  | INTEGER of integer_type

type qualifiers = Cabs.qualifiers

type arithmetic_operator = Cabs.arithmetic_operator
type binary_operator = Cabs.binary_operator

type unary_operator =
  | PLUS
  | MINUS
  | BNOT
  | ADDRESS
  | INDIRECTION
  | POSTFIX_INCR
  | POSTFIX_DECR

type integer_constant = Cabs.integer_constant
type constant = Cabs.constant

type ctype =
  | VOID of qualifiers
  | BASIC of qualifiers * basic_type
  (* TODO Need to convert integer constant to an actual value! Otherwise, we
     cannot compare types! *)
  | ARRAY of ctype * num
  | POINTER of qualifiers * ctype
  | FUNCTION of ctype * ctype list
  | STRUCT of id option * (storage_duration * ctype * member_declarator) list

and member_declarator =
  | MEMBER_DECL of id
(*  | BITFIELD of id option * 'e (* TODO: need to decide what to do about the 'e *) *)

and type_class =
  | T_EXP of ctype
  | T_LVALUE of ctype
  (* TODO: we need to add a T_BITFIELD *)


type declaration = ctype * storage_duration option

type 'a expression =
  | UNARY of unary_operator * 'a expression_l
  | BINARY of binary_operator * 'a expression_l * 'a expression_l 
  | ASSIGN of arithmetic_operator option * 'a expression_l * 'a expression_l
  | CONDITIONAL of 'a expression_l * 'a expression_l * 'a expression_l
  | CAST of ctype * 'a expression_l
  | CALL of 'a expression_l * 'a expression_l list
  | MEMBEROF of 'a expression * id
  | MEMBEROFPTR of 'a expression * id
  | CONSTANT of Cabs.constant
  | VARIABLE of id
  | SIZEOF of ctype
  | ALIGNOF of ctype

and 'a expression_l = 'a * 'a expression

type 'a definition = id * 'a expression_l

(* Statements *)
type 'a statement =
  | SKIP
  | EXPRESSION of 'a expression_l
  | BLOCK of id list * 'a statement_l list
  | IF of 'a expression_l * 'a statement_l * 'a statement_l
  | WHILE of 'a expression_l * 'a statement_l
  | DO of 'a expression_l * 'a statement_l
  | BREAK
  | CONTINUE
  | RETURN_VOID
  | RETURN_EXPRESSION of 'a expression_l
  | SWITCH of 'a expression_l * 'a statement_l
  | CASE of Cabs.integer_constant * 'a statement_l
  | DEFAULT of 'a statement_l
  | LABEL of id * 'a statement_l
  | GOTO of id
  | DECLARATION of 'a definition list
  | PAR of 'a statement_l list

and 'a statement_l = 'a * 'a statement

type 'a file = <|
  main : id;
  id_map : (id, declaration) map;
  globals : (id * 'a expression_l) list;
  fn_map : (id, (id list * 'a statement_l)) map
|>

type 'a env = <|
  symbol : id;
  symbol_map : (id, string) map;
  file : 'a file
|>


(* HACK: equality over ctypes. *)
let rec and2 f l1 l2 =
  match (l1,l2) with
    | ([]   ,[]    ) -> true
    | (x::xs, y::ys) -> f x y && and2 f xs ys
  end

let rec ctype_eq ty1 ty2 =
  match (ty1, ty2) with
    | (VOID qs1             ,     VOID qs2         ) -> Set.equal qs1 qs2
    | (BASIC qs1 b1         , BASIC qs2 b2         ) -> Set.equal qs1 qs2 && b1 = b2
    | (ARRAY ty1 n1         , ARRAY ty2 n2         ) -> ctype_eq ty1 ty2 && n1 = n2
    | (POINTER qs1 ty1      , POINTER qs2 ty2      ) -> Set.equal qs1 qs2 && ctype_eq ty1 ty2
    | (FUNCTION ty1 tys1    , FUNCTION ty2 tys2    ) -> ctype_eq ty1 ty2 && and2 ctype_eq tys1 tys2
    | (STRUCT x1_opt membrs1, STRUCT x2_opt membrs2) -> x1_opt = x2_opt &&
                                                        and2 (fun (x1,y1,z1) (x2,y2,z2) -> x1=x2 && ctype_eq y1 y2 && z1=z2) membrs1 membrs2
  end




module Print = struct
  module P = Pprint

  open P.Operators
  
  let precedence = function
    | VARIABLE _ -> Some 0
    | CONSTANT _ -> Some 0
    
    | CALL _ _             -> Some 1
    | MEMBEROF _ _         -> Some 1
    | MEMBEROFPTR _ _      -> Some 1
    | UNARY POSTFIX_INCR _ -> Some 1
    | UNARY POSTFIX_DECR _ -> Some 1
    
    | UNARY _ _ -> Some 2
    | CAST _ _  -> Some 2
    | SIZEOF _  -> Some 2
    | ALIGNOF _ -> Some 2
    
    | BINARY (Cabs.ARITHMETIC MUL) _ _ -> Some 3
    | BINARY (Cabs.ARITHMETIC DIV) _ _ -> Some 3
    | BINARY (Cabs.ARITHMETIC MOD) _ _ -> Some 3
    
    | BINARY (Cabs.ARITHMETIC ADD) _ _ -> Some 4
    | BINARY (Cabs.ARITHMETIC SUB) _ _ -> Some 4
    
    | BINARY (Cabs.ARITHMETIC SHL) _ _ -> Some 5
    | BINARY (Cabs.ARITHMETIC SHR) _ _ -> Some 5
    
    | BINARY LT _ _ -> Some 6
    | BINARY GT _ _ -> Some 6
    | BINARY LE _ _ -> Some 6
    | BINARY GE _ _ -> Some 6
    
    | BINARY EQ _ _ -> Some 7
    | BINARY NE _ _ -> Some 7
    
    | BINARY (Cabs.ARITHMETIC BAND) _ _ -> Some 8
    
    | BINARY (Cabs.ARITHMETIC XOR) _ _ -> Some 9
    
    | BINARY (Cabs.ARITHMETIC BOR) _ _ -> Some 10
    
    | BINARY AND _ _ -> Some 11
    
    | BINARY OR _ _ -> Some 12
    
    | CONDITIONAL _ _ _ -> Some 13
    
    | ASSIGN _ _ _ -> Some 14
    
    | BINARY COMMA _ _ -> Some 15
  end

  let lt_precedence p1 p2 =
    match (p1, p2) with
      | (Some n1, Some n2) -> n1 < n2
      | (Some _ , None   ) -> true
      | (None   , _      ) -> false
    end

  let optional pp = function
    | Some x -> pp x
    | None   -> P.empty
  end

  let pp_unop = function
    | MINUS        -> P.minus
    | PLUS         -> P.plus
    | ADDRESS      -> P.ampersand
    | INDIRECTION  -> P.star
    | BNOT         -> P.tilde
    | POSTFIX_INCR -> P.plus ^^ P.plus
    | POSTFIX_DECR -> P.minus ^^ P.minus
  end

  let pp_arithop = function
    | Cabs.ADD  -> P.plus
    | Cabs.SUB  -> P.minus
    | Cabs.MUL  -> P.star
    | Cabs.DIV  -> P.slash
    | Cabs.MOD  -> P.percent
    | Cabs.BAND -> P.ampersand
    | Cabs.BOR  -> P.bar
    | Cabs.XOR  -> P.caret
    | Cabs.SHL  -> P.langle ^^ P.langle
    | Cabs.SHR  -> P.rangle ^^ P.rangle
  end

  let pp_binop = function
    | Cabs.ARITHMETIC o -> pp_arithop o
    | Cabs.EQ -> P.equals ^^ P.equals
    | Cabs.NE -> P.bang   ^^ P.equals
    | Cabs.LT -> P.langle
    | Cabs.GT -> P.rangle
    | Cabs.LE -> P.langle ^^ P.equals
    | Cabs.GE -> P.rangle ^^ P.equals
    | Cabs.AND   -> P.ampersand ^^ P.ampersand
    | Cabs.OR    -> P.bar ^^ P.bar
    | Cabs.COMMA -> P.comma
  end

  let showParens = P.parens

  let pp_qualifier = function
    | Cabs.CONST -> !^ "const"
  end

  let pp_integer_base_type = function
    | ICHAR -> !^ "char"
    | SHORT -> !^ "short"
    | INT -> !^ "int"
    | LONG -> !^ "long"
    | LONG_LONG -> !^ "long" ^^^ !^ "long"
  end

  let pp_integer_type = function
    | BOOL        -> !^ "_Bool"
    | UNSIGNED ib -> !^ "unsigned" ^^^ pp_integer_base_type ib
    | SIGNED   ib -> !^ "signed"   ^^^ pp_integer_base_type ib
  end

  let pp_basic_type = function
    | CHAR -> !^ "char"
    | INTEGER i -> pp_integer_type i
  end

  let pp_suffix s =
    let to_string = function
      | Cabs.SUFFIX_UNSIGNED           -> "U"
      | Cabs.SUFFIX_UNSIGNED_LONG      -> "UL"
      | Cabs.SUFFIX_UNSIGNED_LONG_LONG -> "ULL"
      | Cabs.SUFFIX_LONG               -> "L"
      | Cabs.SUFFIX_LONG_LONG          -> "LL"
    end in
    optional (P.text -| to_string) s

  let pp_int_const (i, s) = !^ (string_of_num i) ^^ pp_suffix s

  let rec pp_type t =
    let f = pp_type in
    let pp_qs qs =
      let ins_space ds d = ds ^^ d ^^ P.space in
      P.fold ins_space (List.map pp_qualifier (Set.to_list qs)) in
    match t with
      | VOID qs   -> pp_qs qs ^^ (!^ "void")
      | BASIC qs b -> pp_qs qs ^^ pp_basic_type b
      | ARRAY t s -> P.parens (f t) ^^^ P.brackets (!^ (string_of_num s))
      | POINTER qs t -> pp_qs qs ^^ P.parens (f t) ^^^ P.star
      | FUNCTION t ts -> f t ^^^ P.parens (P.comma_list f ts)
    end

  let pp_type_class = function
    | T_EXP    t -> P.brackets (pp_type t) ^^ !^ "exp"
    | T_LVALUE t -> P.brackets (pp_type t) ^^ !^ "lvalue"
  end

  let pp_return_type = function
    | FUNCTION t _ -> pp_type t
    | _            -> P.empty
  end

  let pp_id id = !^ (Symbol.to_string_pretty id)

  let rec pp_exp p (d, exp) =
    let p' = precedence exp in
    let f = P.group -| pp_exp p' in
    (if lt_precedence p' p then fun x -> x else P.parens) $
    match exp with
      | VARIABLE id -> pp_id id
      | UNARY (POSTFIX_INCR as o) e -> f e ^^ pp_unop o
      | UNARY (POSTFIX_DECR as o) e -> f e ^^ pp_unop o
      | UNARY o                   e -> pp_unop o ^^ f e
      | BINARY (Cabs.COMMA as o) e1 e2 ->
          f e1 ^^ pp_binop o ^^ P.space ^^ f e2
      | BINARY o e1 e2 -> f e1 ^^^ pp_binop o ^^^ f e2
      | CALL e es -> f e ^^ P.parens (P.comma_list f es)
      | ASSIGN o_opt e1 e2 ->
          f e1 ^^^ (optional pp_arithop o_opt ^^ P.equals) ^^^ f e2
      | CONDITIONAL e1 e2 e3 ->
          P.group (f e1 ^^^ P.qmark ^/^ f e2 ^^^ P.colon ^/^ f e3)
      | CAST t e -> P.parens (pp_type t) ^^^ f e
      | CONSTANT (Cabs.CONST_INT ic) -> pp_int_const ic
      | SIZEOF  t -> !^ "sizeof"  ^^ P.parens (pp_type t)
      | ALIGNOF t -> !^ "alignof" ^^ P.parens (pp_type t)
    end

  let pp_decl file id =
    let (t, st) = Pmap.find id file.id_map in
    pp_type t ^^^ pp_id id

  let rec pp_stmt file (d, stmt) =
    let f_e = pp_exp None in
    let f_s = pp_stmt file in
    match stmt with
      | SKIP -> P.semi
      | EXPRESSION e -> f_e e ^^ P.semi
      | BLOCK _ ss ->
          let block = P.sepmap P.break1 f_s ss in
          P.lbrace ^^ P.nest 2 (P.break1 ^^ block) ^/^ P.rbrace
      | IF e s1 s2 ->
          !^ "if" ^^^ P.parens (f_e e) ^^^ f_s s1 ^^^ !^ "else" ^^^ f_s s2
      | WHILE e s ->
          !^ "while" ^^^ P.parens (f_e e) ^/^ f_s s
      | DO e s ->
          !^ "do" ^/^ f_s s ^/^ !^ "while" ^^^ P.parens (f_e e)
      | BREAK -> !^ "break" ^^ P.semi
      | CONTINUE -> !^ "continue" ^^ P.semi
      | RETURN_VOID -> !^ "return" ^^ P.semi
      | RETURN_EXPRESSION e -> !^ "return" ^^^ f_e e ^^ P.semi
      | SWITCH e s -> !^ "switch" ^^^ P.parens (f_e e) ^/^ f_s s
      | CASE ic s -> pp_int_const ic ^^ P.colon ^^^ f_s s
      | DEFAULT s -> !^ "default" ^^ P.colon ^^^ f_s s
      | GOTO id -> !^ "goto" ^^^ pp_id id ^^ P.semi
      | LABEL id s -> pp_id id ^^ P.colon ^^^ f_s s
      | DECLARATION ds ->
          let f_d (id, e) =
            let (t, st) = Pmap.find id file.id_map in
            pp_type t ^^^ pp_id id ^^^ P.equals ^^^ f_e e in
          P.comma_list f_d ds ^^ P.semi
      | PAR ss -> let par = P.sepmap (P.bar ^^ P.bar ^^ P.bar) f_s ss in
                  P.lbrace ^^ P.lbrace ^^ P.lbrace ^^ P.nest 2 (P.break1 ^^ par) ^/^ P.rbrace ^^ P.rbrace ^^ P.rbrace
    end

  let pp_function file (id, (args, s)) =
    let (t, st) = Pmap.find id file.id_map in
    pp_return_type t
    ^^^ pp_id id
    ^^^ P.parens (P.comma_list (pp_decl file) args)
    ^^^ (pp_stmt file s)

  let pp_file file =
    let pp d f = d ^^ pp_function file f ^^ P.break1 in
    List.fold_left pp P.empty (Ocaml.Pmap.bindings file.fn_map)
end
