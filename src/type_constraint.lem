module A = Ail
module C = Constraint
module Const = C.Constants
module R = Range

open Symbol_state.Operators

let inital = C.from_list [
  C.eq (Const.char_bit)   (C.const (R.char_bit));

  C.le (Const.schar_min)  (C.const (R.min_of R.schar));
  C.ge (Const.schar_max)  (C.const (R.max_of R.schar));
  C.ge (Const.uchar_max)  (C.const (R.max_of R.uchar));
  C.le (Const.shrt_min)   (C.const (R.min_of R.shrt));
  C.ge (Const.shrt_max)   (C.const (R.max_of R.shrt));
  C.ge (Const.ushrt_max)  (C.const (R.max_of R.ushrt));
  C.le (Const.int_min)    (C.const (R.min_of R.int));
  C.ge (Const.int_max)    (C.const (R.max_of R.int));
  C.ge (Const.uint_max)   (C.const (R.max_of R.uint));
  C.le (Const.long_min)   (C.const (R.min_of R.long));
  C.ge (Const.long_max)   (C.const (R.max_of R.long));
  C.ge (Const.ulong_max)  (C.const (R.max_of R.ulong));
  C.le (Const.llong_min)  (C.const (R.min_of R.llong));
  C.ge (Const.llong_max)  (C.const (R.max_of R.llong));
  C.ge (Const.ullong_max) (C.const (R.max_of R.ullong))
]

let conv_impl t const =
  let name =
    match t with
      | A.SIGNED A.ICHAR     -> Const.to_char
      | A.SIGNED A.SHORT     -> Const.to_shrt
      | A.SIGNED A.INT       -> Const.to_int
      | A.SIGNED A.LONG      -> Const.to_long
      | A.SIGNED A.LONG_LONG -> Const.to_llong
(*
      | A.BOOL | A.UNSIGNED _ -> invalid_arg "Signed integer type was expected."
*)
    end in
  C.fn name [const]

let min = function
  | A.BOOL                 -> C.zero
  | A.SIGNED   A.ICHAR     -> Const.schar_min
  | A.SIGNED   A.SHORT     -> Const.shrt_min
  | A.SIGNED   A.INT       -> Const.int_min
  | A.SIGNED   A.LONG      -> Const.long_min
  | A.SIGNED   A.LONG_LONG -> Const.llong_min
  | A.UNSIGNED A.ICHAR     -> C.zero
  | A.UNSIGNED A.SHORT     -> C.zero
  | A.UNSIGNED A.INT       -> C.zero
  | A.UNSIGNED A.LONG      -> C.zero
  | A.UNSIGNED A.LONG_LONG -> C.zero
end

let max = function
  | A.BOOL                 -> C.one
  | A.SIGNED   A.ICHAR     -> Const.schar_max
  | A.SIGNED   A.SHORT     -> Const.shrt_max
  | A.SIGNED   A.INT       -> Const.int_max
  | A.SIGNED   A.LONG      -> Const.long_max
  | A.SIGNED   A.LONG_LONG -> Const.llong_max
  | A.UNSIGNED A.ICHAR     -> Const.uchar_max
  | A.UNSIGNED A.SHORT     -> Const.ushrt_max
  | A.UNSIGNED A.INT       -> Const.uint_max
  | A.UNSIGNED A.LONG      -> Const.ulong_max
  | A.UNSIGNED A.LONG_LONG -> Const.ullong_max
end

let min_range_of it =
  match it with
  | A.BOOL                 -> R.bool
  | A.SIGNED   A.ICHAR     -> R.schar
  | A.SIGNED   A.SHORT     -> R.shrt
  | A.SIGNED   A.INT       -> R.int
  | A.SIGNED   A.LONG      -> R.long
  | A.SIGNED   A.LONG_LONG -> R.llong
  | A.UNSIGNED A.ICHAR     -> R.uchar
  | A.UNSIGNED A.SHORT     -> R.ushrt
  | A.UNSIGNED A.INT       -> R.uint
  | A.UNSIGNED A.LONG      -> R.ulong
  | A.UNSIGNED A.LONG_LONG -> R.ullong
  end

let size_int = function
  | A.BOOL                 -> Const.bool_size
  | A.SIGNED   A.ICHAR     -> Const.schar_size
  | A.SIGNED   A.SHORT     -> Const.shrt_size
  | A.SIGNED   A.INT       -> Const.int_size
  | A.SIGNED   A.LONG      -> Const.long_size
  | A.SIGNED   A.LONG_LONG -> Const.llong_size
  | A.UNSIGNED A.ICHAR     -> Const.uchar_size
  | A.UNSIGNED A.SHORT     -> Const.ushrt_size
  | A.UNSIGNED A.INT       -> Const.uint_size
  | A.UNSIGNED A.LONG      -> Const.ulong_size
  | A.UNSIGNED A.LONG_LONG -> Const.ullong_size
end    

let size = function
  | A.BASIC _ (A.INTEGER i) -> size_int i
end    

let align_int = function
  | A.BOOL                 -> Const.bool_align
  | A.SIGNED   A.ICHAR     -> Const.schar_align
  | A.SIGNED   A.SHORT     -> Const.shrt_align
  | A.SIGNED   A.INT       -> Const.int_align
  | A.SIGNED   A.LONG      -> Const.long_align
  | A.SIGNED   A.LONG_LONG -> Const.llong_align
  | A.UNSIGNED A.ICHAR     -> Const.uchar_align
  | A.UNSIGNED A.SHORT     -> Const.ushrt_align
  | A.UNSIGNED A.INT       -> Const.uint_align
  | A.UNSIGNED A.LONG      -> Const.ulong_align
  | A.UNSIGNED A.LONG_LONG -> Const.ullong_align
end

let in_range_int t const = C.conj (C.le (min t) const) (C.le const (max t))

let in_range t const =
  match t with
  | A.BASIC _ (A.INTEGER i) -> in_range_int i const
  end


(*  *)
let conv_int_type i const =
  C.fresh >>= fun a ->
  let constr =
    match i with
    | A.BOOL ->
        C.case (C.eq C.zero const) (C.eq a C.zero) (C.eq a C.one)
    | (A.UNSIGNED _ as i) ->
        C.eq a (C.modulo const (max i))
    | (A.SIGNED   _ as i) ->
        C.case (in_range_int i const)
          (C.eq a const)
          (C.eq a (conv_impl i const))
    end in
  let conv = C.conv_int (min_range_of i) constr const in
  Symbol_state.return (a, conv)

let conv_int t const =
  match t with
  | A.BASIC _ (A.INTEGER i) -> conv_int_type i const
  | _ -> Symbol_state.return (const, C.tt)
  end

let conv t t' const =
  match (t, t') with
  | (_, A.BASIC _ (A.INTEGER i)) ->
      if Types.is_integer t then
        conv_int_type i const
      else Symbol_state.return (const, C.tt)
  | _ -> Symbol_state.return (const, C.tt)
  end  


let align = function
  | A.BASIC _ (A.INTEGER i) -> align_int i
  | _ -> C.one
  end

let is_aligned t addr = C.eq (C.modulo addr (align t)) C.zero
