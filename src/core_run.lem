open Global

(* TODO: this is part of the "memory model" but need to be before Effect *)
type mem_addr = num
and mem_state = Pmap.map mem_addr num * mem_addr


(* Fully evaluated description of an action *)
type trace_action =
  | Tcreate of Ail.ctype
  | Talloc of num
  | Tkill of mem_addr
  | Tstore of Ail.ctype * mem_addr * num
  | Tload of Ail.ctype * mem_addr


(* version of Core's syntax with annotated actions, preserving informations
   about the sequence-before relation and allowing the generation of annotated
   traces. *)
type expr =
  | Kskip
  | Kconst of num
  | Kaddr of mem_addr
  | Ksym of Core.sym
  | Kop of Core.binop * expr * expr
  | Ktrue
  | Kfalse
  | Knot of expr
  | Kctype of Ail.ctype
  | Klet of Core.sym * expr * expr
  | Kif of expr * expr * expr
  | Kcall of Core.sym * list expr
  | Kundef
  | Kerror
  | Kaction of paction
  | Kunseq of list expr
  | Kwseq of list (option Core.sym) * expr * expr
  | Ksseq of list (option Core.sym) * expr * expr
  | Kaseq of option Core.sym * action * paction
  
  | Kindet of num * expr
  | Kbound of num * expr
  
  | Ksame of expr * expr
  
  | Ksave of Core.label * expr
  | Krun of Core.label

and action_ =
  | Kcreate of expr
  | Kalloc of expr
  | Kkill of Core.sym
  | Kstore of expr * expr * expr
  | Kload of expr * expr

and action = set trace_action * action_
and paction = Core.polarity * action














(* -- Pretty printing --------------------------------------------------------------------------- *)
module Print = struct
  module P = Pprint

  open P.Operators
  
  
  let precedence = function
    | Kconst _ -> Some 0
    | Ksym _   -> Some 0
    | Ktrue    -> Some 0
    | Kfalse   -> Some 0
    | Kaddr _  -> Some 0
    | Kctype _ -> Some 0
    | Kundef   -> Some 0
    | Kerror   -> Some 0
    | Kskip    -> Some 0
    
    | Knot _   -> Some 1

    | Kaction _    -> Some 2
    | Ksame _ _    -> Some 2
    | Kcall _ _    -> Some 2
    
    | Kop OpMul _ _ -> Some 3
    | Kop OpDiv _ _ -> Some 3
    | Kop OpMod _ _ -> Some 3
    | Kop OpAdd _ _ -> Some 4
    | Kop OpSub _ _ -> Some 4
    | Kop OpLt  _ _ -> Some 5
    | Kop OpEq  _ _ -> Some 6
    | Kop OpAnd _ _ -> Some 7
    | Kop OpOr  _ _ -> Some 8
    
    | Kif _ _ _  -> Some 9
    | Klet _ _ _ -> Some 10

    | Kaseq _ _ _ -> Some 11
    | Kwseq _ _ _ -> Some 12
    | Ksseq _ _ _ -> Some 13
    | Kunseq _    -> Some 14
  end

  let lt_precedence p1 p2 =
    match (p1, p2) with
      | (Some n1, Some n2) -> n1 <= n2
      | (Some _ , None   ) -> true
      | (None   , _      ) -> false
    end
  
  let pp_keyword  w = !^ ("\x1b[1;35m" ^ w ^ "\x1b[0m")
  let pp_constant c = !^ ("\x1b[35m" ^ c ^ "\x1b[0m")
  let pp_control  w = !^ ("\x1b[1;36m" ^ w ^ "\x1b[0m")
  let pp_symbol   a = !^ ("\x1b[34m" ^ (Symbol.to_string_pretty a) ^ "\x1b[0m")
  let pp_number   n = !^ ("\x1b[33m" ^ n ^ "\x1b[0m")
  
  
  let optional pp = function
    | Some x -> pp x
    | None   -> P.empty
  end
  
  
  let pp_trace_action = function
    | Tcreate ty    -> !^ ("create {") ^^ Ail.Print.pp_type ty ^^ !^ "}"
    | Talloc n      -> !^ ("alloc " ^ string_of_num n)
    | Tkill o       -> !^ ("kill @" ^ string_of_num o)
    | Tstore ty o n -> !^ ("store {") ^^ Ail.Print.pp_type ty ^^ !^ ("} @" ^ string_of_num o ^ " " ^ string_of_num n)
    | Tload ty o    -> !^ ("load {") ^^ Ail.Print.pp_type ty ^^ !^ ("} @" ^ string_of_num o)
  end
  
  let rec pp_expr p e =
    let p' = precedence e in
    let f = P.group -| pp_expr p' in
    (if lt_precedence p' p then fun x -> x else P.parens) $
    match e with
      
      | Kconst n        -> pp_number (string_of_num n)
      | Ksym a          -> pp_symbol a
      | Kaddr o         -> !^ ("addr[" ^ string_of_num o ^ "]")
      | Kop op e1 e2    -> f e1 ^^^ Core.Print.pp_binop op ^^^ f e2
      | Ktrue           -> pp_constant "true"
      | Kfalse          -> pp_constant "false"
      | Knot e          -> pp_keyword "not" ^^^ f e
      | Kctype ty       -> Ail.Print.pp_type ty
      | Klet a e1 e2    -> pp_control "let" ^^^ pp_symbol a ^^^ P.equals ^^ 
                           P.nest 2 (P.break1 ^^ f e1 ^^^ pp_control "in")
                           ^^ P.break1 ^^ f e2
      | Kif b e1 e2     -> pp_control "if" ^^^ f b ^^^ pp_control "then" ^^
                           P.nest 2 (P.break1 ^^ f e1) ^^ P.break1 ^^
                           pp_control "else" ^^ P.nest 2 (P.break1 ^^ f e2) ^^ P.break1
      | Kcall a es      -> pp_symbol a ^^ P.parens (P.sepmap (P.comma ^^ P.space) f es)
      | Kundef          -> pp_keyword "undef"
      | Kerror          -> pp_keyword "error"
      | Kskip           -> pp_keyword "skip"

(*      | Kwhile a s1 e s2 -> pp_control "while" ^^^ pp_symbol a ^^^ !^ "<-" ^^^ f s1 ^^ P.semi ^^^ f e ^^^ pp_control "do" ^^
                            P.nest 2 (P.break1 ^^ f s2) ^^ P.break1 ^^ pp_control "done"
*)

      | Kaseq None act y     -> f (Kaction (Core.Pos, act)) ^^^ (!^ "|>") ^^^ f (Kaction y)
      | Kaseq (Some a) act y -> pp_symbol a ^^^ !^ "<-" ^^ f (Kaction (Core.Pos, act)) ^^^ (!^ "|>") ^^^ f (Kaction y)
      
      | Ksseq [] e1 e2  -> f e1 ^^^ (!^ "<>") ^^ P.break1 ^^ f e2
      | Ksseq [Some a] e1 e2 -> pp_symbol a ^^^ !^ "<-" ^^
                                P.nest 2 (P.break1 ^^ f e1 ^^^ (!^ "<>"))
                                ^^ P.break1 ^^ f e2
      | Ksseq [None] e1 e2  -> f e1 ^^^ (!^ "<>") ^^ P.break1 ^^ f e2
      | Ksseq _as e1 e2 -> let g x = match x with
                                       | Some x -> pp_symbol x
                                       | None   -> P.underscore
                                     end
                           in (P.parens (P.sepmap P.comma g _as)) ^^^ !^ "<-" ^^
                               P.nest 2 (P.break1 ^^ f e1 ^^^ (!^ "<>")) ^^ P.break1 ^^ f e2

      | Kwseq [] e1 e2       -> f e1 ^^^ P.semi ^^ P.break1 ^^ f e2
      | Kwseq [Some a] e1 e2 -> pp_symbol a ^^^ !^ "<-" ^^
                                P.nest 2 (P.break1 ^^ f e1 ^^^ P.semi)
                                ^^ P.break1 ^^ f e2
      | Kwseq [None] e1 e2       -> f e1 ^^^ P.semi ^^ P.break1 ^^ f e2
      | Kwseq _as e1 e2      -> let g x = match x with
                                            | Some x -> pp_symbol x
                                            | None   -> P.underscore
                                          end
                                in (P.parens (P.sepmap P.comma g _as)) ^^^ !^ "<-" ^^
                                   P.nest 2 (P.break1 ^^ f e1 ^^^ P.semi) ^^ P.break1 ^^ f e2
      | Kunseq []       -> !^ "BUG: UNSEQ must have at least two arguments (seen 0)"
      | Kunseq [_]      -> !^ "BUG: UNSEQ must have at least two arguments (seen 1)"
      | Kunseq es       ->  P.sepmap (P.space ^^ (pp_control "||") ^^ P.space) f es
      | Kaction (p, (bs, a)) ->
          (if Set.is_empty bs then P.empty else P.langle ^^ (P.sepmap P.space pp_trace_action (Set.to_list bs)) ^^ P.rangle ^^ P.space) ^^
          (match p with
            | Pos -> P.empty
            | Neg -> P.tilde
           end) ^^
          (match a with
            | Kcreate ty      -> pp_keyword "create" ^^ P.braces (f ty)
            | Kalloc a        -> pp_keyword "alloc" ^^^ f e
            | Kkill a         -> pp_keyword "kill" ^^^ pp_symbol a
            | Kstore ty e1 e2 -> pp_keyword "store" ^^ P.braces (f ty) ^^^ f e1 ^^^ f e2
            | Kload ty e      -> pp_keyword "load" ^^ P.braces (f ty) ^^^ f e
           end)
      
      | Ksame a1 a2     -> pp_keyword "same" ^^^ f a1 ^^^ f a2
(*
      | Kmax ty         -> pp_keyword "max" ^^ P.braces (Ail.Print.pp_type ty)
      | Kmin ty         -> pp_keyword "min" ^^ P.braces (Ail.Print.pp_type ty)
      | Ksizeof ty      -> pp_keyword "sizeof" ^^ P.braces (Ail.Print.pp_type ty)
      | Kalignof ty     -> pp_keyword "alignof" ^^ P.braces (Ail.Print.pp_type ty)
      | Koffsetof ty    -> pp_keyword "offset" ^^ P.braces (Ail.Print.pp_type ty)
      | Kshift a e      -> pp_keyword "shift" ^^^ pp_symbol a ^^^ f e
      | Kconv ty1 ty2 a -> pp_keyword "conv" ^^ P.braces (Ail.Print.pp_type ty1 ^^ !^"\\" ^^ Ail.Print.pp_type ty2) ^^^ pp_symbol a
*)

(*
      | Kgoto l         -> pp_control "goto" ^^^ pp_symbol l
      | Klabel l e      -> pp_symbol l ^^ P.colon ^^^ f e
*)
  end
  
end
























(* TODO: here I'm annotating all actions instead (this may reduce the number of epsilon transitions) *)
(* [annotate b e] add on each sb-minimal action of [e], an annotation meaning that
                  this action is sequenced-after [act]
  
  in the rules comments, this function is noted: <b> e
 *)
val annotate: trace_action -> expr -> expr
let rec annotate act e =
  match e with
  | Klet a e1 e2                         -> Klet a e1 (annotate act e2)
  | Kif e1 e2 e3                         -> Kif e1 (annotate act e2) (annotate act e3)
  | Kcall f es                           -> Kcall f es
  | Kaction (p, (bs, a))                 -> Kaction (p, ({act} union bs, a))
  | Kunseq es                            -> Kunseq (List.map (annotate act) es)
  | Kwseq _as e1 e2                      -> Kwseq _as (annotate act e1) (annotate act e2)
  | Ksseq _as e1 e2                      -> Ksseq _as (annotate act e1) (annotate act e2)
  | Kaseq a_opt (bs1, a1) (p, (bs2, a2)) -> Kaseq a_opt ({act} union bs1, a1) (p, ({act} union bs2, a2))
  | _                                    -> e
end


(* this type represents reduction rules and is used for annotating trace element
   (for debug purpose) *)
type dyn_rule =
  | Rule_Pos
  | Rule_Neg
  | Rule_WseqL of dyn_rule
  | Rule_Neg_Wseq of dyn_rule
  | Rule_Unseq of dyn_rule

(* list monad *)
module L = struct
  val return: forall 'a. 'a -> list 'a
  let return x = [x]
  
  val bind: forall 'a 'b. list 'a -> ('a -> list 'b) -> list 'b
  let bind m f = List.fold_right (fun x y -> (f x) @ y) m []
end


module Effect = struct
  (* the elements of a trace are triple, where:
       - the first element is a description of the reduction rules used for this
         step (this is for a DEBUG feature)
       - the second element is the set of actions sequenced before the action
         that has just been performed
       - the third element is the action that as been performed during that step
     *)
  type trace = list (dyn_rule * set trace_action * trace_action)
  
  type state = <|
      mem : mem_state;               (* the memory layout state    *)
      store: Pmap.map Core.sym expr; (* the symbolic names store   *)
      trace : trace                  (* the execution trace so for *)
  |>
  
  type t 'a = state -> list ('a * state)
  
  
  (* monadic operations *)
  val return: forall 'a. 'a -> t 'a
  let return x = fun s -> [(x, s)]
  
  val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
  let bind m f = fun s -> L.bind (m s) (fun (a, s') -> f a s')
  
  (* MonadPlus operations *)
  val mzero: forall 'a. t 'a
  let mzero = fun s -> []
  
  val mplus: forall 'a. t 'a -> t 'a -> t 'a
  let mplus a b = fun s -> (a s) @ (b s)
  
  
  (* generic functions (that should be moved out once we have type-classes) *)
  val msum: forall 'a. list (t 'a) -> t 'a
  let msum xs = List.fold_right mplus xs mzero
  
  module Operators = struct
    let (>>=) = bind
    let (>>) m f = bind m (fun _ -> f)
  end

end

(* -------------------------------------------------------------------------- *)
module E = Effect
open E.Operators


(* ************************************************************************** *)
(* TODO: dummy memory model (concrete with isolated objects, ignoring
   C types) *)
val initial_state: E.state
let initial_state = <| E.mem= (Pmap.empty, 0); E.store= Pmap.empty; E.trace= [] |>

val init: E.t unit
let init = fun _ -> [((), <| E.mem= (Pmap.empty, 0); E.store= Pmap.empty; E.trace= [] |>)]

val create: Ail.ctype -> E.t mem_addr
let create _ = fun (<| E.mem= (m, i) |> as s) -> [(i, <| s with E.mem= (Pmap.add i 0 m, i+1) |>)]

(* TODO: doesn't do anything regarding the size *)
val alloc: num -> E.t mem_addr
let alloc _ = fun (<| E.mem= (m, i) |> as s) -> [(i, <| s with E.mem= (Pmap.add i 0 m, i+1) |>)]

val kill: mem_addr -> E.t unit
let kill o = fun (<| E.mem= (m, i) |> as s) -> [((), <| s with E.mem= (Pmap.remove o m, i) |>)]

val store: Ail.ctype -> mem_addr -> num -> E.t unit
let store _ o v = fun (<| E.mem= (m, i) |> as s) -> [((), <| s with E.mem= (Pmap.add o v m, i) |>)]

val load: Ail.ctype -> mem_addr -> E.t num
let load _ o = fun (<| E.mem= (m, _) |> as s) -> [(Pmap.find o m, s)]




(* ************************************************************************** *)



(* non-deterministically pick an element of a list with its context within the
   list. (e.g. pick_one [1,2,3] = [ ([],1,[2; 3]); ([1],2,[3]); ([1; 2],3,[]) ])
 *)
val pick_one: forall 'a. list 'a -> E.t (list 'a * 'a * list 'a)
let rec _pick_one acc = function
  | []    -> []
  | x::xs -> (List.rev acc, x, xs) :: _pick_one (x::acc) xs
end
let pick_one l = E.msum $ List.map E.return (_pick_one l [])


(* push an element in the trace *)
val push_trace: (dyn_rule * set trace_action * trace_action) -> E.t unit
let push_trace a = fun (<| E.trace= t |> as s) -> [((), <| s with E.trace= a :: t |>)]

(* get the last element of the trace (crash if none). *)
val get_trace: E.t (dyn_rule * set trace_action * trace_action)
let get_trace = function
  | <| E.trace= []    |>        -> Boot.outOfHomeomorphism "[Core_run.get_trace] empty trace"
  | (<| E.trace= x::xs |> as s) -> [(x, s)]
end

val get_fulltrace: E.t E.trace
let get_fulltrace = fun (<| E.trace= t |> as s) -> [(t, s)]

(* mutate the rule descriptor of the most recent trace element (used by
   inductive rule after application of their premises) *)
val update_rule: (dyn_rule -> dyn_rule) -> E.t unit
let update_rule f = fun (<| E.trace= t |> as s) ->
  match t with
    | []               -> Boot.outOfHomeomorphism "[Core_run.update_rule] empty trace"
    | (r, bs, a) :: ts -> [((), <| s with E.trace= (f r, bs, a) :: ts |>)]
  end


(* get the expression stored in a symbolic names *)
val get_sym: Core.sym -> E.t expr
let get_sym a = fun (<| E.store= st |> as s ) -> [(Pmap.find a st, s)]

(* set the expression stored in a symbolic names *)
val set_sym: Core.sym -> expr -> E.t unit
let set_sym a e = fun (<| E.store= st |> as s ) -> [((), <| s with E.store= Pmap.add a e st |>)]

(* check if a symbolic names is part of a pattern *)
val in_pattern: Core.sym -> list (option Core.sym) -> bool
let rec in_pattern a p =
  match p with
    | []             -> false
    | Nothing  :: xs -> in_pattern a xs
    | Some a'  :: xs -> if a = a' then true else in_pattern a xs
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym: Core.sym -> expr -> expr -> expr
let rec subst_sym a v e =
  match e with
    | Ksym a          -> v
    | Kop binop e1 e2 -> Kop binop (subst_sym a v e1) (subst_sym a v e2)
    | Knot e          -> Knot (subst_sym a v e)
    | Klet _a e1 e2   -> Klet _a (subst_sym a v e1) (if a = _a then e2 else subst_sym a v e2)
    | Kif e1 e2 e3    -> Kif (subst_sym a v e1) (subst_sym a v e2) (subst_sym a v e3)
    | Kcall f args    -> Kcall f (List.map (subst_sym a v) args)
    | Kaction p       -> Kaction (subst_sym_paction a v p)
    | Kunseq es       -> Kunseq (List.map (subst_sym a v) es)
    | Kwseq _as e1 e2 -> Kwseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Ksseq _as e1 e2 -> Ksseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Kaseq _a act p  -> Kaseq _a (subst_sym_action a v act) (if Some a = _a then p else subst_sym_paction a v p)
    | Kindet i e      -> Kindet i (subst_sym a v e)
    | Kbound i e      -> Kbound i (subst_sym a v e)
    | Ksame e1 e2     -> Ksame (subst_sym a v e1) (subst_sym a v e2)
    | Ksave k e       -> Ksave k (subst_sym a v e)
    | _               -> e
  end
and subst_sym_action_ a v act =
  match act with
    | Kcreate e_ty        -> Kcreate (subst_sym a v e_ty)
    | Kalloc e_n          -> Kalloc (subst_sym a v e_n)
    | Kstore e_ty e_o e_v -> Kstore (subst_sym a v e_ty) (subst_sym a v e_o) (subst_sym a v e_v)
    | Kload e_ty e_o      -> Kload (subst_sym a v e_ty) (subst_sym a v e_o)
    | _                   -> act
  end
and subst_sym_action a  v (bs, act) = (bs, subst_sym_action_ a v act)
and subst_sym_paction a v (p,  act) = (p,  subst_sym_action  a v act)


(* evaluation of pure epxressions (will crash on ill-typed and/or non pure
   expressions) *)
val eval: expr -> E.t expr
let rec eval e =
  match e with
    | Kundef -> Boot.outOfHomeomorphism "[Core_run.eval] TODO: Kundef"
    | Kerror -> Boot.outOfHomeomorphism "[Core_run.eval] TODO: Kerror"

    | Ksym a -> get_sym a
    | Kop binop e1 e2 -> match binop with
                           | OpAdd -> eval e1 >>= fun (Kconst v1) ->
                                      eval e2 >>= fun (Kconst v2) ->
                                      E.return $ Kconst (v1 + v2)
                           | OpSub -> eval e1 >>= fun (Kconst v1) ->
                                      eval e2 >>= fun (Kconst v2) ->
                                      E.return $ Kconst (v1 - v2)
                           | OpMul -> eval e1 >>= fun (Kconst v1) ->
                                      eval e2 >>= fun (Kconst v2) ->
                                      E.return $ Kconst (v1 * v2)
                           | OpDiv -> eval e1 >>= fun (Kconst v1) ->
                                      eval e2 >>= fun (Kconst v2) ->
                                      E.return $ Kconst (v1 / v2)
                           | OpEq ->  eval e1 >>= fun (Kconst v1) ->
                                      eval e2 >>= fun (Kconst v2) ->
                                      E.return $ if v1 = v2 then Ktrue else Kfalse
                           | OpLt  -> eval e1 >>= fun (Kconst v1) ->
                                      eval e2 >>= fun (Kconst v2) ->
                                      E.return $ if v1 < v2 then Ktrue else Kfalse
                           | OpAnd -> eval e1 >>= fun b1 ->
                                      eval e2 >>= fun b2 ->
                                      E.return $ match (b1, b2) with
                                                   | (Ktrue, Ktrue) -> Ktrue
                                                   | _              -> Kfalse
                                                 end
                           | OpOr  -> eval e1 >>= fun b1 ->
                                      eval e2 >>= fun b2 ->
                                      E.return $ match (b1, b2) with
                                                   | (Kfalse, Kfalse) -> Kfalse
                                                   | _                -> Ktrue
                                                 end
                         end
    | Knot e -> eval e >>= function
                  | Ktrue  -> E.return Kfalse
                  | Kfalse -> E.return Ktrue
                end
    | Klet _a e1 e2 -> eval e1 >>= fun v -> E.return $ subst_sym _a v e2
    | Kif e1 e2 e3 -> eval e1 >>= function
                        | Ktrue  -> eval e2
                        | Kfalse -> eval e3
                      end
    | Kcall f es -> Boot.outOfHomeomorphism "[Core_run.eval] TODO: Kcall"

    | Ksame e1 e2 -> Boot.outOfHomeomorphism "[Core_run.eval] TODO: Ksame"
    | _ -> E.return e
  end


(* TODO: this function will call the implementation of a given action in a
         particular memory model *)
val perform_action: action_ -> E.t (trace_action * expr)
let perform_action = function
  | Kcreate ty    -> eval ty   >>= fun (Kctype ty) ->
                     create ty >>= fun o           ->
                     E.return (Tcreate ty, Kaddr o)
  | Kalloc n      -> eval n  >>= fun (Kconst n) ->
                     alloc n >>= fun o          ->
                     E.return (Talloc n, Kaddr o)
  | Kkill o       -> (* get_sym o   >>= fun (Kaddr o) ->
                     kill o      >> *)
                     (* TODO *)
                     E.return (Tkill 0, Kskip)
  | Kstore ty o v -> eval ty      >>= fun (Kctype ty) ->
                     eval o       >>= fun (Kaddr o)   ->
                     eval v       >>= fun (Kconst v)  ->
                     store ty o v >>
                     E.return (Tstore ty o v, Kskip)
  | Kload ty o    -> eval ty   >>= fun (Kctype ty) ->
                     eval o    >>= fun (Kaddr o)   ->
                     load ty o >>= fun v           ->
                     E.return $ (Tload ty o, Kconst v)
end


(* TODO: [subst_syms _as v e]  substitute the symbols _as with the corresponding
         of the value expression [v] in the expression [e]. This function
         crashes if [v] is not a value or its type doesn't match the symbolic
         pattern *)
val subst_syms: list (option Core.sym) -> expr -> expr -> expr
let subst_syms _as v e =
  match (_as, v) with
    | ([]       , _        ) -> e
    | ([None], _           ) -> e
    | ([Some _a], _        ) -> subst_sym _a v e
    | (_        , Kunseq vs) -> List.fold_left2 (fun acc _a_opt v -> match _a_opt with Some _a -> subst_sym _a v acc | None -> acc end) e _as vs
  end

(* TODO: This function should be in core.lem. It returns true iff the argument
         is a value expression *)
(* NOTE: we assume that the expression is well typed *)
val is_value: expr -> bool
let rec is_value e =
  match e with
    | Klet _ _ e2  -> is_value e2
    | Kif _ e2 e3  -> is_value e2 && is_value e3
    | Kcall f args -> Boot.outOfHomeomorphism "[Core_run.is_value] Kcall"
    | Kaction _    -> false
    | Kunseq _     -> false
    | Kwseq _ _ _  -> false
    | Ksseq _ _ _  -> false
    | Kaseq _ _ _  -> false
    | Kindet i e   -> Boot.outOfHomeomorphism "[Core_run.is_value] Kindet"
    | Kbound i e   -> Boot.outOfHomeomorphism "[Core_run.is_value] Kbound"
    | Ksave k e    -> Boot.outOfHomeomorphism "[Core_run.is_value] Ksave"
    | Krun k       -> Boot.outOfHomeomorphism "[Core_run.is_value] Krun"
    | _ -> true
  end


(* The reduction rules *)
val red_pos: expr -> E.t expr
val red_neg: expr -> E.t expr

val red: expr -> E.t expr


(*
     S --perform a--> S'
   ---------------------
   (S, a) --a--> (S', v)
 *)
let rec red_pos e =
  match e with
    | Kaction (Core.Pos, (bs, a)) ->
        perform_action a             >>= fun (a, v) ->
        push_trace (Rule_Pos, bs, a) >>
        E.return v
    | _ -> E.mzero
  end

(*
      S --perform a--> S'
   -------------------------
   (S, ~a) --a--> (S', skip)
 *)
and red_neg e =
  match e with
    | Kaction (Core.Neg, (bs, a)) ->
        perform_action a             >>= fun (a, v) ->
        push_trace (Rule_Neg, bs, a) >>
        E.return v
    | _ -> E.mzero
  end

(*
                (S, e1) --a--> (S', v)
    -----------------------------------------------
    (S, as <- e1 >> e2) --a--> (S', <a> e2[as \ v])

             (S, e1) --a--> (S', e1')
  -----------------------------------------------
  (S, as <- e1; e2) --a--> (S', as<- e1'; <a> e2)
*)
and red_wseq_l e =
  match e with
    | Kwseq _as e1 e2 ->
        red e1                 >>= fun e1'       ->
        get_trace              >>= fun (_, _, a) ->
        update_rule Rule_WseqL >>
        E.return (if is_value e1' then annotate a (subst_syms _as e1' e2)
                                  else Kwseq _as e1' (annotate a e2))
    | _ -> E.mzero
  end

(*
          (S, e2) --a--> (S', e2')
  ----------------------------------------
  (S, () <- ~b; e2) --a--> (S', ~b || e2')
*)
and red_neg_wseq e =
  match e with
    | Kwseq [Nothing] (Kaction (Core.Neg, b)) e2 ->
        red e2    >>= fun e2' ->
        E.return match e2' with
                   | Kunseq e2's -> Kunseq $ (Kaction (Core.Neg, b)) :: e2's
                   | _           -> Kunseq [Kaction (Core.Neg, b); e2']
                 end
    | _ -> E.mzero
  end

(*
                     (S, ej) --a--> (S, ej')
  ------------------------------------------------------------
  (S, e1 || .. ej .. || ek) --a--> (S', e1 || .. ej' .. || ek)
*)
and red_unseq e =
  match e with
    | Kunseq es ->
        pick_one es            >>= fun (es1, ej, es2) ->
        red ej                 >>= fun ej'            ->
        update_rule Rule_Unseq >>
        E.return (Kunseq (es1 @
          match ej' with
            | Kskip -> es2
(*      Kunseq ej's -> filter (/= Kskip) $ ej's ++ es2 -- TODO check *)
            | _     -> ej' :: es2
          end))
    | _ -> E.mzero
  end





and red e = E.msum [
  red_pos e; red_neg e;
  red_wseq_l e; red_neg_wseq e;
  red_unseq e
]

































(* Full execution of an expression *)
let rec star_red e =
  red e >>= fun e' ->
  if is_value e' then get_fulltrace
                 else star_red e'



(* HACK *)

let rec convert_expr e =
  match e with
    | Core.Kskip -> Kskip
    | Core.Kconst n -> Kconst n
(*
    | Core.Kaddr o -> Kaddr o
*)
    | Core.Ksym a -> Ksym a
    | Core.Kop op e1 e2 -> Kop op (convert_expr e1) (convert_expr e2)
    | Core.Ktrue -> Ktrue
    | Core.Kfalse -> Kfalse
    | Core.Knot e -> Knot (convert_expr e)
    | Core.Kctype ty -> Kctype ty
    | Core.Klet a e1 e2 -> Klet a (convert_expr e1) (convert_expr e2)
    | Core.Kif e1 e2 e3 -> Kif (convert_expr e1) (convert_expr e2) (convert_expr e3)
    | Core.Kcall f args -> Kcall f (List.map convert_expr args)
    | Core.Kundef -> Kundef
    | Core.Kerror -> Kerror
    | Core.Kaction a -> Kaction (convert_paction a)
    | Core.Kunseq es -> Kunseq (List.map convert_expr es)
    | Core.Kwseq _as e1 e2 -> Kwseq _as (convert_expr e1) (convert_expr e2)
    | Core.Ksseq _as e1 e2 -> Ksseq _as (convert_expr e1) (convert_expr e2)
    | Core.Kaseq a b u -> Kaseq a (convert_action b) (convert_paction u)

(*    | Core.Kindet k e -> Kindet k (convert_expr e) *)
(*    | Core.Kbound k e -> Kbound k (convert_expr e) *)

    | Core.Ksame e1 e2 -> Ksame (convert_expr e1) (convert_expr e2)
(*
    | Core.Ksave l e -> Ksave l (convert_expr e)
    | Core.Krun l -> Krun l (convert_expr e)
*)
  end

and convert_paction (p, a) = (p, convert_action a)
and convert_action a =
  ({}, match a with
    | Core.Kcreate ty    -> Kcreate (convert_expr ty)
    | Core.Kalloc n      -> Kalloc (convert_expr n)
    | Core.Kkill a       -> Kkill a
    | Core.Kstore ty o v -> Kstore (convert_expr ty) (convert_expr o) (convert_expr v)
    | Core.Kload ty o    -> Kload (convert_expr ty) (convert_expr o)
  end) 

(*
and action_ =
  | Kcreate of expr
  | Kalloc of expr
  | Kkill of Core.sym
  | Kstore of expr * expr * expr
  | Kload of expr * expr

and action = set trace_action * action_
and paction = Core.polarity * action
 *)



let run (f: Core.file) : Exception.t (list E.trace) Errors.cause =
  let trs = let (_, _, body) = Pmap.find f.Core.main f.Core.fun_map in
                 List.map fst $ (star_red (convert_expr body) >> get_fulltrace) initial_state in
  Exception.return trs

(*
  let a = Tcreate (Ail.VOID {})      in
  let b = Tstore (Ail.VOID {}) 42 10 in
  let c = Tload (Ail.VOID {}) 42     in
  Exception.return [[
    (Rule_Pos, {}, a);
    (Rule_Pos, {a}, b);
    (Rule_Pos, {a; b}, c)
  ];
[
    (Rule_Pos, {}, a);
    (Rule_Pos, {a}, c);
    (Rule_Pos, {a; c}, b)
  ]
]
*)
