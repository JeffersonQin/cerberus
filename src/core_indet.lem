open Global

type ordering = Before | After | NoOrdering

module L = struct
  (* monadic operations *)
  val return: forall 'a. 'a -> list 'a
  let return x = [x]
  
  val bind: forall 'a 'b. list 'a -> ('a -> list 'b) -> list 'b
  let bind m f = List.fold_right (fun x y -> (f x) @ y) m []
  
  
  (* MonadPlus operations *)
  val mzero: forall 'a. list 'a
  let mzero = []
  
  val mplus: forall 'a. list 'a -> list 'a -> list 'a
  let mplus = (@)
  
  
  (* generic functions (that should be moved out once we have type-classes) *)
  val msum: forall 'a. list (list 'a) -> list 'a
  let msum = List.concat
  
  module Operators = struct
    let (>>=) = bind
    let (>>) m f = bind m (fun _ -> f)
  end
  
  open Operators
  
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)

end

(* -------------------------------------------------------------------------- *)
open L.Operators



type expr =
  | Kskip
  | Kconst of num
  | Kaddr of Core.mem_addr
  | Ksym of Core.sym
  | Kop of Core.binop * expr * expr
  | Ktrue
  | Kfalse
  | Knot of expr
  | Kctype of Ail.ctype
  | Klet of Core.sym * expr * expr
  | Kif of expr * expr * expr
  | Kcall of Core.sym * list expr
  | Ksame of expr * expr
  | Kundef
  | Kerror
  | Kaction of paction
  | Kunseq of list (expr)
  | Kwseq of list (option Core.sym) * expr * expr
  | Ksseq of list (option Core.sym) * expr * expr
  | Kaseq of option Core.sym * action * paction
  | Kindet of expr
  | Kbound of num * expr
  | Ksave of Core.cont * expr
  | Krun of Core.cont
  
  | Kbefore of expr
  | Kafter of expr
  
  (* A [Kindet e] becomes a [Knd es] *)
  | Knd of list expr


and action =
  | Kcreate of expr
  | Kalloc of expr
  | Kkill of expr
  | Kstore of expr * expr * expr
  | Kload of expr * expr
and paction = Core.polarity * action







val     import_expr: Core.expr zero -> expr
let rec import_expr e =
  match e with
  | Core.Kskip            -> Kskip
  | Core.Kconst n         -> Kconst n
  | Core.Kaddr o          -> Kaddr o
  | Core.Ksym a           -> Ksym a
  | Core.Kop binop e1 e2  -> Kop binop (import_expr e1) (import_expr e2)
  | Core.Ktrue            -> Ktrue
  | Core.Kfalse           -> Kfalse
  | Core.Knot e           -> Knot (import_expr e)
  | Core.Kctype ty        -> Kctype ty
  | Core.Klet a e1 e2     -> Klet a (import_expr e1) (import_expr e2)
  | Core.Kif e1 e2 e3     -> Kif (import_expr e1) (import_expr e2) (import_expr e3)
  | Core.Kcall f args     -> Kcall f (List.map import_expr args)
  | Core.Ksame e1 e2      -> Ksame (import_expr e1) (import_expr e2)
  | Core.Kundef           -> Kundef
  | Core.Kerror           -> Kerror
  | Core.Kaction pact     -> Kaction (import_paction pact)
  | Core.Kunseq es        -> Kunseq (List.map import_expr es)
  | Core.Kwseq _as e1 e2  -> Kwseq _as (import_expr e1) (import_expr e2)
  | Core.Ksseq _as e1 e2  -> Ksseq _as (import_expr e1) (import_expr e2)
  | Core.Kaseq a act pact -> Kaseq a (import_action act) (import_paction pact)
  | Core.Kindet e         -> Kindet (import_expr e)
  | Core.Kbound i e       -> Kbound i (import_expr e)
  | Core.Ksave k e        -> Ksave k (import_expr e)
  | Core.Krun k           -> Krun k
  end

and import_action (_, act) =
  match act with
    | Core.Kcreate e_ty        -> Kcreate (import_expr e_ty)
    | Core.Kalloc e_n          -> Kalloc (import_expr e_n)
    | Core.Kkill e_o           -> Kkill (import_expr e_o)
    | Core.Kstore e_ty e_o e_n -> Kstore (import_expr e_ty) (import_expr e_o) (import_expr e_n)
    | Core.Kload e_ty e_o      -> Kload (import_expr e_ty) (import_expr e_o)
  end
and import_paction (p, act) = (p, import_action act)


val     export_expr: expr -> Core.expr zero
let rec export_expr e =
  match e with
  | Kskip            -> Core.Kskip
  | Kconst n         -> Core.Kconst n
  | Kaddr o          -> Core.Kaddr o
  | Ksym a           -> Core.Ksym a
  | Kop binop e1 e2  -> Core.Kop binop (export_expr e1) (export_expr e)
  | Ktrue            -> Core.Ktrue
  | Kfalse           -> Core.Kfalse
  | Knot e           -> Core.Knot (export_expr e)
  | Kctype ty        -> Core.Kctype ty
  | Klet a e1 e2     -> Core.Klet a (export_expr e1) (export_expr e2)
  | Kif e1 e2 e3     -> Core.Kif (export_expr e1) (export_expr e2) (export_expr e3)
  | Kcall f args     -> Core.Kcall f (List.map export_expr args)
  | Ksame e1 e2      -> Core.Ksame (export_expr e1) (export_expr e2)
  | Kundef           -> Core.Kundef
  | Kerror           -> Core.Kerror
  | Kaction pact     -> Core.Kaction (export_paction pact)
  | Kunseq es        -> Core.Kunseq (List.map export_expr es)
  | Kwseq _as e1 e2  -> Core.Kwseq _as (export_expr e1) (export_expr e2)
  | Ksseq _as e1 e2  -> Core.Ksseq _as (export_expr e1) (export_expr e2)
  | Kaseq a act pact -> Core.Kaseq a (export_action act) (export_paction pact)
  | Kindet e         -> Core.Kindet (export_expr e)
  | Kbound i e       -> Core.Kbound i (export_expr e)
  | Ksave k e        -> Core.Ksave k (export_expr e)
  | Krun k           -> Core.Krun k
  end

and export_action act =
  ({},
  match act with
    | Kcreate e_ty        -> Core.Kcreate (export_expr e_ty)
    | Kalloc e_n          -> Core.Kalloc (export_expr e_n)
    | Kkill e_o           -> Core.Kkill (export_expr e_o)
    | Kstore e_ty e_o e_n -> Core.Kstore (export_expr e_ty) (export_expr e_o) (export_expr e_n)
    | Kload e_ty e_o      -> Core.Kload (export_expr e_ty) (export_expr e_o)
  end)
and export_paction (p, act) = (p, export_action act)




(* TODO: duplicate from Core_run *)
val pick_one: forall 'a. list 'a -> list (list 'a * 'a * list 'a)
let rec _pick_one acc = function
  | []    -> []
  | x::xs -> (List.rev acc, x, xs) :: _pick_one (x::acc) xs
end
let pick_one l = L.msum $ List.map L.return (_pick_one [] l)


val     one: expr -> list (ordering * expr)
let rec one e =
  match e with
    | Kaction pact -> L.mplus (L.return (Before, Kbefore $ Kaction pact))
                              (L.return (After, Kafter   $ Kaction pact))
    
    | Kwseq _as (Kindet e1) e2 -> L.return (After, Kwseq _as (Kindet e1)  (Kafter e2))
    | Kwseq _as e1 (Kindet e2) -> L.return (After, Kwseq _as (Kbefore e1) (Kindet e2))
    
    | Kwseq _as e1 e2 -> one e1 >>= fun (d, e1') ->
                     match d with
                       | Before -> one e2 >>= fun (d', e2') -> L.return (d', Kwseq _as e1' e2')
		       | After  -> L.return (d, Kwseq _as e1' (Kafter e2))
                     end
    
    | Kunseq es -> (L.mapM one es >>= L.return -| unzip) >>= fun (ds, es') ->
                   L.return ((if all (fun x -> x = Before) ds then Before else After), Kunseq es')



(* Nothing to do | No direction *)
  | Kskip        -> L.return (NoOrdering, e)
  | Kconst n     -> L.return (NoOrdering, e)
  | Kaddr x      -> L.return (NoOrdering, e)
  | Ksym a       -> L.return (NoOrdering, e)
  | Kop op e1 e2 -> L.return (NoOrdering, e)
  | Ktrue        -> L.return (NoOrdering, e)
  | Kfalse       -> L.return (NoOrdering, e)
  | Knot e       -> L.return (NoOrdering, e)
  | Kctype ty    -> L.return (NoOrdering, e)
  | Klet a e1 e2 -> L.return (NoOrdering, e)
  | Kif e1 e2 e3 -> L.return (NoOrdering, e)
  | Kcall f args -> L.return (NoOrdering, e)
  | Ksame e1 e2  -> L.return (NoOrdering, e)
  | Kundef       -> L.return (NoOrdering, e)
  | Kerror       -> L.return (NoOrdering, e)


(*
  | Kwseq _as e1 e2
  | Ksseq _as e1 e2
  | Kaseq _a act pact
  | Kindet e
*)


(* [one] is only called a particular Kbound and on that run ignore the inner Kbounds *)
  | Kbound i e -> one e >>= fun (d, e') -> L.return (d, Kbound i e')

(*
  (* [one] is called of core expression corresponding to C expression so
           there is no control operator *)
  | Ksave k e
  | Krun k
*)
  
(* (* this ctor can't already exist *)
  | Kbefore e 
  | Kafter e
  | Knd es
*)
  end

(*
one (Katom a) = return (B, Kbefore (Katom a)) `mplus` return (A, Kafter (Katom a))

one (Kseq Kindet e2) = return (A, Kseq Kindet (Kafter e2)) -- CHECK returned Dir
one (Kseq e1 Kindet) = return (B, Kseq (Kbefore e1) Kindet) -- CHECK returned Dir

one (Kseq e1 e2) = do
  (d, e1') <- one e1
  case d of
    B -> one e2 >>= \(d', e2') -> return (d', Kseq e1' e2') -- TODO: not sure about the returned dir
    A -> return (d, Kseq e1' (Kafter e2))

one (Kunseq es) = do
  (ds, es') <- mapM one es >>= return . unzip
  return (if all (==B) ds then B else A, Kunseq es')
*)




(*
let rec b_action_one e =
  match e with
    | Kaction (p, act) -> L.return (Before, Kbefore $ Kaction (p, act))
    | _                -> L.mzero
  end

and a_action_one e =
  match e with
    | Kaction (p, act) -> L.return (After, Kafter $ Kaction (p, act))
    | _                -> L.mzero
  end

and wseq_l_one e =
  match e with
    | Kwseq _as e1 e2 -> one e1 >>= fun (ord, e1') ->
                         L.return $ match ord with
                           | Before -> (Before, Kwseq _as e1' e2         )
                           | After  -> (After,  Kwseq _as e1' (Kafter e2))
                         end
    | _ -> L.mzero
  end

and wseq_r_one e =
  match e with
    | Kwseq _as e1 e2 -> one e2 >>= fun (ord, e2') ->
                         L.return $ match ord with
                           | Before -> (Before, Kwseq _as (Kbefore e1) e2 )
                           | After  -> (After,  Kwseq _as e1           e2')
                         end
    | _ -> L.mzero
  end

and unseq_one e =
  match e with
    | Kunseq es -> pick_one es            >>= fun (es1, ej, es2) ->
                   one ej                 >>= fun (ord, ej')     ->
                   L.return (ord, Kunseq (es1 @ ej' :: es2))
    | _ -> L.mzero
  end

and one e = L.msum [
  b_action_one e; a_action_one e;
  wseq_l_one e; wseq_r_one e;
 ]
*)

val determinate_expr: Core.expr zero -> list expr
let determinate_expr e =
  [import_expr e] (* TODO *)



(* TODO: hack *)
(*  *)
val order: Core.file zero -> Exception.t (list (num * Core.file zero)) (Errors.cause)
let order (f: Core.file zero) =
  let fbodies' = List.map (fun (_, (_, _, e)) -> determinate_expr e) $ Pmap.bindings f.Core.fun_map in
  
  
  
  
  Exception.return [(1,f)]

(*


  Exception.return <| f with fun_map= f.fun_map |>
  Exception.return (numerote $ List.map export_expr (one (import_expr e))) (* (numerote $ List.map export_expr $ one (import_expr e)) (* [(1, e); (2, e)] *) *)
  (* Boot.outOfHomeomorphism "hello" *)


*)

