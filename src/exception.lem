open Global

type t 'a 'msg =
  | Result of 'a
  | Exception of 'msg

let bind m k =
  match m with
    | Result a    -> k a
    | Exception s -> Exception s
  end

let rbind k m = bind m k

let return a = Result a
let throw m = Exception m
let fail = throw
let join m = bind m (fun x -> x)

val fmap: forall 'a 'b 'msg. ('a -> 'b) -> t 'a 'msg -> t 'b 'msg
let fmap f m = bind m (return -| f)

val app: forall 'a 'b 'msg. t ('a -> 'b) 'msg -> t 'a 'msg -> t 'b 'msg
let app mf m = bind mf (fun f -> fmap f m)

let catch = function
  | Result    _ -> None
  | Exception m -> Some m
  end

let of_option m = function
  | Some a -> return a
  | None   -> throw  m
  end

let to_bool = function
  | Result    _ -> true
  | Exception _ -> false
  end

module Operators = struct
  let (>>=) = bind
end

open Operators

let map2 f mx my    = app (fmap f mx) my
let map3 f mx my mz = app (map2 f mx my) mz

val sequence: forall 'a 'msg. list (t 'a 'msg) -> t (list 'a) 'msg
let sequence ms =
  List.fold_right
    (fun m ms' ->
      m   >>= fun x  ->
      ms' >>= fun xs ->
      return (x::xs)
    ) ms (return [])

val t_list: forall 'a 'b 'msg. ('a -> list (t 'b 'msg)) -> 'a -> t (list 'b) 'msg
let t_list t xs = sequence (t xs)

val map_list: forall 'a 'b 'msg. ('a -> t 'b 'msg) -> list 'a -> t (list 'b) 'msg
let map_list f = t_list (List.map f)



let sequence_map mmap =
  Ocaml.Pmap.fold (fun k m mm->
    m  >>= fun x   ->
    mm >>= fun map ->
    return (Pmap.add k x map)
  ) mmap (return Pmap.empty)

let map_map f m = sequence_map (Ocaml.Pmap.map f m)

let inj_right f (a, b) = f b >>= fun b' -> return (a, b')

let compare cmp cmp_msg a1 a2 =
  match (a1, a2) with
  | (Result r1, Result r2) -> cmp r1 r2
  | (Exception e1, Exception e2) -> cmp_msg e1 e2
  | (Result _, _) -> Ord.Lt
  | (_, Result _) -> Ord.Gt
  end

let bind_exception m k =
  match m with
    | Result a -> Result a
    | Exception s -> k s
  end

let rbind_exception k m = bind_exception m k
