open Meaning.Expression.Operators
open Meaning.Statement.Operators

module A = Ail
module C = Constraint
module T = Types
module Tc = Type_constraint

module Me = Meaning.Expression
module Ms = Meaning.Statement

module Effect = struct
  module M = Symbol_state

  let return = M.return

  module Operators = struct
    let (>>=) = M.bind
  end

  let init = M.init
  let foldlM = M.foldlM
end

module E = Effect
open E.Operators

let exp_type    = Annotate.exp_type_of
let lvalue_type = Annotate.lvalue_type_of

let is_function_id file e =
  match Annotate.exp_of e with
  | A.VARIABLE fid ->
      let (ids, body) = Pmap.find fid file.A.fn_map in
      Some (fid, ids , body)
  | _ -> None
  end

let update_env env ids =
  let f id e =
    C.fresh_address >>= fun a ->
    E.return (Pmap.add id a e) in
  E.foldlM f ids env

let conv t t' x =
  x               >>= fun (a, m) ->
  Tc.conv t t' a  >>= fun (v, c) ->
  E.return (v, m +& c)

let conv_int_lifted t (a, m) =
  Tc.conv_int t a >>= fun (v, c) ->
  E.return (v, m +& c)

let rec iterate e s f_e f_s n ml_prev =
  let m_neg (a, m) = m +& (C.eq  a C.zero) in
  let m_pos (a, m) = m +& (C.neq a C.zero) in
  match n with
  | 0 ->
      f_e e >>= fun m  ->
      E.return (Ms.exit_loop (m_neg m) ml_prev)
  | _ ->
      f_e e >>= fun m  ->
      f_s s >>= fun ml ->
      let ml' = Ms.enter_loop (m_pos m) (m_neg m) ml_prev in
      iterate e s f_e f_s (n-1) (ml' --&> ml)
  end

let rec reduce_lvalue n b env file exp =
  let f = reduce_exp n b env file in
  match Annotate.exp_of exp with
  | A.VARIABLE id ->
      E.return (Pmap.find id env, Me.unit)
  | A.UNARY A.INDIRECTION e ->
      f e >>= fun (a, m) ->
      let t = T.base_of_pointer (T.pointer_convert (exp_type e)) in
      let ill_aligned = C.neg (Tc.is_aligned t a) in
      let null = C.eq a C.null in
      let c = C.implies (C.disj null ill_aligned) C.undef in
      E.return (a, m +& c)
  | _ ->
      C.fresh >>= fun a ->
      E.return (a, Me.null)
  end

(* [b] is a bindings(?) map *)
and reduce_exp (n: num) b env file exp =
  let f                      = reduce_exp n b env file in
  let f_lvalue e             = reduce_lvalue n b env file e in
  let lookup_type id         = fst (Pmap.find id file.A.id_map) in
  let conv_exp   e           = f e >>= conv_int_lifted (exp_type exp) in
  let conv_int t e           = f e >>= conv_int_lifted t in
  let usual_arithmetic e1 e2 =
    T.usual_arithmetic (exp_type e1) (exp_type e2) in
  let overflow t c           = C.implies (C.neg (Tc.in_range t c)) C.undef in
  
  match Annotate.exp_of exp with
  | A.VARIABLE id ->
      if T.is_array (lookup_type id) then
        E.return (Pmap.find id env, Me.unit)
      else
        f_lvalue exp >>= fun (a, m) ->
        C.fresh      >>= fun v      ->
        Action.load (lvalue_type exp) a v >>= fun load ->
        E.return (v, m -@> load)
  | A.CONSTANT (A.CONST_INT (i, _)) ->
      E.return (C.const i, Me.unit)
  
  (* (6.5.2.4) Postfix increment and decrement operators *)
  | A.UNARY A.POSTFIX_INCR e ->
      f_lvalue e >>= fun (a, m) ->
      C.fresh    >>= fun v      ->
      let incr = C.plus v C.one in
      Tc.conv_int (exp_type e) incr >>= fun (v', c) ->
      Action.load  (lvalue_type e) a v  >>= fun load  ->
      Action.store (lvalue_type e) a v' >>= fun store ->
      E.return (v, Me.conj_sb (m +& c) (Me.add_ls_pair load store Me.unit))
  | A.UNARY A.POSTFIX_DECR e ->
      f_lvalue e >>= fun (a, m) ->
      C.fresh    >>= fun v      ->
      let decr = C.minus v C.one in
      Tc.conv_int (exp_type e) decr >>= fun (v', c) ->
      Action.load  (lvalue_type e) a v  >>= fun load  ->
      Action.store (lvalue_type e) a v' >>= fun store ->
      let modify = Me.add_ls_pair load store Me.unit in
      if T.is_signed_integer(exp_type exp) then
        let c' = overflow (exp_type exp) decr in
        E.return (decr, Me.conj_sb (m +& c +& c') modify)
      else
        E.return (v, Me.conj_sb (m +& c) modify)
  | A.UNARY A.ADDRESS (_, (A.UNARY A.INDIRECTION e)) -> f e
  | A.UNARY A.ADDRESS e -> f_lvalue e
  | A.CAST t e -> conv t (exp_type e) (f e)
  | A.BINARY (A.ARITHMETIC A.ADD) e1 e2 ->
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let sum = C.plus a1 a2 in
        if T.is_signed_integer(exp_type exp) then
          let c = overflow (exp_type exp) sum in
          E.return (sum, m1 -&- m2 +& c)
        else
          Tc.conv_int (exp_type exp) (C.plus a1 a2) >>= fun (a, c) ->
          E.return (a, m1 -&- m2 +& c)
      else
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        if T.is_pointer (exp_type e1) then
          let size = Tc.size (T.base_of_pointer (exp_type e1)) in
          let a = C.offset a1 a2 size in
          Action.same a1 a >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
        else
          let size = Tc.size (T.base_of_pointer (exp_type e2)) in
          let a = C.offset a2 a1 size in
          Action.same a a1 >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
  | A.BINARY (A.ARITHMETIC A.SUB) e1 e2 ->
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let diff = C.minus a1 a2 in
        if T.is_signed_integer (exp_type exp) then
          let c = overflow (exp_type exp) diff in
          E.return (diff, (m1 -&- m2) +& c)
        else
          Tc.conv_int (exp_type exp) (C.minus a1 a2) >>= fun (a, c) ->
          E.return (a, m1 -&- m2 +& c)
      else (*if T.is_integer (exp_type e2) then*)
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        let size = Tc.size (T.base_of_pointer (exp_type e1)) in
        let a = C.offset a1 (C.minus C.zero a2) size in
        Action.same a1 a >>= fun same ->
        E.return (a, (m1 -&- m2) -@> same)
  | A.BINARY (A.ARITHMETIC A.MOD) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      let modulo = C.modulo a1 a2 in
      let div_zero = C.implies (C.eq a2 C.zero) C.undef in
      if T.is_signed_integer(exp_type exp) then
        let c = overflow (exp_type exp) (C.div a1 a2) in
        E.return (modulo, (m1 -&- m2) +& div_zero +& c)
      else
        Tc.conv_int (exp_type exp) modulo >>= fun (a, c) ->
        E.return (a, (m1 -&- m2 +& c) +& div_zero)
  | A.BINARY (A.ARITHMETIC A.MUL) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      let mult = C.mult a1 a2 in
      if T.is_signed_integer(exp_type exp) then
        let c = overflow (exp_type exp) mult in
        E.return (mult, (m1 -&- m2) +& c)
      else
        Tc.conv_int (exp_type exp) mult >>= fun (a, c) ->
        E.return (a, (m1 -&- m2 +& c))
  | A.BINARY A.COMMA e1 e2 ->
      f e1 >>= fun (_,  m1) ->
      f e2 >>= fun (a2, m2) ->
      E.return (a2, m1 -&> m2)
  | A.BINARY A.OR e1 e2 ->
      f e1 >>= fun (a1, m1) ->
      f e2 >>= fun (a2, m2) ->
      C.fresh >>= fun a ->
      let first_only = C.conj (C.neq a1 C.zero) (C.eq a C.one) in
      let both = C.conj
        (C.eq a1 C.zero)
        (C.case (C.eq a2 C.zero) (C.eq a C.zero) (C.eq a C.one)) in
      E.return (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both))
  | A.BINARY A.AND e1 e2 ->
      f e1 >>= fun (a1, m1) ->
      f e2 >>= fun (a2, m2) ->
      C.fresh >>= fun a ->
      let first_only = C.conj (C.eq a1 C.zero) (C.eq a C.zero) in
      let both = C.conj
        (C.neq a1 C.zero)
        (C.case (C.neq a2 C.zero) (C.eq a C.one) (C.eq a C.zero)) in
      E.return (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both))
  | A.BINARY (A.ARITHMETIC A.SHL) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_int (T.promote (exp_type e1)) e2 >>= fun (a2, m2) ->
      let shifted = C.mult a1 (C.pow a2) in
      if T.is_signed_integer (exp_type exp) then
        let not_repr = C.neg (Tc.in_range (exp_type exp) shifted) in
        let neg = C.lt shifted C.zero in
        let c = C.implies (C.disj neg not_repr) C.undef in
        E.return (shifted, (m1 -&- m2) +& c)
      else
        Tc.conv_int (exp_type exp) shifted >>= fun (a, c) ->
        E.return (a, m1 -&- m2 +& c)
  | A.BINARY (A.ARITHMETIC A.SHR) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_int (T.promote (exp_type e1)) e2 >>= fun (a2, m2) ->
      let shifted = C.div a1 (C.pow a2) in
      if T.is_signed_integer (exp_type exp) then
        C.fresh >>= fun a ->
        let negative = C.lt shifted C.zero in
        let c = C.case negative
          (C.eq a (C.fn Symbol.shift_r [shifted]))
          (C.eq a shifted) in
        E.return (shifted, (m1 -&- m2) +& c)
      else
        E.return (shifted, m1 -&- m2)
  | A.BINARY A.EQ e1 e2 ->
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        let t = usual_arithmetic e1 e2 in
        conv_int t e1 >>= fun (a1, m1) ->
        conv_int t e2 >>= fun (a2, m2) ->
        C.fresh       >>= fun a        ->
        let c = C.case (C.eq a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        E.return (a, (m1 -&- m2) +& c)
      else if T.is_pointer (exp_type e1) && T.is_pointer (exp_type e2) then
        (*TODO*) E.return (C.one, Me.null)
      else if Typing.is_null_pointer_constant e1 then
        (*TODO*) E.return (C.one, Me.null)
      else (*TODO*) E.return (C.one, Me.null)
  | A.BINARY A.NE e1 e2 ->
      if T.is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t e1 >>= fun (a1, m1) ->
        conv_int t e2 >>= fun (a2, m2) ->
        C.fresh       >>= fun a        ->
        let c = C.case (C.neg (C.eq a1 a2)) (C.eq a C.one) (C.eq a C.zero) in
        E.return (a, (m1 -&- m2) +& c)
      else (*TODO*) E.return (C.one, Me.null)
        (* Pointer comparison. *)
  | A.BINARY A.LT e1 e2 ->
      if T.is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t e1 >>= fun (a1, m1) ->
        conv_int t e2 >>= fun (a2, m2) ->
        C.fresh       >>= fun a        ->
        let c = C.case (C.lt a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        E.return (a, (m1 -&- m2) +& c)
      else (*TODO*) E.return (C.one, Me.null)
        (* Pointer comparison. *)
  | A.BINARY A.LE e1 e2 ->
      if T.is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t e1 >>= fun (a1, m1) ->
        conv_int t e2 >>= fun (a2, m2) ->
        C.fresh       >>= fun a        ->
        let c = C.case (C.le a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        E.return (a, (m1 -&- m2) +& c)
      else (*TODO*) E.return (C.one, Me.null)
        (* Pointer comparison. *)
  | A.BINARY A.GT e1 e2 ->
      if T.is_real (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t e1 >>= fun (a1, m1) ->
        conv_int t e2 >>= fun (a2, m2) ->
        C.fresh       >>= fun a        ->
        let c = C.case (C.gt a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        E.return (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
        (* TODO Comparing two pointers to different object is
           undefined unless ... *)
        f e1    >>= fun (a1, m1) ->
        f e2    >>= fun (a2, m2) ->
        C.fresh >>= fun a        ->
        let c = C.case (C.gt a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        Action.same a1 a2 >>= fun same ->
        E.return (a, (m1 -&- m2) +& c -@> same)
  | A.BINARY A.GE e1 e2 ->
      if T.is_arithmetic (exp_type e1) then
        let t = usual_arithmetic e1 e2 in
        conv_int t e1 >>= fun (a1, m1) ->
        conv_int t e2 >>= fun (a2, m2) ->
        C.fresh       >>= fun a        ->
        let c = C.case (C.ge a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        E.return (a, (m1 -&- m2) +& c)
      else
        (* Pointer comparison. *)
        (* TODO Comparing two pointers to different object is
           undefined unless ... *)
        f e1	>>= fun (a1, m1) ->
        f e2	>>= fun (a2, m2) ->
        C.fresh >>= fun a        ->
        let c = C.case (C.ge a1 a2) (C.eq a C.one) (C.eq a C.zero) in
        Action.same a1 a2 >>= fun same ->
        E.return (a, (m1 -&- m2) +& c -@> same)
  | A.BINARY (A.ARITHMETIC A.BAND) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      C.fresh     >>= fun a        ->
      E.return (a, (m1 -&- m2) +& (C.eq a (C.bit_and a1 a2)))
  | A.BINARY (A.ARITHMETIC A.BOR) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      C.fresh     >>= fun a        ->
      E.return (a, (m1 -&- m2) +& (C.eq a (C.bit_or a1 a2)))
  | A.BINARY (A.ARITHMETIC A.XOR) e1 e2 ->
      conv_exp e1 >>= fun (a1, m1) ->
      conv_exp e2 >>= fun (a2, m2) ->
      C.fresh     >>= fun a        ->
      E.return (a, (m1 -&- m2) +& (C.eq a (C.bit_xor a1 a2)))
  | A.ASSIGN None e1 e2 ->
      f_lvalue e1 >>= fun (a1, m1) ->
      f        e2 >>= fun (a2, m2) ->
      Tc.conv (exp_type e1) (exp_type e2) a2 >>= fun (a, c) ->
      Action.store (lvalue_type e1) a1 a >>= fun write ->
      E.return (a, Me.conj_sb (m1 -&- m2 +& c) (Me.add_side_effect write Me.unit))
  | A.CONDITIONAL e1 e2 e3 ->
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        f e1        >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        conv_exp e3 >>= fun (a3, m3) ->
        C.fresh     >>= fun a        ->
        let pos = m2 +& (C.eq a a2) +& (C.eq  a1 C.zero) in
        let neg = m3 +& (C.eq a a3) +& (C.neq a1 C.zero) in
        E.return (a, m1 -&> (pos -/- neg))
      else (*TODO*) E.return (C.one, Me.null)
  | A.CALL e es ->
      match is_function_id file e with
      | Some (fid, ids, s) ->
          let depth = Pmap.find fid b in
          if depth = 0 then
            C.fresh >>= fun a ->
            E.return (a, Me.null)
          else
            update_env env ids >>= fun env' ->
            let b' = Pmap.add fid (depth - 1) b in
            let args =
              let f id e = (Pmap.find id env', lookup_type id, e) in
              List.map2 f ids es in
            let f_create (l, t, e) m' =
              conv (T.unqualify t) (exp_type e) (f e) >>= fun (a, m) ->
              Action.create   t l                     >>= fun create ->
              Action.fn_store t l a                   >>= fun store  ->
              E.return ((m' -&- m) +@ create -@> store) in
            let f_kill (l, _, _) m =
              Action.kill l >>= fun kill ->
              E.return (m +@ kill) in
            E.foldlM f_create args Me.unit     >>= fun m_create ->
            E.foldlM f_kill   args Me.unit     >>= fun m_kill   ->
            C.fresh                            >>= fun a        ->
	    reduce_stmt n b' env' file fid a s >>= fun ml       ->
            Action.call                        >>= fun call     ->
            let m_body = Ms.exit_function call ml in
            E.return (a, m_create -&> m_body -&> m_kill)
      | None ->
          (* Function pointer. *)
          C.fresh >>= fun a ->
          E.return (a, Me.null)
      end
  | A.ALIGNOF t ->
      E.return (Tc.align t, Me.unit)
  | A.SIZEOF  t ->
      E.return (Tc.size  t, Me.unit)
  | _ ->
      if T.is_lvalue (Annotate.type_of exp) then
        f_lvalue exp                      >>= fun (a, m) ->
        C.fresh                           >>= fun v      ->
        Action.load (lvalue_type exp) a v >>= fun load   ->
        E.return (v, m -@> load)
      else
        C.fresh >>= fun a ->
        E.return (a, Me.null)
  end


(* reduce_stmt n b Pmap.empty file file.A.main C.Constants.return s *)
and reduce_stmt (n: num) b env (file: Ail.file _) fid return (_, stmt) =
  let f_s = reduce_stmt n b env file fid return in
  let f_e = reduce_exp  n b env file in
  let lift x = x >>= fun (a, m) -> E.return (a, Ms.normal m) in
  let lookup_type id = fst (Pmap.find id file.A.id_map) in
  match stmt with
  | A.SKIP ->
      E.return Ms.unit
  | A.IF e s1 s2 ->
      lift (f_e e) >>= fun (a, ml) ->
      f_s s1       >>= fun ml1     ->
      f_s s2       >>= fun ml2     ->
      let pos = ml1 ++& (C.neq a C.zero) in
      let neg = ml2 ++& (C.eq  a C.zero) in
      E.return (ml --&> (pos -//- neg))
  | A.BLOCK ids ss ->
      update_env env ids >>= fun env' ->
      let decls = [(Pmap.find id env', lookup_type id)| forall (id MEM ids) | true] in
      let f_create (l, t) ml =
        Action.create t l >>= fun create ->
        E.return (ml ++@ create) in
      let f_kill (l, _) ks =
        Action.kill l >>= fun kill ->
        E.return (ks union {kill}) in
      let f s ml' =
        reduce_stmt n b env' file fid return s >>= fun ml ->
        E.return (ml' --&> ml) in
      E.foldlM f_create decls Ms.unit >>= fun ml_create ->
      E.foldlM f        ss    Ms.unit >>= fun ml        ->
      E.foldlM f_kill   decls {}      >>= fun kills     ->
      E.return (Ms.add_actions_sp kills (ml_create --&> ml))
  | A.DECLARATION defns ->
      let f (id, e) ml' =
        let t = lookup_type id in
        let l = Pmap.find id env in
        lift (conv t (exp_type e) (f_e e)) >>= fun (a, ml) ->
        Action.store t l a                 >>= fun write   ->
        E.return ((ml --@> write) --&> ml') in
      E.foldlM f defns Ms.unit
  | A.RETURN_EXPRESSION e ->
      let t = T.function_return (lookup_type fid) in
      conv t (exp_type e) (f_e e) >>= fun (a, m) ->
      E.return (Ms.return (m +& C.eq a return))
  | A.RETURN_VOID -> E.return (Ms.return Me.unit)
  | A.EXPRESSION e ->
      lift (f_e e) >>= fun (_, ml) ->
      E.return ml
  | A.WHILE e s -> iterate e s f_e f_s n Ms.unit
  | A.BREAK    -> E.return (Ms.break    Me.unit)
  | A.CONTINUE -> E.return (Ms.continue Me.unit)
  end


(*  *)
let reduce_file (n: num) (file: A.file _) : E.M.t (set Meaning.Denotation.t) =
  let b =
    let f m (fid, _) = Pmap.add fid n m in
    List.fold_left f Pmap.empty (Pmap.bindings file.A.fn_map) in
  let (_, s) = Pmap.find file.A.main file.A.fn_map in
  reduce_stmt n b Pmap.empty file file.A.main C.Constants.return s >>= fun ml ->
  Action.call >>= fun call ->
  E.return (Ms.exit_function call ml)
(*
  List.map rd (List.map snd (Pmap.values file.A.fn_map))
*)


(* This is the entry function (called from main) *)
let reduce (n: num) (file: A.file _) : set Meaning.Denotation.t = E.init (reduce_file n file)
