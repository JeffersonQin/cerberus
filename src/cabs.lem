open Global

type cabsloc = <|
  lineno : num;
  filename: string;
  byteno: num;
  ident : num
|>

type location = Location.t


type sequential_operator =
  | COMMA
  | AND
  | OR

type arithmetic_operator =
  | ADD
  | SUB
  | MUL
  | DIV
  | MOD
  | BAND
  | BOR
  | XOR
  | SHL
  | SHR

type relational_operator =
  | EQ
  | NE
  | LT
  | GT
  | LE
  | GE

type binary_operator =
  | ARITHMETIC of arithmetic_operator
  | SEQUENTIAL of sequential_operator
  | RELATIONAL of relational_operator

type unary_operator =
  | MINUS
  | PLUS
  | NOT
  | BNOT
  | ADDRESS
  | INDIRECTION
  | PREFIX_INCR
  | PREFIX_DECR
  | POSTFIX_INCR
  | POSTFIX_DECR

type suffix =
  | SUFFIX_UNSIGNED
  | SUFFIX_UNSIGNED_LONG
  | SUFFIX_UNSIGNED_LONG_LONG
  | SUFFIX_LONG
  | SUFFIX_LONG_LONG

type integer_constant = num * suffix option

type constant =
  | CONST_INT of integer_constant
(*
  | CONST_FLOAT of string (* the textual representaton *)
  | CONST_CHAR of int64 list
  | CONST_WCHAR of int64 list
  | CONST_STRING of string
*)







(* [Storage-class specifiers] (6.7.1#1) *)
type storage_class =
  | AUTO
  | STATIC
  | EXTERN
  | REGISTER

(* [Type qualifiers] (6.7.3#1) *)
type qualifier =
  | CONST
  | RESTRICT
  | VOLATILE
  | ATOMIC

type specifier =
  | VOID
  | CHAR
  | SHORT
  | INT
  | LONG
(*  | FLOAT *)
(*  | DOUBLE *)
  | SIGNED
  | UNSIGNED
  | BOOL
(*  | COMPLEX *)
  | STRUCT of string option * struct_declaration list (* TODO: STRUCT_HACK *)
(* TODO: union-specifier *)
(* TODO: enum-specifier *)
(* TODO: typedef-name *)

and specifiers = specifier multiset
and qualifiers = qualifier set

and c_type =
  | BASE of qualifiers * specifiers
  | ARRAY of qualifiers * c_type * exp_l option
  | POINTER of qualifiers * c_type
  | FUNCTION of c_type * decl_l list

and expression =
  | UNARY of unary_operator * exp_l
  | BINARY of binary_operator * exp_l * exp_l 
  | ASSIGN of arithmetic_operator option * exp_l * exp_l
  | QUESTION of exp_l * exp_l * exp_l
(*
  | COMPOUND_LITERAL of (specifier * c_type) * init_expression
*)
  | CAST of c_type * exp_l
  | CALL of exp_l * exp_l list
  | CONSTANT of constant
  | VARIABLE of string
  | TYPE_SIZEOF of c_type
  | TYPE_ALIGNOF of c_type
  | INDEX of exp_l * exp_l
and exp_l = expression * location

(* TODO: STRUCT_HACK *)
and struct_declarator =
  | STRUCT_DECL of string * c_type
  | BITFIELD of (string * c_type) option * exp_l
and struct_declaration = specifiers * qualifiers * struct_declarator list option


and declaration = string * c_type * storage_class list
and decl_l = declaration * location
and definition = decl_l * exp_l option
and defn_l = definition * location

type statement =
  | SKIP
  | EXPRESSION of exp_l
  | BLOCK of stmt_l list
  | IF of exp_l * stmt_l * stmt_l option
  | WHILE of exp_l * stmt_l
  | DO of exp_l * stmt_l
  | FOR_EXP of exp_l option * exp_l option * exp_l option * stmt_l
  | FOR_DECL of defn_l list * exp_l option * exp_l option * stmt_l
  | BREAK
  | CONTINUE
  | RETURN of exp_l option
  | SWITCH of exp_l * stmt_l
  | CASE of exp_l * stmt_l
  | DEFAULT of stmt_l
  | LABEL of string * stmt_l
  | GOTO of string
  | DECLARATION of defn_l list

and stmt_l = statement * location

type global_definition =
  | FUNCTION_DEFINITION of decl_l * stmt_l
  | EXTERNAL_DECLARATION of defn_l list
  | STRUCT_ (* TODO: struct *)

type g_defn_l = global_definition * location

(* file name, list of toplevel definitions *)
type file = string * g_defn_l list
