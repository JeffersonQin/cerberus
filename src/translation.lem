module A = Ail
module C = Core
module T = Types


(* TODO: put somewhere *)
let ($) f x = f x


let rec mapWithLast f g = function
  | []      -> []
  | [x]     -> [g x]
  | (x::xs) -> f x :: mapWithLast f g xs
end


(* -------------------------------------------------------------------------- *)
module Effect = struct
  module M = Symbol_state

  let return = M.return

  module Operators = struct
    let (>>=) = M.bind
  end

  let init = M.init
  let foldlM = M.foldlM
  
  open Operators
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)
  let mapWithLastM f g xs = sequence (mapWithLast f g xs)

end

(* -------------------------------------------------------------------------- *)
module E = Effect
open E.Operators

let exp_type    = Annotate.exp_type_of
let lvalue_type = Annotate.lvalue_type_of


let fresh_symbol = Symbol_state.map (fun x -> x) Symbol_state.fresh




(* 'optimised' implementation of [\f -> unzip . map f] *)
val mapUnzip: forall 'a 'b 'c. ('a -> 'b * 'c) -> 'a list -> 'b list * 'c list
let rec mapUnzip_ f (xs, ys) = function
  | []      -> (xs, ys)
  | (l::ls) -> let (x,y) = f l in mapUnzip_ f (x::xs, y::ys) ls
end
let mapUnzip f l =
  let (xs, ys) = mapUnzip_ f ([],[]) l in
  (List.rev xs, List.rev ys)


let conv ty1 ty2 exp =
  fresh_symbol      >>= fun a_exp  ->
  fresh_symbol      >>= fun a_conv ->
  exp               >>= fun core_e ->
  E.return $ C.Kseq [a_exp] core_e (C.Klet [a_conv] (C.Kconv ty1 ty2 a_exp) (C.Ksym a_conv))


let is_function_id file e =
  match Annotate.exp_of e with
  | A.VARIABLE fid ->
      let (ids, body) = Pmap.find fid file.A.fn_map in
      Some (fid, ids , body)
  | _ -> None
  end



(*
let conv_int_lifted t (a, m) =
  Tc.conv_int t a >>= fun (v, c) ->
  E.return (v, m +& c)
*)

(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)

let rec translate_lvalue file exp =
  let f = translate_exp file in
  match Annotate.exp_of exp with
    | A.VARIABLE id -> E.return (C.Ksym id)
    
(*
    | A.UNARY A.INDIRECTION e ->
        f e >>= fun (a, m) ->
        let t = T.base_of_pointer (T.pointer_convert (exp_type e)) in
        let ill_aligned = C.neg (Tc.is_aligned t a) in
        let null = C.eq a C.null in
        let c = C.implies (C.disj null ill_aligned) C.undef in
        E.return (a, m +& c)
    | _ ->
        C.fresh >>= fun a ->
        E.return (a, Me.null)
*)
  end

(* ---------------------------------------------------------------------------------------------- *)

and translate_exp file exp =
  match Annotate.exp_of exp with
    (* WARNING: this is not enought (DEBUG FOR NOW) *)
    | A.VARIABLE id ->
        E.return $ C.Kload (lvalue_type exp) (C.Ksym id)
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.CONSTANT (Cabs.CONST_INT (i, _)) -> (* DONE *)
          E.return (C.Kconst i)
    
    
   (* ---------------------------------------------------------------------------------------------
    +                               [| e |]_lvalue  ~>  core_e                                    +
    +           ----------------------------------------------------------------- (post_incr)     +
    +           [| e++ |]_exp  ~>  a_lvalue <- core_e;                                            +
    +                              a_load <- load{signed int} a_lvalue;                           +
    +                              store{ty} a_lvalue (conv_int ty (a_load + 1));                 +
    +                              a_load                                                         +
    --------------------------------------------------------------------------------------------- *)
    | A.UNARY A.POSTFIX_INCR e -> (* TODO: atomic *)
        fresh_symbol            >>= fun a_lvalue ->
        fresh_symbol            >>= fun a_load   ->
        fresh_symbol            >>= fun a_incr   ->
        translate_lvalue file e >>= fun core_e   ->
        E.return $
          C.Kseq [a_lvalue] core_e
            (C.Kseq [a_load] (C.Kload (lvalue_type e) (C.Ksym a_lvalue))
               (C.Kseq [] (C.Kstore (lvalue_type e)
                                    (C.Ksym a_lvalue)
                                    (C.Kcall C.conv_int
                                             [C.Kctype (exp_type e);
                                             (C.Kop C.OpAdd (C.Ksym a_load) (C.Kconst 1))]))
                  (C.Ksym a_load)
               )
            )
    
    
   (* --------------------------------------------------------------------------------------------*)
    (* TODO *)
    | A.UNARY A.POSTFIX_DECR e ->
        E.return (C.DEBUG "A.UNARY A.POSTFIX_DECR e")
(*
        fresh_symbol            >>= fun a_lvalue ->
        fresh_symbol            >>= fun a_load   ->
        fresh_symbol            >>= fun a_incr   ->
        translate_lvalue file e >>= fun core_e   ->
        E.return $
          C.Kseq [a_lvalue] core_e
            (C.Kseq [a_load] (C.Kload (lvalue_type e) (C.Ksym a_lvalue))
               (C.Kseq [] (C.Kstore (lvalue_type e)
                                    (C.Ksym a_lvalue)
                                    (C.Kcall C.conv_int
                                             [C.Kctype (exp_type e);
                                             (C.Kop C.OpAdd (C.Ksym a_load) (C.Kconst 1))]))
                  (C.Ksym a_load)
               )
            )
*)
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.UNARY A.ADDRESS (_, (A.UNARY A.INDIRECTION e)) ->
        translate_exp file e
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.UNARY A.ADDRESS e ->
        translate_lvalue file e
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.CAST ty e ->
        translate_exp file e >>= fun core_e ->
        E.return $ C.Kcall C.conv [C.Kctype ty; C.Kctype (exp_type e)]
    
    
    (* ------------------------------------------------------------------------------------------ *)
    (* TODO *)
(*
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let sum = C.plus a1 a2 in
        if T.is_signed_integer(exp_type exp) then
          let c = overflow (exp_type exp) sum in
          E.return (sum, m1 -&- m2 +& c)
        else
          Tc.conv_int (exp_type exp) (C.plus a1 a2) >>= fun (a, c) ->
          E.return (a, m1 -&- m2 +& c)
      else
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        if T.is_pointer (exp_type e1) then
          let size = Tc.size (T.base_of_pointer (exp_type e1)) in
          let a = C.offset a1 a2 size in
          Action.same a1 a >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
        else
          let size = Tc.size (T.base_of_pointer (exp_type e2)) in
          let a = C.offset a2 a1 size in
          Action.same a a1 >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
*)
    | A.BINARY (Cabs.ARITHMETIC Cabs.ADD) e1 e2 ->
        if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
          (* if both operand have arithmetic types, then semantics is quite
             straightforward and we do the 'usual arithmetic conversion' *)
          fresh_symbol          >>= fun a_e1    ->
          fresh_symbol          >>= fun a_e2    ->
          fresh_symbol          >>= fun a_add   ->
          fresh_symbol          >>= fun a_conv  ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          
          (* Prepare the expression composing the evaluation of the operands which
             are unsequenced with respect to each other *)
          (* If we are ok with passing "complexe" expressions of type 'value' to
             functions, then we can get rid of the Klet *)
          let add_ctx x =
            C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
              (C.Klet [a_add] (C.Kop C.OpAdd (C.Ksym a_e1) (C.Ksym a_e2))
                 x) in
          
          (* The 'usual arithmetic conversion' *)
          if T.is_signed_integer (exp_type exp) then
            (* if the return type is signed, then there is an undefined behaviour
               in the presence of an arithmetic overflow *)
            E.return $ add_ctx (C.Kcall C.overflow [C.Kctype (exp_type exp); C.Ksym a_add])
          else
            (* otherwise, TODO: doc *)
            E.return $ add_ctx (C.Kcall C.conv_int [C.Kctype (exp_type exp); C.Ksym a_add])
            
        else
          (* otherwise, we have some pointer arithmetic *)
          fresh_symbol          >>= fun a_e1    ->
          fresh_symbol          >>= fun a_e2    ->
          fresh_symbol          >>= fun a_shift ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          if T.is_pointer (exp_type e1) then
            E.return $ C.DEBUG "Cabs.ARITHMETIC Cabs.ADD e1 e2 <pointer case>"

(*
            C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
              (C.Klet [a_offset] (C.Kshift a_e1 a_e2 (C.Ksizeof (exp_type e1)))
                (C.Kseq [] (C.Ksame a_e1 a_shift)
                  (C.Ksym a_shift)))
*)
          else
            E.return $ C.DEBUG "Cabs.ARITHMETIC Cabs.ADD e1 e2 <pointer case>"

(*        
      else
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        if T.is_pointer (exp_type e1) then
          let size = Tc.size (T.base_of_pointer (exp_type e1)) in
          let a = C.offset a1 a2 size in
          Action.same a1 a >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
        else
          let size = Tc.size (T.base_of_pointer (exp_type e2)) in
          let a = C.offset a2 a1 size in
          Action.same a a1 >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
*)
    
    
    (* ------------------------------------------------------------------------------------------ *)
(*
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let diff = C.minus a1 a2 in
        if T.is_signed_integer (exp_type exp) then
          let c = overflow (exp_type exp) diff in
          E.return (diff, (m1 -&- m2) +& c)
        else
          Tc.conv_int (exp_type exp) (C.minus a1 a2) >>= fun (a, c) ->
          E.return (a, m1 -&- m2 +& c)
      else (*if T.is_integer (exp_type e2) then*)
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        let size = Tc.size (T.base_of_pointer (exp_type e1)) in
        let a = C.offset a1 (C.minus C.zero a2) size in
        Action.same a1 a >>= fun same ->
        E.return (a, (m1 -&- m2) -@> same)
*)
      | A.BINARY (Cabs.ARITHMETIC Cabs.SUB) e1 e2 ->
          if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
            fresh_symbol          >>= fun a_e1    ->
            fresh_symbol          >>= fun a_e2    ->
            translate_exp file e1 >>= fun core_e1 ->
            translate_exp file e2 >>= fun core_e2 ->
            fresh_symbol         >>= fun a_sub   ->
            let sub_ctx x =
              C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
                (C.Klet [a_sub] (C.Kop C.OpSub (C.Ksym a_e1) (C.Ksym a_e2))
                   x) in
            if T.is_signed_integer (exp_type exp) then
              E.return $ sub_ctx (C.Kcall C.overflow [C.Kctype (exp_type exp); C.Ksym a_sub])
            else
              E.return $ sub_ctx (C.Kcall C.conv_int [C.Kctype (exp_type exp); C.Ksym a_sub])
          
          else (*if T.is_integer (exp_type e2) then*)
            (* Pointer arithmetic. *)
            (* TODO: pointer arith *)
            E.return $ C.DEBUG "Cabs.ARITHMETIC Cabs.SUB e1 e2 <pointer case>"
      
    
    (* ------------------------------------------------------------------------------------------ *)
    (* TODO: ask Justus why the div_zero is placed differently on each branch *)
    | A.BINARY (Cabs.ARITHMETIC Cabs.MOD) e1 e2 ->
        fresh_symbol          >>= fun a_e1    ->
        fresh_symbol          >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        fresh_symbol          >>= fun a_mod   ->
        let mod_ctx x =
          C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
            (C.Klet [a_mod] (C.Kop C.OpMod (C.Ksym a_e1)
                                           (C.Kcall C.guard_zero [C.Ksym a_e2]))
               x) in
        if T.is_signed_integer(exp_type exp) then
          E.return $ mod_ctx (C.Kcall C.overflow [C.Kctype (exp_type exp); C.Ksym a_mod])
        else
          E.return $ mod_ctx (C.Kcall C.conv_int [C.Kctype (exp_type exp); C.Ksym a_mod])
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.BINARY (Cabs.ARITHMETIC Cabs.MUL) e1 e2 ->
        fresh_symbol          >>= fun a_e1    ->
        fresh_symbol          >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        fresh_symbol          >>= fun a_mul   ->
        let mul_ctx x =
          C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
            (C.Klet [a_mul] (C.Kop C.OpMul (C.Ksym a_e1) (C.Ksym a_e2))
               x) in
        if T.is_signed_integer(exp_type exp) then
          E.return $ mul_ctx (C.Kcall C.overflow [C.Kctype (exp_type exp); C.Ksym a_mul])
        else
          E.return $ mul_ctx (C.Kcall C.conv_int [C.Kctype (exp_type exp); C.Ksym a_mul])
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.BINARY Cabs.COMMA e1 e2 ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        E.return $ C.Kseq [] core_e1 core_e2
    
    
   (* ---------------------------------------------------------------------------------------------
    +                   [| e1 |]  ~>  core_e1         [| e2 |]  ~>  core_e2                       +
    +                   --------------------------------------------------- (or)                  +
    +                   [| e1 || e2 |]_exp  ~>  a_e1 <- core_e1;                                  +
    +                                           if not (a_e1 = 0) then 1                          +
    +                                           else                                              +
    +                                             a_e2 <- core_e2;                                +
    +                                             if a_e2 = 0 then 0 else 1                       +
    --------------------------------------------------------------------------------------------- *)
    | A.BINARY Cabs.OR e1 e2 ->
        fresh_symbol          >>= fun a_e1    ->
        fresh_symbol          >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        E.return $
          C.Kseq [a_e1] core_e1
            (C.Kif (C.Knot (C.Kop C.OpEq (C.Ksym a_e1) (C.Kconst 0)))
                   (C.Kconst 1)
                   (C.Kseq [a_e2] core_e2
                     (C.Kif (C.Kop C.OpEq (C.Ksym a_e2) (C.Kconst 0))
                            (C.Kconst 0)
                            (C.Kconst 1)
                     )
                   )
            )
    
    
   (* ---------------------------------------------------------------------------------------------
    +                   [| e1 |]  ~>  core_e1         [| e2 |]  ~>  core_e2                       +
    +                   --------------------------------------------------- (and)                 +
    +                   [| e1 && e2 |]_exp  ~>  a_e1 <- core_e1;                                  +
    +                                           if a_e1 = 0 then 0                                +
    +                                           else                                              +
    +                                             a_e2 <- core_e2;                                +
    +                                             if not (a_e2 = 0) then 1 else 0                 +
    --------------------------------------------------------------------------------------------- *)
    | A.BINARY Cabs.AND e1 e2 ->
        fresh_symbol          >>= fun a_e1    ->
        fresh_symbol          >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        E.return $
          C.Kseq [a_e1] core_e1
            (C.Kif (C.Kop C.OpEq (C.Ksym a_e1) (C.Kconst 0))
                   (C.Kconst 0)
                   (C.Kseq [a_e2] core_e2
                     (C.Kif (C.Knot (C.Kop C.OpEq (C.Ksym a_e2) (C.Kconst 0)))
                            (C.Kconst 1)
                            (C.Kconst 0)
                     )
                   )
            )
    
    
   (* ------------------------------------------------------------------------------------------- *)
    (* TODO *)
    | A.BINARY (Cabs.ARITHMETIC Cabs.SHL) e1 e2 ->
        E.return $ C.DEBUG "Cabs.ARITHMETIC Cabs.SHL e1 e2 <implementation defined stuff>"
    | A.BINARY (Cabs.ARITHMETIC Cabs.SHR) e1 e2 -> 
        E.return $ C.DEBUG "Cabs.ARITHMETIC Cabs.SHR e1 e2 <implementation defined stuff>"
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.BINARY Cabs.EQ e1 e2 ->
        if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
          fresh_symbol          >>= fun a_e1    ->
          fresh_symbol          >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          E.return $
            C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
              (C.Kif (C.Kop C.OpEq (C.Ksym a_e1) (C.Ksym a_e2))
                     (C.Kconst 1)
                     (C.Kconst 0)
              )
        else if T.is_pointer (exp_type e1) && T.is_pointer (exp_type e2) then
          E.return (C.DEBUG "A.BINARY Cabs.EQ e1 e2 <when e1 and e2 are pointers>")
        else if Typing.is_null_pointer_constant e1 then
          E.return (C.DEBUG "A.BINARY Cabs.EQ e1 e2 <when e1 and e2 are pointers, and e1 is a \
                             null constant")
        else
          E.return (C.DEBUG "A.BINARY Cabs.EQ e1 e2 <when e1 and e2 are pointers, and e1 is NOT \
                             a null constant")
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.BINARY Cabs.NE e1 e2 -> E.return (C.DEBUG "A.BINARY Cabs.NE e1 e2")
    | A.BINARY Cabs.LT e1 e2 -> E.return (C.DEBUG "A.BINARY Cabs.LT e1 e2")
    | A.BINARY Cabs.LE e1 e2 -> E.return (C.DEBUG "A.BINARY Cabs.LE e1 e2")
    | A.BINARY Cabs.GT e1 e2 -> E.return (C.DEBUG "A.BINARY Cabs.GT e1 e2")
    | A.BINARY Cabs.GE e1 e2 -> E.return (C.DEBUG "A.BINARY Cabs.GE e1 e2")
    | A.BINARY (Cabs.ARITHMETIC Cabs.BAND) e1 e2 ->
        E.return (C.DEBUG "A.BINARY (Cabs.ARITHMETIC Cabs.BAND) e1 e2  <implementation defined stuff>")
    | A.BINARY (Cabs.ARITHMETIC Cabs.BOR) e1 e2 ->
        E.return (C.DEBUG "A.BINARY (Cabs.ARITHMETIC Cabs.BOR) e1 e2  <implementation defined stuff>")
    | A.BINARY (Cabs.ARITHMETIC Cabs.XOR) e1 e2 ->
        E.return (C.DEBUG "A.BINARY (Cabs.ARITHMETIC Cabs.XOR) e1 e2  <implementation defined stuff>")
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.ASSIGN None e1 e2 ->
        fresh_symbol             >>= fun a_e1    ->
        fresh_symbol             >>= fun a_e2    ->
        translate_lvalue file e1 >>= fun core_e1 ->
        translate_exp    file e2 >>= fun core_e2 ->
        E.return $
          C.Kseq [a_e1; a_e2] (C.Kunseq [core_e1; core_e2])
            (C.Kstore (lvalue_type e1)
                      (C.Ksym a_e1)
                      (C.Kcall C.conv [C.Kctype (exp_type e1); C.Kctype (exp_type e2); C.Ksym a_e2])
            )
    
    
   (* ------------------------------------------------------------------------------------------- *)
    (* TODO: conv_int on e2 and e2 !!!!!!! *)
    | A.CONDITIONAL e1 e2 e3 ->
        if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
          fresh_symbol          >>= fun a_e1    ->
          fresh_symbol          >>= fun a_e2    ->
          fresh_symbol          >>= fun a_e3    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          translate_exp file e3 >>= fun core_e3 ->
          E.return $
            C.Kseq [a_e1] core_e1
              (C.Kif (C.Kop C.OpEq (C.Ksym a_e1) (C.Kconst 0))
                     core_e2
                     core_e3)
        else
          E.return (C.DEBUG "A.CONDITIONAL e1 e2 e3 <pointer>")
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.CALL e es ->
      match is_function_id file e with
      | Some (fid, ids, s) ->
(*
      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
      (* retrieve the declarations of these variables *)
      let decls = [(Pmap.find id env', lookup_type id)| forall (id MEM ids) | true] in
      let n     = List.length decls                                                 in
      
      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx = let (syms, xs) = mapUnzip (fun (a, ty) -> (a, C.Kcreate ty)) (List.rev decls) in
                        match n with
                          | 0 -> fun x -> x
                          | 1 -> C.Kseq syms (List.hd xs)
                          | _ -> C.Kseq syms (C.Kunseq xs)
                        end in


translate_exp env file e >>= fun core_e ->
C.seq [a_id] (C.Kcreate ty)
  (C.Kstore ty a_id (C.Kcall C.conv [C.Kctype (Types.unqualify ty); C.Kctype (exp_type e); core_e]))

(*
            let f_create (l, t, e) m' =
              conv (T.unqualify t) (exp_type e) (f e) >>= fun (a, m) ->
              Action.create   t l                     >>= fun create ->
              Action.fn_store t l a                   >>= fun store  ->
              E.return ((m' -&- m) +@ create -@> store) in
*)
      

      (* prepare the code killing the objects. *)
      let kills = let xs = List.map (fun (a, _) -> C.Kkill a) decls in
                        match n with
                          | 0 -> C.Kskip
                          | 1 -> List.hd xs
                          | _ -> C.Kunseq xs
                        end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt env' file current_function s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt env' file current_function s >>= fun core_s ->
                               E.return ([a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) -> C.Kseq _as stmt acc)
                    (C.Kseq [] kills (C.Ksym a_last))
                    (List.rev core_ss))

        (*
            update_env env ids >>= fun env' ->

            let args =
              let f id e = (Pmap.find id env', lookup_type id, e) in
              List.map2 f ids es in

            let f_create (l, t, e) m' =
              conv (T.unqualify t) (exp_type e) (f e) >>= fun (a, m) ->
              Action.create   t l                     >>= fun create ->
              Action.fn_store t l a                   >>= fun store  ->
              E.return ((m' -&- m) +@ create -@> store) in

            let f_kill (l, _, _) m =
              Action.kill l >>= fun kill ->
              E.return (m +@ kill) in

            E.foldlM f_create args Me.unit     >>= fun m_create ->
            E.foldlM f_kill   args Me.unit     >>= fun m_kill   ->
            C.fresh                            >>= fun a        ->
	    reduce_stmt n b env' file fid a s >>= fun ml       ->
            Action.call                        >>= fun call     ->
            let m_body = Ms.exit_function call ml in
            E.return (a, m_create -&> m_body -&> m_kill)
        *)
*)
        E.return (C.Kindet (C.COMMENT "TODO: function call" C.Kerror))
      | None ->
        (* TODO: looks like we need a "null" constant of type address in Core *)
        E.return (C.DEBUG "A.CALL e es <function pointer>")
      end





    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.ALIGNOF ty -> E.return $ C.Kalignof ty
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.SIZEOF  ty -> E.return $ C.Ksizeof ty
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | _ -> E.return (C.DEBUG "translate_exp, _ case")
  end

(* -------------------------------------------------------------------------- *)

(* translate_stmt Pmap.empty file file.A.main C.Constants.return s *)
and translate_stmt file current_function (_, stmt) : C.expr Symbol_state.t =
  (* return the type of a given identifier. (TODO: why is this a local function?) *)
  let lookup_type id = fst (Pmap.find id file.A.id_map) in
  
  match stmt with
  | A.SKIP -> E.return C.Kskip
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.IF e s1 s2 ->
      fresh_symbol                            >>= fun a_test  ->
      translate_exp file e                    >>= fun core_e  ->
      translate_stmt file current_function s1 >>= fun core_s1 ->
      translate_stmt file current_function s2 >>= fun core_s2 ->
      E.return $ C.Kseq [a_test] core_e
                                 (C.Kif (C.Knot (C.Kop C.OpEq (C.Ksym a_test) (C.Kconst 0)))
                                    core_s1
                                    core_s2
                                 )
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.BLOCK ids ss ->
(*      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
*)
      (* retrieve the declarations of these variables *)
      let decls = [(id, lookup_type id)| forall (id MEM ids) | true] in
      let n     = List.length decls                                  in
      
      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx = let (syms, xs) = mapUnzip (fun (a, ty) -> (a, C.Kcreate ty)) (List.rev decls) in
                        match n with
                          | 0 -> fun x -> x
                          | 1 -> C.Kseq syms (List.hd xs)
                          | _ -> C.Kseq syms (C.Kunseq xs)
                        end in
      
      (* prepare the code killing the objects. *)
      let kills_ctx = let xs = List.map (fun (a, _) -> C.Kkill a) decls in
                      match n with
                        | 0 -> fun x -> x
                        | 1 -> C.Kseq [] (List.hd xs)
                        | _ -> C.Kseq [] (C.Kunseq xs)
                      end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt file current_function s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt file current_function s >>= fun core_s ->
                               E.return ([a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) -> C.Kseq _as stmt acc)
                    (kills_ctx (if List.length ss = 0 then C.Kskip else C.Ksym a_last))
                    (List.rev core_ss))
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.DECLARATION defns ->
      let f (id, e) acc =
        conv (exp_type e) (lookup_type id)
             (translate_exp file e) >>= fun core_e ->
        E.return $ C.Kseq [] core_e acc in
      E.foldlM f defns C.Kskip
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.RETURN_EXPRESSION e ->
      conv (exp_type e) (T.function_return $ lookup_type current_function)
           (translate_exp file e)
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.RETURN_VOID -> E.return C.Kskip
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.EXPRESSION e -> translate_exp file e
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
(*
  iterate e s f_e f_s n Ms.unit
*)
  | A.WHILE e s -> E.return (C.DEBUG "while")
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
(*
  E.return (Ms.break    Me.unit)
*)
  | A.BREAK    -> E.return (C.DEBUG "break")
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
(*
  E.return (Ms.continue Me.unit)
*)
  | A.CONTINUE -> E.return (C.DEBUG "continue")
  end


(* Run the translator on different functions *)
let translate_file (file: _ A.file) : C.file Symbol_state.t =
  E.foldlM
    (fun (name, (args, body)) acc ->
       (* translate the body to Core *)
       translate_stmt file name body >>= fun core_body ->
       E.return $ Pmap.add name (C.TyBase C.value (* TODO: address for pointer type? *),
                                 List.map (fun arg -> (arg,C.address (* TODO: check *))) args,
                                 core_body) acc)
    (Pmap.bindings file.A.fn_map)
    Pmap.empty
  >>= fun core_funcs ->
  E.return <| C.main= file.A.main; C.fun_map= core_funcs |>


(* This is the entry function (called from main.ml) *)
let translate (file: _ A.file) : C.file = E.init (translate_file file)
(* C.test2 *)
