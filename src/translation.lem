module A = Ail
module C = Core
module T = Types


(* TODO: put somewhere *)
let ($) f x = f x

let extractList [x] = x

let rec mapWithLast f g = function
  | []      -> []
  | [x]     -> [g x]
  | (x::xs) -> f x :: mapWithLast f g xs
end


(* -------------------------------------------------------------------------- *)
module Effect = struct
  module M = Symbol_state

  let return = M.return

  module Operators = struct
    let (>>=) = M.bind
  end

  let init = M.init
  let foldlM = M.foldlM
  
  open Operators
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)
  let mapWithLastM f g xs = sequence (mapWithLast f g xs)

end

(* -------------------------------------------------------------------------- *)
module E = Effect
open E.Operators

let exp_type    = Annotate.exp_type_of
let lvalue_type = Annotate.lvalue_type_of


let fresh_symbol = Symbol_state.map (fun x -> x) Symbol_state.fresh




(* TODO: clean up *)
(* TODO: local recursive function are not allowed in Lem ?? *)
let rec bar f (xs, ys) = function
  | []      -> (xs, ys)
  | (l::ls) -> let (x,y) = f l in bar f (x::xs, y::ys) ls
end
let foo f l = bar f ([],[]) l



let update_env env ids =
  let f id env =
    fresh_symbol >>= fun a ->
    E.return (Pmap.add id a env) in
  E.foldlM f ids env


let conv ty1 ty2 exp =
  fresh_symbol      >>= fun a_exp  ->
  fresh_symbol      >>= fun a_conv ->
  exp               >>= fun core_e ->
  E.return $ C.Kseq [a_exp] core_e (C.Klet [a_conv] (C.Kconv ty1 ty2 a_exp) (* C.DEBUG "conv" *) (C.Ksym a_conv))
(*  
  Tc.conv ty ty2 a  >>= fun (v, c) ->
  E.return (v, m +& c)
*)


(*
let is_function_id file e =
  match Annotate.exp_of e with
  | A.VARIABLE fid ->
      let (ids, body) = Pmap.find fid file.A.fn_map in
      Some (fid, ids , body)
  | _ -> None
  end



let conv_int_lifted t (a, m) =
  Tc.conv_int t a >>= fun (v, c) ->
  E.return (v, m +& c)


let rec iterate e s f_e f_s n ml_prev =
  let m_neg (a, m) = m +& (C.eq  a C.zero) in
  let m_pos (a, m) = m +& (C.neq a C.zero) in
  match n with
  | 0 ->
      f_e e >>= fun m  ->
      E.return (Ms.exit_loop (m_neg m) ml_prev)
  | _ ->
      f_e e >>= fun m  ->
      f_s s >>= fun ml ->
      let ml' = Ms.enter_loop (m_pos m) (m_neg m) ml_prev in
      iterate e s f_e f_s (n-1) (ml' --&> ml)
  end
*)

(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)

(*
let rec translate_lvalue n b env file exp =
  let f = translate_exp n b env file in
  match Annotate.exp_of exp with
  | A.VARIABLE id ->
      E.return (Pmap.find id env, Me.unit)
  | A.UNARY A.INDIRECTION e ->
      f e >>= fun (a, m) ->
      let t = T.base_of_pointer (T.pointer_convert (exp_type e)) in
      let ill_aligned = C.neg (Tc.is_aligned t a) in
      let null = C.eq a C.null in
      let c = C.implies (C.disj null ill_aligned) C.undef in
      E.return (a, m +& c)
  | _ ->
      C.fresh >>= fun a ->
      E.return (a, Me.null)
  end
*)

(* -------------------------------------------------------------------------- *)

let rec translate_exp env file exp =
  match Annotate.exp_of exp with
    (* WARNING: this is not enought (DEBUG FOR NOW) *)
    | A.VARIABLE id ->
        let a_id = Pmap.find id env in
        E.return $ C.Kload (lvalue_type exp) a_id


    | A.CONSTANT (Cabs.CONST_INT (i, _)) -> E.return (C.Kconst i)



(*
      f_lvalue e >>= fun (a, m) ->
      C.fresh    >>= fun v      ->
      let incr = C.plus v C.one in
      Tc.conv_int (exp_type e) incr >>= fun (v', c) ->
      Action.load  (lvalue_type e) a v  >>= fun load  ->
      Action.store (lvalue_type e) a v' >>= fun store ->
      E.return (v, Me.conj_sb (m +& c) (Me.add_ls_pair load store Me.unit))
*)
  | A.UNARY A.POSTFIX_INCR e ->
      E.return (C.DEBUG "postfix increment")
      (* TODO: must be done un "lvalue mode" *)
(*
      translate_exp e >>= fun core_e ->
      fresh_symbol >>= fun a ->
      C.Kop C.OpPlus (C.Ksym a) (C.Kconst 1)
*)

  
  | A.ALIGNOF ty -> E.return $ C.Kalignof ty
  
  | A.SIZEOF  ty -> E.return $ C.Ksizeof ty


  | A.UNARY A.POSTFIX_DECR e ->
      E.return (C.DEBUG "postfix decrement")





    | _ -> E.return (C.DEBUG "expression")
  end
(*
  | A.UNARY A.ADDRESS (_, (A.UNARY A.INDIRECTION e)) ->
  | A.UNARY A.ADDRESS e ->
  | A.CAST t e ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.ADD) e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.SUB) e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.MOD) e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.MUL) e1 e2 ->
  | A.BINARY Cabs.COMMA e1 e2 ->
  | A.BINARY Cabs.OR e1 e2 ->
  | A.BINARY Cabs.AND e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.SHL) e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.SHR) e1 e2 ->
  | A.BINARY Cabs.EQ e1 e2 ->
  | A.BINARY Cabs.NE e1 e2 ->
  | A.BINARY Cabs.LT e1 e2 ->
  | A.BINARY Cabs.LE e1 e2 ->
  | A.BINARY Cabs.GT e1 e2 ->
  | A.BINARY Cabs.GE e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.BAND) e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.BOR) e1 e2 ->
  | A.BINARY (Cabs.ARITHMETIC Cabs.XOR) e1 e2 ->
  | A.ASSIGN None e1 e2 ->
  | A.CONDITIONAL e1 e2 e3 ->
  | A.CALL e es ->
  | _ ->
  end
*)

(* -------------------------------------------------------------------------- *)

(* translate_stmt Pmap.empty file file.A.main C.Constants.return s *)
and translate_stmt env file current_function (_, stmt) : C.expr Symbol_state.t =
  (* return the type of a given identifier. (TODO: why is this a local function?) *)
  let lookup_type id = fst (Pmap.find id file.A.id_map) in
  
  match stmt with
  | A.SKIP -> E.return C.Kskip
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.IF e s1 s2 ->
      fresh_symbol                                >>= fun a_test  ->
      translate_exp env file e                    >>= fun core_e  ->
      translate_stmt env file current_function s1 >>= fun core_s1 ->
      translate_stmt env file current_function s2 >>= fun core_s2 ->
      E.return $ C.Kseq [a_test] core_e (C.Kif (C.Ksym a_test) core_s1 core_s2)
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.BLOCK ids ss ->
      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
      (* retrieve the declarations of these variables *)
      let decls = [(Pmap.find id env', lookup_type id)| forall (id MEM ids) | true] in
      let n     = List.length decls                                                 in
      
      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx = let (syms, xs) = foo (fun (a, ty) -> (a, C.Kcreate ty)) (List.rev decls) in
                        match n with
                          | 0 -> fun x -> x
                          | 1 -> C.Kseq syms (extractList xs)
                          | _ -> C.Kseq syms (C.Kunseq xs)
                        end in
      
      (* prepare the code killing the objects. *)
      let kills = let xs = List.map (fun (a, _) -> C.Kkill a) decls in
                        match n with
                          | 0 -> C.Kskip
                          | 1 -> extractList xs
                          | _ -> C.Kunseq xs
                        end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt env' file current_function s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt env' file current_function s >>= fun core_s ->
                               E.return ([a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) -> C.Kseq _as stmt acc)
                    (C.Kseq [] kills (C.Ksym a_last))
                    (List.rev core_ss))
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.DECLARATION defns ->
      let f (id, e) acc =
        let a_id = Pmap.find id env in
        conv (exp_type e) (lookup_type id)
             (translate_exp env file e) >>= fun core_e ->
        E.return $ C.Kseq [] core_e acc in
      E.foldlM f defns C.Kskip
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.RETURN_EXPRESSION e ->
      conv (exp_type e) (T.function_return $ lookup_type current_function)
           (translate_exp env file e)
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.RETURN_VOID -> E.return C.Kskip
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.EXPRESSION e -> translate_exp env file e
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
(*
  iterate e s f_e f_s n Ms.unit
*)
  | A.WHILE e s -> E.return (C.DEBUG "while")
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
(*
  E.return (Ms.break    Me.unit)
*)
  | A.BREAK    -> E.return (C.DEBUG "break")
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
(*
  E.return (Ms.continue Me.unit)
*)
  | A.CONTINUE -> E.return (C.DEBUG "continue")
  end


(* TODO: for now only translating the body of the main function *)
let translate_file (file: _ A.file) : C.expr Symbol_state.t =
   (translate_stmt
              (* initial state of an environment associating Ail identifiers to
                 symbolic names *)
              Pmap.empty
              file
              (* set [main] as the current function. *)
              file.A.main
              (* the body of main. *)
              (let (_,s) = Pmap.find file.A.main file.A.fn_map in s)
  )


(* This is the entry function (called from main.ml) *)
let translate (file: _ A.file) : C.expr = E.init (translate_file file)
