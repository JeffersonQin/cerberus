open Global

type t 'a 'msg = Symbol.sset -> Program.t ('a * Symbol.sset) 'msg


let return a = fun s -> Program.return (a, s)



val fmap: forall 'a 'b 'msg. ('a -> 'b) -> t 'a 'msg -> t 'b 'msg
let fmap f m =
  fun s -> Program.bind (m s) (fun (a, s') -> Program.return (f a, s'))
let join mm = fun s -> Program.bind (mm s) (fun (m, s') -> m s')
let bind m f = join (fmap f m)
let app mf m = bind mf (fun f -> fmap f m)

let fail      msg = fun _ -> Program.fail      msg
let undefined msg = fun _ -> Program.undefined msg
let bug       msg = fun _ -> Program.bug       msg

let fresh          = fun s -> Program.return (Symbol.fresh          s)
let fresh_pretty n = fun s -> Program.return (Symbol.fresh_pretty n s)

let init m = Program.fmap fst (m Symbol.init)

let of_symbol_state m =
  fun s ->
    let (a, s') = Symbol_state.run_impl m s in
    (return a) s'

(*
let of_exception m = fun s -> (Program.of_exception m, s)
*)

let of_option m = function
  | Some v -> return v
  | None   -> m
  end

let rec foldr_list f l a =
  match l with
  | [] -> return a
  | x::xs -> bind (f x a) (fun a' -> foldr_list f xs a')
  end
