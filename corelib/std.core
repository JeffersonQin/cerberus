-- Math utilities

{-
fun exp_aux(n: integer, m: integer, acc: integer) : integer :=
  if m = 0 then
    acc
  else
    exp_aux(n, m - 1, n * acc)
  end


-- TODO: diverges if m < 0
fun exp (n: integer, m: integer) : integer :=
  exp_aux(n, m, 1)
--  if m = 0 then
--    1
--  else
--    n * exp(n, m - 1)
--  end

-}

{-
fun is_signed (ty: ctype) : boolean :=
  case ty of
    | {_} signed _   -> true
    | {_} unsigned _ -> false

type ctype =
  | VOID  of qualifiers
  | BASIC of qualifiers * basic_type
  (* TODO Need to convert integer constant to an actual value! Otherwise, we
     cannot compare types! *)
  | ARRAY of ctype * option int
(* need also to support array types without a length, eg for pointer-to-an-array[10] or just pointer-to-an-array. also some length subtyping in function arguments in C11. so another type here, to have pointers to. *)

(* NOTE: will need to make up ids for some of the bitfields *)
  | STRUCT of qualifiers * id * list (id * member)
  | UNION  of qualifiers * id * list (id * member)
  | ENUM of id
  | FUNCTION of ctype * list ctype
  | POINTER of qualifiers * ctype
  | ATOMIC of ctype
  | TYPEDEF of id
  
  | SIZE_T
  | INTPTR_T
  | WCHAR_T
  | CHAR16_T
  | CHAR32_T
-}





fun overflow (ty: ctype, n: integer) : integer :=
  n

-- [conv_int ty n] returns the value [n] converted to the integer type [ty]
fun conv_int (ty: ctype, n: integer): integer :=
  -- (§6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if ty = "_Bool" then
    if n = 0 then 0 else 1 end
  
  -- (§6.3.1.3#1) When a value with integer type is converted to another integer
  -- type other than _Bool, if the value can be represented by the new type, it
  -- is unchanged.
  else
    if is_representable(n, ty) then
      n
  
  -- (§6.3.1.3#2) Otherwise, if the new type is unsigned, the value is converted
  -- by repeatedly adding or subtracting one more than the maximum value that
  -- can be represented in the new type until the value is in the range of the
  -- new type.
    else
      if is_unsigned(ty) then
        conv_aux(ty, n)
  
  -- (§6.3.1.3#3) Otherwise, the new type is signed and the value cannot be
  -- represented in it; either the result is implementation-defined or an
  -- implementation-defined signal is raised.
      else
        <Integer.conv_nonrepresentable_signed_integer>(ty, n)
      end
    end
  end





-- auxiliary function for the [conv] (see §6.3.1.3#1)
fun conv_aux (ty: ctype, n: integer) : integer :=
  let n2 =
    if <ctype_max>(ty) < n then
      n - <ctype_max>(ty) + 1
    else
      n + <ctype_max>(ty) + 1
    end in
    if is_representable(n2, ty) then
      n2
    else
      conv_aux(ty, n2)
    end
  end



-- TODO: the part do-able statically should probably be done by Translation.lem
-- [conv ty1 ty2 n] converts a value [n] of ctype [ty1] to a value of type [ty2]
fun conv (ty1: ctype, ty2: ctype, n: integer): integer :=
  -- (§6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if is_scalar(ty1) /\ ty2 = "_Bool" then
    if n = 0 then 0 else 1 end
  -- (§6.3.1.3#1) When a value with integer type is converted to another integer type other
  -- than _Bool, if the value can be represented by the new type, it is unchanged.
  else
    if is_integer(ty1) /\ is_integer(ty2) then
      if is_representable(n, ty2) then
        n
    -- (§6.3.1.3#1) Otherwise, if the new type is unsigned, the value is converted by repeatedly
    -- adding or subtracting one more than the maximum value that can be represented in the new type
    -- until the value is in the range of the new type.
      else
        if is_unsigned(ty2) then
          conv_aux(ty2, n)
    
    -- (§6.3.1.3#1) Otherwise, the new type is signed and the value cannot be represented in it;
    -- either the result is implementation-defined or an implementation-defined signal is raised.
        else
          <Integer.conv_nonrepresentable_signed_integer>(ty2, n) -- 42 -- TODO
        end
      end
    else
      error -- 42 -- TODO: floats, OR ty1/ty2 are non-scalar hence this function is undefined
    end
  end

-- fun div_zero (n: integer): integer :=
--  n


fun usual_arithmetic (ty1: ctype, ty2: ctype): ctype :=
  ty1

fun ctype_width (ty: ctype): integer :=
  <sizeof>(ty) * <bits_in_byte>


fun is_representable (n: integer, ty: ctype): boolean :=
  <ctype_min>(ty) <= n /\ n <= <ctype_max>(ty)




-- encode an element of Z into an element of N following the
-- two's complement encoding
fun encodeTwos (ty : ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width = ctype_width(ty) in
    if (n < 0 - 2^(width - 1)) \/ (2^(width - 1) - 1 < n) then
      error
    else
      if 0 <= n then
        n
      else
        2^width + n
      end
    end
  end

-- the inverse of the previous function
fun decodeTwos (ty: ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width = ctype_width(ty) in
    if (n < 0) \/ (2^width <= n) then
      error
    else
      if n <= 2^(width - 1) - 1 then
        n
      else
        n - 2^width
      end
    end
  end

-- bitwise complement of a two's complement encoded integer
fun complementTwos_aux (n: integer, w: integer) : integer :=
  if w = 0 then
    n
  else
    let n_ = n / 2 in
      (1 - (n % 2)) + 2 * complementTwos_aux(n_, w - 1)
    end
  end

fun complementTwos (ty:ctype, n: integer) : integer :=
  complementTwos_aux(n, ctype_width(ty))


-- bitwise AND
fun bitwise_AND_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_ = n1 / 2 in
      let n2_ = n2 / 2 in
        (if n1%2 = 1 /\ n2%2 = 1 then 1 else 0 end) + 2 * bitwise_AND_aux(n1_, n2_, w - 1)
      end
    end
  end

fun bitwise_AND (ty: ctype, n1: integer, n2: integer) : integer :=
  let n1_ = <Integer.encode>(ty, n1) in
    let n2_ = <Integer.encode>(ty, n2) in
      <Integer.decode>(ty, bitwise_AND_aux(n1_, n2_, ctype_width(ty)))
    end
  end


-- bitwise XOR
fun bitwise_XOR_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_ = n1 / 2 in
      let n2_ = n2 / 2 in
        (if (n1%2) * (n2%2) = 0 /\ not((n1%2) + (n2%2) = 0) then 1 else 0 end) + 2 * bitwise_XOR_aux(n1_, n2_, w - 1)
      end
    end
  end

fun bitwise_XOR (ty: ctype, n1: integer, n2: integer) : integer :=
  let n1_ = <Integer.encode>(ty, n1) in
    let n2_ = <Integer.encode>(ty, n2) in
      <Integer.decode>(ty, bitwise_XOR_aux(n1_, n2_, ctype_width(ty)))
    end
  end


-- bitwise OR
fun bitwise_OR_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_ = n1 / 2 in
      let n2_ = n2 / 2 in
        (if n1%2 = 1 \/ n2%2 = 1 then 1 else 0 end) + 2 * bitwise_OR_aux(n1_, n2_, w - 1)
      end
    end
  end

fun bitwise_OR (ty: ctype, n1: integer, n2: integer) : integer :=
  let n1_ = <Integer.encode>(ty, n1) in
    let n2_ = <Integer.encode>(ty, n2) in
      <Integer.decode>(ty, bitwise_OR_aux(n1_, n2_, ctype_width(ty)))
    end
  end

-- ones_prefix(0, k, width) returns an positive integer whose binary
-- representation is 1    ...   1 0      ...       0
--                     k times     width - k times
fun ones_prefix (i: integer, k: integer, width: integer) : integer :=
  if (0 <= i) /\ (i < k) then
    2^(width - 1 - i) + ones_prefix(i + 1, k, width)
  else
    0
  end
-- gccSHR_Twos n m =
--  quot n (2^m) + (sum $ map (\i -> 2^(width - 1 - i)) [0..m-1])
