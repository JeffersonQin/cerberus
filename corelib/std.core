{-
-- Ctype utilities
-- these are hackish
fun ctype_true(ty: ctype) : boolean :=
  true
fun ctype_false(ty: ctype) : boolean :=
  false
fun ctype_integer_false(ty: ctype, n: integer) : boolean :=
  false


 | Basic of AilTypes.basicType
 | Array of ctype * maybe integer
 | Function of ctype * list (AilTypes.qualifiers * ctype) * bool (*true for variadic*)
 | Pointer of AilTypes.qualifiers * ctype
 | Atomic of ctype
 | Struct of struct_tag
 | Union  of union_tag
 | Builtin of string


fun is_pointer(ty) : boolean :=
  case_ctype(false, ctype_false, ctype_integer_false, ctype_true, TODO_function, ctype_false

fun is_integer(ty) : boolean :=
  case_ctype(false, 

fun is_arithmetic(ty) : boolean :=
  -- TODO: is_floating
  is_integer(ty)

fun is_scalar (ty: ctype) : boolean :=
  is_pointer(ty) /\ is_arithmetic(ty)

fun is_signed (ty: ctype) : boolean :=
  
fun is_unsigned (ty: ctype) : boolean :=
-}




-- Math utilities

{-
fun exp_aux(n: integer, m: integer, acc: integer) : integer :=
  if m = 0 then
    acc
  else
    exp_aux(n, m - 1, n * acc)
  end


-- TODO: diverges if m < 0
fun exp (n: integer, m: integer) : integer :=
  exp_aux(n, m, 1)
--  if m = 0 then
--    1
--  else
--    n * exp(n, m - 1)
--  end

-}

{-
fun is_signed (ty: ctype) : boolean :=
  case ty of
    | {_} signed _   -> true
    | {_} unsigned _ -> false

type ctype =
  | VOID  of qualifiers
  | BASIC of qualifiers * basic_type
  (* TODO Need to convert integer constant to an actual value! Otherwise, we
     cannot compare types! *)
  | ARRAY of ctype * option int
(* need also to support array types without a length, eg for pointer-to-an-array[10] or just pointer-to-an-array. also some length subtyping in function arguments in C11. so another type here, to have pointers to. *)

(* NOTE: will need to make up ids for some of the bitfields *)
  | STRUCT of qualifiers * id * list (id * member)
  | UNION  of qualifiers * id * list (id * member)
  | ENUM of id
  | FUNCTION of ctype * list ctype
  | POINTER of qualifiers * ctype
  | ATOMIC of ctype
  | TYPEDEF of id
  
  | SIZE_T
  | INTPTR_T
  | WCHAR_T
  | CHAR16_T
  | CHAR32_T
-}


fun is_representable (n: integer, ty: ctype): boolean :=
--  <ctype_min>(ty) <= n /\ n <= <ctype_max>(ty)
  ivmin(ty) <= n /\ n <= ivmax(ty)



-- STD §6.5#5
fun catch_exceptional_condition (ty: ctype, n: integer) : integer :=
  if is_representable(boolean, n:integer, ty:ctype) then
    n
  else
    undef <<Exceptional_condition>>
  end


-- [conv_int ty n] returns the value [n] converted to the integer type [ty]
fun conv_int (ty: ctype, n: integer): integer :=
  if is_unspec(n) then
    unspecified(ty)
  else
  -- (§6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if ty = "_Bool" then
    if n = 0 then 0 else 1 end
  
  -- (§6.3.1.3#1) When a value with integer type is converted to another integer
  -- type other than _Bool, if the value can be represented by the new type, it
  -- is unchanged.
  else
    if is_representable(boolean, n:integer, ty:ctype) then
      n
  
  -- (§6.3.1.3#2) Otherwise, if the new type is unsigned, the value is converted
  -- by repeatedly adding or subtracting one more than the maximum value that
  -- can be represented in the new type until the value is in the range of the
  -- new type.
    else
      if is_unsigned(ty) then
        wrapI(integer, ty:ctype, n:integer)
  
  -- (§6.3.1.3#3) Otherwise, the new type is signed and the value cannot be
  -- represented in it; either the result is implementation-defined or an
  -- implementation-defined signal is raised.
      else
        <Integer.conv_nonrepresentable_signed_integer>(integer, ty:ctype, n:integer)
      end
    end
  end
  end




-- auxiliary function for the [conv] (see §6.3.1.3#1)
fun conv_aux (ty: ctype, n: integer) : integer :=
{-
--  if is_representable(boolean,n:integer, ty:ctype) then
--    n
--  else
--    conv_aux(ty, if <ctype_max>(ty) < n then n - <ctype_max>(ty) + 1 else n + <ctype_max>(ty) + 1 end)
    -- TODO: check
--    if n >= 0 then
      n % (ivmax(ty) + 1)
    else
      let n2 = (ivmax(ty) + 1) + (n % (ivmax(ty) + 1)) in
      if is_unsigned(ty) /\ n2 < 0 then
        error(<<<conv_aux>>>, (ty, n, n2))
      else
        n2
      end
      end
    end
-}
  n rem_f (ivmax(ty) - ivmin(ty) + 1)

--  end
{-
  let n2 =
    if <ctype_max>(ty) < n then
      n - <ctype_max>(ty) + 1
    else
      n + <ctype_max>(ty) + 1
    end in
    if is_representable(n2, ty) then
      n2
    else
      conv_aux(ty, n2)
    end
  end
-}



-- TODO: the part do-able statically should probably be done by Translation.lem
-- [conv ty1 ty2 n] converts a value [n] of ctype [ty1] to a value of type [ty2]
fun conv (ty1: ctype, ty2: ctype, n: integer): integer :=
  if is_unspec(n) then
    unspecified(ty2)
  else
  -- (§6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if is_scalar(ty1) /\ ty2 = "_Bool" then
    if n = 0 then 0 else 1 end
  -- (§6.3.1.3#1) When a value with integer type is converted to another integer type other
  -- than _Bool, if the value can be represented by the new type, it is unchanged.
  else
    if is_integer(ty1) /\ is_integer(ty2) then
      if is_representable(boolean, n:integer, ty2:ctype) then
        n
    -- (§6.3.1.3#1) Otherwise, if the new type is unsigned, the value is converted by repeatedly
    -- adding or subtracting one more than the maximum value that can be represented in the new type
    -- until the value is in the range of the new type.
      else
        if is_unsigned(ty2) then
          conv_aux(integer, ty2:ctype, n:integer)
    
    -- (§6.3.1.3#1) Otherwise, the new type is signed and the value cannot be represented in it;
    -- either the result is implementation-defined or an implementation-defined signal is raised.
        else
          <Integer.conv_nonrepresentable_signed_integer>(integer, ty2:ctype, n:integer) -- 42 -- TODO
        end
      end
    else
--      error <<<conv>>> -- 42 -- TODO: floats, OR ty1/ty2 are non-scalar hence this function is undefined
    -- TODO !!!!
      n
    end
  end
  end

-- fun div_zero (n: integer): integer :=
--  n


-- fun usual_arithmetic (ty1: ctype, ty2: ctype): ctype :=
--   ty1

fun ctype_width (ty: ctype): integer :=
  ivsizeof(ty) * <bits_in_byte>





-- encode an element of Z into an element of N following the
-- two's complement encoding
{-
fun encodeTwos (ty : ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width = ctype_width(ty) in
    if (n < 0 - 2^(width - 1)) \/ (2^(width - 1) - 1 < n) then
      error(<<<encodeTwos>>>, (width, ty, n))
    else
      if 0 <= n then
        n
      else
        2^width + n
      end
    end
  end
-}
fun encodeTwos (ty : ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width = ctype_width(integer, ty:ctype) in
    if n < ivmin(ty) \/ ivmax(ty) < n then
      error(<<<encodeTwos>>>, (width, ty, n))
    else
      if 0 <= n then
        n
      else
        2^width + n
      end
    end
  end



-- the inverse of the previous function
fun decodeTwos (ty: ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width = ctype_width(integer, ty:ctype) in
    if (n < 0) \/ (2^width <= n) then
      error(<<<decodeTwos>>>, (ty, n))
    else
      if n <= 2^(width - 1) - 1 then
        n
      else
        n - 2^width
      end
    end
  end

-- bitwise complement of a two's complement encoded integer
fun complementTwos_aux (n: integer, w: integer) : integer :=
  if w = 0 then
    n
  else
    let n_ = n / 2 in
      (1 - (n rem_f 2)) + 2 * complementTwos_aux(integer, n_:integer, w - 1 : integer)
    end
  end

fun complementTwos (ty:ctype, n: integer) : integer :=
  complementTwos_aux(integer, n:integer, ctype_width(integer, ty: ctype) : integer)


-- bitwise AND
fun bitwise_AND_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_ = n1 / 2 in
      let n2_ = n2 / 2 in
        (if n1 rem_f 2 = 1 /\ n2 rem_f 2 = 1 then 1 else 0 end) + 2 * bitwise_AND_aux(integer, n1_:integer, n2_:integer, w - 1:integer)
      end
    end
  end

fun bitwise_AND (ty: ctype, n1: integer, n2: integer) : integer :=
  if ty = "unsigned long" /\ (n1 = -39 \/ n2 = -39) then
    error(<<<WIP_bAND>>>, (ty, n1, n2))
  else

  let n1_ = <Integer.encode>(integer, ty:ctype, n1:integer) in
    let n2_ = <Integer.encode>(integer, ty:ctype, n2:integer) in
      <Integer.decode>(integer,ty:ctype, bitwise_AND_aux(integer, n1_:integer, n2_:integer, ctype_width(integer, ty:ctype):integer):integer)
    end
  end
  end

-- bitwise XOR
fun bitwise_XOR_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_ = n1 / 2 in
      let n2_ = n2 / 2 in
        (if (n1 rem_f 2) * (n2 rem_f 2) = 0 /\ not((n1 rem_f 2) + (n2 rem_f 2) = 0) then 1 else 0 end) + 2 * bitwise_XOR_aux(integer, n1_:integer, n2_:integer, w - 1 : integer)
      end
    end
  end

fun bitwise_XOR (ty: ctype, n1: integer, n2: integer) : integer :=
  if ty = "unsigned long" /\ (n1 = -39 \/ n2 = -39) then
    error(<<<WIP_bXOR>>>, unit)
  else
  let n1_ = <Integer.encode>(integer, ty:ctype, n1:integer) in
    let n2_ = <Integer.encode>(integer, ty:ctype, n2:integer) in
      <Integer.decode>(integer,ty:ctype, bitwise_XOR_aux(integer, n1_:integer, n2_:integer, ctype_width(integer, ty:ctype):integer):integer)
    end
  end
  end


-- bitwise OR
fun bitwise_OR_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_ = n1 / 2 in
      let n2_ = n2 / 2 in
        (if n1 rem_f 2 = 1 \/ n2 rem_f 2 = 1 then 1 else 0 end) + 2 * bitwise_OR_aux(integer, n1_:integer, n2_:integer, w - 1 : integer)
      end
    end
  end

fun bitwise_OR (ty: ctype, n1: integer, n2: integer) : integer :=
  if ty = "unsigned long" /\ (n1 = -39 \/ n2 = -39) then
    error(<<<WIP_bOR>>>, unit)
  else

  let n1_ = <Integer.encode>(integer, ty:ctype, n1:integer) in
    let n2_ = <Integer.encode>(integer, ty:ctype, n2:integer) in
      <Integer.decode>(integer,ty:ctype, bitwise_OR_aux(integer, n1_:integer, n2_:integer, ctype_width(integer, ty:ctype):integer):integer)
    end
  end
  end

-- ones_prefix(0, k, width) returns an positive integer whose binary
-- representation is 1    ...   1 0      ...       0
--                     k times     width - k times
fun ones_prefix (i: integer, k: integer, width: integer) : integer :=
  if (0 <= i) /\ (i < k) then
    2^(width - 1 - i) + ones_prefix(integer, i + 1 : integer, k : integer, width:integer)
  else
    0
  end
-- gccSHR_Twos n m =
--  quot n (2^m) + (sum $ map (\i -> 2^(width - 1 - i)) [0..m-1])




proc rev_listFromStr_aux(str: pointer, acc: [integer]) : eff [integer] :=
  let strong c = load("char", array_shift(str, "char", 0)) in
  if c = 0 then
    return(acc)
  else
    let strong ret = pcall({rev_listFromStr_aux}, array_shift(str, "char", 1), cons(c,acc)) in
      return(ret)
    end
  end
  end


-- TODO: this is the reverse
proc rev_listFromStr(str: pointer) : eff [integer] :=
  let strong ret = pcall({rev_listFromStr_aux}, str, []) in
  return(ret)
  end




proc printf_proxy(tmp_ptr: pointer, args: [(ctype, pointer)]) : eff integer :=
  let strong frmt_ptr = load("char*", tmp_ptr) in
  let strong xs = pcall({rev_listFromStr}, frmt_ptr) in
  let strong ret = pcall({<std_function_printf>}, xs, args) in
  return (ret)
  end
  end
  end



{-
fun printf_zip_aux2(arg:pointer, args: [pointer]) : (pointer, [pointer]) :=
  (arg, args)

fun printf_zip_aux1(ty: ctype, args: [pointer]) : ((ctype, pointer), [pointer]) :=
  let (arg, args) = case_list(args,
    error <<<printf_zip_aux1>>>,
    printf_zip_aux2
  ) in
  ((ty,arg), args)
  end

-- fun printf_zip(xs: [ctype], args: [pointer]) : [(ctype, pointer)] :=
--  case_list(xs)


proc printf_loader(tys: [ctype], args: [pointer]) : eff integer :=
  return(0)
  -}



proc malloc_proxy (size_ptr: pointer) : eff pointer :=
  let strong size = load("size_t", size_ptr) in
  let strong ret = alloc(4, size) in
  return (ret)
  end end






-- see §5.1.2 from ISO/IEC 10967-1:1994(E)
fun wrapI(ty: ctype, n: integer) : integer :=
  let dlt = ivmax(ty) - ivmin(ty) + 1 in
  let r = n rem_f dlt in
  if r <= ivmax(ty) then
    r
  else
    r - dlt
  end
  end
  end


{-
  if n < ivmin(ty) then
    wrapI(ty, n + (ivmax(ty) - ivmin(ty) + 1))
  else if ivmax(ty) < n then
    wrapI(ty, n - (ivmax(ty) - ivmin(ty) + 1))
  else
    n
  end end
-}