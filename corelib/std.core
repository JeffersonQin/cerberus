-- Math utilities
fun exp (n: integer, m: integer) : integer :=
  if m = 0 then
    1
  else
    n * exp(n, m - 1)


fun overflow (ty: ctype, n: integer) : integer :=
  n

-- [conv_int ty n] returns the value [n] converted to the integer type [ty]
fun conv_int (ty: ctype, n: integer): integer :=
  -- (§6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if ty = bool then
    if n = 0 then 0 else 1
  
  -- (§6.3.1.3#1) When a value with integer type is converted to another integer
  -- type other than _Bool, if the value can be represented by the new type, it
  -- is unchanged.
  else if is_representable(n, ty) then
    n
  
  -- (§6.3.1.3#2) Otherwise, if the new type is unsigned, the value is converted
  -- by repeatedly adding or subtracting one more than the maximum value that
  -- can be represented in the new type until the value is in the range of the
  -- new type.
  else if is_unsigned(ty) then
    conv_aux(ty, n)
  
  -- (§6.3.1.3#3) Otherwise, the new type is signed and the value cannot be
  -- represented in it; either the result is implementation-defined or an
  -- implementation-defined signal is raised.
  else
    42


-- auxiliary function for the [conv] (see §6.3.1.3#1)
fun conv_aux (ty: ctype, n: integer) : integer :=
  let n2 =
    if <ctype_max>(ty) < n then
      n - <ctype_max>(ty) + 1
    else
      n + <ctype_max>(ty) + 1 in
  if is_representable(n2, ty) then
    n2
  else
    conv_aux(ty, n2)
  end



-- TODO: the part do-able statically should probably be done by Translation.lem
-- [conv ty1 ty2 n] converts a value [n] of ctype [ty1] to a value of type [ty2]
fun conv (ty1: ctype, ty2: ctype, n: integer): integer :=
  -- (§6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if is_scalar(ty1) /\ ty2 = bool then
    if n = 0 then 0 else 1
  -- (§6.3.1.3#1) When a value with integer type is converted to another integer type other
  -- than _Bool, if the value can be represented by the new type, it is unchanged.
  else if is_integer(ty1) /\ is_integer(ty2) then
    if is_representable(n, ty2) then
      n
    -- (§6.3.1.3#1) Otherwise, if the new type is unsigned, the value is converted by repeatedly
    -- adding or subtracting one more than the maximum value that can be represented in the new type
    -- until the value is in the range of the new type.
    else if is_unsigned(ty2) then
      conv_aux(ty2, n)
    
    -- (§6.3.1.3#1) Otherwise, the new type is signed and the value cannot be represented in it;
    -- either the result is implementation-defined or an implementation-defined signal is raised.
    else
      42 -- TODO
  else
    42 -- TODO: floats, OR ty1/ty2 are non-scalar hence this function is undefined




fun usual_arithmetic (ty: ctype, ty: ctype): ctype :=
  ty

fun ctype_width (ty: ctype): integer :=
  <sizeof>(ty) * <bits_in_byte>


fun is_representable (n: integer, ty: ctype): boolean :=
  <ctype_min>(ty) <= n /\ n <= <ctype_max>(ty)
