%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Syntax and Statics of the Ail_ฯ language                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar

% Types %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
storage_duration :: '' ::=
  {{ com storage duration (\S6.2.4\#1) }}
  | static    :: :: STATIC
  | thread    :: :: THREAD
  | automatic :: :: AUTOMATIC
  | allocated :: :: ALLOCATED % TODO: look at (ยง7.22.3)


integer_base_type :: '' ::=
  {{ com standard signed integer types (\S6.2.5\#4) }}
  | ichar     :: :: ICHAR     {{ com corresponds to \textbf{signed/unsigned char} }}
  | short     :: :: SHORT     {{ com corresponds to \textbf{short int}            }}
  | int       :: :: INT       
  | long      :: :: LONG      {{ com corresponds to \textbf{long int}             }}
  | long long :: :: LONG_LONG {{ com corresponds to \textbf{long long int}        }}


integer_type :: '' ::=
  {{ com integer types (\S6.2.5\#17) }} % TODO: add enumerated types
  | bool                       :: :: BOOL     {{ com corresponds to \textbf{\_Bool} }}
  | signed integer_base_type   :: :: SIGNED
  | unsigned integer_base_type :: :: UNSIGNED


basic_type :: '' ::=
  {{ com basic types (\S6.2.5\#14) }}
  | char         :: :: CHAR
  | integer_type :: :: INTEGER


qualifier :: '' ::=
  {{ com type qualifiers (\S6.7.3) }}
  | const    :: :: CONST
  | restrict :: :: RESTRICT
  | volatile :: :: VOLATILE
  | atomic   :: :: ATOMIC   {{ com \textbf{\_Atomic} in C }}


qualifiers :: '' ::=
  | qualifier1 .. qualifierk :: :: Qualifiers


ctype {{ tex \tau }} :: '' ::=
  {{ com \ailtau types }}
  | qualifiers void                       ::   :: VOID             {{ com \texttt{void} type (\S6.2.5\#19)                  }}
  | qualifiers basic_type                 ::   :: BASIC            {{ com  basic types       (\S6.2.5\#14)                  }}
  | enum id                               ::   :: ENUM             {{ com enumerate types    (\S6.2.5\#16)                  }} % TODO: add names to an env + MOVE TO INTEGER_TYPE
  | ctype [ n ]                           ::   :: ARRAY            {{ com  array types       (\S6.2.5\#20)                  }}
  | struct id {
      storage_duration1 ctype1 mem_decl1 ;
      .. ;
      storage_durationk ctypek mem_declk
    }                                     ::   :: STRUCT           {{ com \TODO{we "unfold" anonymous struct/union and give a tag for struct/union
                                                                                declarated without any} }}
  | union id {
      storage_duration1 ctype1 mem_decl1 ;
      .. ;
      storage_durationk ctypek mem_declk
    }                                     ::   :: UNION
  | ctype ( ctype1 , .. , ctypek )        ::   :: FUNCTION         {{ com  function types                                   }}
  | qualifiers ctype *                    ::   :: POINTER          {{ com  pointer types                                    }}
% atomic types 
  | lvalue ctype                          ::   :: LVALUE           {{ com                                                   }} % TODO something I don't remember
  | bitfield ctype                        ::   :: BITFIELDTY       {{ com                                                   }} % TODO put in a env
  | promote ( ctype                       :: M :: PROMOTE          {{ com integer promotion                                 }}
                                                                   {{ tex \texttt{promote}([[ctype]])                       }}
                                                                   {{ lem [[ctype]]                                         }} % TODO
  | usual_arithmetic ( ctype1 ,  ctype2 ) :: M :: USUAL_ARITHMETIC {{ tex \texttt{usual\_arithmetic}([[ctype1]],[[ctype2]]) }}
                                                                   {{ lem [[ctype1]]                                        }} % TODO

mem_decl :: '' ::=
  | id         :: :: MEMBER_DECL
  | id : ail_e :: :: BITFIELD % TODO the id is an option



% TODO: type_class

% TODO: declaration



% Expressions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
aop {{ lem arithmetic_operator }} {{ tex \bullet }} :: '' ::=
  {{ com arithmetic operators }}
  {{ lem Cabs.arithmetic_operator }}
  | *  :: :: MULT {{ tex \texttt{*}                }} {{ com multiplication       (\S6.5.5)  }}
  | /  :: :: DIV  {{ tex \texttt{/}                }} {{ com division                        }}
  | %  :: :: MOD  {{ tex \texttt{\%}               }} {{ com modulo operator                 }}
  | +  :: :: ADD  {{ tex \texttt{+}                }} {{ com addition             (\S6.5.6)  }}
  | -  :: :: SUB  {{ tex \texttt{-}                }} {{ com substraction                    }}
  | << :: :: SHL  {{ tex \texttt{<<}               }} {{ com bitwise left shift   (\S6.5.7)  }}
  | >> :: :: SHR  {{ tex \texttt{>>}               }} {{ com bitwise right shift             }}
  | &  :: :: BAND {{ tex \texttt{\&}               }} {{ com bitwise AND          (\S6.5.10) }}
  | ^  :: :: XOR  {{ tex \texttt{\textasciicircum} }} {{ com bitwise exclusive OR (\S6.5.11) }}
  | |  :: :: BOR  {{ tex \texttt{|}                }} {{ com bitwise inclusive OR (\S6.5.12) }}

bop {{ lem binary_operator }} {{ tex \circ }} :: '' ::=
  {{ com binary operators }}
  {{ lem Cabs.binary_operator }}
  | aop :: :: ARITHMETIC 
  | ,   :: :: COMMA      {{ tex \texttt{,}    }} {{ com comma operator (\S6.5.17) }}
  | &&  :: :: AND        {{ tex \texttt{\&\&} }} {{ com logical AND    (\S6.5.13) }}
  | ||  :: :: OR         {{ tex \texttt{||}   }} {{ com logical OR     (\S6.5.14) }}
  | <   :: :: LT         {{ tex \texttt{<}    }} {{ com less than      (\S6.5.8)  }}
  | >   :: :: GT         {{ tex \texttt{>}    }} {{ com greater than              }}
  | <=  :: :: LE         {{ tex \texttt{<=}   }} {{ com less than or equal to     }}
  | >=  :: :: GE         {{ tex \texttt{>=}   }} {{ com greater than or equal to  }}
  | ==  :: :: EQ         {{ tex \texttt{==}   }} {{ com equal to       (\S6.5.9)  }}
  | !=  :: :: NE         {{ tex \texttt{!=}   }} {{ com not equal to              }}

uop {{lem unary_operator}} {{ tex \diamond }} :: '' ::=
  {{ com unary operators (6.5.3) }}
  | &  :: :: ADDRESS     {{ tex \texttt{\&}   }} {{ com address operator }}
  | *  :: :: INDIRECTION {{ tex \texttt{*}    }} {{ com indirection operator }}
  | +  :: :: PLUS        {{ tex \texttt{+}    }}
  | -  :: :: MINUS       {{ tex \texttt{-}    }} {{ com negation }}
  | ~  :: :: BNOT        {{ tex \mathtt{\sim} }} {{ com bitwise negation }} % TODO: the typesetting is ugly
%  | ++ :: :: POSTFIX_INCR
%  | -- :: :: POSTFIX_DECR

% integer_constant

% constant


constant :: '' ::=
  {{ com TODO: the other constants }}
  {{ lem Cabs.constant }}
  | n  :: :: CONST_INT  {{ com integer constant }}
%  | CONST_FLOAT of string
  | id :: :: CONST_ENUM {{ com enumeration constant }}
%  | CONST_CHAR of int64 list
%  | CONST_WCHAR of int64 list

aop_opt {{ tex \bullet^{?} }} :: '' ::=
  |     :: :: NIL
  | aop :: :: BASE

expression , ail_e {{ tex e^{\texttt{Ail} } }} :: '' ::=
  | uop ailtau_e                                     :: :: UNARY       
% TODO: K don't know how to put them in uop while telling
%       the parser expect ++ and -- after the expr.
  | ailtau_e ++                                      ::   :: INCR        {{ com postfix increment operator (\S6.5.2.4)                         }}
                                                                      {{ tex [[ailtau_e]] \ \texttt{++}                                        }}
  | ailtau_e --                                      ::   :: DECR        {{ com postfix decrement operator (\S6.5.2.4)                         }}
                                                                      {{ tex [[ailtau_e]] \ \texttt{-{}-}                                      }}
  | ailtau_e1 bop ailtau_e2                             ::   :: BINARY      {{ lem [[bop]] [[ailtau_e1]] [[ailtau_e2]] }}
  | ailtau_e1 aop_opt = ailtau_e2                       ::   :: ASSIGN      {{ com assignment operators (\S6.5.16)                                }}
  | ailtau_e1 ? ailtau_e2 : ailtau_e3                      ::   :: CONDITIONAL {{ com  conditional operator (\S6.5.15)                               }}
                                                                      {{ tex [[ailtau_e1]] \ \texttt{?} \ [[ailtau_e2]] \ \texttt{:} \ [[ailtau_e3]] }}
  | ( ctype ) ailtau_e                               ::   :: CAST        {{ com  cast operator (\S6.5.4)                                       }}
%  | ailtau_e ( ctype1 ailtau_e1 , .. , ctypek ailtau_ek ) ::   :: CALL        {{ com function call (\S6.5.2.2)                                      }}
  | ailtau_e ( ailtau_e1 , .. , ailtau_ek )                ::   :: CALL        {{ com function call (\S6.5.2.2)                                      }}
  | ailtau_e . id                                    ::   :: MEMBEROF    {{ com structure/union member (\S6.5.2.3)                             }}
  | ailtau_e -> id                                   ::   :: MEMBEROFPTR {{ tex [[ailtau_e]] \texttt{->} [[id]]                                   }}
  | constant                                      ::   :: CONSTANT    
  | id                                            ::   :: IDENTIFIER  
  | sizeof ( ailtau_e )                              ::   :: SIZEOF_EXPR {{ com  \texttt{sizeof} operator (\S6.5.3.4)                          }}
                                                                      {{ tex  \texttt{sizeof}([[ailtau_e]])                                    }}
  | sizeof ( ctype )                              ::   :: SIZEOF_TY   {{ tex  \texttt{sizeof}([[ctype]])                                    }}
  | alignof ( ctype )                             ::   :: ALIGNOF     {{ com  \texttt{\_Alignof} operator (\S6.5.3.4)                       }}
                                                                      {{ tex  \texttt{alignof}([[ctype]])                                   }}
  | ( ailtau_e )                                     :: M :: PARENS

annotated_expression, ailtau_e {{ tex e^{\texttt{Ail}_\tau} }} :: '' ::=
  | ail_e             :: :: UNTYPED_EXPR
  | ( ail_e : ctype ) :: :: TYPED_EXPR


% TODO: definitions




statement {{ lem 'a statement_l }} , ail_s {{ tex S^\text{ail} }} :: '' ::=
  | skip                                                 :: :: SKIP              {{ tex \textbm{skip}                                          }}
  | ailtau_e                                                :: :: EXPRESSION        
  | begin vars id1 , .. , idk ; ail_s1 ; .. ; ail_sj end :: :: BLOCK             {{ com TODO: check + typesetting                              }}
                                                                                 
  | if ail_e then ail_s1 else ail_s2                     :: :: IF                {{ tex \textbm{if} \ [[ail_e]] \ \textbm{then} \ [[ail_s1]] \
                                                                                        \textbm{else} \ [[ail_s2]]                             }}
  | while ail_e do ail_s done                            :: :: WHILE             {{ tex \textbm{while} \ [[ail_e]] \ \textbm{do} \
                                                                                        [[ail_s]] \ \textbm{done}                              }}
  | do ail_s while ( ail_e )                             :: :: DO                {{ tex \textbm{do} \ [[ail_s]] \ \textbm{while}([[ail_e]])    }}
  | break                                                :: :: BREAK             {{ tex \textbm{break}                                         }}
  | continue                                             :: :: CONTINUE          {{ tex \textbm{continue}                                      }}
  | returnvoid                                           :: :: RETURN_VOID       {{ tex \textbm{return\_void}                                  }}
  | return ail_e                                         :: :: RETURN_EXPRESSION {{ tex \textbm{return} \ [[ail_e]]                            }}
  | switch ( ail_e ) ail_s                               :: :: SWITCH            {{ tex \textbm{switch}([[ail_e]]) \ [[ail_s]]                 }}
  | case constant : ail_s                                :: :: CASE              {{ tex \textbm{case} \ [[constant]] \textbm{:} \ [[ail_s]]    }}
  | default : ail_s                                      :: :: DEFAULT           {{ tex \textbm{default:} \ [[ail_s]]                          }}
  | id : ail_s                                           :: :: LABEL             
  | goto id                                              :: :: GOTO              {{ tex \textbm{goto} \ [[id]]                                 }}
  % | DECLARATION of 'a definition list
















ail_terminals :: 'ail_terminals_' ::=
  | |-                  ::   :: turnstile  {{ tex \vdash }}
  | !=                  ::   :: neq



  G {{ tex \Gamma }} :: 'G_' ::=
    | empty     :: :: base {{ tex \emptyset }}
    | G , id : ctype :: :: ctor
  
  Sig {{ tex \Sigma }} :: 'Sig_' ::=
    | empty :: :: base % TODO



defns
  Jtype :: '' ::=
  % [integer types, real types] (6.2.5#17)
  % 
  % "The type *char*, the signed and unsigned integer types, and the enumerated
  %  types are collectively called `integer types`. The integer and real floating
  %  types are collectively called `real types`."
  defn is_integer ( ctype ) :: :: is_integer :: 'is_integer_'
       {{ com (6.2.5\#17) }} {{ tex \texttt{is\_integer}([[ctype]]) }} by
  
  % [arithmetic types] (6.2.5#18)
  % 
  % "Integer and floating types are collectively called `arithmetic types`.
  %  (...)"
  defn is_arithmetic ( ctype ) :: :: is_arithmetic :: 'is_arithmetic_' {{ tex \texttt{is\_arithmetic}([[ctype]]) }} by
  
  
% defn
% isObject ( ctype ) :: :: isObject :: isObject_ by

% defn
% isModifiable ( ctype ) :: :: isModifiable :: isModifiable_ by






  defn is_scalar ( ctype ) :: :: is_scalar :: 'is_scalar_'
       {{ com Arithmetic types and pointer types are collectively called \emph{scalar types}. (6.2.5\#21) }}
       {{ tex \texttt{is\_scalar}([[ctype]]) }} by
    is_arithmetic(ctype)
    ----------------- :: arith
    is_scalar(ctype)
    
    ----------------- :: pointer
    is_scalar(ctype*)
    
    
  defn is_aggregate ( ctype ) :: :: is_aggregate :: 'is_aggregate_'
       {{ com Array and structure types are collectively called \emph{aggregate types}. (6.2.5\#21) }}
       {{ tex \texttt{is\_aggregate}([[ctype]]) }} by
    ---------------- :: array
    is_scalar(ctype[n])
    
    -------------------- :: struct
    is_scalar(struct id)
    
    
  % TODO better ?
  defn is_object ( ctype ) :: :: is_object :: 'is_object_'
       {{ tex \texttt{is\_object}([[ctype]]) }} by
    ctype != ctype'(ctype'1, .., ctype'k)
    ---------------------- :: def
    is_object(ctype)
    
    
  defn is_complete_object ( ctype ) :: :: is_complete_object :: 'is_complete_object_'
       {{ tex \texttt{is\_complete\_object}([[ctype]]) }} by
    is_object(ctype)
    ctype != void
    ---------------------- :: def
    is_complete_object(ctype)






% defn
% isCompatibleUnqualified ( ctype1 , ctype2 ) :: :: isCompatibleUnqualified :: isCompatibleUnqualified_ by

% defn
% isNullPtrConstant ( E ) :: :: isNullPtrConstant :: isNullPtrConstant_ by



  defn G , Sig |- ail_e : ctype :: :: Ctype :: Ctype_ by 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% SUMMARY OF THE TYPING
% 
% C as defined in the standard
%   [6.5 Expressions]
%                                                 Corresponding Ail_tau construct     STATUS
%                                                 -----------------------------------------------
%     
%     * identifier                  (ยง6.5.1#2)    Ail.IDENTIFIER                      
%     * constant                    (ยง6.4.4)      Ail.CONSTANT                        
%     * string literal              (ยง6.5.1#3)    <NOT SUPPORTED FOR NOW>             
%     * generic selection           (ยง6.5.1.1)    <NOT SUPPORTED FOR NOW>             
%     
%     * array subscripting          (ยง6.5.2.1)    <TODO: needed for typechecking,     
%                                                        but then translated away>    
%     * function calls              (ยง6.5.2.2)    Ail.CALL                            
%     * structure and union members (ยง6.5.2.3)    Ail.MEMBEROF                        
%                                                 Ail.MEMBEROFPTR                     
%     * Postfix increment operator  (ยง6.5.2.4)    Ail.UNARY Ail.POSTFIX_INCR          
%     * Postfix decrement operator  (ยง6.5.2.4)    Ail.UNARY Ail.POSTFIX_DECR          
%     * Compound literals           (ยง6.5.2.5)    NOT SUPPORTED FOR NOW               
%                                                                                     
%     * prefix increment operator   (ยง6.5.3.1)    <none, translated away>             
%     * prefix decrement operator   (ยง6.5.3.1)    <none, translated away>             
%     * address operator            (ยง6.5.3.2)    Ail.UNARY Ail.ADDRESS               
%     * indirection operator        (ยง6.5.3.2)    Ail.UNARY Ail.INDIRECTION           
%     * (unary) +                   (ยง6.5.3.3)    Ail.UNARY Ail.PLUS                  
%     * (unary) -                   (ยง6.5.3.3)    Ail.UNARY Ail.MINUS                 
%     * (unary) ~                   (ยง6.5.3.3)    Ail.UNARY Ail.BNOT                  
%     * (unary) !                   (ยง6.5.3.3)    <none, transalted away>             
%     * sizeof                      (ยง6.5.3.4)    Ail.SIZEOF                          
%     * alignof                     (ยง6.5.3.4)    Ail.ALIGNOF                         
%                                                                                     
%     * cast operator               (ยง6.5.4)      Ail.CAST                            
%                                                                                     
%     * (multiplicative) *          (ยง6.5.5)      Ail.BINARY Ail.MUL                  
%     * (multiplicative) /          (ยง6.5.5)      Ail.BINARY Ail.DIV                  
%     * (multiplicative) %          (ยง6.5.5)      Ail.BINARY Ail.MOD                  
%                                                                                     
%     * (additive) *                (ยง6.5.6)      Ail.BINARY Ail.ADD                  
%     * (additive) -                (ยง6.5.6)      Ail.BINARY Ail.SUB                  
%                                                                                     
%     * (bitwise shift) <<          (ยง6.5.7)      Ail.BINARY Ail.SHL                  
%     * (bitwise shift) >>          (ยง6.5.7)      Ail.BINARY Ail.SHR                  
%                                                                                     
%     * (relational) <              (ยง6.5.8)      Ail.BINARY Ail.LT                   
%     * (relational) >              (ยง6.5.8)      Ail.BINARY Ail.GT                   
%     * (relational) <=             (ยง6.5.8)      Ail.BINARY Ail.LE                   
%     * (relational) >=             (ยง6.5.8)      Ail.BINARY Ail.GE                   
%                                                                                     
%     * (equality) ==               (ยง6.5.9)      Ail.BINARY Ail.EQ                   
%     * (equality) !=               (ยง6.5.9)      Ail.BINARY Ail.NE                   
%                                                                                     
%     * bitwise AND: &              (ยง6.5.10)     Ail.BINARY Ail.BAND                 
%                                                                                     
%     * bitwise exclusive OR: ^     (ยง6.5.11)     Ail.BINARY Ail.XOR                  
%                                                                                     
%     * bitwise inclusive OR: |     (ยง6.5.12)     Ail.BINARY Ail.BOR                  
%                                                                                     
%     * logical AND: &&             (ยง6.5.13)     Ail.BINARY Ail.AND                  
%                                                                                     
%     * logical OR: ||              (ยง6.5.14)     Ail.BINARY Ail.OR                   
%                                                                                     
%     * conditional operator        (ยง6.5.15)     Ail.CONDITIONAL                     
%                                                                                     
%     * assignment operators        (ยง6.5.16)     Ail.ASSIGN                          
%                                                                                     
%     * comma operator              (ยง6.5.17)     Ail.BINARY Ail.COMMA                
%                                                                                     
%     * constant expression         (ยง6.6)        TODO                                
%
% ==================================================================================================
%
%   [6.8 Statements and blocks]
%                                                    Corresponding Ail_tau construct    STATUS
%                                                    -----------------------------------------------
%     * label                          (ยง6.8.1)      Ail.LABEL                          
%     * case                           (ยง6.8.1)      Ail.CASE                           
%     * default                        (ยง6.8.1)      Ail.DEFAULT                        
%
%     * compound statement             (ยง6.8.2)      Ail.BLOCK                          
%
%     * expression and null statements (ยง6.8.3)      Ail.EXPRESSION                     
%
%     * if statement                   (ยง6.8.4.1)    Ail.IF                             
%     * switch statement               (ยง6.8.4.2)    Ail.SWITCH                         
%
%     * while statement                (ยง6.8.5.1)    Ail.WHICH                          
%     * do statement                   (ยง6.8.5.2)    Ail.DO                             
%     * for statement                  (ยง6.8.5.3)    <none (translated away)>
%
%     * goto statement                 (ยง6.8.6.1)    Ail.GOTO                           
%     * continue statement             (ยง6.8.6.2)    Ail.CONTINUE                       
%     * break statement                (ยง6.8.6.3)    Ail.BREAK                          
%     * return statement               (ยง6.8.6.4)    Ail.RETURN_EXPRESSION
%                                                    Ail.RETURN_VOID









% A.IDENTIFIER

% ==================================================================================================

% A.CONSTANT

% ==================================================================================================

% TODO: string literal

% ==================================================================================================

% TODO: generic selection

% ==================================================================================================

% TODO: array subscripting

% ==================================================================================================

% A.CALL e es
% 1  The expression that denotes the called function shall have type pointer to
%    function returning void or returning a complete object type other than an
%    array type.
% 2  If the expression that denotes the called function has a type that includes
%    a prototype, the number of arguments shall agree with the number of
%    parameters. Each argument shall have a type such that its value may be
%    assigned to an object with the unqualified version of the type of its
%    corresponding parameter.
    G,Sig |- ail_e : qualifiers ctype(ctype1, .., ctypej)*
    ctype = void \/ is_complete_object(ctype) /\ ctype != ctype'[n]
    j = k
    --------------------------------------------------- :: call
    G,Sig |- ail_e(ail_e1, .., ail_ek) : ctype
% is_pointer_to_function(ctype)

% t_base = T.base_of_pointer t in
% t_return = T.function_return t_base in
% t_args = T.function_parameters t_base in



%   | A.CALL e es ->
%       type_of e >>= fun t ->
%       if T.is_pointer_to_function t then
%         let t_base = T.base_of_pointer t in
%         let t_return = T.function_return t_base in
%         let t_args = T.function_parameters t_base in

%         if T.is_void t_return
%           || (T.is_complete_object t_return && not (T.is_array t_return)) then

%           if List.length t_args = List.length es then

%             let is_assignable t e =
%               (* TODO Hack! *)
%               let exp = A.ASSIGN None (one (Annot.a_type l (A.T_LVALUE t))) e in
%               E.to_bool (check_exp env l exp) in
%             if List.for_all2 is_assignable t_args es then
%               E.return (A.T_EXP t_return)
%             else E.fail Type_error.CALL_ARGUMENTS_ASSIGNABLE
%           else E.fail Type_error.CALL_NUMBER_OF_ARGUMENTS
%         else E.fail Type_error.CALL_RETURN
%       else E.fail Type_error.CALL_FUNCTION_POINTER

% ==================================================================================================

% TODO: structure and union members

% ==================================================================================================

    % Ail.UNARY Ail.POSTFIX_INCR

% ==================================================================================================

    % Ail.UNARY Ail.POSTFIX_DECR

% ==================================================================================================

    % TODO: compound literals

% ==================================================================================================

    % A.UNARY A.ADDRESS
    % ------------------------------------------------------------------------ %
    % [& - address operator]                                                   %
    % (ยง6.5.3.2#1) "The operand of the unary & operator shall be either a      %
    %               function designator, the result of a [] or                 %
    %               unary * operator, or an lvalue that designates an object   %
    %               that is not a bit-field and is not declared with the       %
    %               register storage-class specifier."                         %
    % (ยง6.5.3.2#3) "[...] If the operand has type โโtypeโโ, the result has     %
    %               type โโpointer to typeโโ. [...]"                           %
    % ------------------------------------------------------------------------ %
    G,Sig |- e : ctype
    is_function_designator(e) \/
    e = e1[e2] \/
    e = *e1 \/
    is_lvalue_of_"an object that is not a bit-field and is not declared with % the register storage-class specifier"(e)
    ------------------------------------------ :: address
    G,Sig |- &e : ctype*
    
    
    % A.UNARY A.INDIRECTION
    % ------------------------------------------------------------------------ %
    % [* - indirection operator]                                               %
    % (ยง6.5.3.2#2) "The operand of the unary * operator shall have             %
    %               pointer type."                                             %
    % (ยง6.5.3.2#4) "[...] If the operand has type โโpointer to typeโโ, the     %
    %               result has type โโtypeโโ. [...]                            %
    % ------------------------------------------------------------------------ %
    G,Sig |- ail_e : qualifiers ctype*
    isObject(ctype)
    ctype' = promote(ctype)
    ----------------------- :: UnaryIndirection
         G,Sig |- *ail_e : ctype'
    
    
    
    
    
    % ------------------------------------------------------------------------ %
    % [unary +]                                                                %
    % (ยง6.5.3.3#1) "The operand of the unary + [...] operator shall have       %
    %               arithmetic type;"                                          %
    % (ยง6.5.3.3#2) "[...] and the result has the promoted type."               %
    G,Sig |- ail_e : ctype
    is_arithmetic(ctype)
    ctype' = promote(ctype)
    ----------------- :: UnaryPlus
    G,Sig |- +ail_e : ctype'
    
    % ------------------------------------------------------------------------ %
    % [unary -]                                                                %
    % (ยง6.5.3.3#1) "The operand of the unary [...] - operator shall have       %
    %               arithmetic type;"                                          %
    % (ยง6.5.3.3#3) "[...] and the result has the promoted type."               %
    G,Sig  |- ail_e : ctype
    is_arithmetic(ctype)
    ctype' = promote ctype
    ----------------- :: UnaryMinus
    G,Sig  |- -ail_e : ctype'
    
    
    % ------------------------------------------------------------------------ %
    % [unary ~]                                                                %
    % (ยง6.5.3.3#1) "The operand [...] of the unary ~ operator, integer type;"  %
    % (ยง6.5.3.3#4) "[...] and the result has the promoted type."               %
    G,Sig |- ail_e : ctype
    is_integer(ctype)
    ctype' = promote ctype 
    ---------------- :: UnaryBnot
      G,Sig  |- ~ail_e : ctype'
    
    % REMARK ----------------------------------------------------------------- %
    %   In addition to the unary operator present in Ail, Cabs has the         %
    %   ! operator requiring an operand of scalar type and whose result type   %
    %   is [int]. During the desugaring, expressions of the form [!E] are      %
    %   translated to [E==0] (as described in ยง6.5.3.3#5).                     %
    %   This translation is typesafe: assume the type of [E] is not a scalar   %
    %   type, then by definition (ยง6.2.5#21) isn't an arithmetic type nor a    %
    %   pointer type. Hence the translated expression is ill-typed (see typing %
    %   of the equality operator). Otherwise the translated expression verify  %
    %   one of the following typing constraint of the equality operator        %
    %   (ยง6.5.9#2):                                                            %
    %     - both operands have arithmetic type                                 %
    %     - one operand is a pointer and the other is a null pointer constant. %
    %   as 0 is a null pointer constant (ยง6.3.2.3#3)                           %
    % ------------------------------------------------------------------------ %
    
    






% A.UNARY A.POSTFIX_INCR

% A.UNARY A.POSTFIX_DECR


% not isFunction(ty)
% not isIncomplete(ty)
% -------------------------
% |- sizeof(ty) : (A.T_EXP (A.BASIC {} (A.INTEGER (A.SIGNED A.INT))))


% not isFunction(ty)
% not isIncomplete(ty)
% -------------------------
% |- alignof(ty) : (A.T_EXP (A.BASIC {} (A.INTEGER (A.SIGNED A.INT))))


----------------- :: CastVoid
G,Sig |- (void)ail_e : void


% TODO: in the tex the ty1 and ty2 both appear as \tay
G,Sig |- ail_e : ctype2
isScalar(ctype1)
isScalar(ctype2)
--------------------- :: Cast
G,Sig |- (ctype1)ail_e : ctype1


|- E1 : ctype1
|- E2 : ctype2
is_arithmetic(ctype1)
is_arithmetic(ctype2)
-------------------------------------------- :: Mul
|- E1 * E2 : usualArithmetic(ctype1, ctype2)


|- E1 : ctype1
|- E2 : ctype2
is_arithmetic(ctype1)
is_arithmetic(ctype2)
-------------------------------------------- :: Div
|- E1 / E2 : usualArithmetic(ctype1, ctype2)


|- E1 : ctype1
|- E2 : ctype2
is_integer(ctype1)
is_integer(ctype2)
-------------------------------------------- :: Mod
|- E1 % E2 : usualArithmetic(ctype1, ctype2)


|- E1 : qualifiers *ctype1
|- E2 : ctype2
ctype1 != void
isObject(ctype1)
is_integer(ctype2)
-------------------------------------------- :: Add_PtrInt
|- E1 + E2 : qualifiers *ctype1


|- E1 : ctype1
|- E2 : qualifiers *ctype2
ctype2 != void
is_integer(ctype1)
isObject(ctype2)
-------------------------------------------- :: Add_IntPtr
|- E1 + E2 : qualifiers *ctype2

|- E1 : ctype1
|- E2 : ctype2
is_arithmetic(ctype1)
is_arithmetic(ctype2)
-------------------------------------------- :: Add_ArithArith
|- E1 + E2 : usualArithmetic(ctype1, ctype2)


% A.BINARY (C.ARITHMETIC C.SUB) e1 e2

|- E1 : ctype1
|- E2 : ctype2
is_integer(ctype1)
is_integer(ctype2)
ctype' = promote ctype1
-------------------------- :: SHL
|- E1 << E2 : ctype'


|- E1 : ctype1
|- E2 : ctype2
is_integer(ctype1)
is_integer(ctype2)
ctype' = promote ctype1
-------------------------- :: SHR
|- E1 >> E2 : ctype'


% TODO: parsing problem
|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
isObject(ctype1)
isObject(ctype2)
isCompatibleUnqualified ( ctype1 , ctype2 )
-------------------------------- :: Lt_PtrPtr
|- E1 < E2 : signed int


% TODO: parsing problem
|- E1 : ctype1
|- E2 : ctype2
isReal(ctype1)
isReal(ctype2)
-------------------------------- :: Lt_RealReal
|- E1 < E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
isObject(ctype1)
isObject(ctype2)
isCompatibleUnqualified ( ctype1 , ctype2 )
-------------------------------- :: Gt_PtrPtr
|- E1 > E2 : signed int


% TODO: parsing problem
|- E1 : ctype1
|- E2 : ctype2
isReal(ctype1)
isReal(ctype2)
-------------------------------- :: Gt_RealReal
|- E1 > E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
isObject(ctype1)
isObject(ctype2)
isCompatibleUnqualified ( ctype1 , ctype2 )
-------------------------------- :: Le_PtrPtr
|- E1 <= E2 : signed int


% TODO: parsing problem
|- E1 : ctype1
|- E2 : ctype2
isReal(ctype1)
isReal(ctype2)
-------------------------------- :: Le_RealReal
|- E1 <= E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
isObject(ctype1)
isObject(ctype2)
isCompatibleUnqualified ( ctype1 , ctype2 )
-------------------------------- :: Ge_PtrPtr
|- E1 >= E2 : signed int


% TODO: parsing problem
|- E1 : ctype1
|- E2 : ctype2
isReal(ctype1)
isReal(ctype2)
-------------------------------- :: Ge_RealReal
|- E1 >= E2 : signed int


% A.BINARY C.EQ e1 e2


|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
isCompatibleUnqualified ( ctype1 , ctype2 )
------------------------------------- :: Ne_PtrPtr1
|- E1 != E2 : signed int


|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
ctype1 = void /\ isObject(ctype2) \/ isObject(ctype1) /\ ctype2 = void
------------------------------------- :: Ne_PtrPtr2
|- E1 != E2 : signed int




  % | A.BINARY C.NE e1 e2 ->
  %     type_of e1 >>= fun t1 ->
  %     type_of e2 >>= fun t2 ->

  %     match (t1, t2) with
  %     | (A.POINTER _ b1, A.POINTER _ b2) ->
  %         if T.compatible_unqualified b1 b2 then
  %           E.return (A.T_EXP int) OK

  %         (* void pointer *)
  %         else if T.is_void b1 && T.is_object b2 then
  %           E.return (A.T_EXP int)
  %         else if T.is_object b1 && T.is_void b2 then
  %           E.return (A.T_EXP int)



% TODO: check
|- E1 : qualifiers1 *ctype1
|- E2 : qualifiers2 *ctype2
ctype1 != void /\ ctype2 != void
isNullPtrConstant(E1) \/ isNullPtrConstant(E2)
------------------------------------- :: Ne_PtrPtr3
|- E1 != E2 : signed int

  %         (* null pointer constant of pointer type*)
  %         else if is_null_pointer_constant e1 then
  %           E.return (A.T_EXP int)
  %         else if is_null_pointer_constant e2 then
  %           E.return (A.T_EXP int)

  %         else E.fail Type_error.NE_POINTERS

  %     (* null pointer constant of integer type *)
  %     | (A.POINTER _ _, _) ->
  %         if is_null_pointer_constant e2 then
  %           E.return (A.T_EXP int)
  %         else E.fail Type_error.NE_NULL_POINTER_CONSTANT_SECOND
  %     | (_, A.POINTER _ _) ->
  %         if is_null_pointer_constant e1 then
  %           E.return (A.T_EXP int)
  %         else E.fail Type_error.NE_NULL_POINTER_CONSTANT_FIRST

  %     | _ ->
  %         if T.is_arithmetic t1 then
  %           if T.is_arithmetic t2 then
  %             E.return (A.T_EXP int)
  %           else E.fail Type_error.NE_ARITHMETIC
  %         else E.fail Type_error.NE_ALL
  %     end


% ==================================
G,Sig |- ail_e1 : ctype1
G,Sig |- ail_e2 : ctype2
is_integer(ctype1)
is_integer(ctype2)
---------------------------------------------------- :: BAND
G,Sig |- ail_e1 & ail_e2 : usual_arithmetic(ctype1,ctype2)


G,Sig |- ail_e1 : ctype1
G,Sig |- ail_e2 : ctype2
is_integer(ctype1)
is_integer(ctype2)
---------------------------------------------------- :: XOR
G,Sig |- ail_e1 ^ ail_e2 : usual_arithmetic(ctype1,ctype2)

G,Sig |- ail_e1 : ctype1
G,Sig |- ail_e2 : ctype2
is_integer(ctype1)
is_integer(ctype2)
--------------------------------------------------- :: BOR
G,Sig|- ail_e1 | ail_e2 : usual_arithmetic(ctype1,ctype2)

G,Sig |- ail_e1 : ctype1
G,Sig |- ail_e2 : ctype2
is_scalar(ctype1)
is_scalar(ctype2)
-------------------------------------- :: AND
G,Sig |- ail_e1 && ail_e2 : signed int

G,Sig |- ail_e1 : ctype1
G,Sig |- ail_e2 : ctype2
is_scalar(ctype1)
is_scalar(ctype2)
-------------------------------- :: OR
G,Sig |- ail_e1 || ail_e2 : signed int

% A.QUESTION e1 e2 e3

% A.ASSIGN None e1 e2

% A.ASSIGN (Some C.ADD) e1 e2

% A.ASSIGN (Some C.SUB) e1 e2

% A.ASSIGN (Some o) e1 e2

% A.BINARY C.COMMA e1 e2


% ------- DONE WITH EXPRESSIONS ---------
defn
G , Sig |- [ ail_s ] ok :: :: StmtOk :: 'StmtOk_'
  {{ com statement well-formedness and expressions typechecking entry point }}
  {{ tex [[G]], [[Sig]] [[|-]] [ [[ail_s]] ] \ \textbm{ok} }} by 
  
  G,Sig |- ail_e : ctype
  is_scalar(ctype)
  G,Sig |- [ail_s1] ok
  G,Sig |- [ail_s2] ok
  ---------------------------------------------- :: if
  G,Sig |- [if ail_e then ail_s1 else ail_s2] ok
  
  
  G,Sig |- ail_e : ctype
  is_integer(ctype)
  G,Sig |- [ail_s] ok
  ---------------------------------- :: switch
  G,Sig |- [switch (ail_e) ail_s] ok
  
  
  G,Sig |- ail_e : ctype
  is_scalar(ctype)
  G,Sig |- [ail_s] ok
  --------------------------------------- :: while
  G,Sig |- [while ail_e do ail_s done] ok
  
  
  G,Sig |- ail_e : ctype
  is_scalar(ctype)
  G,Sig |- [ail_s] ok
  ----------------------------------- :: do
  G,Sig |- [do ail_s while(ail_e)] ok
  
  
  % BLOCK
  
  
  ------------------- :: break
  G,Sig |- [break] ok
  
  
  ---------------------- :: continue
  G,Sig |- [continue] ok
  
  
  ------------------------ :: returnvoid
  G,Sig |- [returnvoid] ok
  
  % return E
  % case n: S
  
  
       G,Sig |- [ail_s] ok
  ---------------------------- :: default
  G,Sig |- [default: ail_s] ok
  
  
  isLabel(id,Sig)
  G,Sig |- [ail_s] ok
  ----------------------- :: label
  G,Sig |- [id: ail_s] ok
  
  
      isLabel(id,Sig)
  --------------------- :: goto
  G,Sig |- [goto id] ok

