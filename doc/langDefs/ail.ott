%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Syntax and Statics of the Ail_ฯ language                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar

% Types %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
storage_duration :: '' ::=
  {{ com storage duration (\S6.2.4\#1) }}
  | static    :: :: STATIC
  | thread    :: :: THREAD
  | automatic :: :: AUTOMATIC
  | allocated :: :: ALLOCATED % TODO: look at (ยง7.22.3)


integer_base_type :: '' ::=
  {{ com standard signed integer types (\S6.2.5\#4) }}
  | ichar     :: :: ICHAR     {{ com corresponds to \textbf{signed/unsigned char} }}
  | short     :: :: SHORT     {{ com corresponds to \textbf{short int}            }}
  | int       :: :: INT       
  | long      :: :: LONG      {{ com corresponds to \textbf{long int}             }}
  | long long :: :: LONG_LONG {{ com corresponds to \textbf{long long int}        }}


integer_type :: '' ::=
  {{ com integer types (\S6.2.5\#17) }} % TODO: add enumerated types
  | bool                       :: :: BOOL     {{ com corresponds to \textbf{\_Bool} }}
  | signed integer_base_type   :: :: SIGNED
  | unsigned integer_base_type :: :: UNSIGNED


basic_type :: '' ::=
  {{ com basic types (\S6.2.5\#14) }}
  | char         :: :: CHAR
  | integer_type :: :: INTEGER


qualifier :: '' ::=
  {{ com type qualifiers (\S6.7.3) }}
  | const    :: :: CONST
  | restrict :: :: RESTRICT
  | volatile :: :: VOLATILE
  | atomic   :: :: ATOMIC   {{ com \textbf{\_Atomic} in C }}


qualifiers :: '' ::=
  | qualifier1 .. qualifierk :: :: Qualifiers


ty {{ tex \tau }} :: '' ::=
  {{ com $\texttt{Ail}_\tau$ types }}
  | qualifiers void                 ::   :: VOID             {{ com \texttt{void} type (\S6.2.5\#19) }}
  | qualifiers basic_type           ::   :: BASIC            {{ com  basic types       (\S6.2.5\#14) }}
  | enum id                         ::   :: ENUM             {{ com enumerate types    (\S6.2.5\#16) }} % TODO: add names to an env + MOVE TO INTEGER_TYPE
  | ty [ n ]                        ::   :: ARRAY            {{ com  array types       (\S6.2.5\#20) }}
%  | struct 
%  | union
  | ty ( ty1 , .. , tyk )           ::   :: FUNCTION         {{ com  function types                  }}
  | qualifiers ty *                 ::   :: POINTER          {{ com  pointer types                   }}
% atomic types 
  | lvalue ty                       ::   :: LVALUE           {{ com  }} % TODO something I don't remember
  | bitfield ty                     ::   :: BITFIELD         {{ com  }} % TODO put in a env
  | promote ( ty )                  :: M :: PROMOTE          {{ com integer promotion }}
                                                             {{ tex \texttt{promote}([[ty]]) }}
  | usual_arithmetic ( ty1 ,  ty2 ) :: M :: USUAL_ARITHMETIC {{ tex \texttt{usual\_arithmetic}([[ty1]],[[ty2]]) }}



% TODO: member declarator


% TODO: type_class

% TODO: declaration



% Expressions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
aop {{ tex \bullet }} :: '' ::= {{ com arithmetic operators }}
  | *  :: :: MULT {{ tex \texttt{*}                }} {{ com multiplication       (\S6.5.5)  }}
  | /  :: :: DIV  {{ tex \texttt{/}                }} {{ com division                        }}
  | %  :: :: MOD  {{ tex \texttt{\%}               }} {{ com modulo operator                 }}
  | +  :: :: ADD  {{ tex \texttt{+}                }} {{ com addition             (\S6.5.6)  }}
  | -  :: :: SUB  {{ tex \texttt{-}                }} {{ com substraction                    }}
  | << :: :: SHL  {{ tex \texttt{<<}               }} {{ com bitwise left shift   (\S6.5.7)  }}
  | >> :: :: SHR  {{ tex \texttt{>>}               }} {{ com bitwise right shift             }}
  | &  :: :: BAND {{ tex \texttt{\&}               }} {{ com bitwise AND          (\S6.5.10) }}
  | ^  :: :: XOR  {{ tex \texttt{\textasciicircum} }} {{ com bitwise exclusive OR (\S6.5.11) }}
  | |  :: :: BOR  {{ tex \texttt{|}                }} {{ com bitwise inclusive OR (\S6.5.12) }}

bop {{ tex \circ }} :: '' ::= {{ com binary operators }}
  | aop :: :: ARITHMETIC 
  | ,   :: :: COMMA      {{ tex \texttt{,}    }} {{ com comma operator (\S6.5.17) }}
  | &&  :: :: AND        {{ tex \texttt{\&\&} }} {{ com logical AND    (\S6.5.13) }}
  | ||  :: :: OR         {{ tex \texttt{||}   }} {{ com logical OR     (\S6.5.14) }}
  | <   :: :: LT         {{ tex \texttt{<}    }} {{ com less than      (\S6.5.8)  }}
  | >   :: :: GT         {{ tex \texttt{<}    }} {{ com greater than              }}
  | <=  :: :: LE         {{ tex \texttt{<=}   }} {{ com less than or equal to     }}
  | >=  :: :: GE         {{ tex \texttt{>=}   }} {{ com greater than or equal to  }}
  | ==  :: :: EQ         {{ tex \texttt{==}   }} {{ com equal to       (\S6.5.9)  }}
  | !=  :: :: NE         {{ tex \texttt{!=}   }} {{ com not equal to              }}

uop :: '' ::=
  {{ com unary operators (6.5.3) }}
  {{ tex \diamond }}
  | &  :: :: ADDRESS     {{ tex \texttt{\&}   }} {{ com address operator }}
  | *  :: :: INDIRECTION {{ tex \texttt{*}    }} {{ com indirection operator }}
  | +  :: :: PLUS        {{ tex \texttt{+}    }}
  | -  :: :: MINUS       {{ tex \texttt{-}    }} {{ com negation }}
  | ~  :: :: BNOT        {{ tex \mathtt{\sim} }} {{ com bitwise negation }} % TODO: the typesetting is ugly
%  | ++ :: :: POSTFIX_INCR
%  | -- :: :: POSTFIX_DECR

% integer_constant

% constant


constant :: '' ::=
  {{ com TODO: the other constants }}
  | n  :: :: CONST_INT  {{ com integer constant }}
%  | CONST_FLOAT of string
  | id :: :: CONST_ENUM {{ com enumeration constant }}
%  | CONST_CHAR of int64 list
%  | CONST_WCHAR of int64 list

expression, ail_e {{ tex e }} :: '' ::=
  | uop ail_e                              :: :: UNARY       
% TODO: K don't know how to put them in uop while telling
%       the parser expect ++ and -- after the expr.
  | ail_e ++                               :: :: INCR        {{ com postfix increment operator (\S6.5.2.4)                         }}
                                                             {{ tex [[ail_e]] \ \texttt{++}                                        }}
  | ail_e --                               :: :: DECR        {{ com postfix decrement operator (\S6.5.2.4)                         }}
                                                             {{ tex [[ail_e]] \ \texttt{-{}-}                                      }}
  | ail_e1 bop ail_e2                      :: :: BINARY      
  | ail_e1 aop = ail_e2                    :: :: ASSIGN      {{ com assignment operators (\S6.5.16)                                }}
  | ail_e1 ? ail_e2 : ail_e3               :: :: CONDITIONAL {{ com  conditional operator (\S6.5.15)                               }}
                                                             {{ tex [[ail_e1]] \ \texttt{?} \ [[ail_e2]] \ \texttt{:} \ [[ail_e3]] }}
  | ( ty ) ail_e                           :: :: CAST        {{ com  cast operator (\S6.5.4)                                       }}
%  | ail_e ( ty1 ail_e1 , .. , tyk ail_ek ) :: :: CALL        {{ com function call (\S6.5.2.2)                                      }}
  | ail_e ( ail_e1 , .. , ail_ek )          :: :: CALL        {{ com function call (\S6.5.2.2)                                      }}
  | ail_e . id                             :: :: MEMBEROF    {{ com structure/union member (\S6.5.2.3)                             }}
  | ail_e -> id                            :: :: MEMBEROFPTR {{ tex [[ail_e]] \texttt{->} [[id]]                                   }}
  | constant                               :: :: CONSTANT    
  | id                                     :: :: VARIABLE    
  | sizeof ( ty )                          :: :: SIZEOF      {{ com  \texttt{sizeof} operator (\S6.5.3.4)                          }}
                                                             {{ tex  \texttt{sizeof}([[ty]])                                       }}
  | alignof ( ty )                         :: :: ALIGNOF     {{ com  \texttt{\_Alignof} operator (\S6.5.3.4)                       }}
                                                             {{ tex  \texttt{alignof}([[ty]])                                      }}

% E_tau :: 'E_tau_' ::=
%   {{ tex E_\tau }}
%   | E : ty :: :: Expr


% TODO: definitions




statement, ail_s {{ tex S }} :: '' ::=
  | skip                                                 :: :: SKIP              {{ tex \textbm{skip}                                          }}
  | ail_e                                                :: :: EXPRESSION        
  | begin vars id1 , .. , idk ; ail_s1 ; .. ; ail_sj end :: :: BLOCK             {{ com TODO: check + typesetting                              }}
                                                                                 
  | if ail_e then ail_s1 else ail_s2                     :: :: IF                {{ tex \textbm{if} \ [[ail_e]] \ \textbm{then} \ [[ail_s1]] \
                                                                                        \textbm{else} \ [[ail_s2]]                             }}
  | while ail_e do ail_s done                            :: :: WHILE             {{ tex \textbm{while} \ [[ail_e]] \ \textbm{do} \
                                                                                        [[ail_s]] \ \textbm{done}                              }}
  | do ail_s while ( ail_e )                             :: :: DO                {{ tex \textbm{do} \ [[ail_s]] \ \textbm{while}([[ail_e]])    }}
  | break                                                :: :: BREAK             {{ tex \textbm{break}                                         }}
  | continue                                             :: :: CONTINUE          {{ tex \textbm{continue}                                      }}
  | returnvoid                                           :: :: RETURN_VOID       {{ tex \textbm{return\_void}                                  }}
  | return ail_e                                         :: :: RETURN_EXPRESSION {{ tex \textbm{return} \ [[ail_e]]                            }}
  | switch ( ail_e ) ail_s                               :: :: SWITCH            {{ tex \textbm{switch}([[ail_e]]) \ [[ail_s]]                 }}
  | case constant : ail_s                                :: :: CASE              {{ tex \textbm{case} \ [[constant]] \textbm{:} \ [[ail_s]]    }}
  | default : ail_s                                      :: :: DEFAULT           {{ tex \textbm{default:} \ [[ail_s]]                          }}
  | id : ail_s                                           :: :: LABEL             
  | goto id                                              :: :: GOTO              {{ tex \textbm{goto} \ [[id]]                                 }}
  % | DECLARATION of 'a definition list
















ail_terminals :: 'ail_terminals_' ::=
  | |-                  ::   :: turnstile  {{ tex \vdash }}
  | !=                  ::   :: neq



  G {{ tex \Gamma }} :: 'G_' ::=
    | empty     :: :: base {{ tex \emptyset }}
    | G , id : ty :: :: ctor
  
  Sig {{ tex \Sigma }} :: 'Sig_' ::=
    | empty :: :: base % TODO



defns
  Jtype :: '' ::=
  % [integer types, real types] (6.2.5#17)
  % 
  % "The type *char*, the signed and unsigned integer types, and the enumerated
  %  types are collectively called `integer types`. The integer and real floating
  %  types are collectively called `real types`."
  defn is_integer ( ty ) :: :: is_integer :: 'is_integer_'
       {{ com (6.2.5\#17) }} {{ tex \texttt{is\_integer}([[ty]]) }} by
  
  % [arithmetic types] (6.2.5#18)
  % 
  % "Integer and floating types are collectively called `arithmetic types`.
  %  (...)"
  defn is_arithmetic ( ty ) :: :: is_arithmetic :: 'is_arithmetic_' {{ tex \texttt{is\_arithmetic}([[ty]]) }} by
  
  
% defn
% isObject ( ty ) :: :: isObject :: isObject_ by

% defn
% isModifiable ( ty ) :: :: isModifiable :: isModifiable_ by






  defn is_scalar ( ty ) :: :: is_scalar :: 'is_scalar_'
       {{ com Arithmetic types and pointer types are collectively called \emph{scalar types}. (6.2.5\#21) }}
       {{ tex \texttt{is\_scalar}([[ty]]) }} by
    is_arithmetic(ty)
    ----------------- :: arith
    is_scalar(ty)
    
    ----------------- :: pointer
    is_scalar(ty*)
    
    
  defn is_aggregate ( ty ) :: :: is_aggregate :: 'is_aggregate_'
       {{ com Array and structure types are collectively called \emph{aggregate types}. (6.2.5\#21) }}
       {{ tex \texttt{is\_aggregate}([[ty]]) }} by
    ---------------- :: array
    is_scalar(ty[n])
    
    -------------------- :: struct
    is_scalar(struct id)
    
    
  % TODO better ?
  defn is_object ( ty ) :: :: is_object :: 'is_object_'
       {{ tex \texttt{is\_object}([[ty]]) }} by
    ty != ty'(ty'1, .., ty'k)
    ---------------------- :: def
    is_object(ty)
    
    
  defn is_complete_object ( ty ) :: :: is_complete_object :: 'is_complete_object_'
       {{ tex \texttt{is\_complete\_object}([[ty]]) }} by
    is_object(ty)
    ty != void
    ---------------------- :: def
    is_complete_object(ty)






% defn
% isCompatibleUnqualified ( ty1 , ty2 ) :: :: isCompatibleUnqualified :: isCompatibleUnqualified_ by

% defn
% isNullPtrConstant ( E ) :: :: isNullPtrConstant :: isNullPtrConstant_ by



  defn G , Sig |- ail_e : ty :: :: Ty :: Ty_ by 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% SUMMARY OF THE TYPING
% 
% C as defined in the standard
%   [6.5 Expressions]
%                                                 Corresponding Ail_tau construct     STATUS
%                                                 -----------------------------------------------
%     
%     * identifier                  (ยง6.5.1#2)    Ail.IDENTIFIER                      
%     * constant                    (ยง6.4.4)      Ail.CONSTANT                        
%     * string literal              (ยง6.5.1#3)    <NOT SUPPORTED FOR NOW>             
%     * generic selection           (ยง6.5.1.1)    <NOT SUPPORTED FOR NOW>             
%     
%     * array subscripting          (ยง6.5.2.1)    <TODO: needed for typechecking,     
%                                                        but then translated away>    
%     * function calls              (ยง6.5.2.2)    Ail.CALL                            
%     * structure and union members (ยง6.5.2.3)    Ail.MEMBEROF                        
%                                                 Ail.MEMBEROFPTR                     
%     * Postfix increment operator  (ยง6.5.2.4)    Ail.UNARY Ail.POSTFIX_INCR          
%     * Postfix decrement operator  (ยง6.5.2.4)    Ail.UNARY Ail.POSTFIX_DECR          
%     * Compound literals           (ยง6.5.2.5)    NOT SUPPORTED FOR NOW               
%                                                                                     
%     * prefix increment operator   (ยง6.5.3.1)    <none, translated away>             
%     * prefix decrement operator   (ยง6.5.3.1)    <none, translated away>             
%     * address operator            (ยง6.5.3.2)    Ail.UNARY Ail.ADDRESS               
%     * indirection operator        (ยง6.5.3.2)    Ail.UNARY Ail.INDIRECTION           
%     * (unary) +                   (ยง6.5.3.3)    Ail.UNARY Ail.PLUS                  
%     * (unary) -                   (ยง6.5.3.3)    Ail.UNARY Ail.MINUS                 
%     * (unary) ~                   (ยง6.5.3.3)    Ail.UNARY Ail.BNOT                  
%     * (unary) !                   (ยง6.5.3.3)    <none, transalted away>             
%     * sizeof                      (ยง6.5.3.4)    Ail.SIZEOF                          
%     * alignof                     (ยง6.5.3.4)    Ail.ALIGNOF                         
%                                                                                     
%     * cast operator               (ยง6.5.4)      Ail.CAST                            
%                                                                                     
%     * (multiplicative) *          (ยง6.5.5)      Ail.BINARY Ail.MUL                  
%     * (multiplicative) /          (ยง6.5.5)      Ail.BINARY Ail.DIV                  
%     * (multiplicative) %          (ยง6.5.5)      Ail.BINARY Ail.MOD                  
%                                                                                     
%     * (additive) *                (ยง6.5.6)      Ail.BINARY Ail.ADD                  
%     * (additive) -                (ยง6.5.6)      Ail.BINARY Ail.SUB                  
%                                                                                     
%     * (bitwise shift) <<          (ยง6.5.7)      Ail.BINARY Ail.SHL                  
%     * (bitwise shift) >>          (ยง6.5.7)      Ail.BINARY Ail.SHR                  
%                                                                                     
%     * (relational) <              (ยง6.5.8)      Ail.BINARY Ail.LT                   
%     * (relational) >              (ยง6.5.8)      Ail.BINARY Ail.GT                   
%     * (relational) <=             (ยง6.5.8)      Ail.BINARY Ail.LE                   
%     * (relational) >=             (ยง6.5.8)      Ail.BINARY Ail.GE                   
%                                                                                     
%     * (equality) ==               (ยง6.5.9)      Ail.BINARY Ail.EQ                   
%     * (equality) !=               (ยง6.5.9)      Ail.BINARY Ail.NE                   
%                                                                                     
%     * bitwise AND: &              (ยง6.5.10)     Ail.BINARY Ail.BAND                 
%                                                                                     
%     * bitwise exclusive OR: ^     (ยง6.5.11)     Ail.BINARY Ail.XOR                  
%                                                                                     
%     * bitwise inclusive OR: |     (ยง6.5.12)     Ail.BINARY Ail.BOR                  
%                                                                                     
%     * logical AND: &&             (ยง6.5.13)     Ail.BINARY Ail.AND                  
%                                                                                     
%     * logical OR: ||              (ยง6.5.14)     Ail.BINARY Ail.OR                   
%                                                                                     
%     * conditional operator        (ยง6.5.15)     Ail.CONDITIONAL                     
%                                                                                     
%     * assignment operators        (ยง6.5.16)     Ail.ASSIGN                          
%                                                                                     
%     * comma operator              (ยง6.5.17)     Ail.BINARY Ail.COMMA                
%                                                                                     
%     * constant expression         (ยง6.6)        TODO                                
%
% ==================================================================================================
%
%   [6.8 Statements and blocks]
%                                                    Corresponding Ail_tau construct    STATUS
%                                                    -----------------------------------------------
%     * label                          (ยง6.8.1)      Ail.LABEL                          
%     * case                           (ยง6.8.1)      Ail.CASE                           
%     * default                        (ยง6.8.1)      Ail.DEFAULT                        
%
%     * compound statement             (ยง6.8.2)      Ail.BLOCK                          
%
%     * expression and null statements (ยง6.8.3)      Ail.EXPRESSION                     
%
%     * if statement                   (ยง6.8.4.1)    Ail.IF                             
%     * switch statement               (ยง6.8.4.2)    Ail.SWITCH                         
%
%     * while statement                (ยง6.8.5.1)    Ail.WHICH                          
%     * do statement                   (ยง6.8.5.2)    Ail.DO                             
%     * for statement                  (ยง6.8.5.3)    <none (translated away)>
%
%     * goto statement                 (ยง6.8.6.1)    Ail.GOTO                           
%     * continue statement             (ยง6.8.6.2)    Ail.CONTINUE                       
%     * break statement                (ยง6.8.6.3)    Ail.BREAK                          
%     * return statement               (ยง6.8.6.4)    Ail.RETURN_EXPRESSION
%                                                    Ail.RETURN_VOID









% A.IDENTIFIER

% ==================================================================================================

% A.CONSTANT

% ==================================================================================================

% TODO: string literal

% ==================================================================================================

% TODO: generic selection

% ==================================================================================================

% TODO: array subscripting

% ==================================================================================================

% A.CALL e es
% 1  The expression that denotes the called function shall have type pointer to
%    function returning void or returning a complete object type other than an
%    array type.
% 2  If the expression that denotes the called function has a type that includes
%    a prototype, the number of arguments shall agree with the number of
%    parameters. Each argument shall have a type such that its value may be
%    assigned to an object with the unqualified version of the type of its
%    corresponding parameter.
    G,Sig |- ail_e : qualifiers ty(ty1, .., tyj)*
    ty = void \/ is_complete_object(ty) /\ ty != ty'[n]
    j = k
    --------------------------------------------------- :: call
    G,Sig |- ail_e(ail_e1, .., ail_ek) : ty
% is_pointer_to_function(ty)

% t_base = T.base_of_pointer t in
% t_return = T.function_return t_base in
% t_args = T.function_parameters t_base in



%   | A.CALL e es ->
%       type_of e >>= fun t ->
%       if T.is_pointer_to_function t then
%         let t_base = T.base_of_pointer t in
%         let t_return = T.function_return t_base in
%         let t_args = T.function_parameters t_base in

%         if T.is_void t_return
%           || (T.is_complete_object t_return && not (T.is_array t_return)) then

%           if List.length t_args = List.length es then

%             let is_assignable t e =
%               (* TODO Hack! *)
%               let exp = A.ASSIGN None (one (Annot.a_type l (A.T_LVALUE t))) e in
%               E.to_bool (check_exp env l exp) in
%             if List.for_all2 is_assignable t_args es then
%               E.return (A.T_EXP t_return)
%             else E.fail Type_error.CALL_ARGUMENTS_ASSIGNABLE
%           else E.fail Type_error.CALL_NUMBER_OF_ARGUMENTS
%         else E.fail Type_error.CALL_RETURN
%       else E.fail Type_error.CALL_FUNCTION_POINTER

% ==================================================================================================

% TODO: structure and union members

% ==================================================================================================

    % Ail.UNARY Ail.POSTFIX_INCR

% ==================================================================================================

    % Ail.UNARY Ail.POSTFIX_DECR

% ==================================================================================================

    % TODO: compound literals

% ==================================================================================================

    % A.UNARY A.ADDRESS
    % ------------------------------------------------------------------------ %
    % [& - address operator]                                                   %
    % (ยง6.5.3.2#1) "The operand of the unary & operator shall be either a      %
    %               function designator, the result of a [] or                 %
    %               unary * operator, or an lvalue that designates an object   %
    %               that is not a bit-field and is not declared with the       %
    %               register storage-class specifier."                         %
    % (ยง6.5.3.2#3) "[...] If the operand has type โโtypeโโ, the result has     %
    %               type โโpointer to typeโโ. [...]"                           %
    % ------------------------------------------------------------------------ %
    G,Sig |- e : ty
    is_function_designator(e) \/
    e = e1[e2] \/
    e = *e1 \/
    is_lvalue_of_"an object that is not a bit-field and is not declared with % the register storage-class specifier"(e)
    ------------------------------------------ :: address
    G,Sig |- &e : ty*
    
    
    % A.UNARY A.INDIRECTION
    % ------------------------------------------------------------------------ %
    % [* - indirection operator]                                               %
    % (ยง6.5.3.2#2) "The operand of the unary * operator shall have             %
    %               pointer type."                                             %
    % (ยง6.5.3.2#4) "[...] If the operand has type โโpointer to typeโโ, the     %
    %               result has type โโtypeโโ. [...]                            %
    % ------------------------------------------------------------------------ %
    G,Sig |- ail_e : qualifiers ty*
    isObject(ty)
    ty' = promote(ty)
    ----------------------- :: UnaryIndirection
         G,Sig |- *ail_e : ty'
    
    
    
    
    
    % ------------------------------------------------------------------------ %
    % [unary +]                                                                %
    % (ยง6.5.3.3#1) "The operand of the unary + [...] operator shall have       %
    %               arithmetic type;"                                          %
    % (ยง6.5.3.3#2) "[...] and the result has the promoted type."               %
    G,Sig |- ail_e : ty
    is_arithmetic(ty)
    ty' = promote(ty)
    ----------------- :: UnaryPlus
    G,Sig |- +ail_e : ty'
    
    % ------------------------------------------------------------------------ %
    % [unary -]                                                                %
    % (ยง6.5.3.3#1) "The operand of the unary [...] - operator shall have       %
    %               arithmetic type;"                                          %
    % (ยง6.5.3.3#3) "[...] and the result has the promoted type."               %
    G,Sig  |- ail_e : ty
    is_arithmetic(ty)
    ty' = promote ty
    ----------------- :: UnaryMinus
    G,Sig  |- -ail_e : ty'
    
    
    % ------------------------------------------------------------------------ %
    % [unary ~]                                                                %
    % (ยง6.5.3.3#1) "The operand [...] of the unary ~ operator, integer type;"  %
    % (ยง6.5.3.3#4) "[...] and the result has the promoted type."               %
    G,Sig |- ail_e : ty
    is_integer(ty)
    ty' = promote ty 
    ---------------- :: UnaryBnot
      G,Sig  |- ~ail_e : ty'
    
    % REMARK ----------------------------------------------------------------- %
    %   In addition to the unary operator present in Ail, Cabs has the         %
    %   ! operator requiring an operand of scalar type and whose result type   %
    %   is [int]. During the desugaring, expressions of the form [!E] are      %
    %   translated to [E==0] (as described in ยง6.5.3.3#5).                     %
    %   This translation is typesafe: assume the type of [E] is not a scalar   %
    %   type, then by definition (ยง6.2.5#21) isn't an arithmetic type nor a    %
    %   pointer type. Hence the translated expression is ill-typed (see typing %
    %   of the equality operator). Otherwise the translated expression verify  %
    %   one of the following typing constraint of the equality operator        %
    %   (ยง6.5.9#2):                                                            %
    %     - both operands have arithmetic type                                 %
    %     - one operand is a pointer and the other is a null pointer constant. %
    %   as 0 is a null pointer constant (ยง6.3.2.3#3)                           %
    % ------------------------------------------------------------------------ %
    
    






% A.UNARY A.POSTFIX_INCR

% A.UNARY A.POSTFIX_DECR


% not isFunction(ty)
% not isIncomplete(ty)
% -------------------------
% |- sizeof(ty) : (A.T_EXP (A.BASIC {} (A.INTEGER (A.SIGNED A.INT))))


% not isFunction(ty)
% not isIncomplete(ty)
% -------------------------
% |- alignof(ty) : (A.T_EXP (A.BASIC {} (A.INTEGER (A.SIGNED A.INT))))


----------------- :: CastVoid
G,Sig |- (void)ail_e : void


% TODO: in the tex the ty1 and ty2 both appear as \tay
G,Sig |- ail_e : ty2
isScalar(ty1)
isScalar(ty2)
--------------------- :: Cast
G,Sig |- (ty1)ail_e : ty1


|- E1 : ty1
|- E2 : ty2
is_arithmetic(ty1)
is_arithmetic(ty2)
-------------------------------------------- :: Mul
|- E1 * E2 : usualArithmetic(ty1, ty2)


|- E1 : ty1
|- E2 : ty2
is_arithmetic(ty1)
is_arithmetic(ty2)
-------------------------------------------- :: Div
|- E1 / E2 : usualArithmetic(ty1, ty2)


|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
-------------------------------------------- :: Mod
|- E1 % E2 : usualArithmetic(ty1, ty2)


|- E1 : qualifiers *ty1
|- E2 : ty2
ty1 != void
isObject(ty1)
is_integer(ty2)
-------------------------------------------- :: Add_PtrInt
|- E1 + E2 : qualifiers *ty1


|- E1 : ty1
|- E2 : qualifiers *ty2
ty2 != void
is_integer(ty1)
isObject(ty2)
-------------------------------------------- :: Add_IntPtr
|- E1 + E2 : qualifiers *ty2

|- E1 : ty1
|- E2 : ty2
is_arithmetic(ty1)
is_arithmetic(ty2)
-------------------------------------------- :: Add_ArithArith
|- E1 + E2 : usualArithmetic(ty1, ty2)


% A.BINARY (C.ARITHMETIC C.SUB) e1 e2

|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
ty' = promote ty1
-------------------------- :: SHL
|- E1 << E2 : ty'


|- E1 : ty1
|- E2 : ty2
is_integer(ty1)
is_integer(ty2)
ty' = promote ty1
-------------------------- :: SHR
|- E1 >> E2 : ty'


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Lt_PtrPtr
|- E1 < E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Lt_RealReal
|- E1 < E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Gt_PtrPtr
|- E1 > E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Gt_RealReal
|- E1 > E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Le_PtrPtr
|- E1 <= E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Le_RealReal
|- E1 <= E2 : signed int


% TODO: parsing problem
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isObject(ty1)
isObject(ty2)
isCompatibleUnqualified ( ty1 , ty2 )
-------------------------------- :: Ge_PtrPtr
|- E1 >= E2 : signed int


% TODO: parsing problem
|- E1 : ty1
|- E2 : ty2
isReal(ty1)
isReal(ty2)
-------------------------------- :: Ge_RealReal
|- E1 >= E2 : signed int


% A.BINARY C.EQ e1 e2


|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
isCompatibleUnqualified ( ty1 , ty2 )
------------------------------------- :: Ne_PtrPtr1
|- E1 != E2 : signed int


|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
ty1 = void /\ isObject(ty2) \/ isObject(ty1) /\ ty2 = void
------------------------------------- :: Ne_PtrPtr2
|- E1 != E2 : signed int




  % | A.BINARY C.NE e1 e2 ->
  %     type_of e1 >>= fun t1 ->
  %     type_of e2 >>= fun t2 ->

  %     match (t1, t2) with
  %     | (A.POINTER _ b1, A.POINTER _ b2) ->
  %         if T.compatible_unqualified b1 b2 then
  %           E.return (A.T_EXP int) OK

  %         (* void pointer *)
  %         else if T.is_void b1 && T.is_object b2 then
  %           E.return (A.T_EXP int)
  %         else if T.is_object b1 && T.is_void b2 then
  %           E.return (A.T_EXP int)



% TODO: check
|- E1 : qualifiers1 *ty1
|- E2 : qualifiers2 *ty2
ty1 != void /\ ty2 != void
isNullPtrConstant(E1) \/ isNullPtrConstant(E2)
------------------------------------- :: Ne_PtrPtr3
|- E1 != E2 : signed int

  %         (* null pointer constant of pointer type*)
  %         else if is_null_pointer_constant e1 then
  %           E.return (A.T_EXP int)
  %         else if is_null_pointer_constant e2 then
  %           E.return (A.T_EXP int)

  %         else E.fail Type_error.NE_POINTERS

  %     (* null pointer constant of integer type *)
  %     | (A.POINTER _ _, _) ->
  %         if is_null_pointer_constant e2 then
  %           E.return (A.T_EXP int)
  %         else E.fail Type_error.NE_NULL_POINTER_CONSTANT_SECOND
  %     | (_, A.POINTER _ _) ->
  %         if is_null_pointer_constant e1 then
  %           E.return (A.T_EXP int)
  %         else E.fail Type_error.NE_NULL_POINTER_CONSTANT_FIRST

  %     | _ ->
  %         if T.is_arithmetic t1 then
  %           if T.is_arithmetic t2 then
  %             E.return (A.T_EXP int)
  %           else E.fail Type_error.NE_ARITHMETIC
  %         else E.fail Type_error.NE_ALL
  %     end


% ==================================
G,Sig |- ail_e1 : ty1
G,Sig |- ail_e2 : ty2
is_integer(ty1)
is_integer(ty2)
---------------------------------------------------- :: BAND
G,Sig |- ail_e1 & ail_e2 : usual_arithmetic(ty1,ty2)


G,Sig |- ail_e1 : ty1
G,Sig |- ail_e2 : ty2
is_integer(ty1)
is_integer(ty2)
---------------------------------------------------- :: XOR
G,Sig |- ail_e1 ^ ail_e2 : usual_arithmetic(ty1,ty2)

G,Sig |- ail_e1 : ty1
G,Sig |- ail_e2 : ty2
is_integer(ty1)
is_integer(ty2)
--------------------------------------------------- :: BOR
G,Sig|- ail_e1 | ail_e2 : usual_arithmetic(ty1,ty2)

G,Sig |- ail_e1 : ty1
G,Sig |- ail_e2 : ty2
is_scalar(ty1)
is_scalar(ty2)
-------------------------------------- :: AND
G,Sig |- ail_e1 && ail_e2 : signed int

G,Sig |- ail_e1 : ty1
G,Sig |- ail_e2 : ty2
is_scalar(ty1)
is_scalar(ty2)
-------------------------------- :: OR
G,Sig |- ail_e1 || ail_e2 : signed int

% A.QUESTION e1 e2 e3

% A.ASSIGN None e1 e2

% A.ASSIGN (Some C.ADD) e1 e2

% A.ASSIGN (Some C.SUB) e1 e2

% A.ASSIGN (Some o) e1 e2

% A.BINARY C.COMMA e1 e2


% ------- DONE WITH EXPRESSIONS ---------
defn
G , Sig |- [ ail_s ] ok :: :: StmtOk :: 'StmtOk_'
  {{ com statement well-formedness and expressions typechecking entry point }}
  {{ tex [[G]], [[Sig]] [[|-]] [ [[ail_s]] ] \ \textbm{ok} }} by 
  
  G,Sig |- ail_e : ty
  is_scalar(ty)
  G,Sig |- [ail_s1] ok
  G,Sig |- [ail_s2] ok
  ---------------------------------------------- :: if
  G,Sig |- [if ail_e then ail_s1 else ail_s2] ok
  
  
  G,Sig |- ail_e : ty
  is_integer(ty)
  G,Sig |- [ail_s] ok
  ---------------------------------- :: switch
  G,Sig |- [switch (ail_e) ail_s] ok
  
  
  G,Sig |- ail_e : ty
  is_scalar(ty)
  G,Sig |- [ail_s] ok
  --------------------------------------- :: while
  G,Sig |- [while ail_e do ail_s done] ok
  
  
  G,Sig |- ail_e : ty
  is_scalar(ty)
  G,Sig |- [ail_s] ok
  ----------------------------------- :: do
  G,Sig |- [do ail_s while(ail_e)] ok
  
  
  % BLOCK
  
  
  ------------------- :: break
  G,Sig |- [break] ok
  
  
  ---------------------- :: continue
  G,Sig |- [continue] ok
  
  
  ------------------------ :: returnvoid
  G,Sig |- [returnvoid] ok
  
  % return E
  % case n: S
  
  
       G,Sig |- [ail_s] ok
  ---------------------------- :: default
  G,Sig |- [default: ail_s] ok
  
  
  isLabel(id,Sig)
  G,Sig |- [ail_s] ok
  ----------------------- :: label
  G,Sig |- [id: ail_s] ok
  
  
      isLabel(id,Sig)
  --------------------- :: goto
  G,Sig |- [goto id] ok

