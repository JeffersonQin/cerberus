grammar
core_eop {{ tex \bullet }} :: 'core_eop' ::= {{ com arithmetic operators }}
  | + :: :: ADD    {{ tex \texttt{+}  }}
  | - :: :: SUB    {{ tex \texttt{-}  }}
  | * :: :: MULT   {{ tex \texttt{*}  }}
  | / :: :: DIV    {{ tex \texttt{/}  }}
  | % :: :: MODULO {{ tex \texttt{\%} }}

core_e {{ tex e }} :: 'core_e' ::= {{ com pure expressions }}
  | n                                   :: :: CONSTANT 
  | a                                   :: :: SYMBOL   
  | core_e1 core_eop core_e2            :: :: EOP      
  | if core_b then core_e1 else core_e2 :: :: IF       % {{ com TODO: document                                                   }}
                                                       {{ tex \textbm{if} \ [[core_b]] \ \textbm{then} \ [[core_e1]] \
                                                                    \textbm{else} \ [[core_e2]] }}
  | max { ty }                          :: :: MAX      % {{ com maximum value representable with the type [[ty]]                 }}
                                                       {{ tex \textbm{max}_{[[ty]]}                                            }}
  | min { ty }                          :: :: MIN      % {{ com minimum value representable with the type [[ty]]                 }}
                                                       {{ tex \textbm{min}_{[[ty]]}                                            }}
  | sizeof { ty }                       :: :: SIZEOF   % {{ com size (in bytes) of [[ty]]                                        }}
                                                       {{ tex \textbm{sizeof}_{[[ty]]}                                         }}
  | alignof { ty }                      :: :: ALIGNOF  % {{ com alignment requirement of [[ty]]                                  }}
                                                       {{ tex \textbm{alignof}_{[[ty]]}                                        }}
  | offsetof { ty }                     :: :: OFFSETOF % {{ com {\color{orange}TODO }                                            }}
                                                       {{ tex \textbm{offsetof}_{[[ty]]}                                       }}
  | shift a core_e                      :: :: SHIFT    % {{ com TODO ([[a]] is of type addr)                                     }}
                                                       {{ tex \textbm{shift} \ [[a]] \ [[core_e]]                              }}
  | conv { ty1 \ ty2 } core_e           :: :: CONV     % {{ com convert the value of [[core_e]] from the type [[ty1]] to [[ty2]] }}
                                                       {{ tex \textbm{conv}_{[[ty1]] \rightarrow [[ty2]]} \ [[core_e]]         }}



core_bop {{ tex \circ }} :: 'core_bop' ::= {{ com relational operators }}
  | = :: :: EQ {{ tex \texttt{=} }}
  | < :: :: LT {{ tex \texttt{<} }}


core_connective {{ tex \diamond }} :: 'core_connective' ::= {{ com logical connectives }}
  | /\ :: :: AND {{ tex \wedge }}
  | \/ :: :: OR  {{ tex \vee }}

core_b {{ tex b }} :: 'core_b' ::= {{ com boolean tests }}
  | true                            :: :: TRUE
  | false                           :: :: FALSE
  | core_e1 core_bop core_e2        :: :: BEXPR
  | core_b1 core_connective core_b2 :: :: BOP

p :: '' ::= {{ com patterns }}
  | a                :: :: ATOM  (+ b = a +)
  | ( p1 , .. , pk ) :: :: TUPLE (+ b = b(p1 .. pk) +)

core_s {{ tex S }} :: 'core_s' ::= {{ com statements }}
  | skip                                :: :: SKIP                           {{ tex \textbm{skip}                                                        }}
  | undef                               :: :: UNDEF                          % {{ com signal an undefined behaviour                                        }}
                                                                             {{ tex \textbm{undef}                                                       }}
  | error                               :: :: ERROR                          % {{ com signal that detection of implementation-defined static error         }}
                                                                             {{ tex \textbm{error}                                                       }}
  | let p = core_s1 in core_s2          :: :: LET (+ bind b(p) in core_s2 +) % {{ com the actions of [[core_s1]] are sequenced-before those of [[core_s2]] }}
                                                                             {{ tex \textbm{let} \ [[p]] = [[core_s1]] \ \textbm{in} \ [[core_s2]]       }}
  | if core_b then core_s1 else core_s2 :: :: IF                             {{ tex \textbm{if} \ [[core_b]] \ \textbm{then} \ [[core_s1]] \
                                                                                    \textbm{else} \ [[core_s2]]                                          }}
%  | core_s1 + core_s2                  :: :: PLUS                           {{ com non-deterministic choice                                             }}
  | core_s1 || core_s2                  :: :: PAR                            % {{ com the actions of [[S1]] are unsequenced with those of [[core_s2]]      }}
                                                                             {{ tex [[core_s1]] \ || \ [[core_s2]]                                       }}
  | create { ty }                       :: :: CREATE                         % {{ com create an object of effective type [[ty]]                            }}
                                                                             {{ tex \textbm{create}_{[[ty]]}                                             }}
  | alloc a                             :: :: ALLOC                          % {{ com create an object (without effective type)                            }}
                                                                             {{ tex \textbm{alloc} \ [[a]]                                               }}
  | kill a                              :: :: KILL                           % {{ com destroy an object                                                    }}
                                                                             {{ tex \textbm{kill} \ [[a]]                                                }}
  | store { ty } a1 a2                  :: :: STORE                          % {{ com store the value [[a2]] in the object [[a1]]                          }}
                                                                             {{ tex \textbm{store}_{[[ty]]} \ [[a1]] \ [[a2]]                            }}
  | load { ty } a                       :: :: LOAD                           % {{ com load the value stored in the object [[a]]                            }}
                                                                             {{ tex \textbm{load}_{[[ty]]} \ [[a]]                                       }}
  | same a1 a2                          :: :: SAME                           % {{ com  TODO: document                                                      }}
                                                                             {{ tex \textbm{same} \ [[a1]] \ [[a2]]                                      }}
% (*  | FUN of 'a * 'a list * 'a statement *)
  | f ( a1 .. ak )                      :: :: FUNCALL                        % {{ com call to a \core{} function                                           }}
  | call a ( a1 .. ak )                 :: :: CALL                           % {{ com these are indeterminately sequenced with their context               }}
  
  | [ core_s ]                          :: :: ATOMICBLOCK                    % {{ com atomic blocks                                                        }}



fun_def :: 'function_definition_' ::= {{ com pure functions }}
  | fun f ( a1 .. ak ) = core_e :: :: '' (+ bind a1 .. ak in core_e +)

proc_def :: 'procedure_definition_' ::= {{ com procedures }}
  | proc  a ( a1 .. ak ) = core_s :: :: '' (+ bind a1 .. ak in core_s +)


program, P :: 'program_' ::=
  | fun_def1 ; .. ; fun_defj ;
    proc_def1 ; .. ; proc_defk  :: :: '' {{ tex [[proc_def1]] ; .. ; [[proc_defk]] }}







coreTy, T :: 'cTy_' ::=
  | unit             :: :: UNIT
  | bool             :: :: BOOL
  | val              :: :: VAL
  | addr             :: :: ADDR
  | ( T1 , .. , Tk ) :: :: TUPLE



  G_core {{ tex \Gamma }} :: 'G_core_' ::=
    | empty     :: :: base {{ tex \emptyset }}
    | G_core , a : T :: :: ctor





  core_formula :: 'core_formula_' ::=          
    | ( a , T ) _in G_core :: :: xTG_core 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
  Jtype_core :: '' ::=
    
    % Core expressions typing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G_core |e- core_e : T :: :: coreETyping :: 'CoreE_' by
      ------------------ :: const
      G_core |e- n : val
      
      (a,T) _in G_core
      ---------------- :: sym
      G_core |e- a : T
      
      G_core |e- core_e1 : val
      G_core |e- core_e2 : val
      ----------------------------------------- :: eop
      G_core |e- core_e1 core_eop core_e2 : val
      
      G_core |b- core_b : bool
      G_core |e- core_e1 : val
      G_core |e- core_e2 : val
      ---------------------------------------------------- :: if
      G_core |e- if core_b then core_e1 else core_e2 : val
      
      ------------------------ :: max
      G_core |e- max{ty} : val
      
      ------------------------ :: min
      G_core |e- min{ty} : val
      
      --------------------------- :: sizeof
      G_core |e- sizeof{ty} : val
      
      ---------------------------- :: alignof
      G_core |e- alignof{ty} : val
      
      ----------------------------- :: offsetof
      G_core |e- offsetof{ty} : val
      
      (a, addr) _in G_core
      G_core |e- core_e : val
      ------------------------------- :: shift
      G_core |e- shift a core_e : val
      
      G_core |e- core_e : val
      ------------------------------------- :: conv
      G_core |e- conv{ty1\ty2} core_e : val
      
      
    % Core boolean tests typing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G_core |b- core_b : T :: :: coreBTyping :: 'CoreB_' by
      ---------------------- :: true
      G_core |b- true : bool
      
      ----------------------- :: false
      G_core |b- false : bool
      
      G_core |e- core_e1 : val
      G_core |e- core_e2 : val
      ----------------------------------------- :: bexpr
      G_core |b- core_e1 core_bop core_e2 : val
      
      G_core |b- core_b1 : bool
      G_core |b- core_b2 : bool
      ------------------------------------------------- :: bop
      G_core |b- core_b1 core_connective core_b2 : bool
      
      
    % Core statements typing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G_core |s- S : coreTy :: :: coreSTyping :: CoreS_ by
      
      ---------------------- :: skip
      G_core |s- skip : unit
      
      ---------------------- :: fail
      G_core |s- fail : unit
      
      G_core |e- core_e : T
      --------------------- :: expr
      G_core |s- core_e : T
      
      % let
      
      G_core |b- B : val
      G_core |s- S1 : T
      G_core |s- S2 : T
      ------------------------------ :: if
      G_core |s- if B then S1 else S2 : T
      
      G_core |s- S1 : T
      G_core |s- S2 : T
      ----------------- :: plus
      G_core |s- S1 + S2 : T
      
      G_core |s- S1 : T1
      G_core |s- S2 : T2
      ------------------------ :: par
      G_core |s- S1 || S2 : (T1,T2)
      
      ----------------------- :: create
      G_core |s- create{ty} : addr
      
          (a,val) _in G_core
      -------------------- :: alloc
      G_core |s- alloc a : addr
      
         (a,addr) _in G_core
      ------------------- :: kill
      G_core |s- kill a : unit
      
      (a1,addr) _in G_core
      (a2,val) _in G_core
      ---------------------------- :: store
      G_core |s- store{ty} a1 a2 : unit
      
          (a,addr) _in G_core
      ---------------------- :: load
      G_core |s- load{ty} a : val
      
      (a1,addr) _in G_core
      (a2,addr) _in G_core
      ----------------------- :: same
      G_core |s- same a1 a2 : unit
      
      % FUN
      % CALL
