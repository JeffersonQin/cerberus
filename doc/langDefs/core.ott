% embed
%   {{ tex
% \newcommand{\mknewline}{\\}
%   }}

grammar
core_eop {{ tex \bullet }} :: 'core_eop' ::= {{ com arithmetic operators }}
  | + :: :: ADD    {{ tex \texttt{+}  }}
  | - :: :: SUB    {{ tex \texttt{-}  }}
  | * :: :: MULT   {{ tex \texttt{*}  }}
  | / :: :: DIV    {{ tex \texttt{/}  }}
  | % :: :: MODULO {{ tex \texttt{\%} }}

core_e {{ tex e^\text{core} }} :: 'core_e' ::= {{ com pure expressions }}
  | n                                   :: :: CONSTANT 
  | a                                   :: :: SYMBOL   
  | core_e1 core_eop core_e2            :: :: EOP      
  | if core_b then core_e1 else core_e2 :: :: IF       % {{ com TODO: document                                                   }}
                                                       {{ tex \textbm{if} \ [[core_b]] \ \textbm{then} \ [[core_e1]] \
                                                                    \textbm{else} \ [[core_e2]] }}
  | max { ctype }                       :: :: MAX      % {{ com maximum value representable with the type [[ctype]]                 }}
                                                       {{ tex \textbm{max}_{[[ctype]]}                                            }}
  | min { ctype }                       :: :: MIN      % {{ com minimum value representable with the type [[ctype]]                 }}
                                                       {{ tex \textbm{min}_{[[ctype]]}                                            }}
  | sizeof { ctype }                    :: :: SIZEOF   % {{ com size (in bytes) of [[ctype]]                                        }}
                                                       {{ tex \textbm{sizeof}_{[[ctype]]}                                         }}
  | alignof { ctype }                   :: :: ALIGNOF  % {{ com alignment requirement of [[ctype]]                                  }}
                                                       {{ tex \textbm{alignof}_{[[ctype]]}                                        }}
  | offsetof { ctype }                  :: :: OFFSETOF % {{ com {\color{orange}TODO }                                            }}
                                                       {{ tex \textbm{offsetof}_{[[ctype]]}                                       }}
  | shift a core_e                      :: :: SHIFT    % {{ com TODO ([[a]] is of type addr)                                     }}
                                                       {{ tex \textbm{shift} \ [[a]] \ [[core_e]]                              }}
  | conv { ctype1 \ ctype2 } core_e     :: :: CONV     % {{ com convert the value of [[core_e]] from the type [[ctype1]] to [[ctype2]] }}
                                                       {{ tex \textbm{conv}_{[[ctype1]] \rightarrow [[ctype2]]} \ [[core_e]]         }}



core_bop {{ tex \circ }} :: 'core_bop' ::= {{ com relational operators }}
  | = :: :: EQ {{ tex \texttt{=} }}
  | < :: :: LT {{ tex \texttt{<} }}


core_connective {{ tex \diamond }} :: 'core_connective' ::= {{ com logical connectives }}
  | /\ :: :: AND {{ tex \wedge }}
  | \/ :: :: OR  {{ tex \vee }}

core_b {{ tex b^\text{core} }} :: 'core_b' ::= {{ com boolean tests }}
  | true                            :: :: TRUE
  | false                           :: :: FALSE
  | core_e1 core_bop core_e2        :: :: BEXPR
  | core_b1 core_connective core_b2 :: :: BOP

p :: '' ::= {{ com patterns }}
  | a                :: :: ATOM  (+ b = a +)
  | ( p1 , .. , pk ) :: :: TUPLE (+ b = b(p1 .. pk) +)

core_s {{ tex S^\text{core} }} :: 'core_s' ::= {{ com statements }}
  | skip                                :: :: SKIP                           {{ tex \textbm{skip}                                                        }}
  | undef                               :: :: UNDEF                          % {{ com signal an undefined behaviour                                        }}
                                                                             {{ tex \textbm{undef}                                                       }}
  | error                               :: :: ERROR                          % {{ com signal that detection of implementation-defined static error         }}
                                                                             {{ tex \textbm{error}                                                       }}
  | core_e                              :: :: EXPR                           
  | let p = core_s1 in core_s2          :: :: LET (+ bind b(p) in core_s2 +) % {{ com the actions of [[core_s1]] are sequenced-before those of [[core_s2]] }}
                                                                             {{ tex \textbm{let} \ [[p]] = [[core_s1]] \ \textbm{in} \ [[core_s2]] }}
  | if core_b then core_s1 else core_s2 :: :: IF                             {{ tex \textbm{if} \ [[core_b]] \ \textbm{then} \ [[core_s1]] \
                                                                                    \textbm{else} \ [[core_s2]]                                          }}
%  | core_s1 + core_s2                  :: :: PLUS                           {{ com non-deterministic choice                                             }}
  | core_s1 || core_s2                  :: :: PAR                            % {{ com the actions of [[S1]] are unsequenced with those of [[core_s2]]      }}
                                                                             {{ tex [[core_s1]] \ || \ [[core_s2]]                                       }}
  | create { ctype }                    :: :: CREATE                         % {{ com create an object of effective type [[ctype]]                            }}
                                                                             {{ tex \textbm{create}_{[[ctype]]}                                             }}
  | alloc a                             :: :: ALLOC                          % {{ com create an object (without effective type)                            }}
                                                                             {{ tex \textbm{alloc} \ [[a]]                                               }}
  | kill a                              :: :: KILL                           % {{ com destroy an object                                                    }}
                                                                             {{ tex \textbm{kill} \ [[a]]                                                }}
  | store { ctype } a1 a2                  :: :: STORE                          % {{ com store the value [[a2]] in the object [[a1]]                          }}
                                                                             {{ tex \textbm{store}_{[[ctype]]} \ [[a1]] \ [[a2]]                            }}
  | load { ctype } a                       :: :: LOAD                           % {{ com load the value stored in the object [[a]]                            }}
                                                                             {{ tex \textbm{load}_{[[ctype]]} \ [[a]]                                       }}
  | same a1 a2                          :: :: SAME                           % {{ com  TODO: document                                                      }}
                                                                             {{ tex \textbm{same} \ [[a1]] \ [[a2]]                                      }}
% (*  | FUN of 'a * 'a list * 'a statement *)
  | f ( a1 .. ak )                      :: :: FUNCALL                        % {{ com call to a \core{} function                                           }}
  | call a ( a1 .. ak )                 :: :: CALL                           % {{ com these are indeterminately sequenced with their context               }}
  
  | [ core_s ]                          :: :: ATOMICBLOCK                    % {{ com atomic blocks                                                        }}
  
  | [multiline] core_s :: M :: multiline {{ com typesetting hack }} {{ tex \left[ \begin{array}{l}[[core_s]]\end{array} \right] }}
  | [newline] core_s   :: M :: newline   {{ com typesetting hack }} {{ tex \\ [[core_s]]                         }}


f :: '' ::=
  | fname    ::   :: '' {{ com user defined functions }}
  | overflow :: M :: 'overlow' {{ com }}

fun_def :: 'function_definition_' ::= {{ com pure functions }}
  | fun fname ( a1 .. ak ) = core_e :: :: '' (+ bind a1 .. ak in core_e +)

proc_def :: 'procedure_definition_' ::= {{ com procedures }}
  | proc  a ( a1 .. ak ) = core_s :: :: '' (+ bind a1 .. ak in core_s +)


program, P :: 'program_' ::=
  | fun_def1 ; .. ; fun_defj ;
    proc_def1 ; .. ; proc_defk  :: :: '' {{ tex [[proc_def1]] ; .. ; [[proc_defk]] }}







coreTy, T :: 'cTy_' ::=
  | unit             :: :: UNIT
  | bool             :: :: BOOL
  | val              :: :: VAL
  | addr             :: :: ADDR
  | type             :: :: CTYPE
  | T1 -> T2         :: :: FUN
  | ( T1 , .. , Tk ) :: :: TUPLE



  G_core {{ tex \Gamma }} :: 'G_core_' ::=
%    | empty     :: :: base {{ tex \emptyset }}
    | overflow : type -> val -> val :: :: STD
    | G_core , a : T                :: :: ctor





  core_formula :: 'core_formula_' ::=          
    | ( a , T ) _in G_core :: :: xTG_core 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
  Jtype_core :: '' ::=
    
    % Core expressions typing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G_core |e- core_e : T :: :: coreETyping :: 'CoreE_' by
      ------------------ :: const
      G_core |e- n : val
      
      (a,T) _in G_core
      ---------------- :: sym
      G_core |e- a : T
      
      G_core |e- core_e1 : val
      G_core |e- core_e2 : val
      ----------------------------------------- :: eop
      G_core |e- core_e1 core_eop core_e2 : val
      
      G_core |b- core_b : bool
      G_core |e- core_e1 : val
      G_core |e- core_e2 : val
      ---------------------------------------------------- :: if
      G_core |e- if core_b then core_e1 else core_e2 : val
      
      ------------------------ :: max
      G_core |e- max{ctype} : val
      
      ------------------------ :: min
      G_core |e- min{ctype} : val
      
      --------------------------- :: sizeof
      G_core |e- sizeof{ctype} : val
      
      ---------------------------- :: alignof
      G_core |e- alignof{ctype} : val
      
      ----------------------------- :: offsetof
      G_core |e- offsetof{ctype} : val
      
      (a, addr) _in G_core
      G_core |e- core_e : val
      ------------------------------- :: shift
      G_core |e- shift a core_e : val
      
      G_core |e- core_e : val
      ------------------------------------- :: conv
      G_core |e- conv{ctype1\ctype2} core_e : val
      
      
    % Core boolean tests typing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G_core |b- core_b : T :: :: coreBTyping :: 'CoreB_' by
      ---------------------- :: true
      G_core |b- true : bool
      
      ----------------------- :: false
      G_core |b- false : bool
      
      G_core |e- core_e1 : val
      G_core |e- core_e2 : val
      ----------------------------------------- :: bexpr
      G_core |b- core_e1 core_bop core_e2 : val
      
      G_core |b- core_b1 : bool
      G_core |b- core_b2 : bool
      ------------------------------------------------- :: bop
      G_core |b- core_b1 core_connective core_b2 : bool
      
      
    % Core statements typing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G_core |s- S : coreTy :: :: coreSTyping :: CoreS_ by
      
      ---------------------- :: skip
      G_core |s- skip : unit
      
      ---------------------- :: fail
      G_core |s- fail : unit
      
      G_core |e- core_e : T
      --------------------- :: expr
      G_core |s- core_e : T
      
      % let
      
      G_core |b- B : val
      G_core |s- S1 : T
      G_core |s- S2 : T
      ------------------------------ :: if
      G_core |s- if B then S1 else S2 : T
      
      G_core |s- S1 : T
      G_core |s- S2 : T
      ----------------- :: plus
      G_core |s- S1 + S2 : T
      
      G_core |s- S1 : T1
      G_core |s- S2 : T2
      ------------------------ :: par
      G_core |s- S1 || S2 : (T1,T2)
      
      ----------------------- :: create
      G_core |s- create{ctype} : addr
      
          (a,val) _in G_core
      -------------------- :: alloc
      G_core |s- alloc a : addr
      
         (a,addr) _in G_core
      ------------------- :: kill
      G_core |s- kill a : unit
      
      (a1,addr) _in G_core
      (a2,val) _in G_core
      ---------------------------- :: store
      G_core |s- store{ctype} a1 a2 : unit
      
          (a,addr) _in G_core
      ---------------------- :: load
      G_core |s- load{ctype} a : val
      
      (a1,addr) _in G_core
      (a2,addr) _in G_core
      ----------------------- :: same
      G_core |s- same a1 a2 : unit
      
      % FUN
      % CALL

    % Ail_tau to Core translation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    defn G , Sig |- ail_e ~> core_s :: :: translation :: trans_  by
      % | A.VARIABLE id ->
      %     if T.is_array (lookup_type id) then
      %       E.return (Pmap.find id env, Me.unit)
      %     else
      %       f_lvalue exp >>= fun (a, m) ->
      %       C.fresh      >>= fun v      ->
      %       Action.load (lvalue_type exp) a v >>= fun load ->
      %       E.return (v, m -@> load)
      G,Sig |- id : ctype[n]
      ----------------------- :: ident_array
      G, Sig |- id ~> skip
      % TODO
      
      G,Sig |- id : ctype
      ctype != ctype'[n]
      ----------------------- :: ident
      G, Sig |- id ~> skip
      % TODO
      
      
      % | A.CONSTANT (Cabs.CONST_INT (i, _)) ->
      %     E.return (C.const i, Me.unit)
      ------------------------------- :: const_int
      G, Sig |- n ~> n
      
      
      % (* (6.5.2.4) Postfix increment and decrement operators *)
      %
      % let rec reduce_lvalue n b env file exp =
      %   let f = reduce_exp n b env file in
      %   match Annotate.exp_of exp with
      %   | A.VARIABLE id           -> E.return (Pmap.find id env, Me.unit)
      %   | A.UNARY A.INDIRECTION e -> do
      %                                  (a,m) <- f e
      %                                  let t           = T.base_of_pointer (T.pointer_convert (exp_type e))
      %                                      ill_aligned = C.neg (Tc.is_aligned t a)
      %                                      null        = C.eq a C.null
      %                                      c           = C.implies (C.disj null ill_aligned) C.undef
      %                                  E.return (a, m +& c)
      %   | _                       -> do
      %                                  a <- C.fresh
      %                                  E.return (a, Me.null)
      %   end
      %
      % let f_lvalue e = do
      %                    (a,m) <- reduce_lvalue n b env file e
      %                    E.return (a, m) in
      
      % | A.UNARY A.POSTFIX_INCR e -> do
      %     (a,m) <- f_lvalue e
      %     v     <- C.fresh
      %     let incr = C.plus v C.one
      %     (v', c) <- Tc.conv_int (exp_type e) incr
      %     load    <- Action.load  (lvalue_type e) a v
      %     store   <- Action.store (lvalue_type e) a v'
      %     E.return (v, Me.conj_sb (m +& c) (Me.add_ls_pair load store Me.unit))
      G,Sig |- ail_e : ctype
      G,Sig |- ail_e ~> core_e
      ------------------------------- :: postfix_incr
      G,Sig |- ail_e++ ~> skip
      % TODO
      
      
      % | A.UNARY A.POSTFIX_DECR e ->
      %     f_lvalue e >>= fun (a, m) ->
      %     C.fresh    >>= fun v      ->
      %     let decr = C.minus v C.one in
      %     Tc.conv_int (exp_type e) decr >>= fun (v', c) ->
      %     Action.load  (lvalue_type e) a v  >>= fun load  ->
      %     Action.store (lvalue_type e) a v' >>= fun store ->
      %     let modify = Me.add_ls_pair load store Me.unit in
      %     if T.is_signed_integer(exp_type exp) then
      %       let c' = overflow (exp_type exp) decr in
      %       E.return (decr, Me.conj_sb (m +& c +& c') modify)
      %     else
      %       E.return (v, Me.conj_sb (m +& c) modify)
      ------------------------------- :: postfix_decr
      G,Sig |- ail_e-- ~> skip
      
      
      % | A.UNARY A.ADDRESS (_, (A.UNARY A.INDIRECTION e)) -> f e
         G,Sig |- ail_e ~> core_s
      ----------------------------- :: addr_indir
      G,Sig |- &(* ail_e) ~> core_s
      
      
      % | A.UNARY A.ADDRESS e -> f_lvalue e
       core_s = f_lvalue ail_e
      ------------------------- :: addr
      G,Sig |- &ail_e ~> core_s
      % TODO
      
      
      % | A.CAST t e -> conv t (exp_type e) (f e)
      G,Sig |- ail_e : ctype'
      G,Sig |- ail_e ~> core_s
      --------------------------------------------------------------- :: cast
      G,Sig |- (ctype)ail_e ~> let a = core_s in conv{ctype'\ctype} a
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.ADD) e1 e2 ->
      %     if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
      %       conv_exp e1 >>= fun (a1, m1) ->
      %       conv_exp e2 >>= fun (a2, m2) ->
      %       let sum = C.plus a1 a2 in
      %       if T.is_signed_integer(exp_type exp) then
      %         let c = overflow (exp_type exp) sum in
      %         E.return (sum, m1 -&- m2 +& c)
      %       else
      %         Tc.conv_int (exp_type exp) (C.plus a1 a2) >>= fun (a, c) ->
      %         E.return (a, m1 -&- m2 +& c)
      %     else
      %       (* Pointer arithmetic. *)
      %       f e1 >>= fun (a1, m1) ->
      %       f e2 >>= fun (a2, m2) ->
      %       if T.is_pointer (exp_type e1) then
      %         let size = Tc.size (T.base_of_pointer (exp_type e1)) in
      %         let a = C.offset a1 a2 size in
      %         Action.same a1 a >>= fun same ->
      %         E.return (a, (m1 -&- m2) -@> same)
      %       else
      %         let size = Tc.size (T.base_of_pointer (exp_type e2)) in
      %         let a = C.offset a2 a1 size in
      %         Action.same a a1 >>= fun same ->
      %         E.return (a, (m1 -&- m2) -@> same)
      -------------------------------- :: add
      G,Sig |- ail_e1 + ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.SUB) e1 e2 ->
      %     if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
      %       conv_exp e1 >>= fun (a1, m1) ->
      %       conv_exp e2 >>= fun (a2, m2) ->
      %       let diff = C.minus a1 a2 in
      %       if T.is_signed_integer (exp_type exp) then
      %         let c = overflow (exp_type exp) diff in
      %         E.return (diff, (m1 -&- m2) +& c)
      %       else
      %         Tc.conv_int (exp_type exp) (C.minus a1 a2) >>= fun (a, c) ->
      %         E.return (a, m1 -&- m2 +& c)
      %     else (*if T.is_integer (exp_type e2) then*)
      %       (* Pointer arithmetic. *)
      %       f e1 >>= fun (a1, m1) ->
      %       f e2 >>= fun (a2, m2) ->
      %       let size = Tc.size (T.base_of_pointer (exp_type e1)) in
      %       let a = C.offset a1 (C.minus C.zero a2) size in
      %       Action.same a1 a >>= fun same ->
      %       E.return (a, (m1 -&- m2) -@> same)
      -------------------------------- :: sub
      G,Sig |- ail_e1 - ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.MOD) e1 e2 ->
      %     conv_exp e1 >>= fun (a1, m1) ->
      %     conv_exp e2 >>= fun (a2, m2) ->
      %     let modulo = C.modulo a1 a2 in
      %     let div_zero = C.implies (C.eq a2 C.zero) C.undef in
      %     if T.is_signed_integer(exp_type exp) then
      %       let c = overflow (exp_type exp) (C.div a1 a2) in
      %       E.return (modulo, (m1 -&- m2) +& div_zero +& c)
      %     else
      %       Tc.conv_int (exp_type exp) modulo >>= fun (a, c) ->
      %       E.return (a, (m1 -&- m2 +& c) +& div_zero)
      -------------------------------- :: mod
      G,Sig |- ail_e1 % ail_e2 ~> skip
      % TODO
      
      
      % let conv_int_type i const = do
      %   a <- C.fresh
      %   let constr = match i with
      %                  | A.BOOL            -> C.case (C.eq C.zero const) (C.eq a C.zero) (C.eq a C.one)
      %                  | A.UNSIGNED _ as i -> C.eq a (C.modulo const (max i))
      %                  | A.SIGNED   _ as i -> C.case (in_range_int i const) (C.eq a const) (C.eq a (conv_impl i const))
      %                end in
      %   let conv = C.conv_int (min_range_of i) constr const in
      %   Symbol_state.return (a, conv)
      % 
      % let conv_int t const =
      %   match t with
      %     | A.BASIC _ (A.INTEGER i) -> conv_int_type i const
      %     | _                       -> Symbol_state.return (const, C.tt)
      %   end
      % 
      % let conv_int_lifted t (a, m) = do
      %   (v, c) <- conv_int t a
      %   E.return (v, m +& c)
      % 
      % let conv_exp e = f e >>= conv_int_lifted (exp_type exp)
      % 
      % --------------------------------------------------------------------------------------------
      % 
      % | A.BINARY (Cabs.ARITHMETIC Cabs.MUL) e1 e2 -> do
      %     (a1, m1) <- conv_exp e1
      %     (a2, m2) <- conv_exp e2
      %     let mult = C.mult a1 a2
      %     if T.is_signed_integer(exp_type exp) then
      %       let c = overflow (exp_type exp) mult in
      %       E.return (mult, (m1 -&- m2) +& c)
      %     else
      %       Tc.conv_int (exp_type exp) mult >>= fun (a, c) ->
      %       E.return (a, (m1 -&- m2 +& c))
      G,Sig |- ail_e1 : ctype
      is_signed_integer(ctype)
%      ctype = qualifiers signed integer_base_type
      G,Sig |- ail_e1 ~> core_s1
      G,Sig |- ail_e2 ~> core_s2
      ---------------------------------------------------------------- :: mul_TODO_signed_integer
      G,Sig |- ail_e1 * ail_e2 ~> [multiline] let (a1, a2) = core_s1 || core_s2 in [newline] let a3 = a1 * a2 in if min{ctype} < a3 \/ a3 < max{ctype} then skip else undef
%                                  undef_guard overflow ctype (a1 * 
%                                  let a3       = a1 * a2            in 
% TODO
      
      G,Sig |- ail_e1 ~> core_s1
      G,Sig |- ail_e2 ~> core_s2
      ---------------------------------------------------------------- :: mul_TODO
      G,Sig |- ail_e1 * ail_e2 ~> let (a1, a2) = core_s1 || core_s2 in skip
%                                  let a3       = a1 * a2            in 
      % TODO
      
      
      % | A.BINARY Cabs.COMMA e1 e2 ->
      %     f e1 >>= fun (_,  m1) ->
      %     f e2 >>= fun (a2, m2) ->
      %     E.return (a2, m1 -&> m2)
      G,Sig |- ail_e1 ~> core_s1
      G,Sig |- ail_e2 ~> core_s2
      ----------------------------------------------------- :: comma
      G,Sig |- ail_e1, ail_e2 ~> let a = core_s1 in core_s2
      % CHECK
      
      
      % | A.BINARY Cabs.OR e1 e2 ->
      %     f e1 >>= fun (a1, m1) ->
      %     f e2 >>= fun (a2, m2) ->
      %     C.fresh >>= fun a ->
      %     let first_only = C.conj (C.neq a1 C.zero) (C.eq a C.one) in
      %     let both = C.conj
      %       (C.eq a1 C.zero)
      %       (C.case (C.eq a2 C.zero) (C.eq a C.zero) (C.eq a C.one)) in
      %     E.return (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both))
      --------------------------------- :: or_TODO
      G,Sig |- ail_e1 || ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.AND e1 e2 ->
      %     f e1 >>= fun (a1, m1) ->
      %     f e2 >>= fun (a2, m2) ->
      %     C.fresh >>= fun a ->
      %     let first_only = C.conj (C.eq a1 C.zero) (C.eq a C.zero) in
      %     let both = C.conj
      %       (C.neq a1 C.zero)
      %       (C.case (C.neq a2 C.zero) (C.eq a C.one) (C.eq a C.zero)) in
      %     E.return (a, (m1 +& first_only) -/- ((m1 -&> m2) +& both))
      --------------------------------- :: and_TODO
      G,Sig |- ail_e1 && ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.SHL) e1 e2 ->
      %     conv_exp e1 >>= fun (a1, m1) ->
      %     conv_int (T.promote (exp_type e1)) e2 >>= fun (a2, m2) ->
      %     let shifted = C.mult a1 (C.pow a2) in
      %     if T.is_signed_integer (exp_type exp) then
      %       let not_repr = C.neg (Tc.in_range (exp_type exp) shifted) in
      %       let neg = C.lt shifted C.zero in
      %       let c = C.implies (C.disj neg not_repr) C.undef in
      %       E.return (shifted, (m1 -&- m2) +& c)
      %     else
      %       Tc.conv_int (exp_type exp) shifted >>= fun (a, c) ->
      %       E.return (a, m1 -&- m2 +& c)
      -------------------------------- :: shl_TODO
      G,Sig |- ail_e1 << ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.SHR) e1 e2 ->
      %     conv_exp e1 >>= fun (a1, m1) ->
      %     conv_int (T.promote (exp_type e1)) e2 >>= fun (a2, m2) ->
      %     let shifted = C.div a1 (C.pow a2) in
      %     if T.is_signed_integer (exp_type exp) then
      %       C.fresh >>= fun a ->
      %       let negative = C.lt shifted C.zero in
      %       let c = C.case negative
      %         (C.eq a (C.fn Symbol.shift_r [shifted]))
      %         (C.eq a shifted) in
      %       E.return (shifted, (m1 -&- m2) +& c)
      %     else
      %       E.return (shifted, m1 -&- m2)
      --------------------------------- :: shr_TODO
      G,Sig |- ail_e1 >> ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.EQ e1 e2 ->
      %     if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
      %       let t = usual_arithmetic e1 e2 in
      %       conv_int t e1 >>= fun (a1, m1) ->
      %       conv_int t e2 >>= fun (a2, m2) ->
      %       C.fresh       >>= fun a        ->
      %       let c = C.case (C.eq a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       E.return (a, (m1 -&- m2) +& c)
      %     else if T.is_pointer (exp_type e1) && T.is_pointer (exp_type e2) then
      %       (*TODO*) E.return (C.one, Me.null)
      %     else if Typing.is_null_pointer_constant e1 then
      %       (*TODO*) E.return (C.one, Me.null)
      %     else (*TODO*) E.return (C.one, Me.null)
      --------------------------------- :: eq_TODO
      G,Sig |- ail_e1 == ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.NE e1 e2 ->
      %     if T.is_real (exp_type e1) then
      %       let t = usual_arithmetic e1 e2 in
      %       conv_int t e1 >>= fun (a1, m1) ->
      %       conv_int t e2 >>= fun (a2, m2) ->
      %       C.fresh       >>= fun a        ->
      %       let c = C.case (C.neg (C.eq a1 a2)) (C.eq a C.one) (C.eq a C.zero) in
      %       E.return (a, (m1 -&- m2) +& c)
      %     else (*TODO*) E.return (C.one, Me.null)
      %       (* Pointer comparison. *)
      --------------------------------- :: ne_TODO
      G,Sig |- ail_e1 != ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.LT e1 e2 ->
      %     if T.is_real (exp_type e1) then
      %       let t = usual_arithmetic e1 e2 in
      %       conv_int t e1 >>= fun (a1, m1) ->
      %       conv_int t e2 >>= fun (a2, m2) ->
      %       C.fresh       >>= fun a        ->
      %       let c = C.case (C.lt a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       E.return (a, (m1 -&- m2) +& c)
      %     else (*TODO*) E.return (C.one, Me.null)
      %       (* Pointer comparison. *)
      --------------------------------- :: lt_TODO
      G,Sig |- ail_e1 < ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.LE e1 e2 ->
      %     if T.is_real (exp_type e1) then
      %       let t = usual_arithmetic e1 e2 in
      %       conv_int t e1 >>= fun (a1, m1) ->
      %       conv_int t e2 >>= fun (a2, m2) ->
      %       C.fresh       >>= fun a        ->
      %       let c = C.case (C.le a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       E.return (a, (m1 -&- m2) +& c)
      %     else (*TODO*) E.return (C.one, Me.null)
      %       (* Pointer comparison. *)
      --------------------------------- :: le_TODO
      G,Sig |- ail_e1 <= ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.GT e1 e2 ->
      %     if T.is_real (exp_type e1) then
      %       let t = usual_arithmetic e1 e2 in
      %       conv_int t e1 >>= fun (a1, m1) ->
      %       conv_int t e2 >>= fun (a2, m2) ->
      %       C.fresh       >>= fun a        ->
      %       let c = C.case (C.gt a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       E.return (a, (m1 -&- m2) +& c)
      %     else
      %       (* Pointer comparison. *)
      %       (* TODO Comparing two pointers to different object is
      %          undefined unless ... *)
      %       f e1    >>= fun (a1, m1) ->
      %       f e2    >>= fun (a2, m2) ->
      %       C.fresh >>= fun a        ->
      %       let c = C.case (C.gt a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       Action.same a1 a2 >>= fun same ->
      %       E.return (a, (m1 -&- m2) +& c -@> same)
      --------------------------------- :: gt_TODO
      G,Sig |- ail_e1 > ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY Cabs.GE e1 e2 ->
      %     if T.is_arithmetic (exp_type e1) then
      %       let t = usual_arithmetic e1 e2 in
      %       conv_int t e1 >>= fun (a1, m1) ->
      %       conv_int t e2 >>= fun (a2, m2) ->
      %       C.fresh       >>= fun a        ->
      %       let c = C.case (C.ge a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       E.return (a, (m1 -&- m2) +& c)
      %     else
      %       (* Pointer comparison. *)
      %       (* TODO Comparing two pointers to different object is
      %          undefined unless ... *)
      %       f e1	>>= fun (a1, m1) ->
      %       f e2	>>= fun (a2, m2) ->
      %       C.fresh >>= fun a        ->
      %       let c = C.case (C.ge a1 a2) (C.eq a C.one) (C.eq a C.zero) in
      %       Action.same a1 a2 >>= fun same ->
      %       E.return (a, (m1 -&- m2) +& c -@> same)
      --------------------------------- :: ge_TODO
      G,Sig |- ail_e1 >= ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.BAND) e1 e2 ->
      %     conv_exp e1 >>= fun (a1, m1) ->
      %     conv_exp e2 >>= fun (a2, m2) ->
      %     C.fresh     >>= fun a        ->
      %     E.return (a, (m1 -&- m2) +& (C.eq a (C.bit_and a1 a2)))
      --------------------------------- :: band_TODO
      G,Sig |- ail_e1 & ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.BOR) e1 e2 ->
      %     conv_exp e1 >>= fun (a1, m1) ->
      %     conv_exp e2 >>= fun (a2, m2) ->
      %     C.fresh     >>= fun a        ->
      %     E.return (a, (m1 -&- m2) +& (C.eq a (C.bit_or a1 a2)))
      --------------------------------- :: bor_TODO
      G,Sig |- ail_e1 | ail_e2 ~> skip
      % TODO
      
      
      % | A.BINARY (Cabs.ARITHMETIC Cabs.XOR) e1 e2 -> do
      %     (a1, m1) <- conv_exp e1
      %     (a2, m2) <- conv_exp e2
      %     a        <- C.fresh
      %     E.return (a, (m1 -&- m2) +& (C.eq a (C.bit_xor a1 a2)))
      --------------------------------- :: xor_TODO
      G,Sig |- ail_e1 ^ ail_e2 ~> skip
      % TODO
      
      
      % | A.ASSIGN None e1 e2 ->
      %     f_lvalue e1 >>= fun (a1, m1) ->
      %     f        e2 >>= fun (a2, m2) ->
      %     Tc.conv (exp_type e1) (exp_type e2) a2 >>= fun (a, c) ->
      %     Action.store (lvalue_type e1) a1 a >>= fun write ->
      %     E.return (a, Me.conj_sb (m1 -&- m2 +& c) (Me.add_side_effect write Me.unit))
      --------------------------------- :: simple_assign_TODO
      G,Sig |- ail_e1 = ail_e2 ~> skip
      % TODO
      
      
      % | A.CONDITIONAL e1 e2 e3 ->
      %     if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
      %       f e1        >>= fun (a1, m1) ->
      %       conv_exp e2 >>= fun (a2, m2) ->
      %       conv_exp e3 >>= fun (a3, m3) ->
      %       C.fresh     >>= fun a        ->
      %       let pos = m2 +& (C.eq a a2) +& (C.eq  a1 C.zero) in
      %       let neg = m3 +& (C.eq a a3) +& (C.neq a1 C.zero) in
      %       E.return (a, m1 -&> (pos -/- neg))
      %     else (*TODO*) E.return (C.one, Me.null)
      G,sig |- ail_e1 : ctype1
      G,sig |- ail_e2 : ctype2
      is_arithmetic(ctype1)
      is_arithmetic(ctype2)
      G,Sig |- ail_e1 ~> core_s1
      ----------------------------------------- :: cond_arith_TODO
      G,Sig |- ail_e1 ? ail_e2 : ail_e3 ~> skip
      % TODO
      
      ----------------------------------------- :: cond_TODO
      G,Sig |- ail_e1 ? ail_e2 : ail_e3 ~> skip
      % TODO
      
      
      % | A.CALL e es ->
      %     match is_function_id file e with
      %     | Some (fid, ids, s) ->
      %         let depth = Pmap.find fid b in
      %         if depth = 0 then
      %           C.fresh >>= fun a ->
      %           E.return (a, Me.null)
      %         else
      %           update_env env ids >>= fun env' ->
      %           let b' = Pmap.add fid (depth - 1) b in
      %           let args =
      %             let f id e = (Pmap.find id env', lookup_type id, e) in
      %             List.map2 f ids es in
      %           let f_create (l, t, e) m' =
      %             conv (T.unqualify t) (exp_type e) (f e) >>= fun (a, m) ->
      %             Action.create   t l                     >>= fun create ->
      %             Action.fn_store t l a                   >>= fun store  ->
      %             E.return ((m' -&- m) +@ create -@> store) in
      %           let f_kill (l, _, _) m =
      %             Action.kill l >>= fun kill ->
      %             E.return (m +@ kill) in
      %           E.foldlM f_create args Me.unit     >>= fun m_create ->
      %           E.foldlM f_kill   args Me.unit     >>= fun m_kill   ->
      %           C.fresh                            >>= fun a        ->
      %           reduce_stmt n b' env' file fid a s >>= fun ml       ->
      %           Action.call                        >>= fun call     ->
      %           let m_body = Ms.exit_function call ml in
      %           E.return (a, m_create -&> m_body -&> m_kill)
      %     | None ->
      %         (* Function pointer. *)
      %         C.fresh >>= fun a ->
      %         E.return (a, Me.null)
      %     end
      ------------------------------------------ :: call_TODO
      G,Sig |- ail_e(ail_e1, .., ail_ek) ~> skip
      % TODO
      
      
      % | A.ALIGNOF t -> E.return (Tc.align t, Me.unit)
      ----------------------------------------- :: alignof
      G,Sig |- alignof(ctype) ~> alignof{ctype}
      
      
      % | A.SIZEOF t -> E.return (Tc.size  t, Me.unit)
      --------------------------------------- :: sizeof_ty
      G,Sig |- sizeof(ctype) ~> sizeof{ctype}
      
      
      % | _ ->
      %     if T.is_lvalue (Annotate.type_of exp) then
      %       f_lvalue exp                      >>= fun (a, m) ->
      %       C.fresh                           >>= fun v      ->
      %       Action.load (lvalue_type exp) a v >>= fun load   ->
      %       E.return (v, m -@> load)
      %     else
      %       C.fresh >>= fun a ->
      %       E.return (a, Me.null)


% NOT IN reduction.lem %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      ------------------------------------------ :: sizeof_expr_TODO
      G,Sig |- sizeof(ail_e) ~> skip
      % TODO
      
      
      % Constants other then integer constants
      
      ------------------------------------------ :: memberof_TODO
      G,Sig |- ail_e.id ~> skip
      % TODO
      
      
      ------------------------------------------ :: memberofptr_TODO
      G,Sig |- ail_e->id ~> skip
      % TODO
      
      % Compound assigments
      
      % Division
      
      % bitwise negation
      
      % indirection (seems to be in [reduce_lvalue])
      
      % unary + and -