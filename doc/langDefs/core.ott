grammar
core_eop {{ tex \bullet }} :: 'core_eop' ::= {{ com arithmetic operators }}
  | + :: :: ADD    {{ tex \texttt{+}  }}
  | - :: :: SUB    {{ tex \texttt{-}  }}
  | * :: :: MULT   {{ tex \texttt{*}  }}
  | / :: :: DIV    {{ tex \texttt{/}  }}
  | % :: :: MODULO {{ tex \texttt{\%} }}

core_e {{ tex e }} :: 'core_e' ::= {{ com pure expressions }}
  | n                         :: :: CONSTANT 
  | a                         :: :: SYMBOL   
  | core_e1 core_eop core_e2  :: :: EOP      
  | - core_e                   :: :: MINUS    {{ com unary negation                                                   }}
  | if B then E1 else E2      :: :: IF	     {{ com TODO: document }}
  | max { ty }                :: :: MAX      {{ com maximum value representable with the type [[ty]]                 }}
                                             {{ tex [[max]]_{[[ty]]}                                                 }}
  | min { ty }                :: :: MIN      {{ com minimum value representable with the type [[ty]]                 }}
                                             {{ tex [[min]]_{[[ty]]}                                                 }}
  | sizeof { ty }             :: :: SIZEOF   {{ com size (in bytes) of [[ty]]                                        }}
                                             {{ tex [[sizeof]]_{[[ty]]}                                              }}
  | alignof { ty }            :: :: ALIGNOF  {{ com alignment requirement of [[ty]]                                  }}
                                             {{ tex [[alignof]]_{[[ty]]}                                             }}
  | offsetof { ty }           :: :: OFFSETOF {{ com {\color{orange}TODO }                                            }}
                                             {{ tex [[offsetof]]_{[[ty]]}                                            }}
  | shift a core_e            :: :: SHIFT    {{ com TODO ([[a]] is of type addr)                                     }}
  | conv { ty1 \ ty2 } core_e :: :: CONV     {{ com convert the value of [[core_e]] from the type [[ty1]] to [[ty2]] }}
                                             {{ tex [[conv]]_{[[ty1]] \rightarrow [[ty2]]} \ [[core_e]]              }}



core_bop {{ tex \circ }} :: 'core_bop' ::= {{ com relational operators }}
  | = :: :: EQ {{ tex \texttt{=} }}
  | < :: :: LT {{ tex \texttt{<} }}


core_connective {{ tex \diamond }} :: 'core_connective' ::= {{ com logical connectives }}
  | /\ :: :: AND {{ tex \wedge }}
  | \/ :: :: OR  {{ tex \vee }}

core_b {{ tex b }} :: 'core_b' ::= {{ com boolean tests }}
  | true                       :: :: TRUE
  | false                      :: :: FALSE
  | core_e1 bop core_e2        :: :: BEXPR
  | core_b1 connective core_b2 :: :: BOP
  | ~ core_b                   :: :: NEG {{ tex \neg [[b]] }}

p :: '' ::= {{ com patterns }}
  | a                :: :: ATOM  (+ b = a +)
  | ( p1 , .. , pk ) :: :: TUPLE (+ b = b(p1 .. pk) +)

core_s {{ tex S }} :: 'core_s' ::= {{ com statements }}
  | skip                                       :: :: SKIP                            
  | undef                                      :: :: UNDEF       {{ com signal an undefined behaviour                                        }}
  | error                                      :: :: ERROR       {{ com signal that detection of implementation-defined static error         }}
  | let p1 = core_e1 .. pk = core_ek in core_s :: :: LET (+ bind b(p1 .. pk) in core_s +)
  | core_s1 ; core_s2    	               :: :: SEQ         {{ com the actions of [[core_s1]] are sequenced-before those of [[core_s2]] }}
  | if core_b then core_s1 else core_s2        :: :: IF                              
%  | core_s1 + core_s2                         :: :: PLUS        {{ com non-deterministic choice                                             }}
  | core_s1 || core_s2                         :: :: PAR         {{ com the actions of [[S1]] are unsequenced with those of [[core_s2]]      }}
  | create { ty }                              :: :: CREATE      {{ com create an object of effective type [[ty]]                            }}
                                                                 {{ tex [[create]]_{[[ty]]}                                                  }}
  | alloc a                                    :: :: ALLOC       {{ com create an object (without effective type)                            }}
  | kill a                                     :: :: KILL        {{ com destroy an object                                                    }}
  | store { ty } a1 a2                         :: :: STORE       {{ com store the value [[a2]] in the object [[a1]]                          }}
                                                                 {{ tex [[store]]_{[[ty]]} \ [[a1]] \ [[a2]]                                 }}
  | load { ty } a                              :: :: LOAD        {{ com load the value stored in the object [[a]]                            }}
                                                                 {{ tex [[load]]_{[[ty]]} \ [[a]]                                            }}
  | same a1 a2                                 :: :: SAME        {{ com  TODO: document                                                      }} 
% (*  | FUN of 'a * 'a list * 'a statement *)
  | call a ( a1 .. ak )                        :: :: CALL        {{ com these are indeterminately sequenced with their context               }}
  | [ core_s ]                                 :: :: ATOMICBLOCK {{ com atomic blocks                                                        }}


% storage_duration :: '' ::=
%   {{ com storage duration (6.2.4\#1) }}
%   | static    :: :: STATIC
%   | thread    :: :: THREAD
%   | automatic :: :: AUTOMATIC
%   | allocated :: :: ALLOCATED {{ com TODO: look at (7.22.3) }}


% integer_base_type :: '' ::=
%   {{ com standard signed integer types (6.2.5\#4) }}
%   | ichar     :: :: ICHAR     {{ com \textbf{signed/unsigned char} in C }}
%   | short     :: :: SHORT     {{ com \textbf{short int} in C }}
%   | int       :: :: INT       
%   | long      :: :: LONG      {{ com \textbf{long int} in C }}
%   | long long :: :: LONG_LONG {{ com \textbf{long long int} in C }}

% integer_type :: '' ::=
%   {{ com integer types (6.2.5\#17), TODO: add enumerated types }}
%   | bool                        :: :: BOOL     {{ com \textbf{\_Bool} in C }}
%   | signed integer_base_type    :: :: SIGNED
%   | unsigned integer_base_type  :: :: UNSIGNED

% basic_type :: '' ::=
%   {{ com basic types (6.2.5\#14) }}
%   | char         :: :: CHAR
%   | integer_type :: :: INTEGER

% qualifier :: '' ::=
%   {{ com type qualifiers (6.7.3) }}
%   | const    :: :: CONST
%   | restrict :: :: RESTRICT
%   | volatile :: :: VOLATILE
%   | atomic   :: :: ATOMIC   {{ com \textbf{\_Atomic} in C }}

% qualifiers :: '' ::=
%   | qualifier1 .. qualifierk :: :: Qualifiers

% ty {{ tex \tau }} :: '' ::=
%   {{ com TODO }}
%   | qualifiers void               ::   :: VOID
%   | qualifiers basic_type         ::   :: BASIC
%   | ty [ n ]                      ::   :: ARRAY
%   | qualifiers * ty               ::   :: POINTER
%   | ty ( ty1 , .. , tyk )         ::   :: FUNCTION
%   | promote ( ty )                ::   :: PROMOTE {{ com TODO(move?) integer promotion }}
%   | usualArithmetic ( ty1 , ty2 ) ::   :: USUAL_ARITHMETIC {{ com TODO(move?) }}
% %  | struct 
% %  | union
% %  | union


coreTy, T :: 'cTy_' ::=
  | unit             :: :: UNIT
  | val              :: :: VAL
  | addr             :: :: ADDR
  | ( T1 , .. , Tk ) :: :: TUPLE



  G {{ tex \Gamma }} :: 'G_' ::=
    | empty     :: :: base {{ tex \emptyset }}
    | G , a : T :: :: ctor



terminals :: 'terminals_' ::=
  | |e- :: :: eturnstile  {{ tex \vdash_E }}
  | |b- :: :: bturnstile  {{ tex \vdash_B }}
  | |s- :: :: sturnstile  {{ tex \vdash_S }}
  | _in  :: :: _in          {{ tex \in }}


  core_formula :: 'core_formula_' ::=          
    | ( a , T ) _in G :: :: xTG 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
  Jtype :: '' ::=
    
    defn G |e- E : T :: :: coreETyping :: coreETyping_ by
      ------------- :: const
      G |e- n : val
      
      (a,T) _in G
      ----------- :: symbol
      G |e- a : T
      
      G |e- E1 : val
      G |e- E2 : val
      --------------------- :: eop
      G |e- E1 eop E2 : val
      
      G |e- E : val
      -------------- :: minus
      G |e- -E : val
      
      ------------------- :: max
      G |e- max{ty} : val
      
      ------------------- :: min
      G |e- min{ty} : val
      
      ---------------------- :: sizeof
      G |e- sizeof{ty} : val
      
      ----------------------- :: alignof
      G |e- alignof{ty} : val
      
      ------------------------ :: offsetof
      G |e- offsetof{ty} : val
      
             (a, val) _in G
      --------------------------- :: conv
      G |e- conv{ty1/ty2} a : val
      
      
    defn G |b- B : T :: :: coreBTyping :: coreBTyping_ by
      ---------------- :: true
      G |b- true : val
      
      ----------------- :: false
      G |b- false : val
      
      G |e- E1 : val
      G |e- E2 : val
      --------------------- :: bexpr
      G |b- E1 bop E2 : val
      
      G |b- B1 : val
      G |b- B2 : val
      ---------------------------- :: bop
      G |b- B1 connective B2 : val
      
      G |b- B : val
      -------------- :: neg
      G |b- ~B : val
      
      
    defn G |s- S : coreTy :: :: coreSTyping :: coreSTyping_ by
      
      ----------------- :: skip
      G |s- skip : unit
      
      ----------------- :: fail
      G |s- fail : unit
      
      G |e- E : T
      ----------- :: expr
      G |s- E : T
      
      % let
      
      G |b- B : val
      G |s- S1 : T
      G |s- S2 : T
      ------------------------------ :: if
      G |s- if B then S1 else S2 : T
      
      G |s- S1 : T
      G |s- S2 : T
      ----------------- :: plus
      G |s- S1 + S2 : T
      
      G |s- S1 : T1
      G |s- S2 : T2
      ------------------------ :: par
      G |s- S1 || S2 : (T1,T2)
      
      ----------------------- :: create
      G |s- create{ty} : addr
      
          (a,val) _in G
      -------------------- :: alloc
      G |s- alloc a : addr
      
         (a,addr) _in G
      ------------------- :: kill
      G |s- kill a : unit
      
      (a1,addr) _in G
      (a2,val) _in G
      ---------------------------- :: store
      G |s- store{ty} a1 a2 : unit
      
          (a,addr) _in G
      ---------------------- :: load
      G |s- load{ty} a : val
      
      (a1,addr) _in G
      (a2,addr) _in G
      ----------------------- :: same
      G |s- same a1 a2 : unit
      
      % FUN
      % CALL
