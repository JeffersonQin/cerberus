indexvar k, j ::=  {{ com index variable }}

metavar n {{ tex \bar{n} }} ::=  {{ com integer constant $n \in \Z$ }}
% metavar id ::=  {{ com identifier }}
metavar a {{ tex \alpha }}  ::=  {{ com symbolic name }}

grammar
eop {{ tex \bullet }} :: '' ::= {{ com arithmetic operators }}
  | + :: :: ADD
  | - :: :: SUB
  | * :: :: MULT
  | / :: :: DIV
  | % :: :: MODULO

E :: '' ::= {{ com pure expressions }}
  | n                    :: :: CONSTANT 
  | a                    :: :: SYMBOL   
  | E1 eop E2            :: :: EOP      
  | - E                  :: :: MINUS    {{ com unary negation                                              }}
  | max { ty }           :: :: MAX      {{ com maximum value representable with the type [[ty]]            }}
                                        {{ tex [[max]]_{[[ty]]}                                            }}
  | min { ty }           :: :: MIN      {{ com minimum value representable with the type [[ty]]            }}
                                        {{ tex [[min]]_{[[ty]]}                                            }}
  | sizeof { ty }        :: :: SIZEOF   {{ com size (in bytes) of [[ty]]                                   }}
                                        {{ tex [[sizeof]]_{[[ty]]}                                         }}
  | alignof { ty }       :: :: ALIGNOF  {{ com alignment requirement of [[ty]]                             }}
                                        {{ tex [[alignof]]_{[[ty]]}                                        }}
  | offsetof { ty }      :: :: OFFSETOF {{ com {\color{orange}TODO }                                       }}
                                        {{ tex [[offsetof]]_{[[ty]]}                                       }}
  | conv { ty1 \ ty2 } E :: :: CONV     {{ com convert the value of [[E]] from the type [[ty1]] to [[ty2]] }}
                                        {{ tex [[conv]]_{[[ty1]] \rightarrow [[ty2]]} \ [[E]]              }}



bop {{ tex \circ }} :: '' ::= {{ com relational operators }}
  | = :: :: EQ
  | < :: :: LT


connective {{ tex \diamond }} :: '' ::= {{ com logical connectives }}
  | /\ :: :: AND {{ tex \wedge }}
  | \/ :: :: OR  {{ tex \vee }}

B :: '' ::= {{ com boolean tests }}
  | true             :: :: TRUE
  | false            :: :: FALSE
  | E1 bop E2        :: :: BEXPR
  | B1 connective B2 :: :: BOP
  | ~ B              :: :: NEG {{ tex \neg [[B]] }}

p :: '' ::= {{ com patterns }}
  | a                :: :: ATOM  (+ b = a +)
  | ( p1 , .. , pk ) :: :: TUPLE (+ b = b(p1 .. pk) +)

S :: '' ::= {{ com statements }}
  | skip                 :: :: SKIP                      
  | fail                 :: :: FAIL                      {{ com signal an undefined behaviour }}
  | E                    :: :: EXPR                      
  | let p = S1 in S2     :: :: LET (+ bind b(p) in S2 +) {{ com the actions of [[S1]] are sequenced-before those of [[S2]] }}
  | if B then S1 else S2 :: :: IF                        
  | S1 + S2              :: :: PLUS                      {{ com non-deterministic choice                                   }}
  | S1 || S2             :: :: PAR                       {{ com the actions of [[S1]] are unsequenced with those of [[S2]] }}
  | create { ty }        :: :: CREATE                    {{ com create an object of effective type [[ty]]                  }}
                                                         {{ tex [[create]]_{[[ty]]}                                        }}
  | alloc a              :: :: ALLOC                     {{ com create an object (without effective type)                  }}
  | kill a               :: :: KILL                      {{ com destroy an object                                          }}
  | store { ty } a1 a2   :: :: STORE                     {{ com store the value [[a2]] in the object [[a1]]                }}
                                                         {{ tex [[store]]_{[[ty]]} \ [[a1]] \ [[a2]]                       }}
  | load { ty } a        :: :: LOAD                      {{ com load the value stored in the object [[a]]                  }}
                                                         {{ tex [[load]]_{[[ty]]} \ [[a]]                                  }}
  | same a1 a2           :: :: SAME                      {{ com  }} 
% (*  | FUN of 'a * 'a list * 'a statement *)
  | call a ( a1 .. ak )  :: :: CALL                      {{ com  }} {{ com these are indeterminately sequenced }}
  | incr a               :: :: INCR                      {{ com  }} {{ com TODO: this may be temporary }}
  | decr a               :: :: DECR                      {{ com  }} {{ com TODO: this may be temporary }}

storage_duration :: '' ::=
  {{ com storage duration (6.2.4\#1) }}
  | static    :: :: STATIC
  | thread    :: :: THREAD
  | automatic :: :: AUTOMATIC
  | allocated :: :: ALLOCATED {{ com TODO: look at (7.22.3) }}


integer_base_type :: '' ::=
  {{ com standard signed integer types (6.2.5\#4) }}
  | ichar     :: :: ICHAR     {{ com \textbf{signed/unsigned char} in C }}
  | short     :: :: SHORT     {{ com \textbf{short int} in C }}
  | int       :: :: INT       
  | long      :: :: LONG      {{ com \textbf{long int} in C }}
  | long long :: :: LONG_LONG {{ com \textbf{long long int} in C }}

integer_type :: '' ::=
  {{ com integer types (6.2.5\#17), TODO: add enumerated types }}
  | bool                        :: :: BOOL     {{ com \textbf{\_Bool} in C }}
  | signed integer_base_type    :: :: SIGNED
  | unsigned integer_base_type  :: :: UNSIGNED

basic_type :: '' ::=
  {{ com basic types (6.2.5\#14) }}
  | char         :: :: CHAR
  | integer_type :: :: INTEGER

qualifier :: '' ::=
  {{ com type qualifiers (6.7.3) }}
  | const    :: :: CONST
  | restrict :: :: RESTRICT
  | volatile :: :: VOLATILE
  | atomic   :: :: ATOMIC   {{ com \textbf{\_Atomic} in C }}

qualifiers :: '' ::=
  | qualifier1 .. qualifierk :: :: Qualifiers

ty {{ tex \tau }} :: '' ::=
  {{ com TODO }}
  | qualifiers void               ::   :: VOID
  | qualifiers basic_type         ::   :: BASIC
  | ty [ n ]                      ::   :: ARRAY
  | qualifiers * ty               ::   :: POINTER
  | ty ( ty1 , .. , tyk )         ::   :: FUNCTION
  | promote ( ty )                ::   :: PROMOTE {{ com TODO(move?) integer promotion }}
  | usualArithmetic ( ty1 , ty2 ) ::   :: USUAL_ARITHMETIC {{ com TODO(move?) }}
%  | struct 
%  | union
%  | union


coreTy, T :: 'cTy_' ::=
  | unit             :: :: UNIT
  | val              :: :: VAL
  | addr             :: :: ADDR
  | ( T1 , .. , Tk ) :: :: TUPLE



  G {{ tex \Gamma }} :: 'G_' ::=
    | empty     :: :: base {{ tex \emptyset }}
    | G , a : T :: :: ctor



terminals :: 'terminals_' ::=
  | |e- :: :: eturnstile  {{ tex \vdash_E }}
  | |b- :: :: bturnstile  {{ tex \vdash_B }}
  | |s- :: :: sturnstile  {{ tex \vdash_S }}
  | _in  :: :: _in          {{ tex \in }}


  formula :: 'formula_' ::=          
    | judgement       :: :: judgement
    | ( a , T ) _in G :: :: xTG 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
  Jtype :: '' ::=
    
    defn G |e- E : T :: :: coreETyping :: coreETyping_ by
      ------------- :: const
      G |e- n : val
      
      (a,T) _in G
      ----------- :: symbol
      G |e- a : T
      
      G |e- E1 : val
      G |e- E2 : val
      --------------------- :: eop
      G |e- E1 eop E2 : val
      
      G |e- E : val
      -------------- :: minus
      G |e- -E : val
      
      ------------------- :: max
      G |e- max{ty} : val
      
      ------------------- :: min
      G |e- min{ty} : val
      
      ---------------------- :: sizeof
      G |e- sizeof{ty} : val
      
      ----------------------- :: alignof
      G |e- alignof{ty} : val
      
      ------------------------ :: offsetof
      G |e- offsetof{ty} : val
      
             (a, val) _in G
      --------------------------- :: conv
      G |e- conv{ty1/ty2} a : val
      
      
    defn G |b- B : T :: :: coreBTyping :: coreBTyping_ by
      ---------------- :: true
      G |b- true : val
      
      ----------------- :: false
      G |b- false : val
      
      G |e- E1 : val
      G |e- E2 : val
      --------------------- :: bexpr
      G |b- E1 bop E2 : val
      
      G |b- B1 : val
      G |b- B2 : val
      ---------------------------- :: bop
      G |b- B1 connective B2 : val
      
      G |b- B : val
      -------------- :: neg
      G |b- ~B : val
      
      
    defn G |s- S : coreTy :: :: coreSTyping :: coreSTyping_ by
      
      ----------------- :: skip
      G |s- skip : unit
      
      ----------------- :: fail
      G |s- fail : unit
      
      G |e- E : T
      ----------- :: expr
      G |s- E : T
      
      % let
      
      G |b- B : val
      G |s- S1 : T
      G |s- S2 : T
      ------------------------------ :: if
      G |s- if B then S1 else S2 : T
      
      G |s- S1 : T
      G |s- S2 : T
      ----------------- :: plus
      G |s- S1 + S2 : T
      
      G |s- S1 : T1
      G |s- S2 : T2
      ------------------------ :: par
      G |s- S1 || S2 : (T1,T2)
      
      ----------------------- :: create
      G |s- create{ty} : addr
      
          (a,val) _in G
      -------------------- :: alloc
      G |s- alloc a : addr
      
         (a,addr) _in G
      ------------------- :: kill
      G |s- kill a : unit
      
      (a1,addr) _in G
      (a2,val) _in G
      ---------------------------- :: store
      G |s- store{ty} a1 a2 : unit
      
          (a,addr) _in G
      ---------------------- :: load
      G |s- load{ty} a : val
      
      (a1,addr) _in G
      (a2,addr) _in G
      ----------------------- :: same
      G |s- same a1 a2 : unit
      
      % FUN
      % CALL
