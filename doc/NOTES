2012-02-28 16:23 - K
2012-02-29 17:02 - K, J

[Introduction]
Core aims at replacing csem's current pipeline starting from "reduction.lem". It
is intended to correspond to the essence of the C. It has pure expressions with
a clear evaluation order; boolean tests over expressions; explicit memory
actions (creation/kill of an object, load, store, ...); effectful statements
allowing the implementation of C's statements but with a syntax making explicit
the sequenced-before over the memory actions; explicit checks for non
memory-related undefined behaviours. Core will be the last intermediate language
in the pipeline from which different things can be done according to the mode on
which csem is run:

  * Simulator mode:    csem is given some setting for the implementation-defined
                       behaviours and the Core program is (one possible)
                       execution is evaluated. It will signal undefined
                       behaviours it finds along the way.

  * Mark's mode:    The set of actions and all the possible sequenced-before
                    relations are computed for the Core program.

  * Prover's mode:    Outputs a proof assistant readable encoding of the Core
                      program (not just an execution) for verification purpose.

Here we recall the "next" csem's intermediate languages and pipeline:
--------------------------------------------------------------------------------
Cabs    tries to follow as closely as possible the grammar given in the standard
        (see Annex A), modulo: collapsing of "parsing motivated" structures of
        the grammar (e.g. expressions); addition of some stuff defined as part
        of the standard library, but which should really be part of the
        language (e.g. setjmp).

Ail    Cabs but with more structure: the type declarators are encoded in a form
       where meaningless declarator are not representable (e.g. int char x;);
       struct/union members are flattened (int x, y ==> int x; int y) and more
       sensible blocks. Some construct of Cabs which are simply syntactic sugar
       are also translated away (e.g. increment/decrement, BUT NOT array
       subscripts because we need to keep them for typechecking).

Ail_τ    Ail with type annotation everywhere

Ail'_τ    Ail_τ after the final pass of sugaring: translating array subscripts
          into arithmetic and deref (TODO: something else ?)

Core    described here, and translated from Ail'_τ


PIPELINE:
  1) C      ----parsing-----> Cabs
  2) Cabs   ---desugaring---> Ail
  3) Ail    --typechecking--> Ail_τ
  4) Ail_τ  --desugaring2---> Ail'_τ
  5) Ail'_τ ----------------> Core
--------------------------------------------------------------------------------


[Syntax]
  [Auxiliary stuff in the syntax] (TODO)
    function name:              φ
    symbols (address or value): α
    C-type:                     τ

[Core program]
P = [(φ, S)] (TODO: this has/will change(d))

== [statements] ================================================================
  S ::= skip
     |  fail
     |  E
     |  let α = S in S
     |  if F then S else S
     |  S + S
     |  S || S
     |  create_τ
     |  kill α
     |  store_τ α α
     |  load_τ α
     |  same α α
     |  fun φ(α1, ..., αN) S (TODO: or outside of statements (?))
     |  call φ(α1, ..., αN)

== [expressions] ===============================================================
  E::= n
    |  α
    |  E * E,  * ∈ {+,−,×,/,mod}
    |  -E
    |  max_τ
    |  min_τ
    |  sizeof_τ
    |  alignof_τ
    |  offsetof α

== [boolean tests] =============================================================
  F::= true
    |  false
    |  ¬F
    |  F * F,  * ∈ {v,∨}
    |  E * E,  * ∈ {<,=}
--------------------------------------------------------------------------------


[Statics]
  We give a nearly trivial type system to Core to avoid having meaningless
  programs (may be useless for the "Prover mode").
  
  We have the following base types:
    * unit    the classic unit type
    * value   morally is the mathematical integers modulo Trap values,
              indeterminate values, ... (Or I (K) am wrong ?)
    * addr    the addr of a memory object
  
  We also have lists (written [ty]) and pairs (written (ty1, ty2)).
  
  EXPRESSIONS
    [α]           lookup in the typing environment
    [E1 * E2]     E1 and E2 must be of type value and the result is of type value.
    [-E]          E must be of type value and the result is of type value.
    [max_τ]       is of type value
    [min_τ]       is of type value
    [sizeof_τ]    is of type value
    [alignof_τ]   is of type value
    [offsetof α]  α is of type addr (TODO: there is some metaphysical thoughts
                  whether we have to enforce that α is not only of type addr but
                  also corresponds to a struct/union members (which is the only
                  case where offsetof makes any sense) or if we ignore this a
                  the typing level and then makes the value of "offsetof α" 
                  equals 0 for any improper α (this should "just work" but this
                  is nasty)
  
  BOOLEAN TESTS
    [true]        is of type value
    [false]       is of type value
    [¬F]          F must be of type value and the result is of type value.
    [F1 * F2]     F1 and F2 must be of type value and the result is of type value.
    [E1 * E2]     E1 and E2 must be of type value and the result is of type value.
  
  STATEMENTS
    [skip]                  is of type unit.
    [fail]                  (TODO) J seems to want to have a base type
                            "undefined" for this construct, whereas K don't see
                            the point (or forgot it) and thinks the type unit is
                            sufficient here.
    [E]                     see the typing of expressions
    [let α = S1 in S2]      is of the same type as S2, which is typed in the
                            current type environmnent extended with "α is of the
                            same type as S1".
    [if F then S1 else S2]  F must be of type value, S1 and S2 must be of the
                            same type (say ty) and result is of type ty.
    [S1 + S2]               S1 and S2 must be of the same type (say ty) and
                            result is of type ty.
    [S1 || S2]              if S1 is of type ty1 and S2 of type ty2, then the
                            result is of type (ty1, ty2)
    [create_τ]              if τ is not a struct/union type, then the result is
                            of type addr, otherwise it is of type [addr] with
                            length equal to the number of fields of τ.
    [kill α]                α must be of type addr, and the return type is unit.
    [store_τ α1 α2]         α1 must be of type addr, α2 must be of type value
                            and the return type is unit.
    [load_τ α]              α must be of type addr and the return type is value.
    [same α1 α2]            α1 and α2 must be of type addr and the return type
                            is unit.
    [fun φ(α1, ..., αN) S]  
    [call φ(α1, ..., αN)]   
--------------------------------------------------------------------------------


[Dynamics]

== [skip] ======================================================================
Is just a "nop". Used for example to implement C's if-then statements and loop
with empty bodies.

== [fail] ======================================================================
This construct represents an undefined behaviour. In the simulator mode this is
implemented as an exception being thrown.

== [if F then S else S] ========================================================
Classic if-then-else construct: the test is evaluated (remember that it is pure)
and the corresponding branch is executed. This is used to implement C's
if-then-else statement, but also to make explicit checks for non memory-related
undefined behaviours (such as: arithmetic overflows, conversion errors, ...).

== [create_τ] ==================================================================
This statement creates in the memory an "object" (§3.15) with
"effective type" (§6.5#6) τ. It returns one or more symbols of type Addr. Later,
to refer to the object or its subobjects (fields of structs/unions) one has to
use the corresponding symbol introduced by the create statement. 

This construct typically corresponds to the translation of a C declaration,
where it is used as the left operand of a let construct:

  (in C)        (in Core)
  
  struct T {      let α1 = create_{signed int} in
    int x, y;     let α2 = create_{signed_int} in
  };              ...
  ...             let [α3, α4, α5] = create_{struct T} in
  int u, v;       
  ...             
  struct T w;     


== [offsetof α] ================================================================
If α designate a struct/union field, then the value of the expression "offsetof
α" is the offset of that field in the memory representation of the containing
object. Otherwise the value is 0.

[K: the only alternative to the "otherwise" I see is to put a "binary" type for
    Addr symbols, but this seems uselessly heavy. Morally the expression has no
    real meaning for an α not corresponding to a struct/union field, but for
    these the 0 should be correct (?)]

The value of this construct is clearly implementation-defined; it is needed to
implement the offsetof macro (§7.19).


== Proposed implementation of gotos ============================================
We try to avoid having plain continuations in Core's syntax or semantics. For
gotos, a possible hack is to make for each label a partial duplicate of the
containing function. This would be done during the translation from Ail to Core.
Goto statement would then simply translated as Core function calls. Here is an
example:

  (in C)                   (in Core)
  int f(int x) {           fun φ1 x =
    int i = 0;               let α1 = create_{signed int} in
                             let α2 = 0 in
                             if min_{signed int} ≤ α2 ≤ max_{signed int} then
                               store_{signed int} α1 α2
                             else
                               fail
    loop: if i<5 {           let (α3, α4) = load_{signed int} α1 || 5 in
            i++;             if min_{signed int} ≤ α4 ≤ max_{signed int} then
            goto loop;         if α3 < α4 then
          }                      let α5 = load_{signed_int} α1 in
   return i;                     let α6 = α5 + 1 in
  }                              if min_{signed int} ≤ α6 ≤ max_{signed int} then
                                   store_{signed int} α1 α6
                                 else
                                   fail
                                 call φ2(x, α1)
                               else
                                 skip
                             else
                               fail
                             let α7 = load_{signed int} α1 in
                             α7
                           
                           fun φ2 x i =
                             let (α1, α2) = load_{signed int} i || 5 in
                             if min_{signed int} ≤ α2 ≤ max_{signed int} then
                               if α1 < α2 then
                                 let α3 = load_{signed_int} i in
                                 let α4 = α3 + 1 in
                                 if min_{signed int} ≤ α4 ≤ max_{signed int} then
                                   store_{signed int} i α4
                                 else
                                   fail
                                 call φ2 x i
                               else
                                 skip
                             else
                               fail
                             let α5 = load_{signed int} i in
                             α5

However there are several problems:
  * loss of original program structure
  * when calling a function corresponding to a label, have to pass in addresses
    of locals
  * when jumping into new block, have to allocate new locals
  * when jumping into a loop body, have to unfold loop once
  * when jumping out of a block, have to kill locals


Crazy remark by J: maybe goto in Core is a better option

################################################################################
2012-02-29 15:36 - K, J

[Bringing & back to Core]
Consider the following C pseudo-program: A + B + f()

The operands of the additions are "unsequenced", except for function calls which
are indeterminately sequenced. Here the sb-relation look like:
  
       .- f() -.            A             B        A
   sb /         \ sb        |             |         \ sb
     |           |     OR   | sb       sb |   OR     '-> f()        OR
     v           v           \           /                 \ sb
     A           B            '-> f() <-'                   '-> B
   
                            B
                             \ sb
                              '-> f()
                                    \ sb
                                     '-> A
   --------------------------------------------------------------------------

== Previous attempt 1) at the definition of &:
  f & A = f(); A or A; f
  
But if we have A = e_1 || e_2, we are missing the last two cases.


== Previous attempt 2):
  f (A || B) = f; (A || B) or (A||B); f + A; f; B + B; f; A

But this is still not enough because of the following program:
  f() + ((x, x=0) + y)


== Third attempt:
  