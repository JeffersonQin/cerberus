TRANSLATION
  
  * For non-void functions, if there is an end of the body with no return
    statement then we need to signal an undefined behaviour (ยง6.9.1#12). To do
    that we need to translate function bodies in two step: first to do the
    "normal" translation, then on the translate code we look for all the control
    path (without being clever regarding loops) an add undef when needed. This
    locally breaks the composability of the translation, but this already the
    case at least because of the current scheme (code dupliation) for gotos.
    
    NOTE: given the phrasing of ยง6.9.1#12, I wonder if a non-void function
          ending with a call to a _Noreturn (but no return statement) has and
          undefined behaviour.
  
  * Just a remark: the behaviour of bitwise operations is highly implementation
    defined since it directly depens on the representation of integer types.
    However there is (reasonable) finite number of allowed interpretation (??)
    so we can implement all of them in Core and have bitwise operation
    translation to a implementation-defined symbolic function call to the proper
    implementation of the operation.
  
  *




GRAPH BASED EXECUTION OF CORE

For execution, a Core program is translated into a set of graphs each
corresponding to one of the possible choice regarding "indeterminate
sequencing". Their are two kind of nodes: the first contains basic
(that is no ; || [ ] or < >) effectful Core expression (create, store,
kill, same, ...) and have at most one outgoing edge; the second
called "decision nodes" contains a pure boolean Core expression and
have two outgoing edge (associated the two possible values of the
boolean expression).

More precisely, in any graph corresponding to a Core program, the body
of each Core function correspond to a separated subgraph.


These graphs are executed in an abstract machine. Taking a graph, the
machine starts by loading the subgraph corresponding to the main
function (by loading we mean making a duplicate and placing it an
execution environment). Then the machine finds the nodes with no
incoming edges (these nodes correspond to initial actions and are
unsequenced with respect to each other), then execute them is some
order of it "choice" (the choice is saved in a execution history).

The state of the machine record a "current node".

As said before, simple nodes contain Core base expressions so executing them
result in memory access.

Nodes may have an associated symbolic name (according to the original
Core program), after the execution of a node its symbolic name stores
it's value.

Decision nodes contain Core boolean expression so executing them do
NOT result in memory access.

After the execution of a node, the "current node" of a the machine is
change to:
  * the only successor (if the current node is a simple node)
  * one of the successor according to the computed boolean value (if the current node is a decision node)
  * nothing if there is no successor, in this case the machine halts

and the former current node is removed from the execution environment.
If the former current node was a Decision node, then we also need to remove the nodes in the 
non visited branch. These nodes are simple to compute: they are (I think) also the reflexive transitive successors
of the non visited former current node that do not have a precessor that have yet to be executed.


When the expression contain in a simple node is a Core function call, then the subgraph corresponding to the
body of that function is loaded to the execution environment. The "current node" (the call) is connected with
edges from it to all the initial nodes of that subgraph and the terminal nodes of that subgraph are connected with
edges from them to the successor of the "current node". The edge from the "current node" and its successor is
removed.



