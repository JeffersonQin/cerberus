open import Pervasives

open import Utils Core Core_aux Ctype Annot
import Symbol Mem

import Pp

let mapsnd f l = List.map (fun (a,b) -> (a, f b)) l


type object_and_loaded_value_alg 'ov 'lv = 
 <| a_OVinteger : Mem.integer_value -> 'ov
  ; a_OVfloating : Mem.floating_value -> 'ov
  ; a_OVpointer : Mem.pointer_value -> 'ov
  ; a_OVarray : list 'lv -> 'ov
  ; a_OVstruct : Symbol.sym -> list (Symbol.identifier * ctype * Mem.mem_value) -> 'ov
  ; a_OVunion : Symbol.sym -> Symbol.identifier -> Mem.mem_value -> 'ov
  ; a_LVspecified : 'ov -> 'lv
  ; a_LVunspecified : ctype -> 'lv
 |>

let rec fold_object_value alg ov = 
  match ov with
  | OVinteger iv -> alg.a_OVinteger iv
  | OVfloating fv -> alg.a_OVfloating fv
  | OVpointer pv -> alg.a_OVpointer pv
  | OVarray lvs -> alg.a_OVarray (List.map (fold_loaded_value alg) lvs)
  | OVstruct sym icmv -> alg.a_OVstruct sym icmv
  | OVunion sym id mv -> alg.a_OVunion sym id mv
  end

and fold_loaded_value alg lv = 
  match lv with
  | LVspecified ov -> alg.a_LVspecified (fold_object_value alg ov)
  | LVunspecified ct -> alg.a_LVunspecified ct
  end

type value_alg 'ov 'lv 'value =
  <| object_and_loaded_value_alg : object_and_loaded_value_alg 'ov 'lv
   ; a_Vobject : 'ov -> 'value
   ; a_Vloaded : 'lv -> 'value
   ; a_Vunit : 'value
   ; a_Vtrue : 'value
   ; a_Vfalse : 'value
   ; a_Vctype : ctype -> 'value
   ; a_Vlist : core_base_type -> list 'value -> 'value
   ; a_Vtuple : list 'value -> 'value
  |>


let rec fold_value alg v = 
  match v with
  | Vobject ov -> 
     alg.a_Vobject (fold_object_value alg.object_and_loaded_value_alg ov)
  | Vloaded lv -> 
     alg.a_Vloaded (fold_loaded_value alg.object_and_loaded_value_alg lv)
  | Vunit -> alg.a_Vunit
  | Vtrue -> alg.a_Vtrue
  | Vfalse -> alg.a_Vfalse
  | Vctype ct -> alg.a_Vctype ct
  | Vlist ct vs -> alg.a_Vlist ct (List.map (fold_value alg) vs)
  | Vtuple vs -> alg.a_Vtuple (List.map (fold_value alg) vs)
 end

type pexpr_alg 'sym 'bty 'ov 'lv 'value 'pexpr_ 'pexpr = 
  <| value_alg : value_alg 'ov 'lv 'value
   ; a_Pexpr : list annot -> 'bty -> 'pexpr_ -> 'pexpr
   ; a_PEsym : 'sym -> 'pexpr_
   ; a_PEimpl : Implementation.implementation_constant -> 'pexpr_
   ; a_PEval : 'value -> 'pexpr_
   ; a_PEconstrained :  list (Mem.mem_iv_constraint * 'pexpr) -> 'pexpr_
   ; a_PEundef : Loc.t -> Undefined.undefined_behaviour -> 'pexpr_
   ; a_PEerror : string -> 'pexpr -> 'pexpr_
   ; a_PEctor : (generic_ctor 'bty) -> list 'pexpr -> 'pexpr_
   ; a_PEcase : 'pexpr -> list ((generic_pattern 'bty 'sym) * 'pexpr) -> 'pexpr_
   ; a_PEarray_shift : 'pexpr -> ctype -> 'pexpr -> 'pexpr_
   ; a_PEmember_shift : 'pexpr -> 'sym -> Symbol.identifier -> 'pexpr_
   ; a_PEnot : 'pexpr -> 'pexpr_
   ; a_PEop : binop -> 'pexpr -> 'pexpr -> 'pexpr_
   ; a_PEstruct : 'sym -> list (Symbol.identifier * 'pexpr) -> 'pexpr_
   ; a_PEunion : 'sym -> Symbol.identifier -> 'pexpr -> 'pexpr_
   ; a_PEcfunction : 'pexpr -> 'pexpr_
   ; a_PEmemberof : 'sym -> Symbol.identifier -> 'pexpr -> 'pexpr_
   ; a_PEcall : (generic_name 'sym) -> list 'pexpr -> 'pexpr_
   ; a_PElet : (generic_pattern 'bty 'sym) -> 'pexpr -> 'pexpr -> 'pexpr_
   ; a_PEif : 'pexpr -> 'pexpr -> 'pexpr -> 'pexpr_
   ; a_PEis_scalar : 'pexpr -> 'pexpr_
   ; a_PEis_integer : 'pexpr -> 'pexpr_
   ; a_PEis_signed : 'pexpr -> 'pexpr_
   ; a_PEis_unsigned : 'pexpr -> 'pexpr_
   ; a_PEbmc_assume : 'pexpr -> 'pexpr_
   ; a_PEare_compatible : 'pexpr -> 'pexpr -> 'pexpr_
  |>


let rec fold_pexpr alg pe =
  let (Pexpr annots bty pe_) = pe in
  let wrap pe_ = alg.a_Pexpr annots bty pe_ in
  match pe_ with
  | PEsym sym -> 
     wrap (alg.a_PEsym sym)
  | PEimpl c -> 
     wrap (alg.a_PEimpl c)
  | PEval v -> 
     wrap (alg.a_PEval (fold_value alg.value_alg v))
  | PEconstrained c_pes -> 
     wrap (alg.a_PEconstrained (mapsnd (fold_pexpr alg) c_pes))
  | PEundef l u -> 
     wrap (alg.a_PEundef l u)
  | PEerror str pe -> 
     wrap (alg.a_PEerror str (fold_pexpr alg pe))
  | PEctor ctor args -> 
     wrap (alg.a_PEctor ctor (List.map (fold_pexpr alg) args))
  | PEcase pe ppes -> 
     wrap (alg.a_PEcase (fold_pexpr alg pe) (mapsnd (fold_pexpr alg) ppes))
  | PEarray_shift pe1 ct pe2 -> 
     wrap (alg.a_PEarray_shift (fold_pexpr alg pe1) ct (fold_pexpr alg pe2))
  | PEmember_shift pe sym id -> 
     wrap (alg.a_PEmember_shift (fold_pexpr alg pe) sym id)
  | PEnot pe ->
     wrap (alg.a_PEnot (fold_pexpr alg pe))
  | PEop op pe1 pe2 ->
     wrap (alg.a_PEop op (fold_pexpr alg pe1) (fold_pexpr alg pe2))
  | PEstruct sym id_pes ->
     wrap (alg.a_PEstruct sym (mapsnd (fold_pexpr alg) id_pes))
  | PEunion sym id pe ->
     wrap (alg.a_PEunion sym id (fold_pexpr alg pe))
  | PEcfunction pe ->
     wrap (alg.a_PEcfunction pe)
  | PEmemberof sym id pe ->
     wrap (alg.a_PEmemberof sym id pe)
  | PEcall name pes ->
     wrap (alg.a_PEcall name (List.map (fold_pexpr alg) pes))
  | PElet pat pe1 pe2 ->
     wrap (alg.a_PElet pat (fold_pexpr alg pe1) (fold_pexpr alg pe2))
  | PEif pe1 pe2 pe3 ->
     wrap (alg.a_PEif (fold_pexpr alg pe1) (fold_pexpr alg pe2) (fold_pexpr alg pe3))
  | PEis_scalar pe ->
     wrap (alg.a_PEis_scalar (fold_pexpr alg pe))
  | PEis_integer pe ->
     wrap (alg.a_PEis_integer (fold_pexpr alg pe))
  | PEis_signed pe ->
     wrap (alg.a_PEis_signed (fold_pexpr alg pe))
  | PEis_unsigned pe ->
     wrap (alg.a_PEis_unsigned (fold_pexpr alg pe))
  | PEbmc_assume pe ->
     wrap (alg.a_PEbmc_assume (fold_pexpr alg pe))
  | PEare_compatible pe1 pe2 ->
     wrap (alg.a_PEare_compatible (fold_pexpr alg pe1) (fold_pexpr alg pe2))
  end


type action_alg 'sym 'bty 'ov 'lv 'value 'pexpr_ 'pexpr 'a 'action_ 'action 'paction =
  <| apexpr_alg : pexpr_alg 'sym 'bty 'ov 'lv 'value 'pexpr_ 'pexpr
   ; a_Action : Loc.t -> 'a -> 'action_ -> 'action
   ; a_Paction : polarity -> 'action -> 'paction
   ; a_Create : 'pexpr -> 'pexpr -> Symbol.prefix -> 'action_
   ; a_CreateReadOnly : 'pexpr -> 'pexpr -> 'pexpr -> Symbol.prefix -> 'action_
   ; a_Alloc : 'pexpr -> 'pexpr -> Symbol.prefix -> 'action_
   ; a_Kill : bool -> 'pexpr -> 'action_
   ; a_Store : bool -> 'pexpr -> 'pexpr -> 'pexpr -> Cmm_csem.memory_order -> 'action_
   ; a_Load : 'pexpr -> 'pexpr -> Cmm_csem.memory_order -> 'action_
   ; a_RMW : 'pexpr -> 'pexpr -> 'pexpr -> 'pexpr -> Cmm_csem.memory_order -> Cmm_csem.memory_order -> 'action_
   ; a_Fence : Cmm_csem.memory_order -> 'action_
   ; a_CompareExchangeStrong : 'pexpr -> 'pexpr -> 'pexpr -> 'pexpr -> Cmm_csem.memory_order -> Cmm_csem.memory_order -> 'action_
   ; a_CompareExchangeWeak : 'pexpr -> 'pexpr -> 'pexpr -> 'pexpr -> Cmm_csem.memory_order -> Cmm_csem.memory_order -> 'action_
   ; a_LinuxFence : Linux.linux_memory_order -> 'action_
   ; a_LinuxLoad : 'pexpr -> 'pexpr -> Linux.linux_memory_order -> 'action_
   ; a_LinuxStore : 'pexpr -> 'pexpr -> 'pexpr -> Linux.linux_memory_order -> 'action_
   ; a_LinuxRMW : 'pexpr -> 'pexpr -> 'pexpr -> Linux.linux_memory_order -> 'action_
  |>

let fold_action alg action = 
  let (Action l a action_) = action in
  let wrap action_ = alg.a_Action l a action_ in
  wrap
    match action_ with
    | Create pe1 pe2 p -> 
       alg.a_Create
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2) 
         p
    | CreateReadOnly pe1 pe2 pe3 p ->
       alg.a_CreateReadOnly 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         (fold_pexpr alg.apexpr_alg pe3) 
         p
    | Alloc pe1 pe2 p ->
       alg.a_Alloc 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         p
    | Kill b pe ->
       alg.a_Kill 
         b
         (fold_pexpr alg.apexpr_alg pe)
    | Store b pe1 pe2 pe3 mo ->
       alg.a_Store 
         b
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         (fold_pexpr alg.apexpr_alg pe3)
         mo
    | Load pe1 pe2 mo ->
       alg.a_Load 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         mo
    | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
       alg.a_RMW 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         (fold_pexpr alg.apexpr_alg pe3)
         (fold_pexpr alg.apexpr_alg pe4)
         mo1
         mo2
    | Fence mo ->
       alg.a_Fence 
         mo
    | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
       alg.a_CompareExchangeStrong 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2) 
         (fold_pexpr alg.apexpr_alg pe3)
         (fold_pexpr alg.apexpr_alg pe4)
         mo1 
         mo2
    | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
       alg.a_CompareExchangeWeak 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2) 
         (fold_pexpr alg.apexpr_alg pe3)
         (fold_pexpr alg.apexpr_alg pe4)
         mo1 
         mo2
    | LinuxFence mo ->
       alg.a_LinuxFence 
         mo
    | LinuxLoad pe1 pe2 mo ->
       alg.a_LinuxLoad 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         mo
    | LinuxStore pe1 pe2 pe3 mo ->
       alg.a_LinuxStore 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         (fold_pexpr alg.apexpr_alg pe3)
         mo
    | LinuxRMW pe1 pe2 pe3 mo ->
       alg.a_LinuxRMW 
         (fold_pexpr alg.apexpr_alg pe1)
         (fold_pexpr alg.apexpr_alg pe2)
         (fold_pexpr alg.apexpr_alg pe3)
         mo
    end

let fold_paction alg (Paction polarity action) =
  alg.a_Paction polarity action



type expr_alg 'sym 'bty 'ov 'lv 'value 'pexpr_ 'pexpr 'a 'action_ 'action 'paction 'expr_ 'expr =
  <| action_alg : action_alg 'sym 'bty 'ov 'lv 'value 'pexpr_ 'pexpr 'a 'action_ 'action 'paction
   ; pexpr_alg : pexpr_alg 'sym 'bty 'ov 'lv 'value 'pexpr_ 'pexpr
   ; a_Expr : list annot -> 'expr_ -> 'expr
   ; a_Epure : 'pexpr -> 'expr_
   ; a_Ememop : Mem_common.memop -> list 'pexpr -> 'expr_
   ; a_Eaction : 'paction -> 'expr_
   ; a_Ecase : 'pexpr -> list ((generic_pattern 'bty 'sym) * 'expr) -> 'expr_
   ; a_Elet : (generic_pattern 'bty 'sym) -> 'pexpr -> 'expr -> 'expr_
   ; a_Eif : 'pexpr -> 'expr -> 'expr -> 'expr_
   ; a_Eskip : 'expr_
   ; a_Eccall : 'a -> 'pexpr -> 'pexpr -> list 'pexpr -> 'expr_
   ; a_Eproc : 'a -> (generic_name 'sym) -> list 'pexpr -> 'expr_
   ; a_Eunseq : list 'expr -> 'expr_
   ; a_Ewseq : (generic_pattern 'bty 'sym) -> 'expr -> 'expr -> 'expr_
   ; a_Esseq : (generic_pattern 'bty 'sym) -> 'expr -> 'expr -> 'expr_
   ; a_Easeq : ('sym * core_base_type) -> (generic_action 'a 'bty 'sym) -> 'paction -> 'expr_
   ; a_Eindet : nat -> 'expr -> 'expr_
   ; a_Ebound : nat -> 'expr -> 'expr_
   ; a_End : list 'expr -> 'expr_
   ; a_Esave : ('sym * core_base_type) -> list ('sym * (core_base_type * generic_pexpr 'bty 'sym)) -> 'expr -> 'expr_
   ; a_Erun : 'a -> 'sym -> list 'pexpr -> 'expr_
   ; a_Epar : list 'expr -> 'expr_
   ; a_Ewait : Mem_common.thread_id -> 'expr_
  |>

let rec fold_expr alg e = 
  let Expr annots e_ = e in
  let wrap e_ = alg.a_Expr annots e_ in
  match e_ with
  | Epure pe ->
     wrap (alg.a_Epure (fold_pexpr alg.pexpr_alg pe))
  | Ememop mop pes ->
     wrap (alg.a_Ememop mop (List.map (fold_pexpr alg.pexpr_alg) pes))
  | Eaction a ->
     wrap (alg.a_Eaction (fold_paction alg.action_alg a))
  | Ecase pe pats_pes ->
     wrap (alg.a_Ecase (fold_pexpr alg.pexpr_alg pe) (mapsnd (fold_expr alg) pats_pes))
  | Elet pat pe e ->
     wrap (alg.a_Elet pat (fold_pexpr alg.pexpr_alg pe) (fold_expr alg e))
  | Eif pe e1 e2 ->
     wrap (alg.a_Eif (fold_pexpr alg.pexpr_alg pe) (fold_expr alg e1) (fold_expr alg e2))
  | Eskip ->
     wrap alg.a_Eskip
  | Eccall a pe1 pe2 pes ->
     wrap (alg.a_Eccall a (fold_pexpr alg.pexpr_alg pe1) (fold_pexpr alg.pexpr_alg pe2) (List.map (fold_pexpr alg.pexpr_alg) pes))
  | Eproc a n pes ->
     wrap (alg.a_Eproc a n (List.map (fold_pexpr alg.pexpr_alg) pes))
  | Eunseq es ->
     wrap (alg.a_Eunseq (List.map (fold_expr alg) es))
  | Ewseq pat e1 e2 ->
     wrap (alg.a_Ewseq pat (fold_expr alg e1) (fold_expr alg e2))
  | Esseq pat e1 e2 ->
     wrap (alg.a_Esseq pat (fold_expr alg e1) (fold_expr alg e2))
  | Easeq s a pa ->
     wrap (alg.a_Easeq s (fold_action alg.action_alg a) (fold_paction alg.action_alg pa))
  | Eindet n e ->
     wrap (alg.a_Eindet n (fold_expr alg e))
  | Ebound n e ->
     wrap (alg.a_Ebound n (fold_expr alg e))
  | End es ->
     wrap (alg.a_End (List.map (fold_expr alg) es))
  | Esave s s_cbts_pes e ->
     wrap (alg.a_Esave s (List.map (fun (s,(cbt,pe)) -> (s,(cbt,fold_pexpr alg.pexpr_alg pe))) s_cbts_pes) (fold_expr alg e))
  | Erun a s pes ->
     wrap (alg.a_Erun a s (List.map (fold_pexpr alg.pexpr_alg) pes))
  | Epar es ->
     wrap (alg.a_Epar (List.map (fold_expr alg) es))
  | Ewait tid ->
     wrap (alg.a_Ewait tid)
end



let id_object_and_loaded_value_alg = 
  <| a_OVinteger = OVinteger
   ; a_OVfloating = OVfloating
   ; a_OVpointer = OVpointer
   ; a_OVarray = OVarray
   ; a_OVstruct = OVstruct
   ; a_OVunion = OVunion 
   ; a_LVspecified = LVspecified
   ; a_LVunspecified = LVunspecified
  |>


let id_value_alg = 
  <| object_and_loaded_value_alg = id_object_and_loaded_value_alg
   ; a_Vobject = Vobject
   ; a_Vloaded = Vloaded
   ; a_Vunit = Vunit
   ; a_Vtrue = Vtrue
   ; a_Vfalse = Vfalse
   ; a_Vctype = Vctype
   ; a_Vlist = Vlist
   ; a_Vtuple = Vtuple
  |>

let id_pexpr_alg = 
  <| value_alg = id_value_alg
   ; a_Pexpr = Pexpr
   ; a_PEsym = PEsym
   ; a_PEimpl = PEimpl
   ; a_PEval = PEval
   ; a_PEconstrained = PEconstrained
   ; a_PEundef = PEundef
   ; a_PEerror = PEerror
   ; a_PEctor = PEctor
   ; a_PEcase = PEcase
   ; a_PEarray_shift = PEarray_shift
   ; a_PEmember_shift = PEmember_shift
   ; a_PEnot = PEnot
   ; a_PEop = PEop
   ; a_PEstruct = PEstruct
   ; a_PEunion = PEunion
   ; a_PEcfunction = PEcfunction
   ; a_PEmemberof = PEmemberof
   ; a_PEcall = PEcall
   ; a_PElet = PElet
   ; a_PEif = PEif
   ; a_PEis_scalar = PEis_scalar
   ; a_PEis_integer = PEis_integer
   ; a_PEis_signed = PEis_signed
   ; a_PEis_unsigned = PEis_unsigned
   ; a_PEbmc_assume = PEbmc_assume
   ; a_PEare_compatible = PEare_compatible
  |>


let id_action_alg = 
  <| apexpr_alg = id_pexpr_alg
   ; a_Action = Action
   ; a_Paction = Paction
   ; a_Create = Create
   ; a_CreateReadOnly = CreateReadOnly
   ; a_Alloc = Alloc
   ; a_Kill = Kill
   ; a_Store = Store
   ; a_Load = Load
   ; a_RMW = RMW
   ; a_Fence = Fence
   ; a_CompareExchangeStrong = CompareExchangeStrong
   ; a_CompareExchangeWeak = CompareExchangeWeak
   ; a_LinuxFence = LinuxFence
   ; a_LinuxLoad = LinuxLoad
   ; a_LinuxStore = LinuxStore
   ; a_LinuxRMW = LinuxRMW
  |>




let id_expr_alg =
  <| action_alg = id_action_alg
   ; pexpr_alg = id_pexpr_alg
   ; a_Expr = Expr
   ; a_Epure = Epure
   ; a_Ememop = Ememop
   ; a_Eaction = Eaction
   ; a_Ecase = Ecase
   ; a_Elet = Elet
   ; a_Eif = Eif
   ; a_Eskip = Eskip
   ; a_Eccall = Eccall
   ; a_Eproc = Eproc
   ; a_Eunseq = Eunseq
   ; a_Ewseq = Ewseq
   ; a_Esseq = Esseq
   ; a_Easeq = Easeq
   ; a_Eindet = Eindet
   ; a_Ebound = Ebound
   ; a_End = End
   ; a_Esave = Esave
   ; a_Erun = Erun
   ; a_Epar = Epar
   ; a_Ewait = Ewait
  |>



(* let rewriter_cfunction env = 
 * 
 *   let a_PEcfunction = function
 *     | PEsym sym ->
 *        match Map.find sym env with
 *        | 
 *        end 
 *     | _ -> 
 *        failwith "rewriter_cfunction: passing function pointers not supported"
 *   in
 * 
 *   let pexpr_alg = <| id_pexpr_alg with a_PEcfunction = a_PEcfunction |> in
 *   let expr_alg = <| id_expr_alg with pexpr_alg = pexpr_alg |> in
 *   expr_alg *)


let rw_expr = 
  fold_expr id_expr_alg

let rw_pexpr = 
  fold_pexpr id_pexpr_alg




let rw_fun fn = 
  match fn with
  | Fun cbt args pe -> Fun cbt args (rw_pexpr pe)
  | Proc loc cbt args e -> Proc loc cbt args (rw_expr e)
  | _ -> fn
  end

let rw_impl i = 
  match i with
  | IFun cbt args pe -> IFun cbt args (rw_pexpr pe)
  | _ -> i
  end

let rw_glob g = 
  match g with
  | GlobalDef cbt e -> GlobalDef cbt (rw_expr e)
  | _ -> g
  end

let rw_fun_map m = Map.map rw_fun m
let rw_impls m = Map.map rw_impl m
let rw_globs m = mapsnd rw_glob m

let rw_file file = 
  <| main    = file.main
   ; tagDefs = file.tagDefs
   ; stdlib  = rw_fun_map file.stdlib
   ; impl    = rw_impls file.impl
   ; globs   = rw_globs file.globs
   ; funs    = rw_fun_map file.funs
   ; extern  = file.extern
   ; funinfo = file.funinfo
  |>
