open import Pervasives

open import Ctype Annot Loc
import Symbol Implementation Undefined Cmm_csem
import Mem Mem_common
(* import Linux *)

import Core

open import Assert_extra





type symbol = Symbol.sym
type mu_object_type = Core.core_object_type
type mu_base_type = Core.core_base_type
type bty = mu_base_type
type mu_name = Core.generic_name symbol
type annotated 'a 'bty = Annotated of list Annot.annot * 'bty * 'a
type asym 'bty = annotated Symbol.sym 'bty

(* type mv_tsymbol = tsymbol       (\* Mem.mem_value *\) *)
type ov_asym 'bty = asym 'bty       (* object_value *)
type lv_asym 'bty = asym 'bty       (* loaded_value *)
type va_asym 'bty = asym 'bty       (* value *)


type mu_object_value 'bty =  (* C object values *)
 | M_OVinteger of Mem.integer_value (* integer value *)
 | M_OVfloating of Mem.floating_value (* floating-point value *)
 | M_OVpointer of Mem.pointer_value (* pointer value *)
 | M_OVarray of list (lv_asym 'bty) (* C array value *)
 | M_OVstruct of symbol * list (Symbol.identifier * ctype * Mem.mem_value) (* C struct value *)
 | M_OVunion of symbol * Symbol.identifier * Mem.mem_value (* C union value *)

type mu_loaded_value 'bty =  (* potentially unspecified C object values *)
 | M_LVspecified of mu_object_value 'bty (* non-unspecified loaded value *)
 | M_LVunspecified of ctype (* unspecified loaded value *)


(* again, we might remove something from the definition here,
   e.g. Vctype *)
type mu_value 'bty =  (* Core values *)
 | M_Vobject of mu_object_value 'bty (* C object value *)
 | M_Vloaded of mu_loaded_value 'bty (* loaded C object value *)
 | M_Vunit
 | M_Vtrue
 | M_Vfalse
 (* | M_Vctype of ctype (\* C type as value *\) *)
 | M_Vlist of Core.core_base_type * list (asym 'bty)
 | M_Vtuple of list (asym 'bty) (* tuple *)



type mu_ctor 'bty = Core.generic_ctor 'bty

type mu_pattern_ 'bty = Core.generic_pattern_ 'bty symbol
type mu_pattern 'bty = Core.generic_pattern 'bty symbol

type mu_pexpr_ 'bty =  (* Core pure expressions *)
 | M_PEsym of symbol
 | M_PEimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | M_PEval of mu_value 'bty
 | M_PEconstrained of list (Mem.mem_iv_constraint * asym 'bty) (* constrained value *)
 | M_PEundef of Loc.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_PEerror of string * asym 'bty (* impl-defined static error *)
 | M_PEctor of mu_ctor 'bty * list (asym 'bty) (* data constructor application *)
 | M_PEcase of (asym 'bty) * list ((mu_pattern 'bty) * mu_pexpr 'bty) (* pattern matching *)
 | M_PEarray_shift of (asym 'bty) * ctype * (asym 'bty) (* pointer array shift *)
 | M_PEmember_shift of (asym 'bty) * symbol * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of asym 'bty (* boolean not *)
 | M_PEop of Core.binop * (asym 'bty) * (asym 'bty)
 | M_PEstruct of symbol * list (Symbol.identifier * asym 'bty) (* C struct expression *)
 | M_PEunion of symbol * Symbol.identifier * asym 'bty (* C union expression *)
 (* | M_PEcfunction of asym 'bty (\* C function pointer expression *\) *)
 | M_PEmemberof of symbol * Symbol.identifier * asym 'bty (* C struct/union member access *)
 | M_PEcall of mu_name * list (asym 'bty) (* pure function call *)
 | M_PElet of (mu_pattern 'bty) * (mu_pexpr 'bty) * (mu_pexpr 'bty) (* pure let *)
 | M_PEif of asym 'bty * asym 'bty * asym 'bty (* pure if *)
 (* | M_PEis_scalar of asym 'bty
  * | M_PEis_integer of asym 'bty
  * | M_PEis_signed of asym 'bty
  * | M_PEbmc_assume of asym 'bty
  * | M_PEis_unsigned of asym 'bty
  * | M_PEare_compatible of asym 'bty * asym 'bty *)

and mu_pexpr 'bty = 
 | M_Pexpr of list annot * 'bty * (mu_pexpr_ 'bty)


type mu_action_ 'bty =  (* memory actions *)
 | M_Create of asym 'bty * asym 'bty * Symbol.prefix
 | M_CreateReadOnly of asym 'bty * asym 'bty * asym 'bty * Symbol.prefix
 | M_Alloc of asym 'bty * asym 'bty * Symbol.prefix
 | M_Kill of bool * asym 'bty (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | M_Store of bool * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order (* the boolean indicates whether the store is locking *)
 | M_Load of asym 'bty * asym 'bty * Cmm_csem.memory_order
 | M_RMW of asym 'bty * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_Fence of Cmm_csem.memory_order
 | M_CompareExchangeStrong of asym 'bty * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_CompareExchangeWeak of asym 'bty * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_LinuxFence of Linux.linux_memory_order
 | M_LinuxLoad of asym 'bty * asym 'bty * Linux.linux_memory_order
 | M_LinuxStore of asym 'bty * asym 'bty * asym 'bty * Linux.linux_memory_order
 | M_LinuxRMW of asym 'bty * asym 'bty * asym 'bty * Linux.linux_memory_order


type mu_action 'a 'bty = 
 | M_Action of Loc.t * 'a * (mu_action_ 'bty)


type mu_paction 'a 'bty =  (* memory actions with Core.polarity *)
 | M_Paction of Core.polarity * (mu_action 'a 'bty)

type mu_expr_ 'a 'bty =  (* (effectful) expression *)
 | M_Epure of (mu_pexpr 'bty)
 | M_Ememop of Mem_common.memop * list (asym 'bty) (* pointer op involving memory *)
 | M_Eaction of (mu_paction 'a 'bty) (* memory action *)
 | M_Ecase of asym 'bty * list ((mu_pattern 'bty) * (mu_expr 'a 'bty)) (* pattern matching *)
 | M_Elet of (mu_pattern 'bty) * (mu_pexpr 'bty) * (mu_expr 'a 'bty)
 | M_Eif of asym 'bty * (mu_expr 'a 'bty) * (mu_expr 'a 'bty)
 | M_Eskip
 | M_Eccall of 'a * (annotated ctype 'bty) * asym 'bty * list (asym 'bty) (* C function call *)
 | M_Eproc of 'a * mu_name * list (asym 'bty) (* Core procedure call *)
 (* | M_Eunseq of list (mu_expr 'a 'bty) (\* unsequenced expressions *\) *)
 | M_Ewseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* weak sequencing *)
 | M_Esseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* strong sequencing *)
 (* | M_Easeq of (symbol * mu_base_type) * (mu_action 'a 'bty) * (mu_paction 'a 'bty) (\* atomic sequencing *\) *)
 (* | M_Eindet of nat * (mu_expr 'a 'bty) (\* indeterminately sequenced expr *)
 | M_Ebound of nat * (mu_expr 'a 'bty) (* $\ldots$and boundary *)
 | M_End of list (mu_expr 'a 'bty) (* nondeterministic choice *)
 | M_Esave of (symbol * mu_base_type) * list (symbol * (mu_base_type * asym 'bty)) * (mu_expr 'a 'bty) (* save label *)
 | M_Erun of 'a * symbol * list (asym 'bty) (* run from label *)
 (* | M_Epar of list (mu_expr 'a 'bty) (\* cppmem-like thread creation *\) *)
 (* | M_Ewait of Mem_common.thread_id (\* wait for thread termination *\) *)

and mu_expr 'a 'bty = 
 | M_Expr of list annot * (mu_expr_ 'a 'bty)

type mu_impl_decl 'bty =
  | M_Def of mu_base_type * mu_pexpr 'bty
  | M_IFun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty

type mu_impl 'bty = map Implementation.implementation_constant (mu_impl_decl 'bty)

type mu_fun_map_decl 'bty 'a =
  | M_Fun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty
  | M_Proc of Loc.t * mu_base_type * list (symbol * mu_base_type) * mu_expr 'a 'bty
  | M_ProcDecl of Loc.t * mu_base_type * list mu_base_type
  | M_BuiltinDecl of Loc.t * mu_base_type * list mu_base_type

type mu_fun_map 'bty 'a = map symbol (mu_fun_map_decl 'bty 'a)

instance forall 'bty. (Located (mu_pexpr 'bty))
  let locOf pe =
    let (M_Pexpr annots _ _) = pe in
    get_loc_ annots
end

instance forall 'a 'bty. (Located (mu_expr 'a 'bty))
  let locOf e =
    let (M_Expr annots _) = e in
    get_loc_ annots
end


type mu_linking_kind = Core.linking_kind

type mu_extern_map = Core.extern_map

type mu_globs 'a 'bty=
  | M_GlobalDef of mu_base_type * mu_expr 'a 'bty
  | M_GlobalDecl of mu_base_type

type mu_globs_map 'a 'bty =
  map symbol (mu_globs 'a 'bty)

type mu_tag_definitions = Core.core_tag_definitions

(* a Core file is just a set of named functions *)
type mu_file 'bty 'a = <|
  mu_main    : maybe symbol;
  mu_tagDefs : mu_tag_definitions;
  mu_stdlib  : mu_fun_map 'bty 'a;
  mu_impl    : mu_impl 'bty;
  mu_globs   : list (symbol * mu_globs 'a 'bty);
  mu_funs    : mu_fun_map 'bty 'a;
  mu_extern  : mu_extern_map;
  mu_funinfo : map symbol (Loc.t * Annot.attributes * ctype * list (maybe symbol * ctype) * bool * bool);
|>




let mapsnd (f : 'b -> 'c) (l : list ('a * 'b)) : list ('a * 'c) = 
  List.map (fun (a,b) -> (a, f b)) l


let make_symbol_pexpr (Annotated annots bty sym) : Core.generic_pexpr 'bty symbol =
  Core.Pexpr annots bty (Core.PEsym sym)

type env 'bty = map symbol (mu_pexpr 'bty)

let insert_symbol sym v env =
  Map.insert sym v env

let lookup_asym env (Annotated _ _ sym) = 
  match Map.lookup sym env with
  | Just v -> v
  | Nothing -> 
     let err = "symbol " ^ show sym ^ " not found" in
     failwith err
  end

let get_loaded_value env sym = 
  match lookup_asym env sym with
  | M_Pexpr _ _ (M_PEval (M_Vloaded lv)) -> lv
  | _ -> failwith "not a loaded value"
  end

let get_object_value env sym = 
  match lookup_asym env sym with
  | M_Pexpr _ _ (M_PEval (M_Vobject ov)) -> ov
  | _ -> failwith "not an object value"
  end

let get_value env sym = 
  match lookup_asym env sym with
  | M_Pexpr _ _ (M_PEval v) -> v
  | _ -> failwith "not an object value"
  end

let rec mu_to_core__object_value (env : env 'bty) ov = 
  match ov with
  | M_OVinteger iv -> Core.OVinteger iv
  | M_OVfloating fv -> Core.OVfloating fv
  | M_OVpointer ov -> Core.OVpointer ov
  | M_OVstruct s is -> Core.OVstruct s is
  | M_OVunion s i mv -> Core.OVunion s i mv
  | M_OVarray is ->
     let is = List.map (get_loaded_value env) is in
     Core.OVarray (List.map (mu_to_core__loaded_value env) is)
  end

and mu_to_core__loaded_value (env : env 'bty) lv = 
  match lv with
  | M_LVspecified ov ->
     Core.LVspecified (mu_to_core__object_value env ov)
  | M_LVunspecified ct -> Core.LVunspecified ct
  end


let rec mu_to_core__value (env : env 'bty) (v : mu_value 'bty)
        : Core.generic_value symbol =
  match v with
  | M_Vobject ov -> Core.Vobject (mu_to_core__object_value env ov)
  | M_Vloaded lv -> Core.Vloaded (mu_to_core__loaded_value env lv)
  | M_Vunit -> Core.Vunit
  | M_Vtrue -> Core.Vtrue
  | M_Vfalse -> Core.Vfalse
  (* | M_Vctype ct -> Core.Vctype ct *)
  | M_Vlist cbt is -> 
     let is = List.map (get_value env) is in
     Core.Vlist cbt (List.map (mu_to_core__value env) is)
  | M_Vtuple is ->
     let is = List.map (get_value env) is in
     Core.Vtuple (List.map (mu_to_core__value env) is)
  end
  

let maybe_extend_env (env : env 'bty) pat (pe : mu_pexpr 'bty) = 
  let (Core.Pattern _ p) = pat in
  match p with
  | Core.CaseBase (Just sym, _cbt)  ->
     insert_symbol sym pe env
  | _ -> env
  end

let rec mu_to_core__pexpr (env : env 'bty) (pexpr : mu_pexpr 'bty)
        : Core.generic_pexpr 'bty symbol =
  let (M_Pexpr annots bty pexpr_) = pexpr in
  let pexpr_ = match pexpr_ with
    | M_PEsym s ->
       Core.PEsym s
    | M_PEimpl ic -> 
       Core.PEimpl ic
    | M_PEval v -> 
       Core.PEval (mu_to_core__value env v)
    | M_PEconstrained l -> 
       let l = mapsnd make_symbol_pexpr l in
       Core.PEconstrained l
    | M_PEundef loc undef ->
       Core.PEundef loc undef
    | M_PEerror err p -> 
       Core.PEerror err (make_symbol_pexpr p)
    | M_PEctor ctor pes -> 
       Core.PEctor ctor (map make_symbol_pexpr pes)
    | M_PEcase p pats_pes ->
       let pats_pes = mapsnd (mu_to_core__pexpr env) pats_pes in
       Core.PEcase (make_symbol_pexpr p) pats_pes
    | M_PEarray_shift pe1 ctype pe2 ->
       Core.PEarray_shift (make_symbol_pexpr pe1) ctype (make_symbol_pexpr pe2)
    | M_PEmember_shift p s id  ->
       Core.PEmember_shift (make_symbol_pexpr p) s id
    | M_PEnot p ->
       Core.PEnot (make_symbol_pexpr p)
    | M_PEop binop p1 p2 ->
       Core.PEop binop (make_symbol_pexpr p1) (make_symbol_pexpr p2)
    | M_PEstruct sym fields ->
       let fields = mapsnd make_symbol_pexpr fields in
       Core.PEstruct sym fields
    | M_PEunion sym id p ->
       Core.PEunion sym id (make_symbol_pexpr p)
    (* | M_PEcfunction f ->
     *    Core.PEcfunction (make_symbol_pexpr f) *)
    | M_PEmemberof sym id p ->
       Core.PEmemberof sym id (make_symbol_pexpr p)
    | M_PEcall name args ->
       Core.PEcall name (map make_symbol_pexpr args)
    | M_PElet pat p1 p2 ->
       let env' = maybe_extend_env env pat p1 in
       Core.PElet pat 
         (mu_to_core__pexpr env p1) 
         (mu_to_core__pexpr env' p2)
    | M_PEif p0 p1 p2 ->
       Core.PEif 
         (make_symbol_pexpr p0)
         (make_symbol_pexpr p1)
         (make_symbol_pexpr p2)
    (* | M_PEis_scalar p ->
     *    Core.PEis_scalar (make_symbol_pexpr p)
     * | M_PEis_integer p ->
     *    Core.PEis_integer (make_symbol_pexpr p)
     * | M_PEis_signed p ->
     *    Core.PEis_signed (make_symbol_pexpr p)
     * | M_PEis_unsigned p ->
     *    Core.PEis_unsigned (make_symbol_pexpr p)
     * | M_PEbmc_assume e ->
     *    Core.PEbmc_assume (make_symbol_pexpr e)
     * | M_PEare_compatible p1 p2 ->
     *    Core.PEare_compatible (make_symbol_pexpr p1) (make_symbol_pexpr p2) *)
  end in
  Core.Pexpr annots bty pexpr_

let mu_to_core__action_ (action_ : mu_action_ 'bty)
        : Core.generic_action_ 'bty symbol =
  match action_ with
  | M_Create p1 p2 prefix ->
     Core.Create (make_symbol_pexpr p1) (make_symbol_pexpr p2) prefix
  | M_CreateReadOnly p1 p2 p3 prefix ->
     Core.CreateReadOnly (make_symbol_pexpr p2) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) prefix
  | M_Alloc p1 p2 prefix ->
     Core.Alloc (make_symbol_pexpr p1) (make_symbol_pexpr p2) prefix
  | M_Kill b p ->
     Core.Kill b (make_symbol_pexpr p)
  | M_Store b p1 p2 p3 mo ->
     Core.Store b (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) mo
  | M_Load p1 p2 mo ->
     Core.Load (make_symbol_pexpr p1) (make_symbol_pexpr p2) mo
  | M_RMW p1 p2 p3 p4 mo1 mo2 ->
     Core.RMW (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) (make_symbol_pexpr p4) mo1 mo2
  | M_Fence mo ->
     Core.Fence mo
  | M_CompareExchangeStrong p1 p2 p3 p4 mo1 mo2 ->
     Core.CompareExchangeStrong (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) (make_symbol_pexpr p4) mo1 mo2
  | M_CompareExchangeWeak p1 p2 p3 p4 mo1 mo2 ->
     Core.CompareExchangeWeak (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) (make_symbol_pexpr p4) mo1 mo2
  | M_LinuxFence mo ->
     Core.LinuxFence mo
  | M_LinuxLoad p1 p2 mo ->
     Core.LinuxLoad (make_symbol_pexpr p1) (make_symbol_pexpr p2) mo
  | M_LinuxStore p1 p2 p3 mo ->
     Core.LinuxStore (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) mo
  | M_LinuxRMW p1 p2 p3 mo ->
     Core.LinuxRMW (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) mo
  end

let mu_to_core__action (M_Action t a action_) = 
  Core.Action t a (mu_to_core__action_ action_)

let mu_to_core__paction (M_Paction p action) = 
  Core.Paction p (mu_to_core__action action)

let rec mu_to_core__expr env (expr : mu_expr 'a 'bty)
        : Core.generic_expr 'a 'bty symbol =
  let (M_Expr annots expr_) = expr in
  let expr_ = match expr_ with
    | M_Epure p -> 
       Core.Epure (mu_to_core__pexpr env p)
    | M_Ememop memop pexprs ->
       Core.Ememop memop (map make_symbol_pexpr pexprs)
    | M_Eaction pa ->
       Core.Eaction (mu_to_core__paction pa)
    | M_Ecase pe es ->
       Core.Ecase (make_symbol_pexpr pe) (mapsnd (mu_to_core__expr env) es)
    | M_Elet pat pe e ->
       let env' = maybe_extend_env env pat pe in
       Core.Elet pat (mu_to_core__pexpr env pe) (mu_to_core__expr env' e)
    | M_Eif pe e1 e2 ->
       Core.Eif (make_symbol_pexpr pe) 
                (mu_to_core__expr env e1)
                (mu_to_core__expr env e2)
    | M_Eskip ->
       Core.Eskip
    | M_Eccall a (Annotated annots bty ct) pe2 pes ->
       Core.Eccall a 
         (Core.Pexpr annots bty (Core.PEval (Core.Vctype ct)))
         (make_symbol_pexpr pe2) 
         (map make_symbol_pexpr pes)
    | M_Eproc a name pes ->
       Core.Eproc a name (map make_symbol_pexpr pes)
    (* | M_Eunseq es ->
     *    Core.Eunseq (map (mu_to_core__expr env) es) *)
    | M_Ewseq pat e1 e2 ->
       Core.Ewseq pat (mu_to_core__expr env e1) (mu_to_core__expr env e2)
    | M_Esseq pat e1 e2 ->
       Core.Esseq pat (mu_to_core__expr env e1) (mu_to_core__expr env e2)
    (* | M_Easeq (s,bt) a pa ->
     *    Core.Easeq (s,bt) (mu_to_core__action a) (mu_to_core__paction pa) *)
    (* | M_Eindet n e ->
     *    Core.Eindet n (mu_to_core__expr env e) *)
    | M_Ebound n e ->
       Core.Ebound n (mu_to_core__expr env e)
    | M_End es ->
       Core.End (List.map (mu_to_core__expr env) es)
    | M_Esave (sym,bt) sbp e ->
       let sbp = 
         List.map (fun (sym,(bt,pe)) -> (sym,(bt,make_symbol_pexpr pe))) sbp in
       Core.Esave (sym,bt) sbp (mu_to_core__expr env e)
    | M_Erun a sym pes ->
       Core.Erun a sym (map make_symbol_pexpr pes)
    (* | M_Epar es ->
     *    Core.Epar (map (mu_to_core__expr env) es) *)
    (* | M_Ewait tid -> 
     *    Core.Ewait tid *)
  end in
  Core.Expr annots expr_


let mu_to_core__impl_decl (i : mu_impl_decl 'bty) 
    : Core.generic_impl_decl 'bty =
  match i with
  | M_Def bt p -> 
     Core.Def bt (mu_to_core__pexpr Map.empty p)
  | M_IFun bt args body -> 
     Core.IFun bt args (mu_to_core__pexpr Map.empty body)
  end

let mu_to_core__impl (i : mu_impl 'bty) 
    : Core.generic_impl 'bty =
  Map.map mu_to_core__impl_decl i


let mu_to_core__fun_map_decl (d : mu_fun_map_decl 'bty 'a) 
    : Core.generic_fun_map_decl 'bty 'a =
  match d with
  | M_Fun bt args pe ->
     Core.Fun bt args (mu_to_core__pexpr Map.empty pe)
  | M_Proc loc bt args e ->
     Core.Proc loc bt args (mu_to_core__expr Map.empty e)
  | M_ProcDecl loc bt bts ->
     Core.ProcDecl loc bt bts
  | M_BuiltinDecl loc bt bts ->
     Core.BuiltinDecl loc bt bts
  end

let mu_to_core__fun_map (fmap : mu_fun_map 'bty 'a) 
    : Core.generic_fun_map 'bty 'a = 
  Map.map mu_to_core__fun_map_decl fmap
  

let mu_to_core__globs (g : mu_globs 'a 'bty) 
    : Core.generic_globs 'a 'bty = 
  match g with
  | M_GlobalDef bt e -> Core.GlobalDef bt (mu_to_core__expr Map.empty e)
  | M_GlobalDecl bt -> Core.GlobalDecl bt 
  end

(* let mu_to_core__globs_map (g : Core.generic_globs_map 'a bty) 
 *     : mu_globs_map 'a bty = 
 *   Map.map mu_to_core__globs g *)
  
let mu_to_core__globs_list (gs : list (symbol * mu_globs 'a 'bty) )
    : list (symbol * Core.generic_globs 'a 'bty) = 
  List.map (fun (sym,g) -> (sym, mu_to_core__globs g)) gs


let mu_to_core__file file = 
  <| Core.main = file.mu_main
   ; Core.tagDefs = file.mu_tagDefs
   ; Core.stdlib = mu_to_core__fun_map file.mu_stdlib
   ; Core.impl = mu_to_core__impl file.mu_impl
   ; Core.globs = mu_to_core__globs_list file.mu_globs
   ; Core.funs = mu_to_core__fun_map file.mu_funs
   ; Core.extern = file.mu_extern
   ; Core.funinfo = file.mu_funinfo
  |>

