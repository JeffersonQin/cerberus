open import Pervasives

open import Ctype Annot Loc
import Symbol Implementation Undefined Cmm_csem
import Mem Mem_common
(* import Linux *)

import Core

type symbol = Symbol.sym

type mu_object_type = Core.core_object_type

(* although we might drop the BTy_ctype *)
type mu_base_type = Core.core_base_type
(* type core_base_type =  (\* Core base types *\)
 *  | BTy_unit (\* unit *\)
 *  | BTy_boolean (\* boolean *\)
 *  | BTy_ctype (\* Core type of C type exprs *\)
 *  | BTy_list of core_base_type (\* list *\)
 *  | BTy_tuple of list core_base_type (\* tuple *\)
 *  | BTy_object of core_object_type (\* C object value *\)
 *  | BTy_loaded of core_object_type (\* core_object_type or unspecified *\)
 *  | BTy_storable (\* top type for integer/float/pointer/structs (maybe union?). This is only used in the type system *\) *)

(* let rec eq_core_base_type bTy1 bTy2 =
 *   let ord = function
 *     | BTy_unit ->
 *         (0: nat)
 *     | BTy_boolean ->
 *         1
 *     | BTy_ctype ->
 *         2
 *     | BTy_list _ ->
 *         3
 *     | BTy_tuple _ ->
 *         4
 *     | BTy_object _ ->
 *         5
 *     | BTy_loaded _ ->
 *         6
 *     | BTy_storable ->
 *         7
 *   end in
 *   match (bTy1, bTy2) with
 *     | (BTy_list bTy1', BTy_list bTy2') ->
 *         eq_core_base_type bTy1' bTy2'
 *     | (BTy_tuple bTys1, BTy_tuple bTys2) ->
 *         listEqualBy eq_core_base_type bTys1 bTys2
 *     | (BTy_object oTy1, BTy_object oTy2) ->
 *         oTy1 = oTy2
 *     | (BTy_loaded oTy1, BTy_loaded oTy2) ->
 *         oTy1 = oTy2
 *     | _ ->
 *         ord bTy1 = ord bTy2
 *   end
 * instance (Eq core_base_type)
 *   let (=) = eq_core_base_type
 *   let (<>) = fun x y -> not (eq_core_base_type x y)
 * end *)

type mu_name = Core.generic_name symbol

type mu_object_value = Core.generic_object_value symbol
type mu_loaded_value = Core.generic_loaded_value symbol

(* type generic_object_value 'symbol =  (\* C object values *\)
 *  | OVinteger of Mem.integer_value (\* integer value *\)
 *  | OVfloating of Mem.floating_value (\* floating-point value *\)
 *  | OVpointer of Mem.pointer_value (\* pointer value *\)
 *  | OVarray of list (generic_loaded_value 'sym) (\* C array value *\)
 *  | OVstruct of symbol * list (Symbol.identifier * ctype * Mem.mem_value) (\* C struct value *\)
 *  | OVunion of symbol * Symbol.identifier * Mem.mem_value (\* C union value *\) *)

(* and generic_loaded_value 'symbol =  (\* potentially unspecified C object values *\)
 *  | LVspecified of (generic_object_value 'sym) (\* non-unspecified loaded value *\)
 *  | LVunspecified of ctype (\* unspecified loaded value *\) *)



(* although, again, we might remove something from the definition
   here, e.g. Vctype *)
type mu_value = Core.generic_value symbol

(* type generic_value 'symbol =  (\* Core values *\)
 *  | Vobject of (generic_object_value 'sym) (\* C object value *\)
 *  | Vloaded of (generic_loaded_value 'sym) (\* loaded C object value *\)
 *  | Vunit
 *  | Vtrue
 *  | Vfalse
 *  | Vctype of ctype (\* C type as value *\)
 *  | Vlist of core_base_type * list (generic_value 'sym)
 *  | Vtuple of list (generic_value 'sym) (\* tuple *\) *)


type mu_ctor 'bty = Core.generic_ctor 'bty

type mu_pattern_ 'bty = Core.generic_pattern_ 'bty symbol
type mu_pattern 'bty = Core.generic_pattern 'bty symbol

type mu_pexpr_ 'bty =  (* Core pure expressions *)
 | M_PEsym of symbol
 | M_PEimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | M_PEval of mu_value
 | M_PEconstrained of list (Mem.mem_iv_constraint * symbol) (* constrained value *)
 | M_PEundef of Loc.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_PEerror of string * symbol (* impl-defined static error *)
 | M_PEctor of mu_ctor 'bty * list symbol (* data constructor application *)
 | M_PEcase of symbol * list ((mu_pattern 'bty) * (mu_pexpr 'bty)) (* pattern matching *)
 | M_PEarray_shift of symbol * ctype * symbol (* pointer array shift *)
 | M_PEmember_shift of symbol * symbol * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of symbol (* boolean not *)
 | M_PEop of Core.binop * symbol * symbol
 | M_PEstruct of symbol * list (Symbol.identifier * symbol) (* C struct expression *)
 | M_PEunion of symbol * Symbol.identifier * symbol (* C union expression *)
 | M_PEcfunction of symbol (* C function pointer expression *)
 | M_PEmemberof of symbol * Symbol.identifier * symbol (* C struct/union member access *)
 | M_PEcall of mu_name * list symbol (* pure function call *)
 | M_PElet of (mu_pattern 'bty) * (mu_pexpr 'bty) * (mu_pexpr 'bty) (* pure let *)
 | M_PEif of symbol * (mu_pexpr 'bty) * (mu_pexpr 'bty) (* pure if *)
 | M_PEis_scalar of symbol
 | M_PEis_integer of symbol
 | M_PEis_signed of symbol
 | M_PEbmc_assume of symbol
 | M_PEis_unsigned of symbol
 (* | M_PEbmc_assume of symbol *)
 | M_PEare_compatible of symbol * symbol

and mu_pexpr 'bty = 
 | M_Pexpr of list annot * 'bty * (mu_pexpr_ 'bty)


type mu_action_ 'bty =  (* memory actions *)
 | M_Create of symbol * symbol * Symbol.prefix
 | M_CreateReadOnly of symbol * symbol * symbol * Symbol.prefix
 | M_Alloc of symbol * symbol * Symbol.prefix
 | M_Kill of bool * symbol (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | M_Store of bool * symbol * symbol * symbol * Cmm_csem.memory_order (* the boolean indicates whether the store is locking *)
 | M_Load of symbol * symbol * Cmm_csem.memory_order
 | M_RMW of symbol * symbol * symbol * symbol * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_Fence of Cmm_csem.memory_order
 | M_CompareExchangeStrong of symbol * symbol * symbol * symbol * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_CompareExchangeWeak of symbol * symbol * symbol * symbol * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_LinuxFence of Linux.linux_memory_order
 | M_LinuxLoad of symbol * symbol * Linux.linux_memory_order
 | M_LinuxStore of symbol * symbol * symbol * Linux.linux_memory_order
 | M_LinuxRMW of symbol * symbol * symbol * Linux.linux_memory_order


type mu_action 'a 'bty = 
 | M_Action of Loc.t * 'a * (mu_action_ 'bty)


type mu_paction 'a 'bty =  (* memory actions with Core.polarity *)
 | M_Paction of Core.polarity * (mu_action 'a 'bty)

type mu_expr_ 'a 'bty =  (* (effectful) expression *)
 | M_Epure of (mu_pexpr 'bty)
 | M_Ememop of Mem_common.memop * list symbol (* pointer op involving memory *)
 | M_Eaction of (mu_paction 'a 'bty) (* memory action *)
 | M_Ecase of symbol * list ((mu_pattern 'bty) * (mu_expr 'a 'bty)) (* pattern matching *)
 | M_Elet of (mu_pattern 'bty) * (mu_pexpr 'bty) * (mu_expr 'a 'bty)
 | M_Eif of symbol * (mu_expr 'a 'bty) * (mu_expr 'a 'bty)
 | M_Eskip
 | M_Eccall of 'a * symbol * symbol * list symbol (* C function call *)
 | M_Eproc of 'a * mu_name * list symbol (* Core procedure call *)
 | M_Eunseq of list (mu_expr 'a 'bty) (* unsequenced expressions *)
 | M_Ewseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* weak sequencing *)
 | M_Esseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* strong sequencing *)
 | M_Easeq of (symbol * mu_base_type) * (mu_action 'a 'bty) * (mu_paction 'a 'bty) (* atomic sequencing *)
 | M_Eindet of nat * (mu_expr 'a 'bty) (* indeterminately sequenced expr *)
 | M_Ebound of nat * (mu_expr 'a 'bty) (* $\ldots$and boundary *)
 | M_End of list (mu_expr 'a 'bty) (* nondeterministic sequencing *)
 | M_Esave of (symbol * mu_base_type) * list (symbol * (mu_base_type * symbol)) * (mu_expr 'a 'bty) (* save label *)
 | M_Erun of 'a * symbol * list symbol (* run from label *)
 | M_Epar of list (mu_expr 'a 'bty) (* cppmem-like thread creation *)
 | M_Ewait of Mem_common.thread_id (* wait for thread termination *)

and mu_expr 'a 'bty = 
 | M_Expr of list annot * (mu_expr_ 'a 'bty)

type mu_impl_decl 'bty =
  | M_Def of mu_base_type * mu_pexpr 'bty
  | M_IFun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty

type mu_impl 'bty = map Implementation.implementation_constant (mu_impl_decl 'bty)

type mu_fun_map_decl 'bty 'a =
  | M_Fun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty
  | M_Proc of Loc.t * mu_base_type * list (symbol * mu_base_type) * mu_expr 'a 'bty
  | M_ProcDecl of Loc.t * mu_base_type * list mu_base_type
  | M_BuiltinDecl of Loc.t * mu_base_type * list mu_base_type

type mu_fun_map 'bty 'a = map symbol (mu_fun_map_decl 'bty 'a)

instance forall 'bty. (Located (mu_pexpr 'bty))
  let locOf pe =
    let (M_Pexpr annots _ _) = pe in
    get_loc_ annots
end

instance forall 'a 'bty. (Located (mu_expr 'a 'bty))
  let locOf e =
    let (M_Expr annots _) = e in
    get_loc_ annots
end


type mu_linking_kind = Core.linking_kind

type mu_extern_map = Core.extern_map

type mu_globs 'a 'bty=
  | M_GlobalDef of mu_base_type * mu_expr 'a 'bty
  | M_GlobalDecl of mu_base_type

type mu_globs_map 'a 'bty =
  map symbol (mu_globs 'a 'bty)

type mu_tag_definitions = Core.core_tag_definitions

(* a Core file is just a set of named functions *)
type mu_file 'bty 'a = <|
  mu_main    : maybe symbol;
  mu_tagDefs : mu_tag_definitions;
  mu_stdlib  : mu_fun_map 'bty 'a;
  mu_impl    : mu_impl 'bty;
  mu_globs   : list (symbol * mu_globs 'a 'bty);
  mu_funs    : mu_fun_map 'bty 'a;
  mu_extern  : mu_extern_map;
  mu_funinfo : map symbol (Loc.t * Annot.attributes * ctype * list (maybe symbol * ctype) * bool * bool);
|>




open import Assert_extra
import Pp

let mapsnd (f : 'b -> 'c) (l : list ('a * 'b)) : list ('a * 'c) = 
  List.map (fun (a,b) -> (a, f b)) l

(* for error reporting *)
type outer 'a 'bty = 
  | PEXPR of Core.generic_pexpr 'bty symbol
  | ACTION of Core.generic_action_ 'bty symbol
  | EXPR of Core.generic_expr 'a 'bty symbol
  | NONE

val print_endline : string -> unit
declare ocaml target_rep function print_endline = `print_endline`

let pexpr_error 
      (err : string) 
      (outer : outer 'a 'bty)
      (pexpr : Core.generic_pexpr 'bty symbol) = 
  let outer = match outer with
    | PEXPR outer -> "outer: " ^ Pp.stringFromCore_pexpr outer
    | ACTION outer -> "outer: " ^ Pp.stringFromCore_action outer
    | EXPR outer -> "outer: " ^ Pp.stringFromCore_expr outer
    | NONE -> "outer: NONE"
  end in
  let err = "inner: " ^ Pp.stringFromCore_pexpr pexpr ^ "\n" ^ outer in
  let () = print_endline err in
  failwith "not a symbol"

let ensure_symbol 
      (outer : outer 'a 'bty)
      (pexpr : Core.generic_pexpr 'bty symbol)
    : symbol = 
  let (Core.Pexpr _annots _bty pexpr_) = pexpr in
  match pexpr_ with
  | Core.PEsym s -> s
  | _ -> pexpr_error "not a symbol" outer pexpr
  end

let rec core_to_mu__pexpr (pexpr : Core.generic_pexpr 'bty symbol)
        : mu_pexpr 'bty =
  let (Core.Pexpr annots bty pexpr_) = pexpr in
  let ensure_symbol = ensure_symbol (PEXPR pexpr : outer unit 'bty) in
  let pexpr_ = match pexpr_ with
    | Core.PEsym s -> 
       M_PEsym s
    | Core.PEimpl ic -> 
       M_PEimpl ic
    | Core.PEval v -> 
       M_PEval v
    | Core.PEconstrained l -> 
       let l = mapsnd ensure_symbol l in
       M_PEconstrained l
    | Core.PEundef loc undef ->
       M_PEundef loc undef
    | Core.PEerror err p -> 
       M_PEerror err (ensure_symbol p)
    | Core.PEctor ctor pes -> 
       M_PEctor ctor (map ensure_symbol pes)
    | Core.PEcase p pats ->
       let pats = mapsnd core_to_mu__pexpr pats in
       M_PEcase (ensure_symbol p) pats
    | Core.PEarray_shift pe1 ctype pe2 ->
       M_PEarray_shift (ensure_symbol pe1) ctype (ensure_symbol pe2)
    | Core.PEmember_shift p s id  ->
       M_PEmember_shift (ensure_symbol p) s id
    | Core.PEnot p ->
       M_PEnot (ensure_symbol p)
    | Core.PEop binop p1 p2 ->
       M_PEop binop (ensure_symbol p1) (ensure_symbol p2)
    | Core.PEstruct sym fields ->
       let fields = mapsnd ensure_symbol fields in
       M_PEstruct sym fields
    | Core.PEunion sym id p ->
       M_PEunion sym id (ensure_symbol p)
    | Core.PEcfunction f ->
       M_PEcfunction (ensure_symbol f)
    | Core.PEmemberof sym id p ->
       M_PEmemberof sym id (ensure_symbol p)
    | Core.PEcall name args ->
       M_PEcall name (map ensure_symbol args)
    | Core.PElet pat p1 p2 ->
       M_PElet pat (core_to_mu__pexpr p1) (core_to_mu__pexpr p2)
    | Core.PEif p0 p1 p2 ->
       M_PEif (ensure_symbol p0) (core_to_mu__pexpr p1) (core_to_mu__pexpr p2)
    | Core.PEis_scalar p ->
       M_PEis_scalar (ensure_symbol p)
    | Core.PEis_integer p ->
       M_PEis_integer (ensure_symbol p)
    | Core.PEis_signed p ->
       M_PEis_signed (ensure_symbol p)
    | Core.PEis_unsigned p ->
       M_PEis_unsigned (ensure_symbol p)
    | Core.PEbmc_assume e ->
       M_PEbmc_assume (ensure_symbol e)
    | Core.PEare_compatible p1 p2 ->
       M_PEare_compatible (ensure_symbol p1) (ensure_symbol p2)
  end in
  M_Pexpr annots bty pexpr_

let core_to_mu__action_ (action_ : Core.generic_action_ 'bty symbol)
        : mu_action_ 'bty =
  let ensure_symbol = ensure_symbol (ACTION action_ : outer unit 'bty) in
  match action_ with
  | Core.Create p1 p2 prefix ->
     M_Create (ensure_symbol p1) (ensure_symbol p2) prefix
  | Core.CreateReadOnly p1 p2 p3 prefix ->
     M_CreateReadOnly (ensure_symbol p2) (ensure_symbol p2) 
       (ensure_symbol p3) prefix
  | Core.Alloc p1 p2 prefix ->
     M_Alloc (ensure_symbol p1) (ensure_symbol p2) prefix
  | Core.Kill b p ->
     M_Kill b (ensure_symbol p)
  | Core.Store b p1 p2 p3 mo ->
     M_Store b (ensure_symbol p1) (ensure_symbol p2) 
       (ensure_symbol p3) mo
  | Core.Load p1 p2 mo ->
     M_Load (ensure_symbol p1) (ensure_symbol p2) mo
  | Core.RMW p1 p2 p3 p4 mo1 mo2 ->
     M_RMW (ensure_symbol p1) (ensure_symbol p2) 
       (ensure_symbol p3) (ensure_symbol p4) mo1 mo2
  | Core.Fence mo ->
     M_Fence mo
  | Core.CompareExchangeStrong p1 p2 p3 p4 mo1 mo2 ->
     M_CompareExchangeStrong (ensure_symbol p1) (ensure_symbol p2) 
       (ensure_symbol p3) (ensure_symbol p4) mo1 mo2
  | Core.CompareExchangeWeak p1 p2 p3 p4 mo1 mo2 ->
     M_CompareExchangeWeak (ensure_symbol p1) (ensure_symbol p2) 
       (ensure_symbol p3) (ensure_symbol p4) mo1 mo2
  | Core.LinuxFence mo ->
     M_LinuxFence mo
  | Core.LinuxLoad p1 p2 mo ->
     M_LinuxLoad (ensure_symbol p1) (ensure_symbol p2) mo
  | Core.LinuxStore p1 p2 p3 mo ->
     M_LinuxStore (ensure_symbol p1) (ensure_symbol p2) 
       (ensure_symbol p3) mo
  | Core.LinuxRMW p1 p2 p3 mo ->
     M_LinuxRMW (ensure_symbol p1) (ensure_symbol p2) 
       (ensure_symbol p3) mo
  end

let core_to_mu__action (Core.Action t a action_) = 
  M_Action t a (core_to_mu__action_ action_)

let core_to_mu__paction (Core.Paction p action) = 
  M_Paction p (core_to_mu__action action)

let rec core_to_mu__expr (expr : Core.generic_expr 'a 'bty symbol)
        : mu_expr 'a 'bty =
  let (Core.Expr annots expr_) = expr in
  let ensure_symbol = ensure_symbol (EXPR expr) in
  let expr_ = match expr_ with
    | Core.Epure p -> 
       M_Epure (core_to_mu__pexpr p)
    | Core.Ememop memop pexprs ->
       M_Ememop memop (map ensure_symbol pexprs)
    | Core.Eaction pa ->
       M_Eaction (core_to_mu__paction pa)
    | Core.Ecase pe es ->
       M_Ecase (ensure_symbol pe) (mapsnd core_to_mu__expr es)
    | Core.Elet pat pe e ->
       M_Elet pat (core_to_mu__pexpr pe) (core_to_mu__expr e)
    | Core.Eif pe e1 e2 ->
       M_Eif (ensure_symbol pe) (core_to_mu__expr e1) (core_to_mu__expr e2)
    | Core.Eskip ->
       M_Eskip
    | Core.Eccall a pe1 pe2 pes ->
       M_Eccall a (ensure_symbol pe1) (ensure_symbol pe2) 
         (map ensure_symbol pes)
    | Core.Eproc a name pes ->
       M_Eproc a name (map ensure_symbol pes)
    | Core.Eunseq es ->
       M_Eunseq (map core_to_mu__expr es)
    | Core.Ewseq pat e1 e2 ->
       M_Ewseq pat (core_to_mu__expr e1) (core_to_mu__expr e2)
    | Core.Esseq pat e1 e2 ->
       M_Esseq pat (core_to_mu__expr e1) (core_to_mu__expr e2)
    | Core.Easeq (s,bt) a pa ->
       M_Easeq (s,bt) (core_to_mu__action a) (core_to_mu__paction pa)
    | Core.Eindet n e ->
       M_Eindet n (core_to_mu__expr e)
    | Core.Ebound n e ->
       M_Ebound n (core_to_mu__expr e)
    | Core.End es ->
       M_End (List.map core_to_mu__expr es)
    | Core.Esave (sym,bt) sbp e ->
       let sbp = 
         List.map (fun (sym,(bt,pe)) -> (sym,(bt,ensure_symbol pe))) sbp in
       M_Esave (sym,bt) sbp (core_to_mu__expr e)
    | Core.Erun a sym pes ->
       M_Erun a sym (List.map ensure_symbol pes)
    | Core.Epar es ->
       M_Epar (List.map core_to_mu__expr es)
    | Core.Ewait tid -> 
       M_Ewait tid
  end in
  M_Expr annots expr_


let core_to_mu__impl_decl (i : Core.generic_impl_decl 'bty) 
    : mu_impl_decl 'bty =
  match i with
  | Core.Def bt p -> 
     M_Def bt (core_to_mu__pexpr p)
  | Core.IFun bt args body -> 
     M_IFun bt args (core_to_mu__pexpr body)
  end

let core_to_mu__impl (i : Core.generic_impl 'bty) 
    : mu_impl 'bty =
  Map.map core_to_mu__impl_decl i


let core_to_mu__fun_map_decl (d : Core.generic_fun_map_decl 'bty 'a) 
    : mu_fun_map_decl 'bty 'a =
  match d with
  | Core.Fun bt args pe ->
     M_Fun bt args (core_to_mu__pexpr pe)
  | Core.Proc loc bt args e ->
     M_Proc loc bt args (core_to_mu__expr e)
  | Core.ProcDecl loc bt bts ->
     M_ProcDecl loc bt bts
  | Core.BuiltinDecl loc bt bts ->
     M_BuiltinDecl loc bt bts
  end

let core_to_mu__fun_map (fmap : Core.generic_fun_map 'bty 'a) 
    : mu_fun_map 'bty 'a = 
  Map.map core_to_mu__fun_map_decl fmap
  

let core_to_mu__globs (g : Core.generic_globs 'a 'bty) 
    : mu_globs 'a 'bty = 
  match g with
  | Core.GlobalDef bt e -> M_GlobalDef bt (core_to_mu__expr e)
  | Core.GlobalDecl bt -> M_GlobalDecl bt 
  end

(* let core_to_mu__globs_map (g : Core.generic_globs_map 'a 'bty) 
 *     : mu_globs_map 'a 'bty = 
 *   Map.map core_to_mu__globs g *)
  
let core_to_mu__globs_list (gs : list (symbol * Core.generic_globs 'a 'bty) )
    : list (symbol * mu_globs 'a 'bty) = 
  List.map (fun (sym,g) -> (sym, core_to_mu__globs g)) gs


let core_to_mu__file file = 
  <| mu_main = file.Core.main
   ; mu_tagDefs = file.Core.tagDefs
   ; mu_stdlib = core_to_mu__fun_map file.Core.stdlib
   ; mu_impl = core_to_mu__impl file.Core.impl
   ; mu_globs = core_to_mu__globs_list file.Core.globs
   ; mu_funs = core_to_mu__fun_map file.Core.funs
   ; mu_extern = file.Core.extern
   ; mu_funinfo = file.Core.funinfo
  |>

