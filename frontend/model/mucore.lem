open import Pervasives

open import Ctype Annot Loc
import Symbol Implementation Undefined Cmm_csem
open import Mem Mem_common
(* import Linux *)

import Core
open import Core_aux

open import Assert_extra


val better_error_messages : forall 'a. string -> 'a -> 'a
declare ocaml target_rep function better_error_messages message a = 
  `try` a `with | Failure error -> failwith (` message ` ^ error) `





type symbol = Symbol.sym
type mu_object_type = Core.core_object_type
type mu_base_type = Core.core_base_type
(* type bty = mu_base_type *)
type mu_name = Core.generic_name symbol

type annotated 'a 'bty = Annotated of list Annot.annot * 'bty * 'a
let a_unpack (Annotated _ _ a) = a

type asym 'bty = annotated Symbol.sym 'bty
type actype 'bty = annotated ctype 'bty

(* type mv_tsymbol = tsymbol       (\* Mem.mem_value *\) *)
type ov_asym 'bty = asym 'bty       (* object_value *)
type lv_asym 'bty = asym 'bty       (* loaded_value *)
type va_asym 'bty = asym 'bty       (* value *)




let unspec_undef = Undefined.DUMMY "unspecified value"



type mu_object_value 'bty =  (* C object values *)
 | M_OVinteger of Mem.integer_value (* integer value *)
 | M_OVfloating of Mem.floating_value (* floating-point value *)
 | M_OVpointer of Mem.pointer_value (* pointer value *)
 | M_OVarray of list (lv_asym 'bty) (* C array value *)
 | M_OVstruct of symbol * list (Symbol.identifier * ctype * Mem.mem_value) (* C struct value *)
 | M_OVunion of symbol * Symbol.identifier * Mem.mem_value (* C union value *)

type mu_loaded_value 'bty =  (* potentially unspecified C object values *)
 | M_LVspecified of mu_object_value 'bty (* non-unspecified loaded value *)
 | M_LVunspecified of ctype (* unspecified loaded value *)


(* again, we might remove something from the definition here,
   e.g. Vctype *)
type mu_value 'bty =  (* Core values *)
 | M_Vobject of mu_object_value 'bty (* C object value *)
 | M_Vloaded of mu_loaded_value 'bty (* loaded C object value *)
 | M_Vunit
 | M_Vtrue
 | M_Vfalse
 (* | M_Vctype of ctype (\* C type as value *\) *)
 | M_Vlist of Core.core_base_type * list (asym 'bty)
 | M_Vtuple of list (asym 'bty) (* tuple *)



type mu_ctor 'bty = Core.generic_ctor 'bty


type mu_pattern_ 'bty = Core.generic_pattern_ 'bty symbol
type mu_pattern 'bty = Core.generic_pattern 'bty symbol

type mu_sym_or_pattern 'bty = 
  | M_symbol of annotated symbol 'bty
  | M_normal_pattern of mu_pattern 'bty


type mu_pexpr_ 'bty =  (* Core pure expressions *)
 | M_PEsym of symbol
 | M_PEimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | M_PEval of mu_value 'bty
 | M_PEconstrained of list (Mem.mem_iv_constraint * asym 'bty) (* constrained value *)
 | M_PEundef of Loc.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_PEerror of string * asym 'bty (* impl-defined static error *)
 | M_PEctor of mu_ctor 'bty * list (asym 'bty) (* data constructor application *)
 | M_PEcase of (asym 'bty) * list ((mu_pattern 'bty) * mu_pexpr 'bty) (* pattern matching *)
 | M_PEarray_shift of (asym 'bty) * ctype * (asym 'bty) (* pointer array shift *)
 | M_PEmember_shift of (asym 'bty) * symbol * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of asym 'bty (* boolean not *)
 | M_PEop of Core.binop * (asym 'bty) * (asym 'bty)
 | M_PEstruct of symbol * list (Symbol.identifier * asym 'bty) (* C struct expression *)
 | M_PEunion of symbol * Symbol.identifier * asym 'bty (* C union expression *)
 (* | M_PEcfunction of asym 'bty (\* C function pointer expression *\) *)
 | M_PEmemberof of symbol * Symbol.identifier * asym 'bty (* C struct/union member access *)
 | M_PEcall of mu_name * list (asym 'bty) (* pure function call *)
 | M_PElet of (mu_sym_or_pattern 'bty) * (mu_pexpr 'bty) * (mu_pexpr 'bty) (* pure let *)
 | M_PEif of asym 'bty * asym 'bty * asym 'bty (* pure if *)
 (* | M_PEis_scalar of asym 'bty
  * | M_PEis_integer of asym 'bty
  * | M_PEis_signed of asym 'bty
  * | M_PEbmc_assume of asym 'bty
  * | M_PEis_unsigned of asym 'bty
  * | M_PEare_compatible of asym 'bty * asym 'bty *)

 | M_PEensure_specified of asym 'bty * mu_base_type

and mu_pexpr 'bty = 
 | M_Pexpr of list annot * 'bty * (mu_pexpr_ 'bty)



type mu_action_ 'bty =  (* memory actions *)
 | M_Create of asym 'bty * actype 'bty * Symbol.prefix
 | M_CreateReadOnly of asym 'bty * actype 'bty * asym 'bty * Symbol.prefix
 | M_Alloc of actype 'bty * asym 'bty * Symbol.prefix
 | M_Kill of bool * asym 'bty (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | M_Store of bool * actype 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order (* the boolean indicates whether the store is locking *)
 | M_Load of actype 'bty * asym 'bty * Cmm_csem.memory_order
 | M_RMW of actype 'bty * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_Fence of Cmm_csem.memory_order
 | M_CompareExchangeStrong of actype 'bty * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_CompareExchangeWeak of actype 'bty * asym 'bty * asym 'bty * asym 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_LinuxFence of Linux.linux_memory_order
 | M_LinuxLoad of actype 'bty * asym 'bty * Linux.linux_memory_order
 | M_LinuxStore of actype 'bty * asym 'bty * asym 'bty * Linux.linux_memory_order
 | M_LinuxRMW of actype 'bty * asym 'bty * asym 'bty * Linux.linux_memory_order


type mu_action 'a 'bty = 
 | M_Action of Loc.t * 'a * (mu_action_ 'bty)


type mu_paction 'a 'bty =  (* memory actions with Core.polarity *)
 | M_Paction of Core.polarity * (mu_action 'a 'bty)

type mu_memop 'bty =
  | M_PtrEq of (asym 'bty * asym 'bty)
  | M_PtrNe of (asym 'bty * asym 'bty)
  | M_PtrLt of (asym 'bty * asym 'bty)
  | M_PtrGt of (asym 'bty * asym 'bty)
  | M_PtrLe of (asym 'bty * asym 'bty)
  | M_PtrGe of (asym 'bty * asym 'bty)
  | M_Ptrdiff of (actype 'bty * asym 'bty * asym 'bty)
  | M_IntFromPtr of (actype 'bty * asym 'bty)
  | M_PtrFromInt of (actype 'bty * asym 'bty)
  | M_PtrValidForDeref of (actype 'bty * asym 'bty  )
  | M_PtrWellAligned of (actype 'bty * asym 'bty  )
  | M_PtrArrayShift of (asym 'bty * actype 'bty * asym 'bty  )
  | M_Memcpy of (asym 'bty * asym 'bty * asym 'bty)
  | M_Memcmp of (asym 'bty * asym 'bty * asym 'bty)
  | M_Realloc of (asym 'bty * asym 'bty * asym 'bty)
  | M_Va_start  of (asym 'bty * asym 'bty)
  | M_Va_copy of (asym 'bty)
  | M_Va_arg of (asym 'bty * actype 'bty)
  | M_Va_end of (asym 'bty)

type mu_expr_ 'a 'bty =  (* (effectful) expression *)
 | M_Epure of (mu_pexpr 'bty)
 | M_Ememop of mu_memop 'bty
 | M_Eaction of (mu_paction 'a 'bty) (* memory action *)
 | M_Ecase of asym 'bty * list ((mu_pattern 'bty) * (mu_expr 'a 'bty)) (* pattern matching *)
 | M_Elet of (mu_sym_or_pattern 'bty) * (mu_pexpr 'bty) * (mu_expr 'a 'bty)
 | M_Eif of asym 'bty * (mu_expr 'a 'bty) * (mu_expr 'a 'bty)
 | M_Eskip
 | M_Eccall of 'a * (actype 'bty) * asym 'bty * list (asym 'bty) (* C function call *)
 | M_Eproc of 'a * mu_name * list (asym 'bty) (* Core procedure call *)
 (* | M_Eunseq of list (mu_expr 'a 'bty) (\* unsequenced expressions *\) *)
 | M_Ewseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* weak sequencing *)
 | M_Esseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* strong sequencing *)
 (* | M_Easeq of (symbol * mu_base_type) * (mu_action 'a 'bty) * (mu_paction 'a 'bty) (\* atomic sequencing *\) *)
 (* | M_Eindet of nat * (mu_expr 'a 'bty) (\* indeterminately sequenced expr *)
 | M_Ebound of nat * (mu_expr 'a 'bty) (* $\ldots$and boundary *)
 | M_End of list (mu_expr 'a 'bty) (* nondeterministic choice *)
 | M_Esave of (symbol * mu_base_type) * list (symbol * (mu_base_type * asym 'bty)) * (mu_expr 'a 'bty) (* save label *)
 | M_Erun of 'a * symbol * list (asym 'bty) (* run from label *)
 (* | M_Epar of list (mu_expr 'a 'bty) (\* cppmem-like thread creation *\) *)
 (* | M_Ewait of Mem_common.thread_id (\* wait for thread termination *\) *)

and mu_expr 'a 'bty = 
 | M_Expr of list annot * (mu_expr_ 'a 'bty)




let embed_pexpr_expr pe = 
  let (M_Pexpr annots _bty _) = pe in
  M_Expr annots (M_Epure pe)


type mu_impl_decl 'bty =
  | M_Def of mu_base_type * mu_pexpr 'bty
  | M_IFun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty

type mu_impl 'bty = map Implementation.implementation_constant (mu_impl_decl 'bty)

type mu_fun_map_decl 'bty 'a =
  | M_Fun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty
  | M_Proc of Loc.t * mu_base_type * list (symbol * mu_base_type) * mu_expr 'a 'bty
  | M_ProcDecl of Loc.t * mu_base_type * list mu_base_type
  | M_BuiltinDecl of Loc.t * mu_base_type * list mu_base_type

type mu_fun_map 'bty 'a = map symbol (mu_fun_map_decl 'bty 'a)

instance forall 'bty. (Located (mu_pexpr 'bty))
  let locOf pe =
    let (M_Pexpr annots _ _) = pe in
    get_loc_ annots
end

instance forall 'a 'bty. (Located (mu_expr 'a 'bty))
  let locOf e =
    let (M_Expr annots _) = e in
    get_loc_ annots
end


type mu_linking_kind = Core.linking_kind

type mu_extern_map = Core.extern_map

type mu_globs 'a 'bty=
  | M_GlobalDef of mu_base_type * mu_expr 'a 'bty
  | M_GlobalDecl of mu_base_type

type mu_globs_map 'a 'bty =
  map symbol (mu_globs 'a 'bty)

type mu_tag_definitions = Core.core_tag_definitions

(* a Core file is just a set of named functions *)
type mu_file 'bty 'a = <|
  mu_main    : maybe symbol;
  mu_tagDefs : mu_tag_definitions;
  mu_stdlib  : mu_fun_map 'bty 'a;
  mu_impl    : mu_impl 'bty;
  mu_globs   : list (symbol * mu_globs 'a 'bty);
  mu_funs    : mu_fun_map 'bty 'a;
  mu_extern  : mu_extern_map;
  mu_funinfo : map symbol (Loc.t * Annot.attributes * ctype * list (maybe symbol * ctype) * bool * bool);
|>




let mapsnd (f : 'b -> 'c) (l : list ('a * 'b)) : list ('a * 'c) = 
  map (fun (a,b) -> (a, f b)) l


type env 'bty = map symbol (Core.generic_pexpr 'bty symbol)

let insert_symbol sym v env =
  Map.insert sym v env

let get_pexpr _where env asym = 
  let (Annotated annots bty sym) = asym in
  match Map.lookup sym env with
  | Just pexpr -> pexpr
  | Nothing -> Core.Pexpr annots bty (Core.PEsym sym)
  end

let get_loaded_value env asym = 
  let sym = a_unpack asym in
  match Map.lookup sym env with
  | Just (Core.Pexpr _ _ (Core.PEval (Core.Vloaded lv))) -> lv
  | Just _ -> failwith "not a loaded value"
  | Nothing -> failwith ("get_loaded_value: " ^ show sym ^ " not found")
  end

let get_object_value env asym = 
  let sym = a_unpack asym in
  match lookup sym env with
  | Just (Core.Pexpr _ _ (Core.PEval (Core.Vobject ov))) -> ov
  | Just _ -> failwith "not an object value"
  | Nothing -> failwith ("get_object_value: " ^ show sym ^ " not found")
  end

let get_value env asym = 
  let sym = a_unpack asym in
  match Map.lookup sym env with
  | Just (Core.Pexpr _ _ (Core.PEval v)) -> v
  | Just _ -> failwith "not an object value"
  | Nothing -> failwith ("get_value: " ^ show sym ^ " not found")
  end


let make_symbol_pexpr (Annotated annots bty sym) : Core.generic_pexpr 'bty symbol =
  Core.Pexpr annots bty (Core.PEsym sym)

let make_ctype_pexpr (Annotated annots bty ctype) : Core.generic_pexpr 'bty symbol =
  Core.Pexpr annots bty (Core.PEval (Core.Vctype ctype))


let rec mu_to_core__object_value (env : env 'bty) ov = 
  match ov with
  | M_OVinteger iv -> Core.OVinteger iv
  | M_OVfloating fv -> Core.OVfloating fv
  | M_OVpointer ov -> Core.OVpointer ov
  | M_OVstruct s is -> Core.OVstruct s is
  | M_OVunion s i mv -> Core.OVunion s i mv
  | M_OVarray is ->
     let is = map (get_loaded_value env) is in
     Core.OVarray is
  end

and mu_to_core__loaded_value (env : env 'bty) lv = 
  match lv with
  | M_LVspecified ov ->
     Core.LVspecified (mu_to_core__object_value env ov)
  | M_LVunspecified ct -> Core.LVunspecified ct
  end


let rec mu_to_core__value (env : env 'bty) (v : mu_value 'bty)
        : Core.generic_value symbol =
  match v with
  | M_Vobject ov -> Core.Vobject (mu_to_core__object_value env ov)
  | M_Vloaded lv -> Core.Vloaded (mu_to_core__loaded_value env lv)
  | M_Vunit -> Core.Vunit
  | M_Vtrue -> Core.Vtrue
  | M_Vfalse -> Core.Vfalse
  (* | M_Vctype ct -> Core.Vctype ct *)
  | M_Vlist cbt is -> 
     let is = map (get_value env) is in
     Core.Vlist cbt is
  | M_Vtuple is ->
     let is = map (get_value env) is in
     Core.Vtuple is
  end
  

(* let maybe_extend_env (env : env 'bty) sym (pe : mu_pexpr 'bty) = 
 *   match pat_ with
 *   | M_UT_CaseBase sym  -> insert_symbol sym pe env
 *   | _ -> env
 *   end *)

(* let rec mu_to_core__pattern (M_Pattern annots pattern_) =
 *   match pattern_ with
 *   | M_CaseBase (sym, Just bty) -> 
 *      Core.Pattern annots (Core.CaseBase (sym, bty))
 *   | M_CaseBase (sym, nothing) -> 
 *      failwith "pattern with no core base type"
 *   | M_CaseCtor ctor pats ->
 *      let pats = map mu_to_core__pattern pats in
 *      Core.Pattern annots (Core.CaseCtor ctor pats)
 *   end *)


(* let replace_ensure_specified annots asym pat_bty 
 * 
 *  (sym, pat_annots, pat_cbt) (e_spec, e_annots, e_cbt) = 
 *   let sym_pat = mk_sym_pat_ pat_annots (Just sym) pat_cbt in
 *   let spec_pat = mk_specified_pat_ pat_annots sym_pat in
 *   let wild_card = mk_sym_pat_ pat_annots Nothing pat_cbt in
 *   let unspec_pat = mk_unspecified_pat_ pat_annots wild_card in
 *   let e_unspec = Core.Pexpr e_annots e_cbt (Core.PEundef (Annot.get_loc_ e_annots) unspec_undef) in
 *   let pats_pes = [(spec_pat, e_spec); (unspec_pat, e_unspec)] in
 *   pats_pes
 * 
 * 
 *         (\* let sym1_pat = Core.Pattern annots1 (Core.CaseBase (Just sym1, cbt)) in
 *          * let spec_pat = Core.Pattern annots1 (Core.CaseCtor Core.Cspecified [sym1_pat]) in
 *          * let wild_card = Core.Pattern annots1 (Core.CaseBase (Nothing, cbt)) in
 *          * let unspec_pat = Core.Pattern annots1 (Core.CaseCtor Core.Cunspecified [wild_card]) in
 *          * let undef_e = Core.Pexpr annots1 bty1 (Core.PEundef (locOf pexpr) unspec_undef) in
 *          * let p2 = mu_to_core__pexpr env p2 in
 *          * let pats_pes = [(spec_pat, p2); (unspec_pat, undef_e)] in *\)
 *         let e = get_pexpr asym2 in
 *         wrap (Core.PEcase e pats_pes) *)



let rec mu_to_core__pexpr (env : env 'bty) (pexpr : mu_pexpr 'bty)
        : Core.generic_pexpr 'bty symbol =
  let (M_Pexpr annots bty pexpr_) = pexpr in
  let wrap pexpr_ = Core.Pexpr annots bty pexpr_ in
  match pexpr_ with
  | M_PEsym s ->
     wrap (Core.PEsym s)
  | M_PEimpl ic -> 
     wrap (Core.PEimpl ic)
  | M_PEval v -> 
     wrap (Core.PEval (mu_to_core__value env v))
  | M_PEconstrained l -> 
     let l = mapsnd (get_pexpr "PEconstrained" env) l in
     wrap (Core.PEconstrained l)
  | M_PEundef loc undef ->
     wrap (Core.PEundef loc undef)
  | M_PEerror err p -> 
     wrap (Core.PEerror err (get_pexpr "PEerror" env p))
  | M_PEctor ctor pes -> 
     wrap (Core.PEctor ctor (map (get_pexpr "PEctor" env) pes))
  | M_PEcase p pats_pes ->
     let pats_pes = 
       map (fun (pat,e) -> (pat, mu_to_core__pexpr env e)) pats_pes in
     wrap (Core.PEcase (get_pexpr "PEcase" env p) pats_pes)
  | M_PEarray_shift pe1 ctype pe2 ->
     wrap (Core.PEarray_shift 
             (get_pexpr "PEarray_shift" env pe1) 
             ctype 
             (get_pexpr "PEarray_shift" env pe2))
  | M_PEmember_shift p s id  ->
     wrap (Core.PEmember_shift (get_pexpr "PEmember_shift" env p) s id)
  | M_PEnot p ->
     wrap (Core.PEnot (get_pexpr "PEnot" env p))
  | M_PEop binop p1 p2 ->
     wrap (Core.PEop binop 
             (get_pexpr "PEop" env p1) 
             (get_pexpr "PEop" env p2))
  | M_PEstruct sym fields ->
     let fields = mapsnd (get_pexpr "PEstruct" env) fields in
     wrap (Core.PEstruct sym fields)
  | M_PEunion sym id p ->
     wrap (Core.PEunion sym id (get_pexpr "PEunion" env p))
  (* | M_PEcfunction f ->
   *    Core.PEcfunction (get_pexpr f) *)
  | M_PEmemberof sym id p ->
     wrap (Core.PEmemberof sym id (get_pexpr "PEmemberof" env p))
  | M_PEcall name args ->
     wrap (Core.PEcall name (map (get_pexpr "PEcall" env) args))
  | M_PElet pat p1 p2 ->
     match pat with
     | M_symbol (Annotated _ _ sym) ->
        let p1 = mu_to_core__pexpr env p1 in
        let env' = insert_symbol sym p1 env in
        mu_to_core__pexpr env' p2
     | M_normal_pattern pat ->
        wrap (Core.PElet 
                pat
                (mu_to_core__pexpr env p1) 
                (mu_to_core__pexpr env p2))
     end
  | M_PEif p0 p1 p2 ->
     wrap (Core.PEif 
             (get_pexpr "PEif" env p0)
             (get_pexpr "PEif" env p1)
             (get_pexpr "PEif" env p2))
  (* | M_PEis_scalar p ->
   *    Core.PEis_scalar (get_pexpr p)
   * | M_PEis_integer p ->
   *    Core.PEis_integer (get_pexpr p)
   * | M_PEis_signed p ->
   *    Core.PEis_signed (get_pexpr p)
   * | M_PEis_unsigned p ->
   *    Core.PEis_unsigned (get_pexpr p)
   * | M_PEbmc_assume e ->
   *    Core.PEbmc_assume (get_pexpr e)
   * | M_PEare_compatible p1 p2 ->
   *    Core.PEare_compatible (get_pexpr p1) (get_pexpr p2) *)
  | M_PEensure_specified asym cbt ->
     let pats_pes = 
       let newsym = Symbol.fresh_pretty "eanf" in
       let sym_pat = mk_sym_pat_ annots (Just newsym) cbt in
       let wild_pat = mk_sym_pat_ annots Nothing cbt in
       let spec_pat = mk_specified_pat_ annots sym_pat in
       let unspec_pat = mk_unspecified_pat_ annots wild_pat in
       let e_unspec = Core.Pexpr annots bty 
                        (Core.PEundef (Annot.get_loc_ annots) unspec_undef) in
       let e_spec = make_symbol_pexpr (Annotated annots bty newsym) in
       [(spec_pat, e_spec); (unspec_pat, e_unspec)]
     in
     let pe = get_pexpr "ensure_specified" env asym in
     wrap (Core.PEcase pe pats_pes)


  end

let mu_to_core__action_ env (action_ : mu_action_ 'bty)
        : Core.generic_action_ 'bty symbol =
  match action_ with
  | M_Create p1 p2 prefix ->
     Core.Create 
       (get_pexpr "Create" env p1)
       (make_ctype_pexpr p2)
       prefix
  | M_CreateReadOnly p1 p2 p3 prefix ->
     Core.CreateReadOnly 
       (get_pexpr "CreateReadOnly" env p1)
       (make_ctype_pexpr p2)
       (get_pexpr "CreateReadOnly" env p3)
       prefix
  | M_Alloc p1 p2 prefix ->
     Core.Alloc 
       (make_ctype_pexpr p1)
       (get_pexpr "Alloc" env p2)
       prefix
  | M_Kill b p ->
     Core.Kill 
       b
       (get_pexpr "Kill" env p)
  | M_Store b p1 p2 p3 mo ->
     Core.Store 
       b
       (make_ctype_pexpr p1)
       (get_pexpr "Store" env p2) 
       (get_pexpr "Store" env p3)
       mo
  | M_Load p1 p2 mo ->
     Core.Load 
       (make_ctype_pexpr p1)
       (get_pexpr "Load" env p2)
       mo
  | M_RMW p1 p2 p3 p4 mo1 mo2 ->
     Core.RMW 
       (make_ctype_pexpr p1)
       (get_pexpr "RMW" env p2) 
       (get_pexpr "RMW" env p3)
       (get_pexpr "RMW" env p4)
       mo1
       mo2
  | M_Fence mo ->
     Core.Fence 
       mo
  | M_CompareExchangeStrong p1 p2 p3 p4 mo1 mo2 ->
     Core.CompareExchangeStrong 
       (make_ctype_pexpr p1)
       (get_pexpr "CompareExchangeStrong" env p2) 
       (get_pexpr "CompareExchangeStrong" env p3)
       (get_pexpr "CompareExchangeStrong" env p4)
       mo1
       mo2
  | M_CompareExchangeWeak p1 p2 p3 p4 mo1 mo2 ->
     Core.CompareExchangeWeak
       (make_ctype_pexpr p1)
       (get_pexpr "CompareExchangeWeak" env p2) 
       (get_pexpr "CompareExchangeWeak" env p3)
       (get_pexpr "CompareExchangeWeak" env p4)
       mo1
       mo2
  | M_LinuxFence mo ->
     Core.LinuxFence 
       mo
  | M_LinuxLoad p1 p2 mo ->
     Core.LinuxLoad 
       (make_ctype_pexpr p1)
       (get_pexpr "LinuxLoad" env p2)
       mo
  | M_LinuxStore p1 p2 p3 mo ->
     Core.LinuxStore
       (make_ctype_pexpr p1)
       (get_pexpr "LinuxStore" env p2) 
       (get_pexpr "LinuxStore" env p3)
       mo
  | M_LinuxRMW p1 p2 p3 mo ->
     Core.LinuxRMW
       (make_ctype_pexpr p1)
       (get_pexpr "LinuxRMW" env p2) 
       (get_pexpr "LinuxRMW" env p3)
       mo
  end

let mu_to_core__action env (M_Action t a action_) = 
  Core.Action t a (mu_to_core__action_ env action_)

let mu_to_core__paction env (M_Paction p action) = 
  Core.Paction p (mu_to_core__action env action)

let mu_to_core__memop__ memop = 
  let mctype ct = Left ct in
  let msym sym = Right sym in
  match memop with
  | M_PtrEq (sym1,sym2) ->
     (PtrEq, 
      [msym sym1; msym sym2])
  | M_PtrNe (sym1,sym2) ->
     (PtrNe, 
      [msym sym1; msym sym2])
  | M_PtrLt (sym1,sym2) ->
     (PtrLt, 
      [msym sym1; msym sym2])
  | M_PtrGt (sym1,sym2) ->
     (PtrGt, 
      [msym sym1; msym sym2])
  | M_PtrLe (sym1,sym2) ->
     (PtrLe, 
      [msym sym1; msym sym2])
  | M_PtrGe (sym1,sym2) ->
     (PtrGe, 
      [msym sym1; msym sym2])
  | M_Ptrdiff (ct,sym1,sym2) ->
     (Ptrdiff, 
      [mctype ct; msym sym1; msym sym2])
  | M_IntFromPtr (ct,sym) ->
     (IntFromPtr, 
      [mctype ct; msym sym])
  | M_PtrFromInt (ct,sym) ->
     (PtrFromInt, 
      [mctype ct; msym sym])
  | M_PtrValidForDeref (ct,sym) ->
     (PtrValidForDeref, 
      [mctype ct; msym sym])
  | M_PtrWellAligned (ct,sym) ->
     (PtrWellAligned, 
      [mctype ct; msym sym])
  | M_PtrArrayShift (sym1,ct,sym2) ->
     (PtrArrayShift, 
      [msym sym1; mctype ct; msym sym2])
  | M_Memcpy (sym1,sym2,sym3) ->
     (Memcpy, 
      [msym sym1; msym sym2; msym sym3])
  | M_Memcmp (sym1,sym2,sym3) ->
     (Memcmp, 
      [msym sym1; msym sym2; msym sym3])
  | M_Realloc (sym1,sym2,sym3) ->
     (Realloc, 
      [msym sym1; msym sym2; msym sym3])
  | M_Va_start (sym1,sym2) ->
     (Va_start, 
      [msym sym1; msym sym2])
  | M_Va_copy sym ->
     (Va_copy, 
      [msym sym])
  | M_Va_arg (sym,ct) ->
     (Va_arg, 
      [msym sym; mctype ct])
  | M_Va_end sym ->
     (Va_end, 
      [msym sym])
  end


let mu_to_core__memop env memop = 
  let mctype = make_ctype_pexpr in
  let msym where asym = get_pexpr where env asym in
  match memop with
  | M_PtrEq (sym1,sym2) ->
     (PtrEq, 
      [msym "PtrEq" sym1; 
       msym "PtrEq" sym2])
  | M_PtrNe (sym1,sym2) ->
     (PtrNe, 
      [msym "PtrNe" sym1; 
       msym "PtrNe" sym2])
  | M_PtrLt (sym1,sym2) ->
     (PtrLt, 
      [msym "PtrLt" sym1; 
       msym "PtrLt" sym2])
  | M_PtrGt (sym1,sym2) ->
     (PtrGt, 
      [msym "PtrGt" sym1; 
       msym "PtrGt" sym2])
  | M_PtrLe (sym1,sym2) ->
     (PtrLe, 
      [msym "PtrLe" sym1; 
       msym "PtrLe" sym2])
  | M_PtrGe (sym1,sym2) ->
     (PtrGe, 
      [msym "PtrGe" sym1; 
       msym "PtrGe" sym2])
  | M_Ptrdiff (ct,sym1,sym2) ->
     (Ptrdiff, 
      [mctype ct; 
       msym "Ptrdiff" sym1; 
       msym "Ptrdiff" sym2])
  | M_IntFromPtr (ct,sym) ->
     (IntFromPtr, 
      [mctype ct; 
       msym "IntFromPtr" sym])
  | M_PtrFromInt (ct,sym) ->
     (PtrFromInt, 
      [mctype ct; 
       msym "PtrFromInt" sym])
  | M_PtrValidForDeref (ct,sym) ->
     (PtrValidForDeref, 
      [mctype ct; 
       msym "PtrValidForDeref" sym])
  | M_PtrWellAligned (ct,sym) ->
     (PtrWellAligned, 
      [mctype ct; 
       msym "PtrWellAligned" sym])
  | M_PtrArrayShift (sym1,ct,sym2) ->
     (PtrArrayShift, 
      [msym "PtrArrayShift" sym1; 
       mctype ct; 
       msym "PtrArrayShift" sym2])
  | M_Memcpy (sym1,sym2,sym3) ->
     (Memcpy, 
      [msym "Memcpy" sym1; 
       msym "Memcpy" sym2; 
       msym "Memcpy" sym3])
  | M_Memcmp (sym1,sym2,sym3) ->
     (Memcmp, 
      [msym "Memcmp" sym1; 
       msym "Memcmp" sym2; 
       msym "Memcmp" sym3])
  | M_Realloc (sym1,sym2,sym3) ->
     (Realloc, 
      [msym "Realloc" sym1; 
       msym "Realloc" sym2; 
       msym "Realloc" sym3])
  | M_Va_start (sym1,sym2) ->
     (Va_start, 
      [msym "Va_start" sym1; 
       msym "Va_start" sym2])
  | M_Va_copy sym ->
     (Va_copy, 
      [msym "Va_copy" sym])
  | M_Va_arg (sym,ct) ->
     (Va_arg, 
      [msym "Va_arg" sym; 
       mctype ct])
  | M_Va_end sym ->
     (Va_end, 
      [msym "Va_end" sym])
  end

let rec mu_to_core__expr env (expr : mu_expr 'a 'bty)
        : Core.generic_expr 'a 'bty symbol =
  let (M_Expr annots expr_) = expr in
  let wrap expr_ = Core.Expr annots expr_ in
  match expr_ with
    | M_Epure p -> 
       wrap (Core.Epure (mu_to_core__pexpr env p))
    | M_Ememop memop ->
       let (memop,args) = mu_to_core__memop env memop in
       wrap (Core.Ememop memop args)
    | M_Eaction pa ->
       wrap (Core.Eaction (mu_to_core__paction env pa))
    | M_Ecase pe es ->
       wrap (Core.Ecase (get_pexpr "Ecase" env pe) 
               (map (fun (pat,e) -> (pat, mu_to_core__expr env e)) es))
    | M_Elet pat pe e ->
       match pat with
       | M_symbol (Annotated _ _ sym) ->
          let pe = mu_to_core__pexpr env pe in
          let env' = insert_symbol sym pe env in
          mu_to_core__expr env' e
       | M_normal_pattern pat ->
          wrap (Core.Elet 
                  pat
                  (mu_to_core__pexpr env pe) 
                  (mu_to_core__expr env e))
       end
    | M_Eif pe e1 e2 ->
       wrap (Core.Eif (get_pexpr "Eif" env pe)
               (mu_to_core__expr env e1)
               (mu_to_core__expr env e2))
    | M_Eskip ->
       wrap Core.Eskip
    | M_Eccall a (Annotated annots bty ct) pe2 pes ->
       wrap (Core.Eccall a 
               (Core.Pexpr annots bty (Core.PEval (Core.Vctype ct)))
               (get_pexpr "Eccall" env pe2) 
               (map (get_pexpr "Eccall" env) pes))
    | M_Eproc a name pes ->
       wrap (Core.Eproc a name (map (get_pexpr "Eproc" env) pes))
    (* | M_Eunseq es ->
     *    Core.Eunseq (map (mu_to_core__expr env) es) *)
    | M_Ewseq pat e1 e2 ->
       wrap (Core.Ewseq pat
               (mu_to_core__expr env e1)
               (mu_to_core__expr env e2))
    | M_Esseq pat e1 e2 ->
       wrap (Core.Esseq pat
               (mu_to_core__expr env e1)
               (mu_to_core__expr env e2))
    (* | M_Easeq (s,bt) a pa ->
     *    Core.Easeq (s,bt) (mu_to_core__action a) (mu_to_core__paction pa) *)
    (* | M_Eindet n e ->
     *    Core.Eindet n (mu_to_core__expr env e) *)
    | M_Ebound n e ->
       wrap (Core.Ebound n (mu_to_core__expr env e))
    | M_End es ->
       wrap (Core.End (map (mu_to_core__expr env) es))
    | M_Esave (sym,bt) sbp e ->
       let sbp = 
         map (fun (sym,(bt,pe)) -> (sym,(bt,get_pexpr "Esave" env pe))) sbp in
       wrap (Core.Esave (sym,bt) sbp (mu_to_core__expr env e))
    | M_Erun a sym pes ->
       wrap (Core.Erun a sym (map (get_pexpr "Erun" env) pes))
    (* | M_Epar es ->
     *    Core.Epar (map (mu_to_core__expr env) es) *)
    (* | M_Ewait tid -> 
     *    Core.Ewait tid *)
  end


let mu_to_core__impl_decl (i : mu_impl_decl 'bty) 
    : Core.generic_impl_decl 'bty =
  match i with
  | M_Def bt p -> 
     Core.Def bt (mu_to_core__pexpr Map.empty p)
  | M_IFun bt args body -> 
     Core.IFun bt args (mu_to_core__pexpr Map.empty body)
  end

let mu_to_core__impl (i : mu_impl 'bty) 
    : Core.generic_impl 'bty =
  Map.map mu_to_core__impl_decl i


let mu_to_core__fun_map_decl (d : mu_fun_map_decl 'bty 'a) 
    : Core.generic_fun_map_decl 'bty 'a =
  match d with
  | M_Fun bt args pe ->
     Core.Fun bt args (mu_to_core__pexpr Map.empty pe)
  | M_Proc loc bt args e ->
     Core.Proc loc bt args (mu_to_core__expr Map.empty e)
  | M_ProcDecl loc bt bts ->
     Core.ProcDecl loc bt bts
  | M_BuiltinDecl loc bt bts ->
     Core.BuiltinDecl loc bt bts
  end

let mu_to_core__fun_map (fmap : mu_fun_map 'bty 'a) 
    : Core.generic_fun_map 'bty 'a = 
  Map.map mu_to_core__fun_map_decl fmap
  

let mu_to_core__globs (g : mu_globs 'a 'bty) 
    : Core.generic_globs 'a 'bty = 
  match g with
  | M_GlobalDef bt e -> Core.GlobalDef bt (mu_to_core__expr Map.empty e)
  | M_GlobalDecl bt -> Core.GlobalDecl bt 
  end

(* let mu_to_core__globs_map (g : Core.generic_globs_map 'a bty) 
 *     : mu_globs_map 'a bty = 
 *   Map.map mu_to_core__globs g *)
  
let mu_to_core__globs_list (gs : list (symbol * mu_globs 'a 'bty) )
    : list (symbol * Core.generic_globs 'a 'bty) = 
  map (fun (sym,g) -> (sym, mu_to_core__globs g)) gs


let mu_to_core__file file = 
  <| Core.main = file.mu_main
   ; Core.tagDefs = file.mu_tagDefs
   ; Core.stdlib = mu_to_core__fun_map file.mu_stdlib
   ; Core.impl = mu_to_core__impl file.mu_impl
   ; Core.globs = mu_to_core__globs_list file.mu_globs
   ; Core.funs = mu_to_core__fun_map file.mu_funs
   ; Core.extern = file.mu_extern
   ; Core.funinfo = file.mu_funinfo
  |>

