open import Pervasives

open import Ctype Annot Loc
import Symbol Implementation Undefined Cmm_csem
import Mem Mem_common
(* import Linux *)

import Core


type mu_object_type = Core.core_object_type



(* although we might drop the BTy_ctype *)
type mu_base_type = Core.core_base_type
type bty = mu_base_type

type symbol = Symbol.sym
type tsymbol 'bty = Sym of list Annot.annot * 'bty * Symbol.sym


type mu_name = Core.generic_name symbol

type mu_object_value = Core.generic_object_value symbol
type mu_loaded_value = Core.generic_loaded_value symbol



(* again, we might remove something from the definition here,
   e.g. Vctype *)
type mu_value = Core.generic_value symbol


type mu_ctor 'bty = Core.generic_ctor 'bty

type mu_pattern_ 'bty = Core.generic_pattern_ 'bty symbol
type mu_pattern 'bty = Core.generic_pattern 'bty symbol

type mu_pexpr_ 'bty =  (* Core pure expressions *)
 | M_PEsym of symbol
 | M_PEimpl of Implementation.implementation_constant (* implementation-defined constant *)
 | M_PEval of mu_value
 | M_PEconstrained of list (Mem.mem_iv_constraint * tsymbol 'bty) (* constrained value *)
 | M_PEundef of Loc.t * Undefined.undefined_behaviour (* undefined behaviour *)
 | M_PEerror of string * tsymbol 'bty (* impl-defined static error *)
 | M_PEctor of mu_ctor 'bty * list (tsymbol 'bty) (* data constructor application *)
 | M_PEcase of (tsymbol 'bty) * list ((mu_pattern 'bty) * (mu_pexpr 'bty)) (* pattern matching *)
 | M_PEarray_shift of (tsymbol 'bty) * ctype * (tsymbol 'bty) (* pointer array shift *)
 | M_PEmember_shift of (tsymbol 'bty) * symbol * Symbol.identifier (* pointer struct/union member shift *)
 | M_PEnot of tsymbol 'bty (* boolean not *)
 | M_PEop of Core.binop * (tsymbol 'bty) * (tsymbol 'bty)
 | M_PEstruct of symbol * list (Symbol.identifier * tsymbol 'bty) (* C struct expression *)
 | M_PEunion of symbol * Symbol.identifier * tsymbol 'bty (* C union expression *)
 | M_PEcfunction of tsymbol 'bty (* C function pointer expression *)
 | M_PEmemberof of symbol * Symbol.identifier * tsymbol 'bty (* C struct/union member access *)
 | M_PEcall of mu_name * list (tsymbol 'bty) (* pure function call *)
 | M_PElet of (mu_pattern 'bty) * (mu_pexpr 'bty) * (mu_pexpr 'bty) (* pure let *)
 | M_PEif of tsymbol 'bty * (mu_pexpr 'bty) * (mu_pexpr 'bty) (* pure if *)
 | M_PEis_scalar of tsymbol 'bty
 | M_PEis_integer of tsymbol 'bty
 | M_PEis_signed of tsymbol 'bty
 | M_PEbmc_assume of tsymbol 'bty
 | M_PEis_unsigned of tsymbol 'bty
 | M_PEare_compatible of tsymbol 'bty * tsymbol 'bty

and mu_pexpr 'bty = 
 | M_Pexpr of list annot * 'bty * (mu_pexpr_ 'bty)


type mu_action_ 'bty =  (* memory actions *)
 | M_Create of tsymbol 'bty * tsymbol 'bty * Symbol.prefix
 | M_CreateReadOnly of tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Symbol.prefix
 | M_Alloc of tsymbol 'bty * tsymbol 'bty * Symbol.prefix
 | M_Kill of bool * tsymbol 'bty (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | M_Store of bool * tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Cmm_csem.memory_order (* the boolean indicates whether the store is locking *)
 | M_Load of tsymbol 'bty * tsymbol 'bty * Cmm_csem.memory_order
 | M_RMW of tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_Fence of Cmm_csem.memory_order
 | M_CompareExchangeStrong of tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_CompareExchangeWeak of tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Cmm_csem.memory_order * Cmm_csem.memory_order
 | M_LinuxFence of Linux.linux_memory_order
 | M_LinuxLoad of tsymbol 'bty * tsymbol 'bty * Linux.linux_memory_order
 | M_LinuxStore of tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Linux.linux_memory_order
 | M_LinuxRMW of tsymbol 'bty * tsymbol 'bty * tsymbol 'bty * Linux.linux_memory_order


type mu_action 'a 'bty = 
 | M_Action of Loc.t * 'a * (mu_action_ 'bty)


type mu_paction 'a 'bty =  (* memory actions with Core.polarity *)
 | M_Paction of Core.polarity * (mu_action 'a 'bty)

type mu_expr_ 'a 'bty =  (* (effectful) expression *)
 | M_Epure of (mu_pexpr 'bty)
 | M_Ememop of Mem_common.memop * list (tsymbol 'bty) (* pointer op involving memory *)
 | M_Eaction of (mu_paction 'a 'bty) (* memory action *)
 | M_Ecase of tsymbol 'bty * list ((mu_pattern 'bty) * (mu_expr 'a 'bty)) (* pattern matching *)
 | M_Elet of (mu_pattern 'bty) * (mu_pexpr 'bty) * (mu_expr 'a 'bty)
 | M_Eif of tsymbol 'bty * (mu_expr 'a 'bty) * (mu_expr 'a 'bty)
 | M_Eskip
 | M_Eccall of 'a * tsymbol 'bty * tsymbol 'bty * list (tsymbol 'bty) (* C function call *)
 | M_Eproc of 'a * mu_name * list (tsymbol 'bty) (* Core procedure call *)
 | M_Eunseq of list (mu_expr 'a 'bty) (* unsequenced expressions *)
 | M_Ewseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* weak sequencing *)
 | M_Esseq of (mu_pattern 'bty) * (mu_expr 'a 'bty) * (mu_expr 'a 'bty) (* strong sequencing *)
 | M_Easeq of (symbol * mu_base_type) * (mu_action 'a 'bty) * (mu_paction 'a 'bty) (* atomic sequencing *)
 | M_Eindet of nat * (mu_expr 'a 'bty) (* indeterminately sequenced expr *)
 | M_Ebound of nat * (mu_expr 'a 'bty) (* $\ldots$and boundary *)
 | M_End of list (mu_expr 'a 'bty) (* nondeterministic sequencing *)
 | M_Esave of (symbol * mu_base_type) * list (symbol * (mu_base_type * tsymbol 'bty)) * (mu_expr 'a 'bty) (* save label *)
 | M_Erun of 'a * symbol * list (tsymbol 'bty) (* run from label *)
 | M_Epar of list (mu_expr 'a 'bty) (* cppmem-like thread creation *)
 | M_Ewait of Mem_common.thread_id (* wait for thread termination *)

and mu_expr 'a 'bty = 
 | M_Expr of list annot * (mu_expr_ 'a 'bty)

type mu_impl_decl 'bty =
  | M_Def of mu_base_type * mu_pexpr 'bty
  | M_IFun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty

type mu_impl 'bty = map Implementation.implementation_constant (mu_impl_decl 'bty)

type mu_fun_map_decl 'bty 'a =
  | M_Fun of mu_base_type * list (symbol * mu_base_type) * mu_pexpr 'bty
  | M_Proc of Loc.t * mu_base_type * list (symbol * mu_base_type) * mu_expr 'a 'bty
  | M_ProcDecl of Loc.t * mu_base_type * list mu_base_type
  | M_BuiltinDecl of Loc.t * mu_base_type * list mu_base_type

type mu_fun_map 'bty 'a = map symbol (mu_fun_map_decl 'bty 'a)

instance forall 'bty. (Located (mu_pexpr 'bty))
  let locOf pe =
    let (M_Pexpr annots _ _) = pe in
    get_loc_ annots
end

instance forall 'a 'bty. (Located (mu_expr 'a 'bty))
  let locOf e =
    let (M_Expr annots _) = e in
    get_loc_ annots
end


type mu_linking_kind = Core.linking_kind

type mu_extern_map = Core.extern_map

type mu_globs 'a 'bty=
  | M_GlobalDef of mu_base_type * mu_expr 'a 'bty
  | M_GlobalDecl of mu_base_type

type mu_globs_map 'a 'bty =
  map symbol (mu_globs 'a 'bty)

type mu_tag_definitions = Core.core_tag_definitions

(* a Core file is just a set of named functions *)
type mu_file 'bty 'a = <|
  mu_main    : maybe symbol;
  mu_tagDefs : mu_tag_definitions;
  mu_stdlib  : mu_fun_map 'bty 'a;
  mu_impl    : mu_impl 'bty;
  mu_globs   : list (symbol * mu_globs 'a 'bty);
  mu_funs    : mu_fun_map 'bty 'a;
  mu_extern  : mu_extern_map;
  mu_funinfo : map symbol (Loc.t * Annot.attributes * ctype * list (maybe symbol * ctype) * bool * bool);
|>




let mapsnd (f : 'b -> 'c) (l : list ('a * 'b)) : list ('a * 'c) = 
  List.map (fun (a,b) -> (a, f b)) l

(* for error reporting *)
type outer 'a 'bty = 
  | PEXPR of Core.generic_pexpr 'bty symbol
  | ACTION of Core.generic_action_ 'bty symbol
  | EXPR of Core.generic_expr 'a 'bty symbol
  | NONE

val print_endline : string -> unit
declare ocaml target_rep function print_endline = `print_endline`

let make_symbol_pexpr (Sym annots bty sym) : Core.generic_pexpr 'bty symbol =
  Core.Pexpr annots bty (Core.PEsym sym)

let rec mu_to_core__pexpr (pexpr : mu_pexpr 'bty)
        : Core.generic_pexpr 'bty symbol =
  let (M_Pexpr annots bty pexpr_) = pexpr in
  let pexpr_ = match pexpr_ with
    | M_PEsym s ->
       Core.PEsym s       
    | M_PEimpl ic -> 
       Core.PEimpl ic
    | M_PEval v -> 
       Core.PEval v
    | M_PEconstrained l -> 
       let l = mapsnd make_symbol_pexpr l in
       Core.PEconstrained l
    | M_PEundef loc undef ->
       Core.PEundef loc undef
    | M_PEerror err p -> 
       Core.PEerror err (make_symbol_pexpr p)
    | M_PEctor ctor pes -> 
       Core.PEctor ctor (map make_symbol_pexpr pes)
    | M_PEcase p pats ->
       let pats = mapsnd mu_to_core__pexpr pats in
       Core.PEcase (make_symbol_pexpr p) pats
    | M_PEarray_shift pe1 ctype pe2 ->
       Core.PEarray_shift (make_symbol_pexpr pe1) ctype (make_symbol_pexpr pe2)
    | M_PEmember_shift p s id  ->
       Core.PEmember_shift (make_symbol_pexpr p) s id
    | M_PEnot p ->
       Core.PEnot (make_symbol_pexpr p)
    | M_PEop binop p1 p2 ->
       Core.PEop binop (make_symbol_pexpr p1) (make_symbol_pexpr p2)
    | M_PEstruct sym fields ->
       let fields = mapsnd make_symbol_pexpr fields in
       Core.PEstruct sym fields
    | M_PEunion sym id p ->
       Core.PEunion sym id (make_symbol_pexpr p)
    | M_PEcfunction f ->
       Core.PEcfunction (make_symbol_pexpr f)
    | M_PEmemberof sym id p ->
       Core.PEmemberof sym id (make_symbol_pexpr p)
    | M_PEcall name args ->
       Core.PEcall name (map make_symbol_pexpr args)
    | M_PElet pat p1 p2 ->
       Core.PElet pat (mu_to_core__pexpr p1) (mu_to_core__pexpr p2)
    | M_PEif p0 p1 p2 ->
       Core.PEif (make_symbol_pexpr p0) (mu_to_core__pexpr p1) (mu_to_core__pexpr p2)
    | M_PEis_scalar p ->
       Core.PEis_scalar (make_symbol_pexpr p)
    | M_PEis_integer p ->
       Core.PEis_integer (make_symbol_pexpr p)
    | M_PEis_signed p ->
       Core.PEis_signed (make_symbol_pexpr p)
    | M_PEis_unsigned p ->
       Core.PEis_unsigned (make_symbol_pexpr p)
    | M_PEbmc_assume e ->
       Core.PEbmc_assume (make_symbol_pexpr e)
    | M_PEare_compatible p1 p2 ->
       Core.PEare_compatible (make_symbol_pexpr p1) (make_symbol_pexpr p2)
  end in
  Core.Pexpr annots bty pexpr_

let mu_to_core__action_ (action_ : mu_action_ 'bty)
        : Core.generic_action_ 'bty symbol =
  match action_ with
  | M_Create p1 p2 prefix ->
     Core.Create (make_symbol_pexpr p1) (make_symbol_pexpr p2) prefix
  | M_CreateReadOnly p1 p2 p3 prefix ->
     Core.CreateReadOnly (make_symbol_pexpr p2) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) prefix
  | M_Alloc p1 p2 prefix ->
     Core.Alloc (make_symbol_pexpr p1) (make_symbol_pexpr p2) prefix
  | M_Kill b p ->
     Core.Kill b (make_symbol_pexpr p)
  | M_Store b p1 p2 p3 mo ->
     Core.Store b (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) mo
  | M_Load p1 p2 mo ->
     Core.Load (make_symbol_pexpr p1) (make_symbol_pexpr p2) mo
  | M_RMW p1 p2 p3 p4 mo1 mo2 ->
     Core.RMW (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) (make_symbol_pexpr p4) mo1 mo2
  | M_Fence mo ->
     Core.Fence mo
  | M_CompareExchangeStrong p1 p2 p3 p4 mo1 mo2 ->
     Core.CompareExchangeStrong (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) (make_symbol_pexpr p4) mo1 mo2
  | M_CompareExchangeWeak p1 p2 p3 p4 mo1 mo2 ->
     Core.CompareExchangeWeak (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) (make_symbol_pexpr p4) mo1 mo2
  | M_LinuxFence mo ->
     Core.LinuxFence mo
  | M_LinuxLoad p1 p2 mo ->
     Core.LinuxLoad (make_symbol_pexpr p1) (make_symbol_pexpr p2) mo
  | M_LinuxStore p1 p2 p3 mo ->
     Core.LinuxStore (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) mo
  | M_LinuxRMW p1 p2 p3 mo ->
     Core.LinuxRMW (make_symbol_pexpr p1) (make_symbol_pexpr p2) 
       (make_symbol_pexpr p3) mo
  end

let mu_to_core__action (M_Action t a action_) = 
  Core.Action t a (mu_to_core__action_ action_)

let mu_to_core__paction (M_Paction p action) = 
  Core.Paction p (mu_to_core__action action)

let rec mu_to_core__expr (expr : mu_expr 'a 'bty)
        : Core.generic_expr 'a 'bty symbol =
  let (M_Expr annots expr_) = expr in
  let expr_ = match expr_ with
    | M_Epure p -> 
       Core.Epure (mu_to_core__pexpr p)
    | M_Ememop memop pexprs ->
       Core.Ememop memop (map make_symbol_pexpr pexprs)
    | M_Eaction pa ->
       Core.Eaction (mu_to_core__paction pa)
    | M_Ecase pe es ->
       Core.Ecase (make_symbol_pexpr pe) (mapsnd mu_to_core__expr es)
    | M_Elet pat pe e ->
       Core.Elet pat (mu_to_core__pexpr pe) (mu_to_core__expr e)
    | M_Eif pe e1 e2 ->
       Core.Eif (make_symbol_pexpr pe) (mu_to_core__expr e1) (mu_to_core__expr e2)
    | M_Eskip ->
       Core.Eskip
    | M_Eccall a pe1 pe2 pes ->
       Core.Eccall a (make_symbol_pexpr pe1) (make_symbol_pexpr pe2) 
         (map make_symbol_pexpr pes)
    | M_Eproc a name pes ->
       Core.Eproc a name (map make_symbol_pexpr pes)
    | M_Eunseq es ->
       Core.Eunseq (map mu_to_core__expr es)
    | M_Ewseq pat e1 e2 ->
       Core.Ewseq pat (mu_to_core__expr e1) (mu_to_core__expr e2)
    | M_Esseq pat e1 e2 ->
       Core.Esseq pat (mu_to_core__expr e1) (mu_to_core__expr e2)
    | M_Easeq (s,bt) a pa ->
       Core.Easeq (s,bt) (mu_to_core__action a) (mu_to_core__paction pa)
    | M_Eindet n e ->
       Core.Eindet n (mu_to_core__expr e)
    | M_Ebound n e ->
       Core.Ebound n (mu_to_core__expr e)
    | M_End es ->
       Core.End (List.map mu_to_core__expr es)
    | M_Esave (sym,bt) sbp e ->
       let sbp = 
         List.map (fun (sym,(bt,pe)) -> (sym,(bt,make_symbol_pexpr pe))) sbp in
       Core.Esave (sym,bt) sbp (mu_to_core__expr e)
    | M_Erun a sym pes ->
       Core.Erun a sym (List.map make_symbol_pexpr pes)
    | M_Epar es ->
       Core.Epar (List.map mu_to_core__expr es)
    | M_Ewait tid -> 
       Core.Ewait tid
  end in
  Core.Expr annots expr_


let mu_to_core__impl_decl (i : mu_impl_decl 'bty) 
    : Core.generic_impl_decl 'bty =
  match i with
  | M_Def bt p -> 
     Core.Def bt (mu_to_core__pexpr p)
  | M_IFun bt args body -> 
     Core.IFun bt args (mu_to_core__pexpr body)
  end

let mu_to_core__impl (i : mu_impl 'bty) 
    : Core.generic_impl 'bty =
  Map.map mu_to_core__impl_decl i


let mu_to_core__fun_map_decl (d : mu_fun_map_decl 'bty 'a) 
    : Core.generic_fun_map_decl 'bty 'a =
  match d with
  | M_Fun bt args pe ->
     Core.Fun bt args (mu_to_core__pexpr pe)
  | M_Proc loc bt args e ->
     Core.Proc loc bt args (mu_to_core__expr e)
  | M_ProcDecl loc bt bts ->
     Core.ProcDecl loc bt bts
  | M_BuiltinDecl loc bt bts ->
     Core.BuiltinDecl loc bt bts
  end

let mu_to_core__fun_map (fmap : mu_fun_map 'bty 'a) 
    : Core.generic_fun_map 'bty 'a = 
  Map.map mu_to_core__fun_map_decl fmap
  

let mu_to_core__globs (g : mu_globs 'a 'bty) 
    : Core.generic_globs 'a 'bty = 
  match g with
  | M_GlobalDef bt e -> Core.GlobalDef bt (mu_to_core__expr e)
  | M_GlobalDecl bt -> Core.GlobalDecl bt 
  end

(* let mu_to_core__globs_map (g : Core.generic_globs_map 'a bty) 
 *     : mu_globs_map 'a bty = 
 *   Map.map mu_to_core__globs g *)
  
let mu_to_core__globs_list (gs : list (symbol * mu_globs 'a 'bty) )
    : list (symbol * Core.generic_globs 'a 'bty) = 
  List.map (fun (sym,g) -> (sym, mu_to_core__globs g)) gs


let mu_to_core__file file = 
  <| Core.main = file.mu_main
   ; Core.tagDefs = file.mu_tagDefs
   ; Core.stdlib = mu_to_core__fun_map file.mu_stdlib
   ; Core.impl = mu_to_core__impl file.mu_impl
   ; Core.globs = mu_to_core__globs_list file.mu_globs
   ; Core.funs = mu_to_core__fun_map file.mu_funs
   ; Core.extern = file.mu_extern
   ; Core.funinfo = file.mu_funinfo
  |>

