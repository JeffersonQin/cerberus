open import Pervasives
open import Assert_extra

import Symbol

open import Core
open import Mucore
     import Core_typing Core_typing_aux

type bty = core_base_type
type value = generic_value Symbol.sym
type values = list value
type pexpr = generic_pexpr bty Symbol.sym
type pexprs = list pexpr
type expr 'a = generic_expr 'a bty Symbol.sym
type pattern = generic_pattern bty Symbol.sym
type annot = Annot.annot
type annots = list annot
type action 'a = generic_action 'a bty Symbol.sym
type paction 'a = generic_paction 'a bty Symbol.sym

type mu_value = Mucore.mu_value bty
type mu_values = list mu_value
type mu_pexpr = Mucore.mu_pexpr bty
type mu_pexprs = list mu_pexpr
type mu_expr 'a = Mucore.mu_expr 'a bty
type mu_pattern = Mucore.mu_pattern bty
type mu_action 'a = Mucore.mu_action 'a bty
type mu_paction 'a = Mucore.mu_paction 'a bty

type tsymbol = Mucore.tsymbol Mucore.mu_base_type
type tsymbols = list tsymbol



let annots_of_pexpr (Pexpr annots _ _) = annots
let annots_of_mu_pexpr (M_Pexpr annots _ _) = annots
let bty_of_pexpr (Pexpr _ bty _) = bty
let bty_of_mu_pexpr (M_Pexpr _ bty _) = bty


(* ... adapting the algorithm from
   http://matt.might.net/articles/a-normalization/ for core *)

let is_symbol (M_Pexpr annots bty e) = 
  match e with
  | M_PEsym sym -> Just (TSym annots bty sym)
  | _ -> Nothing
  end

(* Here we depend on bty being of type core_base_type *)
let var_pat sym annots bty = 
  Pattern annots (CaseBase (Just sym, bty))
let var_pexpr sym annots bty = 
  M_Pexpr annots bty (M_PEsym sym) 



type mu_pexpr_context 'a = 'a -> mu_pexpr



val n_val :           annots -> value -> mu_pexpr_context mu_value -> mu_pexpr
val n_val_name :      annots -> value -> mu_pexpr_context tsymbol -> mu_pexpr
val n_val_names :     annots -> values -> mu_pexpr_context tsymbols -> mu_pexpr
val n_pexpr :         pexpr -> mu_pexpr_context mu_pexpr -> mu_pexpr
val n_pexpr_name :    pexpr -> mu_pexpr_context tsymbol -> mu_pexpr
val n_pexpr_no_let :  pexpr -> (mu_pexpr -> mu_pexpr) -> mu_pexpr
val n_pexpr_names :   pexprs -> mu_pexpr_context tsymbols -> mu_pexpr
val normalise_pexpr : pexpr -> mu_pexpr
val normalise_pexpr_name : pexpr -> mu_pexpr

val let_bind_pexpr : mu_pexpr -> mu_pexpr_context tsymbol -> mu_pexpr
let let_bind_pexpr pexp ctxt = 
  let (M_Pexpr annots bty _) = pexp in
  let sym = Symbol.fresh () in
  let pat = var_pat sym annots bty in
  let body = ctxt (TSym annots bty sym) in
  M_Pexpr annots (bty_of_mu_pexpr body) (M_PElet pat pexp body)


let mu_pexpr_for_val annots bty v = 
  M_Pexpr annots bty (M_PEval v)


let typeof_value v = 
  match Core_typing.typeof_value Loc.unknown Core_typing_aux.empty_env v with
  | Exception.Result bty -> bty
  | Exception.Exception msg -> failwith "msg"
  end


let rec n_ov annots v k = 
  match v with
  | Core.OVinteger iv -> k (M_OVinteger iv)
  | Core.OVfloating fv -> k (M_OVfloating fv)
  | Core.OVpointer pv -> k (M_OVpointer pv)
  | Core.OVarray is -> 
     let vs = List.map Vloaded is in
     n_val_names annots vs (fun syms ->
     k (M_OVarray syms))
  | Core.OVstruct sym is ->
     k (M_OVstruct sym is)
  | Core.OVunion sym id mv ->
     k (M_OVunion sym id mv)
  end

and n_lv annots v k = 
  match v with
  | LVspecified ov ->
     n_val_name annots (Vobject ov) (fun sym ->
     k (M_LVspecified sym))
  | LVunspecified ct ->
     k (M_LVunspecified ct)
  end

and n_val annots v k = 
  match v with
  | Vobject ov -> n_ov annots ov (fun ov -> k (M_Vobject ov))
  | Vloaded lv -> n_lv annots lv (fun lv -> k (M_Vloaded lv))
  | Vunit -> k M_Vunit
  | Vtrue -> k M_Vtrue
  | Vfalse -> k M_Vfalse
  | Vctype ct -> k (M_Vctype ct)
  | Vlist cbt vs -> n_val_names annots vs (fun vs -> k (M_Vlist cbt vs))
  | Vtuple vs -> n_val_names annots vs (fun vs -> k (M_Vtuple vs))
  end

and n_val_name annots v k = 
  let bty = typeof_value v in
  n_val annots v (fun v -> 
  let pe = mu_pexpr_for_val annots bty v in
  let_bind_pexpr pe (fun sym -> 
  k sym))

and n_val_names annots vs k = 
  match vs with
  | [] -> k []
  | v :: vs ->
     n_val_name annots v (fun sym ->
     n_val_names annots vs (fun syms ->
     k (sym :: syms)))
  end


let rec normalise_pexpr e = 
  n_pexpr e (fun e -> e)

and normalise_pexpr_name e = 
  n_pexpr_name e (fun (TSym annots bty sym) -> 
  M_Pexpr annots bty (M_PEsym sym))


and n_pexpr_name (e : pexpr) (k : tsymbol -> mu_pexpr) : mu_pexpr = 
  n_pexpr (e : pexpr) (fun e -> 
  match is_symbol e with
  | Just sym -> k sym
  | Nothing -> let_bind_pexpr e k
  end)

and n_pexpr_name_2 (e,e') k = 
  n_pexpr_name e (fun e -> 
  n_pexpr_name e' (fun e' ->
  k (e,e')))

(* and n_pexpr_no_let (e : pexpr) (k : mu_pexpr -> mu_pexpr) : mu_pexpr = 
 *   match e with
 *   | Pexpr annots bty (PElet pat e' e'') -> 
 *      n_pexpr_no_let e' (fun e' -> 
 *      M_Pexpr annots bty (M_PElet pat e' (n_pexpr e'' k)))
 *   | e -> n_pexpr e k
 *   end *)

and n_pexpr_names (es : list pexpr) (k : tsymbols -> mu_pexpr) : mu_pexpr =
  match es with
  | [] -> k []
  | e :: es -> 
     n_pexpr_name e (fun e -> 
     n_pexpr_names es (fun es ->
     k (e :: es)))
  end

and n_pexpr e k = 

  let (Pexpr annots bty pe) = e in
  let annotate pe = M_Pexpr annots bty pe in

  match pe with
  | PEsym sym -> 
     k (annotate (M_PEsym sym))
  | PEimpl i -> 
     k (annotate (M_PEimpl i))
  | PEval v -> 
     n_val annots v (fun v ->
     k (annotate (M_PEval v)))
  | PEconstrained l -> 
     let (constraints,exprs) = List.unzip l in
     n_pexpr_names exprs (fun exprs ->
     let l = List.zip constraints exprs in
     k (annotate (M_PEconstrained l)))
  | PEundef l u -> 
     k (annotate (M_PEundef l u))
  | PEerror err e' ->
     n_pexpr_name e' (fun e' -> 
     k (annotate (M_PEerror err e')))
  | PEctor ctor args ->
     n_pexpr_names args (fun args -> 
     k (annotate (M_PEctor ctor args)))
  | PEcase e' pats_pes ->
     n_pexpr_name e' (fun e' -> 
     let (pats,pes) = List.unzip pats_pes in
     n_pexpr_names pes (fun pes ->
     let pats_pes = List.zip pats pes in
     k (annotate (M_PEcase e' pats_pes))))
  | PEarray_shift e' ctype e'' ->
     n_pexpr_name_2 (e',e'') (fun (e',e'') -> 
     k (annotate (M_PEarray_shift e' ctype e'')))
  | PEmember_shift e' sym id ->
     n_pexpr_name e' (fun e' -> 
     k (annotate (M_PEmember_shift e' sym id)))
  | PEnot e' -> 
     n_pexpr_name e' (fun e' -> 
     k (annotate (M_PEnot e')))
  | PEop binop e' e'' ->
     n_pexpr_name_2 (e',e'') (fun (e',e'') -> 
     k (annotate (M_PEop binop e' e'')))
  | PEstruct sym fields ->
     let (fnames, pes) = List.unzip fields in
     n_pexpr_names pes (fun pes ->
     let fields = List.zip fnames pes in
     k (annotate (M_PEstruct sym fields)))
  | PEunion sym id e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEunion sym id e')))
  | PEcfunction e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEcfunction e')))
  | PEmemberof sym id e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEmemberof sym id e')))
  | PEcall sym args ->
     n_pexpr_names args (fun args ->
     k (annotate (M_PEcall sym args)))
  | PElet pat e' e'' ->
     n_pexpr e' (fun e' ->
     (* n_pexpr_no_let e' (fun e' -> *)
     annotate (M_PElet pat e' (n_pexpr e'' k)))
  | PEif e' e'' e''' ->
     n_pexpr_name e' (fun e' ->
     n_pexpr_name e'' (fun e'' ->
     n_pexpr_name e''' (fun e''' ->
     k (annotate (M_PEif e' e'' e''')))))
  | PEis_scalar e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEis_scalar e')))
  | PEis_integer e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEis_integer e')))
  | PEis_signed e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEis_signed e')))
  | PEis_unsigned e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEis_unsigned e')))
  | PEbmc_assume e' ->
     n_pexpr_name e' (fun e' ->
     k (annotate (M_PEbmc_assume e')))
  | PEare_compatible e' e'' ->
     n_pexpr_name_2 (e',e'') (fun (e',e'') ->
     k (annotate (M_PEare_compatible e' e'')))
  end


let rec pull_let (pexpr : mu_pexpr) (k : mu_pexpr -> mu_expr 'a) : mu_expr 'a = 
  match pexpr with
  | M_Pexpr annots _bty (M_PElet pat e' e'') ->
     M_Expr annots (M_Elet pat e' (pull_let e'' k))
  | M_Pexpr _ _ _ ->
     k pexpr
  end

let rec pull_let_name (pexpr : mu_pexpr) (k : tsymbol -> mu_expr 'a) : mu_expr 'a = 
  match pexpr with
  | M_Pexpr annots _bty (M_PElet pat e' e'') ->
     M_Expr annots (M_Elet pat e' (pull_let_name e'' k))
  | M_Pexpr annots bty (M_PEsym sym) ->
     k (TSym annots bty sym)
  | _ -> failwith "not a symbol"
  end


(* let pull_let_pexpr_no_let (pexpr : pexpr) (k : mu_pexpr -> mu_expr 'a) : mu_expr 'a = 
 *   pull_let (n_pexpr_no_let pexpr (fun p -> p)) k *)

let rec pull_let_pexpr (pexpr : pexpr) (k : mu_pexpr -> mu_expr 'a) : mu_expr 'a = 
  pull_let (normalise_pexpr pexpr) k

let rec pull_let_pexpr_name (pexpr : pexpr) (k : tsymbol -> mu_expr 'a) : mu_expr 'a = 
  pull_let_name (normalise_pexpr_name pexpr) k

let rec pull_let_pexprs_names (pexprs : pexprs) (k : tsymbols -> mu_expr 'a) : mu_expr 'a =
  match pexprs with
  | [] -> k []
  | e :: es -> 
     pull_let_pexpr_name e (fun e -> 
     pull_let_pexprs_names es (fun es -> 
     k (e :: es)))
  end

let pull_let_action (action : action 'a) (k : mu_action 'a -> mu_expr 'a) = 
  let (Action t an a) = action in
  let wrap a = M_Action t an a in
  match a with
  | Create e1 e2 sym ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     k (wrap (M_Create e1 e2 sym))))
  | CreateReadOnly e1 e2 e3 sym ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     k (wrap (M_CreateReadOnly e1 e2 e3 sym)))))
  | Alloc e1 e2 sym ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     k (wrap (M_Alloc e1 e2 sym))))
  | Kill b e1 ->
     pull_let_pexpr_name e1 (fun e1 ->
     k (wrap (M_Kill b e1)))
  | Store b e1 e2 e3 mo ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     k (wrap (M_Store b e1 e2 e3 mo)))))
  | Load e1 e2 mo ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     k (wrap (M_Load e1 e2 mo))))
  | RMW e1 e2 e3 e4 mo1 mo2 ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     pull_let_pexpr_name e4 (fun e4 ->
     k (wrap (M_RMW e1 e2 e3 e4 mo1 mo2))))))
  | Fence mo -> 
     k (wrap (M_Fence mo))
  | CompareExchangeStrong e1 e2 e3 e4 mo1 mo2 ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     pull_let_pexpr_name e4 (fun e4 ->
     k (wrap (M_CompareExchangeStrong e1 e2 e3 e4 mo1 mo2))))))
  | CompareExchangeWeak e1 e2 e3 e4 mo1 mo2 ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     pull_let_pexpr_name e4 (fun e4 ->
     k (wrap (M_CompareExchangeWeak e1 e2 e3 e4 mo1 mo2))))))
  | LinuxFence lmo ->
     k (wrap (M_LinuxFence lmo))
  | LinuxLoad e1 e2 lmo ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     k (wrap (M_LinuxLoad e1 e2 lmo))))
  | LinuxStore e1 e2 e3 lmo ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     k (wrap (M_LinuxStore e1 e2 e3 lmo)))))
  | LinuxRMW e1 e2 e3 lmo ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexpr_name e3 (fun e3 ->
     k (wrap (M_LinuxRMW e1 e2 e3 lmo)))))
  end
     

let pull_let_paction pa (k : mu_paction 'a -> mu_expr 'a) = 
  let (Paction pol a) = pa in
  let wrap a = M_Paction pol a in
  pull_let_action a (fun a -> 
  k (wrap a))


(* let rec normalise_expr e = n_expr e (fun e -> e) *)

let rec normalise_expr e =
  n_expr e (fun e -> e)

(* and n_expr_no_let (e : expr 'a) (k : mu_expr 'a -> mu_expr 'a) 
 *         : mu_expr 'a = 
 *   let (Expr annots e_) = e in
 *   let wrap e_ = M_Expr annots e_ in
 *   match e_ with
 *   | Ewseq pat e1 e2 -> 
 *      n_expr_no_let e1 (fun e1 -> 
 *      wrap (M_Ewseq pat e1 (n_expr e2 k)))
 *   | Esseq pat e1 e2 -> 
 *      n_expr_no_let e1 (fun e1 -> 
 *      wrap (M_Esseq pat e1 (n_expr e2 k)))
 *   | Eunseq _ -> failwith "todo Eunseq"
 *   | Easeq _ _ _ -> failwith "todo Easeq"
 *   | Eindet _ _ -> failwith "todo Eindet"
 *   | End _ -> failwith "todo End"
 *   (\* | Eif e1 e2 e3 ->
 *    *    pull_let_pexpr_name e1 (fun e1 ->
 *    *    let e2 = n_expr_no_let_or_ctrl e2 k in
 *    *    let e3 = n_expr_no_let_or_ctrl e3 k in
 *    *    wrap (M_Eif e1 e2 e3))           
 *    * | Ecase e1 pats_es ->
 *    *    pull_let_pexpr_name e1 (fun e1 ->
 *    *    let pats_es = mapsnd (fun e -> n_expr_no_let_or_ctrl e k) pats_es in
 *    *    wrap (M_Ecase e1 pats_es)) *\)
 *   | _ -> n_expr e k
 *   end *)


and n_expr (e : expr 'a) (k : mu_expr 'a -> mu_expr 'a) 
        : mu_expr 'a = 
  let (Expr annot pe) = e in
  let wrap pe : mu_expr 'a = M_Expr annot pe in
  
  match pe with
  | Epure pexpr -> 
     pull_let_pexpr pexpr (fun e -> 
     k (wrap (M_Epure e)))
  | Ememop memop pexprs -> 
     pull_let_pexprs_names pexprs (fun pexprs -> 
     k (wrap (M_Ememop memop pexprs)))
  | Eaction paction ->
     pull_let_paction paction (fun paction ->
     k (wrap (M_Eaction paction)))
  | Ecase pexpr pats_es ->
     pull_let_pexpr_name pexpr (fun pexpr ->
     let pats_es = mapsnd (fun expr -> normalise_expr expr) pats_es in
     k (wrap (M_Ecase pexpr pats_es)))
  | Elet pat e1 e2 ->
     pull_let_pexpr e1 (fun e1 ->
     wrap (M_Elet pat e1 (n_expr e2 k)))
  | Eif e1 e2 e3 ->
     pull_let_pexpr_name e1 (fun e1 ->
     let e2 = normalise_expr e2 in
     let e3 = normalise_expr e3 in
     k (wrap (M_Eif e1 e2 e3)))
  | Eskip ->
     k (wrap (M_Eskip))
  | Eccall a e1 e2 es ->
     pull_let_pexpr_name e1 (fun e1 ->
     pull_let_pexpr_name e2 (fun e2 ->
     pull_let_pexprs_names es (fun es ->
     k (wrap (M_Eccall a e1 e2 es)))))
  | Eproc a name es ->
     pull_let_pexprs_names es (fun es ->
     k (wrap (M_Eproc a name es)))
  | Eunseq es ->
     failwith "todo Eunseq"
  | Ewseq pat e1 e2 ->
     n_expr e1 (fun e1 ->
     wrap (M_Ewseq pat e1 (n_expr e2 k)))
  | Esseq pat e1 e2 ->
     n_expr e1 (fun e1 ->
     wrap (M_Esseq pat e1 (n_expr e2 k)))
  | Easeq b action paction ->
     failwith "todo Easeq"
  | Eindet n e ->
     failwith "todo Eindet"
  | Ebound n e ->
     wrap (M_Ebound n (n_expr e (fun e -> e)))
  | End es ->
     failwith "todo End"
  | Esave b syms_typs_pes e ->  (* have to check *)
     let (syms,typs_pes) = List.unzip syms_typs_pes in
     let (typs,pes) = List.unzip typs_pes in
     pull_let_pexprs_names pes (fun pes ->
     let typs_pes = List.zip typs pes in
     let syms_typs_pes = List.zip syms typs_pes in
     let e = normalise_expr e in
     k (wrap (M_Esave b syms_typs_pes e)))
  | Erun a sym pes ->
     pull_let_pexprs_names pes (fun pes ->
     k (wrap (M_Erun a sym pes)))
  | Epar es -> 
     failwith "todo Epar"
  | Ewait tid ->
     failwith "todo Ewait"
  end




let normalise_impl_decl (i : generic_impl_decl bty) : mu_impl_decl bty =
  match i with
  | Def bt p -> M_Def bt (normalise_pexpr p)
  | IFun bt args body -> M_IFun bt args (normalise_pexpr body)
  end

let normalise_impl (i : generic_impl bty) : mu_impl bty =
  Map.map normalise_impl_decl i

let normalise_fun_map_decl (d : generic_fun_map_decl bty 'a) 
    : mu_fun_map_decl bty 'a =
  match d with
  | Fun bt args pe -> M_Fun bt args (normalise_pexpr pe)
  | Proc loc bt args e -> M_Proc loc bt args (normalise_expr e)
  | ProcDecl loc bt bts -> M_ProcDecl loc bt bts
  | BuiltinDecl loc bt bts -> M_BuiltinDecl loc bt bts
  end

let normalise_fun_map (fmap : generic_fun_map bty 'a) : mu_fun_map bty 'a = 
  Map.map normalise_fun_map_decl fmap
  

let normalise_globs (g : generic_globs 'a bty) : mu_globs 'a bty = 
  match g with
  | GlobalDef bt e -> M_GlobalDef bt (normalise_expr e)
  | GlobalDecl bt -> M_GlobalDecl bt 
  end

let normalise_globs_list (gs : list (Symbol.sym * generic_globs 'a bty) )
    : list (Symbol.sym * mu_globs 'a bty) = 
  List.map (fun (sym,g) -> (sym, normalise_globs g)) gs


let normalise_file file = 
  <| mu_main = file.main
   ; mu_tagDefs = file.tagDefs
   ; mu_stdlib = normalise_fun_map file.stdlib
   ; mu_impl = normalise_impl file.impl
   ; mu_globs = normalise_globs_list file.globs
   ; mu_funs = normalise_fun_map file.funs
   ; mu_extern = file.extern
   ; mu_funinfo = file.funinfo
  |>

