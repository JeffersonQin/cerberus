open import Pervasives
open import Utils
open import Core Core_aux Core_run_aux

import State
import Core_eval Cmm_aux Cmm_csem

(* TODO *)
import Core_run

module Cmm = struct
  include Cmm_aux
  include Cmm_csem
end

module Caux = Core_aux
module EU  = Exception_undefined
module SEU = State_exception_undefined

(* TODO: duplicate from Core_run *)
module E = struct
  let inline return = SEU.return
  let inline undef  = SEU.undef
  let inline mapM   = SEU.mapM
  let inline foldlM = SEU.foldM
  
  let fresh_excluded_id =
    SEU.runS (fun run_st ->
    let n = run_st.excluded_supply in
    (n, <| run_st with excluded_supply= n+1 |>)
  )
  
  let eval_pexpr2 th_st core_extern mem_st file pe =
    SEU.runEU (Core_eval.eval_pexpr_aux2 th_st.current_loc core_extern th_st.env (Just mem_st) file pe)
end

let inline (>>=) = SEU.bind
let inline (<$>) = SEU.fmap

let rec full_eval_pexpr th_st core_extern mem_st file pe =
  E.eval_pexpr2 th_st core_extern mem_st file pe >>= (function
    | Left pe' ->
        full_eval_pexpr th_st core_extern mem_st file pe'
    | Right cval ->
        E.return cval
  end)





type action_request2 'a =
  | AllocRequest2 of Symbol.prefix
                  *  Mem.integer_value (* alignment constraint *)
                  *  Mem.integer_value (* size of allocation *)
                  *  (Cmm.aid -> Mem.pointer_value -> 'a) (* new thread state builder *)
  
  | CreateRequest2 of Symbol.prefix
                   *  Mem.integer_value (* alignment constraint *)
                   *  Ctype.ctype (* C type of allocation *)
                   *  maybe Mem.mem_value (* optional initialisation value *)
                   *  (Cmm.aid -> Mem.pointer_value -> 'a)
  
  | StoreRequest2 of Cmm.memory_order (* C11 memory order *)
                  *  Ctype.ctype (* C type of lvalue *)
                  *  bool (* whether the store locks the allocation *)
                  *  Mem.pointer_value
                  *  Mem.mem_value 
                  *  (Cmm.aid -> Mem.footprint -> 'a)
  
  | LoadRequest2 of Cmm.memory_order (* C11 memory order *)
                 *  Ctype.ctype (* C type of lvalue *)
                 *  Mem.pointer_value
              (* *  Symbol.sym  (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *) *)
                 *  (Cmm.aid -> Mem.footprint -> Mem.mem_value -> 'a)
  
  | SeqRMWRequest2 of Ctype.ctype
                   *  Mem.pointer_value
                   *  (Mem.mem_value -> core_runM Mem.mem_value)
                   *  (Cmm.aid -> Mem.footprint -> Mem.mem_value -> Mem.mem_value -> 'a)
  
  (* TODO: RMW, Fence *)
  | KillRequest2 of (* is_dynamic *)bool * Mem.pointer_value * (Cmm.aid -> 'a)


type runstate_step_kind =
  | RSK_eval of string
  | RSK_tau of string * Core_run.core_tau_step_kind

type core_step2 =
  | Step_with_runstate2 of runstate_step_kind * core_runM thread_state
  | Step_tau2 of string * Core_run.core_tau_step_kind * thread_state
  
  | Step_action_request2 of string * Loc.t * (* set Cmm.aid * set Cmm.aid * set Cmm.aid * *)
                            Mem_common.thread_id *
                            core_runM (action_request2 thread_state)
  | Step_aseq of Loc.t * Mem_common.thread_id * action_request2 unit * action_request2 thread_state
  
  | Step_blocked2
  | Step_error2 of string
  | Step_thread_done2 of Mem_common.thread_id * Core.value
  | Step_done2 of Core.value
  | Step_memop_request2 of Mem_common.memop * list Core.value * Mem_common.thread_id * (Core.value -> thread_state)
  | Step_spawn_threads2 of (list Mem_common.thread_id -> thread_state) * list thread_state (* initial states for the children *)
(*  | Step_fs2 of thread_state * Core_run.fs_oper *)
  | Step_fs2 of thread_state * core_runM Core_run.fs_oper
  | Step_nd2 of list thread_state


instance (Show core_step2)
  let show step =
    match step with
      | Step_with_runstate2 kind _ ->
          let kind_str =
            match kind with
              | RSK_eval debug_str ->
                  "RSK_eval[" ^ debug_str ^ "]"
              | RSK_tau debug_str kind' ->
                let kind'_str =
                  match kind' with
                    | Core_run.TSK_Ccall sym _ ->
                        "TSK_Ccall(" ^ show sym ^ ")"
                    | Core_run.TSK_Return sym _ ->
                        "TSK_Return(" ^ show sym ^ ")"
                    | Core_run.TSK_Misc ->
                        "TSK_Misc"
                  end in
                "RSK_tau[" ^ debug_str ^ ", " ^ kind'_str ^ "]"
            end in
          "Step_with_runstate2[" ^ kind_str ^ "]"
      | Step_tau2 debug_str kind _ ->
          "Step_tau2<TAU>[" ^ debug_str ^ "]"
      | Step_action_request2 debug_str loc tid _ ->
          "Step_action_request2[" ^ debug_str ^ "] -- tid: " ^ show tid ^ " -- at loc: " ^ Loc.stringFromLocation loc
      | Step_aseq loc tid _(*action_request2 unit*) _ ->
        "Step_aseq -- tid: " ^ show tid ^ " -- at loc: " ^ Loc.stringFromLocation loc
      | Step_blocked2 ->
          "Step_blocked2"
      | Step_error2 debug_str ->
          "Step_error2[" ^ debug_str ^ "]"
      | Step_thread_done2 tid cval ->
          "Step_thread_done2(tid: " ^ show tid ^ ") -- value: " ^ Pp.stringFromCore_value cval
      | Step_done2 cval ->
          "Step_done2 -- value: " ^ Pp.stringFromCore_value cval
      | Step_memop_request2 memop _ tid _ ->
          "Step_memop_request2[" ^ show memop ^ "] -- tid: " ^ show tid
      | Step_spawn_threads2 _ _ ->
          "Step_spawn_threads2"
      | Step_fs2 _ _ ->
          "Step_fs2"
    end
end

(* ********************************************************************************************* *)

let is_irreducible = function
    (* annot(..., annot(..., _)) ==> NOTE THE _ may be a value *)
  | Expr _ (Eannot _ (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))))) ->
      (* TODO: this makes the function misnamed, but this has a one step reduction *)
      false
    (* v *)
  | Expr _ (Epure (Pexpr _ _ (PEval _))) ->
      true
    (* annot(..., v) *)
  | Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))) ->
      true
  | _ ->
      false
end


import Debug


val do_race: list Core.dyn_annotation -> list Core.dyn_annotation -> bool
let do_race xs1 xs2 =
  List.any (function
    | DA_neg id1 exclusion1 fp1 ->
        List.any (function
          | DA_neg id2 exclusion2 fp2 ->
              if List.elem id1 exclusion2 || List.elem id2 exclusion1 then
                false
              else
                Mem.do_overlap fp1 fp2
          | DA_pos exclusion2 fp2 ->
              if List.elem id1 exclusion2 then
                false
              else
                Mem.do_overlap fp1 fp2
        end) xs2
    | DA_pos exclusion1 fp1 ->
        List.any (function
          | DA_neg id2 _ fp2 ->
              if List.elem id2 exclusion1 then
                false
              else
                Mem.do_overlap fp1 fp2
          | DA_pos _ fp2 ->
                Mem.do_overlap fp1 fp2
        end) xs2
  end) xs1


val combine_dyn_annotations: list Core.dyn_annotation -> list Core.dyn_annotation -> list Core.dyn_annotation
let combine_dyn_annotations xs1 xs2 =
  xs1 ++ xs2


type one_step =
  | TAU_WITH_RUNSTATE of string * core_runM (list (map Symbol.sym value) * Core.expr core_run_annotation)
  | TAU of string * list (map Symbol.sym value) * Core.expr core_run_annotation
  | EVAL of string * core_runM (Core.expr core_run_annotation)
  | ND of list (Core.expr core_run_annotation)
  | MEMOP of Mem_common.memop * list Core.value
  | UNSEQUENCED_RACE
  | ILLTYPED of string


let rec one_step_unseq_aux (fps_acc, cvals_acc) = function
  | [] ->
      Just (fps_acc, List.reverse cvals_acc)
  | Expr _ (Epure (Pexpr _ _ (PEval cval))) :: xs ->
      one_step_unseq_aux (fps_acc, cval::cvals_acc) xs
  | Expr _ (Eannot fps (Expr _ (Epure (Pexpr _ _ (PEval cval))))) :: xs ->
      if do_race fps fps_acc then
        let () = Debug.print_debug 2 [Debug.DB_core_dynamics] (fun () ->
          "FOUND AN UNSEQUENCED RACE: " ^ show fps ^ " <---> " ^ show fps_acc
        ) in
        (* we found an unsequenced race (undefined behaviour) *)
        Nothing
      else
        one_step_unseq_aux (combine_dyn_annotations fps fps_acc, cval :: cvals_acc) xs
  | e :: _ ->
      (* all the operand of the unseq() must have already been reduced to values *)
      error ("Core_reduction.one_step_unseq_aux ==> " ^ Pp.stringFromCore_expr e)
  end


(* Effectless reductions *************************************************************************)
(* NOTE: for performance, we use scoped environment instead of substitutions for bound variables *)
val one_step:
  (Core.pexpr -> core_runM Core.pexpr) ->
  (Core.pexpr -> core_runM Core.value) ->
  list (map Symbol.sym value) -> Core.expr core_run_annotation -> maybe one_step
let one_step eval_pexpr full_eval_pexpr env (Expr annots expr_ as expr) =
  if is_irreducible expr then
    Nothing
  else match expr_ with
    | Epure pe ->
        match valueFromPexpr pe with
          | Just _ ->
              Nothing
          | Nothing ->
              (* reduction: PURE + PURE-UNDEF *)
              Just begin
              (*     eval e = v
                -------------------
                pure(e) --> pure(v) *)
                EVAL "Epure" begin
                  full_eval_pexpr pe >>= fun cval ->
                  E.return (Expr annots (Epure (Caux.mk_value_pe cval)))
                end
              end
      end
    
    | Eannot xs1 (Expr annots2 (Eannot xs2 e)) ->
        (* {A_1} {A_2} E --> {A_1 union A_2} E *)
        (* reduction: ANNOTS *)
        Just (TAU "Eannot" env (Expr (annots ++ annots2) (Eannot (combine_dyn_annotations xs1 xs2) e)))
    
    | Ememop memop pes ->
        Just match valueFromPexprs pes with
          | Just cvals ->
              MEMOP memop cvals
          | Nothing ->
              EVAL "Ememop" begin
                E.mapM eval_pexpr pes >>= fun pes' ->
                E.return (Expr annots (Ememop memop pes'))
              end
        end
    
    | Ecase (Pexpr _ () (PEconstrained xs)) _ ->
        error "TODO: Core_reduction.one_step, Ecase PEconstrained"
    | Ecase pe pat_es ->
        (* reduction: CASE + CASE-UNDEF *)
        Just match valueFromPexpr pe with
          | Just cval ->
              (* TODO: stop using subst? *)
              match select_case subst_sym_expr cval pat_es with
                | Just e' ->
                    TAU "Ecase" env e'
                | Nothing ->
                    ILLTYPED ("Ecase, mismatched ==> " ^ Pp.stringFromCore_expr expr)
              end
          | Nothing ->
              EVAL "Ecase" begin
                eval_pexpr pe >>= fun pe' ->
                E.return (Expr annots (Ecase pe' pat_es))
              end
        end
    
    | Elet pat pe1 e2 ->
        match valueFromPexpr pe1 with
          | Just cval ->
              (* let pat = v in E2 --> { v / pat } E2 *)
              (* reductions: LET(last step) *)
              Just (TAU "Elet" (update_env pat cval env) e2)
          | Nothing ->
              Just begin
              (*              eval e1 = v
                 -------------------------------------
                 let pat = e1 in E2 --> { v / pat } E2 *)
                (* reductions: LET(first step) + LET-UNDEF *)
                TAU_WITH_RUNSTATE "Elet" begin
                  full_eval_pexpr pe1 >>= fun cval ->
                  E.return (update_env pat cval env, e2)
                end
              end
        end
    
    | Eif pe1 e2 e3 ->
        (* reductions: IF-TRUE + IF-FALSE + IF-UNDEF *)
        Just begin
          TAU_WITH_RUNSTATE "Eif" begin
            full_eval_pexpr pe1 >>= function
              | Vtrue ->
                  E.return (env, e2)
              | Vfalse ->
                  E.return (env, e3)
              | _ ->
                  error "TODO(use the core_runM) ILLTYPED, the first operand of an Eif didn't evaluated to a boolean"
            end
          end
        end
    
    | Eunseq es ->
        (* assert: List.all is_irreducible es *)
        match one_step_unseq_aux ([], []) es with
          | Nothing ->
              (* reductions: UNSEQ-RACE *)
              Just UNSEQUENCED_RACE
          | Just (fps, cvals) ->
              (* unseq({A_1}?v1, ..., {A_n}?vn) -->
                 {A_1 ...union... A_n}(v1, ..., v2)    (in the absence of race) *)
              (* reductions: UNSEQ-PURE + UNSEQ-ANNOT *)
              Just (TAU "Eunseq" env (Expr annots (Eannot fps (Caux.mk_value_e (Vtuple cvals)))))
        end
    
    | Ewseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* letw pat = v in E2 --> { v / pat } E2 *)
              TAU "Ewseq" (update_env pat cval env) e2
          | Nothing ->
              error "Core_reduction.one_step Ewseq saw a non-evaluated e1"
        end
    | Esseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* lets pat = v in E2 --> { v / pat } E2 *)
              TAU "Esseq" (update_env pat cval env) e2
          | Nothing ->
            error "Core_reduction.one_step Esseq saw a non-evaluated e1"
        end
    
    | Ewseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* letw pat = {A}v in E2 --> {A} { v / pat } E2 *)
              TAU "Ewseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              error "Core_reduction.one_step Ewseq Eannot saw a non-evaluated e1"
        end
    | Esseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              (* lets pat = {A}v in E2 --> {A} { v / pat } E2 *)
              TAU "Esseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              error "Core_reduction.one_step Esseq Eannot saw a non-evaluated e1"
        end
    
    | Esave sym_bTy sym_bTy_pes e ->
        Just match valueFromPexprs (List.map (fun (_, (_, z)) -> z) sym_bTy_pes) with
          | Just cvals ->
              TAU "Esave"
                begin
                  List.foldl (fun acc ((sym, (bTy, _)), cval) ->
                    update_env (Caux.mk_sym_pat sym bTy) cval acc
                 ) env (List.zip sym_bTy_pes cvals)
                end
                e
          | Nothing ->
              EVAL "Esave" begin
                E.mapM (fun (sym, (bTy, pe)) ->
                  eval_pexpr pe >>= fun pe' ->
                  E.return (sym, (bTy, pe'))
                ) sym_bTy_pes >>= fun sym_bTy_pes' ->
                E.return (Expr annots (Esave sym_bTy sym_bTy_pes' e))
              end
        end
    | End es ->
        (* reduction: ND *)
        Just (ND es)

    | _ ->
        Nothing
  end






val     get_ctx: Core.expr core_run_annotation -> list (context * Core.expr core_run_annotation)
let rec get_ctx (Expr annot expr_ as expr) =
  if is_irreducible expr then
    [(CTX, expr)]
  else match expr_ with
    | Epure _ ->
        [(CTX, expr)]
    | Ememop  _ _ ->
        [(CTX, expr)]
    | Eaction _ ->
        [(CTX, expr)]
    | Ecase _ _ ->
        [(CTX, expr)]
    | Elet _ _ _ ->
        [(CTX, expr)]
    | Eif _ _ _ ->
        [(CTX, expr)]
    | Eccall _ _ _ _ ->
        [(CTX, expr)]
    | Eproc _ _ _ ->
        [(CTX, expr)]
    | Eunseq es ->
        if List.all is_irreducible es then
          [(CTX, expr)]
        else
          get_ctx_unseq_aux annot [] [] es
    | Ewseq pat e1 e2 ->
        if is_irreducible e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cwseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Esseq pat e1 e2 ->
        if is_irreducible e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Csseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Easeq _ _ _ ->
        [(CTX, expr)]
    | Ebound e ->
        if is_irreducible e then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cbound annot ctx, e)
          ) (get_ctx e)
    | End _ ->
        [(CTX, expr)]
    | Esave _ _ _ ->
        [(CTX, expr)]
    | Erun _ _ _ ->
        [(CTX, expr)]
    | Epar _ ->
        [(CTX, expr)]
    | Ewait _ ->
        [(CTX, expr)]
    | Eannot _ (Expr _ (Eannot _ e)) ->
        [(CTX, expr)]
    | Eannot xs e ->
        List.map (fun (ctx, e) ->
          (Cannot annot xs ctx, e)
        ) (get_ctx e)
    | Eexcluded _ _ ->
        [(CTX, expr)]
  end

and get_ctx_unseq_aux annot acc es1 = function
  | [] ->
      acc
  | e :: es2 ->
      if is_irreducible e then
        get_ctx_unseq_aux annot acc (es1 ++ [e]) es2
      else
        let zs =
          List.map (fun (ctx, e) ->
            (Cunseq annot es1 ctx es2, e)
          ) (get_ctx e) in
        get_ctx_unseq_aux annot (zs ++ acc) (es1 ++ [e]) es2
end


val     apply_ctx: context -> Core.expr core_run_annotation -> Core.expr core_run_annotation
let rec apply_ctx ctx expr =
  match ctx with
    | CTX ->
        expr
    | Cunseq annot es1 ctx' es2 ->
        Expr annot (Eunseq (es1 ++ (apply_ctx ctx' expr :: es2)))
    | Cwseq annot pat ctx' e2 ->
        Expr annot (Ewseq pat (apply_ctx ctx' expr) e2)
    | Csseq annot pat ctx' e2 ->
        Expr annot (Esseq pat (apply_ctx ctx' expr) e2)
    | Cannot annot xs ctx' ->
        Expr annot (Eannot xs (apply_ctx ctx' expr))
    | Cbound annot ctx' ->
        Expr annot (Ebound (apply_ctx ctx' expr))
  end


let act_valueFromPexpr = function
  | Pexpr _ _ (PEconstrained _) ->
      error "Core_reduction.step_action => PEconstrained"
  | z ->
      valueFromPexpr z
end

type action_step =
  | ACTION_REQUEST of string * Loc.t * action_request2 (Core.expr core_run_annotation)
  | ACTION_EVAL of string * core_runM (Core.action core_run_annotation)
  | ACTION_ILLTYPED of string

val step_action:
    (Core.pexpr -> core_runM Core.pexpr) -> maybe nat -> Core.action core_run_annotation -> action_step
let step_action eval_pexpr is_excluded (Action loc act_annots act) =
  let wrap z =
    Action loc act_annots z in
  match act with
    | Create pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty)) ->
              ACTION_REQUEST
                "CreateRequest"
                loc
                begin
                  CreateRequest2 pref ival ty Nothing (fun aid ptrval ->
                    Caux.mk_value_e (Vobject (OVpointer ptrval))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Create"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Create" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Create pe1' pe2 pref))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Create" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Create pe1 pe2' pref))
              end
        end
    | CreateReadOnly pe1 pe2 pe3 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty), Just cval3) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                | Just mval ->
                    ACTION_REQUEST
                      "CreateRequest"
                      loc
                      begin
                        CreateRequest2 pref ival ty (Just mval) (fun aid ptrval ->
                          Caux.mk_value_e (Vobject (OVpointer ptrval))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a create_readonly(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval3
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "CreateReadOnly"
          | (Nothing, _, _) ->
              ACTION_EVAL "first operand of CreateReadOnly" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (CreateReadOnly pe1' pe2 pe3 pref))
              end
          | (_, Nothing, _) ->
              ACTION_EVAL "second operand of CreateReadOnly" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (CreateReadOnly pe1 pe2' pe3 pref))
              end
          | (_, _, Nothing) ->
              ACTION_EVAL "third operand of CreateReadOnly" begin
                eval_pexpr pe3 >>= fun pe3' ->
                E.return (wrap (CreateReadOnly pe1 pe2 pe3' pref))
              end
        end
    | Store is_locking pe1 pe2 (Pexpr _ () (PEconstrained xs3)) mo ->
        error "TODO: Core_reduction.step_action => Store pe1 pe2 PEconstrained"
    | Store is_locking pe1 pe2 pe3 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)), Just cval) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval with
                | Just mval ->
                    ACTION_REQUEST
                      "StoreRequest"
                      loc
                      begin
                        StoreRequest2 mo ty is_locking ptrval mval (fun aid fp ->
                          let dyn_annots =
                            match is_excluded with
                              | Nothing ->
                                  [DA_pos [] fp]
                              | Just excl_id ->
                                  [DA_neg excl_id [] fp]
                            end in
                          Expr [] (Eannot dyn_annots (Caux.mk_value_e Vunit))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a store(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "Store"
          | (Nothing, _, _) ->
              ACTION_EVAL "first operand of Store" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Store is_locking pe1' pe2 pe3 mo))
              end
          | (_, Nothing, _) ->
              ACTION_EVAL "second operand of Store" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Store is_locking pe1 pe2' pe3 mo))
              end
          | (_, _, Nothing) ->
              ACTION_EVAL "third operand of Store" begin
                eval_pexpr pe3 >>= fun pe3' ->
                E.return (wrap (Store is_locking pe1 pe2 pe3' mo))
              end
        end
    | Load pe1 pe2 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)))  ->
              ACTION_REQUEST
                "LoadRequest"
                loc
                begin
                  LoadRequest2 mo ty ptrval (fun aid fp mval ->
                    let dyn_annots =
                      match is_excluded with
                        | Nothing ->
                            [DA_pos [] fp]
                        | Just excl_id ->
                            [DA_neg excl_id [] fp]
                      end in
                    let (_, cval) = Caux.valueFromMemValue mval in
                    Expr [] (Eannot dyn_annots (Caux.mk_value_e cval))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Load"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Load" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Load pe1' pe2 mo))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Load" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Load pe1 pe2' mo))
              end
        end
    | Alloc pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
              ACTION_REQUEST
                "AllocRequest"
                loc
                begin
                  AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                    Caux.mk_value_e (Vobject (OVpointer ptrval))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Alloc"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Alloc" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Alloc pe1' pe2 pref))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Alloc" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Alloc pe1 pe2' pref))
              end
        end
    | Kill is_dynamic pe ->
        match act_valueFromPexpr pe with
          | Just (Vobject (OVpointer ptrval)) ->
              ACTION_REQUEST
                "KillRequest"
                loc
                begin
                  KillRequest2 is_dynamic ptrval
                    (fun aid -> Caux.mk_value_e Vunit)
                end
          | Just _ ->
              ACTION_ILLTYPED "Kil"
          | Nothing ->
              ACTION_EVAL "operand of Kill" begin
                eval_pexpr pe >>= fun pe' ->
                E.return (wrap (Kill is_dynamic pe'))
              end
        end
end




let is_constrained = function
  | Pexpr _ _ (PEconstrained _) ->
      true
  | _ ->
      false
end


(*
val step_action2:
    (Core.pexpr -> core_runM Core.value) -> maybe nat -> Core.action core_run_annotation -> core_runM action_step
let step_action2 full_eval_pexpr is_excluded (Action loc act_annots act) =
(*
  let wrap z =
    Action loc act_annots z in
*)
  match act with
    | Load pe1 pe2 mo ->
        if is_constrained pe1 || is_constrained pe2 then
          error "Core_reduction.step_action => PEconstrained"
        else
          full_eval_pexpr pe1 >>= fun cval1 ->
          full_eval_pexpr pe2 >>= fun cval2 ->
          E.return match (cval1, cval2) with
            | (Vctype ty, Vobject (OVpointer ptrval)) ->
                ACTION_REQUEST
                  "LoadRequest"
                  loc
                  begin
                    let val_sym = Symbol.fresh () in
                    LoadRequest2 mo ty ptrval val_sym (fun aid fp mval ->
                      let dyn_annots =
                        match is_excluded with
                          | Nothing ->
                              [DA_pos [] fp]
                          | Just excl_id ->
                              [DA_neg excl_id [] fp]
                        end in
                      let (oTy, cval) = valueFromMemValue mval in
                      Expr [] (Eannot dyn_annots (Caux.mk_value_e cval)) )
                  end
            | _ ->
                error "TODO: illtyped load"
          end
    | Store is_locking pe1 pe2 pe3 mo ->
        if is_constrained pe1 || is_constrained pe2  || is_constrained pe3 then
          error "Core_reduction.step_action => PEconstrained"
        else
          full_eval_pexpr pe1 >>= fun cval1 ->
          full_eval_pexpr pe2 >>= fun cval2 ->
          full_eval_pexpr pe3 >>= fun cval3 ->
          E.return match (cval1, cval2) with
            | (Vctype ty, Vobject (OVpointer ptrval)) ->
                match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                  | Just mval ->
                      ACTION_REQUEST
                        "StoreRequest"
                        loc
                        begin
                          StoreRequest2 mo ty is_locking ptrval mval (fun aid fp ->
                            let dyn_annots =
                              match is_excluded with
                                | Nothing ->
                                    [DA_pos [] fp]
                                | Just excl_id ->
                                    [DA_neg excl_id [] fp]
                            end in
                            Expr [] (Eannot dyn_annots (Caux.mk_value_e Vunit))
                          )
                        end
                | Nothing ->
                    error "didn't match the lvalue type in Store"
(*
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a store(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval
                    end
*)
              end
          end
  end
*)







val break_at_sseq:
  context -> maybe (context * Core.pattern * context * Core.expr core_run_annotation)
(*
  | CTX
  | Cunseq of list Annot.annot * list (Core.expr core_run_annotation) * context * list (Core.expr core_run_annotation)
  | Cwseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Csseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Cannot of list Annot.annot * Core.dyn_annotation * context
  | Cbound of list Annot.annot * context
*)

let rec break_at_sseq ctx =
  match ctx with
    | CTX ->
        Nothing
    | Cwseq annots pat ctx' e2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cwseq annots pat ctxA e2, sseq_pat, ctxB, sseq_e2)
        end
    | Csseq annots pat ctx' e2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Just (CTX, pat, ctx', e2)
          | Just (in_ctxA, in_pat, in_ctxB, in_e2) ->
              Just (Csseq annots pat in_ctxA e2, in_pat, in_ctxB, in_e2)
      end
    | Cunseq annots es1 ctx' es2 ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cunseq annots es1 ctxA es2, sseq_pat, ctxB, sseq_e2)
        end
    | Cannot annots xs ctx' ->
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cannot annots xs ctxA, sseq_pat, ctxB, sseq_e2)
        end
    | Cbound annots ctx' ->
        error "break_at_sseq, Cbound"
(*
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cbound annots ctxA, sseq_pat, ctxB, sseq_e2)
        end
*)
  end

type break =
  | NO_BOUND
  | BOUND_NO_SSEQ of context * context
  | BOUND_WITH_SSEQ of context * context * Core.pattern * context * Core.expr core_run_annotation

let rec break_at_bound_and_sseq ctx =
  match ctx with
    | CTX ->
        NO_BOUND
    | Cwseq annots pat ctx' e2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cwseq annots pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cwseq annots pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
        end
    | Csseq annots pat ctx' e2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Csseq annots pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Csseq annots pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
      end
    | Cunseq annots es1 ctx' es2 ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cunseq annots es1 ctxA es2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cunseq annots es1 ctxA es2) ctxB sseq_pat ctxC e2_sseq
        end
    | Cannot annots xs ctx' ->
        match break_at_bound_and_sseq ctx' with
          | NO_BOUND ->
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB ->
              BOUND_NO_SSEQ (Cannot annots xs ctxA) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq ->
              BOUND_WITH_SSEQ (Cannot annots xs ctxA) ctxB sseq_pat ctxC e2_sseq
        end
    | Cbound annots ctx' ->
        match break_at_sseq ctx' with
          | Nothing ->
              BOUND_NO_SSEQ (Cbound annots CTX) ctx'
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              BOUND_WITH_SSEQ (Cbound annots CTX) ctxA sseq_pat ctxB sseq_e2
        end
  end


let rec pull_dyn_annotations z =
  match z with
    | CTX ->
        ([], CTX)
    | Cunseq annots es1 ctx es2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cunseq annots es1 ctx' es2)
    | Cwseq annots pat ctx e2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cwseq annots pat ctx' e2)
    | Csseq annots pat ctx e2 ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Csseq annots pat ctx' e2)
    | Cannot annots xs ctx ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (xs :: acc, ctx')
    | Cbound annots ctx ->
        let (acc, ctx') = pull_dyn_annotations ctx in
        (acc, Cbound annots ctx')
  end

let rec add_exclusion n = function
  | CTX ->
      CTX
  | Cunseq annots es1 ctx' es2 ->
      Cunseq annots es1 (add_exclusion n ctx') es2
  | Cwseq annots pat ctx' e2 ->
      Cwseq annots pat (add_exclusion n ctx') e2
  | Csseq annots pat ctx' e2 ->
      Csseq annots pat (add_exclusion n ctx') e2
  | Cannot annots xs ctx' ->
      let xs' = List.map (function
        | DA_neg id excl fp ->
            DA_neg id (n::excl) fp
        | DA_pos excl fp ->
            DA_pos (n::excl) fp
      end) xs in
      Cannot annots xs' (add_exclusion n ctx')
  | Cbound annots ctx' ->
      Cbound annots (add_exclusion n ctx')
end


let step_fs_proc th_st iCst cvals =
  let charFromMValue errmsg = function
    | Vobject (OVinteger ival) ->
        match Mem_aux.integerFromIntegerValue ival with
          | Just n -> Decode.encode_character_constant n
          | Nothing -> error errmsg
        end
    | _ -> error errmsg
  end in
  let _forceIntegerFromIntegerValue errmsg ival =
    match Mem_aux.integerFromIntegerValue ival with
      | Just n -> n
      | Nothing -> error errmsg
    end in
  match iCst with
    | Implementation.BuiltinFunction "printf" ->
        match cvals with
          | [Vlist _ fmt_cvals; Vlist _ args_cvals] ->
              let fmt = List.map (charFromMValue "printf") fmt_cvals in
              let args_ptrvals = List.map (function
                | Vtuple [Vctype ty; Vobject (OVpointer ptr_val)] -> (ty, ptr_val)
                | _ -> error "Core_run, printf the second argument should be a list of (ctype, pointer) pairs"
              end) args_cvals in
              Core_run.FS_PRINTF fmt args_ptrvals
          | _ ->
              error ("Core_run, printf giving arguments of wrong types ==> " ^ stringFromList Pp.stringFromCore_value cvals)
        end
    | _ ->
        error "TODO: Eproc ==> impl"
  end




val step_ctx:
  Mem.mem_state -> Core.file core_run_annotation -> map Symbol.sym Symbol.sym ->
  Mem_common.thread_id -> (maybe Mem_common.thread_id * thread_state) ->
  list core_step2
let step_ctx mem_st file core_extern current_tid (parent_tid_opt, th_st) =
  let eval_pexpr pe =
    E.eval_pexpr2 th_st core_extern mem_st file pe >>= function
      | Left pe' ->
          E.return pe'
      | Right cval ->
          E.return (Caux.mk_value_pe cval)
    end in
  let full_eval_pexpr' pe =
    full_eval_pexpr th_st core_extern mem_st file pe in
  List.map (function
    | (CTX, Expr e_annots (Epure (Pexpr _ _ (PEval cval)))) ->
        match th_st.stack with
          | Stack_empty ->
              (* reached the end of the execution of a thread. *)
              match parent_tid_opt with
                | Just parent_tid ->
                    (* reduction: THREAD-DONE *)
                    Step_thread_done2 parent_tid cval
                | Nothing ->
                    (* this was the startup thread *)
                    (* reduction: PROGRAM-DONE *)
                    Step_done2 cval
              end
          | Stack_cons2 parent_proc_opt caller_ctx sk' ->
              (* reached the end of the execution of a procedure. *)
              let tsk =
                match th_st.current_proc_opt with
                  | Just psym ->
                      match Map.lookup psym file.funinfo with
                        | Just (_, _, ret_ty, _, _, _) ->
                            Core_run.TSK_Return psym (Core_aux.memValueFromValue ret_ty cval)
                        | Nothing ->
                            Core_run.TSK_Misc
                      end
                  | Nothing ->
                      Core_run.TSK_Misc
                end in
              (* reduction: RETURN *)
              Step_tau2 "end of procedure" tsk begin
                match th_st.env with
                  | [] ->
                      error "end of proc, found an empty Core_run env"
                  | _ :: env' ->
                      <| th_st with
                        arena= apply_ctx caller_ctx (Expr e_annots (Epure (Caux.mk_value_pe cval)));
                        stack= sk';
                        env= env';
                        current_proc_opt= parent_proc_opt; |>
                end
              end
        end
    
    | (CTX, (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr')))) ->
        (* {A}v -> v   (in empty context) *)
        (* reduction: REMOVE-ANNOT *)
        Step_tau2 "CTX, Eannot(value)" Core_run.TSK_Misc begin
          <| th_st with arena= expr' |>
        end
    
    | (ctx, expr) ->
        let Expr e_annots expr_ = expr in
        let maybe_loc = Annot.get_loc e_annots in
        let th_st = match maybe_loc with
          | Nothing ->
              th_st
          | Just loc ->
              <| th_st with current_loc= loc; |>
        end in
        let wrap_expr z = <| th_st with arena= apply_ctx ctx z |> in
        let process_action is_excluded wrap_act z =
          match step_action eval_pexpr is_excluded z with
            | ACTION_REQUEST debug_str loc _request ->
                Step_action_request2 debug_str loc current_tid begin
                  E.return match _request with
                    | CreateRequest2 pref ival ty mval_opt mk_expr' ->
                        CreateRequest2 pref ival ty mval_opt (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | AllocRequest2 pref ival1 ival2 mk_expr' ->
                        AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | LoadRequest2 mo ty ptrval mk_expr' ->
                        LoadRequest2 mo ty ptrval (fun aid fp mval ->
                          wrap_expr (mk_expr' aid fp mval)
                        )
                    | StoreRequest2 mk ty is_locking ptrval mval mk_expr' ->
                        StoreRequest2 mk ty is_locking ptrval mval (fun aid fp ->
                          wrap_expr (mk_expr' aid fp)
                        )
                    | KillRequest2 is_dynamic ptrval mk_expr' ->
                        KillRequest2 is_dynamic ptrval (fun aid ->
                          wrap_expr (mk_expr' aid)
                        )
                  end
                end
            | ACTION_EVAL debug_str eval_m ->
                Step_with_runstate2 (RSK_eval debug_str) begin
                  eval_m >>= fun act' ->
                  E.return (wrap_expr (Expr e_annots (wrap_act act')))
                end
            | ACTION_ILLTYPED str ->
                Step_error2 str
          end in
        match expr_ with
          | Epure (Pexpr _ _ (PEval _)) ->
              error ("Core_run.step_ctx ==> found a value with ctx <> CTX ==> " ^
                     Pp.stringFromCore_expr expr ^ " <--> " ^ show ctx)
          
          | Ebound (Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr'))) ->
              (* bound({A}v)-> v *)
              (* reduction: REMOVE-BOUND *)
              Step_tau2 "CTX, Ebound Eannot(value)" Core_run.TSK_Misc begin
                wrap_expr expr'
              end
          
          | Ebound (Expr _ (Epure (Pexpr _ _ (PEval _))) as expr') ->
              (* bound(v)-> v *)
              (* reduction: REMOVE-BOUND *)
              Step_tau2 "CTX, Ebound(value)" Core_run.TSK_Misc begin
                wrap_expr expr'
              end
          
          | Eaction (Paction p (Action loc _ (SeqRMW with_forward pe1 pe2 sym pe3))) ->
              if p = Neg then
                error "TODO(better typing) negative SeqRMW should be forbidden by the typecheck"
              else
                Step_action_request2 "SeqRMW" loc current_tid begin
                  full_eval_pexpr' pe1 >>= fun cval1 ->
                  full_eval_pexpr' pe2 >>= fun cval2 ->
                  match (cval1, cval2) with
                    | (Vctype ty, Vobject (OVpointer ptrval)) ->
                        E.fresh_excluded_id >>= fun n ->
                        E.return begin
                          SeqRMWRequest2 ty ptrval (fun mval ->
                            let th_st_tmp =
                              <| th_st with env=
                                match th_st.env with
                                  | [] ->
                                      error "Core_reduction.step_ctx, SeqRMW ==> env is empty"
                                  | x :: xs ->
                                      Map.insert sym (snd (Caux.valueFromMemValue mval)) x :: xs
                                end |> in
                            full_eval_pexpr th_st_tmp core_extern mem_st file pe3 >>= fun cval3 ->
                            match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                              | Just mval' ->
                                  E.return mval'
                              | Nothing ->
                                  error "TODO(use the error the monad) didn't match the lvalue type in SeqRMW"
                            end)
                            (fun aid fp mval mval' ->
                              let cval_e =
                                Caux.mk_value_e (snd (Caux.valueFromMemValue (if with_forward then mval' else mval))) in
                              let mk_annot_e z = Expr [] (Eannot [DA_neg n [] fp] z) in
                              (* TODO: try to factorize this with the code for negative actions *)
                              match break_at_bound_and_sseq ctx with
                                | NO_BOUND ->
                                    error "TODO: NO_BOUND (SeqRMW)"
                                | BOUND_NO_SSEQ ctx_bound ctxA ->
                                    let ctxA' = add_exclusion n ctxA in
                                    let sym = Symbol.fresh () in
                                    let expr' =
                                      Caux.mk_wseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                        ; Caux.mk_sym_pat sym BTy_unit(*TODO:HACKHACK*) ])
                                                     (Caux.mk_unseq_e [ mk_annot_e (Caux.mk_value_e Vunit)
                                                                      ; apply_ctx ctxA' cval_e ])
                                                     (Caux.mk_pure_e (Caux.mk_sym_pe sym)) in
                                    <| th_st with arena= apply_ctx ctx_bound expr' |>
                                | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 ->
                                    (* TODO: check *)
                                    (* Empty inner context, so no need to pull and annotate for exclusion *)
                                    <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA (Caux.mk_sseq_e sseq_pat (mk_annot_e cval_e ) sseq_e2)) |>
                                | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 ->
                                    let ctxB' = add_exclusion n ctxB in
                                    let expr' =
                                      Caux.mk_sseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                        ; sseq_pat ])
                                                     (Caux.mk_unseq_e [ mk_annot_e (Caux.mk_value_e Vunit)
                                                                      ; apply_ctx ctxB' cval_e ])
                                                     sseq_e2 in
                                    <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA expr') |>
                              end
                            )
                        end
                    | _ ->
                        error "TODO(use the error the monad) illtyped SeqRMW"
                  end
                end
              
          | Eaction (Paction p act) ->
              let Action loc _ _ = act in (* DEBUG *)
              match p with
                | Pos ->
                    process_action Nothing(*not excluded*) (fun z -> Eaction (Paction p z)) act
                | Neg ->
                    match break_at_bound_and_sseq ctx with
                      | NO_BOUND ->
                          error "TODO: NO_BOUND (Neg)"
                      | BOUND_NO_SSEQ ctx_bound ctxA ->
                          let debug_str = "Neg Action, no break ==> " ^ Loc.stringFromLocation loc in
                          Step_with_runstate2 (RSK_tau debug_str Core_run.TSK_Misc) begin
                            E.fresh_excluded_id >>= fun n ->
                            let ctxA' = add_exclusion n ctxA in
                            let sym = Symbol.fresh () in
                            let expr' =
                              Caux.mk_wseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                ; Caux.mk_sym_pat sym BTy_unit(*TODO:HACKHACK*) ])
                                             (Caux.mk_unseq_e [ Expr [] (Eexcluded n act)
                                                              ; apply_ctx ctxA' (Caux.mk_pure_e Caux.mk_unit_pe) ])
                                             (Caux.mk_pure_e (Caux.mk_sym_pe sym)) in
                            E.return <| th_st with arena= apply_ctx ctx_bound expr' |>
                          end
                      | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 ->
                          (* TODO: check *)
                          (* Empty inner context, so no need to pull and annotate for exclusion *)
                          Step_tau2 "Neg Action, CTX" Core_run.TSK_Misc begin
                            <| th_st with arena= apply_ctx ctx_bound
                                                   (apply_ctx ctxA (Caux.mk_sseq_e sseq_pat (Expr [] (Eaction (Paction Pos act))) sseq_e2)) |>
                          end
                          
                      | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 ->
                          let debug_str = "Neg Action, with break" ^ Loc.stringFromLocation loc in
                          Step_with_runstate2 (RSK_tau debug_str Core_run.TSK_Misc) begin
                            E.fresh_excluded_id >>= fun n ->
                            let ctxB' = add_exclusion n ctxB in
                            let expr' =
                              Caux.mk_sseq_e (Caux.mk_tuple_pat [ Caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                                                ; sseq_pat ])
                                             (Caux.mk_unseq_e [ Expr [] (Eexcluded n act)
                                                              ; apply_ctx ctxB' (Caux.mk_pure_e Caux.mk_unit_pe) ])
                                             sseq_e2 in
                            E.return <| th_st with arena= apply_ctx ctx_bound (apply_ctx ctxA expr') |>
                          end
                    end
              end
          | Eexcluded n act ->
              process_action (Just n)(*is excluded*) (fun z -> Eexcluded n z) act
          
          | Easeq sym_bTy act1 act2 ->
              match step_action eval_pexpr Nothing(*not excluded*) act1 with
                | ACTION_EVAL debug_str eval_m ->
                    Step_with_runstate2 (RSK_eval debug_str) begin
                      eval_m >>= fun act1' ->
                      E.return (wrap_expr (Expr e_annots (Easeq sym_bTy act1' act2)))
                     end
                | ACTION_ILLTYPED str ->
                    Step_error2 str
                | ACTION_REQUEST debug_str loc _request ->
                    error "Easeq"
(*
                    match step_action eval_pexpr Nothing act2 with
                      | ACTION_EVAL debug_str eval_m ->
                          Step_with_runstate2 (RSK_eval debug_str) begin
                            eval_m >>= fun act2' ->
                            E.return (wrap_expr (Expr e_annots (Easeq sym_bTy act1 act2')))
                          end
                      | ACTION_ILLTYPED str ->
                          Step_error2 str
                      | ACTION_REQUEST _ _ _ ->
                          (* TODO: this is a horrible hack: in the previous call we pretended this  *)
                    end
*)

(*
          match step_action eval_pexpr is_excluded z with
            | ACTION_REQUEST debug_str loc _request ->
                Step_action_request2 debug_str loc current_tid
                  match _request with
                    | CreateRequest2 pref ival ty mval_opt mk_expr' ->
                        CreateRequest2 pref ival ty mval_opt (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | AllocRequest2 pref ival1 ival2 mk_expr' ->
                        AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | LoadRequest2 mo ty ptrval sym mk_expr' ->
                        LoadRequest2 mo ty ptrval sym (fun aid fp mval ->
                          wrap_expr (mk_expr' aid fp mval)
                        )
                    | StoreRequest2 mk ty is_locking ptrval mval mk_expr' ->
                        StoreRequest2 mk ty is_locking ptrval mval (fun aid fp ->
                          wrap_expr (mk_expr' aid fp)
                        )
                    | KillRequest2 is_dynamic ptrval mk_expr' ->
                        KillRequest2 is_dynamic ptrval (fun aid ->
                          wrap_expr (mk_expr' aid)
                        )
                  end
            | ACTION_ILLTYPED str ->
                Step_error2 str
*)



              end




          
          | Eccall call_annots ty pe pes ->
              Step_with_runstate2 (RSK_eval "Eccall") begin
                full_eval_pexpr' pe >>= function
                  | Vloaded (LVspecified (OVpointer pv)) ->
                      E.mapM full_eval_pexpr' pes >>= fun cvals ->
                      let case_funptrval psym =
                        let _mem_values =
                          match Map.lookup psym file.funinfo with
                            | Just (_, _, _, param_tys, _, _) ->
                                List.map (fun (ty, cval) ->
                                  match Core_aux.memValueFromValue (Ctype.Ctype [] (Ctype.Pointer Ctype.no_qualifiers ty)) cval with
                                    | Just mval -> mval
                                    | Nothing -> error "Eccall memvalue"
                                  end) $ List.zip (List.map snd param_tys) cvals
                            | Nothing ->
                                error $ "Eccall : function " ^ show psym ^ " not found"
                          end in
                        SEU.runEU (
                          Exception.bind (Core_run.call_proc core_extern file psym cvals)
                            EU.return
                        ) >>= fun (proc_env, expr) ->
                        E.return <| th_st with
                          arena= expr;
                          stack= Stack_cons2 th_st.current_proc_opt ctx th_st.stack;
                          exec_loc= push_exec_loc psym th_st.exec_loc;
                          env= proc_env :: th_st.env;
                          current_proc_opt= Just psym;
                        |>
                      in
                      Mem.case_ptrval pv
                        (fun _ -> error "null function pointer")
                        case_funptrval
                      (fun _ addr ->
                        (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
                        match Mem.case_funsym_opt mem_st pv with
                          | Just sym ->
                              case_funptrval sym
                          | None ->
                              error (show addr ^ " does not point to a function (Eccall)")
                        end)
                      (fun _ -> error "function pointer has an unspecified value")
                  | _ ->
                      error "TODO(use core_runM) Eccall illtyped first operand"
                end
              end
          | Eproc _ (Sym psym) pes ->
              Step_with_runstate2 (RSK_eval "Eccall") begin
                E.mapM full_eval_pexpr' pes >>= fun cvals ->
                 SEU.runEU (
                   Exception.bind (Core_run.call_proc core_extern file psym cvals)
                    EU.return
                 ) >>= fun (proc_env, expr) ->
                 E.return <| th_st with
                   arena= expr;
                   stack= Stack_cons2 th_st.current_proc_opt ctx th_st.stack;
                   exec_loc= push_exec_loc psym th_st.exec_loc;
                   env= proc_env :: th_st.env;
                   current_proc_opt= Just psym;
                 |>
               end
          | Eproc _ (Impl iCst) pes ->
              if true (* iCst is an FS function *) then
                Step_fs2 th_st begin
                  E.mapM full_eval_pexpr' pes >>= fun cvals ->
                  E.return (step_fs_proc th_st iCst cvals)
                end
              else
                error "TODO: Eproc Impl not FS"

          | Erun run_annots sym pes ->
              let Just current_proc = th_st.current_proc_opt in
              Step_with_runstate2 (RSK_eval "Erun") begin
                SEU.read (fun st ->
                  let proc_sym = match Map.lookup current_proc core_extern with
                    | Just proc_sym -> proc_sym
                    | Nothing -> current_proc
                  end in
                  Maybe.bind (Map.lookup proc_sym st.labeled) (Map.lookup sym)
                ) >>= function
                  | Nothing ->
                      error ("Erun couldn't resolve label: `" ^ show sym ^
                             "' for procedure `" ^ show current_proc ^ "'")
                  | Just (syms, cont_expr) ->
                      (* E.mapM (fun (sym, pe) ->
                        full_eval_pexpr pe >>= fun cval ->
                        E.return (sym, (bTy, pe'))
                      ) sym_bTy_pes >>= fun sym_bTy_pes' ->
                      E.foldlM (fun acc x ->
                        full_eval_pexpr pe >>= fun cval ->
                      ) cont_expr (List.zip syms pes) >>= fun cont_expr' -> *)
                      (* TODO: 11 march 2022 *)
                      let cont_expr' = List.foldl (fun acc (sym, pe) ->
                        unsafe_subst_sym_expr sym pe acc
                      ) cont_expr (List.zip syms pes) in
                      E.return <| th_st with arena= cont_expr'; |>
                end
              end
          | Epar es ->
              (* This step places waiting constructs in the arena and asks the
                 driver to spawn new threads *)
              Step_spawn_threads2
                (fun tids -> wrap_expr (Caux.mk_unseq_e (List.map Caux.mk_wait_e tids)))
                begin
                  List.map (fun e -> <|
                    arena= e;
                    stack= Stack_empty;
                    errno= Mem.null_ptrval Ctype.signed_int; (* TODO: allocate errno (do not store 0) *)
                    current_loc= th_st.current_loc;
                    exec_loc= ELoc_normal [];
                    env= th_st.env;
                    current_proc_opt= Nothing;
                  |>) es
                end
          | Ewait _ ->
              Step_blocked2
          | _ ->
              match one_step eval_pexpr full_eval_pexpr' th_st.env expr with
                | Nothing ->
                    error ("STUCK ==> " ^ Pp.stringFromCore_expr expr)
                | Just (TAU_WITH_RUNSTATE debug_str step_m) ->
                    Step_with_runstate2 (RSK_tau debug_str Core_run.TSK_Misc) begin
                      step_m >>= fun (env', expr') ->
                      E.return <| th_st with arena= apply_ctx ctx expr'; env= env' |>
                    end
                | Just (TAU debug_str env' expr') ->
                    Step_tau2 debug_str Core_run.TSK_Misc
                      <| th_st with arena= apply_ctx ctx expr'; env= env' |>
                | Just (EVAL debug_str eval_m) ->
                    Step_with_runstate2 (RSK_eval debug_str) begin
                      eval_m >>= fun expr' ->
                      E.return (wrap_expr expr')
                    end
                | Just (ND es) ->
                    Step_nd2 (List.map wrap_expr es) 
                | Just (MEMOP memop cvals) ->
                    Step_memop_request2 memop cvals current_tid (fun cval ->
                      wrap_expr (Caux.mk_pure_e (Caux.mk_value_pe cval))
                    )
                | Just UNSEQUENCED_RACE ->
                    (* TODO: loc *)
                    Step_with_runstate2 (RSK_eval "unsequenced race") begin
                      E.undef th_st.current_loc [Undefined.UB035_unsequenced_race]
                    end
                | Just (ILLTYPED str) ->
                    Step_error2 str
              end
        end
  end) (get_ctx th_st.arena)
