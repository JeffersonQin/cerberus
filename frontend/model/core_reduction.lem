open import Pervasives
open import Utils
open import Core Core_aux Core_run_aux

import State
import Core_eval Cmm_aux Cmm_csem

(* TODO *)
import Core_run

module Cmm = struct
  include Cmm_aux
  include Cmm_csem
end

module Caux = Core_aux


let combine_dyn_annotation xs1 xs2 =
  xs1 ++ xs2

(* TODO: use to_pure? *)
val     get_pure: expr core_run_annotation -> maybe (list Annot.annot * pexpr)
let rec get_pure (Expr annots expr_) =
  match expr_ with
    | Epure pe ->
        Just (annots, pe)
    | Eannot _ (Expr _ (Epure pe)) ->
        Just (annots, pe)
    | _ ->
        Nothing
  end

val is_pure: Core.expr core_run_annotation -> bool
let is_pure expr =
  match get_pure expr with
    | Nothing ->
        false
    | Just _ ->
        true
  end

type one_step =
  | TAU of string * list (map Symbol.sym value) * Core.expr core_run_annotation
  | EVAL of string * core_runM (Core.expr core_run_annotation)
  | UNSEQUENCED_RACE
  | ILLTYPED of string




module EU  = Exception_undefined
module SEU = State_exception_undefined

(* TODO: duplicate from Core_run *)
module E = struct
  let core_run_return =
    SEU.return
  let inline return = core_run_return
  let step_eval_pexprs th_st core_extern mem_st file pes =
    let () = Debug.print_debug 5 [] (fun () ->
      "CALLING Core_run.step_eval_pexprs (Core_eval.step_eval_pexpr, hasConstrained= false)"
    ) in
    SEU.runEU (EU.mapM (Core_eval.step_eval_pexpr 0 th_st.current_loc core_extern th_st.env (Just mem_st) file false) pes)

  let core_run_step_eval_pexpr th_st core_extern mem_st file pe =
    let () = Debug.print_debug 5 [] (fun () ->
      "CALLING Core_run.step_eval_pexpr (Core_eval.step_eval_pexpr, hasConstrained= false)"
    ) in
    SEU.runEU (Core_eval.step_eval_pexpr 0 th_st.current_loc core_extern th_st.env (Just mem_st) file false pe)
  let inline step_eval_pexpr = core_run_step_eval_pexpr
  
  let core_run_eval_pexpr th_st core_extern mem_st file pe =
    let () = Debug.print_debug 5 [] (fun () ->
      "CALLING Core_run.eval_pexpr (Core_eval.eval_pexpr_aux_broken)"
    ) in
    SEU.runEU (Core_eval.eval_pexpr_aux_broken th_st.current_loc core_extern th_st.env (Just mem_st) file pe)
  let inline eval_pexpr = core_run_eval_pexpr
  
  let eval_pexpr2 th_st core_extern mem_st file pe =
    let () = Debug.print_debug 5 [] (fun () -> "CALLING Core_run.eval_pexpr2" ) in
    SEU.runEU (Core_eval.eval_pexpr_aux2 th_st.current_loc core_extern th_st.env (Just mem_st) file pe)
  
  let wrapped_eval_pexpr2 th_st core_extern mem_st file pe =
    let () = Debug.print_debug 5 [] (fun () -> "CALLING Core_run.wrapped_eval_pexpr2" ) in
    (* TODO: it would be better to just call eval_pexpr2, but
       Lem generates buggy OCaml ... *)
    SEU.bind (SEU.runEU (Core_eval.eval_pexpr_aux2 th_st.current_loc core_extern th_st.env (Just mem_st) file pe)) function
      | Left pe' ->
          SEU.return pe'
      | Right cval ->
          SEU.return (Core_aux.mk_value_pe cval)
    end
  
  let fresh_action_id =
    SEU.runS Core_run.fresh_action_id'
end

let inline (>>=) = SEU.bind
let inline (<$>) = SEU.fmap

(* ********************************************************************************************** *)

import Debug

let rec one_step_unseq_aux (fps_acc, cvals_acc) = function
  | [] ->
      Just (fps_acc, List.reverse cvals_acc)
  | Expr _ (Epure (Pexpr _ _ (PEval cval))) :: xs ->
      one_step_unseq_aux (fps_acc, cval::cvals_acc) xs
  | Expr _ (Eannot fps (Expr _ (Epure (Pexpr _ _ (PEval cval))))) :: xs ->
      let () = Debug.print_debug 0 [] (fun () ->
        "CHECKING FOR RACE"
      ) in
      if List.any (fun z -> List.any (fun z' -> Mem.do_overlap z z') fps_acc) fps then
        (* found an unsequenced race *)
        Nothing
      else
        one_step_unseq_aux (fps ++ fps_acc, cval :: cvals_acc) xs
  | e :: _ ->
      (* all the operand of the unseq() must have already been reduced to values *)
      error ("Core_run.one_step_unseq_aux ==> " ^ Pp.stringFromCore_expr e)
  end

(* NOTE: for performance, we use scoped environment instead of substitutions for bound variables *)
val one_step:
  (Core.pexpr -> core_runM Core.pexpr) ->
  list (map Symbol.sym value) -> Core.expr core_run_annotation -> maybe one_step
let one_step eval_pexpr env (Expr annots expr_) =
  match expr_ with
    (* {A_1} {A_2} E --> {A_1 union A_2} E *)
    | Eannot xs1 (Expr annots2 (Eannot xs2 e)) ->
        Just (TAU "Eannot" env (Expr (annots ++ annots2) (Eannot (combine_dyn_annotation xs1 xs2) e)))
    
    | Ecase pe xs ->
        error "WIP: one_step Ecase"
    | Elet pat pe1 e2 ->
        match valueFromPexpr pe1 with
          | Just cval ->
              Just (TAU "Elet" (update_env pat cval env) e2)
          | Nothing ->
              Just begin
                EVAL "Elet" begin
                  eval_pexpr pe1 >>= fun pe1' ->
                  let () = Debug.print_debug 4 [] (fun () ->
                    "Elet ==> " ^ Pp.stringFromCore_pexpr pe1 ^
                    " --> " ^ Pp.stringFromCore_pexpr pe1'
                  ) in
                  E.return (Expr annots (Elet pat pe1' e2))
                end
              end
        end
    
    | Eif pe1 e2 e3 ->
        Just match valueFromPexpr pe1 with
          | Just Vtrue ->
              TAU "Eif (true)" env e2
          | Just Vfalse ->
              TAU "Eif (false)" env e3
          | Just _ ->
              ILLTYPED "the first operand of an Eif didn't evaluated to a boolean"
          | Nothing ->
              EVAL "Eif" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (Expr annots (Eif pe1' e2 e3))
              end
        end
    
    | Eunseq es ->
        match one_step_unseq_aux ([], []) es with
          | Nothing ->
              Just UNSEQUENCED_RACE
          | Just (fps, cvals) ->
              Just (TAU "Eunseq" env (Expr annots (Eannot fps (Expr [] (Epure (Pexpr [] () (PEval (Vtuple cvals))))))))
        end
    
    | Ewseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              TAU "Ewseq" (update_env pat cval env) e2
          | Nothing ->
              let mk_wseq z =
                Expr annots (Ewseq pat (Expr pe1_annots (Epure z)) e2) in
              EVAL "Ewseq" (mk_wseq <$> eval_pexpr pe1)
        end
    | Esseq pat (Expr pe1_annots (Epure pe1)) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              TAU "Esseq" (update_env pat cval env) e2
          | Nothing ->
              let mk_sseq z =
                Expr annots (Esseq pat (Expr pe1_annots (Epure z)) e2) in
              EVAL "Esseq" (mk_sseq <$> eval_pexpr pe1)
        end
    
    | Ewseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              TAU "Ewseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              let mk_wseq z =
                Expr annots (Ewseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure z)))) e2) in
              EVAL "Ewseq Eannot" (mk_wseq <$> eval_pexpr pe1)
        end
    | Esseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure pe1)))) e2 ->
        Just match valueFromPexpr pe1 with
          | Just cval ->
              TAU "Esseq Eannot" (update_env pat cval env) (Expr [] (Eannot xs e2))
          | Nothing ->
              let mk_sseq z =
                Expr annots (Esseq pat (Expr annots1 (Eannot xs (Expr annots2 (Epure z)))) e2) in
              EVAL "Esseq Eannot" (mk_sseq <$> eval_pexpr pe1)
        end
    
    | _ ->
        Nothing
  end


type context (* core_run_annotation unit Symbol.sym *) =
  | CTX
  | Cunseq of list Annot.annot * list (Core.expr core_run_annotation) * context * list (Core.expr core_run_annotation)
  | Cwseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Csseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Cannot of list Annot.annot * Core.dyn_annotation * context
  | Cbound of list Annot.annot * context


let is_value = function
  | Expr _ (Epure (Pexpr _ _ (PEval _))) ->
      true
  | Expr _ (Eannot _ (Expr _ (Epure (Pexpr _ _ (PEval _))))) ->
      true
  | _ ->
      false
end

val     get_ctx: Core.expr core_run_annotation -> list (context * Core.expr core_run_annotation)
let rec get_ctx (Expr annot expr_ as expr) =
  match expr_ with
    | Epure _ ->
        [(CTX, expr)]
    | Ememop  _ _ ->
        [(CTX, expr)]
    | Eaction _ ->
        [(CTX, expr)]
    | Ecase _ _ ->
        [(CTX, expr)]
    | Elet _ _ _ ->
        [(CTX, expr)]
    | Eif _ _ _ ->
        [(CTX, expr)]
    | Eccall _ _ _ _ ->
        [(CTX, expr)]
    | Eproc _ _ _ ->
        [(CTX, expr)]
    | Eunseq es ->
        if List.all is_value es then
          [(CTX, expr)]
        else
          get_ctx_unseq_aux annot [] [] es
    | Ewseq pat e1 e2 ->
        if is_value e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Cwseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Esseq pat e1 e2 ->
        if is_value e1 then
          [(CTX, expr)]
        else
          List.map (fun (ctx, e) ->
            (Csseq annot pat ctx e2, e)
          ) (get_ctx e1)
    | Easeq _ _ _ ->
        error "WIP: [get_ctx] REMOVE Easeq"
    | Ebound _ e ->
        List.map (fun (ctx, e) ->
          (Cbound annot ctx, e)
        ) (get_ctx e)
    | End _ ->
        [(CTX, expr)]
    | Esave _ _ _ ->
        [(CTX, expr)]
    | Erun _ _ _ ->
        [(CTX, expr)]
    | Epar _ ->
        [(CTX, expr)]
    | Ewait _ ->
        [(CTX, expr)]
    | Eannot xs e ->
        List.map (fun (ctx, e) ->
          (Cannot annot xs ctx, e)
        ) (get_ctx e)
  end

and get_ctx_unseq_aux annot acc es1 = function
  | [] ->
      acc
  | e :: es2 ->
      if is_value e then
        get_ctx_unseq_aux annot acc (es1 ++ [e]) es2
      else
        let zs =
          List.map (fun (ctx, e) ->
            (Cunseq annot es1 ctx es2, e)
          ) (get_ctx e) in
        get_ctx_unseq_aux annot (zs ++ acc) (es1 ++ [e]) es2
(*
  | Eannot xs (Expr annot' (Epure pe)) :: es2 ->
      get_ctx_unseq_aux annot acc (es1 ++ [Eannot xs (Expr annot' (Epure pe))]) es2
  | (Expr annot' (Epure pe)) :: es2 ->
      get_ctx_unseq_aux annot acc (es1 ++ [Expr annot' (Epure pe)]) es2
  | e :: es2 ->
      let zs =
        List.map (fun (ctx, e) ->
          (Cunseq annot es1 ctx es2, e)
        ) (get_ctx e) in
      get_ctx_unseq_aux annot (zs ++ acc) (es1 ++ [e]) es2
*)
end


val     apply_ctx: context -> Core.expr core_run_annotation -> Core.expr core_run_annotation
let rec apply_ctx ctx expr =
  match ctx with
    | CTX ->
        expr
    | Cunseq annot es1 ctx' es2 ->
        Expr annot (Eunseq (es1 ++ (apply_ctx ctx' expr :: es2)))
    | Cwseq annot pat ctx' e2 ->
        Expr annot (Ewseq pat (apply_ctx ctx' expr) e2)
    | Csseq annot pat ctx' e2 ->
        Expr annot (Esseq pat (apply_ctx ctx' expr) e2)
    | Cannot annot xs ctx' ->
        Expr annot (Eannot xs (apply_ctx ctx' expr))
    | Cbound annot ctx' ->
        Expr annot (Ebound 0(*TODO*) (apply_ctx ctx' expr))
  end


type action_request2 'a =
  (* RequestName  of location * sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest2 of Symbol.prefix * Mem.integer_value * Mem.integer_value *
                    (Cmm.aid -> Mem.pointer_value -> 'a)
  
  | CreateRequest2 of Symbol.prefix * Mem.integer_value * Ctype.ctype * maybe Mem.mem_value *
                     (Cmm.aid -> Mem.pointer_value -> 'a)
  
  | StoreRequest2 of Cmm.memory_order * Ctype.ctype * (* is_locking *)bool * Mem.pointer_value * Mem.mem_value *
                     (Cmm.aid -> 'a)
  
  | LoadRequest2 of (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                    Cmm.memory_order * Ctype.ctype * Mem.pointer_value * Symbol.sym *
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *)
                   (Cmm.aid -> Mem.mem_value -> 'a)
  
  (* TODO: RMW, Fence *)
  | KillRequest2 of (* is_dynamic *)bool * Mem.pointer_value * (Cmm.aid -> 'a)




type core_step2 =
  | Step_eval2 of string * core_runM thread_state
  | Step_tau2 of string * Core_run.core_tau_step_kind * thread_state
  | Step_action_request2 of string * Loc.t * (* set Cmm.aid * set Cmm.aid * set Cmm.aid * *)
                            Mem_common.thread_id *
                            action_request2 thread_state
  | Step_blocked2
  | Step_error2 of string
  | Step_thread_done2 of Mem_common.thread_id * Core.value
  | Step_done2 of Core.value



(*
  | Step_memop_request of Mem_common.memop * list Core.value * Mem_common.thread_id * (Core.value -> thread_state)
  | Step_constrained of string * list (Mem.mem_iv_constraint * core_runM thread_state)

  | Step_spawn_threads of (Core.expr core_run_annotation -> thread_state) * list thread_state (* initial states for the children *)
  
  | Step_fs of thread_state * fs_oper
  
  | Step_bound of core_runM thread_state
*)


let act_valueFromPexpr = function
  | Pexpr _ _ (PEconstrained _) ->
      error "Core_reduction.step_action => PEconstrained"
  | z ->
      valueFromPexpr z
end

type action_step =
  | ACTION_REQUEST of string * Loc.t * action_request2 (Core.expr core_run_annotation)
  | ACTION_EVAL of string * core_runM (Core.action core_run_annotation)
  | ACTION_ILLTYPED of string

val step_action: (Core.pexpr -> core_runM Core.pexpr) -> Core.action core_run_annotation -> action_step
let step_action eval_pexpr (Action loc act_annots act) =
  let wrap z =
    Action loc act_annots z in
  match act with
    | Create pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty)) ->
              ACTION_REQUEST
                "CreateRequest"
                loc
                begin
                  CreateRequest2 pref ival ty Nothing (fun aid ptrval ->
                    Expr [] (Epure (Pexpr [] () (PEval (Vobject (OVpointer ptrval)))))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Create"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Create" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Create pe1' pe2 pref))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Create" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Create pe1 pe2' pref))
              end
        end
    | CreateReadOnly pe1 pe2 pe3 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vobject (OVinteger ival)), Just (Vctype ty), Just cval3) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval3 with
                | Just mval ->
                    ACTION_REQUEST
                      "CreateRequest"
                      loc
                      begin
                        CreateRequest2 pref ival ty (Just mval) (fun aid ptrval ->
                          Expr [] (Epure (Pexpr [] () (PEval (Vobject (OVpointer ptrval)))))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a create_readonly(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval3
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "CreateReadOnly"
          | (Nothing, _, _) ->
              ACTION_EVAL "first operand of CreateReadOnly" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (CreateReadOnly pe1' pe2 pe3 pref))
              end
          | (_, Nothing, _) ->
              ACTION_EVAL "second operand of CreateReadOnly" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (CreateReadOnly pe1 pe2' pe3 pref))
              end
          | (_, _, Nothing) ->
              ACTION_EVAL "third operand of CreateReadOnly" begin
                eval_pexpr pe3 >>= fun pe3' ->
                E.return (wrap (CreateReadOnly pe1 pe2 pe3' pref))
              end
        end
    | Store is_locking pe1 pe2 (Pexpr _ () (PEconstrained xs3)) mo ->
        error "WIP: Core_reduction.step_action => Store pe1 pe2 PEconstrained"
    | Store is_locking pe1 pe2 pe3 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr pe3) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)), Just cval) ->
              match memValueFromValue (Ctype.Ctype [] (Ctype.unatomic_ ty)) cval with
                | Just mval ->
                    ACTION_REQUEST
                      "StoreRequest"
                      loc
                      begin
                        StoreRequest2 mo ty is_locking ptrval mval (fun aid ->
                          Expr [] (Epure (Pexpr [] () (PEval Vunit)))
                        )
                      end
                | Nothing ->
                    ACTION_ILLTYPED begin
                      (Loc.stringFromLocation loc) ^ "the value of a store(" ^
                      Pp.stringFromCore_ctype (Ctype.Ctype [] (Ctype.unatomic_ ty)) ^
                      ") didn't match the lvalue type: " ^ Pp.stringFromCore_value cval
                    end
              end
          | (Just _, Just _, Just _) ->
              ACTION_ILLTYPED "Store"
          | (Nothing, _, _) ->
              ACTION_EVAL "first operand of Store" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Store is_locking pe1' pe2 pe3 mo))
              end
          | (_, Nothing, _) ->
              ACTION_EVAL "second operand of Store" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Store is_locking pe1 pe2' pe3 mo))
              end
          | (_, _, Nothing) ->
              ACTION_EVAL "third operand of Store" begin
                eval_pexpr pe3 >>= fun pe3' ->
                E.return (wrap (Store is_locking pe1 pe2 pe3' mo))
              end
        end
    | Load pe1 pe2 mo ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vobject (OVpointer ptrval)))  ->
              ACTION_REQUEST
                "LoadRequest"
                loc
                begin
                  let val_sym = Symbol.fresh () in
                  LoadRequest2 mo ty ptrval val_sym (fun aid mval ->
                    let (oTy, cval) = valueFromMemValue mval in
                    Expr [] (Epure (Pexpr [] () (PEval cval)))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Load"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Load" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Load pe1' pe2 mo))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Load" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Load pe1 pe2' mo))
              end
        end
    | Alloc pe1 pe2 pref ->
        match (act_valueFromPexpr pe1, act_valueFromPexpr pe2) with
          | (Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
              ACTION_REQUEST
                "AllocRequest"
                loc
                begin
                  AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                    Expr [] (Epure (Pexpr [] () (PEval (Vobject (OVpointer ptrval)))))
                  )
                end
          | (Just _, Just _) ->
              ACTION_ILLTYPED "Alloc"
          | (Nothing, _) ->
              ACTION_EVAL "first operand of Alloc" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (wrap (Alloc pe1' pe2 pref))
              end
          | (_, Nothing) ->
              ACTION_EVAL "second operand of Alloc" begin
                eval_pexpr pe2 >>= fun pe2' ->
                E.return (wrap (Alloc pe1 pe2' pref))
              end
        end
    | Kill is_dynamic pe ->
        match act_valueFromPexpr pe with
          | Just (Vobject (OVpointer ptrval)) ->
              ACTION_REQUEST
                "KillRequest"
                loc
                begin
                  KillRequest2 is_dynamic ptrval(fun aid ->
                    Expr [] (Epure (Pexpr [] () (PEval Vunit)))
                  )
                end
          | Just _ ->
              ACTION_ILLTYPED "Kil"
          | Nothing ->
              ACTION_EVAL "operand of Kill" begin
                eval_pexpr pe >>= fun pe' ->
                E.return (wrap (Kill is_dynamic pe'))
              end
        end
end


val step_ctx:
  Mem.mem_state -> Core.file core_run_annotation -> map Symbol.sym Symbol.sym ->
  Mem_common.thread_id -> (maybe Mem_common.thread_id * thread_state) ->
  list core_step2
let step_ctx mem_st file core_extern current_tid (parent_tid_opt, th_st) =
  let eval_pexpr pe =
    E.eval_pexpr2 th_st core_extern mem_st file pe >>= function
      | Left pe' ->
          E.return pe'
      | Right cval ->
          E.return (Caux.mk_value_pe cval)
    end in
  List.map (fun (ctx, expr) ->
    match get_pure expr with
      | Just (e_annots, Pexpr _ _ (PEval cval)) ->
(*
          match ctx with
            | CTX ->
*)
                match th_st.stack with
                  | Stack_empty ->
                      (*error "impossible ==> step_ctx ctx = CTX and stack = Stack_empty"*)
                      (* TODO: this indirection is silly... *)
                      Step_done2 cval
                  | Stack_cons _ [] Stack_empty ->
                      (* reached the end of the execution of a thread. *)
                      match parent_tid_opt with
                        | Just parent_tid ->
                            let () = Debug.print_debug 0 [] (fun () ->
                              "TODO: end of normal thread"
                            ) in
                            Step_thread_done2 parent_tid cval
                        | Nothing ->
                            let () = Debug.print_debug 0 [] (fun () ->
                              "TODO: end of startup thread"
                            ) in
                            (* this was the startup thread *)
                            Step_done2 cval
                      end
                  | Stack_cons current_proc_opt [] (Stack_cons parent_proc_opt cont sk') ->
                      let () = Debug.print_debug 0 [] (fun () ->
                        "TODO: end of procedure"
                      ) in
                      (* reached the end of the execution of a procedure. *)
                      let tsk =
                        match current_proc_opt with
                          | Just psym ->
                              match Map.lookup psym file.funinfo with
                                | Just (ret_ty, _, _, _) ->
                                    Core_run.TSK_Return psym $ Core_aux.memValueFromValue ret_ty cval
                                | Nothing ->
                                    Core_run.TSK_Misc
                              end
                          | Nothing ->
                              Core_run.TSK_Misc
                        end in
                      Step_tau2 "end of procedure" tsk begin
                        match th_st.env with
                          | [] ->
                              error "end of proc, found an empty Core_run env"
                          | _ :: env' ->
                              <| th_st with
                                arena= apply_continuation cont (Expr e_annots (Epure (Caux.mk_value_pe cval)));
                                stack= Stack_cons parent_proc_opt [] sk';
                                env= env' |>
                        end
                      end
                  | _ ->
                      Step_tau2 "value in CTX" Core_run.TSK_Misc begin
                        <| th_st with arena= apply_ctx ctx (Expr e_annots (Epure (Caux.mk_value_pe cval))) |>
                      end
                end
(*
            | _ ->
                error ("Core_run.step_ctx ==> found a value with ctx <> CTX ==> " ^ Pp.stringFromCore_expr expr)
          end
*)
      | Just (e_annots, pe) ->
          Step_eval2 "Epure" begin
            eval_pexpr pe >>= fun pe' ->
            E.return <| th_st with arena= apply_ctx ctx (Expr e_annots (Epure pe')) |>
          end
      | Nothing ->
          let Expr e_annots expr_ = expr in
          let wrap_expr z = <| th_st with arena= apply_ctx ctx z |> in
          match expr_ with
            | Eaction (Paction p act) ->
                match p with
                  | Pos ->
                      match step_action eval_pexpr act with
                        | ACTION_REQUEST debug_str loc _request ->
                            Step_action_request2 debug_str loc current_tid
                              match _request with
                                | CreateRequest2 pref ival ty mval_opt mk_expr' ->
                                    CreateRequest2 pref ival ty mval_opt (fun aid ptrval ->
                                      wrap_expr (mk_expr' aid ptrval)
                                    )
                                | AllocRequest2 pref ival1 ival2 mk_expr' ->
                                    AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                                      wrap_expr (mk_expr' aid ptrval)
                                    )
                                | LoadRequest2 mo ty ptrval sym mk_expr' ->
                                    LoadRequest2 mo ty ptrval sym (fun aid mval ->
                                      wrap_expr (mk_expr' aid mval)
                                    )
                                | StoreRequest2 mk ty is_locking ptrval mval mk_expr' ->
                                    StoreRequest2 mk ty is_locking ptrval mval (fun aid ->
                                      wrap_expr (mk_expr' aid)
                                    )
                                | KillRequest2 is_dynamic ptrval mk_expr' ->
                                    KillRequest2 is_dynamic ptrval (fun aid ->
                                      wrap_expr (mk_expr' aid)
                                    )
                            end
                        | ACTION_EVAL debug_str eval_m -> (* of string * core_runM (Core.action core_run_annotation) *)
                            Step_eval2 debug_str begin
                              eval_m >>= fun act' ->
                              E.return (wrap_expr (Expr e_annots (Eaction (Paction p act'))))
                            end
                        | ACTION_ILLTYPED str ->
                            Step_error2 str
                      end
                  | Neg ->
                      error "WIP: DELAY negative action"
                end
            | Eccall _ _ _ _ ->
                error "WIP: CCALL"
            | Eproc _ _ _ ->
                error "WIP: PROC"
(*
            | Ebound e ->
                
            | Ebound (Expr _ (Eannot _ e)) ->
                
*)
            | Erun _ _ _ ->
                error "WIP: RUN"
            | _ ->
                match one_step eval_pexpr th_st.env expr with
                  | Nothing ->
                      error ("STUCK ==> " ^ Pp.stringFromCore_expr expr)
                  | Just (TAU debug_str env' expr') ->
                      Step_tau2 debug_str Core_run.TSK_Misc <| th_st with arena= apply_ctx ctx expr'; env= env' |>
                  | Just (EVAL debug_str eval_m) ->
                      Step_eval2 debug_str begin
                        eval_m >>= fun expr' ->
                        E.return <| th_st with arena= apply_ctx ctx expr' |>
                      end
                  | Just UNSEQUENCED_RACE ->
                      error "WIP: UNSEQUENCED_RACE"
                  | Just (ILLTYPED str) ->
                      Step_error2 str
                end
          end
    end
  ) (get_ctx th_st.arena)
