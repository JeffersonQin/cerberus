open import Pervasives Loc Common Context Ctype
import Symbol Cmm_csem

(* == Ail syntax datatypes ================================================== *)
type identifier = Symbol.sym

type reg = nat

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

type basis =
  | Octal
  | Decimal
  | Hexadecimal

type integerConstant [name = "ic*"] =
  | IConstant of integer * basis * maybe integerSuffix
  | IConstantMax of integerType
  | IConstantMin of integerType

type floatingSuffix =
  | Fsuf_F
  | Fsuf_L

type floatingConstant = string * maybe floatingSuffix

type characterPrefix =
  | Pref_L
  | Pref_u
  | Pref_U

type characterConstant = maybe characterPrefix * string

type encodingPrefix =
  | Enc_u8
  | Enc_u
  | Enc_U
  | Enc_L

type stringLiteral = maybe encodingPrefix * list string

type arithmeticOperator [name = "aop.*"] =
  (* STD §6.5.5 Multiplicative operators *)
  | Mul | Div | Mod
  (* STD §6.5.6 Additive operators *)
  | Add | Sub
  (* STD §6.5.7 Bitwise shift operators *)
  | Shl | Shr
  (* STD §6.5.10 Bitwise AND operator *)
  | Band
  (* STD §6.5.11 Bitwise exclusive OR operator *)
  | Bxor
  (* STD §6.5.12 Bitwise inclusive OR operator *)
  | Bor

type constant [name = "c*"] =
  | ConstantIndeterminate of ctype
  | ConstantNull
  | ConstantInteger       of integerConstant
  | ConstantFloating      of floatingConstant
  | ConstantCharacter     of characterConstant
  | ConstantArray         of ctype * list constant
  | ConstantStruct        of identifier * list (Cabs.cabs_identifier * constant)
  | ConstantUnion         of identifier * Cabs.cabs_identifier * constant

type unaryOperator = 
  | Plus
  | Minus
  | Bnot
  | Address
  | Indirection
  | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
  | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assignments *)
  | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
  | Comma (*r 6.5.13 Logical AND operator *)
  | And (*r 6.5.14 Logical OR operator *)
  | Or (*r 6.5.8 Relational operators *)
  | Lt
  | Gt
  | Le
  | Ge (*r 6.5.9 Equality operators *)
  | Eq
  | Ne

type expression_ 'a [name = "e*"] = 
  | AilEunary of unaryOperator * expression 'a
  | AilEbinary of expression 'a * binaryOperator * expression 'a
  | AilEassign of expression 'a * expression 'a
  | AilEcompoundAssign of expression 'a * arithmeticOperator * expression 'a
  | AilEcond of expression 'a * expression 'a * expression 'a
  | AilEcast of qualifiers * ctype * expression 'a
  | AilEcall of expression 'a * list (expression 'a)
  | AilEassert of expression 'a
  | AilEoffsetof of ctype * Cabs.cabs_identifier
  | AilEgeneric of expression 'a * list (generic_association 'a)
  (* NOTE: these don't exist in C (apart from in decl)
   * the boolean says whether this array was created from a string literal
   * used to initialise a pointer to an array of character *)
  | AilEarray of bool * ctype * list (maybe (expression 'a))
  | AilEstruct of identifier * list (Cabs.cabs_identifier * maybe (expression 'a)) (* tag, pairs of member id, expression *)
  | AilEunion of identifier * Cabs.cabs_identifier * maybe (expression 'a)
  
  (* NOTE: the expression obviously need to match the type, and will typically be
           a AilEarray or AilEstruct *)
  | AilEcompound of qualifiers * ctype * expression 'a
  
  
  | AilEmemberof of expression 'a * Cabs.cabs_identifier
  | AilEmemberofptr of expression 'a * Cabs.cabs_identifier
  
  | AilEbuiltin of string (* TODO: see if that can be moved to [constant] *)
  
  | AilEstr of stringLiteral
  | AilEconst of constant
  | AilEident of identifier
  | AilEsizeof of qualifiers * ctype
  | AilEsizeof_expr of expression 'a
  | AilEalignof of qualifiers * ctype
  
  (* NOTE: type annotation on expression, used to remember the type of desugared
           enumeration constants *)
  | AilEannot of ctype * (expression 'a)
  | AilEva_start of expression 'a * identifier
  | AilEva_arg of expression 'a * ctype
  | AilEva_copy of expression 'a * expression 'a
  | AilEva_end of expression 'a
  
  | AilEprint_type of expression 'a
  | AilEbmc_assume of expression 'a
  | AilEreg_load of reg
  
    (* §6.3.2.1#2, the result of a non-array lvalue conversion *)
  | AilErvalue of expression 'a (* NOTE: never generated by the desugaring *)
    (* §6.3.2.1#3 *)
  | AilEarray_decay of expression 'a (* NOTE: never generated by the desugaring *)
    (* §6.3.2.1#4 *)
  | AilEfunction_decay of expression 'a (* NOTE: never generated by the desugaring *)

and generic_association 'a =
  | AilGAtype of ctype * expression 'a
  | AilGAdefault of expression 'a

and expression 'a [name = "e*"] =
  | AnnotatedExpression of 'a * list string * Loc.t * expression_ 'a

instance forall 'a. (Located (expression 'a))
  let locOf a_expr =
    let (AnnotatedExpression _ _ loc _) = a_expr in
    loc
end

(* STD §6.2.4#1 *)
type storageDuration [name = "^\\([a-z A-Z]*_\\)?dur[0-9]*'?$"] =
 | Static
 | Thread
 | Automatic
 | Allocated

instance (Eq storageDuration)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

(* the boolean tells whether the object was declared with the register
 * storage-class *)
type bindings =
  list (identifier * ((Loc.t * storageDuration * bool) * qualifiers * ctype))

type statement_ 'a [name="s*"] =
  | AilSskip
  | AilSexpr of expression 'a
  | AilSblock of bindings * list (statement 'a)
  | AilSif of expression 'a * statement 'a * statement 'a
  | AilSwhile of expression 'a * statement 'a
  | AilSdo of statement 'a * expression 'a
  | AilSbreak
  | AilScontinue
  | AilSreturnVoid
  | AilSreturn of expression 'a
  | AilSswitch of expression 'a * statement 'a
  | AilScase of integerConstant * statement 'a
  | AilSdefault of statement 'a
  | AilSlabel of identifier * statement 'a
  | AilSgoto of identifier
  | AilSdeclaration of list (identifier * expression 'a)
  | AilSpar of list (statement 'a) (* NON-STD cppmem threads *)
  | AilSreg_store of reg * expression 'a
and statement 'a [name="s*"] =
  | AnnotatedStatement of Loc.t * statement_ 'a

instance forall 'a. (Located (statement 'a))
  let locOf stmt =
    let (AnnotatedStatement loc _) = stmt in
    loc
end

type declaration =
  | Decl_object   of (storageDuration * bool) * qualifiers * ctype
  | Decl_function of bool (* has_prototype *)
                   * (qualifiers * ctype) (* return qualifiers *)
                   * (list (qualifiers * ctype * (* isRegister *)bool))
                   * bool (* is_variadic *)
                   * bool (* is_inline *)
                   * bool (* is_Noreturn *)


(*
TODO
type tag_definition =
  | StructDef of list (Cabs.cabs_identifier * (qualifiers * ctype))
  | UnionDef of list (Cabs.cabs_identifier * (qualifiers * ctype))

instance (Show tag_definition)
  let show def =
    let string_of_identifiers tag_defs =
      List.foldl (fun acc (Cabs.CabsIdentifier _ str, _) ->
        acc ^ str ^ "; "
      ) "[" tag_defs ^ "]"
    in
    match def with
      | StructDef tag_defs -> string_of_identifiers tag_defs
      | UnionDef tag_defs -> string_of_identifiers tag_defs
    end
end
*)

(* external identifier kind *)
type id_kind =
  | IK_declaration
  | IK_tentative
  | IK_definition

type sigma 'a = <|
  declarations: Context.context identifier (Loc.t * declaration);
  object_definitions: Context.context identifier (expression 'a);
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: Context.context identifier (Loc.t * list identifier * statement 'a);
  static_assertions: list (expression 'a * stringLiteral);
  tag_definitions: Context.context identifier tag_definition;
  extern_idmap: map Cabs.cabs_identifier (identifier * id_kind);
|>


type gamma = Context.context identifier ((Loc.t * storageDuration * bool) * qualifiers * ctype)

type ail_program 'a = maybe identifier * sigma 'a



(* == Equality functions ==================================================== *)

val identifierEqual:         identifier         -> identifier         -> bool
val integerSuffixEqual:      integerSuffix      -> integerSuffix      -> bool
val integerConstantEqual:    integerConstant    -> integerConstant    -> bool
val arithmeticOperatorEqual: arithmeticOperator -> arithmeticOperator -> bool
val constantEqual:           constant           -> constant           -> bool
val unaryOperatorEqual:      unaryOperator      -> unaryOperator      -> bool
val binaryOperatorEqual:     binaryOperator     -> binaryOperator     -> bool

(* NOTE: this is an internal function *)
val argumentsEqual_aux: forall 'a.
                      ('a -> 'a -> bool)                                             ->
                      (('a -> 'a -> bool) -> expression 'a -> expression 'a -> bool) ->
                      list (expression 'a) -> list (expression 'a)                   ->
                      bool

(* NOTE: this is an internal function *)
val expressionEqual': forall 'a.
                    ('a -> 'a -> bool)               ->
                    expression_ 'a -> expression_ 'a ->
                    bool

val expressionEqual: forall 'a.
                   ('a -> 'a -> bool)             ->
                   expression 'a -> expression 'a ->
                   bool

val argumentsEqual: forall 'a.
                  ('a -> 'a -> bool)                           ->
                  list (expression 'a) -> list (expression 'a) ->
                  bool

val bindingsEqual: bindings -> bindings -> bool

val definitionEqual: forall 'a.
                   ('a -> 'a -> bool)                                           ->
                   (identifier * expression 'a) -> (identifier * expression 'a) ->
                   bool

val declarationEqual: declaration -> declaration -> bool

val blockEqual_aux: forall 'a.
                  ('a -> 'a -> bool)                                           ->
                  (('a -> 'a -> bool) -> statement 'a -> statement 'a -> bool) ->
                  list (statement 'a) -> list (statement 'a)                   ->
                  bool

val statementEqual': forall 'a.
                   ('a -> 'a -> bool)             ->
                   statement_ 'a -> statement_ 'a ->
                   bool

val statementEqual: forall 'a.
                  ('a -> 'a -> bool)           ->
                  statement 'a -> statement 'a ->
                  bool

val blockEqual: forall 'a.
              ('a -> 'a -> bool)                         ->
              list (statement 'a) -> list (statement 'a) ->
              bool

val sigmaEqual: forall 'a.
              ('a -> 'a -> bool)   ->
              sigma 'a -> sigma 'a ->
              bool

val gammaEqual: gamma -> gamma -> bool

val programEqual: forall 'a.
                ('a -> 'a -> bool)       ->
                ail_program 'a -> ail_program 'a ->
                bool

let identifierEqual =
  (=)

let basisEqual b1 b2 =
  match (b1, b2) with
    | (Octal      , Octal      ) -> true
    | (Decimal    , Decimal    ) -> true
    | (Hexadecimal, Hexadecimal) -> true
    | (_          , _          ) -> false
  end

let integerSuffixEqual s1 s2 =
  match (s1, s2) with
    | (U  , U  ) -> true
    | (UL , UL ) -> true
    | (ULL, ULL) -> true
    | (L  , L  ) -> true
    | (LL , LL ) -> true
    | (_  , _  ) -> false
  end

let integerConstantEqual iCst1 iCst2 =
  match (iCst1, iCst2) with
    | (IConstant n1 b1 suff1_opt, IConstant n2 b2 suff2_opt) ->
        n1 = n2 && basisEqual b1 b2
        && eq_option integerSuffixEqual suff1_opt suff2_opt
    | (IConstantMax ity1, IConstantMax ity2) ->
        integerTypeEqual ity1 ity2
    | (IConstantMin ity1, IConstantMin ity2) ->
        integerTypeEqual ity1 ity2
    | _ ->
        false
end

instance (Eq integerConstant)
  let (=)  = integerConstantEqual
  let (<>) = fun ic_a ic_b -> not (integerConstantEqual ic_a ic_b)
end

let arithmeticOperatorEqual aop1 aop2 =
  match (aop1, aop2) with
    | (Mul , Mul ) -> true
    | (Div , Div ) -> true
    | (Mod , Mod ) -> true
    | (Add , Add ) -> true
    | (Sub , Sub ) -> true
    | (Shl , Shl ) -> true
    | (Shr , Shr ) -> true
    | (Band, Band) -> true
    | (Bor , Bor ) -> true
    | (Bxor, Bxor) -> true
    | (_   , _   ) -> false
  end


let characterPrefixEqual pref1 pref2 =
  match (pref1, pref2) with
    | (Pref_L, Pref_L) -> true
    | (Pref_u, Pref_u) -> true
    | (Pref_U, Pref_U) -> true
    | (_     , _     ) -> false
  end

let characterConstantEqual =
  pairEqualBy (eq_option characterPrefixEqual) (=)

let encodingPrefixEqual pref1 pref2 =
  match (pref1, pref2) with
    | (Enc_u8, Enc_u8) -> true
    | (Enc_u , Enc_u ) -> true
    | (Enc_U , Enc_U ) -> true
    | (Enc_L , Enc_L ) -> true
    | (_     , _     ) -> false
  end

let stringLiteralEqual =
  pairEqualBy (eq_option encodingPrefixEqual) (=)


let rec constantEqual c1 c2 =
  match (c1, c2) with
    | (ConstantIndeterminate ty1, ConstantIndeterminate ty2) ->
        ty1 = ty2
    | (ConstantNull, ConstantNull) ->
        true
    | (ConstantInteger ic1, ConstantInteger ic2) ->
        integerConstantEqual   ic1 ic2
    | (ConstantFloating fc1, ConstantFloating fc2) ->
        fc1 = fc2
    | (ConstantCharacter cc1, ConstantCharacter cc2) ->
        characterConstantEqual cc1 cc2
    | (ConstantArray ty1 cs1, ConstantArray ty2 cs2) ->
        ty1 = ty2 && List.listEqualBy constantEqual cs1 cs2
    | (ConstantStruct tag_sym1 xs1, ConstantStruct tag_sym2 xs2) ->
        tag_sym1 = tag_sym2
        && List.listEqualBy (pairEqualBy (=) constantEqual) xs1 xs2
    | (ConstantUnion tag_sym1 memb_ident1 cst1,
       ConstantUnion tag_sym2 memb_ident2 cst2) ->
        tag_sym1 = tag_sym2
        && memb_ident1 = memb_ident1 && constantEqual cst1 cst2
    | _ ->
        false
  end

let unaryOperatorEqual u1 u2 =
  match (u1, u2) with
    | (Plus       , Plus       ) -> true
    | (Minus      , Minus      ) -> true
    | (Bnot       , Bnot       ) -> true
    | (Address    , Address    ) -> true
    | (Indirection, Indirection) -> true
    | (PostfixIncr, PostfixIncr) -> true
    | (PostfixDecr, PostfixDecr) -> true
    | (_          , _          ) -> false
  end

let binaryOperatorEqual bop1 bop2 =
  match (bop1, bop2) with
    | (Arithmetic aop1, Arithmetic aop2) -> arithmeticOperatorEqual aop1 aop2
    | (Comma, Comma) -> true
    | (And  , And  ) -> true
    | (Or   , Or   ) -> true
    | (Lt   , Lt   ) -> true
    | (Gt   , Gt   ) -> true
    | (Le   , Le   ) -> true
    | (Ge   , Ge   ) -> true
    | (Eq   , Eq   ) -> true
    | (Ne   , Ne   ) -> true
    | (_    , _    ) -> false
  end

let rec argumentsEqual_aux eq_A expressionEqual a1 a2 =
  match (a1, a2) with
    | ([]      , []      ) -> true
    | (e1 :: a1, e2 :: a2) -> expressionEqual eq_A e1 e2 && argumentsEqual_aux eq_A expressionEqual a1 a2
    | (_       , _       ) -> false
  end

let rec expressionEqual' (eq_A : 'a -> 'a -> bool) e1 e2 =
  let argumentsEqual = argumentsEqual_aux eq_A
        (fun eq a b -> expressionEqual eq a b) in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        unaryOperatorEqual uop1 uop2 &&
        expressionEqual eq_A e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        binaryOperatorEqual bop1 bop2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        arithmeticOperatorEqual aop1 aop2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        expressionEqual eq_A e2_1 e2_2 &&
        expressionEqual eq_A e3_1 e3_2
    | (AilEcast qs1 ty1 e1, AilEcast qs2 ty2 e2) ->
        qs1 = qs2 && ty1 = ty2 &&
        expressionEqual eq_A e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        expressionEqual eq_A e1 e2 &&
        argumentsEqual es1 es2
    | (AilEassert e1, AilEassert e2) ->
        expressionEqual eq_A e1 e2
    | (AilEoffsetof ty1 ident1, AilEoffsetof ty2 ident2) ->
        ty1 = ty1 && ident1 = ident2
    | (AilEstr lit1, AilEstr lit2) ->
        stringLiteralEqual lit1 lit2
    | (AilEconst c1, AilEconst c2) ->
        constantEqual c1 c2
    | (AilEident v1, AilEident v2) ->
        identifierEqual v1 v2
    | (AilEsizeof qs1 ty1, AilEsizeof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEsizeof_expr e1, AilEsizeof_expr e2) ->
        expressionEqual eq_A e1 e2
    | (AilEalignof qs1 ty1, AilEalignof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEbmc_assume e1, AilEbmc_assume e2) ->
        expressionEqual eq_A e1 e2
    | (AilEreg_load r1, AilEreg_load r2) ->
        r1 = r2
    | (_, _) -> false (* TODO: this is wrong *)
  end
and expressionEqual eq_A e1 e2 =
  match (e1, e2) with
    | (AnnotatedExpression a1 _ _ e1, AnnotatedExpression a2 _ _ e2) ->
        eq_A a1 a2 && expressionEqual' eq_A e1 e2
  end

let argumentsEqual eq_A a1 a2 =
  argumentsEqual_aux eq_A expressionEqual a1 a2

let bindingsEqual bs1 bs2 =
  List.listEqualBy (pairEqualBy identifierEqual (eq_triple (=) qualifiersEqual ctypeEqual)) bs1 bs2

let definitionEqual eq_A d1 d2 =
  pairEqualBy identifierEqual (expressionEqual eq_A) d1 d2

let eq_declaration ds1 ds2 =
  match (ds1, ds2) with
    | (Decl_object dur1 qs1 ty1, Decl_object dur2 qs2 ty2) ->
        dur1 = dur2 && qs1 = qs2 && ty1 = ty2
    | (Decl_function has_proto1 ret_ty1 qs_tys1 is_variadic1 is_inline1 is_Noreturn1,
       Decl_function has_proto2 ret_ty2 qs_tys2 is_variadic2 is_inline2 is_Noreturn2) ->
        has_proto1 = has_proto2 &&
        ret_ty1 = ret_ty2 &&
        qs_tys1 = qs_tys2 &&
        is_variadic1 = is_variadic2 &&
        is_inline1 = is_inline2 &&
        is_Noreturn1 = is_Noreturn2
    | _ ->
        false
  end

let rec eq_block_aux eq_A equiv_statement ss1 ss2 =
  match (ss1, ss2) with
    | ([]       , []       ) -> true
    | (s1 :: ss1, s2 :: ss2) -> equiv_statement eq_A s1 s2 && eq_block_aux eq_A equiv_statement ss1 ss2
    | (_        , _        ) -> false
  end

let rec statementEqual' eq_A s1 s2 =
  let eq_block = eq_block_aux eq_A 
      (fun eq a b -> statementEqual eq a b) in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        expressionEqual eq_A e1 e2
    | (AilSblock bs1 ss1, AilSblock bs2 ss2) ->
        bs1 = bs2 &&
        eq_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1_1 s1_2 &&
        statementEqual eq_A s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        expressionEqual eq_A e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        integerConstantEqual ic1 ic2 &&
        statementEqual eq_A s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        statementEqual eq_A s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        identifierEqual v1 v2 &&
        statementEqual eq_A s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        identifierEqual v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        List.listEqualBy (pairEqualBy identifierEqual (expressionEqual eq_A)) d1 d2
    | (_, _) -> false
  end
and statementEqual eq_A s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        statementEqual' eq_A s1 s2
  end

let eq_block eq_A ss1 ss2 =
  eq_block_aux eq_A statementEqual ss1 ss2

let eq_gamma g1 g2 =
  eq_context identifierEqual (pairEqualBy qualifiersEqual ctypeEqual) g1 g2

(* == Equivalence functions ================================================= *)

val equiv_arguments_aux: forall 'a1 'a2.
                         (expression 'a1 -> expression 'a2 -> bool)     ->
                         list (expression 'a1) -> list (expression 'a2) ->
                         bool

val equiv_expression_: forall 'a1 'a2. expression_ 'a1                    -> expression_ 'a2                    -> bool
val equiv_expression:  forall 'a1 'a2. expression  'a1                    -> expression  'a2                    -> bool
val equiv_arguments:   forall 'a1 'a2. list (expression 'a1)              -> list (expression 'a2)              -> bool
val equiv_definition:  forall 'a1 'a2. identifier * expression 'a1        -> identifier * expression 'a2        -> bool
val equiv_declaration: forall 'a1 'a2. list (identifier * expression 'a1) -> list (identifier * expression 'a2) -> bool

val equiv_block_aux: forall 'a1 'a2.
                     (statement 'a1 -> statement 'a2 -> bool) ->
                     list (statement 'a1) -> list (statement 'a2) ->
                     bool

val equiv_statement_: forall 'a1 'a2. statement_ 'a1       -> statement_ 'a2       -> bool
val equiv_statement:  forall 'a1 'a2. statement  'a1       -> statement  'a2       -> bool
val equiv_block:      forall 'a1 'a2. list (statement 'a1) -> list (statement 'a2) -> bool


let rec equiv_arguments_aux equiv_expression a1 a2 =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> equiv_expression e1 e2 && equiv_arguments_aux equiv_expression a1 a2
  | (_       , _       ) -> false
    end

let rec equiv_expression_ e1 e2 =
  let equiv_arguments = equiv_arguments_aux 
      (fun a b -> equiv_expression a b) in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        unaryOperatorEqual uop1 uop2 &&
        equiv_expression e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        binaryOperatorEqual bop1 bop2 &&
        equiv_expression e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        arithmeticOperatorEqual aop1 aop2 &&
        equiv_expression e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2 &&
        equiv_expression e3_1 e3_2
    | (AilEcast qs1 ty1 e1, AilEcast qs2 ty2 e2) ->
        qs1 = qs2 && ty1 = ty2 &&
        equiv_expression e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        equiv_expression e1 e2 &&
        equiv_arguments es1 es2
    | (AilEassert e1, AilEassert e2) ->
        equiv_expression e1 e2
    | (AilEconst c1, AilEconst c2) ->
        constantEqual c1 c2
    | (AilEident v1, AilEident v2) ->
        identifierEqual v1 v2
    | (AilEsizeof qs1 ty1, AilEsizeof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEalignof qs1 ty1, AilEalignof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEbmc_assume e1, AilEbmc_assume e2) ->
        equiv_expression e1 e2
    | (AilEreg_load r1, AilEreg_load r2) ->
        r1 = r2
    | (_, _) -> false
  end
and equiv_expression e1 e2 =
  match (e1, e2) with
  | (AnnotatedExpression _ _ _ e1, AnnotatedExpression _ _ _ e2) -> equiv_expression_ e1 e2
  end

let equiv_arguments a1 a2 =
  equiv_arguments_aux equiv_expression a1 a2

let equiv_definition d1 d2 =
  equiv_pair identifierEqual equiv_expression d1 d2


let rec equiv_declaration ds1 ds2 =
  match (ds1, ds2) with
  | ([]       , []       ) -> true
  | (d1 :: ds1, d2 :: ds2) -> equiv_definition d1 d2 && equiv_declaration ds1 ds2
  | (_        , _        ) -> false
  end

let rec equiv_block_aux equiv_statement ss1 ss2 =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement s1 s2 && equiv_block_aux equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec equiv_statement_ s1 s2 =
  let equiv_block = equiv_block_aux 
      (fun a b -> equiv_statement a b) in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        equiv_expression e1 e2
    | (AilSblock bs1 ss1, AilSblock bs2 ss2) ->
        bs1 = bs2 &&
        equiv_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1_1 s1_2 &&
        equiv_statement s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        equiv_expression e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        integerConstantEqual ic1 ic2 &&
        equiv_statement s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        equiv_statement s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        identifierEqual v1 v2 &&
        equiv_statement s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        identifierEqual v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        equiv_declaration d1 d2
    | (_, _) -> false
  end
and equiv_statement s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        equiv_statement_ s1 s2
  end

let equiv_block ss1 ss2 =
 equiv_block_aux equiv_statement ss1 ss2

val sigma_fresh_bindings: forall 'a. bindings -> sigma 'a -> bool
let sigma_fresh_bindings bs S =
  List.all (fun (ident, _) -> Context.fresh_binding identifierEqual ident S.declarations) bs

val parameters_of_bindings: bindings -> list ((Loc.t * storageDuration * bool) * qualifiers * ctype)

val type_from_sigma: forall 'a. (ctype * bindings * bool) * maybe (statement 'a) -> ctype

let parameters_of_bindings bs =
  List.map snd bs

