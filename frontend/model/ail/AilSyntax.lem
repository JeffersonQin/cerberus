open import Pervasives Loc Ctype
import Symbol Annot

type ail_identifier = Symbol.sym

type reg = nat

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

type basis =
  | Octal
  | Decimal
  | Hexadecimal

type integerConstant [name = "ic*"] =
  | IConstant of integer * basis * maybe integerSuffix
  | IConstantMax of integerType
  | IConstantMin of integerType

type floatingSuffix =
  | Fsuf_F
  | Fsuf_L

type floatingConstant = string * maybe floatingSuffix

type characterPrefix =
  | Pref_L
  | Pref_u
  | Pref_U

type characterConstant = maybe characterPrefix * string

type encodingPrefix =
  | Enc_u8
  | Enc_u
  | Enc_U
  | Enc_L

type stringLiteral = maybe encodingPrefix * list string

type arithmeticOperator [name = "aop.*"] =
  (* STD §6.5.5 Multiplicative operators *)
  | Mul | Div | Mod
  (* STD §6.5.6 Additive operators *)
  | Add | Sub
  (* STD §6.5.7 Bitwise shift operators *)
  | Shl | Shr
  (* STD §6.5.10 Bitwise AND operator *)
  | Band
  (* STD §6.5.11 Bitwise exclusive OR operator *)
  | Bxor
  (* STD §6.5.12 Bitwise inclusive OR operator *)
  | Bor

type constant [name = "c*"] =
  | ConstantIndeterminate of ctype
  | ConstantNull
  | ConstantInteger       of integerConstant
  | ConstantFloating      of floatingConstant
  | ConstantCharacter     of characterConstant
  | ConstantArray         of ctype * list constant
  | ConstantStruct        of Symbol.sym * list (Symbol.identifier * constant)
  | ConstantUnion         of Symbol.sym * Symbol.identifier * constant

type unaryOperator =
  | Plus
  | Minus
  | Bnot
  | Address
  | Indirection
  | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
  | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assignments *)
  | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
  | Comma (*r 6.5.13 Logical AND operator *)
  | And (*r 6.5.14 Logical OR operator *)
  | Or (*r 6.5.8 Relational operators *)
  | Lt
  | Gt
  | Le
  | Ge (*r 6.5.9 Equality operators *)
  | Eq
  | Ne

type ail_builtin_atomic =
  | AilBAthread_fence
  | AilBAstore
  | AilBAload
  | AilBAexchange
  | AilBAcompare_exchange_strong
  | AilBAcompare_exchange_weak
  | AilBAfetch_key

type ail_builtin_linux =
  | AilBLfence
  | AilBLread
  | AilBLwrite
  | AilBLrmw

(* NOTE: add new constructors here when adding new builtins to Ail *)
type ail_builtin =
  | AilBatomic of ail_builtin_atomic
  | AilBlinux of ail_builtin_linux

type expression_ 'a [name = "e*"] = 
  | AilEunary of unaryOperator * expression 'a
  | AilEbinary of expression 'a * binaryOperator * expression 'a
  | AilEassign of expression 'a * expression 'a
  | AilEcompoundAssign of expression 'a * arithmeticOperator * expression 'a
  | AilEcond of expression 'a * expression 'a * expression 'a
  | AilEcast of qualifiers * ctype * expression 'a
  | AilEcall of expression 'a * list (expression 'a)
  | AilEassert of expression 'a
  | AilEoffsetof of ctype * Symbol.identifier
  | AilEgeneric of expression 'a * list (generic_association 'a)
  (* NOTE: these don't exist in C (apart from in decl)
   * the boolean says whether this array was created from a string literal
   * used to initialise a pointer to an array of character *)
  | AilEarray of bool * ctype * list (maybe (expression 'a))
  | AilEstruct of ail_identifier * list (Symbol.identifier * maybe (expression 'a)) (* tag, pairs of member id, expression *)
  | AilEunion of ail_identifier * Symbol.identifier * maybe (expression 'a)
  (* NOTE: the expression obviously need to match the type, and will typically
   * be a AilEarray or AilEstruct *)
  | AilEcompound of qualifiers * ctype * expression 'a
  | AilEmemberof of expression 'a * Symbol.identifier
  | AilEmemberofptr of expression 'a * Symbol.identifier
  | AilEbuiltin of ail_builtin
  | AilEstr of stringLiteral
  | AilEconst of constant
  | AilEident of ail_identifier
  | AilEsizeof of qualifiers * ctype
  | AilEsizeof_expr of expression 'a
  | AilEalignof of qualifiers * ctype
  (* NOTE: type annotation on expression, used to remember the type of desugared
   * enumeration constants *)
  | AilEannot of ctype * (expression 'a)
  | AilEva_start of expression 'a * ail_identifier
  | AilEva_arg of expression 'a * ctype
  | AilEva_copy of expression 'a * expression 'a
  | AilEva_end of expression 'a
  | AilEprint_type of expression 'a
  | AilEbmc_assume of expression 'a
  | AilEreg_load of reg
    (* §6.3.2.1#2, the result of a non-array lvalue conversion *)
  | AilErvalue of expression 'a (* NOTE: never generated by the desugaring *)
    (* §6.3.2.1#3 *)
  | AilEarray_decay of expression 'a (* NOTE: never generated by the desugaring *)
    (* §6.3.2.1#4 *)
  | AilEfunction_decay of expression 'a (* NOTE: never generated by the desugaring *)

and generic_association 'a =
  | AilGAtype of ctype * expression 'a
  | AilGAdefault of expression 'a

and expression 'a [name = "e*"] =
  | AnnotatedExpression of 'a * list string * Loc.t * expression_ 'a

instance forall 'a. (Located (expression 'a))
  let locOf a_expr =
    let (AnnotatedExpression _ _ loc _) = a_expr in
    loc
end

(* STD §6.2.4#1 *)
type storageDuration [name = "^\\([a-z A-Z]*_\\)?dur[0-9]*'?$"] =
 | Static
 | Thread
 | Automatic
 | Allocated

type ident_info = <|
  bs_loc: Loc.t;
  bs_duration: storageDuration;
  bs_isRegister: is_register;
  bs_qs: qualifiers;
  bs_ty: ctype
|>

type bindings =
  list (ail_identifier * ident_info)

type statement_ 'a [name="s*"] =
  | AilSskip
  | AilSexpr of expression 'a
  | AilSblock of bindings * list (statement 'a)
  | AilSif of expression 'a * statement 'a * statement 'a
  | AilSwhile of expression 'a * statement 'a
  | AilSdo of statement 'a * expression 'a
  | AilSbreak
  | AilScontinue
  | AilSreturnVoid
  | AilSreturn of expression 'a
  | AilSswitch of expression 'a * statement 'a
  | AilScase of integerConstant * statement 'a
  | AilSdefault of statement 'a
  | AilSlabel of ail_identifier * statement 'a
  | AilSgoto of ail_identifier
  | AilSdeclaration of list (ail_identifier * expression 'a)
  | AilSpar of list (statement 'a) (* NON-STD cppmem threads *)
  | AilSreg_store of reg * expression 'a
and statement 'a [name="s*"] =
  | AnnotatedStatement of Loc.t * statement_ 'a

instance forall 'a. (Located (statement 'a))
  let locOf stmt =
    let (AnnotatedStatement loc _) = stmt in
    loc
end

type function_declaration = <|
  fdecl_has_proto: bool;
  fdecl_return: qualifiers * ctype;
  fdecl_params: list (qualifiers * ctype * is_register);
  fdecl_is_variadic: bool;
  fdecl_is_inline: bool;
  fdecl_is_Noreturn: bool;
|>

type function_definition 'a = <|
  fdef_loc: Loc.t;
  fdef_attrs: Annot.attributes;
  fdef_params: list ail_identifier;
  fdef_body: statement 'a;
|>

type declaration =
  | Decl_object   of (storageDuration * is_register) * qualifiers * ctype
  | Decl_function of function_declaration

(* external identifier kind *)
type id_kind =
  | IK_declaration
  | IK_tentative
  | IK_definition

type sigma 'a = <|
  declarations: list (ail_identifier * (Loc.t * declaration));
  object_definitions: list (ail_identifier * (expression 'a));
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: list (ail_identifier * function_definition 'a);
  static_assertions: list (expression 'a * stringLiteral);
  tag_definitions: list (ail_identifier * tag_definition);
  extern_idmap: map Symbol.identifier (ail_identifier * id_kind);
|>


type gamma = list (ail_identifier * ident_info)

type ail_program 'a = maybe ail_identifier * sigma 'a

