SOURCE_prelude=\
  utils.lem \
  global.lem \
  loc.lem \
  annot.lem \
  bimap.lem \
  dlist.lem \
  debug.lem \
  enum.lem \
  state.lem \
  symbol.lem \
  exception.lem \
  product.lem \
  float.lem \
  any.lem

SOURCE_cabs=\
  cabs.lem \
  undefined.lem \
  constraint.lem \
  ctype.lem

SOURCE_ail=\
  TypingError.lem \
  ErrorMonad.lem \
  AilSyntax.lem \
  GenTypes.lem

SOURCE_core_ctype=\
  core_ctype_aux.lem

SOURCE_core=\
  core.lem \
  errors.lem \
  core_aux.lem \
  core_linking.lem

SOURCE_core_typing=\
  core_typing.lem \
  core_typing_aux.lem \
  core_typing_effect.lem

SOURCE_utils=\
  boot.lem \
  decode.lem \
  exception_undefined.lem \
  multiset.lem \
  state_exception.lem \
  state_exception_undefined.lem \
  std.lem \
  monadic_parsing.lem \
  fs.lem \
  trace_event.lem

SOURCE_ail_typing=\
  Range.lem \
  IntegerImpl.lem \
  AilTypesAux.lem \
  AilSyntaxAux.lem \
  AilWf.lem \
  AilTyping.lem \
  GenTypesAux.lem \
  GenTyping.lem

SOURCE_cabs_to_ail=\
  cabs_to_ail_aux.lem \
  scope_table.lem \
  cabs_to_ail_effect.lem \
  cabs_to_ail.lem \
  wipFrontend.lem

SOURCE_core_to_core=\
  core_sequentialise.lem \
  core_indet.lem \
  core_rewrite.lem \
  core_unstruct.lem

SOURCE_core_dynamics=\
  core_run_aux.lem \
  core_eval.lem \
  core_run.lem \
  core_reduction.lem \
  driver.lem

SOURCE_elaboration=\
  translation_effect.lem \
  translation_aux.lem \
  translation.lem 

SOURCE_defacto=\
  mem_common.lem \
  defacto_memory_types.lem \
  defacto_memory_aux.lem \
  defacto_memory.lem \
  mem.lem \
  mem_aux.lem

SOURCE_concurrency_interface=\
  cmm_aux.lem \
  memory_order.lem

FLAT_SOURCE_concurrency_interface=\
  cmm_aux.lem \
  cmm_csem.lem

SOURCE_language_aux=\

CERBERUS_LEM_FLAT_SOURCES=\
  $(SOURCE_prelude) \
  $(SOURCE_cabs) \
  $(SOURCE_ail) \
  $(SOURCE_core_ctype) \
  $(SOURCE_defacto) \
  $(FLAT_SOURCE_concurrency_interface) \
  $(SOURCE_core) \
  $(SOURCE_utils) \
  $(SOURCE_ail_typing) \
  $(SOURCE_cabs_to_ail) \
  $(SOURCE_core_to_core) \
  $(SOURCE_elaboration) \
  $(SOURCE_core_dynamics)

CERBERUS_LEM_SOURCES=\
  $(SOURCE_prelude) \
  $(SOURCE_cabs) \
  $(addprefix ail/, $(SOURCE_ail)) \
  $(SOURCE_core_ctype) \
  builtins.lem \
  output.lem \
  pp.lem \
  implementation.lem \
  $(SOURCE_defacto) \
  $(SOURCE_utils) \
  nondeterminism.lem \
  $(SOURCE_concurrency_interface) \
  $(SOURCE_core) \
  $(SOURCE_core_typing) \
  $(addprefix ail/, $(SOURCE_ail_typing)) \
  $(SOURCE_cabs_to_ail) \
  $(SOURCE_core_to_core) \
  $(SOURCE_core_dynamics) \
  $(SOURCE_elaboration)

CERBERUS_LEM_SOURCES_COQ=\
  utils.lem \
  enum.lem \
  debug.lem \
  symbol.lem \
  loc.lem \
  annot.lem \
  ctype.lem \
  implementation.lem \
  bimap.lem \
  undefined.lem \
  core.lem \
  memory_order.lem \
  cmm_aux.lem \
  mem_common.lem \
  float.lem \
  mem.lem \
  Range.lem \
  IntegerImpl.lem \
  GenTypes.lem \
  TypingError.lem \
  ErrorMonad.lem \
  AilTypesAux.lem \
  AilSyntax.lem \
  core_reduction.lem \
  core_eval.lem \
  state_exception.lem \
  any.lem \
  global.lem \
  core_run_aux.lem \
  mem_aux.lem \
  dlist.lem \
  product.lem \
  symbol.lem \
  constraint.lem \
  exception.lem \
  state_exception_undefined.lem \
  state.lem \
  decode.lem \
  builtins.lem \
  pp.lem \
  errors.lem \
  core_aux.lem \
  nondeterminism.lem \
  linux.lem \
  core_ctype_aux.lem \
  exception_undefined.lem


# CERBERUS_LEM_SOURCES_COQ=\
#   loc.lem \             source locations (fake in Lem; real impl in OCaml). Currently mapped to unit, but will want proper locations
#   Range.lem \           tiny, just integer ranges
#   IntegerImpl.lem \     C integer impl - maybe here only for ctype.lem. maybe don't use much of IntegerImpl for that.
#   GenTypes.lem \        the types that the Ail type system returns. no idea why we have those
#   TypingError.lem \     typing error of Ail; no idea why here
#   ErrorMonad.lem \      needed by AilTypesAux - maybe we can get rid of that
#   AilTypesAux.lem \     certainly need some of this, but could move things that depend on an implementation to another module
#   AilSyntax.lem \       not actually used in core_run, but is used by other things
#   core.lem \            need
#   core_reduction.lem \  need (the dynamics of effectful expressions)
#   core_eval.lem \       need (the dynamics of pure expressions)
#   symbol.lem \          need (symbols - eg core variables)
#   ctype.lem \           need
#   state_exception.lem \ need (monad)
#   any.lem \             for Victor static analysis arbitrary value - needed, but not really in our source langauge.
#   global.lem \          connecting to OCaml global state. will map to some particular Coq state
#   core_run_aux.lem \    reused some aux functions, but not lots of these
#   mem_aux.lem \         need
#   dlist.lem \           used for logging; shouldn't really need
#   product.lem \         could use Lem now
#   core_run.lem \        this is old; it's going to disappear; not sure why we have it here
#   constraint.lem \      need - C constraint-violation names (this uses GenTYpes)
#   bimap.lem \           need (and tiny) - for undefined
#   undefined.lem \       need - C UB names
#   exception.lem \       need? exception monad
#   cmm_csem.lem \        should split into types (used elsewhere) and lots of other stuff (not used)
#   cmm_aux.lem \         need (but small)
#   state_exception_undefined.lem \     need (monad)
#   state.lem \           need (monad)
#   decode.lem \          mainly used by the frontend. and for printf, but hf doesn't have that
#   builtins.lem \        harmless
#   pp.lem \              morally don't want, but used for logging
#   errors.lem \          Cerberus errors - including runtime errors, which we need
#   core_aux.lem \        need a fair few of these
#   float.lem \           need to have it, but for Hf can stub out with dummy (well-typed) impls
#   implementation.lem \  K needs to check if we use this
#   annot.lem \           AST nodes can be annotated with STD annotations or locations
#   debug.lem \           debug function - stub out
#   enum.lem \            enum type class - commented out
#   mem.lem \             need memory interface
#   mem_common.lem \      need (memory functions that don't depend on concrete/symbolic)
#   nondeterminism.lem \  need (monad) - maybe only was for core_run??
#   linux.lem \           type of linux memory actions - need for that
#   core_ctype_aux.lem \  need
#   cmm_op.lem \          shouldn't need that - Kyndylan's op sem
#   exception_undefined.lem \   need (monad)
#   utils.lem             things that should have been in Lem std library
  

