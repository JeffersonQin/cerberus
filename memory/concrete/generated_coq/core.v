(* Generated by Lem from ocaml_generated/core.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(* generated by Ott 0.28 from: core.ott *)
Require Import lem_pervasives.
Require Export lem_pervasives.


Require Import ctype.
Require Export ctype.
Require Import annot.
Require Export annot.
Require Import loc.
Require Export loc.

Require Import symbol.
Require Export symbol.
Require Import implementation.
Require Export implementation.
Require Import undefined.
Require Export undefined.
Require Import cmm_csem.
Require Export cmm_csem.

Require Import mem.
Require Export mem.
Require Import mem_common.
Require Export mem_common.

Require Import linux.
Require Export linux.



Inductive core_object_type : Type :=   (* types for C objects *)
 | OTy_integer: core_object_type 
 | OTy_floating: core_object_type 
 | OTy_pointer: core_object_type 
 | OTy_array:  core_object_type  -> core_object_type 
 | OTy_struct:  symbol.sym  -> core_object_type 
 | OTy_union:  symbol.sym  -> core_object_type .
Definition core_object_type_default: core_object_type  := OTy_integer.

Program Fixpoint eq_core_object_type  (oTy1 : core_object_type ) (oTy2 : core_object_type )  : bool := 
  let ord := fun (x : core_object_type ) =>
   match (x) with | OTy_integer => ( 0 : nat ) | OTy_floating =>  1
     | OTy_pointer =>  2 | OTy_array _ =>  3 | OTy_struct _ =>  4
     | OTy_union _ =>  5 end in
  match ( (oTy1, oTy2)) with 
    | (OTy_array oTy1,  OTy_array oTy2) =>
        eq_core_object_type oTy1 oTy2
    | (OTy_struct sym1,  OTy_struct sym2) => match ( (sym1, sym2)) with 
    | (symbol.Symbol d1 n1 str_opt1,  symbol.Symbol d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end
    | (OTy_union sym1,  OTy_union sym2) => match ( (sym1, sym2)) with 
    | (symbol.Symbol d1 n1 str_opt1,  symbol.Symbol d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end
    | _ => beq_nat
        (ord oTy1) (ord oTy2)
  end.
Instance x18_Eq : Eq core_object_type := {
   isEqual  :=  eq_core_object_type;
   isInequal  :=  fun  x  y => negb (eq_core_object_type x y)
}.



Inductive core_base_type : Type :=   (* Core base types *)
 | BTy_unit: core_base_type  (* unit *)
 | BTy_boolean: core_base_type  (* boolean *)
 | BTy_ctype: core_base_type  (* Core type of C type exprs *)
 | BTy_list:  core_base_type  -> core_base_type  (* list *)
 | BTy_tuple:  list  core_base_type  -> core_base_type  (* tuple *)
 | BTy_object:  core_object_type  -> core_base_type  (* C object value *)
 | BTy_loaded:  core_object_type  -> core_base_type  (* core_object_type or unspecified *)
 | BTy_storable: core_base_type .
Definition core_base_type_default: core_base_type  := BTy_unit. (* top type for integer/float/pointer/structs (maybe union?). This is only used in the type system *)

Program Fixpoint eq_core_base_type  (bTy1 : core_base_type ) (bTy2 : core_base_type )  : bool := 
  let ord := fun (x : core_base_type ) =>
   match (x) with | BTy_unit => ( 0 : nat ) | BTy_boolean =>  1
     | BTy_ctype =>  2 | BTy_list _ =>  3 | BTy_tuple _ =>  4
     | BTy_object _ =>  5 | BTy_loaded _ =>  6 | BTy_storable =>  7 end in
  match ( (bTy1, bTy2)) with 
    | (BTy_list bTy1',  BTy_list bTy2') =>
        eq_core_base_type bTy1' bTy2'
    | (BTy_tuple bTys1,  BTy_tuple bTys2) =>
        list_equal_by eq_core_base_type bTys1 bTys2
    | (BTy_object oTy1,  BTy_object oTy2) => eq_core_object_type
        oTy1 oTy2
    | (BTy_loaded oTy1,  BTy_loaded oTy2) => eq_core_object_type
        oTy1 oTy2
    | _ => beq_nat
        (ord bTy1) (ord bTy2)
  end.
Instance x17_Eq : Eq core_base_type := {
   isEqual  :=  eq_core_base_type;
   isInequal  :=  fun  x  y => negb (eq_core_base_type x y)
}.



Inductive binop : Type :=   (* binary operators *)
 | OpAdd: binop 
 | OpSub: binop 
 | OpMul: binop 
 | OpDiv: binop 
 | OpRem_t: binop 
 | OpRem_f: binop 
 | OpExp: binop 
 | OpEq: binop 
 | OpGt: binop 
 | OpLt: binop 
 | OpGe: binop 
 | OpLe: binop 
 | OpAnd: binop 
 | OpOr: binop .
Definition binop_default: binop  := OpAdd.


Inductive core_type : Type :=   (* Core types *)
 | TyBase:  core_base_type  -> core_type  (* pure base type *)
 | TyEffect:  core_base_type  -> core_type .
Definition core_type_default: core_type  := TyBase core_base_type_default. (* effectful base type *)

Instance x16_Eq : Eq binop := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.


Instance x15_Show : Show binop := {
   show   op :=  
    match ( op) with 
      | OpAdd   => "OpAdd"
      | OpSub   => "OpSub"
      | OpMul   => "OpMul"
      | OpDiv   => "OpDiv"
      | OpRem_t => "OpRem_t"
      | OpRem_f => "OpRem_f"
      | OpExp   => "OpExp"
      | OpEq    => "OpEq"
      | OpGt    => "OpGt"
      | OpLt    => "OpLt"
      | OpGe    => "OpGe"
      | OpLe    => "OpLe"
      | OpAnd   => "OpAnd"
      | OpOr    => "OpOr"
    end
}.
  


Inductive polarity : Type :=   (* memory action polarities *)
 | Pos: polarity  (* sequenced by \ottkw{let\ weak} and \ottkw{let\ strong} *)
 | Neg: polarity .
Definition polarity_default: polarity  := Pos. (* only sequenced by \ottkw{let\ strong} *)


Inductive generic_name (sym : Type) : Type :=  
 | Sym:  sym -> generic_name sym (* Core identifier *)
 | Impl:  implementation.implementation_constant  -> generic_name sym.
Definition generic_name_default{sym: Type} : generic_name sym := Sym DAEMON. (* implementation-defined constant *)

Instance x14_MapKeyType{sym: Type} `{MapKeyType sym}: MapKeyType (generic_name  sym):= {
   mapKeyCompare   nm1  nm2 := 
    match ( (nm1, nm2)) with 
      | (Sym sym1,  Sym sym2) =>
          mapKeyCompare sym1 sym2
      | (Impl iCst1,  Impl iCst2) =>
          implementation.implementation_constant_compare iCst1 iCst2
      | (Sym _,  Impl _) =>
          LT
      | (Impl _,  Sym _) =>
          GT
    end
}.



Inductive generic_object_value (sym : Type) : Type :=   (* C object values *)
 | OVinteger:  tt  -> generic_object_value sym (* integer value *)
 | OVfloating:  tt  -> generic_object_value sym (* floating-point value *)
 | OVpointer:  tt  -> generic_object_value sym (* pointer value *)
 | OVarray:  list  (generic_loaded_value  sym) -> generic_object_value sym (* C array value *)
 | OVstruct:  symbol.sym  ->  list  ((cabs.cabs_identifier  * ctype  * tt ) % type) -> generic_object_value sym (* C struct value *)
 | OVunion:  symbol.sym  ->  cabs.cabs_identifier  ->  tt  -> generic_object_value sym (* C union value *)

with generic_loaded_value (sym : Type) : Type :=   (* potentially unspecified C object values *)
 | LVspecified:  (generic_object_value  sym) -> generic_loaded_value sym (* non-unspecified loaded value *)
 | LVunspecified:  ctype  -> generic_loaded_value sym.
Definition generic_object_value_default{sym: Type} : generic_object_value sym := OVinteger tt_default.
Definition generic_loaded_value_default{sym: Type} : generic_loaded_value sym := LVspecified DAEMON. (* unspecified loaded value *)


Inductive generic_value (sym : Type) : Type :=   (* Core values *)
 | Vobject:  (generic_object_value  sym) -> generic_value sym (* C object value *)
 | Vloaded:  (generic_loaded_value  sym) -> generic_value sym (* loaded C object value *)
 | Vunit: generic_value sym
 | Vtrue: generic_value sym
 | Vfalse: generic_value sym
 | Vctype:  ctype  -> generic_value sym (* C type as value *)
 | Vlist:  core_base_type  ->  list  (generic_value  sym) -> generic_value sym
 | Vtuple:  list  (generic_value  sym) -> generic_value sym.
Definition generic_value_default{sym: Type} : generic_value sym := Vobject DAEMON. (* tuple *)


Inductive generic_ctor (bty : Type) : Type :=   (* data constructors *)
 | Cnil:  bty -> generic_ctor bty (* empty list *)
 | Ccons: generic_ctor bty (* list cons *)
 | Ctuple: generic_ctor bty (* tuple *)
 | Carray: generic_ctor bty (* C array *)
 | Civmax: generic_ctor bty (* max integer value *)
 | Civmin: generic_ctor bty (* min integer value *)
 | Civsizeof: generic_ctor bty (* sizeof value *)
 | Civalignof: generic_ctor bty (* alignof value *)
 | CivCOMPL: generic_ctor bty (* bitwise complement *)
 | CivAND: generic_ctor bty (* bitwise AND *)
 | CivOR: generic_ctor bty (* bitwise OR *)
 | CivXOR: generic_ctor bty (* bitwise XOR *)
 | Cspecified: generic_ctor bty (* non-unspecified loaded value *)
 | Cunspecified: generic_ctor bty (* unspecified loaded value *)
 | Cfvfromint: generic_ctor bty (* cast integer to floating value *)
 | Civfromfloat: generic_ctor bty.
Definition generic_ctor_default{bty: Type} : generic_ctor bty := Cnil DAEMON. (* cast floating to integer value *)


Inductive generic_pattern_ (bty : Type) (sym : Type) : Type :=  
 | CaseBase:  ((option  sym  * core_base_type ) % type) -> generic_pattern_ bty sym
 | CaseCtor:  (generic_ctor  bty) ->  list  (generic_pattern  bty  sym) -> generic_pattern_ bty sym

with generic_pattern (bty : Type) (sym : Type) : Type :=  
 | Pattern:  list  annot  ->  (generic_pattern_  bty  sym) -> generic_pattern bty sym.
Definition generic_pattern__default {bty: Type} {sym: Type} : generic_pattern_ bty sym := CaseBase (DAEMON, core_base_type_default).
Definition generic_pattern_default {bty: Type} {sym: Type} : generic_pattern bty sym := Pattern DAEMON DAEMON.


Inductive generic_pexpr_ (bty : Type) (sym : Type) : Type :=   (* Core pure expressions *)
 | PEsym:  sym -> generic_pexpr_ bty sym
 | PEimpl:  implementation.implementation_constant  -> generic_pexpr_ bty sym (* implementation-defined constant *)
 | PEval:  (generic_value  sym) -> generic_pexpr_ bty sym
 | PEconstrained:  list  ((mem.mem_iv_constraint  * (generic_pexpr  bty  sym)) % type) -> generic_pexpr_ bty sym (* constrained value *)
 | PEundef:  unit  ->  undefined.undefined_behaviour  -> generic_pexpr_ bty sym (* undefined behaviour *)
 | PEerror:  string  ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* impl-defined static error *)
 | PEctor:  (generic_ctor  bty) ->  list  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* data constructor application *)
 | PEcase:  (generic_pexpr  bty  sym) ->  list  (((generic_pattern  bty  sym) * (generic_pexpr  bty  sym)) % type) -> generic_pexpr_ bty sym (* pattern matching *)
 | PEarray_shift:  (generic_pexpr  bty  sym) ->  ctype  ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* pointer array shift *)
 | PEmember_shift:  (generic_pexpr  bty  sym) ->  sym ->  cabs.cabs_identifier  -> generic_pexpr_ bty sym (* pointer struct/union member shift *)
 | PEnot:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* boolean not *)
 | PEop:  binop  ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym
 | PEstruct:  sym ->  list  ((cabs.cabs_identifier  * (generic_pexpr  bty  sym)) % type) -> generic_pexpr_ bty sym (* C struct expression *)
 | PEunion:  sym ->  cabs.cabs_identifier  ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* C union expression *)
 | PEcfunction:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* C function pointer expression *)
 | PEmemberof:  sym ->  cabs.cabs_identifier  ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* C struct/union member access *)
 | PEcall:  (generic_name  sym) ->  list  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* pure function call *)
 | PElet:  (generic_pattern  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* pure let *)
 | PEif:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym (* pure if *)
 | PEis_scalar:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym
 | PEis_integer:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym
 | PEis_signed:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym
 | PEis_unsigned:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym
 | PEbmc_assume:  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym
 | PEare_compatible:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) -> generic_pexpr_ bty sym

with generic_pexpr (bty : Type) (sym : Type) : Type :=  
 | Pexpr:  list  annot  ->  bty ->  (generic_pexpr_  bty  sym) -> generic_pexpr bty sym.
Definition generic_pexpr__default {bty: Type} {sym: Type} : generic_pexpr_ bty sym := PEsym DAEMON.
Definition generic_pexpr_default {bty: Type} {sym: Type} : generic_pexpr bty sym := Pexpr DAEMON DAEMON DAEMON.


Inductive generic_action_ (bty : Type) (sym : Type) : Type :=   (* memory actions *)
 | Create:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  symbol.prefix  -> generic_action_ bty sym
 | CreateReadOnly:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  symbol.prefix  -> generic_action_ bty sym
 | Alloc0:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  symbol.prefix  -> generic_action_ bty sym
 | Kill:  bool  ->  (generic_pexpr  bty  sym) -> generic_action_ bty sym (* the boolean indicates whether the action is dynamic (i.e. free()) *)
 | Store0:  bool  ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  cmm_csem.memory_order  -> generic_action_ bty sym (* the boolean indicates whether the store is locking *)
 | Load0:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  cmm_csem.memory_order  -> generic_action_ bty sym
 | SeqRMW:  bool  ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  sym ->  (generic_pexpr  bty  sym) -> generic_action_ bty sym (* the boolean indicates whether the value should be that of the update (otherwise it is what was read from memory) *)
 | RMW0:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  cmm_csem.memory_order  ->  cmm_csem.memory_order  -> generic_action_ bty sym
 | Fence0:  cmm_csem.memory_order  -> generic_action_ bty sym
 | CompareExchangeStrong:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  cmm_csem.memory_order  ->  cmm_csem.memory_order  -> generic_action_ bty sym
 | CompareExchangeWeak:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  cmm_csem.memory_order  ->  cmm_csem.memory_order  -> generic_action_ bty sym
 | LinuxFence:  linux.linux_memory_order  -> generic_action_ bty sym
 | LinuxLoad:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  linux.linux_memory_order  -> generic_action_ bty sym
 | LinuxStore:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  linux.linux_memory_order  -> generic_action_ bty sym
 | LinuxRMW:  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  linux.linux_memory_order  -> generic_action_ bty sym.
Definition generic_action__default {bty: Type} {sym: Type} : generic_action_ bty sym := Create DAEMON DAEMON prefix_default.


Inductive generic_action (a : Type) (bty : Type) (sym : Type) : Type :=  
 | Action:  unit  ->  a ->  (generic_action_  bty  sym) -> generic_action a bty sym.
Definition generic_action_default {a: Type} {bty: Type} {sym: Type} : generic_action a bty sym := Action unit_default DAEMON DAEMON.


Inductive generic_paction (a : Type) (bty : Type) (sym : Type) : Type :=   (* memory actions with polarity *)
 | Paction:  polarity  ->  (generic_action  a  bty  sym) -> generic_paction a bty sym.
Definition generic_paction_default {a: Type} {bty: Type} {sym: Type} : generic_paction a bty sym := Paction polarity_default DAEMON.


Inductive dyn_annotation : Type := 
  | DA_neg:  nat  ->  list  nat  ->  tt  -> dyn_annotation  (* the nat is its unique "exclusion ID", the list is its "exclusion set" *)
  | DA_pos:  list  nat  ->  tt  -> dyn_annotation .
Definition dyn_annotation_default: dyn_annotation  := DA_neg nat_default DAEMON tt_default. (* the list of nat is its "exclusions set" *)

Definition dyn_annotations : Type := 
  list  dyn_annotation .
Definition dyn_annotations_default: dyn_annotations  := DAEMON.

Inductive generic_expr_ (a : Type) (bty : Type) (sym : Type) : Type :=   (* (effectful) expression *)
 | Epure:  (generic_pexpr  bty  sym) -> generic_expr_ a bty sym
 | Ememop:  mem_common.memop  ->  list  (generic_pexpr  bty  sym) -> generic_expr_ a bty sym (* pointer op involving memory *)
 | Eaction:  (generic_paction  a  bty  sym) -> generic_expr_ a bty sym (* memory action *)
 | Ecase:  (generic_pexpr  bty  sym) ->  list  (((generic_pattern  bty  sym) * (generic_expr  a  bty  sym)) % type) -> generic_expr_ a bty sym (* pattern matching *)
 | Elet:  (generic_pattern  bty  sym) ->  (generic_pexpr  bty  sym) ->  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym
 | Eif:  (generic_pexpr  bty  sym) ->  (generic_expr  a  bty  sym) ->  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym
 | Eccall:  a ->  (generic_pexpr  bty  sym) ->  (generic_pexpr  bty  sym) ->  list  (generic_pexpr  bty  sym) -> generic_expr_ a bty sym (* C function call *)
 | Eproc:  a ->  (generic_name  sym) ->  list  (generic_pexpr  bty  sym) -> generic_expr_ a bty sym (* Core procedure call *)
 | Eunseq:  list  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* unsequenced expressions *)
 | Ewseq:  (generic_pattern  bty  sym) ->  (generic_expr  a  bty  sym) ->  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* weak sequencing *)
 | Esseq:  (generic_pattern  bty  sym) ->  (generic_expr  a  bty  sym) ->  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* strong sequencing *)
 | Easeq:  ((sym * core_base_type ) % type) ->  (generic_action  a  bty  sym) ->  (generic_action  a  bty  sym) -> generic_expr_ a bty sym (* atomic sequencing *)
(*
 | Eindet of nat * (generic_expr 'a 'bty 'sym) (* indeterminately sequenced expr *)
*)
 | Ebound:  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* $\ldots$and boundary *)
 | End:  list  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* nondeterministic sequencing *)
 | Esave:  ((sym * core_base_type ) % type) ->  list  ((sym * ((core_base_type  * generic_pexpr  bty  sym) % type)) % type) ->  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* save label *)
 | Erun:  a ->  sym ->  list  (generic_pexpr  bty  sym) -> generic_expr_ a bty sym (* run from label *)
 | Epar:  list  (generic_expr  a  bty  sym) -> generic_expr_ a bty sym (* cppmem-like thread creation *)
 (* This two only exists during the execution *)
 | Ewait:  mem_common.thread_id  -> generic_expr_ a bty sym (* wait for thread termination *)
  
 | Eannot:  dyn_annotations  ->  generic_expr  a  bty  sym -> generic_expr_ a bty sym
 | Eexcluded:  nat  ->  generic_action  a  bty  sym -> generic_expr_ a bty sym

with generic_expr (a : Type) (bty : Type) (sym : Type) : Type :=  
 | Expr:  list  annot  ->  (generic_expr_  a  bty  sym) -> generic_expr a bty sym.
Definition generic_expr__default {a: Type} {bty: Type} {sym: Type} : generic_expr_ a bty sym := Epure DAEMON.
Definition generic_expr_default {a: Type} {bty: Type} {sym: Type} : generic_expr a bty sym := Expr DAEMON DAEMON.

Inductive generic_impl_decl (bty : Type) : Type := 
  | Def:  core_base_type  ->  generic_pexpr  bty  symbol.sym  -> generic_impl_decl bty
  | IFun:  core_base_type  ->  list  ((symbol.sym  * core_base_type ) % type) ->  generic_pexpr  bty  symbol.sym  -> generic_impl_decl bty.
Definition generic_impl_decl_default{bty: Type} : generic_impl_decl bty := Def core_base_type_default DAEMON.
Definition generic_impl (bty: Type) : Type :=  fmap  implementation.implementation_constant   (generic_impl_decl  bty).
Definition generic_impl_default{bty: Type} : generic_impl bty := DAEMON.

Inductive generic_fun_map_decl (bty : Type) (a : Type) : Type := 
  | Fun:  core_base_type  ->  list  ((symbol.sym  * core_base_type ) % type) ->  generic_pexpr  bty  symbol.sym  -> generic_fun_map_decl bty a
  | Proc:  unit  ->  core_base_type  ->  list  ((symbol.sym  * core_base_type ) % type) ->  generic_expr  a  bty  symbol.sym  -> generic_fun_map_decl bty a
  | ProcDecl:  unit  ->  core_base_type  ->  list  core_base_type  -> generic_fun_map_decl bty a
  | BuiltinDecl:  unit  ->  core_base_type  ->  list  core_base_type  -> generic_fun_map_decl bty a.
Definition generic_fun_map_decl_default {bty: Type} {a: Type} : generic_fun_map_decl bty a := Fun core_base_type_default DAEMON DAEMON.

Definition generic_fun_map  (bty: Type) (a: Type) : Type :=  fmap  symbol.sym   (generic_fun_map_decl  bty  a).
Definition generic_fun_map_default {bty: Type} {a: Type} : generic_fun_map bty a := DAEMON.

Instance x13_Located{bty sym: Type} : Located (generic_pattern  bty  sym):= {
   locOf   pat :=  match ( pat) with ( Pattern annots1 _) => get_loc_ annots1 end
}.


Instance x12_Located{bty sym: Type} : Located (generic_pexpr  bty  sym):= {
   locOf   pe :=  match ( pe) with ( Pexpr annots1 _ _) => get_loc_ annots1 end
}.


Instance x11_Located{a bty sym: Type} : Located (generic_expr  a  bty  sym):= {
   locOf   e :=  match ( e) with ( Expr annots1 _) => get_loc_ annots1 end
}.


Inductive linking_kind : Type := 
  | LK_none: linking_kind 
  | LK_tentative:  symbol.sym  -> linking_kind 
  | LK_normal:  symbol.sym  -> linking_kind .
Definition linking_kind_default: linking_kind  := LK_none.

Instance x10_Show : Show linking_kind := {
  show   x :=  
   match ( x) with 
   | LK_none => "LK_none"
   | LK_tentative sym1 =>  String.append"LK_tentative" 
  match ( sym1) with symbol.Symbol d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun  x_opt=>
            stringFromMaybe
              (fun  s=> String.append """" (String.append s """")) x_opt)
         (n, str_opt)) end
   | LK_normal sym1 =>  String.append"LK_normal" 
  match ( sym1) with symbol.Symbol d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun  x_opt=>
            stringFromMaybe
              (fun  s=> String.append """" (String.append s """")) x_opt)
         (n, str_opt)) end
   end
}.



Definition extern_map : Type := 
  fmap  cabs.cabs_identifier   ((list  symbol.sym  * linking_kind ) % type).
Definition extern_map_default: extern_map  := DAEMON.

Inductive generic_globs (a : Type) (bty : Type) : Type :=
  | GlobalDef:  core_base_type  ->  generic_expr  a  bty  symbol.sym  -> generic_globs a bty
  | GlobalDecl:  core_base_type  -> generic_globs a bty.
Definition generic_globs_default {a: Type} {bty: Type} : generic_globs a bty := GlobalDef core_base_type_default DAEMON.

Definition generic_globs_map  (a: Type) (bty: Type) : Type := 
  fmap  symbol.sym   (generic_globs  a  bty).
Definition generic_globs_map_default {a: Type} {bty: Type} : generic_globs_map a bty := DAEMON.

Definition core_tag_definitions : Type := 
  fmap  symbol.sym   ctype.tag_definition .
Definition core_tag_definitions_default: core_tag_definitions  := DAEMON.

(* a Core file is just a set of named functions *)
Record generic_file  (bty: Type) (a: Type) : Type := {
  main    : option  symbol.sym  ;
  tagDefs : core_tag_definitions ;
  stdlib  : generic_fun_map  bty  a;
  impl    : generic_impl  bty;
  globs   : list  ((symbol.sym  * generic_globs  a  bty) % type);
  funs    : generic_fun_map  bty  a;
  extern  : extern_map ;
  funinfo : fmap  symbol.sym   ((ctype  * list  ((option  symbol.sym   * ctype ) % type) * bool  * bool ) % type)
}.
Notation "{[ r 'with' 'main' := e ]}" := ({| main := e; tagDefs := tagDefs r; stdlib := stdlib r; impl := impl r; globs := globs r; funs := funs r; extern := extern r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'tagDefs' := e ]}" := ({| tagDefs := e; main := main r; stdlib := stdlib r; impl := impl r; globs := globs r; funs := funs r; extern := extern r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'stdlib' := e ]}" := ({| stdlib := e; main := main r; tagDefs := tagDefs r; impl := impl r; globs := globs r; funs := funs r; extern := extern r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'impl' := e ]}" := ({| impl := e; main := main r; tagDefs := tagDefs r; stdlib := stdlib r; globs := globs r; funs := funs r; extern := extern r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'globs' := e ]}" := ({| globs := e; main := main r; tagDefs := tagDefs r; stdlib := stdlib r; impl := impl r; funs := funs r; extern := extern r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'funs' := e ]}" := ({| funs := e; main := main r; tagDefs := tagDefs r; stdlib := stdlib r; impl := impl r; globs := globs r; extern := extern r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'extern' := e ]}" := ({| extern := e; main := main r; tagDefs := tagDefs r; stdlib := stdlib r; impl := impl r; globs := globs r; funs := funs r; funinfo := funinfo r |}).
Notation "{[ r 'with' 'funinfo' := e ]}" := ({| funinfo := e; main := main r; tagDefs := tagDefs r; stdlib := stdlib r; impl := impl r; globs := globs r; funs := funs r; extern := extern r |}).
Definition generic_file_default {bty: Type} {a: Type} : generic_file bty a := {| main := DAEMON; tagDefs := core_tag_definitions_default; stdlib := DAEMON; impl := DAEMON; globs := DAEMON; funs := DAEMON; extern := extern_map_default; funinfo := DAEMON |}.


Definition name : Type :=             generic_name  symbol.sym .
Definition name_default: name  := DAEMON.
Definition object_value : Type :=     generic_object_value  symbol.sym .
Definition object_value_default: object_value  := DAEMON.
Definition loaded_value : Type :=     generic_loaded_value  symbol.sym .
Definition loaded_value_default: loaded_value  := DAEMON.
Definition value0 : Type :=            generic_value  symbol.sym .
Definition value0_default: value0  := DAEMON.
Definition ctor : Type :=             generic_ctor  unit .
Definition ctor_default: ctor  := DAEMON.
Definition pattern : Type :=          generic_pattern  unit   symbol.sym .
Definition pattern_default: pattern  := DAEMON.
Definition pexpr : Type :=            generic_pexpr  unit   symbol.sym .
Definition pexpr_default: pexpr  := DAEMON.
Definition expr (a: Type) : Type :=          generic_expr  a  unit   symbol.sym .
Definition expr_default{a: Type} : expr a := DAEMON.
Definition action0 (a: Type) : Type :=        generic_action  a  unit   symbol.sym .
Definition action0_default{a: Type} : action0 a := DAEMON.
Definition paction (a: Type) : Type :=       generic_paction  a  unit   symbol.sym .
Definition paction_default{a: Type} : paction a := DAEMON.
Definition impl_decl : Type :=        generic_impl_decl  unit .
Definition impl_decl_default: impl_decl  := DAEMON.
Definition impl_ : Type :=             generic_impl  unit .
Definition impl__default: impl_  := DAEMON.
Definition fun_map_decl (a: Type) : Type :=  generic_fun_map_decl  unit   a.
Definition fun_map_decl_default{a: Type} : fun_map_decl a := DAEMON.
Definition fun_map (a: Type) : Type :=       generic_fun_map  unit   a.
Definition fun_map_default{a: Type} : fun_map a := DAEMON.
Definition file (a: Type) : Type :=          generic_file  unit   a.
Definition file_default{a: Type} : file a := DAEMON.

Definition typed_ctor : Type :=             generic_ctor  core_base_type .
Definition typed_ctor_default: typed_ctor  := DAEMON.
Definition typed_pattern : Type :=          generic_pattern  core_base_type   symbol.sym .
Definition typed_pattern_default: typed_pattern  := DAEMON.
Definition typed_pexpr : Type :=            generic_pexpr  core_base_type   symbol.sym .
Definition typed_pexpr_default: typed_pexpr  := DAEMON.
Definition typed_expr (a: Type) : Type :=          generic_expr  a  core_base_type   symbol.sym .
Definition typed_expr_default{a: Type} : typed_expr a := DAEMON.
Definition typed_action (a: Type) : Type :=        generic_action  a  core_base_type   symbol.sym .
Definition typed_action_default{a: Type} : typed_action a := DAEMON.
Definition typed_paction (a: Type) : Type :=       generic_paction  a  core_base_type   symbol.sym .
Definition typed_paction_default{a: Type} : typed_paction a := DAEMON.
Definition typed_impl_decl : Type :=        generic_impl_decl  core_base_type .
Definition typed_impl_decl_default: typed_impl_decl  := DAEMON.
Definition typed_impl : Type :=             generic_impl  core_base_type .
Definition typed_impl_default: typed_impl  := DAEMON.
Definition typed_fun_map_decl (a: Type) : Type :=  generic_fun_map_decl  core_base_type   a.
Definition typed_fun_map_decl_default{a: Type} : typed_fun_map_decl a := DAEMON.
Definition typed_fun_map (a: Type) : Type :=       generic_fun_map  core_base_type   a.
Definition typed_fun_map_default{a: Type} : typed_fun_map a := DAEMON.
Definition typed_file (a: Type) : Type :=          generic_file  core_base_type   a.
Definition typed_file_default{a: Type} : typed_file a := DAEMON. (* workaround for Lem issue #74 *)






 
 
 
 
 

 
 
 
 
 (* basic class instanciations *)
 Instance x9_SetType : SetType polarity := {
    setElemCompare  :=  (fun  x  y=>EQ)
}.
 



