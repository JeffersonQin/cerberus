(* Generated by Lem from ocaml_generated/GenTypes.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import ailSyntax.
Require Export ailSyntax.
Require Import ctype.
Require Export ctype.


Inductive genIntegerType : Type := 
 | Concrete:  integerType  -> genIntegerType 
 | SizeT: genIntegerType 
 | PtrdiffT: genIntegerType 
 | Unknown:  integerConstant  -> genIntegerType 
 | Promote:  genIntegerType  -> genIntegerType 
 | Usual:  genIntegerType  ->  genIntegerType  -> genIntegerType .
Definition genIntegerType_default: genIntegerType  := Concrete integerType_default.


Inductive genBasicType : Type := 
 | GenInteger:  genIntegerType  -> genBasicType 
 | GenFloating:  floatingType  -> genBasicType .
Definition genBasicType_default: genBasicType  := GenInteger genIntegerType_default.

Inductive genType : Type := 
 | GenVoid: genType 
 | GenBasic:  genBasicType  -> genType 
 | GenArray:  ctype  ->  (option  Z  ) -> genType 
 | GenFunction:  (* has_proto *)bool  ->  ((qualifiers  * ctype ) % type)
              ->  list  ((qualifiers  * ctype  * (* is_register *)bool ) % type)
              ->  (* is_variadic *)bool  -> genType 
 | GenPointer:  qualifiers  ->  ctype  -> genType 
 | GenStruct:  identifier  -> genType 
 | GenUnion:  identifier  -> genType 
 | GenAtomic:  ctype  -> genType .
Definition genType_default: genType  := GenVoid.
(* [?]: removed value specification. *)

Definition genChar16_t   : genType := 
  (* STD Â§7.28#2 *)
  GenBasic (GenInteger (Concrete (Unsigned (Int_leastN_t( 16))))).
(* [?]: removed value specification. *)

Definition genChar32_t   : genType := 
  (* STD Â§7.28#2 *)
  GenBasic (GenInteger (Concrete (Unsigned (Int_leastN_t( 32))))).


(* TODO: is this ever used? *)
Inductive typeCategory : Type :=  
 | LValueType:  qualifiers  ->  ctype  ->  (* isRegister *) bool  -> typeCategory 
 | RValueType:  ctype  -> typeCategory .
Definition typeCategory_default: typeCategory  := LValueType qualifiers_default ctype_default bool_default.


Inductive genTypeCategory : Type := 
 | GenLValueType:  qualifiers  ->  ctype  ->  (* isRegister *) bool  -> genTypeCategory 
 | GenRValueType:  genType  -> genTypeCategory .
Definition genTypeCategory_default: genTypeCategory  := GenLValueType qualifiers_default ctype_default bool_default.


(* Equality functions *)
Program Fixpoint eq_genIntegerType  (gity1 : genIntegerType ) (gity2 : genIntegerType )  : bool := 
  let ord := fun (x : genIntegerType ) =>
   match (x) with | Concrete _ => ( 0 : nat ) | SizeT =>  1 | PtrdiffT => 
    2 | Unknown _ =>  3 | Promote _ =>  4 | Usual _ _ =>  5 end in
  match ( (gity1, gity2)) with 
    | (Concrete ity1,  Concrete ity2) => integerTypeEqual
        ity1 ity2
    | (Unknown iCst1,  Unknown iCst2) => classical_boolean_equivalence
        iCst1 iCst2
    | (Promote gity1,  Promote gity2) =>
        eq_genIntegerType gity1 gity2
    | (Usual gity11 gity21,  Usual gity12 gity22) =>
        eq_genIntegerType gity11 gity12 && eq_genIntegerType gity21 gity22
    | _ => beq_nat
        (ord gity1) (ord gity2)
  end.

Instance x42_Eq : Eq genIntegerType := {
   isEqual   :=  eq_genIntegerType;
   isInequal  :=  fun  git1  git2 => negb (eq_genIntegerType git1 git2)
}.



Definition eq_genBasicType  (gbty1 : genBasicType ) (gbty2 : genBasicType )  : bool := 
  match ( (gbty1, gbty2)) with 
    | (GenInteger gity1,  GenInteger gity2) =>
        eq_genIntegerType gity1 gity2
    | (GenFloating fty1,  GenFloating fty2) => classical_boolean_equivalence
        fty1 fty2
    | _ =>
        false
  end.

Instance x41_Eq : Eq genBasicType := {
   isEqual   :=  eq_genBasicType;
   isInequal  :=  fun  gbty1  gbty2 => negb (eq_genBasicType gbty1 gbty2)
}.



Definition eq_genType  (gty1 : genType ) (gty2 : genType )  : bool := 
  let ord := fun (x : genType ) =>
   match (x) with | GenVoid => ( 0 : nat ) | GenBasic _ =>  1
     | GenArray _ _ =>  2 | GenFunction _ _ _ _ =>  3 | GenPointer _ _ => 
    4 | GenStruct _ =>  5 | GenUnion _ =>  6 | GenAtomic _ =>  7 end in
  match ( (gty1, gty2)) with 
    | (GenBasic gbty1,  GenBasic gbty2)  => eq_genBasicType
        gbty1 gbty2
    | (GenArray ty1 n1_opt,  GenArray ty2 n2_opt) => ctypeEqual
        ty1 ty2 && (maybeEqualBy Z.eqb n1_opt n2_opt)
    | (GenFunction has_proto1 (qs1,  ty1) params1 b1, 
       GenFunction has_proto2 (qs2,  ty2) params2 b2)  => Bool.eqb
        has_proto1 has_proto2 && (qualifiersEqual qs1 qs2
        && (ctypeEqual ty1 ty2 && ((list_equal_by tripleEqual params1 params2) && Bool.eqb b1 b2)))
    | (GenPointer qs1 ty1,  GenPointer qs2 ty2) => qualifiersEqual
        qs1 qs2 && ctypeEqual ty1 ty2
    | (GenStruct tag1,  GenStruct tag2) => match ( (tag1, tag2)) with 
    | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end
    | (GenUnion tag1,  GenUnion tag2) => match ( (tag1, tag2)) with 
    | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end
    | (GenAtomic ty1,  GenAtomic ty2) => ctypeEqual
        ty1 ty2
    | _ => beq_nat
        (ord gty1) (ord gty2)
  end.

Instance x40_Eq : Eq genType := {
   isEqual   :=  eq_genType;
   isInequal  :=  fun  gty1  gty2 => negb (eq_genType gty1 gty2)
}.


Definition eq_genTypeCategory  (gentyCat1 : genTypeCategory ) (gentyCat2 : genTypeCategory )  : bool := 
  let ord := fun (x : genTypeCategory ) =>
   match (x) with | GenLValueType _ _ _ => ( 0 : nat ) | GenRValueType _ =>
      1 end in
  match ( (gentyCat1, gentyCat2)) with 
    | (GenLValueType qs1 ty1 isRegister1,  GenLValueType qs2 ty2 isRegister2) => qualifiersEqual
        qs1 qs2 && (ctypeEqual ty1 ty2 && Bool.eqb isRegister1 isRegister2)
    | (GenRValueType gty1,  GenRValueType gty2) => eq_genType
        gty1 gty2
    | _ => beq_nat
        (ord gentyCat1) (ord gentyCat2)
  end.

Instance x39_Eq : Eq genTypeCategory := {
   isEqual   :=  eq_genTypeCategory;
   isInequal  :=  fun  gty1  gty2 => negb (eq_genTypeCategory gty1 gty2)
}.

(* [?]: removed value specification. *)

Definition inject_integerType  (ity : integerType )  : genIntegerType := 
  Concrete ity.
(* [?]: removed value specification. *)

Definition inject_basicType   : basicType  -> genBasicType :=  
  fun (x : basicType ) =>
    match (x) with | Integer ity => GenInteger (inject_integerType ity)
      | Floating fty => GenFloating fty end.
(* [?]: removed value specification. *)

Definition inject_type  (c : ctype )  : genType := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Void => GenVoid | Basic bty =>
      GenBasic (inject_basicType bty) | Pointer qs ty => GenPointer qs ty
      | Array ty n_opt => GenArray ty n_opt
      | Function has_proto qs_ty params b =>
      GenFunction has_proto qs_ty params b | Atomic ty => GenAtomic ty
      | Struct tag => GenStruct tag | Union tag => GenUnion tag end end.
(* [?]: removed value specification. *)

Definition inject_typeCategory   : typeCategory  -> genTypeCategory :=  
  fun (x : typeCategory ) =>
    match (x) with | LValueType qs ty isRegister =>
      GenLValueType qs ty isRegister | RValueType ty =>
      GenRValueType (inject_type ty) end.
(* [?]: removed value specification. *)

Definition annotations {a : Type}  (e : expression a)  : (list (string )*a) % type:= 
  match ( (e)) with (( AnnotatedExpression gtc annots1 _ _)) =>
    (annots1, gtc) end.
(* [?]: removed value specification. *)

Definition genTypeCategoryOf  (e : expression (genTypeCategory ))  : genTypeCategory := 
  match ( (e)) with (( AnnotatedExpression gtc _ _ _)) => gtc end.

