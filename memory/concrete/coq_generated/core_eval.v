(* Generated by Lem from ocaml_generated/core_eval.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.


Require Import utils.
Require Export utils.

Require Import core.
Require Export core.

Require Import core_run_aux.
Require Export core_run_aux.
Require Import errors.
Require Export errors.

Require Import mem.
Require Export mem.

Require Import ailTypesAux.
Require Export ailTypesAux.

Require Import loc.
Require Export loc.
Require Import symbol.
Require Export symbol.
Require Import exception_undefined.
Require Export exception_undefined.
Require Import pp.
Require Export pp.


Require Import ctype.
Require Export ctype.
Require Import core_ctype_aux.
Require Export core_ctype_aux.
Require Import core_aux.
Require Export core_aux.


Require Import exception.
Require Export exception.


Require Import nondeterminism.
Require Export nondeterminism.

(* [?]: removed value specification. *)

Definition call_function  (file1 : generic_file (unit ) (core_run_annotation )) (f_nm : generic_name (symbol.sym )) (arg_cvals : list (generic_value (symbol.sym )))  : exception.exceptM (generic_pexpr (unit ) (symbol.sym )) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "CALL_FUNCTION: "
                   (BOOM
                      (Pexpr [] tt
                         (PEcall f_nm (List.map caux.mk_value_pe arg_cvals))))
               end )) with tt =>
    exception.except_bind
      match ( f_nm) with | Sym f_a =>
        match ( (fmap_lookup_by
                   (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                      ordCompare sym1 sym2) f_a (stdlib  file1))) with
              | Some z =>
          (* callign a function from the Core standard library *)
          exception.except_return z | None =>
          match ( (fmap_lookup_by
                     (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                        ordCompare sym1 sym2) f_a (funs  file1))) with
                | Some z =>
            (* calling a user function *) exception.except_return z | None =>
            exception.fail0 (Illformed_program "calling an unknown function")
          end end | Impl f =>
        match ( (fmap_lookup_by
                   implementation.implementation_constant_compare f
                   (impl  file1))) with | Some( IFun bty params pe) =>
          exception.except_return (Fun bty params pe) | _ =>
          exception.fail0
            (Illformed_program
               ( String.append "calling an unknown impl-function: "
                   (implementation.string_of_implementation_constant f))) end
      end
      (fun (x : generic_fun_map_decl (unit ) (core_run_annotation )) =>
         match (x) with | Fun _ params body_pe =>
           if negb (beq_nat (List.length params) (List.length arg_cvals)) then
             BOOM
               ( (*^ Pp.stringFromCore_value (Vobject (OVcfunction f_nm)) *)
                 (*  TODO: clean *) String.append "CALL("
                   (String.append ") |params|= "
                      (String.append
                         (lem_string_extra.stringFromNat (List.length params))
                         (String.append " <> |args|= "
                            (lem_string_extra.stringFromNat
                               (List.length arg_cvals))))) ) else
             apply exception.except_return
               (utils.foldl2
                  (fun (acc : generic_pexpr (unit ) (symbol.sym )) (p : (symbol.sym *core_base_type ) % type) (cval : generic_value (symbol.sym )) =>
                     match ( (acc ,p ,cval) ) with
                         ( acc ,  (a,  _) ,  cval) =>
                       caux.subst_sym_pexpr a cval acc end) body_pe params
                  arg_cvals) | ProcDecl _ _ _ =>
           BOOM "Core_eval.call_function, called on a ProcDecl"
           | BuiltinDecl _ _ _ =>
           BOOM "Core_eval.call_function, called on a BuiltinDecl"
           | Proc _ _ _ _ => BOOM "Core_eval.call_function, called on a Proc"
         end) end.
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Definition pull_helper {a b : Type}  (pull : generic_pexpr (unit ) (symbol.sym ) -> generic_pexpr (unit ) (symbol.sym )) (pe_cons : list ((a*generic_pexpr (unit ) (symbol.sym )) % type) -> generic_pexpr_ (unit ) b)  (ps: list  ((a * pexpr ) % type))  : generic_pexpr_ (unit ) b:= 
  match ( List.fold_left (
  fun (acc : sum (list ((mem_common.mem_constraint (tt )*list ((a*generic_pexpr (unit ) (symbol.sym )) % type)) % type)) (list ((a*generic_pexpr (unit ) (symbol.sym )) % type))) (p : (a*generic_pexpr (unit ) (symbol.sym )) % type) =>
    match ( (acc ,p) ) with ( acc ,  (a1,  pe)) =>
      match ( pull pe) with | Pexpr _ tt( PEconstrained xs) =>
        let ys  := match ( acc) with | inr pes =>
                     [(mem_common.MC_empty, pes)] | inl ys => ys end in
      inl
        (
        List.map
          (fun (p : (((mem_common.mem_constraint (tt )*list ((a*generic_pexpr (unit ) (symbol.sym )) % type)) % type)*((mem_common.mem_constraint (tt )*list ((a*generic_pexpr (unit ) (symbol.sym )) % type)) % type)) % type) =>
             match ( (p) ) with ( ((cs1,  pes1),  (cs2,  pes2))) =>
               (mem_common.MC_conj [cs1; cs2], (@ List.app _) pes1 pes2) end
          )
          (utils.product_list
             (List.map
                (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                   match ( (p) ) with ( (cs,  pe)) => (cs, [(a1, pe)]) end)
                xs) ys) ) | pe' =>
        match ( acc) with | inr pes' => inr ((a1, pe) :: pes') | inl ys =>
          inl
            (List.map
               (fun (p : (mem_common.mem_constraint (tt )*list ((a*generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                  match ( (p) ) with ( (cs,  pes)) =>
                    (cs, ((a1, pe') :: pes)) end) ys) end end end
  ) ps (inr [])) with 
  | inl ys =>
      PEconstrained (
        List.map (fun (p : (mem_common.mem_constraint (tt )*list ((a*generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
  match ( (p) ) with ( (cs,  pes_rev)) =>
    (cs, Pexpr [] tt (pe_cons (List.rev pes_rev))) end)
      ys )
  | inr pes_rev =>
      pe_cons (List.rev pes_rev)
end.
(* [?]: removed value specification. *)

Program Fixpoint pull_constrained  (n : nat ) (g : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  match ( (n,g)) with ( n, ( Pexpr _ tt pexpr_)) =>
    let self := (fun (pe : generic_pexpr (unit ) (symbol.sym )) =>
                   pull_constrained (Coq.Init.Peano.plus n ( 1)) pe) in
  let wrap := (fun (f : generic_pexpr (unit ) (symbol.sym ) -> generic_pexpr_ (unit ) (symbol.sym )) (pe : generic_pexpr (unit ) (symbol.sym )) =>
                 match ( self pe) with | Pexpr _ tt( PEconstrained xs) =>
                   PEconstrained
                     (List.map
                        (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                           match ( (p) ) with ( (cs,  pe')) =>
                             (cs, Pexpr [] tt (f pe')) end) xs) | pe' =>
                   f pe' end) in
  let wrap_bin := (fun (f : generic_pexpr (unit ) (symbol.sym ) -> generic_pexpr (unit ) (symbol.sym ) -> generic_pexpr_ (unit ) (symbol.sym )) (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym )) =>
                     match ( (self pe1, self pe2)) with
                           | (Pexpr _ tt( PEconstrained xs1),  Pexpr _ tt( PEconstrained xs2)) =>
                       PEconstrained
                         (
                         List.map
                           (fun (p : (((mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type)*((mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                              match ( (p) ) with
                                  ( ((cs1,  pe1),  (cs2,  pe2))) =>
                                (mem_common.MC_conj [cs1; cs2], Pexpr 
                                                                [] tt
                                                                  (f pe1 pe2))
                              end ) (utils.product_list xs1 xs2) )
                       | (Pexpr _ tt( PEconstrained xs1),  pe2') =>
                       PEconstrained
                         (List.map
                            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                               match ( (p) ) with ( (cs,  pe)) =>
                                 (cs, Pexpr [] tt (f pe pe2')) end) xs1)
                       | (pe1',  Pexpr _ tt( PEconstrained xs2)) =>
                       PEconstrained
                         (List.map
                            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                               match ( (p) ) with ( (cs,  pe)) =>
                                 (cs, Pexpr [] tt (f pe1' pe)) end) xs2)
                       | (pe1',  pe2') => f pe1' pe2' end) in
  let wrap_list := (fun (f : list (generic_pexpr (unit ) (symbol.sym )) -> generic_pexpr_ (unit ) (symbol.sym )) (pes : list (generic_pexpr (unit ) (symbol.sym ))) =>
                      pull_helper self
                        (fun (xs : list ((unit *generic_pexpr (unit ) (symbol.sym )) % type)) =>
                           f (List.map (@ snd _ _) xs))
                        (List.map
                           (fun (pe : generic_pexpr (unit ) (symbol.sym )) =>
                              (tt, pe)) pes)) in
  Pexpr [] tt
    match ( pexpr_) with | PEsym _ => pexpr_ | PEimpl _ => pexpr_
      | PEval _ => pexpr_ | PEconstrained xs =>
      PEconstrained
        (
        List.fold_left
          (fun (acc : list ((mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type)) (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
             match ( (acc ,p) ) with ( acc ,  (cs,  pe)) =>
               match ( self pe) with | Pexpr _ tt( PEconstrained xs) =>
                 (@ List.app _)
                   (List.map
                      (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                         match ( (p) ) with ( (cs',  pe')) =>
                           (mem_common.MC_conj [cs; cs'], pe') end) xs) 
                 acc | pe' => (cs, pe') :: acc end end ) xs [])
      | PEundef _ _ => pexpr_ | PEerror err_str pe =>
      wrap (PEerror err_str) pe | PEctor ctor1 pes=>
      wrap_list (PEctor ctor1) pes | PEcase pe pat_pes =>
      match ( self pe) with | Pexpr annots1 tt( PEconstrained xs) =>
        PEconstrained
          (
          List.map
            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (cs,  pe)) =>
                 (cs, Pexpr annots1 tt (pull_helper self (PEcase pe) pat_pes))
               end ) xs ) | pe' => pull_helper self (PEcase pe') pat_pes end
      | PEarray_shift pe1 cty pe2=>
      wrap_bin
        (fun (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym )) =>
           PEarray_shift pe1 cty pe2) pe1 pe2 | PEmember_shift pe sym1 cid=>
      wrap
        (fun (pe : generic_pexpr (unit ) (symbol.sym )) =>
           PEmember_shift pe sym1 cid) pe | PEnot pe => wrap PEnot pe
      | PEop binop1 pe1 pe2 => wrap_bin (PEop binop1) pe1 pe2
      | PEstruct sym1 xs => pull_helper self (PEstruct sym1) xs
      | PEunion sym1 cid pe => wrap (PEunion sym1 cid) pe | PEcfunction pe =>
      wrap PEcfunction pe | PEmemberof tag_sym memb_ident pe =>
      wrap (PEmemberof tag_sym memb_ident) pe | PEcall nm pes =>
      wrap_list (PEcall nm) pes | PElet pat pe1 pe2 =>
      wrap_bin (PElet pat) pe1 pe2 | PEif pe1 pe2 pe3 =>
      (* TODO: not sure about this one! *)
    let aux := fun (x : list (generic_pexpr (unit ) (symbol.sym ))) =>
                 match (x) with | [pe1; pe2; pe3] => PEif pe1 pe2 pe3 | _ =>
                   BOOM "impossible => Core_eval" end in
    wrap_list aux [pe1;pe2;pe3] | PEis_scalar pe => wrap PEis_scalar pe
      | PEis_integer pe => wrap PEis_integer pe | PEis_signed pe =>
      wrap PEis_signed pe | PEis_unsigned pe => wrap PEis_unsigned pe
      | PEbmc_assume pe => wrap PEbmc_assume pe | PEare_compatible pe1 pe2 =>
      wrap_bin PEare_compatible pe1 pe2 end end.
(* [?]: removed value specification. *)


Definition step_eval_peop  (loc : unit ) (mem_st_opt : option (mem.mem_state ) ) (self : generic_pexpr (unit ) (symbol.sym ) -> exception.exceptM (undefined.t0 (generic_pexpr (unit ) (symbol.sym ))) (core_run_cause )) (binop1 : binop ) (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym ))  : exception.exceptM (undefined.t0 (generic_pexpr_ (unit ) (symbol.sym ))) (core_run_cause ):=  exception_undefined.exception_undef_bind
  (self pe1) (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) => exception_undefined.exception_undef_bind
  (self pe2) (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
  match ( (binop1, caux.valueFromPexpr pe1', caux.valueFromPexpr pe2')) with 
(*
        | (_, Just (Vconstrained xs1), Just (Vconstrained xs2)) ->
            EU.return (
              PEconstrained $ List.map (fun ((cs1, v1), (cs2, v2)) ->
                  (ND.concat cs1 cs2, Pexpr [] () (PEop binop (Pexpr [] () (PEval v1)) (Pexpr [] () (PEval v2))))
              ) (Utils.product_list xs1 xs2)
            )
        
        | (_, Just (Vconstrained xs1), Just v2) ->
            EU.return (
              PEconstrained $ List.map (fun (cs1, v1) ->
                  (cs1, Pexpr [] () (PEop binop (Pexpr [] () (PEval v1)) (Pexpr [] () (PEval v2))))
              ) xs1
            )
        
        | (_, Just v1, Just (Vconstrained xs2)) ->
            EU.return (
              PEconstrained $ List.map (fun (cs1, v2) ->
                  (cs1, Pexpr [] () (PEop binop (Pexpr [] () (PEval v1)) (Pexpr [] () (PEval v2))))
              ) xs2
            )
*)
        (* Ctype equality *)
        | (OpEq,  Some( Vctype ty1),  Some( Vctype ty2)) => 
            apply exception_undefined.exception_undef_return (PEval (if ctype.ctypeEqual ty1 ty2 then Vtrue else Vfalse))
        
        (* Integer equality *)
        | (OpEq,  Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
            match ( BOOM mem_st_opt ival1 ival2) with 
              | Some b =>
                  exception_undefined.exception_undef_return (PEval (if b then Vtrue else Vfalse))
              | None =>
                  (* when both outcomes are still possible *)
                  let eq_constr := mem_common.MC_eq ival1 ival2 in
(*
                  let () = Debug.print_debug 1 [] (fun () ->
                    "SYMBOLIC INT EQ ==> " ^
                    Pp.stringFromMem_iv_mem_constraint eq_constr
                  ) in
*)
                  exception_undefined.exception_undef_return (PEconstrained [ (eq_constr, Pexpr [] tt (PEval Vtrue))
                                           ; (mem_common.MC_not eq_constr, Pexpr [] tt (PEval Vfalse))] )
            end

        | (OpEq,  Some( Vobject( OVfloating fval1)),  Some( Vobject( OVfloating fval2))) =>
            exception_undefined.exception_undef_return (PEval (if BOOM fval1 fval2 then Vtrue else Vfalse))
        
        | (OpLt,  Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
            match ( BOOM mem_st_opt ival1 ival2) with 
              | Some b =>
                  exception_undefined.exception_undef_return (PEval (if b then Vtrue else Vfalse))
              | None =>
                  (* when both outcomes are still possible *)
                  let lt_constr := mem_common.MC_lt ival1 ival2 in
                  exception_undefined.exception_undef_return (PEconstrained [ (lt_constr, Pexpr [] tt (PEval Vtrue))
                                           ; (mem_common.MC_not lt_constr, Pexpr [] tt (PEval Vfalse))] )
            end

        | (OpLt,  Some( Vobject( OVfloating fval1)),  Some( Vobject( OVfloating fval2))) =>
            exception_undefined.exception_undef_return (PEval (if BOOM fval1 fval2 then Vtrue else Vfalse))
        
        | (OpLe,  Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
            match ( BOOM mem_st_opt ival1 ival2) with 
              | Some b =>
                  exception_undefined.exception_undef_return (PEval (if b then Vtrue else Vfalse))
              | None =>
                  (* when both outcomes are still possible *)
                  let le_constr := mem_common.MC_le ival1 ival2 in
                  exception_undefined.exception_undef_return (PEconstrained [ (le_constr, Pexpr [] tt (PEval Vtrue))
                                           ; (mem_common.MC_not le_constr, Pexpr [] tt (PEval Vfalse))] )
            end

        | (OpLe,  Some( Vobject( OVfloating fval1)),  Some( Vobject( OVfloating fval2))) =>
            exception_undefined.exception_undef_return (PEval (if BOOM fval1 fval2 then Vtrue else Vfalse))
        
        | (OpGe,  Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
            (* TODO CHECK *)
            match ( BOOM mem_st_opt ival2 ival1) with 
              | Some b =>
                  exception_undefined.exception_undef_return (PEval (if b then Vtrue else Vfalse))
              | None =>
                  (* when both outcomes are still possible *)
                  let ge_constr := mem_common.MC_le ival2 ival1 in
                  exception_undefined.exception_undef_return (PEconstrained [ (ge_constr, Pexpr [] tt (PEval Vtrue))
                                           ; (mem_common.MC_not ge_constr, Pexpr [] tt (PEval Vfalse))] )
            end

        | (OpGe,  Some( Vobject( OVfloating fval1)),  Some( Vobject( OVfloating fval2))) =>
            exception_undefined.exception_undef_return (PEval (if BOOM fval2 fval1 then Vtrue else Vfalse))
        
        | (OpGt,  Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
            (* TODO CHECK *)
            match ( BOOM mem_st_opt ival2 ival1) with 
              | Some b =>
                  exception_undefined.exception_undef_return (PEval (if b then Vtrue else Vfalse))
              | None =>
                  (* when both outcomes are still possible *)
                  let gt_constr := mem_common.MC_lt ival2 ival1 in
                  exception_undefined.exception_undef_return (PEconstrained [ (gt_constr, Pexpr [] tt (PEval Vtrue))
                                           ; (mem_common.MC_not gt_constr, Pexpr [] tt (PEval Vfalse))] )
            end

        | (OpGt,  Some( Vobject( OVfloating fval1)),  Some( Vobject( OVfloating fval2))) =>
            exception_undefined.exception_undef_return (PEval (if BOOM fval2 fval1 then Vtrue else Vfalse))
        
        | (_,  Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
            let iop := match ( binop1) with 
              | OpAdd   => mem_common.IntAdd
              | OpSub   => mem_common.IntSub
              | OpMul   => mem_common.IntMul
              | OpDiv   => mem_common.IntDiv
              | OpRem_t => mem_common.IntRem_t
              | OpRem_f => mem_common.IntRem_f
              | OpExp   => mem_common.IntExp
              | _ =>
                  BOOM ( String.append"Core_eval.eval_pexpr, PEop Vinteger Vinteger: " match ( binop1) with 
      | OpAdd   => "OpAdd"
      | OpSub   => "OpSub"
      | OpMul   => "OpMul"
      | OpDiv   => "OpDiv"
      | OpRem_t => "OpRem_t"
      | OpRem_f => "OpRem_f"
      | OpExp   => "OpExp"
      | OpEq    => "OpEq"
      | OpGt    => "OpGt"
      | OpLt    => "OpLt"
      | OpGe    => "OpGe"
      | OpLe    => "OpLe"
      | OpAnd   => "OpAnd"
      | OpOr    => "OpOr"
    end)
            end in
            exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM iop ival1 ival2))))

        | (_,  Some( Vobject( OVfloating fval1)),  Some( Vobject( OVfloating fval2))) =>
            let fop := match ( binop1) with 
              | OpAdd => mem_common.FloatAdd
              | OpSub => mem_common.FloatSub
              | OpMul => mem_common.FloatMul
              | OpDiv => mem_common.FloatDiv
              | _ =>
                BOOM ( String.append"Core_eval.eval_pexpr, PEop Vfloating Vfloating " match ( binop1) with 
      | OpAdd   => "OpAdd"
      | OpSub   => "OpSub"
      | OpMul   => "OpMul"
      | OpDiv   => "OpDiv"
      | OpRem_t => "OpRem_t"
      | OpRem_f => "OpRem_f"
      | OpExp   => "OpExp"
      | OpEq    => "OpEq"
      | OpGt    => "OpGt"
      | OpLt    => "OpLt"
      | OpGe    => "OpGe"
      | OpLe    => "OpLe"
      | OpAnd   => "OpAnd"
      | OpOr    => "OpOr"
    end)
            end in
            exception_undefined.exception_undef_return (PEval (Vobject (OVfloating (BOOM fop fval1 fval2))))
        
        | (OpAnd,  Some v1,  Some v2) =>
            let v1 := (*Core_aux.flatten_constrained_value*) v1 in
            let v2 := (*Core_aux.flatten_constrained_value*) v2 in
            (* TODO: factorise *)
            match ( (v1, v2)) with 
              | (Vtrue,  Vtrue) =>
                  exception_undefined.exception_undef_return (PEval Vtrue)
              | (Vtrue,  Vfalse) =>
                  exception_undefined.exception_undef_return (PEval Vfalse)
              | (Vfalse,  Vtrue) =>
                  exception_undefined.exception_undef_return (PEval Vfalse)
              | (Vfalse,  Vfalse) =>
                  exception_undefined.exception_undef_return (PEval Vfalse)
(*
              | (Vtrue, Vconstrained xs) ->
                  (* true /\ constrained v --> constrained v *)
                  EU.return (PEval (Vconstrained (List.map (fun (consts, v) -> (consts, v)) xs)))
              | (Vfalse, Vconstrained xs) ->
                  (* false /\ constrained v --> false *)
                  EU.return (PEval Vfalse)
              | (Vconstrained xs, Vtrue) ->
                  (* constrained v /\ true --> constrained v *)
                  EU.return (PEval (Vconstrained (List.map (fun (consts, v) -> (consts, v)) xs)))
              | (Vconstrained xs, Vfalse) ->
                  (* constrained v /\ false --> false *)
                  EU.return (PEval Vfalse)
              | (Vconstrained xs1, Vconstrained xs2) ->
                  EU.return (
                    PEval (
                      Vconstrained $ List.map (fun ((cs1, v1'), (cs2, v2')) ->
                        (ND.concat cs1 cs1, match (v1', v2') with
                          | (Vtrue,  Vtrue)  -> Vtrue
                          | (Vtrue,  Vfalse) -> Vfalse
                          | (Vfalse, Vtrue)  -> Vfalse
                          | (Vfalse, Vfalse) -> Vfalse
                          | _ ->
                              (* this case is not possible thanks to the calls to [flatten_constrained_value] *)
                              error "Core_eval.step_eval_peop, OpAnd"
                         end)
                      ) (Utils.product_list xs1 xs2)
                    )
                  )
*)

              | _ => 
                  apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"["  (String.append("")  (String.append"] the two operands of /\ should be booleans ==> "  (String.append(BOOM v1)  (String.append" <-> " (BOOM v2)))))))
            end
        
        | (OpOr,  Some v1,  Some v2) =>
            match ( (v1, v2)) with 
              | (Vtrue,  Vtrue) => 
                  apply exception_undefined.exception_undef_return (PEval Vtrue)
              | (Vtrue,  Vfalse) => 
                  apply exception_undefined.exception_undef_return (PEval Vtrue)
              | (Vfalse,  Vtrue) => 
                  apply exception_undefined.exception_undef_return (PEval Vtrue)
              | (Vfalse,  Vfalse) => 
                  apply exception_undefined.exception_undef_return (PEval Vfalse)
              | _ => 
                  apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"["  (String.append("") "] the two operands of \/ should be booleans")))
            end
        
        | (_,  Some _,  Some _) => 
            apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"["  (String.append("")  (String.append"] ill-typed PEop ==> "
                                         (BOOM (caux.mk_op_pe binop1 pe1 pe2))))))
        | _ => 
(*
            let () = Debug.print_debug 1 [] (fun () ->
              Pp.stringFromCore_pexpr (Pexpr [] () (PEop binop pe1' pe2'))
            ) in
*)
            apply exception_undefined.exception_undef_return (PEop binop1 pe1' pe2')
      end)).
(* [?]: removed value specification. *)

Program Fixpoint step_eval_pexpr  (n : nat ) (loc : unit ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (env1 : list (fmap (symbol.sym ) (generic_value (symbol.sym )))) (mem_st_opt : option (mem.mem_state ) ) (file1 : generic_file (unit ) (core_run_annotation )) (hasConstrained : bool ) (pexpr1 : generic_pexpr (unit ) (symbol.sym ))  : exception.exceptM (undefined.t0 (generic_pexpr (unit ) (symbol.sym ))) (core_run_cause ):= 
  match ( pexpr1) with  Pexpr _ tt pexpr_  =>
  let strip1 := (fun (g : generic_pexpr (unit ) (symbol.sym )) =>
  match ( (g) ) with (( Pexpr _ _ pe_)) => pe_ end) in
  let self := (fun (pe : generic_pexpr (unit ) (symbol.sym )) =>
    step_eval_pexpr (Coq.Init.Peano.plus n( 1)) loc core_extern env1 mem_st_opt file1 (*hasConstrained *)false pe) in exception_undefined.exception_undef_fmap
  (Pexpr [] tt) match ( pexpr_) with 

(* NEW pull_constrained *)
    | PEconstrained xs =>
        exception_undefined.exception_undef_return pexpr_
(*
        if hasConstrained then
          let (cs, pe') = List.unzip xs in
          match Caux.valueFromPexprs pe' with
            | Just cvals ->
(*
                EU.return $ PEconstrained (List.zip cs (List.map Caux.mk_value_pe cvals))
*)
                error ("EU.return $ PEval (Vconstrained (List.zip cs cvals))\n cvals= " ^
                       Pp.stringFromCore_value (Vtuple cvals))
            | Nothing ->
                EU.return $ PEconstrained (List.zip cs pe')
          end
        else
          error ("step_eval_pexpr, hasConstrained = False  ==>  " ^
                 Pp.stringFromCore_pexpr pexpr)
*)
    | PEsym sym1 =>
        let sym1 := match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) sym1 core_extern)) with 
          | Some sym1 => sym1
          | None => sym1
        end in
        match ( core_aux.lookup_env sym1 env1) with 
          | None =>
              (* NOTE: check if it is a procedure pointer *)
              match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) sym1(funs  file1))) with 
                | Some( Proc _ _ _ _) =>
                    exception_undefined.exception_undef_return (PEval (Vobject (OVpointer (BOOM (ctype.Ctype [] ctype.Void)))))
                | _ =>
                    exception_undefined.exception_undef_fail (Unresolved_symbol loc sym1)
              end
          | Some cval =>
              exception_undefined.exception_undef_return (PEval cval)
        end
    | PEimpl iCst =>
        match ( (fmap_lookup_by implementation.implementation_constant_compare iCst(impl  file1))) with 
          | Some( Def _ pe) =>
              exception_undefined.exception_undef_return (strip1 pe)
          | _ =>
              exception_undefined.exception_undef_fail Unknown_impl
        end
    | PEval cval =>
        exception_undefined.exception_undef_return pexpr_
    | PEundef loc ub =>
        exception.except_return (undefined.undef loc [ub])
    | PEerror str debug_pe => 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 2) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "PEerror ==> " (BOOM debug_pe) end)) with
      tt => exception.except_return (undefined.error loc str) end
    | PEctor ctor1 pes => exception_undefined.exception_undef_bind
        (exception_undefined.exception_undef_mapM self pes) (fun (pes' : list (pexpr )) =>
        match ( (ctor1, caux.valueFromPexprs pes')) with 
          | (Cnil tt,  Some []) => 
  match ( fun (_: list domain) (_: unit -> string) := tt
            [debug.DB_core_dynamics]
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "TODO(hack): Core_Eval, PEctor Cnil ==> producing a [unit]"
               end)) with tt =>
    apply exception_undefined.exception_undef_return
      (PEval (Vlist BTy_unit (*TODO this is wrong*) [])) end
          | (Ccons,  Some [cval1;  Vlist bTy' cvals]) => 
                apply exception_undefined.exception_undef_return (PEval (Vlist bTy' (cval1 :: cvals)))
          | (Ctuple,  Some cvals) => 
              apply exception_undefined.exception_undef_return (PEval (Vtuple cvals))
          | (Carray,  Some cvals) =>
              (* By typing all the [cvals] must be loaded_values *)
              match ( List.fold_right (fun (cval : generic_value (symbol.sym )) (acc : option (list (generic_loaded_value (symbol.sym ))) ) =>
                match ( (cval, acc)) with 
                  | (Vloaded lval,  Some lvals) =>
                      Some (lval :: lvals)
                  | _ =>
                      None
                end
              ) (Some []) cvals) with 
                | None => 
                    apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEctor, Carray: one of the operands didn't evaluate to a loaded value ==> "
                                                 (stringFromList BOOM cvals)))
                | Some lvals =>
                    exception_undefined.exception_undef_return (PEval (Vobject (OVarray lvals)))
              end
          | (Civmax,  Some [Vctype ty]) =>
              match ( ctype.unatomic_ ty) with 
                |( ctype.Basic( ctype.Integer ity)) => 
                    apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity))))
                | _ =>
                    BOOM ( String.append"Core_eval ivmax"
                           ( (* DEBUG *)BOOM (core.Expr [] (core.Epure (core.Pexpr [] tt (core.PEval (Vctype ty)))) :  core.expr  unit ))) (* DEBUG *)
              end
          | (Civmin,  Some [Vctype ty]) =>
              match ( ctype.unatomic_ ty) with 
                |( ctype.Basic( ctype.Integer ity)) => 
                    apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity))))
                | _ =>
                    BOOM ( String.append"Core_eval ivmin ["  (String.append("")  (String.append"] ==> "
                               ( (* DEBUG *)BOOM (core.Expr [] (core.Epure (core.Pexpr [] tt (core.PEval (Vctype ty)))) :  core.expr  unit ))))) (* DEBUG *)
              end
          | (Civsizeof,  Some [Vctype ty]) => 
              apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ty))))
          | (Civalignof,  Some [Vctype ty]) => 
              apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ty))))
          | (CivCOMPL,  Some [Vctype ty;  Vobject( OVinteger ival)]) =>
              match ( ctype.unatomic_ ty) with 
                |( ctype.Basic( ctype.Integer ity)) => 
                    apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity ival))))
                | _ =>
                    BOOM "Core_Eval ivCOMPL, not (is_integer ty)"
              end
          | (CivAND,  Some [Vctype ty;  Vobject( OVinteger ival1);  Vobject( OVinteger ival2)]) =>
              match ( ctype.unatomic_ ty) with 
                |( ctype.Basic( ctype.Integer ity)) => 
                    apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity ival1 ival2))))
                | _ =>
                    BOOM "Core_Eval ivAND, not (is_integer ty)"
              end
          | (CivOR,  Some [Vctype ty;  Vobject( OVinteger ival1);  Vobject( OVinteger ival2)]) =>
              match ( ctype.unatomic_ ty) with 
                |( ctype.Basic( ctype.Integer ity)) => 
                    apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity ival1 ival2))))
                | _ =>
                    BOOM "Core_Eval ivOR, not (is_integer ty)"
              end
          | (CivXOR,  Some [Vctype ty;  Vobject( OVinteger ival1);  Vobject( OVinteger ival2)]) =>
              match ( ctype.unatomic_ ty) with 
                |( ctype.Basic( ctype.Integer ity)) => 
                    apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity ival1 ival2))))
                | _ =>
                    BOOM "Core_Eval ivXOR, not (is_integer ty)"
              end
          | (Cspecified,  Some [Vobject oval]) => 
              apply exception_undefined.exception_undef_return (PEval (Vloaded (LVspecified oval)))
          | (Cunspecified,  Some [Vctype ty]) => 
              apply exception_undefined.exception_undef_return (PEval (Vloaded (LVunspecified ty)))

          | (Cfvfromint,  Some [Vobject( OVinteger ival)]) => 
              apply exception_undefined.exception_undef_return (PEval (Vobject (OVfloating (BOOM ival))))
          | (Civfromfloat,  Some [Vctype( ctype.Ctype []( ctype.Basic( ctype.Integer ity)));  Vobject( OVfloating fval)]) => 
              apply exception_undefined.exception_undef_return (PEval (Vobject (OVinteger (BOOM ity fval))))
          
          | (_,  Some cvals) =>
              if false (*List.any Caux.isConstrainedValue cvals*) then
                (* if some operands of the ctor are constrained, the following pulls the PEconstrained operator
                   outside of the PEctor *)
                (* TODO: check this code *)
                let xs :=
                  List.fold_left (fun (acc : list ((mem_common.mem_constraint (tt )*list (generic_pexpr (unit ) (symbol.sym ))) % type)) (cval : generic_value (symbol.sym )) =>
(*
                    match cval with
                      | Vconstrained xs ->
                          List.map (fun ((xs_cs, xsCval), (acc_cs, accPes)) ->
                            (ND.concat xs_cs acc_cs, Pexpr [] () (PEval xsCval) :: accPes)
                          ) (Utils.product_list xs acc)
                      | _ ->
                          List.map (fun (cs, pes) -> (cs, Pexpr [] () (PEval cval) :: pes)) acc
                    end
*)
                    List.map (
  fun (p : (mem_common.mem_constraint (tt )*list (generic_pexpr (unit ) (symbol.sym ))) % type) =>
    match ( (p) ) with ( (cs,  pes)) =>
      (cs, (Pexpr [] tt (PEval cval) :: pes)) end) acc
                  ) cvals [(mem_common.MC_empty, [])] in
                exception_undefined.exception_undef_return (
                  PEconstrained (
                    List.map (
  fun (p : (mem_common.mem_constraint (tt )*list (generic_pexpr (unit ) (symbol.sym ))) % type) =>
    match ( (p) ) with ( (cs,  pes')) =>
      (cs, Pexpr [] tt (PEctor ctor1 pes')) end) xs
                  )
                )
              else 
              
              apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEctor: one of the operands was ill-typed ==> " 
                                           (String.append(BOOM pexpr1)  (String.append" <====> "
                                           (stringFromList BOOM cvals)))))
          | (_,  None) => 
              apply exception_undefined.exception_undef_return (PEctor ctor1 pes')
        end)
    | PEcase pe pat_pes => exception_undefined.exception_undef_bind
        (self pe) (fun (x : generic_pexpr (unit ) (symbol.sym )) =>
    match (x) with
        (*
          | Pexpr _ _ (PEval (Vconstrained xs)) ->
              EU.return (
                PEconstrained (
                  List.map (fun (cs, cval) ->
                    (cs, Caux.mk_case_pe (Caux.mk_value_pe cval) pat_pes)
                  ) xs
                )
              )
*)
      | Pexpr _ _( PEval cval) =>
      match ( caux.select_case caux.subst_sym_pexpr cval pat_pes) with
            | Some pe'' =>
        exception_undefined.exception_undef_return (strip1 pe'') | None =>
        BOOM
          ( String.append "PEcase, mismatched ==> ["
              (String.append ("") (String.append "]" (BOOM cval)))) end
      | pe' =>
      exception_undefined.exception_undef_return (PEcase pe' pat_pes) end)
    | PEarray_shift pe1 ty pe2 => exception_undefined.exception_undef_bind
        (self pe1) (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) => exception_undefined.exception_undef_bind
        (self pe2) (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( (caux.valueFromPexpr pe1', caux.valueFromPexpr pe2')) with 
          | (Some( Vobject( OVpointer ptr_val)),  Some( Vobject( OVinteger ival))) => 
              apply exception_undefined.exception_undef_return (PEval (Vobject (OVpointer (BOOM ptr_val ty ival))))
          | (Some _,  Some _) => 
              apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEarray_shift: type error ==> "
                                           (BOOM (Pexpr [] tt (PEarray_shift pe1' ty pe2')))))
          | _ => 
              apply exception_undefined.exception_undef_return (PEarray_shift pe1' ty pe2')
        end))
    | PEmember_shift pe tag_sym member_ident => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vobject( OVpointer ptr_val)) => 
              apply exception_undefined.exception_undef_return (PEval (Vobject (OVpointer (BOOM ptr_val tag_sym member_ident))))
          | Some _ => 
              apply exception_undefined.exception_undef_fail (Illformed_program "PEmember_shift")
          | _ => 
              apply exception_undefined.exception_undef_return (PEmember_shift pe' tag_sym member_ident)
        end)
    | PEnot( Pexpr annot1 pe_bTy _ as  pe) => exception_undefined.exception_undef_bind
        (self pe) (fun (g : generic_pexpr (unit ) (symbol.sym )) =>
    match ( (g) ) with ( Pexpr annot1 pe_bTy pe_' as pe') =>
      match ( pe_') with
          (*
          | PEval (Vconstrained xs) ->
              (PEval -| Vconstrained) <$> EU.mapM function
                | (cs, Vtrue) ->
                    EU.return (cs, Vfalse)
                | (cs, Vfalse) ->
                    EU.return (cs, Vtrue)
                | _ ->
                    EU.fail (Illformed_program "PEnot: operand should be a boolean")
              end xs
*)
        | PEval Vtrue =>
        exception_undefined.exception_undef_return (PEval Vfalse)
        | PEval Vfalse =>
        exception_undefined.exception_undef_return (PEval Vtrue) | PEval _ =>
        exception_undefined.exception_undef_fail
          (Illformed_program "PEnot: operand should be a boolean") | _ =>
        exception_undefined.exception_undef_return (PEnot pe') end end)
    | PEop binop1 pe1 pe2 =>
       step_eval_peop loc mem_st_opt self binop1 pe1 pe2
    | PEstruct tag_sym ident_pes => 
  match ( lem_list.unzip ident_pes) with (idents,  pes) =>
    exception_undefined.exception_undef_bind
      (exception_undefined.exception_undef_mapM self pes)
      (fun (pes' : list (pexpr )) =>
         match ( caux.valueFromPexprs pes') with | Some cvals =>
           let xs := List.map
                       (fun (p : (cabs.cabs_identifier *generic_value (symbol.sym )) % type) =>
                          match ( (p) ) with ( (memb_ident,  cval)) =>
                            match ( apply
                                      (fromJust "Core_eval, PEstruct 1,1")
                                      (fmap_lookup_by
                                         (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                            ordCompare sym1 sym2) tag_sym
                                         (tagDefs  file1))) with
                                  | ctype.StructDef membrs =>
                              match ( fromJust "Core_eval, PEstruct 1"
                                        ((lookupBy
                                            (fun (ident1 : cabs.cabs_identifier ) (ident2 : cabs.cabs_identifier )=>
                                               match ( ident1) with
                                                   ( cabs.CabsIdentifier _ str1) =>
                                                 match ( ident2) with
                                                     ( cabs.CabsIdentifier _ str2) =>
                                                   (string_equal str1 str2)
                                                 end end) memb_ident 
                                          membrs))) with (_,  memb_ty) =>
                                let mval := fromJust
                                              ( String.append
                                                  "Core_Eval, PEstruct 2, memb_ty: "
                                                  (String.append
                                                     (BOOM memb_ty)
                                                     (String.append
                                                        ", cval: "
                                                        (BOOM cval))))
                                              (caux.memValueFromValue 
                                               memb_ty cval) in
                              (memb_ident, memb_ty, mval) end
                              | ctype.UnionDef _ =>
                              BOOM
                                "Core_eval.step_eval_pexpr, PEstruct found a UnionDef"
                            end end ) (lem_list.zip idents cvals) in
         exception_undefined.exception_undef_return
           (PEval (Vobject (OVstruct tag_sym xs)))
         (*
KKK:              EU.return (PEval (Vloaded (LVspecified (OVstruct tag_sym xs))))
*)
           | None =>
           exception_undefined.exception_undef_return
             (PEstruct tag_sym (lem_list.zip idents pes')) end) end
    | PEunion tag_sym memb_ident pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some cval =>
              match (  apply(fromJust "Core_eval, PEunion 1,1") (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym(tagDefs  file1))) with 
                | ctype.UnionDef membrs => 
  match ( fromJust "Core_eval, PEunion 1"
            ((lookupBy
                (fun (ident1 : cabs.cabs_identifier ) (ident2 : cabs.cabs_identifier )=>
                   match ( ident1) with ( cabs.CabsIdentifier _ str1) =>
                     match ( ident2) with ( cabs.CabsIdentifier _ str2) =>
                       (string_equal str1 str2) end end) memb_ident membrs))) with
      (_,  memb_ty) =>
    let mval := fromJust "Core_Eval, PEunion 2"
                  (caux.memValueFromValue memb_ty cval) in
  exception_undefined.exception_undef_return
    (PEval (Vobject (OVunion tag_sym memb_ident mval))) end
                | ctype.StructDef _ =>
                      BOOM "Core_eval.step_eval_pexpr, PEunion found a StructDef"
                end
          | None =>
              exception_undefined.exception_undef_return (PEunion tag_sym memb_ident pe')
        end)
    | PEcfunction pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vloaded( LVspecified( OVpointer pv))) =>
              let case_funptrval := (
  fun (sym1 : symbol.sym ) =>
    match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 3) 
            []
              (fun (u : unit ) =>
                 match ( (u) ) with ( tt) =>
                   String.append "function pointer: "
                     match ( sym1) with symbol.Symbol0 d n str_opt =>
                       String.append "Symbol"
                         (stringFromPair lem_string_extra.stringFromNat
                            (fun (x_opt : option (string ) )=>
                               stringFromMaybe
                                 (fun (s : string )=>
                                    String.append """" (String.append s """"))
                                 x_opt) (n, str_opt)) end end)) with tt =>
      match ( (fmap_lookup_by
                 (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                    ordCompare sym1 sym2) sym1 (funinfo  file1))) with
            | Some (ret,  params,  is_variadic,  has_proto) =>
        match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                ( 3) []
                  (fun (u : unit ) =>
                     match ( (u) ) with ( tt) =>
                       String.append "function pointer (lookup): "
                         match ( sym1) with symbol.Symbol0 d n str_opt =>
                           String.append "Symbol"
                             (stringFromPair lem_string_extra.stringFromNat
                                (fun (x_opt : option (string ) )=>
                                   stringFromMaybe
                                     (fun (s : string )=>
                                        String.append """"
                                          (String.append s """")) x_opt)
                                (n, str_opt)) end end)) with tt =>
          exception_undefined.exception_undef_return
            (PEval
               (Vtuple
                  [Vctype ret;
                  Vlist BTy_ctype
                    (List.map
                       (fun (p : (option (symbol.sym ) *ctype.ctype ) % type) =>
                          match ( (p) ) with ( (_,  ty)) => Vctype ty end)
                       params); (if is_variadic then Vtrue else Vfalse); (
                  if has_proto then Vtrue else Vfalse) ] )) end | _ =>
        apply exception_undefined.exception_undef_fail
          (Illformed_program
             ( String.append ("")
                 (String.append ": '"
                    (String.append
                       match ( sym1) with symbol.Symbol0 d n str_opt =>
                         String.append "Symbol"
                           (stringFromPair lem_string_extra.stringFromNat
                              (fun (x_opt : option (string ) )=>
                                 stringFromMaybe
                                   (fun (s : string )=>
                                      String.append """"
                                        (String.append s """")) x_opt)
                              (n, str_opt)) end
                       "' does not point to a function (cfunction)")))) end
    end) in
              BOOM pv
                (fun ( _ : ctype.ctype ) =>  apply exception_undefined.exception_undef_fail (Illformed_program "null function pointer"))
                 case_funptrval
                (fun ( _ : option (Z ) ) (addr : Z ) =>
                (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
                  match ( mem_st_opt) with 
                  | Some mem_st =>
                      match ( BOOM mem_st pv) with 
                      | Some sym1 =>
                          case_funptrval sym1
                      | None => 
                          apply exception_undefined.exception_undef_fail (Illformed_program ( String.append("")  (String.append": "  (String.append(lem_string_extra.stringFromInteger addr) " does not point to a function"))))
                      end
                  | None => 
                      apply exception_undefined.exception_undef_fail (Illformed_program ( String.append("")  (String.append": "  (String.append(lem_string_extra.stringFromInteger addr) " does not point to a function"))))
                  end)
                (fun ( _ : unit ) =>  apply exception_undefined.exception_undef_fail (Illformed_program "function pointer has an unspecified value"))
          | Some( Vloaded( LVunspecified _)) => 
              apply exception_undefined.exception_undef_fail (Illformed_program "function pointer has an unspecified value")
          | _ =>
            BOOM "Core_eval.step_eval_pexpr, PEcfunction expects a pointer"
        end)
    | PEmemberof tag_sym memb_ident pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vobject( OVstruct tag_sym' xs)) =>
              if negb (match ( (tag_sym, tag_sym')) with 
    | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end) then 
                apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEmemberof(struct) ==> mismatched tags: "  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end  (String.append" vs " 
  match ( tag_sym') with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end))))
              else match ( (lookupBy (
  fun (ident1 : cabs.cabs_identifier ) (ident2 : cabs.cabs_identifier )=>
    match ( ident1) with ( cabs.CabsIdentifier _ str1) =>
      match ( ident2) with ( cabs.CabsIdentifier _ str2) =>
        (string_equal str1 str2) end end) memb_ident (List.map (
  fun (p : (cabs.cabs_identifier *ctype.ctype *tt ) % type) =>
    match ( (p) ) with ( (a, _, b)) => (a,b) end) xs))) with 
                | None => 
                    apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEmemberof ==> invalid member: " 
  match ( memb_ident) with cabs.CabsIdentifier _ str => str end))
                | Some mval =>
                    exception_undefined.exception_undef_return (PEval ((@ snd _ _) (caux.valueFromMemValue mval)))
              end
          | Some( Vobject( OVunion tag_sym' memb_ident' mval)) =>
              if negb (match ( (tag_sym, tag_sym')) with 
    | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end) then 
                apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEmemberof(union) ==> mismatched tags: "  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end  (String.append" vs " 
  match ( tag_sym') with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end))))
              else if 
  match ( memb_ident) with ( cabs.CabsIdentifier _ str1) =>
    match ( memb_ident') with ( cabs.CabsIdentifier _ str2) =>
      negb ((string_equal str1 str2)) end end then
                BOOM "TODO: evaluation of PEmemberof => union puning"
              else
                exception_undefined.exception_undef_return (PEval ((@ snd _ _) (caux.valueFromMemValue mval)))
          | Some cval => 
              apply exception_undefined.exception_undef_fail (Illformed_program ( String.append"PEmemberof ==> " (BOOM cval)))
          | None =>
              exception_undefined.exception_undef_return (PEmemberof tag_sym memb_ident pe')
        end)
    | PEcall nm pes => exception_undefined.exception_undef_bind
        (exception_undefined.exception_undef_mapM self pes) (fun (pes' : list (pexpr )) =>
        match ( caux.valueFromPexprs pes') with 
          | Some cvals => exception_undefined.exception_undef_bind
              (
              (* We do not immediately call eval on the result of call_function,
                 as that could lead to non-termination. *)exception.except_bind (call_function file1 nm cvals) (
  fun (g : generic_pexpr (unit ) (symbol.sym )) =>
    match ( (g) ) with (( Pexpr _ _ pe_)) =>
      (* TODO: maybe annyoing to have stripping if we want a proof of type preservation? *)
      exception_undefined.exception_undef_return pe_ end)) (fun (pe_' : generic_pexpr_ (unit ) (symbol.sym )) =>
  (* TODO: check KKK *)
  match ( pull_constrained ( 0) (Pexpr [] tt pe_')) with
      ( Pexpr _ _ pe_'') =>
    match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
            []
              (fun (u : unit ) =>
                 match ( (u) ) with ( tt) =>
                   String.append "PEcall ===> " (BOOM (Pexpr [] tt pe_''))
                 end )) with tt =>
      exception_undefined.exception_undef_return pe_'' end end)
(* TODO OLD CONCUR
              if List.all Core_aux.is_concrete cvals then
                (* We do not immediately call eval on the result of call_function,
                   as that could lead to non-termination. *)
                Exception.bind (call_function file nm cvals)
                  EU.return
              else
                let symb_nm = match nm with
                  | Sym f -> Symbolic.SYMBfsym f
                  | Impl i -> Symbolic.SYMBimpl i
                end in
                EU.return $ PEval (Vobject (OVsymbolic (Symbolic.make_call symb_nm (List.map symbolify cvals))))
*)
          | None =>
              exception_undefined.exception_undef_return (PEcall nm pes')
        end)
    | PElet pat pe1 pe2 => exception_undefined.exception_undef_bind
        (self pe1) (fun (x : generic_pexpr (unit ) (symbol.sym )) =>
    match (x) with | Pexpr _ _( PEval cval) =>
      match ( caux.select_case caux.subst_sym_pexpr cval [(pat, pe2)]) with
            | None =>
        apply exception_undefined.exception_undef_fail
          (Illformed_program "PElet: the pattern didn't match pe1")
        | Some pe' =>
        apply exception_undefined.exception_undef_return (strip1 pe') end
      | pe1' =>
      apply exception_undefined.exception_undef_return (PElet pat pe1' pe2)
    end)
    | PEif pe1 pe2 pe3 => 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "Core_eval ==> PEif (_) ==> " (BOOM pexpr1)
               end )) with tt =>
    exception_undefined.exception_undef_bind (self pe1)
      (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
         match ( caux.valueFromPexpr pe1') with | Some Vtrue =>
           exception_undefined.exception_undef_fmap strip1 (self pe2)
           | Some Vfalse =>
           exception_undefined.exception_undef_fmap strip1 (self pe3)
         (*
          | (Just (Vconstrained xs)) ->
              EU.return $ PEconstrained (
                List.map (fun (cs, v) ->
                  (cs, match v with
                    | Vtrue  -> pe2
                    | Vfalse -> pe3
                    | _ ->
                        (* this Core type-error would have been caught during the evaluation of the pe1 *)
                        error "Core_eval.step_eval_pexpr, PEif"
                  end)
                ) xs
              )
*)
         (*
    | PEif (Pexpr _ _ (PEconstrained xs)) pe2 pe3 ->
        EU.return $ PEconstrained (
          List.map (fun (cs, pe) ->
            (cs, Caux.mk_if_pe pe pe2 pe3)
          ) xs
        )
*)
           | Some cval =>
           apply exception_undefined.exception_undef_fail
             (Illformed_program
                ( String.append
                    "PEif: first operand should be a boolean ==> "
                    (BOOM cval))) | None =>
           apply exception_undefined.exception_undef_return
             (PEif pe1' pe2 pe3) end) end
    | PEis_scalar pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vctype ty) => 
              apply exception_undefined.exception_undef_return (PEval (if ailTypesAux.is_scalar ty then Vtrue else Vfalse))
          | Some _ => 
              apply exception_undefined.exception_undef_fail (Illformed_program "PEis_scalar: the operand should be a ctype")
          | None => 
              apply exception_undefined.exception_undef_return (PEis_scalar pe')
        end)
    | PEis_integer pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vctype ty) => 
              apply exception_undefined.exception_undef_return (PEval (if ailTypesAux.is_integer ty then Vtrue else Vfalse))
          | Some _ => 
              apply exception_undefined.exception_undef_fail (Illformed_program "PEis_integer: the operand should be a ctype")
          | None => 
              apply exception_undefined.exception_undef_return (PEis_scalar pe')
        end)
    | PEis_signed pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vctype ty) => 
              apply exception_undefined.exception_undef_return (PEval (if ailTypesAux.is_signed_integer_type ty then Vtrue else Vfalse))
          | Some _ => 
              apply exception_undefined.exception_undef_fail (Illformed_program "PEis_signed: the operand should be a ctype")
          | None => 
              apply exception_undefined.exception_undef_return (PEis_scalar pe')
        end)
    | PEis_unsigned pe => exception_undefined.exception_undef_bind
        (self pe) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
        match ( caux.valueFromPexpr pe') with 
          | Some( Vctype ty) => 
              apply exception_undefined.exception_undef_return (PEval (if ailTypesAux.is_unsigned_integer_type ty then Vtrue else Vfalse))
          | Some _ => 
              apply exception_undefined.exception_undef_fail (Illformed_program "PEis_unsigned: the operand should be a ctype")
          | None => 
              apply exception_undefined.exception_undef_return (PEis_scalar pe')
        end)
    | PEbmc_assume pe => 
      apply exception_undefined.exception_undef_fail (Illformed_program "PEbmc_assume: __bmc_assume is for model checking only")
    | PEare_compatible pe1 pe2 => exception_undefined.exception_undef_bind
        (self pe1) (fun (pe1 : generic_pexpr (unit ) (symbol.sym )) => exception_undefined.exception_undef_bind
        (self pe2) (fun (pe2 : generic_pexpr (unit ) (symbol.sym )) =>
        match ( (caux.valueFromPexpr pe1, caux.valueFromPexpr pe2)) with 
          | (Some( Vctype ty1),  Some( Vctype ty2)) =>
              let are_compatible2 :=
                ailTypesAux.are_compatible
                  (ctype.no_qualifiers, ty1)
                  (ctype.no_qualifiers, ty2) in 
              apply exception_undefined.exception_undef_return (PEval (if are_compatible2 then Vtrue else Vfalse))
          | (_,  _) => 
              apply exception_undefined.exception_undef_fail (Illformed_program "PEare_compatible: the operands should be ctypes")
        end))
  end
  end.
(* [?]: removed value specification. *)

Program Fixpoint eval_pexpr_aux2  (loc : unit ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (env1 : list (fmap (symbol.sym ) (value0 ))) (mem_st_opt : option (mem.mem_state ) ) (file1 : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : exception.exceptM (undefined.t0 (sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym )))) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "ENTERING Core_eval.eval_pexpr_aux2 ==> "
                   (BOOM pe) end )) with tt =>
    match ( let pulled := pull_constrained ( 0) pe in
    match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
            []
              (fun (u : unit ) =>
                 match ( (u) ) with ( tt) =>
                   String.append "pulled ==> " (BOOM pulled) end )) with
        tt => pulled end) with
          | (Pexpr _ tt( PEconstrained _)) as pulled_pe =>
      exception_undefined.exception_undef_return (inl pulled_pe)
      | pulled_pe =>
      exception_undefined.exception_undef_bind
        (step_eval_pexpr ( 0) loc core_extern env1 mem_st_opt file1 false
           pulled_pe)
        (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
           match ( caux.valueFromPexpr pe') with | Some cval =>
             exception_undefined.exception_undef_return (inr cval) | None =>
             eval_pexpr_aux2 loc core_extern env1 mem_st_opt file1 pe' end)
    end end.
(* [?]: removed value specification. *)

Program Fixpoint eval_pexpr_aux_broken  (loc : unit ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (env1 : list (fmap (symbol.sym ) (value0 ))) (mem_st_opt : option (mem.mem_state ) ) (file1 : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : exception.exceptM (undefined.t0 (generic_value (symbol.sym ))) (core_run_cause ):=  exception_undefined.exception_undef_bind
  (step_eval_pexpr( 0) loc core_extern env1 mem_st_opt file1 false (
  match (fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
         [] (fun (u : unit ) => match ( (u) ) with ( tt) => "BOOM" end)) with
      tt=> pe end)) (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
  match ( caux.valueFromPexpr pe') with 
    | Some cval =>
        exception_undefined.exception_undef_return cval
    | None =>
        eval_pexpr_aux_broken loc core_extern env1 mem_st_opt file1 pe'
  end).
(* [?]: removed value specification. *)

Definition eval_pexpr  (loc : unit ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (env1 : list (fmap (symbol.sym ) (value0 ))) (mem_st_opt : option (mem.mem_state ) ) (file1 : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : sum ((unit *cause ) % type) (undefined.t0 (value0 )):= 
  match ( eval_pexpr_aux_broken loc core_extern env1 mem_st_opt file1 pe) with 
    | exception.Result z =>
        inr z
    | exception.Exception err =>
        inl (loc, errors.CORE_RUN err)
  end.
