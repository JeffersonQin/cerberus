(* Generated by Lem from ocaml_generated/mem_common.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(* Concrete types and functions common to all memory layout models *)
Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import loc.
Require Export loc.

Require Import undefined.
Require Export undefined.


Require Import nondeterminism.
Require Export nondeterminism.


Definition thread_id : Type :=  nat .
Definition thread_id_default: thread_id  := nat_default.

Inductive access_kind : Type := 
  | LoadAccess: access_kind 
  | StoreAccess: access_kind .
Definition access_kind_default: access_kind  := LoadAccess.

Inductive access_error : Type := 
  | NullPtr: access_error 
  | FunctionPtr: access_error 
  | DeadPtr: access_error 
  | OutOfBoundPtr: access_error 
  | NoProvPtr: access_error .
Definition access_error_default: access_error  := NullPtr.


Definition stringFromAccess_error   : access_error  -> string :=  
  fun (x : access_error ) =>
    match (x) with | NullPtr => "NullPtr" | FunctionPtr => "FunctionPtr"
      | DeadPtr => "DeadPtr" | OutOfBoundPtr => "OutOfBoundPtr"
      | NoProvPtr => "NoProvPtr" end.

Inductive free_error : Type := 
  | Free_static_allocation: free_error 
  | Free_dead_allocation: free_error 
  | Free_out_of_bound: free_error .
Definition free_error_default: free_error  := Free_static_allocation.

Definition stringFromFree_error   : free_error  -> string :=  
  fun (x : free_error ) =>
    match (x) with | Free_static_allocation => "Free_static_allocation"
      | Free_dead_allocation => "Free_dead_allocation" | Free_out_of_bound =>
      "Free_out_of_bound" end.

Inductive mem_error : Type := 
  | MerrOutsideLifetime:  string  -> mem_error  (* mem_read_request *)
  | MerrInternal:  string  -> mem_error 
  | MerrOther:  string  -> mem_error 
  
  | MerrPtrdiff: mem_error 
  | MerrAccess:  unit  ->  access_kind  ->  access_error  -> mem_error 
  | MerrWriteOnReadOnly:  unit  -> mem_error 
  
  | MerrUndefinedFree:  unit  ->  free_error  -> mem_error 
  | MerrUndefinedRealloc: mem_error 
  
  | MerrIntFromPtr: mem_error 
  | MerrPtrFromInt: mem_error 
  
  | MerrPtrComparison: mem_error 
  
  | MerrArrayShift: mem_error 
  
  | MerrWIP:  string  -> mem_error .
Definition mem_error_default: mem_error  := MerrOutsideLifetime string_default.

Instance x41_Show : Show mem_error := {
   show  :=  fun x =>
   match (x) with | MerrOutsideLifetime str =>
     String.append "MerrOutsideLifetime """ (String.append str """")
     | MerrInternal str =>
     String.append "MerrInternal """ (String.append str """")
     | MerrOther str => String.append "MerrOther """ (String.append str """")
     | MerrWIP str => String.append "Memory WIP: " str | MerrPtrdiff =>
     "MerrPtrdiff" | MerrAccess loc LoadAccess err =>
     String.append "MerrAccess Load ["
       (String.append ("") (String.append "] " (stringFromAccess_error err)))
     | MerrWriteOnReadOnly loc =>
     String.append "MerrWriteOnReadOnly [" (String.append ("") "]")
     | MerrAccess loc StoreAccess err =>
     String.append "MerrAccess Store ["
       (String.append ("") (String.append "] " (stringFromAccess_error err)))
     | MerrUndefinedFree loc err =>
     String.append "MerrUndefinedFree ["
       (String.append ("") (String.append "] " (stringFromFree_error err)))
     | MerrUndefinedRealloc => "MerrUndefinedRealloc" | MerrIntFromPtr =>
     "MerrIntFromPtr" | MerrPtrFromInt => "MerrPtrFromInt"
     | MerrPtrComparison => "MerrPtrComparison" | MerrArrayShift =>
     "MerrArrayShift" end
}.



Definition undefinedFromMem_error   : mem_error  -> option (list (undefined.undefined_behaviour )) :=  
  fun (x : mem_error ) =>
    match (x) with | MerrOutsideLifetime _ =>
      Some [undefined.UB009_outside_lifetime] | MerrPtrdiff =>
      Some [undefined.UB048_disjoint_array_pointers_subtraction]
      | MerrAccess _ _ NullPtr => Some [undefined.UB019_lvalue_not_an_object]
      | MerrAccess _ _ DeadPtr =>
      Some [undefined.UB010_pointer_to_dead_object] | MerrIntFromPtr =>
      Some [undefined.UB024_out_of_range_pointer_to_integer_conversion]
      | MerrPtrFromInt => Some [undefined.UB_CERB001_integer_to_dead_pointer]
      | MerrPtrComparison =>
      Some [undefined.UB053_distinct_aggregate_union_pointer_comparison]
      | MerrArrayShift => Some [undefined.UB046_array_pointer_outside]
    (* TODO do better *) | MerrAccess _ LoadAccess OutOfBoundPtr =>
      Some [undefined.UB_CERB002a_out_of_bound_load]
      | MerrAccess _ StoreAccess OutOfBoundPtr =>
      Some [undefined.UB_CERB002b_out_of_bound_store]
      | MerrUndefinedFree loc Free_static_allocation =>
      Some [undefined.UB179a_static_allocation]
      | MerrUndefinedFree loc Free_dead_allocation =>
      Some [undefined.UB179b_dead_allocation]
      | MerrUndefinedFree loc Free_out_of_bound => None (* TODO *)
      | MerrUndefinedRealloc =>
      (* TODO *) Some [undefined.UB179a_static_allocation]
      | MerrWriteOnReadOnly _ => (* TODO *) None | _ => None end.







Inductive integer_operator : Type := 
  | IntAdd: integer_operator 
  | IntSub: integer_operator 
  | IntMul: integer_operator 
  | IntDiv: integer_operator 
  | IntRem_t: integer_operator  (* truncating remainder (this is % of C) *)
  | IntRem_f: integer_operator  (* flooring remainder *)
  | IntExp: integer_operator .
Definition integer_operator_default: integer_operator  := IntAdd.

Inductive floating_operator : Type := 
  | FloatAdd: floating_operator 
  | FloatSub: floating_operator 
  | FloatMul: floating_operator 
  | FloatDiv: floating_operator .
Definition floating_operator_default: floating_operator  := FloatAdd.


Inductive pure_memop : Type := 
  | PURE_MEMOP_TODO: pure_memop .
Definition pure_memop_default: pure_memop  := PURE_MEMOP_TODO.

Inductive memop : Type := 
  | PtrEq: memop 
  | PtrNe: memop 
  | PtrLt: memop 
  | PtrGt: memop 
  | PtrLe: memop 
  | PtrGe: memop 
(*  | PtrIsNull *)
  
  | Ptrdiff: memop      (* (address, address) -> eff integer *)
  | IntFromPtr: memop   (* (ctype, ctype, address) -> eff integer *) (* first type is that of the referenced type, second on is type of integer *)
  | PtrFromInt: memop   (* (ctype, ctype, integer) -> eff address *) (* first type is that of integer, second on is type of reference *)
  | PtrValidForDeref: memop  (* (ctype, address) -> eff boolean *)
  
  | PtrWellAligned: memop  (* (ctype, address) -> eff boolean *)
  
  | PtrArrayShift: memop  (* address -> ctype -> integer -> eff address *)
  
  | Memcpy: memop 
  | Memcmp: memop 
  | Realloc: memop  (* TODO: not sure about this *)
  | Va_start: memop 
  | Va_copy: memop 
  | Va_arg: memop 
  | Va_end: memop .
Definition memop_default: memop  := PtrEq.


Instance x40_Show : Show memop := {
   show  :=  fun x =>
   match (x) with | PtrEq => "ptreq" | PtrNe => "ptrne" | PtrLt => "ptrlt"
     | PtrGt => "ptrgt" | PtrLe => "ptrle" | PtrGe => "ptrge" | Ptrdiff =>
     "ptrdiff" | IntFromPtr => "intfromptr" | PtrFromInt => "ptrfromint"
     | PtrValidForDeref => "ptrvalidforderef" | PtrWellAligned =>
     "ptrwellaligned" | Memcpy => "memcpy" | Memcmp => "memcmp" | Realloc =>
     "realloc" | PtrArrayShift => "ptrarrayshift" | Va_start => "va_start"
     | Va_copy => "va_copy" | Va_arg => "va_arg" | Va_end => "va_end" end
}.




Definition stringFromInteger_operator   : integer_operator  -> string :=  
  fun (x : integer_operator ) =>
    match (x) with | IntAdd => "IntAdd" | IntSub => "IntSub" | IntMul =>
      "IntMul" | IntDiv => "IntDiv" | IntRem_t => "IntRem_t" | IntRem_f =>
      "IntRem_f" | IntExp => "IntExp" end.


Definition stringFromFloating_operator   : floating_operator  -> string :=  
  fun (x : floating_operator ) =>
    match (x) with | FloatAdd => "FloatAdd" | FloatSub => "FloatSub"
      | FloatMul => "FloatMul" | FloatDiv => "FloatDiv" end.


Inductive mem_constraint (a : Type) : Type := 
  | MC_empty: mem_constraint a
  | MC_eq:  a ->  a -> mem_constraint a
  | MC_le:  a ->  a -> mem_constraint a
  | MC_lt:  a ->  a -> mem_constraint a
  
  | MC_in_device:  a -> mem_constraint a
  
  | MC_or:  mem_constraint  a ->  mem_constraint  a -> mem_constraint a
  | MC_conj:  list  (mem_constraint  a) -> mem_constraint a
  | MC_not:  mem_constraint  a -> mem_constraint a.
Definition mem_constraint_default{a: Type} : mem_constraint a := MC_empty a.
Arguments MC_empty {_}.
Arguments MC_eq {_} _ _.
Arguments MC_le {_} _ _.
Arguments MC_lt {_} _ _.
Arguments MC_in_device {_} _.
Arguments MC_or {_} _ _.
Arguments MC_conj {_} _.
Arguments MC_not {_} _.


Instance x39_Constraints{a: Type} : Constraints (mem_constraint  a):= {
   empty  :=  MC_empty;
   negate   cs :=  MC_not cs;
   concat   cs1  cs2 :=  MC_conj [cs1; cs2]
}.





(*


type pointer_shift =
(* TODO: bring back symbols *)
(*  list (Core_ctype.ctype * Symbolic.symbolic) *)
  list (Core_ctype.ctype * integer)


type pointer_value =
  | PVnull of Core_ctype.ctype
  | PVobject of object_id * pointer_shift
  | PVfunction of Symbol.t


type integer_value_operator =
  | IntAdd
  | IntSub
  | IntMul
  | IntDiv
  | IntMod
  | IntExp

type integer_value =
  | IVinteger of integer
  | IVsymbolic of Symbolic.symbolic (* possibly-symbolic integer value *)
  | IVptrdiff of pointer_value * pointer_value
  | IVintptr of pointer_value
  | IVop of integer_value_operator * integer_value * integer_value


type mem_value =
  | MVunspecified of Core_ctype.ctype (* this should only be used for base and union types *)
  | MVinteger of integer_value
  | MVfloating of string
  | MVpointer of pointer_value
  | MVarray of list mem_value (* TODO: list (maybe mem_value) *)
  | MVstruct of Symbol.t * list (Cabs.identifier * mem_value)
  | MVunion of Symbol.t * Cabs.identifier * mem_value (* the symbols are respectively the tag and the member *)


*)


Record memory_flags : Type := {
  allow_multi_provenance: bool  (* allow Prov_some aids, where aids is not a singleton *)
  
}.

Definition memory_flags_default: memory_flags  := {| allow_multi_provenance := bool_default |}.


Inductive memory_flag : Type := 
  | Allow_disjoint_alloc_tests: memory_flag .
Definition memory_flag_default: memory_flag  := Allow_disjoint_alloc_tests. (* allow (for example) pointer equality between different objects *)
