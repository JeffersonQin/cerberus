(* Generated by Lem from ocaml_generated/cmm_op.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(* --------------------------------------------------------------------- *)
(* -- An operational semantics of C11 concurrency                        *)
(* -- (c) Kyndylan Nienhuis, University of Cambridge                     *)
(* --------------------------------------------------------------------- *)

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import lem_show.
Require Export lem_show.
Require Import lem_show_extra.
Require Export lem_show_extra.

Require Import cmm_aux.
Require Export cmm_aux.
Require Import cmm_csem.
Require Export cmm_csem.



(* [?]: removed value specification. *)


Require Import loc.
Require Export loc.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition well_formed_threads_opsem  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (pre,  wit,  rel1)) =>
    well_formed_threads (pre, wit, rel1) && true end.
(* [?]: removed value specification. *)

Definition axsimpConsistentExecution   : named_predicate_tree := 
  Node [ 
    ("assumptions",                     Leaf assumptions);
    ("tot_empty",                       Leaf tot_empty);
    ("well_formed_threads_opsem",       Leaf well_formed_threads_opsem);
    ("well_formed_rf",                  Leaf well_formed_rf);
    ("locks_only_consistent_locks",     Leaf locks_only_consistent_locks);
    ("locks_only_consistent_lo",        Leaf locks_only_consistent_lo);
    ("consistent_mo",                   Leaf consistent_mo);
    ("sc_accesses_consistent_sc",       Leaf sc_accesses_consistent_sc);
    ("sc_fenced_sc_fences_heeded",      Leaf sc_fenced_sc_fences_heeded);
    ("consistent_hb",                   Leaf consistent_hb);
    ("det_read_alt",                    Leaf det_read_alt);
    ("consistent_non_atomic_rf",        Leaf consistent_non_atomic_rf);
    ("consistent_atomic_rf",            Leaf consistent_atomic_rf);
    ("coherent_memory_use",             Leaf coherent_memory_use);
    ("rmw_atomicity",                   Leaf rmw_atomicity);
    ("sc_accesses_sc_reads_restricted", Leaf sc_accesses_sc_reads_restricted)]  
  .
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition axsimpMemoryModel   : memory_model :=  
  {|consistent := axsimpConsistentExecution;relation_calculation := standard_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition axsimpBehaviour  (opsem_t1 : program  -> pre_execution  -> bool ) (p : nat )  : program_behaviours := 
  behaviour axsimpMemoryModel true_condition opsem_t1 p.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition preRestrict  (pre : pre_execution ) (actions1 : set (action ))  : pre_execution :=  
{|actions := (set_inter_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(actions  pre) actions1);threads :=(threads  pre);lk :=(lk  pre);sb := (lem_relation.relRestrict(sb  pre) actions1);asw := (lem_relation.relRestrict(asw  pre) actions1);dd := (lem_relation.relRestrict(dd  pre) actions1)
|}.
(* [?]: removed value specification. *)

Definition incWitRestrict  (wit : execution_witness ) (actions1 : set (action ))  : execution_witness :=  
{|rf := (lem_relation.relRestrict(rf  wit) actions1);mo := (lem_relation.relRestrict(mo  wit) actions1);sc := (lem_relation.relRestrict(sc  wit) actions1);lo := (lem_relation.relRestrict(lo  wit) actions1);tot := (lem_relation.relRestrict(tot  wit) actions1)
|}.
(* [?]: removed value specification. *)

Definition pre_hb  (pre : pre_execution )  : set ((action *action ) % type):=  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))(sb  
  pre) (sw_asw pre)).
(* [?]: removed value specification. *)

Definition wit_hb  (pre : pre_execution ) (wit : execution_witness )  : set ((action *action ) % type):= 
  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) 
  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) 
        (sw_lock pre wit) (sw_rel_acq_rs pre wit)) (sw_fence_sb_hrs_rf_sb pre wit)) (sw_fence_sb_hrs_rf pre wit)) (sw_fence_rs_rf_sb pre wit)).
(* [?]: removed value specification. *)

Definition sb_r_f  (pre : pre_execution ) (wit : execution_witness )  : set ((action *action ) % type):=  
  let x2 := [] in set_fold
   (fun (p : (action *action ) % type) (x2 : set ((action *action ) % type)) =>
      match ( (p ,x2) ) with ((a,  b) ,  x2) =>
        if is_at_atomic_location (lk  pre) a &&
           (is_read a && (is_fence b && is_acquire b)) then set_add (a, b) x2
        else x2 end) (sb  pre) x2.
(* [?]: removed value specification. *)

Definition sb_f_w  (pre : pre_execution ) (wit : execution_witness )  : set ((action *action ) % type):=  
  let x2 := [] in set_fold
   (fun (p : (action *action ) % type) (x2 : set ((action *action ) % type)) =>
      match ( (p ,x2) ) with ((a,  b) ,  x2) =>
        if is_fence a &&
           (is_release a && (is_at_atomic_location (lk  pre) b && is_write b)) then
          set_add (a, b) x2 else x2 end) (sb  pre) x2.
(* [?]: removed value specification. *)

Definition incCom2_step  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set ((action *action ) % type):= 
  match ( (p)) with ( (pre,  wit,  rel1)) =>
    (set_union_by
       (pairCompare
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
       (set_union_by
          (pairCompare
             (fun (x : action ) (y : action )=>
                (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
             (fun (x : action ) (y : action )=>
                (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
          (set_union_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (mo  wit) (rf  wit)) (sb_r_f pre wit)) (sb_f_w pre wit)) end.
(* [?]: removed value specification. *)

Definition incCom2  (ex : (pre_execution *execution_witness *relation_list ) % type)  : set ((action *action ) % type):= 
  (set_tc (fun (a1 : action ) (a2 : action )=>classical_boolean_equivalence a1 a2) (incCom2_step ex)).
(* [?]: removed value specification. *)

Definition is_na_or_non_write  (pre : pre_execution ) (a : action )  : bool :=  
  negb (is_write a) || is_at_non_atomic_location(lk  pre) a.
(* [?]: removed value specification. *)

Definition hbMinus  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set ((action *action ) % type):= 
  match ( (p)) with ( (pre,  _,  ("hb", hb)::_)) =>
    let x2 := [] in set_fold
                      (fun (p : (action *action ) % type) (x2 : set ((action *action ) % type)) =>
                         match ( (p ,x2) ) with ((a,  b) ,  x2) =>
                           if is_na_or_non_write pre b then set_add (a, b) x2
                           else x2 end) hb x2 | (( _,  _, [])) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/cmm_op.lem\", line 184, character 1 to line 185, character 61 *)
    | (( _,  _, ( _,  _):: _)) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/cmm_op.lem\", line 184, character 1 to line 185, character 61 *)
  end.
(* [?]: removed value specification. *)

Definition incCom  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set ((action *action ) % type):= 
  match ( (p)) with ( (pre,  wit,  rel1)) =>
    (set_tc
       (fun (a1 : action ) (a2 : action )=>
          classical_boolean_equivalence a1 a2)
       ((set_union_by
           (pairCompare
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
           (hbMinus (pre, wit, rel1))
           ((set_union_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (rf  wit) (mo  wit)))))) end.
(* [?]: removed value specification. *)

Definition respectsCom  (actions1 : set (action )) (committed : list (action )) (comOrder : set ((action *action ) % type)) (a : action )  : bool :=  
  (set_for_all  (fun (b : action ) =>
    ( ((negb (lem_list.elem b committed)) ||
       negb
         ( (set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (a, b) comOrder)))) &&
    ( ((negb
          (set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (b, a) comOrder)) || lem_list.elem b committed))) actions1).
  

(* The state of the incremental model *)

Record incState : Type := 
{ incWit:       execution_witness ;
   incCommitted: list  action 
}.
Notation "{[ r 'with' 'incWit' := e ]}" := ({| incWit := e; incCommitted := incCommitted r |}).
Notation "{[ r 'with' 'incCommitted' := e ]}" := ({| incCommitted := e; incWit := incWit r |}).
Definition incState_default: incState  := {| incWit := execution_witness_default; incCommitted := DAEMON |}.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition incInitialState  ( _ : pre_execution )  : incState :=  
{|incWit       := empty_witness;incCommitted := []
|}.
(* [?]: removed value specification. *)

Definition incToEx  (pre : pre_execution ) (s : incState )  : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type:=  
  let pre_res := preRestrict pre ((set_from_list_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(incCommitted  s))) in
  let wit     :=(incWit  s) in
  let rel1     := standard_relations pre_res wit in
  (pre_res, wit, rel1).
(* [?]: removed value specification. *)

Definition incStep  (pre : pre_execution ) (s1 : incState ) (s2 : incState ) (a : action )  : bool := 

  let s2_ex := incToEx pre s2 in
  let com := incCom (pre,(incWit  s2), standard_relations pre(incWit  s2)) in (set_member_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))

  (* The action that is committed in this step hasn't already been committed *)
  a(actions  pre)) &&
  (negb ( lem_list.elem a(incCommitted  s1)) && ((list_equal_by (fun (a1 : action ) (a2 : action )=>classical_boolean_equivalence a1 a2)(incCommitted 
  s2) (a::(incCommitted s1))) &&
  (  

  (* Actions are committed in the right order. *)respectsCom(actions  pre)(incCommitted  s1) com a &&
  (

  (* The new execution_witness extends the previous (only new
  relations are added, and new relations are from or to the committed
  action). *)( classical_boolean_equivalence (incWitRestrict(incWit  s2) ((set_from_list_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(incCommitted  s1))))(incWit  s1)) &&

  (* The new execution satisfies the consistency predicates. *)
  apply_tree axsimpConsistentExecution s2_ex)))).
Inductive incTrace: (pre_execution) -> (incState) -> (incState) -> Prop :=
  | incReflexive: forall pre s, ( 
  well_formed_threads_opsem (pre, empty_witness, []):Prop) -> incTrace   pre  s  s
  | incStep: forall pre x y z a, (
  incTrace pre x y:Prop) -> ( 
  incStep pre y z a:Prop) -> incTrace   pre  x  z.
(* [?]: removed value specification. *)

(* 
Definition consistencyFromTrace  (trace : pre_execution  -> incState  -> incState  -> bool )  ((pre : pre_execution ), (wit : execution_witness ), (rel : list ((string *set ((action *action ) % type)) % type)))  : bool := 
  instance_Basic_classes_Eq_list.= rel getRelations pre wit &&exists s,( 
  trace pre (incInitialState pre) s &&
  (instance_Basic_classes_Eq_Cmm_csem_execution_witness.=(incWit  s) wit) &&
  (instance_Basic_classes_Eq_set.= incCommittedSet s(actions  pre)) : Prop). *)
(* [?]: removed value specification. *)

Definition incConsistent   : candidate_execution  -> bool := 
  BOOM incTrace.


(* The monadic model --------------------------------------------------- *)

Require Import nondeterminism.
Require Export nondeterminism.

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Definition ndM0 (a: Type) : Type :=  nondeterminism.ndM  a  string   string   mem.mem_iv_constraint   unit .
Definition ndM0_default{a: Type} : ndM0 a := DAEMON.
(* [?]: removed value specification. *)

Definition sameLocWrites  (actions1 : list (action )) (a : action )  : list (action ):= 
  let x2 := [] in List.fold_right
   (fun (b : action ) (x2 : list (action )) =>
      if is_write b &&
         ( (maybeEqualBy classical_boolean_equivalence (loc_of b) (loc_of a))) then
        b :: x2 else x2) x2 actions1.
(* [?]: removed value specification. *)

Definition sameLocLocksUnlocks  (actions1 : list (action )) (a : action )  : list (action ):= 
  let x2 := [] in List.fold_right
   (fun (b : action ) (x2 : list (action )) =>
      if (is_lock b || is_unlock b) &&
         ( (maybeEqualBy classical_boolean_equivalence (loc_of b) (loc_of a))) then
        b :: x2 else x2) x2 actions1.
(* [?]: removed value specification. *)

Definition scActions  (actions1 : list (action ))  : list (action ):= 
  let x2 := [] in List.fold_right
   (fun (b : action ) (x2 : list (action )) =>
      if is_seq_cst b then b :: x2 else x2) x2 actions1.
(* [?]: removed value specification. *)

Definition checkValuesAreEqual  (v : option ((tt *tt ) % type) )  : nondeterminism.ndM (unit ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  match ( v) with 
  | Some (value_w,  value_r) => 
         nondeterminism.nd_guard ( classical_boolean_equivalence value_w value_r) 
                              (nondeterminism.Other ( String.append"The value written ("  (String.append"TODO"  
                                                     (String.append") and the value read ( "  (String.append"TODO" 
                                                     ") cannot be matched")))))
  | _ => nondeterminism.nd_return tt
  end.
(* [?]: removed value specification. *)

Definition addToTransitiveOrder  (domain1 : list (action )) (a : action ) (r : set ((action *action ) % type))  : nondeterminism.ndM (set ((action *action ) % type)) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  nondeterminism.mplus
  (* We insert the action before all other actions *)
  (nondeterminism.nd_return ((set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) r ((set_from_list_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (let x2 := [] in 
  List.fold_right
    (fun (b : action ) (x2 : list ((action *action ) % type)) =>
       if true then (a, b) :: x2 else x2) x2 domain1))))))
  (* We choose an action, and insert 'a' directly after it *)
  ( nondeterminism.bindExhaustive(nondeterminism.pick "addToTransitiveOrder" domain1) (fun (b : action ) =>
    let prev := let x2 := [] in 
  List.fold_right
    (fun (c : action ) (x2 : list ((action *action ) % type)) =>
       if (set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (c, b) r) then (c, a) :: x2 else x2) x2 domain1 in
    let succ1 := let x2 := [] in 
  List.fold_right
    (fun (c : action ) (x2 : list ((action *action ) % type)) =>
       if (set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (b, c) r) then (a, c) :: x2 else x2) x2 domain1 in
    nondeterminism.nd_return ((set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) r 
                                       (set_add (b, a) 
                                                   ((set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) ((set_from_list_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) prev)) 
                                                                ((set_from_list_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) succ1))))))))).
(* [?]: removed value specification. *)

Definition monAddToMo  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM (set ((action *action ) % type)) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  let prev := let x2 := [] in 
  List.fold_right
    (fun (b : action ) (x2 : list ((action *action ) % type)) =>
       if true then (b, a) :: x2 else x2) x2
    (sameLocWrites (incCommitted  s) a) in
  nondeterminism.nd_return ((set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))(mo (incWit  s)) ((set_from_list_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) prev)))).
(* [?]: removed value specification. *)

Definition auxAddPairToRf  (old_rf : set ((action *action ) % type)) (w : action ) (r : action )  : nondeterminism.ndM ((set ((action *action ) % type)*tt *tt ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  match ( (value_written_by w, value_read_by r)) with 
  | (Some value_w,  Some value_r) => 
      nondeterminism.nd_return ((set_add (w, r) old_rf), value_w, value_r)
  | _ => 
      nondeterminism.kill (nondeterminism.Error0 tt "A write-read pair doesn't contain the values written and read")
  end.
(* [?]: removed value specification. *)

Definition auxAddToRfLoad  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM ((set ((action *action ) % type)*option ((tt *tt ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.log ( String.append"CONCUR CHOICE ==> " (stringFromList (fun (s : string )=> String.append""""  (String.append s """")) (List.map (fun (act : action ) => lem_string_extra.stringFromNat (aid_of act)) (sameLocWrites(incCommitted  s) a))))) (fun ( _ : unit ) => (* begin block *)
  nondeterminism.mplus
  (* We do not add an rf-edge. This should happen when there is no vse-edge in the resulting state. *)
  (nondeterminism.nd_return ((rf (incWit s)), None))
  (* We add an rf-edge. *)
  ( 
   nondeterminism.bindExhaustive(nondeterminism.pick "auxAddToRfLoad" (sameLocWrites(incCommitted  s) a)) (fun (w : action ) =>
   nondeterminism.bindExhaustive
   (auxAddPairToRf(rf (incWit  s)) w a) 
  (fun (p : (set ((action *action ) % type)*tt *tt ) % type) =>
     match ( (p) ) with ( (new_rf,  value_w,  value_r)) =>
       nondeterminism.nd_return (new_rf, Some (value_w, value_r)) end)))
(* end block *))) (fun (p : (set ((action *action ) % type)*option ((tt *tt ) % type) ) % type) =>
    match ( (p) ) with ( (_,  x) as ret) =>
      nondeterminism.bindExhaustive
        (nondeterminism.log
           ( String.append "CONCUR CHOSE ==> "
               match ( x) with | Some (y, z) =>
                 String.append (BOOM y) (String.append " --- " (BOOM z))
                 | None => "nothing" end))
        (fun ( _ : unit ) => nondeterminism.nd_return ret) end).
(* [?]: removed value specification. *)

Definition monAddToRfLoad  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM (set ((action *action ) % type)) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive
  (auxAddToRfLoad pre a s) 
  (fun (p : (set ((action *action ) % type)*option ((cvalue *cvalue ) % type) ) % type) =>
     match ( (p) ) with ( (new_rf,  v)) =>
       nondeterminism.bindExhaustive (checkValuesAreEqual v)
         (fun ( _ : unit ) => nondeterminism.nd_return new_rf) end).
(* [?]: removed value specification. *)

Definition auxAddToRfRmw  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM ((set ((action *action ) % type)*option ((tt *tt ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  let mo_actions := sameLocWrites(incCommitted  s) a in
  if lem_list.null mo_actions then
    nondeterminism.nd_return ((rf (incWit s)), None)
  else
    nondeterminism.bindExhaustive
    (nondeterminism.pick "auxAddToRfRmw" 
        (let x2 := [] in 
  List.fold_right
    (fun (w : action ) (x2 : list (action )) =>
       if List.forallb
            (fun (c : action ) =>
               negb
                 ( (set_member_by
                      (pairCompare
                         (fun (x : action ) (y : action )=>
                            (genericCompare nat_ltb beq_nat (aid_of x)
                               (aid_of y)))
                         (fun (x : action ) (y : action )=>
                            (genericCompare nat_ltb beq_nat (aid_of x)
                               (aid_of y)))) (w, c) (mo (incWit  s)))))
            mo_actions then w :: x2 else x2) x2 mo_actions)) (fun (w : action ) =>  
    nondeterminism.bindExhaustive
    (auxAddPairToRf(rf (incWit  s)) w a) 
  (fun (p : (set ((action *action ) % type)*tt *tt ) % type) =>
     match ( (p) ) with ( (new_rf,  value_w,  value_r)) =>
       nondeterminism.nd_return (new_rf, Some (value_w, value_r)) end)).
(* [?]: removed value specification. *)

Definition monAddToRfRmw  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM (set ((action *action ) % type)) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive
  (auxAddToRfRmw pre a s) 
  (fun (p : (set ((action *action ) % type)*option ((cvalue *cvalue ) % type) ) % type) =>
     match ( (p) ) with ( (new_rf,  v)) =>
       nondeterminism.bindExhaustive (checkValuesAreEqual v)
         (fun ( _ : unit ) => nondeterminism.nd_return new_rf) end).
(* [?]: removed value specification. *)

Definition monAddToLo  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM (set ((action *action ) % type)) (string ) (string ) (mem.mem_iv_constraint ) (unit ):=  
  addToTransitiveOrder (sameLocLocksUnlocks(incCommitted  s) a) a(lo (incWit  s)).
(* [?]: removed value specification. *)

Definition monAddToSc  (pre : pre_execution ) (a : action ) (s : incState )  : nondeterminism.ndM (set ((action *action ) % type)) (string ) (string ) (mem.mem_iv_constraint ) (unit ):=  
  addToTransitiveOrder (scActions(incCommitted  s)) a(sc (incWit  s)).
(* [?]: removed value specification. *)

Definition monCheckConsistency  (ex : (pre_execution *execution_witness *relation_list ) % type)  : nondeterminism.ndM (unit ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.nd_guard (assumptions ex) (nondeterminism.Other "Inconsistent (assumptions)")) (fun ( _ : unit ) => nondeterminism.nd_guard (locks_only_consistent_locks ex) (nondeterminism.Other "Inconsistent (locks_only_consistent_locks)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (locks_only_consistent_lo ex) (nondeterminism.Other "Inconsistent (locks_only_consistent_lo)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (sc_accesses_consistent_sc ex) (nondeterminism.Other "Inconsistent (sc_accesses_consistent_sc)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (sc_fenced_sc_fences_heeded ex) (nondeterminism.Other "Inconsistent (sc_fenced_sc_fences_heeded)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (consistent_hb ex) (nondeterminism.Other "Inconsistent (consistent_hb)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (det_read_alt ex) (nondeterminism.Other "Inconsistent (det_read_alt)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (consistent_non_atomic_rf ex) (nondeterminism.Other "Inconsistent (consistent_non_atomic_rf)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (consistent_atomic_rf ex) (nondeterminism.Other "Inconsistent (consistent_atomic_rf)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (coherent_memory_use ex) (nondeterminism.Other "Inconsistent (coherent_memory_use)"))) (fun ( _ : unit ) => nondeterminism.nd_guard (sc_accesses_sc_reads_restricted ex) (nondeterminism.Other "Inconsistent (sc_accesses_sc_reads_restricted)")).
(* [?]: removed value specification. *)

Definition monCheckWitRestrict  (new_wit : execution_witness ) (committed : set (action )) (old_wit : execution_witness )  : nondeterminism.ndM (unit ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  nondeterminism.nd_guard ( classical_boolean_equivalence (incWitRestrict new_wit committed) old_wit) 
           (nondeterminism.Error0 tt """witnessRestrict new committed = old"" should hold by construction.").
(* [?]: removed value specification. *)

Definition monCheckCommitmentOrder  (pre : pre_execution ) (wit : execution_witness ) (committed : list (action )) (a : action )  : nondeterminism.ndM (unit ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  
  let rel1 := standard_relations pre wit in
  let order := incCom (pre, wit, rel1) in
  nondeterminism.nd_guard 
    (respectsCom(actions  pre) committed order a)
    (nondeterminism.Other ( String.append"Committing action "  (String.append(lem_string_extra.stringFromNat (aid_of a)) 
                           " does not respect the commitment order."))).
(* [?]: removed value specification. *)

Definition monPerformLoad  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=     nondeterminism.bindExhaustive
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     nondeterminism.nd_return(sc (incWit  s))) (fun (new_sc : set ((action *action ) % type)) =>       nondeterminism.bindExhaustive
  (monAddToRfLoad pre a s) (fun (new_rf : set ((action *action ) % type)) =>
  (* Without the extra brackets the generated isabelle code is invalid. *)
  nondeterminism.nd_return ( {[{[(incWit  s) with rf := new_rf  ]} with sc := new_sc  ]}))).
(* [?]: removed value specification. *)

Definition monPerformStore  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=     nondeterminism.bindExhaustive
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     nondeterminism.nd_return(sc (incWit  s))) (fun (new_sc : set ((action *action ) % type)) =>    nondeterminism.bindExhaustive
  (if is_at_atomic_location(lk  pre) a then
     monAddToMo pre a s
   else
     nondeterminism.nd_return(mo (incWit  s))) (fun (new_mo : set ((action *action ) % type)) =>
  (* Without the extra brackets the generated isabelle code is invalid. *)
  nondeterminism.nd_return ( {[{[(incWit  s) with mo := new_mo  ]} with sc := new_sc  ]}))).
(* [?]: removed value specification. *)

Definition monPerformRmw  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=     nondeterminism.bindExhaustive
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     nondeterminism.nd_return(sc (incWit  s))) (fun (new_sc : set ((action *action ) % type)) =>        nondeterminism.bindExhaustive
  (monAddToRfRmw pre a s) (fun (new_rf : set ((action *action ) % type)) =>           nondeterminism.bindExhaustive
  (monAddToMo pre a s) (fun (new_mo : set ((action *action ) % type)) =>
  (* Without the extra brackets the generated isabelle code is invalid. *)
  nondeterminism.nd_return ( {[ {[{[(incWit  s) with mo := new_mo  ]} with rf := new_rf  ]} with sc := new_sc  ]})))).
(* [?]: removed value specification. *)

Definition monPerformLock  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=           nondeterminism.bindExhaustive
  (monAddToLo pre a s) (fun (new_lo : set ((action *action ) % type)) =>
  (* Without the extra brackets the generated isabelle code is invalid. *)
  nondeterminism.nd_return ({[(incWit  s) with lo := new_lo  ]})).
(* [?]: removed value specification. *)

Definition monPerformUnlock  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=           nondeterminism.bindExhaustive
  (monAddToLo pre a s) (fun (new_lo : set ((action *action ) % type)) =>
  (* Without the extra brackets the generated isabelle code is invalid. *)
  nondeterminism.nd_return ({[(incWit  s) with lo := new_lo  ]})).
(* [?]: removed value specification. *)

Definition monPerformFence  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=     nondeterminism.bindExhaustive
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     nondeterminism.nd_return(sc (incWit  s))) (fun (new_sc : set ((action *action ) % type)) =>
  (* Without the extra brackets the generated isabelle code is invalid. *)
  nondeterminism.nd_return ({[(incWit  s) with sc := new_sc  ]})).
(* [?]: removed value specification. *)

Definition monPerformAction  (pre : pre_execution ) (s : incState ) (a : action )  : nondeterminism.ndM (execution_witness ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  match ( a) with 
  | Lock _ _ _ _      => monPerformLock pre s a
  | Unlock _ _ _      => monPerformUnlock pre s a
  | Load _ _ _ _ _    => monPerformLoad pre s a
  | Store _ _ _ _ _   => monPerformStore pre s a
  | RMW _ _ _ _ _ _   => monPerformRmw pre s a
  | Fence _ _ _       => monPerformFence pre s a
  | Blocked_rmw _ _ _ => nondeterminism.nd_return(incWit  s)
  | Alloc _ _ _       => nondeterminism.nd_return(incWit  s)
  | Dealloc _ _ _     => nondeterminism.nd_return(incWit  s)
  end.
(* [?]: removed value specification. *)

Definition monStep  (pre : pre_execution ) (s : incState )  : nondeterminism.ndM ((action *incState ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  let uncommitted_actions := 
    let x2 := [] in List.fold_right
   (fun (a : action ) (x2 : list (action )) =>
      if negb ( lem_list.elem a (incCommitted  s)) then a :: x2 else x2) 
 x2 (set_to_list (actions  pre)) in nondeterminism.bindExhaustive
  (nondeterminism.pick "monStep" uncommitted_actions) (fun (a : action ) => nondeterminism.bindExhaustive

  (monPerformAction pre s a) (fun (new_wit : execution_witness ) =>

  let new_committed := a::(incCommitted s) in
  let new_pre := preRestrict pre ((set_from_list_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) new_committed)) in
  let new_ex := (new_pre, new_wit, standard_relations new_pre new_wit) in     nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (nondeterminism.bindExhaustive (monCheckConsistency new_ex) (fun ( _ : unit ) => monCheckWitRestrict new_wit ((set_from_list_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(incCommitted  s)))(incWit  s))) (fun ( _ : unit ) => monCheckCommitmentOrder pre new_wit(incCommitted  s) a)) (fun ( _ : unit ) => let new_state := {|incWit       := new_wit;incCommitted := new_committed |} in
  nondeterminism.nd_return (a, new_state)))).
Inductive monTrace: (pre_execution) -> (incState) -> (incState) -> Prop :=
  | monReflexive: forall pre s, ( 
  well_formed_threads_opsem (pre, empty_witness, []):Prop) -> monTrace   pre  s  s
  | monStep: forall pre x y z a, (
  monTrace pre x y:Prop) -> ( 
  nondeterminism.nd_mem ((a : action ), z) (monStep pre y):Prop) -> monTrace   pre  x  z.
(* [?]: removed value specification. *)

Definition monConsistent   : candidate_execution  -> bool := 
  BOOM monTrace.



(* The symbolic model -------------------------------------------------- *)

(* We have a different type of state, because pre-executions and the
   equality over cvalues can be updated. *)

Record symState : Type :=
{ symPre:            pre_execution ; 
   symWit:            execution_witness ;
   symCommitted:      list  action ;
   symUndefinedness:  list  undefinedness 
}.
Notation "{[ r 'with' 'symPre' := e ]}" := ({| symPre := e; symWit := symWit r; symCommitted := symCommitted r; symUndefinedness := symUndefinedness r |}).
Notation "{[ r 'with' 'symWit' := e ]}" := ({| symWit := e; symPre := symPre r; symCommitted := symCommitted r; symUndefinedness := symUndefinedness r |}).
Notation "{[ r 'with' 'symCommitted' := e ]}" := ({| symCommitted := e; symPre := symPre r; symWit := symWit r; symUndefinedness := symUndefinedness r |}).
Notation "{[ r 'with' 'symUndefinedness' := e ]}" := ({| symUndefinedness := e; symPre := symPre r; symWit := symWit r; symCommitted := symCommitted r |}).
Definition symState_default: symState  := {| symPre := pre_execution_default; symWit := execution_witness_default; symCommitted := DAEMON; symUndefinedness := DAEMON |}.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x115_Show : Show symState := {
   show   state :=  
    String.append"(pre_ex: "  (String.append(stringFromSet lem_string_extra.stringFromNat (lem_set.map aid_of(actions (symPre  state))))   
    (String.append", wit: "  (String.append    (String.append"rf: "  (String.append(action_rel_tostring(rf (symWit  state)))   
    (String.append", mo: "  (String.append(action_rel_tostring(mo (symWit  state)))   
    (String.append", sc: "  (String.append(action_rel_tostring(sc (symWit  state)))   
    (String.append", lo: "  (String.append(action_rel_tostring(lo (symWit  state)))  
    (String.append", tot: " (action_rel_tostring(tot (symWit  state)))))))))))) 
    (String.append", committed: "  (String.append(stringFromList lem_string_extra.stringFromNat (List.map aid_of(symCommitted  state))) ")")))))
}.

(* [?]: removed value specification. *)

Definition defaultLk   : location_kind :=  Non_Atomic.
(* [?]: removed value specification. *)

Definition symInitialPre   : pre_execution :=  
  {|actions := [];threads := [];lk := (fun ( _ : tt ) => defaultLk);sb := [];asw := [];dd := [] 
  |}.
(* [?]: removed value specification. *)

Definition symInitialState  (pre : pre_execution )  : symState :=  
  {|symPre := pre;symWit := empty_witness;symCommitted := [];symUndefinedness := []
  |}.

(* The symbolic model allows the threadwise local semantics to build
   the pre-execution step by step, as opposed to generate full
   pre-executions. *)

Record preExStep : Type := 
  { newAction    : action ;
     sbBefore     : set  aid ;
     ddBefore     : set  aid ;
     aswBefore    : set  aid ;
     locationKind : option  location_kind  
  }.
Notation "{[ r 'with' 'newAction' := e ]}" := ({| newAction := e; sbBefore := sbBefore r; ddBefore := ddBefore r; aswBefore := aswBefore r; locationKind := locationKind r |}).
Notation "{[ r 'with' 'sbBefore' := e ]}" := ({| sbBefore := e; newAction := newAction r; ddBefore := ddBefore r; aswBefore := aswBefore r; locationKind := locationKind r |}).
Notation "{[ r 'with' 'ddBefore' := e ]}" := ({| ddBefore := e; newAction := newAction r; sbBefore := sbBefore r; aswBefore := aswBefore r; locationKind := locationKind r |}).
Notation "{[ r 'with' 'aswBefore' := e ]}" := ({| aswBefore := e; newAction := newAction r; sbBefore := sbBefore r; ddBefore := ddBefore r; locationKind := locationKind r |}).
Notation "{[ r 'with' 'locationKind' := e ]}" := ({| locationKind := e; newAction := newAction r; sbBefore := sbBefore r; ddBefore := ddBefore r; aswBefore := aswBefore r |}).
Definition preExStep_default: preExStep  := {| newAction := action_default; sbBefore := DAEMON; ddBefore := DAEMON; aswBefore := DAEMON; locationKind := DAEMON |}.

Instance x114_Show : Show preExStep := {
   show   step :=       
    String.append"(Action: "  (String.appendmatch ((newAction  step)) with 
    | Lock aid1 tid1 loc lock        => 
      String.append"Lock (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  
      (String.append"TODO"  (String.append", "  (String.appendmatch ( lock) with 
    | Locked  => "Locked"
    | Blocked => "Blocked"
    end ")")))))))
    | Unlock aid1 tid1 loc           => 
      String.append"Unlock (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  
      (String.append"TODO" ")")))))
    | Load aid1 tid1 mo1 loc val1     => 
      String.append"Load (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val: "  (String.append"TODO" ")")))))))))
    | Store aid1 tid1 mo1 loc val1    => 
      String.append"Store (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val: "  (String.append"TODO" ")")))))))))
    | RMW aid1 tid1 mo1 loc val1 val2 => 
      String.append"RMW (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val1: "  (String.append"TODO"  (String.append", val2: "  (String.append"TODO" ")")))))))))))
    | Fence aid1 tid1 mo1             => 
      String.append"Fence (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end ")")))))
    | Blocked_rmw aid1 tid1 loc      => 
      String.append"Blocked_rmw (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")")))))
    | Alloc aid1 tid1 loc            =>                                                  (* CSEM *)
      String.append"Alloc (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")")))))   (* CSEM *)
    | Dealloc aid1 tid1 loc          =>                                                  (* CSEM *)
      String.append"Dealloc (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")"))))) (* CSEM *)
    end  
    (String.append", sbBefore: "  (String.append(stringFromSet lem_string_extra.stringFromNat(sbBefore  step))  
    (String.append", ddBefore: "  (String.append(stringFromSet lem_string_extra.stringFromNat(ddBefore  step)) 
    (String.append", aswBefore: "  (String.append(stringFromSet lem_string_extra.stringFromNat(aswBefore  step))   
    (String.append", locKind: "  (String.append(stringFromMaybe (fun  loc=>match ( loc) with 
    | Mutex      => "Mutex"
    | Non_Atomic => "Non_Atomic"
    | Atomic0     => "Atomic"
    end)(locationKind  step)) ")")))))))))
}.

(* [?]: removed value specification. *)

Definition symUpdatePreEx  (s : symState ) (step1 : preExStep )  : symState :=  
  let pre :=(symPre  s) in
  let new_lk := match ( ((locationKind step1), loc_of(newAction  step1))) with 
               | (Some loc_kind,  Some loc) => (fun (x : tt ) => if classical_boolean_equivalence x loc then loc_kind else(lk  pre) x)
               | _                         =>(lk  pre)
               end in
  let extra_sb  := lem_set.cross (let x2 := 
  [] in set_fold
   (fun (a : action ) (x2 : set (action )) =>
      if (set_member_by (genericCompare nat_ltb beq_nat) (aid_of a)
            (sbBefore  step1)) then set_add a x2 else x2) (actions  pre) 
 x2)  [(newAction step1)] in
  let extra_dd  := lem_set.cross (let x2 := 
  [] in set_fold
   (fun (a : action ) (x2 : set (action )) =>
      if (set_member_by (genericCompare nat_ltb beq_nat) (aid_of a)
            (ddBefore  step1)) then set_add a x2 else x2) (actions  pre) 
 x2)  [(newAction step1)] in
  let extra_asw := lem_set.cross (let x2 := 
  [] in set_fold
   (fun (a : action ) (x2 : set (action )) =>
      if (set_member_by (genericCompare nat_ltb beq_nat) (aid_of a)
            (aswBefore  step1)) then set_add a x2 else x2) (actions  pre) 
 x2) [(newAction step1)] in
  let new_pre := {|actions := (set_add(newAction  step1)(actions  pre));threads := (set_add (tid_of(newAction  step1))(threads  pre));lk      := new_lk;sb      := (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))(sb  pre) extra_sb);asw     := (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))(asw  pre) extra_asw);dd      := (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))(dd  pre) extra_dd)
                |} in
  {[ s with symPre := new_pre  ]}.



(* The return type of the step function. The threadwise model wants to
   know which values are being considered equal when a new rf-edge is
   formed. *)

Inductive symStep : Type :=  
  | ConcurrencyTau:  action  ->  symState  -> symStep 

  (* The first cvalue is the value written, the second the value read. *)
  | ReadsFrom:       cvalue  ->  cvalue  ->  action  ->  symState  -> symStep .
Definition symStep_default: symStep  := ConcurrencyTau action_default symState_default. 

Instance x113_Show : Show symStep := {
   show   step :=  
    match ( step) with 
    | ConcurrencyTau a state  =>  
        String.append"Tau ("  (String.append(lem_string_extra.stringFromNat (aid_of a))  (String.append", "  (String.append (String.append"(pre_ex: "  (String.append(stringFromSet lem_string_extra.stringFromNat (lem_set.map aid_of(actions (symPre  state))))   
    (String.append", wit: "  (String.append    (String.append"rf: "  (String.append(action_rel_tostring(rf (symWit  state)))   
    (String.append", mo: "  (String.append(action_rel_tostring(mo (symWit  state)))   
    (String.append", sc: "  (String.append(action_rel_tostring(sc (symWit  state)))   
    (String.append", lo: "  (String.append(action_rel_tostring(lo (symWit  state)))  
    (String.append", tot: " (action_rel_tostring(tot (symWit  state)))))))))))) 
    (String.append", committed: "  (String.append(stringFromList lem_string_extra.stringFromNat (List.map aid_of(symCommitted  state))) ")")))))) ")")))
    | ReadsFrom v1 v2 a state =>  
        String.append"ReadsFrom ("  (String.append(lem_string_extra.stringFromNat (aid_of a))  (String.append", "  (String.append"TODO"  (String.append" <- "  (String.append"TODO"  (String.append", "  (String.append (String.append"(pre_ex: "  (String.append(stringFromSet lem_string_extra.stringFromNat (lem_set.map aid_of(actions (symPre  state))))   
    (String.append", wit: "  (String.append    (String.append"rf: "  (String.append(action_rel_tostring(rf (symWit  state)))   
    (String.append", mo: "  (String.append(action_rel_tostring(mo (symWit  state)))   
    (String.append", sc: "  (String.append(action_rel_tostring(sc (symWit  state)))   
    (String.append", lo: "  (String.append(action_rel_tostring(lo (symWit  state)))  
    (String.append", tot: " (action_rel_tostring(tot (symWit  state)))))))))))) 
    (String.append", committed: "  (String.append(stringFromList lem_string_extra.stringFromNat (List.map aid_of(symCommitted  state))) ")")))))) ")")))))))
    end
}.

(* [?]: removed value specification. *)

Definition stateOf  (step1 : symStep )  : symState :=  
  match ( step1) with 
  | ConcurrencyTau _ s => s
  | ReadsFrom _ _ _ s  => s
  end.
(* [?]: removed value specification. *)

Definition actionOf  (step1 : symStep )  : action :=  
  match ( step1) with 
  | ConcurrencyTau a _ => a
  | ReadsFrom _ _ a _  => a
  end.
(* [?]: removed value specification. *)

Definition symToIncState  (s : symState )  : incState := 
  {|incWit :=(symWit  s);incCommitted :=(symCommitted  s) |}.
(* [?]: removed value specification. *)

Definition symAddToRfLoad  (s : symState ) (a : action )  : nondeterminism.ndM ((set ((action *action ) % type)*option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem.mem_iv_constraint ) (unit ):=  
  auxAddToRfLoad(symPre  s) a (symToIncState s).
(* [?]: removed value specification. *)

Definition symAddToRfRmw  (s : symState ) (a : action )  : nondeterminism.ndM ((set ((action *action ) % type)*option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem.mem_iv_constraint ) (unit ):=  
  auxAddToRfRmw(symPre  s) a (symToIncState s).
(* [?]: removed value specification. *)

Definition symPerformLoad  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=     nondeterminism.bindExhaustive
  (if is_seq_cst a then
     monAddToSc(symPre  s) a (symToIncState s)
   else
     nondeterminism.nd_return(sc (symWit  s))) (fun (new_sc : set ((action *action ) % type)) =>                       nondeterminism.bindExhaustive
  (symAddToRfLoad s a) 
  (fun (p : (set ((action *action ) % type)*option ((cvalue *cvalue ) % type) ) % type) =>
     match ( (p) ) with ( (new_rf,  values)) =>
       nondeterminism.nd_return
         ( {[{[(symWit  s) with rf := new_rf  ]} with sc := new_sc  ]}, values)
     end)).
(* [?]: removed value specification. *)

Definition symPerformStore  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive
  (monPerformStore(symPre  s) (symToIncState s) a) (fun (wit : execution_witness ) => 
  nondeterminism.nd_return (wit, None)).
(* [?]: removed value specification. *)

Definition symPerformRmw  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=     nondeterminism.bindExhaustive
  (if is_seq_cst a then
     monAddToSc(symPre  s) a (symToIncState s)
   else
     nondeterminism.nd_return(sc (symWit  s))) (fun (new_sc : set ((action *action ) % type)) =>                        nondeterminism.bindExhaustive
  (symAddToRfRmw s a) 
  (fun (p : (set ((action *action ) % type)*option ((cvalue *cvalue ) % type) ) % type) =>
     match ( (p) ) with ( (new_rf,  values)) =>
       nondeterminism.bindExhaustive
         (monAddToMo (symPre  s) a (symToIncState s))
         (fun (new_mo : set ((action *action ) % type)) =>
            nondeterminism.nd_return
              ( {[ {[{[(symWit  s) with mo := new_mo  ]} with rf := new_rf  ]} with sc := new_sc  ]}, values))
     end)).
(* [?]: removed value specification. *)

Definition symPerformLock  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive
  (monPerformLock(symPre  s) (symToIncState s) a) (fun (wit : execution_witness ) => 
  nondeterminism.nd_return (wit, None)).
(* [?]: removed value specification. *)

Definition symPerformUnlock  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive
  (monPerformUnlock(symPre  s) (symToIncState s) a) (fun (wit : execution_witness ) => 
  nondeterminism.nd_return (wit, None)).
(* [?]: removed value specification. *)

Definition symPerformFence  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):=  nondeterminism.bindExhaustive
  (monPerformFence(symPre  s) (symToIncState s) a) (fun (wit : execution_witness ) => 
  nondeterminism.nd_return (wit, None)).
(* [?]: removed value specification. *)

Definition symPerformAction  (s : symState ) (a : action )  : nondeterminism.ndM ((execution_witness *option ((cvalue *cvalue ) % type) ) % type) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 
  match ( a) with 
  | Lock _ _ _ _      => symPerformLock s a
  | Unlock _ _ _      => symPerformUnlock s a
  | Load _ _ _ _ _    => symPerformLoad s a
  | Store _ _ _ _ _   => symPerformStore s a
  | RMW _ _ _ _ _ _   => symPerformRmw s a
  | Fence _ _ _       => symPerformFence s a
  | Blocked_rmw _ _ _ => nondeterminism.nd_return ((symWit s), None)
  | Alloc _ _ _       => nondeterminism.nd_return ((symWit s), None)
  | Dealloc _ _ _     => nondeterminism.nd_return ((symWit s), None)
  end.
(* [?]: removed value specification. *)

Definition symStep  (s : symState )  : nondeterminism.ndM (symStep ) (string ) (string ) (mem_common.mem_constraint (tt )) (unit ):= 

  let uncommitted_actions := 
    let x2 := [] in List.fold_right
   (fun (a : action ) (x2 : list (action )) =>
      if negb ( lem_list.elem a (symCommitted  s)) then a :: x2 else x2) 
 x2 (set_to_list (actions (symPre  s))) in nondeterminism.bindExhaustive
  (nondeterminism.pick "symStep" uncommitted_actions) (fun (a : action ) => nondeterminism.bindExhaustive

  (symPerformAction s a) 
  (fun (p : (execution_witness *option ((tt *tt ) % type) ) % type) =>
     match ( (p) ) with ( (new_wit,  values)) =>
       let new_committed := a :: (symCommitted s) in
     let new_pre := preRestrict (symPre  s)
                      ((set_from_list_by
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y))) new_committed)) in
     let new_ex := (new_pre, new_wit, standard_relations new_pre new_wit) in 
     nondeterminism.bindExhaustive
       (nondeterminism.bindExhaustive
          (nondeterminism.bindExhaustive (monCheckConsistency new_ex)
             (fun ( _ : unit ) =>
                monCheckWitRestrict new_wit
                  ((set_from_list_by
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y))) (symCommitted  s))) (symWit  s)))
          (fun ( _ : unit ) =>
             monCheckCommitmentOrder (symPre  s) new_wit (symCommitted  s) a))
       (fun ( _ : unit ) =>
          let new_state := {[ {[ s with symCommitted := new_committed  ]} with symWit := new_wit  ]} in
          match ( values) with | Some (v,  w) =>
            nondeterminism.nd_return (ReadsFrom v w a new_state) | None =>
            nondeterminism.nd_return (ConcurrencyTau a new_state) end) end)).
