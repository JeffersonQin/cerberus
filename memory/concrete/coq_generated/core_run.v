(* Generated by Lem from ocaml_generated/core_run.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import lem_string_extra.
Require Export lem_string_extra.
Require Import utils.
Require Export utils.
Require Import core.
Require Export core.
Require Import core_ctype_aux.
Require Export core_ctype_aux.
Require Import core_aux.
Require Export core_aux.
Require Import lem_show.
Require Export lem_show.
Require Import lem_show_extra.
Require Export lem_show_extra.
Require Import annot.
Require Export annot.
Require Import any.
Require Export any.

Require Import lem_set_extra.
Require Export lem_set_extra.

Require Import state.
Require Export state.
Require Import loc.
Require Export loc.

Require Import exception.
Require Export exception.
Require Import errors.
Require Export errors.
Require Import undefined.
Require Export undefined.
Require Import exception_undefined.
Require Export exception_undefined.
Require Import state_exception_undefined.
Require Export state_exception_undefined.

Require Import cmm_csem.
Require Export cmm_csem.
Require Import mem.
Require Export mem.
Require Import mem_common.
Require Export mem_common.
Require Import mem_aux.
Require Export mem_aux.

Require Import ailSyntax.
Require Export ailSyntax.
Require Import ctype.
Require Export ctype.
Require Import ailTypesAux.
Require Export ailTypesAux.

Require Import builtins.
Require Export builtins.


Require Import implementation.
Require Export implementation.
Require Import decode.
Require Export decode.


Require Import errors.
Require Export errors.


Require Import core_eval.
Require Export core_eval.

Module Cmm.  
  Require Import cmm_aux.
Require Export cmm_aux.

  Require Import cmm_csem.
Require Export cmm_csem.

End Cmm.


Require Import core_run_aux.
Require Export core_run_aux.

Require Import core_run_aux.
Require Export core_run_aux.

(* [?]: removed value specification. *)

Definition call_proc  (core_extern : fmap (symbol.sym ) (symbol.sym )) (file1 : generic_file (unit ) (core_run_annotation )) (psym : symbol.sym ) (cvals : list (generic_value (symbol.sym )))  : exception.exceptM ((fmap (symbol.sym ) (generic_value (symbol.sym ))*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) (core_run_cause ):= 
  let bTy_params_body_opt :=
    (* NOTE: the order of lookups implies that user procedure cannot hide the
       ones from stdlib, do we really want that? *)
    match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) psym(stdlib  file1))) with 
      | Some( Proc _ bTy params body) =>
          Some (bTy, params, body)
      | _ =>
          let core_sym := match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) psym core_extern)) with 
            | Some sym1 => sym1
            | None => psym
          end in
          match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) core_sym(funs  file1))) with 
            | Some( Proc _ bTy params body) =>
                Some (bTy, params, body)
            | _ =>
                None
          end
    end in
  match ( bTy_params_body_opt) with 
    | Some (bTy,  params,  body) =>
        if negb (beq_nat (List.length params) (List.length cvals)) then
          exception.fail0 (Illformed_program (* begin block *) 
            String.append"calling procedure `"  (String.append 
  match ( psym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end 
            (String.append"' with the wrong number of args: |args|=" 
            (String.append(lem_string_extra.stringFromNat (List.length cvals))  (String.append"expecting: "
            (lem_string_extra.stringFromNat (List.length params))))))
          (* end block *))
        else
          let env1 := utils.foldl2 (
  fun (acc : fmap (symbol.sym ) (generic_value (symbol.sym ))) (p : (symbol.sym *core_base_type ) % type) (cval : generic_value (symbol.sym )) =>
    match ( (acc ,p ,cval) ) with ( acc ,  (sym1,  _) ,  cval) =>
      fmap_add sym1 cval acc end
          ) fmap_empty params cvals in
          exception.except_return (env1, body)
    | None =>
        exception.fail0
          (Illformed_program ( String.append"calling an unknown procedure: " 
  match ( psym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end))
  end.
(* [?]: removed value specification. *)

Definition update_thread_state  (tid1 : nat ) (th_st : thread_state ) (st : core_state )  : core_state := 
  let f := (fun (p : (option (mem_common.thread_id ) *thread_state ) % type) =>
  match ( (p) ) with ( (parent_tid_opt,  _)) => (parent_tid_opt, th_st) end) in
  {[ st with thread_states:= assoc_adjust f tid1(thread_states  st)  ]}.
(* [?]: removed value specification. *)

Definition spawn_thread  (parent_tid_opt : option (mem_common.thread_id ) ) (th_st : thread_state ) (st : core_state )  : core_run_state  -> (((nat *core_state ) % type)*core_run_state ) % type:= 
  state.modify (fun (run_st : core_run_state ) =>
    let tid1 :=(tid_supply  run_st) in
    ((tid1, {[ st with thread_states:= assoc_insert tid1 (parent_tid_opt, th_st)(thread_states  st)  ]}),
     {[ run_st with tid_supply:= Coq.Init.Peano.plus tid1( 1)  ]})
  ).
(* [?]: removed value specification. *)

Definition kill_thread  (tid1 : nat ) (parent_tid : nat ) (aswBefores : set (nat )) (v : generic_value (symbol.sym )) (st : core_state )  : core_state :=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5)
            [debug.DB_core_dynamics]
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "KILLING Thread "
                   (String.append (lem_string_extra.stringFromNat tid1)
                      (String.append " (child of thread "
                         (String.append
                            (lem_string_extra.stringFromNat parent_tid) 
                          ")"))) end)) with tt =>
    let _ := lem_set.map
               (fun (aid1 : nat ) =>
                  fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                  ( 5) [debug.DB_core_dynamics]
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) =>
                         String.append "AID ==> "
                           (lem_string_extra.stringFromNat aid1) end) )
               aswBefores in
  {[ st with thread_states:= apply
                               (assoc_adjust
                                  (fun (p : (option (mem_common.thread_id ) *thread_state ) % type) =>
                                     match ( (p) ) with
                                         ( (parent_tid_opt,  th_st)) =>
                                       (parent_tid_opt, {[ {[ th_st with stack:= 
                                     add_to_asw_stack aswBefores
                                       (subst_wait_stack tid1 v
                                          (stack  th_st))  ]} with arena:= 
                                     subst_wait tid1 v (arena  th_st)  ]})
                                     end ) parent_tid)
                               (assoc_remove tid1 (thread_states  st))  ]}
  end.
(* [?]: removed value specification. *)

Definition fresh_action_id'   : core_run_state  -> (nat *core_run_state ) % type:= 
  state.modify (fun (run_st : core_run_state ) =>
    let aid1 :=(aid_supply  run_st) in
    (aid1, {[ run_st with aid_supply:=Coq.Init.Peano.plus aid1( 1)  ]})
  ).
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)












Module E.  
  Definition core_run_return {a b c d : Type}   : d -> state_exception_undefined.stExceptUndefM d b a:= 
    state_exception_undefined.stExceptUndef_return.
(* [?]: removed top-level value definition. *)
  Definition step_eval_pexprs {a : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file : generic_file (unit ) (core_run_annotation )) (pes : list (generic_pexpr (unit ) (symbol.sym )))  : a -> exception.exceptM ((undefined.t0 (list (generic_pexpr (unit ) (symbol.sym )))*a) % type) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 4) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "CALLING Core_run.step_eval_pexprs (Core_eval.step_eval_pexpr, hasConstrained= false)"
               end )) with tt =>
    seu.runEU
      (exception_undefined.exception_undef_mapM
         (core_eval.step_eval_pexpr ( 0) (current_loc  th_st) core_extern
            (env  th_st) (Some mem_st) file false) pes) end.

  Definition core_run_step_eval_pexpr {a : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : a -> exception.exceptM ((undefined.t0 (generic_pexpr (unit ) (symbol.sym ))*a) % type) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 4) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "CALLING Core_run.step_eval_pexpr (Core_eval.step_eval_pexpr, hasConstrained= false)"
               end )) with tt =>
    seu.runEU
      (core_eval.step_eval_pexpr ( 0) (current_loc  th_st) core_extern
         (env  th_st) (Some mem_st) file false pe) end.
(* [?]: removed top-level value definition. *)
  
  Definition core_run_eval_pexpr {a : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : a -> exception.exceptM ((undefined.t0 (generic_value (symbol.sym ))*a) % type) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 4) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "CALLING Core_run.eval_pexpr (Core_eval.eval_pexpr_aux_broken)"
               end )) with tt =>
    seu.runEU
      (core_eval.eval_pexpr_aux_broken (current_loc  th_st) core_extern
         (env  th_st) (Some mem_st) file pe) end.
(* [?]: removed top-level value definition. *)
  
  Definition eval_pexpr2 {a : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : a -> exception.exceptM ((undefined.t0 (sum (pexpr ) (value0 ))*a) % type) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 4) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) => "CALLING Core_run.eval_pexpr2" end )) with
      tt =>
    seu.runEU
      (core_eval.eval_pexpr_aux2 (current_loc  th_st) core_extern
         (env  th_st) (Some mem_st) file pe) end.
  
  Definition wrapped_eval_pexpr2 {a b c : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : a -> exception.exceptM ((undefined.t0 (generic_pexpr (unit ) (symbol.sym ))*a) % type) (core_run_cause ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 4) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "CALLING Core_run.wrapped_eval_pexpr2" end )) with tt =>
    (* TODO: it would be better to just call eval_pexpr2, but
       Lem generates buggy OCaml ... *)
    state_exception_undefined.stExceptUndef_bind
      (seu.runEU
         (core_eval.eval_pexpr_aux2 (current_loc  th_st) core_extern
            (env  th_st) (Some mem_st) file pe))
      (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
         match (x) with | inl pe' =>
           state_exception_undefined.stExceptUndef_return pe' | inr cval =>
           state_exception_undefined.stExceptUndef_return
             (core_aux.mk_value_pe cval) end) end.
  
  Definition fresh_action_id {a : Type}   : core_run_state  -> exception.exceptM ((undefined.t0 (nat )*core_run_state ) % type) a:= 
    seu.runS fresh_action_id'.
End E.

Require Import operators.
Require Export operators.



Inductive action_request : Type := 
  (* RequestName  of location * sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  -> 
                    cmm.aid  ->  mem_common.thread_id  ->  symbol.prefix  ->  tt  ->  tt  -> 
                    (tt  ->  thread_state ) -> action_request 
  
  | CreateRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  -> 
                     cmm.aid  ->  mem_common.thread_id  ->  symbol.prefix  ->  tt  ->  ctype.ctype  ->  option  tt   -> 
                     (tt  ->  thread_state ) -> action_request 
  
  | LoadRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  ->  
                   (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                   cmm.aid  ->  mem_common.thread_id  ->  cmm.memory_order  ->  ctype.ctype  ->  tt  ->  symbol.sym  -> 
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *)
                   (tt  ->  thread_state ) -> action_request 
  
  | StoreRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  -> 
                    cmm.aid  ->  mem_common.thread_id  ->  cmm.memory_order  ->  ctype.ctype  ->  (* is_locking *)bool  ->  tt  ->  tt  -> 
                    thread_state  -> action_request 
  | RMWRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  -> 
                  cmm.aid  ->  mem_common.thread_id  ->  cmm.memory_order  ->  cmm.memory_order  ->  ctype.ctype  ->  tt  -> 
                  tt  ->  tt  ->  thread_state  -> action_request 
  | FenceRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  -> 
                    cmm.aid  ->  mem_common.thread_id  ->  cmm.memory_order  -> 
                    thread_state  -> action_request 
  | KillRequest:  unit  ->  set  cmm.aid  ->  set  cmm.aid  ->  set  cmm.aid  -> 
                   cmm.aid  ->  mem_common.thread_id  ->  (* is_dynamic *) bool  ->  tt  ->  thread_state  -> action_request .
Definition action_request_default: action_request  := AllocRequest unit_default DAEMON DAEMON DAEMON aid_default thread_id_default prefix_default tt_default tt_default (fun (x121 : tt ) => thread_state_default).

Inductive fs_oper : Type := 
  | FS_MKDIR:  string  ->  Z  -> fs_oper  (* path * mode_t *)
  | FS_RMDIR:  string  -> fs_oper  (* path *)
  | FS_OPEN:  string  ->  Z  ->  option  Z   -> fs_oper  (* path * open_flags *)
  | FS_CLOSE:  Z  -> fs_oper  (* fd *)
  | FS_WRITE:  Z  ->  list  ascii  ->  Z  -> fs_oper  (* fd * buf * size_t *)
  | FS_LSEEK:  Z  ->  Z  ->  Z  -> fs_oper  (* fd * off_t * whence_t *)
  | FS_READ:  Z  ->  tt  ->  Z  -> fs_oper  (* fd * bufptr * size_t *)
  | FS_PWRITE:  Z  ->  list  ascii  ->  Z  ->  Z  -> fs_oper  (* fd * buf * size_t * off_t *)
  | FS_PREAD:  Z  ->  tt  ->  Z  ->  Z  -> fs_oper  (* fd * bufptr * size_t * off_t *)
  | FS_UMASK:  Z  -> fs_oper  (* file perm *)
  | FS_RENAME:  string  ->  string  -> fs_oper  (* old * new *)
  | FS_LINK:  string  ->  string  -> fs_oper  (* target * link *)
  | FS_SYMLINK:  string  ->  string  -> fs_oper  (* target * link *)
  | FS_READLINK:  string  ->  tt  ->  Z  -> fs_oper  (* path * buf * size *)
  | FS_STAT:  string  ->  tt  -> fs_oper  (* path * struct stat *)
  | FS_LSTAT:  string  ->  tt  -> fs_oper  (* path * struct stat *)
  | FS_TRUNCATE:  string  ->  Z  -> fs_oper  (* path * off_t *)
  | FS_UNLINK:  string  -> fs_oper  (* path *)
  | FS_CHMOD:  string  ->  Z  -> fs_oper  (* path * file perm *)
  | FS_CHOWN:  string  ->  Z  ->  Z  -> fs_oper  (* path * uid * gid *)
  | FS_CHDIR:  string  -> fs_oper  (* path *)
  | FS_OPENDIR:  string  -> fs_oper  (* path *)
  | FS_READDIR:  Z  -> fs_oper  (* DIR node *)
  | FS_REWINDDIR:  Z  -> fs_oper  (* DIR node *)
  | FS_CLOSEDIR:  Z  -> fs_oper  (* DIR node *)
  | FS_PRINTF:  list  ascii  (* fmt *) ->  list  ((ctype.ctype  * tt ) % type) -> fs_oper  (* args *)
  | FS_VPRINTF:  Z  (* fd *) ->  list  ascii  (* fmt *) ->  Z  -> fs_oper  (* va_list *)
  | FS_VSNPRINTF:  tt  ->  tt  ->  list  ascii  ->  Z  -> fs_oper .
Definition fs_oper_default: fs_oper  := FS_MKDIR string_default Z_default. (* NOTE: this is arguably not a fs operation *)

Inductive core_tau_step_kind : Type := 
  | TSK_Ccall:  symbol.sym  ->  list  tt  -> core_tau_step_kind 
  | TSK_Return:  symbol.sym  ->  option  tt   -> core_tau_step_kind 
  | TSK_Misc: core_tau_step_kind .
Definition core_tau_step_kind_default: core_tau_step_kind  := TSK_Ccall sym_default DAEMON.

Inductive core_step : Type := 
  | Step_action_request:  string  ->  core_runM  action_request  -> core_step 
  | Step_memop_request:  mem_common.memop  ->  list  core.value0  ->  mem_common.thread_id  ->  (core.value0  ->  thread_state ) -> core_step 
  | Step_tau:  string  ->  core_tau_step_kind  ->  core_runM  thread_state  -> core_step 
  | Step_eval:  string  ->  core_runM  thread_state  -> core_step 
  | Step_thread_done:  mem_common.thread_id  ->  core.value0  -> core_step 
(*  | Step_nd of string * list core_step *)
  | Step_blocked: core_step 
  | Step_error:  string  -> core_step 
  | Step_constrained:  string  ->  list  ((mem.mem_iv_constraint  * core_runM  thread_state ) % type) -> core_step 

  | Step_done:  core.value0  -> core_step 
  | Step_spawn_threads:  (core.expr  core_run_annotation  ->  thread_state ) ->  list  thread_state  -> core_step  (* initial states for the children *)
  
  | Step_fs:  thread_state  ->  fs_oper  -> core_step 
  
  | Step_bound:  core_runM  thread_state  -> core_step .
Definition core_step_default: core_step  := Step_action_request string_default DAEMON.
(* [?]: removed value specification. *)

Definition core_action_step  (arena_annots : list (annot )) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file1 : generic_file (unit ) (core_run_annotation )) (current_tid : nat ) (p0 : (option (nat ) *thread_state ) % type) (g : generic_paction (core_run_annotation ) (unit ) (symbol.sym ))  : core_step := 
  match ( (arena_annots,core_extern,mem_st,file1,current_tid,p0,g)) with
      ( arena_annots,  core_extern,  mem_st,  file1,  current_tid,  (parent_tid_opt,  th_st), ( Paction p( Action loc annots1 act))) =>
    let sb_before1 :=
  (* filter out actions from other threads *) apply (lem_set.map (@ snd _ _))
    (lem_set.filter
       (fun (p : (nat *nat ) % type) =>
          match ( (p) ) with ( (tid1,  _)) => beq_nat tid1 current_tid end)
       (sb_before  annots1)) in let dd_before1 := [] in let asw_before_ :=
  if has_sbBefore_on_thread current_tid annots1 then [] else
    apply (lem_set.map (@ snd _ _))
      (lem_set.filter
         (fun (p : (nat *nat ) % type) =>
            match ( (p) ) with ( (tid1,  _)) =>
              match ( parent_tid_opt) with | Some parent_tid =>
                beq_nat tid1 parent_tid | _ => false end end)
         (sb_before  annots1)) in
  let asw_before1 := (set_union_by (genericCompare nat_ltb beq_nat)
                        (asw_before  annots1) asw_before_) in
  match ( act) with | Create pe1 pe2 pref =>
    (* TODO: the russian doll pattern matching is because to to slow on tuples *)
    match ( pe1) with | Pexpr _ tt( PEconstrained xs1) =>
      BOOM "Create PEconstrained 1" | _ =>
      match ( pe2) with | Pexpr _ tt( PEconstrained xs2) =>
        BOOM "Create PEconstrained 2" | _ =>
        match ( (valueFromPexpr pe1, valueFromPexpr pe2)) with
              | (Some( Vobject( OVinteger ival)),  Some( Vctype ty)) =>
          Step_action_request "CreateRequest"
            ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
                (fun (create_aid : nat ) =>
                   e.core_run_return
                     (
                     CreateRequest loc sb_before1 dd_before1 asw_before1
                       create_aid current_tid pref ival ty None
                       (fun (ptr_val : tt ) =>
                          {[ {[ th_st with stack:= add_to_sb_stack
                                                     [(p, (current_tid, create_aid))]
                                                     (stack  (* TODO: remove for sequential !!! *) th_st)
                           ]} with arena:= Expr arena_annots
                                             (Epure
                                                (Pexpr [] tt
                                                   (PEval
                                                      (Vobject
                                                         (OVpointer ptr_val)))))  ]})
                     )) ) | (Some _,  Some _) =>
          Step_error
            ( String.append "found a create() with ill-typed operands ["
                (String.append (BOOM pref) "]")) | (None,  _) =>
          Step_eval "first operand of a Create"
            ( state_exception_undefined.stExceptUndef_bind
                (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
                (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                   e.core_run_return
                     {[ th_st with arena:= Expr arena_annots
                                             (Eaction
                                                (Paction p
                                                   (Action loc annots1
                                                      (Create pe1' pe2 pref))))
                      ]}) ) | (_,  None) =>
          Step_eval "second operand of a Create"
            ( state_exception_undefined.stExceptUndef_bind
                (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe2)
                (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                   e.core_run_return
                     {[ th_st with arena:=
                     Expr arena_annots
                       (Eaction
                          (Paction p
                             (Action loc annots1 (Create pe1 pe2' pref))))
                      ]}) ) end end end | CreateReadOnly pe1 pe2 pe3 pref =>
    match ( pe1) with | Pexpr _ tt( PEconstrained xs1) =>
      BOOM "CreateReadOnly PEconstrained 1" | _ =>
      match ( pe2) with | Pexpr _ tt( PEconstrained xs2) =>
        BOOM "CreateReadOnly PEconstrained 2" | _ =>
        match ( pe3) with | Pexpr _ tt( PEconstrained xs3) =>
          BOOM "CreateReadOnly PEconstrained 3" | _ =>
          match ( valueFromPexpr pe1) with | None =>
            Step_eval "first operand of a CreateReadOnly"
              ( state_exception_undefined.stExceptUndef_bind
                  (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
                  (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                     e.core_run_return
                       {[ th_st with arena:= Expr arena_annots
                                               (Eaction
                                                  (Paction p
                                                     (Action loc annots1
                                                        (CreateReadOnly 
                                                         pe1' pe2 pe3 
                                                         pref))))  ]}) )
            | Some cval1 =>
            match ( valueFromPexpr pe2) with | None =>
              Step_eval "second operand of a CreateReadOnly"
                ( state_exception_undefined.stExceptUndef_bind
                    (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe2)
                    (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                       e.core_run_return
                         {[ th_st with arena:=
                         Expr arena_annots
                           (Eaction
                              (Paction p
                                 (Action loc annots1
                                    (CreateReadOnly pe1 pe2' pe3 pref))))  ]})
                ) | Some cval2 =>
              match ( valueFromPexpr pe3) with | None =>
                Step_eval "third operand of a CreateReadOnly"
                  ( state_exception_undefined.stExceptUndef_bind
                      (e.wrapped_eval_pexpr2 th_st core_extern mem_st 
                       file1 pe3)
                      (fun (pe3' : generic_pexpr (unit ) (symbol.sym )) =>
                         e.core_run_return
                           {[ th_st with arena:=
                           Expr arena_annots
                             (Eaction
                                (Paction p
                                   (Action loc annots1
                                      (CreateReadOnly pe1 pe2 pe3' pref))))
                            ]}) ) | Some cval3 =>
                match ( (cval1, cval2)) with
                      | (Vobject( OVinteger ival),  Vctype ty) =>
                  match ( memValueFromValue
                            (ctype.Ctype [] (ctype.unatomic_ ty)) cval3) with
                        | Some mem_val =>
                    Step_action_request "CreateRequest"
                      ( state_exception_undefined.stExceptUndef_bind
                          e.fresh_action_id
                          (fun (create_aid : nat ) =>
                             e.core_run_return
                               (
                               CreateRequest loc sb_before1 dd_before1
                                 asw_before1 create_aid current_tid pref 
                               ival ty (Some mem_val)
                                 (fun (ptr_val : tt ) =>
                                    {[ {[ th_st with stack:= add_to_sb_stack
                                                               [(p, (current_tid, create_aid))]
                                                               (stack  (* TODO: remove for sequential !!! *) th_st)
                                     ]} with arena:= Expr arena_annots
                                                       (Epure
                                                          (Pexpr [] tt
                                                             (PEval
                                                                (Vobject
                                                                   (OVpointer
                                                                    ptr_val)))))  ]})
                               )) ) | None =>
                    Step_error
                      ( String.append ("")
                          (String.append "the value of a create_readonly("
                             (String.append
                                (BOOM (ctype.Ctype [] (ctype.unatomic_ ty)))
                                (String.append
                                   ") didn't match the lvalue type: "
                                   (BOOM cval3))))) end | _ =>
                  Step_error
                    ( String.append
                        "found a create() with ill-typed operands ["
                        (String.append (BOOM pref) "]")) end end end end end
      end end | Alloc0 pe1 pe2 pref =>
    (* TODO: doing an indirection in the pattern matching otherwise Lem diverges... *)
    match ( (pe1, pe2)) with
          | (Pexpr _ tt( PEconstrained xs1),  Pexpr _ tt( PEconstrained xs2)) =>
      BOOM "Alloc PEconstrained 1 and 2"
      | (Pexpr _ tt( PEconstrained xs1),  _) => BOOM "Alloc PEconstrained 1"
      | (_,  Pexpr _ tt( PEconstrained xs2)) => BOOM "Alloc PEconstrained 2"
      | _ =>
      match ( (valueFromPexpr pe1, valueFromPexpr pe2)) with
            | (Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
        Step_action_request "AllocRequest"
          ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
              (fun (alloc_aid : nat ) =>
                 e.core_run_return
                   (
                   AllocRequest loc sb_before1 dd_before1 asw_before1
                     alloc_aid current_tid pref ival1 ival2
                     (fun (ptr_val : tt ) =>
                        {[ {[ th_st with stack:= add_to_sb_stack
                                                   [(p, (current_tid, alloc_aid))]
                                                   (stack  (* TODO: remove for sequential !!! *) th_st)
                         ]} with arena:= Expr arena_annots
                                           (Epure
                                              (Pexpr [] tt
                                                 (PEval
                                                    (Vobject
                                                       (OVpointer ptr_val)))))  ]})
                   )) ) | (Some _,  Some _) =>
        Step_error "found a alloc() with ill-typed operands" | (None,  _) =>
        Step_eval "first operand of a Alloc"
          ( state_exception_undefined.stExceptUndef_bind
              (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
              (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                 e.core_run_return
                   {[ th_st with arena:=
                   Expr arena_annots
                     (Eaction
                        (Paction p
                           (Action loc annots1 (Alloc0 pe1' pe2 pref))))  ]})
          ) | (_,  None) =>
        Step_eval "second operand of a Alloc"
          ( state_exception_undefined.stExceptUndef_bind
              (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe2)
              (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                 e.core_run_return
                   {[ th_st with arena:=
                   Expr arena_annots
                     (Eaction
                        (Paction p
                           (Action loc annots1 (Alloc0 pe1 pe2' pref))))  ]})
          ) end end | Kill _( Pexpr _ tt( PEconstrained xs)) =>
    BOOM "Kill PEconstrained" | Kill is_dynamic pe =>
    match ( valueFromPexpr pe) with | Some( Vobject( OVpointer ptr_val)) =>
      Step_action_request "KillRequest"
        ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
            (fun (kill_aid : nat ) =>
               e.core_run_return
                 (
                 KillRequest loc sb_before1 dd_before1 asw_before1 kill_aid
                   current_tid is_dynamic ptr_val
                   {[
                   {[ th_st with stack:= add_to_sb_stack
                                           [(p, (current_tid, kill_aid))]
                                           (stack  (* TODO: remove for sequential !!! *) th_st)
                    ]} with arena:= Expr arena_annots
                                      (Epure (Pexpr [] tt (PEval Vunit)))  ]}
                 )) ) | Some _ =>
      Step_error "found a kill() with an ill-typed operand" | None =>
      Step_eval "operand of kill()"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe)
            (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p (Action loc annots1 (Kill is_dynamic pe'))))
                  ]}) ) end
  (*
    | Store (Pexpr _ () (PEconstrained xs1)) (Pexpr _ () (PEconstrained xs2)) (Pexpr _ () (PEconstrained xs3)) mo ->
        error "Store PEconstrained 1 and 2 and 3"
    | Store (Pexpr _ () (PEconstrained xs1)) (Pexpr _ () (PEconstrained xs2)) pe3 mo ->
        error "Store PEconstrained 1 and 2"
    | Store (Pexpr _ () (PEconstrained xs1)) pe2 (Pexpr _ () (PEconstrained xs3)) mo ->
        error "Store PEconstrained 1 and 3"
    | Store pe1 (Pexpr _ () (PEconstrained xs2)) (Pexpr _ () (PEconstrained xs3)) mo ->
        error "Store PEconstrained 2 and 3"
    | Store (Pexpr _ () (PEconstrained xs1)) pe2 pe3 mo ->
        error "Store PEconstrained 1"
    | Store pe1 (Pexpr _ () (PEconstrained xs2)) pe3 mo ->
        error "Store PEconstrained 2"
*)
    | Store0 is_locking pe1 pe2( Pexpr _ tt( PEconstrained xs3)) mo1 =>
    Step_constrained "Store"
      (
      List.map
        (fun (p0 : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
           match ( (p0) ) with ( (cs,  pe3)) => ( cs
           , e.core_run_return
               {[ th_st with arena:= Expr arena_annots
                                       (Eaction
                                          (Paction p
                                             (Action loc annots1
                                                (Store0 is_locking pe1 
                                                 pe2 pe3 mo1) )))  ]}) end )
        xs3 ) | Store0 is_locking pe1 pe2 pe3 mo1 =>
    match ( (valueFromPexpr pe1, valueFromPexpr pe2, valueFromPexpr pe3)) with
          | (Some( Vctype ty),  Some( Vobject( OVpointer ptr_val)),  Some cval) =>
      match ( cval) with
          (*
KKK


                | Vconstrained xs ->
                    (* TODO: the treatment of constrained() should be more uniform (instead of the current case by case)? *)
                    Step_constrained "Store" (
                      List.map (fun (cs, cval) ->
                        ( cs
                        , E.return <| th_st with
                            arena= Expr [] (Eaction (Paction p (Action loc annots
                                (Store (Caux.mk_value_pe (Vctype ty)) (Caux.mk_value_pe (Vobject (OVpointer ptr_val))) (Caux.mk_value_pe cval) mo)
                              )));
                          |> )
                      ) xs
                    )
*)
        | _ =>
        match ( memValueFromValue (ctype.Ctype [] (ctype.unatomic_ ty)) cval) with
              | Some mem_val =>
          Step_action_request "StoreRequest"
            ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
                (fun (store_aid : nat ) =>
                   e.core_run_return
                     (
                     StoreRequest loc sb_before1 dd_before1 asw_before1
                       store_aid current_tid mo1 ty is_locking ptr_val
                       mem_val
                       {[
                       {[ th_st with stack:= add_to_sb_stack
                                               [(p, (current_tid, store_aid))]
                                               (stack  (* TODO: remove for sequential !!! *) th_st)
                        ]} with arena:= Expr arena_annots
                                          (Epure (Pexpr [] tt (PEval Vunit)))  ]}
                     )) ) | None =>
          Step_error
            ( String.append ("")
                (String.append "the value of a store("
                   (String.append
                      (BOOM (ctype.Ctype [] (ctype.unatomic_ ty)))
                      (String.append ") didn't match the lvalue type: "
                         (BOOM cval))))) end end
      | (Some cval1,  Some cval2,  Some cval3) =>
      Step_error
        ( String.append "found a store() with ill-typed operands: "
            (String.append (BOOM cval1)
               (String.append " <-> "
                  (String.append (BOOM cval2)
                     (String.append " <-> " (BOOM cval3))))))
      | (None,  _,  _) =>
      Step_eval "first operand of a Store"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p
                         (Action loc annots1
                            (Store0 is_locking pe1' pe2 pe3 mo1))))  ]}) )
      | (_,  None,  _) =>
      Step_eval "second operand of a Store"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe2)
            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p
                         (Action loc annots1
                            (Store0 is_locking pe1 pe2' pe3 mo1))))  ]}) )
      | (_,  _,  None) =>
      Step_eval "third operand of a Store"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe3)
            (fun (pe3' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:= Expr arena_annots
                                         (Eaction
                                            (Paction p
                                               (Action loc annots1
                                                  (Store0 is_locking 
                                                   pe1 pe2 pe3' mo1))))  ]})
        ) end
  (*
    | Load (Pexpr _ () (PEconstrained xs1)) (Pexpr _ () (PEconstrained xs2)) mo ->
        error "Load PEconstrained 1 and 2"
    | Load (Pexpr _ () (PEconstrained xs1)) pe2 mo ->
        error "Load PEconstrained 1"
    | Load pe1 (Pexpr _ () (PEconstrained xs2)) mo ->
        error "Load PEconstrained 2"
*)
    | Load0 pe1 pe2 mo1 =>
    match ( (valueFromPexpr pe1, valueFromPexpr pe2)) with
          | (Some( Vctype ty),  Some( Vobject( OVpointer ptr_val))) =>
      Step_action_request "LoadRequest"
        ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
            (fun (load_aid : nat ) => let val_sym := symbol.fresh tt in
               e.core_run_return
                 (
                 LoadRequest loc sb_before1 dd_before1 asw_before1 load_aid
                   current_tid mo1 ty ptr_val val_sym
                   (fun (mem_val : tt ) =>
                      {[ {[ th_st with stack:= add_to_sb_stack
                                                 [(p, (current_tid, load_aid))]
                                                 (stack  (* TODO: remove for sequential !!! *) th_st)
                       ]} with arena:= (match ( valueFromMemValue mem_val) with
                                            (oTy,  cval) =>
                                          Expr arena_annots
                                            (Epure (Pexpr [] tt (PEval cval)))
                                        end)  ]}) )) ) | (Some _,  Some _) =>
      Step_error "found a load with ill-typed operands" | (None,  _) =>
      Step_eval "first operand of a Load"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p (Action loc annots1 (Load0 pe1' pe2 mo1))))
                  ]}) ) | (_,  None) =>
      Step_eval "second operand of a Load"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe2)
            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p (Action loc annots1 (Load0 pe1 pe2' mo1))))
                  ]}) ) end | RMW0 pe1 pe2 pe3 pe4 mo1 mo2 =>
    match ( (valueFromPexpr pe1, valueFromPexpr pe2, valueFromPexpr pe3, 
    valueFromPexpr pe4)) with
          | (Some( Vctype ty),  Some( Vobject( OVpointer ptr_val)),  Some cval_expected,  Some cval_desired) =>
      match ( (memValueFromValue ty cval_expected, memValueFromValue 
                                                   ty cval_desired)) with
            | (Some mval_expected,  Some mval_desired) =>
        Step_action_request "RMWRequest"
          ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
              (fun (rmw_aid : nat ) =>
                 e.core_run_return
                   (
                   RMWRequest loc sb_before1 dd_before1 asw_before1 rmw_aid
                     current_tid mo1 mo2 ty ptr_val mval_expected
                     mval_desired
                     {[
                     {[ th_st with stack:= add_to_sb_stack
                                             [(p, (current_tid, rmw_aid))]
                                             (stack  (* TODO: remove for sequential !!! *) th_st)
                      ]} with arena:= Expr arena_annots
                                        (Epure (Pexpr [] tt (PEval Vtrue)))  ]}
                   )) )
      (*
  | RMW of aid * tid * memory_order * location * cvalue * cvalue  (* first val = value read; second val = value written *)
*)
      (*
                    Step_action_request (
                      E.fresh_action_id >>= fun rmw_aid ->
                      E.fresh_symbol    >>= fun val_sym ->
                      E.return (
                        StoreRequest loc sb_before dd_before asw_before
                          store_aid current_tid mo ty ptr_val mem_val
                          <| th_st with
                            arena= Eskip (* Epure (PEval (objectValueFromMemValue mem_val)) *);
                            stack= (* add_to_sb_stack {(p, (current_tid, store_aid))} *) (* TODO: bring back for concurrency !!! *) th_st.stack;
                          |>
                      )
                    )
*)
        | _ =>
        Step_error
          ("one of the values of a rmw() didn't match the lvalue type: " (* ^
                      Pp.pp_ail_ctype (Core_aux.unproj_ctype ty) ^ " <-> " ^
                                Pp.stringFromCore_expr ((Epure (PEval cval_expected)) : Core.expr unit) ^ " <-> " ^
                                Pp.stringFromCore_expr ((Epure (PEval cval_desired)) : Core.expr unit) *) )
      end | (Some _,  Some _,  Some _,  Some _) =>
      Step_error "found a rmw with ill-typed operands"
      | (None,  _,  _,  _) =>
      Step_eval "first operand of a RMW"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p
                         (Action loc annots1 (RMW0 pe1' pe2 pe3 pe4 mo1 mo2))))
                  ]}) ) | (_,  None,  _,  _) =>
      Step_eval "second operand of a RMW"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe2)
            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p
                         (Action loc annots1 (RMW0 pe1 pe2' pe3 pe4 mo1 mo2))))
                  ]}) ) | (_,  _,  None,  _) =>
      Step_eval "third operand of a RMW"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe3)
            (fun (pe3' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p
                         (Action loc annots1 (RMW0 pe1 pe2 pe3' pe4 mo1 mo2))))
                  ]}) ) | (_,  _,  _,  None) =>
      Step_eval "fourth operand of a RMW"
        ( state_exception_undefined.stExceptUndef_bind
            (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe4)
            (fun (pe4' : generic_pexpr (unit ) (symbol.sym )) =>
               e.core_run_return
                 {[ th_st with arena:=
                 Expr arena_annots
                   (Eaction
                      (Paction p
                         (Action loc annots1 (RMW0 pe1 pe2 pe3 pe4' mo1 mo2))))
                  ]}) ) end
  (*
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vpointer ptr_val)) ->
              Step_action_request (
                E.fresh_action_id >>= fun load_aid ->
                E.fresh_symbol    >>= fun val_sym  ->
                E.return (
                  LoadRequest loc sb_before dd_before asw_before
                    load_aid current_tid mo ty ptr_val val_sym
                    (fun mem_val -> <| th_st with
                        arena= Epure (PEval (objectValueFromMemValue mem_val));
                        stack= (* add_to_sb_stack {(p, (current_tid, load_aid))} *) th_st.stack
                    |>)
                )
              )
          | (Just _, Just _) ->
              Step_error "found a load with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Load" (
                E.step_eval_pexpr file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1' pe2 mo)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Load" (
                E.step_eval_pexpr file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1 pe2' mo)))
                |>
              )
        end
*)
    | Fence0 mo1 =>
    Step_action_request "FenceRequest"
      ( state_exception_undefined.stExceptUndef_bind e.fresh_action_id
          (fun (fence_aid : nat ) =>
             e.core_run_return
               (
               FenceRequest loc sb_before1 dd_before1 asw_before1 fence_aid
                 current_tid mo1
                 {[
                 {[ th_st with stack:= add_to_sb_stack
                                         [(p, (current_tid, fence_aid))]
                                         (stack  (* TODO: remove for sequential !!! *) th_st)
                  ]} with arena:= Expr arena_annots
                                    (Epure (Pexpr [] tt (PEval Vunit)))  ]} ))
      ) (* TODO: CompareExchangeStrong *)
    | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 =>
    BOOM "WIP: CompareExchangeStrong"
    | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 =>
    BOOM "WIP: CompareExchangeWeak" | LinuxFence mo1 =>
    BOOM "WIP: LinuxFence" | LinuxStore pe1 pe2 pe3 mo1 =>
    BOOM "WIP: LinuxStore" | LinuxLoad pe1 pe2 mo1 => BOOM "WIP: LinuxLoad"
    | LinuxRMW pe1 pe2 pe3 mo1 => BOOM "WIP: LinuxRMW" | SeqRMW _ _ _ _ _ =>
    core_step_default (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 285, character 3 to line 737, character 5 *)
  (*
  | FenceRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * Mem_common.thread_id * Cmm.memory_order * ctype *
                    thread_state
*)
  end end.
(* [?]: removed value specification. *)

Definition core_thread_step2  (mem_st : mem.mem_state ) (file1 : generic_file (unit ) (core_run_annotation )) (core_extern : fmap (symbol.sym ) (symbol.sym )) (m : fmap (symbol.sym ) (object_value )) (current_tid : nat ) (p : (option (mem_common.thread_id ) *thread_state ) % type)  : list (core_step ):= 
  match ( (mem_st,file1,core_extern,m,current_tid,p)) with
      ( mem_st,  file1,  core_extern,  _,  (*concur_sym_map*) current_tid,  (parent_tid_opt,  th_st)) =>
    let one := (fun (z : core_step ) => [z]) in
  match ((arena  th_st)) with Expr arena_annots expr_ =>
    let maybe_loc := annot.get_loc arena_annots in
  let th_st := match ( maybe_loc) with | None => th_st | Some loc =>
                 {[ th_st with current_loc:= loc  ]} end in
  match ( (expr_,(stack  th_st))) with | (Eannot _ _,  _) =>
    BOOM "Core_run.core_thread_step2 ==> Eannot" | (Eexcluded _ _,  _) =>
    BOOM "Core_run.core_thread_step2 ==> Eexcluded"
  (*
    | (Eskip, Stack_empty) ->
        error "reached empty stack with an Eskip"
    
    | (Eskip, Stack_cons current_proc_opt cont sk') ->
(* -----------------------------------------
   <skip, ÃÂº.ÃÂºs, ÃÂ> --ÃÂ--> <ÃÂº(unit), ÃÂ.ÃÂºs, ÃÂ> *)
        one $ Step_tau "Eskip" TSK_Misc (
          E.return <| th_st with
            arena= apply_continuation cont (Expr arena_annots (Epure (Pexpr [] () (PEval Vunit))));
            stack= Stack_cons current_proc_opt [] sk'
          |>
        )
*)
    | (Ecase pe pat_es,  _) =>
    one
      match ( pe) with | Pexpr _ tt( PEconstrained xs) =>
        Step_constrained "Ecase"
          (
          List.map
            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (constrs,  pe')) => ( constrs
               , e.core_run_return
                   {[ th_st with arena:= Expr arena_annots (Ecase pe' pat_es)
                    ]}) end ) xs ) | Pexpr _ tt( PEval cval) =>
        match ( select_case subst_sym_expr cval pat_es) with | Some e' =>
          Step_tau "Ecase" TSK_Misc
            ( e.core_run_return {[ th_st with arena:= e'  ]} ) | None =>
          Step_error
            ( String.append "Ecase, mismatched ==> " (BOOM (arena  th_st)))
        end | _ =>
        Step_eval "Ecase"
          ( state_exception_undefined.stExceptUndef_bind
              (e.eval_pexpr2 th_st core_extern mem_st file1 pe)
              (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                 match (x) with | inl pe' =>
                   e.core_run_return
                     {[ th_st with arena:= Expr arena_annots
                                             (Ecase pe' pat_es)  ]}
                   | inr cval =>
                   e.core_run_return
                     {[ th_st with arena:= Expr arena_annots
                                             (Ecase (caux.mk_value_pe cval)
                                                pat_es)  ]} end) )
      (*

BEFORE EVAL_PEXPR2

              Step_eval "Ecase" (
                E.eval_pexpr th_st.current_loc mem_st file pe >>= fun cval ->
                E.return <| th_st with
                  arena= Expr [] (Ecase (Caux.mk_value_pe cval) pat_es)
                |>
              )
*)
      end | (Elet pat pe1 e2,  _) =>
    (*                      [| pe1 |] = v
   --------------------------------------------------------
   <let pat = pe1 in e2, ÃÂºs, ÃÂ> --ÃÂ--> <e2[pat \ v], ÃÂºs, ÃÂ> *)
    one
      match ( pe1) with | Pexpr _ tt( PEconstrained xs1) =>
        Step_constrained "Elet"
          (
          List.map
            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (cs,  pe1)) => ( cs
               , e.core_run_return
                   {[ th_st with arena:= Expr arena_annots (Elet pat pe1 e2)
                    ]}) end ) xs1 ) | _ =>
        Step_eval "Elet"
          ( state_exception_undefined.stExceptUndef_bind
              (e.eval_pexpr2 th_st core_extern mem_st file1 pe1)
              (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                 match (x) with | inl pe1' =>
                   e.core_run_return
                     {[ th_st with arena:= Expr arena_annots
                                             (Elet pat pe1' e2)  ]}
                   | inr cval =>
                   e.core_run_return
                     {[ {[ th_st with env:= update_env pat cval (env  th_st)
                      ]} with arena:= e2  ]} end) ) end
    | (Eif _ _ _,  Stack_empty) => BOOM "reached empty stack with an Eif"
    | (Eif pe1 e2 e3,  Stack_cons _ cont _) =>
    (*              [| pe1 |] = v    e' = e2 labels e2
   -----------------------------------------------------------------
                                           .- <e2, ÃÂºs>  IF v = true
   <if pe1 then e2 else e3, ÃÂºs, ÃÂ> --ÃÂ--> <
                                           '- <e3, ÃÂºs>  IF v = false *)
    apply one
      match ( caux.strip pe1) with | PEconstrained xs =>
        Step_constrained "Eif"
          (
          List.map
            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (constrs,  pe')) => ( constrs
               , e.core_run_return
                   {[ th_st with arena:= Expr arena_annots (Eif pe' e2 e3)
                    ]}) end ) xs ) | PEval Vtrue =>
        Step_tau "Eif (then)" TSK_Misc
          (
          (* TODO: should this labeled_conts be used somewhere? *)
          (* let labeled_conts =
                  Map.map (fun (sym_tys, e) ->
                    (sym_tys, apply_continuation cont e)
                  ) (collect_labeled_continuations e3) in *)
          e.core_run_return {[ th_st with arena:= e2  ]} ) | PEval Vfalse =>
        Step_tau "Eif (else)" TSK_Misc
          (
          (* TODO: should this labeled_conts be used somewhere? *)
          (* let labeled_conts =
                  Map.map (fun (sym_tys, e) ->
                    (sym_tys, apply_continuation cont e)
                  ) (collect_labeled_continuations e2) in *)
          e.core_run_return {[ th_st with arena:= e3  ]} ) | PEval _ =>
        Step_error
          "the first operand of an Eif didn't evaluated to a boolean" | _ =>
        Step_eval "Eif"
          ( state_exception_undefined.stExceptUndef_bind
              (e.wrapped_eval_pexpr2 th_st core_extern mem_st file1 pe1)
              (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                 e.core_run_return
                   {[ th_st with arena:= Expr arena_annots (Eif pe1' e2 e3)
                    ]}) )
      (*

BEFORE EVAL_PEXPR2

              Step_eval "Eif" (
                E.eval_pexpr th_st.current_loc mem_st file pe1 >>= fun cval ->
                E.return <| th_st with
                  arena= Expr [] (Eif (Caux.mk_value_pe cval) e2 e3)
                |>
              )
*)
      end | (Eccall annots1 ty pe pes,  sk) =>
    one
      match ( valueFromPexpr pe) with
            | Some( Vloaded( LVspecified( OVpointer pv))) =>
        let case_funptrval := (fun (psym : symbol.sym ) =>
                                 match ( valueFromPexprs pes) with
                                       | Some cvals => let mem_values :=
                                 match ( (fmap_lookup_by
                                            (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                               ordCompare sym1 sym2) 
                                          psym (funinfo  file1))) with
                                       | Some (_,  param_tys,  _,  _) =>
                                   apply
                                     (List.map
                                        (fun (p : (ctype.ctype *generic_value (symbol.sym )) % type) =>
                                           match ( (p) ) with
                                               ( (ty,  cval)) =>
                                             match ( core_aux.memValueFromValue
                                                       (ctype.Ctype []
                                                          (ctype.Pointer
                                                             ctype.no_qualifiers
                                                             ty)) cval) with
                                                   | Some mval => mval
                                               | None =>
                                               BOOM "Eccall memvalue" end end))
                                     (lem_list.zip
                                        (List.map (@ snd _ _) param_tys)
                                        cvals) | None =>
                                   apply BOOM
                                     (String.append "Eccall : function "
                                        (String.append
                                           match ( psym) with
                                               symbol.Symbol0 d n str_opt =>
                                             String.append "Symbol"
                                               (stringFromPair
                                                  lem_string_extra.stringFromNat
                                                  (fun (x_opt : option (string ) )=>
                                                     stringFromMaybe
                                                       (fun (s : string )=>
                                                          String.append 
                                                          """"
                                                            (String.append 
                                                             s """")) 
                                                     x_opt) (n, str_opt)) end
                                           " not found")) end in
                                 Step_tau "Eccall"
                                   (TSK_Ccall psym mem_values)
                                   ( state_exception_undefined.stExceptUndef_bind
                                       (seu.runEU
                                          (
                                          exception.except_bind
                                            (call_proc core_extern file1 
                                             psym cvals)
                                            exception_undefined.exception_undef_return
                                          ))
                                       (fun (p : (fmap (symbol.sym ) (value0 )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
                                          match ( (p) ) with
                                              ( (proc_env,  expr1)) =>
                                            (* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
                                          let a_expr := add_to_sb
                                                          (lem_set.map
                                                             (fun (z : (mem_common.thread_id *cmm_csem.aid ) % type) =>
                                                                (Pos, z))
                                                             (sb_before  annots1))
                                                          (* TODO: remove for sequential !!! *) expr1 in
                                          e.core_run_return
                                            {[ {[ {[ {[ th_st with env:= 
                                            proc_env :: (env  th_st)
                                             ]} with exec_loc:= push_exec_loc
                                                                  psym
                                                                  (exec_loc  th_st)  ]} with stack:= 
                                            push_empty_continuation
                                              (Some psym) sk  ]} with arena:= a_expr  ]}
                                          end) ) | None =>
                                   Step_eval "Eccall"
                                     (
                                     match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                                               ( 4) []
                                               (fun (u : unit ) =>
                                                  match ( (u) ) with ( tt) =>
                                                    "XX 16" end)) with tt =>
                                       state_exception_undefined.stExceptUndef_bind
                                         (e.step_eval_pexprs th_st
                                            core_extern mem_st file1 
                                          pes)
                                         (fun (pes' : list (generic_pexpr (unit ) (symbol.sym ))) =>
                                            e.core_run_return
                                              {[ th_st with arena:= Expr
                                                                    arena_annots
                                                                    (
                                                                    Eccall
                                                                    annots1
                                                                    ty 
                                                                    pe 
                                                                    pes')  ]})
                                     end ) end) in
      BOOM pv (fun ( _ : ctype.ctype ) => BOOM "null function pointer")
        case_funptrval
        (fun ( _ : option (Z ) ) (addr : Z ) =>
           (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
           match ( BOOM mem_st pv) with | Some sym1 => case_funptrval sym1
             | None =>
             BOOM
               ( String.append (lem_string_extra.stringFromInteger addr)
                   " does not point to a function (Eccall)") end)
        (fun ( _ : unit ) => BOOM "function pointer has an unspecified value")
        | Some cval =>
        Step_error
          ( String.append ("")
              (String.append
                 "the first argument of pcall() must evaluate to a cfunction, found: "
                 (String.append (BOOM cval) ""))) | None =>
        Step_eval "Eccall"
          (
          match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                  ( 4) []
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) => "XX 17" end)) with tt =>
            state_exception_undefined.stExceptUndef_bind
              (e.core_run_step_eval_pexpr th_st core_extern mem_st file1 pe)
              (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
                 e.core_run_return
                   {[ th_st with arena:= Expr arena_annots
                                           (Eccall annots1 ty pe' pes)  ]})
          end ) end | (Eproc annots1 nm pes,  sk) =>
    one
      match ( valueOrPEconstrainedFromPexprs pes) with
            | Some( inr ((i,  xs),  pes')) =>
        Step_constrained "Eproc"
          (
          List.map
            (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (constrs,  pe')) => ( constrs
               , e.core_run_return
                   {[ th_st with arena:= Expr arena_annots
                                           (Eproc annots1 nm
                                              (lem_list.update pes' i pe'))
                    ]}) end ) xs ) | Some( inl cvals) =>
        let charFromMValue := (fun (errmsg : string ) =>
                                 fun (x : generic_value (symbol.sym )) =>
                                   match (x) with
                                         | Vobject( OVinteger ival) =>
                                     match ( mem_aux.integerFromIntegerValue
                                               ival) with | Some n => 
                                     BOOM n | None => BOOM errmsg end | _ =>
                                     BOOM errmsg end) in
      let forceIntegerFromIntegerValue := (fun (errmsg : string ) (ival : tt ) =>
                                             match ( mem_aux.integerFromIntegerValue
                                                       ival) with | Some n =>
                                               n | None => BOOM errmsg end) in
      match ( nm) with | Sym psym =>
        Step_tau "Eproc" TSK_Misc
          ( state_exception_undefined.stExceptUndef_bind
              (seu.runEU
                 (
                 exception.except_bind
                   (call_proc core_extern file1 psym cvals)
                   exception_undefined.exception_undef_return ))
              (fun (p : (fmap (symbol.sym ) (value0 )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
                 match ( (p) ) with ( (proc_env,  expr1)) =>
                   (* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
                 let a_expr := add_to_sb
                                 (lem_set.map
                                    (fun (z : (mem_common.thread_id *cmm_csem.aid ) % type) =>
                                       (Pos, z)) (sb_before  annots1))
                                 (* TODO: remove for sequential !!! *) expr1 in
                 e.core_run_return
                   {[ {[ {[ {[ th_st with env:= proc_env :: (env  th_st)
                    ]} with exec_loc:= push_exec_loc psym (exec_loc  th_st)  ]} with stack:= 
                   push_empty_continuation (Some psym) sk  ]} with arena:= a_expr  ]}
                 end) )
      (* ----------------------------------------------------------- *)
      (* Cerberus headers <any.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "any_bounded_int") =>
        match ( cvals) with
              | [Vobject( OVinteger min_ival);  Vobject( OVinteger max_ival)] =>
          let min1 := forceIntegerFromIntegerValue "any_bounded_int" min_ival in
        let max1 := forceIntegerFromIntegerValue "any_bounded_int" max_ival in
        let any_ival := BOOM (BOOM min1 max1) in
        Step_tau "any_bounded_int" TSK_Misc
          (
          e.core_run_return
            {[ th_st with arena:= Expr arena_annots
                                    (Epure
                                       (caux.mk_specified_pe
                                          (caux.mk_value_pe
                                             (Vobject (OVinteger any_ival)))))  ]}
          ) | _ =>
          BOOM
            ( String.append
                "Core_run, builtin any_bounded_int arguments ==> "
                (stringFromList BOOM cvals)) end
      (* ----------------------------------------------------------- *)
      (* 7.21 Input/output <stdio.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "printf") =>
        match ( cvals) with | [Vlist _ fmt_cvals;  Vlist _ args_cvals] =>
          let fmt := List.map (charFromMValue "printf") fmt_cvals in
        let args_ptrvals := List.map
                              (fun (x : generic_value (symbol.sym )) =>
                                 match (x) with
                                       | Vtuple [Vctype ty;  Vobject( OVpointer ptr_val)] =>
                                   (ty, ptr_val) | _ =>
                                   BOOM
                                     "Core_run, printf the second argument should be a list of (ctype, pointer) pairs"
                                 end) args_cvals in
        apply (Step_fs th_st) (FS_PRINTF fmt args_ptrvals) | _ =>
          BOOM
            ( String.append
                "Core_run, printf giving arguments of wrong types ==> "
                (stringFromList BOOM cvals)) end
        | Impl( BuiltinFunction "vprintf") =>
        match ( cvals) with | [Vobject( OVinteger fd_ival); 
        Vlist _ fmt_cvals;  Vobject( OVinteger ap_ival)] =>
          let fd := forceIntegerFromIntegerValue "vprintf" fd_ival in
        let fmt := List.map (charFromMValue "vprintf") fmt_cvals in
        let ap := forceIntegerFromIntegerValue "vprintf" ap_ival in
        apply (Step_fs th_st) (FS_VPRINTF fd fmt ap) | _ =>
          BOOM
            ( String.append
                "Core_run, vprintf giving arguments of wrong types ==> "
                (stringFromList BOOM cvals)) end
        | Impl( BuiltinFunction "vsnprintf") =>
        match ( cvals) with | [Vobject( OVpointer ptrval); 
        Vobject( OVinteger size_ival);  Vlist _ fmt_cvals; 
        Vobject( OVinteger ap_ival)] =>
          let fmt := List.map (charFromMValue "vsnprintf") fmt_cvals in
        let ap := forceIntegerFromIntegerValue "vsnprintf" ap_ival in
        apply (Step_fs th_st) (FS_VSNPRINTF ptrval size_ival fmt ap) | _ =>
          BOOM
            ( String.append
                "Core_run, vsnprintf giving arguments of wrong types ==> "
                (stringFromList BOOM cvals)) end
        | Impl( BuiltinFunction "rename") =>
        match ( cvals) with
              | [Vlist _ oldpath_cvals;  Vlist _ newpath_cvals] =>
          let oldpath_chars := List.map (charFromMValue "rename")
                                 oldpath_cvals in
        let newpath_chars := List.map (charFromMValue "rename") newpath_cvals in
        apply (Step_fs th_st)
          (FS_RENAME (string_from_char_list oldpath_chars)
             (string_from_char_list newpath_chars)) | _ =>
          BOOM "Core_run, rename" end
      (* ----------------------------------------------------------- *)
      (* 7.5 Errors <errno.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "errno") =>
        match ( cvals) with | [] =>
          Step_tau "Ecase" TSK_Misc
            (
            e.core_run_return
              {[ th_st with arena:= Expr arena_annots
                                      (Epure
                                         (caux.mk_specified_pe
                                            (caux.mk_value_pe
                                               (Vobject
                                                  (OVpointer (errno  th_st))))))  ]}
            ) | _ => BOOM "wrong arguments for __builtin_errno" end
      (* ----------------------------------------------------------- *)
      (* 7.22 General utilities <stdlib.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "exit") =>
        (* TODO: it should close all open resources *) match ( cvals) with
              | [cval] => Step_done cval | _ =>
          BOOM
            ( String.append
                "Core_run, exit giving arguments of wrong types ==> "
                (stringFromList BOOM cvals)) end
      (* ----------------------------------------------------------- *)
      (* Posix <sys/stat.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "mkdir") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVinteger mode_ival)] =>
          let path_chars := List.map (charFromMValue "mkdir") path_cvals in
        let mode := forceIntegerFromIntegerValue "mkdir" mode_ival in
        apply (Step_fs th_st)
          (FS_MKDIR (string_from_char_list path_chars) mode) | _ =>
          BOOM "mkdir" end | Impl( BuiltinFunction "umask") =>
        match ( cvals) with | [Vobject( OVinteger mode_ival)] =>
          let mode := forceIntegerFromIntegerValue "umask" mode_ival in
        apply (Step_fs th_st) (FS_UMASK mode) | _ => BOOM "pread" end
        | Impl( BuiltinFunction "chmod") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVinteger mode_ival)] =>
          let path := List.map (charFromMValue "chmod") path_cvals in
        let mode := forceIntegerFromIntegerValue "chmod" mode_ival in
        apply (Step_fs th_st) (FS_CHMOD (string_from_char_list path) mode)
          | _ => BOOM "chmod" end | Impl( BuiltinFunction "chdir") =>
        match ( cvals) with | [Vlist _ path_cvals] =>
          let path := List.map (charFromMValue "chdir") path_cvals in
        apply (Step_fs th_st) (FS_CHDIR (string_from_char_list path)) | _ =>
          BOOM "chdir" end | Impl( BuiltinFunction "chown") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVinteger uid_ival);  Vobject( OVinteger gid_ival)] =>
          let path := List.map (charFromMValue "chown") path_cvals in
        let uid := forceIntegerFromIntegerValue "chown" uid_ival in
        let gid := forceIntegerFromIntegerValue "chown" gid_ival in
        apply (Step_fs th_st) (FS_CHOWN (string_from_char_list path) uid gid)
          | _ => BOOM "chown" end
      (* ----------------------------------------------------------- *)
      (* Posix <dirent.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "opendir") =>
        match ( cvals) with | [Vlist _ path_cvals] =>
          let path := List.map (charFromMValue "opendir") path_cvals in
        apply (Step_fs th_st) (FS_OPENDIR (string_from_char_list path))
          | _ => BOOM "opendir" end | Impl( BuiltinFunction "readdir") =>
        match ( cvals) with | [Vobject( OVinteger dir_ival)] =>
          let dir := forceIntegerFromIntegerValue "readdir" dir_ival in
        apply (Step_fs th_st) (FS_READDIR dir) | _ => BOOM "readdir" end
        | Impl( BuiltinFunction "rewinddir") =>
        match ( cvals) with | [Vobject( OVinteger dir_ival)] =>
          let dir := forceIntegerFromIntegerValue "rewinddir" dir_ival in
        apply (Step_fs th_st) (FS_REWINDDIR dir) | _ => BOOM "rewinddir" end
        | Impl( BuiltinFunction "closedir") =>
        match ( cvals) with | [Vobject( OVinteger dir_ival)] =>
          let dir := forceIntegerFromIntegerValue "closedir" dir_ival in
        apply (Step_fs th_st) (FS_CLOSEDIR dir) | _ => BOOM "closedir" end
      (* ----------------------------------------------------------- *)
      (* Posix <fctnl.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "open") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVinteger oflag_ival)] =>
          let path_chars := List.map (charFromMValue "open") path_cvals in
        let oflag := forceIntegerFromIntegerValue "open" oflag_ival in
        apply (Step_fs th_st)
          (FS_OPEN (string_from_char_list path_chars) oflag None) | _ =>
          BOOM "open" end
      (* ----------------------------------------------------------- *)
      (* Posix <unistd.h> *)
      (* ----------------------------------------------------------- *)
        | Impl( BuiltinFunction "close") =>
        match ( cvals) with | [Vobject( OVinteger fd_ival)] =>
          let fd := forceIntegerFromIntegerValue "close" fd_ival in
        apply (Step_fs th_st) (FS_CLOSE fd) | _ => BOOM "close" end
        | Impl( BuiltinFunction "write") =>
        match ( cvals) with
              | [Vobject( OVinteger fd_ival);  Vlist _ buf_cvals;  Vobject( OVinteger size_ival)] =>
          let buf := List.map (charFromMValue "write") buf_cvals in
        let fd := forceIntegerFromIntegerValue "write" fd_ival in
        let size := forceIntegerFromIntegerValue "write" size_ival in
        apply (Step_fs th_st) (FS_WRITE fd buf size) | _ => BOOM "write" end
        | Impl( BuiltinFunction "read") =>
        match ( cvals) with
              | [Vobject( OVinteger fd_ival);  Vobject( OVpointer bufptr);  Vobject( OVinteger size_ival)] =>
          let fd := forceIntegerFromIntegerValue "read" fd_ival in
        let size := forceIntegerFromIntegerValue "read" size_ival in
        apply (Step_fs th_st) (FS_READ fd bufptr size) | _ => BOOM "read" end
        | Impl( BuiltinFunction "pwrite") =>
        match ( cvals) with
              | [Vobject( OVinteger fd_ival);  Vlist _ buf_cvals;  Vobject( OVinteger size_ival);  Vobject( OVinteger off_ival)] =>
          let fd := forceIntegerFromIntegerValue "pwrite" fd_ival in
        let buf := List.map (charFromMValue "pwrite") buf_cvals in
        let size := forceIntegerFromIntegerValue "pwrite" size_ival in
        let off := forceIntegerFromIntegerValue "pwrite" off_ival in
        apply (Step_fs th_st) (FS_PWRITE fd buf size off) | _ =>
          BOOM "pwrite" end | Impl( BuiltinFunction "pread") =>
        match ( cvals) with
              | [Vobject( OVinteger fd_ival);  Vobject( OVpointer bufptr);  Vobject( OVinteger size_ival);  Vobject( OVinteger off_ival)] =>
          let fd := forceIntegerFromIntegerValue "pread" fd_ival in
        let size := forceIntegerFromIntegerValue "pread" size_ival in
        let off := forceIntegerFromIntegerValue "pread" off_ival in
        apply (Step_fs th_st) (FS_PREAD fd bufptr size off) | _ =>
          BOOM "pread" end | Impl( BuiltinFunction "link") =>
        match ( cvals) with
              | [Vlist _ oldpath_cvals;  Vlist _ newpath_cvals] =>
          let oldpath := List.map (charFromMValue "link") oldpath_cvals in
        let newpath := List.map (charFromMValue "link") newpath_cvals in
        apply (Step_fs th_st)
          (FS_LINK (string_from_char_list oldpath)
             (string_from_char_list newpath)) | _ => BOOM "link" end
        | Impl( BuiltinFunction "readlink") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVpointer ptr);  Vobject( OVinteger max_ival)] =>
          let path := List.map (charFromMValue "readlink") path_cvals in
        let max1 := forceIntegerFromIntegerValue "readlink" max_ival in
        apply (Step_fs th_st)
          (FS_READLINK (string_from_char_list path) ptr max1) | _ =>
          BOOM "readlink" end | Impl( BuiltinFunction "stat") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVpointer ptr)] =>
          let path := List.map (charFromMValue "readlink") path_cvals in
        apply (Step_fs th_st) (FS_STAT (string_from_char_list path) ptr)
          | _ => BOOM "stat" end | Impl( BuiltinFunction "lstat") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVpointer ptr)] =>
          let path := List.map (charFromMValue "readlink") path_cvals in
        apply (Step_fs th_st) (FS_LSTAT (string_from_char_list path) ptr)
          | _ => BOOM "lstat" end | Impl( BuiltinFunction "symlink") =>
        match ( cvals) with | [Vlist _ target_cvals;  Vlist _ lpath_cvals] =>
          let target := List.map (charFromMValue "symlink") target_cvals in
        let lpath := List.map (charFromMValue "symlink") lpath_cvals in
        apply (Step_fs th_st)
          (FS_SYMLINK (string_from_char_list target)
             (string_from_char_list lpath)) | _ => BOOM "symlink" end
        | Impl( BuiltinFunction "rmdir") =>
        match ( cvals) with | [Vlist _ path_cvals] =>
          let path := List.map (charFromMValue "rmdir") path_cvals in
        apply (Step_fs th_st) (FS_RMDIR (string_from_char_list path)) | _ =>
          BOOM "rmdir" end | Impl( BuiltinFunction "truncate") =>
        match ( cvals) with
              | [Vlist _ path_cvals;  Vobject( OVinteger len_ival)] =>
          let path_chars := List.map (charFromMValue "truncate") path_cvals in
        let len := forceIntegerFromIntegerValue "truncate" len_ival in
        apply (Step_fs th_st)
          (FS_TRUNCATE (string_from_char_list path_chars) len) | _ =>
          BOOM "truncate" end | Impl( BuiltinFunction "unlink") =>
        match ( cvals) with | [Vlist _ path_cvals] =>
          let path := List.map (charFromMValue "unlink") path_cvals in
        apply (Step_fs th_st) (FS_UNLINK (string_from_char_list path)) | _ =>
          BOOM "unlink" end | Impl( BuiltinFunction "lseek") =>
        match ( cvals) with
              | [Vobject( OVinteger fd_ival);  Vobject( OVinteger off_ival);  Vobject( OVinteger whence_ival)] =>
          let fd := forceIntegerFromIntegerValue "lseek" fd_ival in
        let off := forceIntegerFromIntegerValue "lseek" off_ival in
        let whence := forceIntegerFromIntegerValue "lseek" whence_ival in
        apply (Step_fs th_st) (FS_LSEEK fd off whence) | _ => BOOM "lseek"
        end (* NOTE: some GCC builtins needed by Hafnium *)
        | Impl( BuiltinFunction "ctz") =>
        match ( cvals) with | [Vobject( OVinteger n_ival)] =>
          let n' := BOOM (forceIntegerFromIntegerValue "ctz" n_ival) in
        Step_tau "Eproc __builtin_ctz" TSK_Misc
          (
          e.core_run_return
            {[ th_st with arena:= Expr arena_annots
                                    (Epure
                                       (caux.mk_specified_pe
                                          (caux.mk_integer_pe n')))  ]} )
          | _ => BOOM "ctz" end (* unknown *) | _ =>
        BOOM ( String.append "WIP: Eproc ==> " (BOOM (arena  th_st))) end
        | None =>
        Step_eval "Eproc"
          (
          match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                  ( 4) []
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) => "XX 18" end)) with tt =>
            state_exception_undefined.stExceptUndef_bind
              (e.step_eval_pexprs th_st core_extern mem_st file1 pes)
              (fun (pes' : list (generic_pexpr (unit ) (symbol.sym ))) =>
                 e.core_run_return
                   {[ th_st with arena:= Expr arena_annots
                                           (Eproc annots1 nm pes')  ]}) end )
      end | (Eaction pact,  _) =>
    apply one
      (core_action_step arena_annots core_extern mem_st file1 current_tid
         (parent_tid_opt, th_st) pact) | (Ememop memop1 pes,  _) =>
    one
      match ( valueFromPexprs pes) with | Some bTy_cvals =>
        Step_memop_request memop1 bTy_cvals current_tid
          (fun (cval : generic_value (symbol.sym )) =>
             {[ th_st with arena:= Expr arena_annots
                                     (Epure (Pexpr [] tt (PEval cval)))  ]} )
        | None =>
        Step_eval "Ememop"
          (
          match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                  ( 4) []
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) => "XX 19" end)) with tt =>
            state_exception_undefined.stExceptUndef_bind
              (state_exception_undefined.stExceptUndef_mapM
                 (e.core_run_eval_pexpr th_st core_extern mem_st file1) 
               pes)
              (fun (cval' : list (generic_value (symbol.sym ))) =>
                 let pes' := List.map caux.mk_value_pe cval' in
                 e.core_run_return
                   {[ th_st with arena:= Expr arena_annots
                                           (Ememop memop1 pes')  ]}) end )
      end | (Eunseq _,  Stack_empty) =>
    BOOM "reached empty stack with an Eunseq"
    | (Eunseq es,  Stack_cons current_proc_opt cont sk) =>
    match ( to_pures es) with | Some pes =>
      apply one
        (Step_tau "Eunseq pure" TSK_Misc
           (
           e.core_run_return
             {[ th_st with arena:= Expr arena_annots
                                     (Epure (caux.mk_tuple_pe pes))  ]} ))
      | None =>
      let is_wait := fun (x : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                       match (x) with | Expr _( Ewait _) => true | _ => false
                       end in
    if List.forallb
         (fun (e : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
            is_wait e ||
            negb
              ((maybeEqualBy classical_boolean_equivalence (to_pure e) None)))
         es then one Step_blocked else
      if false(*EXPERIMENTAL UNSEQ*) then [] else
        (* begin block *) let xs :=
        List.map
          (fun (p : (list (expr (core_run_annotation ))*generic_expr (core_run_annotation ) (unit ) (symbol.sym )*list (expr (core_run_annotation ))) % type) =>
             match ( (p) ) with ( (es1,  ej,  es2)) =>
               Step_tau "Eunseq" TSK_Misc
                 (
                 e.core_run_return
                   {[ {[ th_st with stack:= Stack_cons current_proc_opt
                                              (Kunseq arena_annots es1 es2 ::
                                               cont) sk  ]} with arena:= ej  ]}
                 ) end )
          (pickWith
             (fun (e : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                (maybeEqualBy classical_boolean_equivalence (to_pure e) None)
                && negb (is_wait e)) es) in
        if beq_nat (List.length xs) ( 0) then
          BOOM
            ( String.append "BOOM Core_run, Eunseq, empty list ==> "
                (BOOM (Expr arena_annots (Eunseq es)))) (* TODO: debug *)
        else xs (* end block *) end | (Ewseq _ _ _,  Stack_empty) =>
    BOOM "reached empty stack with an Ewseq"
    | (Ewseq pat e1 e2,  Stack_cons current_proc_opt cont sk) =>
    match ( fun (_: list domain) (_: unit -> string) := tt []
              (fun (u : unit ) =>
                 match ( (u) ) with ( tt) =>
                   "Core_run, Esseq ==> TODO negatives" end)) with tt =>
      one
        match ( e1) with
              | Expr e1_annots( Epure( Pexpr _ tt( PEconstrained xs1))) =>
          Step_constrained "Ewseq"
            (
            List.map
              (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                 match ( (p) ) with ( (cs,  pe1)) => ( cs
                 , e.core_run_return
                     {[ {[ th_st with stack:= Stack_cons current_proc_opt
                                                (Kwseq arena_annots pat e2 ::
                                                 cont) sk
                      ]} with arena:= Expr e1_annots (Epure pe1)  ]}) end )
              xs1 ) | Expr e1_annots( Epure pe1) =>
          (* evaluate the pure first operand and substitute into the second
                 if it's not constrained, otherwise put things back in place for
                 Step_constrained to do the branching *)
          Step_eval "Ewseq"
            ( state_exception_undefined.stExceptUndef_bind
                (e.eval_pexpr2 th_st core_extern mem_st file1 pe1)
                (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                   match (x) with | inl pe1' =>
                     e.core_run_return
                       {[ th_st with arena:= Expr arena_annots
                                               (Ewseq pat
                                                  (Expr e1_annots
                                                     (Epure pe1')) e2)  ]}
                     | inr cval1 =>
                     e.core_run_return
                       {[ {[ th_st with env:= update_env pat cval1
                                                (env  th_st)
                        ]} with arena:= e2  ]} end) ) | _ =>
          (* focus the execution on the first operand *) Step_tau "Ewseq"
            TSK_Misc
            (
            e.core_run_return
              {[ {[ th_st with stack:= Stack_cons current_proc_opt
                                         (Kwseq arena_annots pat e2 :: cont)
                                         sk  ]} with arena:= e1  ]} ) end end
    | (Esseq _ _ _,  Stack_empty) => BOOM "reached empty stack with an Esseq"
    | (Esseq pat e1 e2,  Stack_cons current_proc_opt cont sk) =>
    match ( fun (_: list domain) (_: unit -> string) := tt []
              (fun (u : unit ) =>
                 match ( (u) ) with ( tt) =>
                   "Core_run, Esseq ==> TODO negatives" end)) with tt =>
      one
        match ( e1) with
              | Expr e1_annots( Epure( Pexpr _ tt( PEconstrained xs1))) =>
          Step_constrained "Esseq"
            (
            List.map
              (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                 match ( (p) ) with ( (cs,  pe1)) => ( cs
                 , e.core_run_return
                     {[ {[ th_st with stack:= Stack_cons current_proc_opt
                                                (Ksseq arena_annots pat e2 ::
                                                 cont) sk
                      ]} with arena:= Expr e1_annots (Epure pe1)  ]}) end )
              xs1 ) | Expr e1_annots( Epure pe1) =>
          (* evaluate the pure first operand and substitute into the second
                 if it's not constrained, otherwise put things back in place for
                 Step_constrained to do the branching *)
          Step_eval "Esseq"
            (
            match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                      ( 4) []
                      (fun (u : unit ) =>
                         match ( (u) ) with ( tt) =>
                           String.append "Step_eval Esseq ==> pe1: "
                             (BOOM pe1) end )) with tt =>
              state_exception_undefined.stExceptUndef_bind
                (e.eval_pexpr2 th_st core_extern mem_st file1 pe1)
                (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                   match (x) with | inl pe1' =>
                     e.core_run_return
                       {[ th_st with arena:= Expr arena_annots
                                               (Esseq pat
                                                  (Expr e1_annots
                                                     (Epure pe1')) e2)  ]}
                     | inr cval1 =>
                     e.core_run_return
                       {[ {[ th_st with env:= update_env pat cval1
                                                (env  th_st)
                        ]} with arena:= e2  ]} end) end ) | _ =>
          (* focus the execution on the first operand *) Step_tau "Esseq"
            TSK_Misc
            (
            e.core_run_return
              {[ {[ th_st with stack:= Stack_cons current_proc_opt
                                         (Ksseq arena_annots pat e2 :: cont)
                                         sk  ]} with arena:= e1  ]} ) end end
    | (Esave _ _ _,  Stack_empty) => BOOM "reached empty stack with an Esave"
    | (Esave (sym1,  _) sym_bTy_pes e,  _) =>
    apply one
      (Step_eval "Esave"
         ( state_exception_undefined.stExceptUndef_bind
             (state_exception_undefined.stExceptUndef_foldM
                (fun (acc : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                   match ( (acc ,p) ) with ( acc ,  (sym1,  (bTy,  pe))) =>
                     state_exception_undefined.stExceptUndef_bind
                       (e.core_run_eval_pexpr th_st core_extern mem_st 
                        file1 pe)
                       (fun (cval : generic_value (symbol.sym )) =>
                          e.core_run_return (subst_sym_expr sym1 cval acc))
                   end ) e sym_bTy_pes)
             (fun (e' : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                e.core_run_return {[ th_st with arena:= e'  ]}) ))
    | (Erun _ _ _,  Stack_empty) => BOOM "reached empty stack with an Erun"
    | (Erun _ _ _,  Stack_cons None _ _) =>
    BOOM "found a Erun outside of a procedure"
    | (Erun annots1 sym1 pes,  Stack_cons( Some current_proc) cont sk) =>
    apply one
      (Step_tau "Erun" TSK_Misc
         (* begin block *) state_exception_undefined.stExceptUndef_bind
                             (state_exception_undefined.runSE
                                (state_exception.state_except_read
                                   (fun (st : core_run_state ) =>
                                      let proc_sym := match ( (fmap_lookup_by
                                                                 (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                                                    ordCompare
                                                                    sym1 
                                                                    sym2)
                                                                 current_proc
                                                                 core_extern)) with
                                                            | Some proc_sym =>
                                                        proc_sym | None =>
                                                        current_proc end in
                                      lem_maybe.bind
                                        ((fmap_lookup_by
                                            (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                               ordCompare sym1 sym2) 
                                          proc_sym (labeled  st)))
                                        ((fmap_lookup_by
                                            (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                               ordCompare sym1 sym2) 
                                          sym1)) )))
                             (fun (x : option ((list (symbol.sym )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) ) =>
                                match (x) with | None =>
                                  BOOM
                                    ( String.append
                                        "Erun couldn't resolve label: `"
                                        (String.append
                                           match ( sym1) with
                                               symbol.Symbol0 d n str_opt =>
                                             String.append "Symbol"
                                               (stringFromPair
                                                  lem_string_extra.stringFromNat
                                                  (fun (x_opt : option (string ) )=>
                                                     stringFromMaybe
                                                       (fun (s : string )=>
                                                          String.append 
                                                          """"
                                                            (String.append 
                                                             s """")) 
                                                     x_opt) (n, str_opt)) end
                                           (String.append "' for procedure `"
                                              (String.append
                                                 match ( current_proc) with
                                                     symbol.Symbol0 d n str_opt =>
                                                   String.append "Symbol"
                                                     (stringFromPair
                                                        lem_string_extra.stringFromNat
                                                        (fun (x_opt : option (string ) )=>
                                                           stringFromMaybe
                                                             (fun (s : string )=>
                                                                String.append
                                                                  """"
                                                                  (String.append
                                                                    s 
                                                                   """"))
                                                             x_opt)
                                                        (n, str_opt)) end 
                                               "'"))))
                                  | Some (syms,  cont_expr) =>
                                  let cont_expr' := List.fold_left
                                                      (fun (acc : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) (p : (symbol.sym *generic_pexpr (unit ) (symbol.sym )) % type) =>
                                                         match ( (acc ,p) ) with
                                                             ( acc ,  (sym1,  pe)) =>
                                                           unsafe_subst_sym_expr
                                                             sym1 pe 
                                                           acc end )
                                                      (lem_list.zip syms pes)
                                                      cont_expr in
                                e.core_run_return
                                  {[ {[ th_st with stack:= push_empty_continuation
                                                             (Some
                                                                current_proc)
                                                             sk
                                   ]} with arena:= cont_expr'  ]} end)
         (* end block *)) | (Epure( Pexpr _ tt( PEconstrained xs)),  _) =>
    apply one
      (Step_constrained "Epure"
         (
         List.map
           (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
              match ( (p) ) with ( (cs,  pe')) => ( cs
              , e.core_run_return
                  {[ th_st with arena:= Expr arena_annots (Epure pe')  ]})
              end ) xs ))
    | (Epure( Pexpr _ tt( PEval cval)),  Stack_empty) =>
    (* End of program execution *) one (Step_done cval)
    | (Epure pe,  Stack_empty) =>
    apply one
      (Step_eval "Epure"
         ( state_exception_undefined.stExceptUndef_bind
             (e.eval_pexpr2 th_st core_extern mem_st file1 pe)
             (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                match (x) with | inl pe' =>
                  e.core_run_return
                    {[ th_st with arena:= Expr arena_annots (Epure pe')  ]}
                  | inr cval =>
                  e.core_run_return
                    {[ th_st with arena:= Expr arena_annots
                                            (Epure (caux.mk_value_pe cval))  ]}
                end) )) | (Epure pe,  sk) =>
    one
      match ( valueFromPexpr pe) with | Some cval =>
        match ( sk) with | Stack_empty =>
          BOOM "impossible ==> Core_run.core_thread_step2"
          | Stack_cons _ [] Stack_empty =>
          (* reached the end of the execution of a thread. *)
          match ( parent_tid_opt) with | Some parent_tid =>
            Step_thread_done parent_tid cval | None =>
            (* this was the startup thread *) Step_done cval end
          | Stack_cons current_proc_opt []( Stack_cons parent_proc_opt cont sk') =>
          (* reached the end of the execution of a procedure. *) let tsk :=
        match ( current_proc_opt) with | Some psym =>
          match ( (fmap_lookup_by
                     (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                        ordCompare sym1 sym2) psym (funinfo  file1))) with
                | Some (ret_ty,  _,  _,  _) =>
            apply (TSK_Return psym) (core_aux.memValueFromValue ret_ty cval)
            | None => TSK_Misc end | None => TSK_Misc end in
        Step_tau "end of procedure" tsk
          (
          match ((env  th_st)) with | [] =>
            BOOM "end of proc, found an empty Core_run env" | _ :: env' =>
            e.core_run_return
              {[ {[ {[ th_st with env:= env'
               ]} with stack:= Stack_cons parent_proc_opt [] sk'  ]} with arena:= 
              apply_continuation cont
                (Expr arena_annots (Epure (caux.mk_value_pe cval)))  ]} end )
          | Stack_cons current_proc_opt cont sk' =>
          Step_tau "Epure" TSK_Misc
            (
            e.core_run_return
              {[ {[ th_st with stack:= Stack_cons current_proc_opt [] sk'
               ]} with arena:= apply_continuation cont
                                 (Expr arena_annots
                                    (Epure (caux.mk_value_pe cval)))  ]} )
          | Stack_cons2 _ _ _ =>
          core_step_default (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 1525, character 15 to line 1570, character 17 *)
        end | None =>
        Step_eval "Epure"
          ( state_exception_undefined.stExceptUndef_bind
              (e.eval_pexpr2 th_st core_extern mem_st file1 pe)
              (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                 match (x) with | inl pe' =>
                   e.core_run_return
                     {[ th_st with arena:= Expr arena_annots (Epure pe')  ]}
                   | inr cval =>
                   e.core_run_return
                     {[ th_st with arena:= Expr arena_annots
                                             (Epure (caux.mk_value_pe cval))  ]}
                 end) ) end | (End es,  _) =>
    (* -------------------------------------------
           <nd(e1, ..., eN), ÃÂºs, ÃÂ> --ÃÂ--> <ej, ÃÂºs, ÃÂ>    j Ã¢ÂÂ {1, ..., N} *)
    List.map
      (fun (e : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
         Step_tau "End" TSK_Misc
           (e.core_run_return {[ th_st with arena:= e  ]}) ) es
    | (Epar es,  _) =>
    (* TODO: doc *) apply one
      (Step_spawn_threads
         (fun (e : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
            {[ th_st with arena:= e  ]})
         (
         List.map
           (fun (e : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
              {|arena:= e;stack:= (push_empty_continuation None empty_stack);errno:= (
              BOOM ctype.signed_int);current_loc:=(current_loc  th_st);exec_loc:= (
              ELoc_normal []);env:=(env  th_st) |}) es )) | (Ewait _,  _) =>
    (* We don't do anything here. When a thread terminates, the driver
           substitute the corresponding wait in parent thread with the returned
           value. *)
    BOOM "Core_run, Ewait" | (Easeq _ _ _,  _) =>
    BOOM "Core_run must be called after Core_indet" | (Ebound e,  _) =>
    match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 4) 
            []
              (fun (u : unit ) =>
                 match ( (u) ) with ( tt) => "STEP Ebound" end )) with tt =>
      apply one
        (Step_bound ( e.core_run_return {[ th_st with arena:= e  ]} )) end
  (*
    | (Eskip, Stack_empty) ->
        error "reached empty stack with an Eskip"
    
    | (Eskip, Stack_cons current_proc_opt cont sk') ->
(* -----------------------------------------
   <skip, ÃÂº.ÃÂºs, ÃÂ> --ÃÂ--> <ÃÂº(unit), ÃÂ.ÃÂºs, ÃÂ> *)
        one $ Step_tau "Eskip" TSK_Misc (
          E.return <| th_st with
            arena= apply_continuation cont (Expr arena_annots (Epure (Pexpr [] () (PEval Vunit))));
            stack= Stack_cons current_proc_opt [] sk'
          |>
        )
*)
    | (Eif _ _ _, Stack_cons2 _ _ _) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 752, character 3 to line 1615, character 5 *)
  (*
    | (Eskip, Stack_empty) ->
        error "reached empty stack with an Eskip"
    
    | (Eskip, Stack_cons current_proc_opt cont sk') ->
(* -----------------------------------------
   <skip, ÃÂº.ÃÂºs, ÃÂ> --ÃÂ--> <ÃÂº(unit), ÃÂ.ÃÂºs, ÃÂ> *)
        one $ Step_tau "Eskip" TSK_Misc (
          E.return <| th_st with
            arena= apply_continuation cont (Expr arena_annots (Epure (Pexpr [] () (PEval Vunit))));
            stack= Stack_cons current_proc_opt [] sk'
          |>
        )
*)
    | (Eunseq _, Stack_cons2 _ _ _) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 752, character 3 to line 1615, character 5 *)
  (*
    | (Eskip, Stack_empty) ->
        error "reached empty stack with an Eskip"
    
    | (Eskip, Stack_cons current_proc_opt cont sk') ->
(* -----------------------------------------
   <skip, ÃÂº.ÃÂºs, ÃÂ> --ÃÂ--> <ÃÂº(unit), ÃÂ.ÃÂºs, ÃÂ> *)
        one $ Step_tau "Eskip" TSK_Misc (
          E.return <| th_st with
            arena= apply_continuation cont (Expr arena_annots (Epure (Pexpr [] () (PEval Vunit))));
            stack= Stack_cons current_proc_opt [] sk'
          |>
        )
*)
    | (Ewseq _ _ _, Stack_cons2 _ _ _) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 752, character 3 to line 1615, character 5 *)
  (*
    | (Eskip, Stack_empty) ->
        error "reached empty stack with an Eskip"
    
    | (Eskip, Stack_cons current_proc_opt cont sk') ->
(* -----------------------------------------
   <skip, ÃÂº.ÃÂºs, ÃÂ> --ÃÂ--> <ÃÂº(unit), ÃÂ.ÃÂºs, ÃÂ> *)
        one $ Step_tau "Eskip" TSK_Misc (
          E.return <| th_st with
            arena= apply_continuation cont (Expr arena_annots (Epure (Pexpr [] () (PEval Vunit))));
            stack= Stack_cons current_proc_opt [] sk'
          |>
        )
*)
    | (Esseq _ _ _, Stack_cons2 _ _ _) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 752, character 3 to line 1615, character 5 *)
  (*
    | (Eskip, Stack_empty) ->
        error "reached empty stack with an Eskip"
    
    | (Eskip, Stack_cons current_proc_opt cont sk') ->
(* -----------------------------------------
   <skip, ÃÂº.ÃÂºs, ÃÂ> --ÃÂ--> <ÃÂº(unit), ÃÂ.ÃÂºs, ÃÂ> *)
        one $ Step_tau "Eskip" TSK_Misc (
          E.return <| th_st with
            arena= apply_continuation cont (Expr arena_annots (Epure (Pexpr [] () (PEval Vunit))));
            stack= Stack_cons current_proc_opt [] sk'
          |>
        )
*)
    | (Erun _ _ _, Stack_cons2 _ _ _) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run.lem\", line 752, character 3 to line 1615, character 5 *)
  end end end.
