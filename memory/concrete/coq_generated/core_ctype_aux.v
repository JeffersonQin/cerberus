(* Generated by Lem from ocaml_generated/core_ctype_aux.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.


Require Import symbol.
Require Export symbol.
Require Import ailTypesAux.
Require Export ailTypesAux.

Require Import utils.
Require Export utils.
Require Import ctype.
Require Export ctype.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition get_membersDefs  (tag_sym : symbol.sym )  : tag_definition :=  
  apply(fromJust "Core_ctype_aux.get_membersDefs") (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym (DAEMON tt)).
(* [?]: removed value specification. *)

Definition get_structDef  (tag_sym : symbol.sym )  : list ((symbol.identifier *((qualifiers *ctype ) % type)) % type):= 
  match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym (DAEMON tt))) with 
    | Some( StructDef xs) =>
        xs
    | Some _ =>
        DAEMON
    | None =>
        DAEMON
  end.
(* [?]: removed value specification. *)

Definition get_unionDef  (tag_sym : symbol.sym )  : (((symbol.identifier *((qualifiers *ctype ) % type)) % type)*list ((symbol.identifier *((qualifiers *ctype ) % type)) % type)) % type:= 
  match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym (DAEMON tt))) with 
    | Some( UnionDef []) =>
        DAEMON
    | Some( UnionDef( x::xs)) =>
        (x, xs)
    | Some _ =>
        DAEMON
    | None =>
        DAEMON
  end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Program Fixpoint are_compatible0  (p : (qualifiers *ctype ) % type) (p0 : (qualifiers *ctype ) % type)  : bool := 
  match ( (p,p0)) with ( (qs1,  Ctype _ ty1),  (qs2,  Ctype _ ty2)) =>
    qualifiersEqual qs1 qs2 &&
    match ( (ty1, ty2)) with | (Void,  Void) => true
      | (Basic bty1,  Basic bty2) =>
      ailTypesAux.are_compatible (qs1, Ctype [] (Basic bty1))
        (qs2, Ctype [] (Basic bty2))
      | (Array elem_ty1 n1_opt,  Array elem_ty2 n2_opt) =>
      (* STD ÃÂ§6.7.6.2#6 *) are_compatible0 (no_qualifiers, elem_ty1)
        (no_qualifiers, elem_ty2) &&
      match ( (n1_opt, n1_opt)) with | (Some n1,  Some n2) => Z.eqb n1 n2
        | (Some _ ,  None) => true | (None,  Some _) => true
        | (None,  None) => true end
      | (Function _ (ret_qs1,  ret_ty1) params1 isVariadic1,  Function _ (ret_qs2,  ret_ty2) params2 isVariadic2) =>
      (* STD ÃÂ§6.7.6.3#15 *)
      (* TODO: when the two types do not both have a param list *)
      are_compatible0 (ret_qs1, ret_ty1) (ret_qs2, ret_ty2) &&
      (are_compatible_params0 params1 params2 &&
       Bool.eqb isVariadic1 isVariadic2)
      | (Pointer ref_qs1 ref_ty1,  Pointer ref_qs2 ref_ty2) =>
      (* STD ÃÂ§6.7.6.1#2 *) are_compatible0 (ref_qs1, ref_ty1)
        (ref_qs2, ref_ty2) | (Struct tag1,  Struct tag2) =>
      (* STD ÃÂ§6.2.7#1 *)
      (* TODO: being conservative here (aka STD compliant) *)
      if symbol.from_same_translation_unit tag1 tag2 then
        symbol.symbolEqual0 tag1 tag2 else
        (* TODO: temporary hack *) match ( tag1) with
            symbol.Symbol _ _ str_opt1 =>
          match ( tag2) with symbol.Symbol _ _ str_opt2 =>
            if (maybeEqualBy
                  (fun (left : string ) (right : string )=>
                     (string_equal left right)) str_opt1 str_opt2) then
              match ( (get_membersDefs tag1, get_membersDefs tag2)) with
                    | (StructDef xs1,  StructDef xs2) =>
                if negb (beq_nat (List.length xs1) (List.length xs2)) then
                  false else
                  List.forallb
                    (fun (p : (((symbol.identifier *((qualifiers *ctype ) % type)) % type)*((symbol.identifier *((qualifiers *ctype ) % type)) % type)) % type) =>
                       match ( (p) ) with
                           ( ((ident1,  (qs1,  ty1)),  (ident2,  (qs2,  ty2)))) =>
                         match ( ident1) with ( symbol.Identifier0 _ str1) =>
                           match ( ident2) with
                               ( symbol.Identifier0 _ str2) =>
                             (string_equal str1 str2) end end &&
                         are_compatible0 (qs1, ty1) (qs2, ty2) end )
                    (lem_list.zip xs1 xs2) | _ => DAEMON end else false end
        end | (Union tag1,  Union tag2) =>
      symbol.symbolEqual0
        (* STD ÃÂ§6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *) tag1 
      tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
      | (Atomic atom_ty1,  Atomic atom_ty2) =>
      are_compatible0 (no_qualifiers, atom_ty1) (no_qualifiers, atom_ty2)
      | _ =>
      (* TODO: we can't see Enum types here and there is some impl-def stuff *)
    false end end
with are_compatible_params_aux0  (acc : bool )  : (list ((qualifiers *ctype *bool ) % type)*list ((qualifiers *ctype *bool ) % type)) % type -> bool := 
  match ( (acc)) with ( acc) =>
    fun (x : (list ((qualifiers *ctype *bool ) % type)*list ((qualifiers *ctype *bool ) % type)) % type) =>
      match (x) with | ([],  []) => acc
        | (((qs1,  ty1,  _) :: params1), ( (qs2,  ty2,  _) :: params2)) =>
        are_compatible_params_aux0
          (
          (* NOTE(unsure): but as far as I can tell the twos parameters can differ
           on whether they have the register storage-class *)
          acc && are_compatible0 (qs1, ty1) (qs2, ty2) ) (params1, params2)
        | _ =>
        (* the list of params must have the same length to be compatible *)
      false end end
with are_compatible_params0  (params1 : list ((qualifiers *ctype *bool ) % type)) (params2 : list ((qualifiers *ctype *bool ) % type))  : bool := 
  match ( (params1,params2)) with ( params1,  params2) =>
    are_compatible_params_aux0 true (params1, params2) end.


(*
val tags_are_compatible: Symbol.sym -> Symbol.sym -> bool
let tags_are_compatible tag_sym1 tag_sym2 =
  let members_are_compatibles xs1 xs2 =
    if List.length xs1 <> List.length xs2 then
      false
    else
      List.all (fun ((ident1, ty1), (ident2, ty2)) ->
        ident1 = ident2 && 
      ) (List.combine xs1)
  
  if from_same_translation_unit tag_sym1 tag_sym2 then
    tag_sym1 = tag_sym2
  else
    (* TODO: temporary hack *)
    let Symbol.Symbol _ _ str_opt1 = tag_sym1 in
    let Symbol.Symbol _ _ str_opt2 = tag_sym2 in
    if str_opt1 = str_opt2 then
      match (get_membersDefs tag_sym1, get_membersDefs tag_sym2) with
        | (StructDef xs1, StructDef xs2) ->
            members_are_compatibles xs1 x2
        | (UnionDef xs1, UnionDef xs2) ->
            members_are_compatibles xs1 xs2
        | _ ->
            false
      end
    else
      false
*)

(*
  | StructDef of list (Symbol.identifier * ctype)
  | UnionDef of list (Symbol.identifier * ctype)
*)
