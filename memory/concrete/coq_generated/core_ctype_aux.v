(* Generated by Lem from ocaml_generated/core_ctype_aux.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.


Require Import symbol.
Require Export symbol.
Require Import cabs.
Require Export cabs.
Require Import ailTypesAux.
Require Export ailTypesAux.

Require Import utils.
Require Export utils.
Require Import ctype.
Require Export ctype.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition get_membersDefs  (tag_sym : symbol.sym )  : tag_definition :=  
  apply(fromJust "Core_ctype_aux.get_membersDefs") (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym (BOOM tt)).
(* [?]: removed value specification. *)

Definition get_structDef  (tag_sym : symbol.sym )  : list ((cabs.cabs_identifier *((qualifiers *ctype ) % type)) % type):= 
  match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym (BOOM tt))) with 
    | Some( StructDef xs) =>
        xs
    | Some _ =>
        BOOM ( String.append"Core_type.aux.get_structDef ("  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end
               "): found a union definition instead of a struct"))
    | None =>
        BOOM ( String.append"Core_type.aux.get_structDef ("  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end
               "): couldn't find a struct/union definition"))
  end.
(* [?]: removed value specification. *)

Definition get_unionDef  (tag_sym : symbol.sym )  : (((cabs.cabs_identifier *((qualifiers *ctype ) % type)) % type)*list ((cabs.cabs_identifier *((qualifiers *ctype ) % type)) % type)) % type:= 
  match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) tag_sym (BOOM tt))) with 
    | Some( UnionDef []) =>
        BOOM ( String.append"Core_type.aux.get_unionDef ("  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end
               "): found an empty union definition"))
    | Some( UnionDef( x::xs)) =>
        (x, xs)
    | Some _ =>
        BOOM ( String.append"Core_type.aux.get_unionDef ("  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end
               "): found a struct definition instead of a union"))
    | None =>
        BOOM ( String.append"Core_type.aux.get_unionDef ("  (String.append 
  match ( tag_sym) with symbol.Symbol0 d n str_opt =>
    String.append "Symbol"
      (stringFromPair lem_string_extra.stringFromNat
         (fun (x_opt : option (string ) )=>
            stringFromMaybe
              (fun (s : string )=> String.append """" (String.append s """"))
              x_opt) (n, str_opt)) end
               "): couldn't find a struct/union definition"))
  end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Program Fixpoint are_compatible0  (p : (qualifiers *ctype ) % type) (p0 : (qualifiers *ctype ) % type)  : bool := 
  match ( (p,p0)) with ( (qs1,  Ctype _ ty1),  (qs2,  Ctype _ ty2)) =>
    qualifiersEqual qs1 qs2 &&
    match ( (ty1, ty2)) with | (Void,  Void) => true
      | (Basic bty1,  Basic bty2) =>
      ailTypesAux.are_compatible (qs1, Ctype [] (Basic bty1))
        (qs2, Ctype [] (Basic bty2))
      | (Array elem_ty1 n1_opt,  Array elem_ty2 n2_opt) =>
      (* STD ÃÂ§6.7.6.2#6 *) are_compatible0 (no_qualifiers, elem_ty1)
        (no_qualifiers, elem_ty2) &&
      match ( (n1_opt, n1_opt)) with | (Some n1,  Some n2) => Z.eqb n1 n2
        | (Some _ ,  None) => true | (None,  Some _) => true
        | (None,  None) => true end
      | (Function _ (ret_qs1,  ret_ty1) params1 isVariadic1,  Function _ (ret_qs2,  ret_ty2) params2 isVariadic2) =>
      (* STD ÃÂ§6.7.6.3#15 *)
      (* TODO: when the two types do not both have a param list *)
      are_compatible0 (ret_qs1, ret_ty1) (ret_qs2, ret_ty2) &&
      (are_compatible_params0 params1 params2 &&
       Bool.eqb isVariadic1 isVariadic2)
      | (Pointer ref_qs1 ref_ty1,  Pointer ref_qs2 ref_ty2) =>
      (* STD ÃÂ§6.7.6.1#2 *) are_compatible0 (ref_qs1, ref_ty1)
        (ref_qs2, ref_ty2) | (Struct tag1,  Struct tag2) =>
      (* STD ÃÂ§6.2.7#1 *)
      (* TODO: being conservative here (aka STD compliant) *)
      if symbol.from_same_translation_unit tag1 tag2 then
        match ( (tag1, tag2)) with
              | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
          if Z.eqb (fun _: unit _: unit => 0 d1 d2)
               ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
            if nat_gteb (fun _: tt => 0 tt) ( 5) &&
               negb
                 ((maybeEqualBy
                     (fun (left : string ) (right : string )=>
                        (string_equal left right)) str_opt1 str_opt2)) then
              match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                        ( 5) []
                        (fun (u : unit ) =>
                           match ( (u) ) with ( tt) =>
                             String.append
                               "[Symbol.symbolEqual] suspicious equality ==> "
                               (String.append
                                  (stringFromMaybe
                                     (fun (s : string )=>
                                        String.append """"
                                          (String.append s """")) str_opt1)
                                  (String.append " <-> "
                                     (stringFromMaybe
                                        (fun (s : string )=>
                                           String.append """"
                                             (String.append s """")) 
                                      str_opt2))) end)) with tt => true end
            else true else false end else
        (* TODO: temporary hack *) match ( tag1) with
            symbol.Symbol _ _ str_opt1 =>
          match ( tag2) with symbol.Symbol _ _ str_opt2 =>
            if (maybeEqualBy
                  (fun (left : string ) (right : string )=>
                     (string_equal left right)) str_opt1 str_opt2) then
              match ( (get_membersDefs tag1, get_membersDefs tag2)) with
                    | (StructDef xs1,  StructDef xs2) =>
                if negb (beq_nat (List.length xs1) (List.length xs2)) then
                  false else
                  List.forallb
                    (fun (p : (((cabs.cabs_identifier *((qualifiers *ctype ) % type)) % type)*((cabs.cabs_identifier *((qualifiers *ctype ) % type)) % type)) % type) =>
                       match ( (p) ) with
                           ( ((ident1,  (qs1,  ty1)),  (ident2,  (qs2,  ty2)))) =>
                         match ( ident1) with
                             ( cabs.CabsIdentifier _ str1) =>
                           match ( ident2) with
                               ( cabs.CabsIdentifier _ str2) =>
                             (string_equal str1 str2) end end &&
                         are_compatible0 (qs1, ty1) (qs2, ty2) end )
                    (lem_list.zip xs1 xs2) | _ =>
                BOOM "TODO(msg): impossible" end else false end end
      | (Union tag1,  Union tag2) =>
      match ( ( (* STD ÃÂ§6.2.7#1 *)
      (* TODO: being conservative here (aka STD compliant) *) tag1, tag2)) with
            | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)
             ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt) ( 5) &&
             negb
               ((maybeEqualBy
                   (fun (left : string ) (right : string )=>
                      (string_equal left right)) str_opt1 str_opt2)) then
            match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                      ( 5) []
                      (fun (u : unit ) =>
                         match ( (u) ) with ( tt) =>
                           String.append
                             "[Symbol.symbolEqual] suspicious equality ==> "
                             (String.append
                                (stringFromMaybe
                                   (fun (s : string )=>
                                      String.append """"
                                        (String.append s """")) str_opt1)
                                (String.append " <-> "
                                   (stringFromMaybe
                                      (fun (s : string )=>
                                         String.append """"
                                           (String.append s """")) str_opt2)))
                         end)) with tt => true end else true else false end (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
      | (Atomic atom_ty1,  Atomic atom_ty2) =>
      are_compatible0 (no_qualifiers, atom_ty1) (no_qualifiers, atom_ty2)
      | _ =>
      (* TODO: we can't see Enum types here and there is some impl-def stuff *)
    false end end
with are_compatible_params_aux0  (acc : bool )  : (list ((qualifiers *ctype *bool ) % type)*list ((qualifiers *ctype *bool ) % type)) % type -> bool := 
  match ( (acc)) with ( acc) =>
    fun (x : (list ((qualifiers *ctype *bool ) % type)*list ((qualifiers *ctype *bool ) % type)) % type) =>
      match (x) with | ([],  []) => acc
        | (((qs1,  ty1,  _) :: params1), ( (qs2,  ty2,  _) :: params2)) =>
        are_compatible_params_aux0
          (
          (* NOTE(unsure): but as far as I can tell the twos parameters can differ
           on whether they have the register storage-class *)
          acc && are_compatible0 (qs1, ty1) (qs2, ty2) ) (params1, params2)
        | _ =>
        (* the list of params must have the same length to be compatible *)
      false end end
with are_compatible_params0  (params1 : list ((qualifiers *ctype *bool ) % type)) (params2 : list ((qualifiers *ctype *bool ) % type))  : bool := 
  match ( (params1,params2)) with ( params1,  params2) =>
    are_compatible_params_aux0 true (params1, params2) end.


(*
val tags_are_compatible: Symbol.sym -> Symbol.sym -> bool
let tags_are_compatible tag_sym1 tag_sym2 =
  let members_are_compatibles xs1 xs2 =
    if List.length xs1 <> List.length xs2 then
      false
    else
      List.all (fun ((ident1, ty1), (ident2, ty2)) ->
        ident1 = ident2 && 
      ) (List.combine xs1)
  
  if from_same_translation_unit tag_sym1 tag_sym2 then
    tag_sym1 = tag_sym2
  else
    (* TODO: temporary hack *)
    let Symbol.Symbol _ _ str_opt1 = tag_sym1 in
    let Symbol.Symbol _ _ str_opt2 = tag_sym2 in
    if str_opt1 = str_opt2 then
      match (get_membersDefs tag_sym1, get_membersDefs tag_sym2) with
        | (StructDef xs1, StructDef xs2) ->
            members_are_compatibles xs1 x2
        | (UnionDef xs1, UnionDef xs2) ->
            members_are_compatibles xs1 xs2
        | _ ->
            false
      end
    else
      false
*)

(*
  | StructDef of list (Cabs.cabs_identifier * ctype)
  | UnionDef of list (Cabs.cabs_identifier * ctype)
*)
