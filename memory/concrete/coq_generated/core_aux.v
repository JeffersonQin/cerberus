(* Generated by Lem from ocaml_generated/core_aux.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.
Require Import lem_show.
Require Export lem_show.
Require Import core.
Require Export core.
Require Import ctype.
Require Export ctype.
Require Import annot.
Require Export annot.
Require Import lem_map.
Require Export lem_map.
Require Import lem_map_extra.
Require Export lem_map_extra.

Require Import ailSyntax.
Require Export ailSyntax.
Require Import core_ctype_aux.
Require Export core_ctype_aux.

Require Import product.
Require Export product.
Require Import exception.
Require Export exception.
Require Import mem.
Require Export mem.
Require Import mem_common.
Require Export mem_common.
Require Import mem_aux.
Require Export mem_aux.


Require Import errors.
Require Export errors.


Require Import debug.
Require Export debug.
Require Import pp.
Require Export pp.


Require Import nondeterminism.
Require Export nondeterminism.

(* [?]: removed value specification. *)

Definition strip {sym ty : Type}  (g : generic_pexpr ty sym)  : generic_pexpr_ ty sym:= 
  match ( (g)) with (( Pexpr _ _ pexpr_)) => pexpr_ end.
(* [?]: removed value specification. *)

Definition strip_expr {a bty sym : Type}  (g : generic_expr a bty sym)  : generic_expr_ a bty sym:= 
  match ( (g)) with (( Expr _ expr_)) => expr_ end.
(* [?]: removed value specification. *)

Program Fixpoint core_object_type_of_ctype  (c : ctype )  : option (core_object_type ) := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Void => None | Basic( Integer _) => Some OTy_integer
      | Basic( Floating _) => Some OTy_floating | Array ty _ =>
      match ( core_object_type_of_ctype ty) with | Some oTy =>
        Some (OTy_array oTy) | None =>
        BOOM "Core_aux.core_object_type_of_ctype: Array found a Nothing" end
      | Function _ (_,  ret_ty) xs isVariadic =>
      BOOM "core_object_type_of_ctype: not core function object"
      | Pointer _ _ => Some OTy_pointer | Atomic ty =>
      core_object_type_of_ctype ty | Struct tag_sym =>
      Some (OTy_struct tag_sym) | Union tag_sym => Some (OTy_union tag_sym)
    end end.
(* [?]: removed value specification. *)

Definition oTy_of_bTy   : core_base_type  -> option (core_object_type ) :=  
  fun (x : core_base_type ) =>
    match (x) with | BTy_unit => None | BTy_boolean => None | BTy_ctype =>
      None | BTy_list _ => None | BTy_tuple _ => None | BTy_object oTy =>
      Some oTy | BTy_loaded oTy => Some oTy | BTy_storable => None end.
(* [?]: removed value specification. *)

Program Fixpoint objectValueFromMemValue  (mem_val : tt )  : (core_object_type *generic_object_value (symbol.sym )) % type:=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 6) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "objectValueFromMemValue ==> " (BOOM mem_val)
               end )) with tt =>
    BOOM mem_val
      (fun (ty : ctype ) =>
         BOOM "[Core_aux.objectValueFromMemValue] FOUND AN UNSPECIFIED MVAL")
      (fun ( _ : integerType ) ( _ : symbol.sym ) =>
         BOOM "[Core_aux.objectValueFromMemValue] concurrency read")
      (fun ( _ : integerType ) (ival : tt ) => (OTy_integer, OVinteger ival))
      (fun ( _ : floatingType ) (fval : tt ) =>
         (OTy_floating, OVfloating fval))
      (fun ( _ : ctype ) (ptr_val : tt ) => (OTy_pointer, OVpointer ptr_val))
      (fun (mem_vals : list (tt )) =>
         BOOM
           "[Core_aux.objectValueFromMemValue] Vspecified (OVarray (List.map objectValueFromMemValue mem_vals))")
      (fun (sym1 : symbol.sym ) (xs : list ((cabs.cabs_identifier *ctype *tt ) % type)) =>
         (OTy_struct sym1, OVstruct sym1 xs))
      (fun (sym1 : symbol.sym ) (ident : cabs.cabs_identifier ) (mem_val : tt ) =>
         (OTy_union sym1, OVunion sym1 ident mem_val)) end
with loadedValueFromMemValue  (mem_val : tt )   : ( core_object_type  * loaded_value ) % type:=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 6) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "loadedValueFromMemValue ==> " (BOOM mem_val)
               end )) with tt =>
    BOOM mem_val
      (fun (ty : ctype ) =>
         (fromJust "loadedValueFromMemValue" (core_object_type_of_ctype ty), 
         LVunspecified ty))
      (fun ( _ : integerType ) ( _ : symbol.sym ) =>
         BOOM "[Core_aux.loadedValueFromMemValue] concurrency read")
      (fun ( _ : integerType ) (ival : tt ) =>
         (OTy_integer, LVspecified (OVinteger ival)))
      (fun ( _ : floatingType ) (fval : tt ) =>
         (OTy_floating, LVspecified (OVfloating fval)))
      (fun ( _ : ctype ) (ptr_val : tt ) =>
         (OTy_pointer, LVspecified (OVpointer ptr_val)))
      (fun (mem_vals : list (tt )) =>
         match ( List.map loadedValueFromMemValue mem_vals) with | [] =>
           BOOM "[Core_aux.loadedValueFromMemValue] empty array"
           | (oTy,  lval) :: oTy_lvals =>
           if List.existsb
                (fun (p : (core_object_type *generic_loaded_value (symbol.sym )) % type) =>
                   match ( (p) ) with ( (oTy',  _)) =>
                     ((fun (x : core_object_type ) (y : core_object_type ) =>
                         negb (eq_core_object_type x y)) oTy oTy') end)
                oTy_lvals then
             BOOM "[Core_aux.loadedValueFromMemValue] heterogenous array"
           else
             (OTy_array oTy, LVspecified
                               (OVarray
                                  (lval :: List.map (@ snd _ _) oTy_lvals)))
         end)
      (fun (sym1 : symbol.sym ) (xs : list ((cabs.cabs_identifier *ctype *tt ) % type)) =>
         (OTy_struct sym1, LVspecified (OVstruct sym1 xs)))
      (fun (sym1 : symbol.sym ) (ident : cabs.cabs_identifier ) (mem_val : tt ) =>
         (OTy_union sym1, LVspecified (OVunion sym1 ident mem_val))) end.
(* [?]: removed value specification. *)

Definition valueFromMemValue  (mem_val : tt )  : (core_object_type *generic_value (symbol.sym )) % type:=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 6) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append "valueFromMemValue ==> " (BOOM mem_val) end )) with
      tt =>
    BOOM mem_val
      (fun (ty : ctype ) =>
         (fromJust "Core_aux.valueFromMemValue"
            (core_object_type_of_ctype ty), Vloaded (LVunspecified ty)))
      (fun ( _ : integerType ) ( _ : symbol.sym ) =>
         BOOM "[Core_aux.valueFromMemValue] concurrency read")
      (fun ( _ : integerType ) (ival : tt ) =>
         (OTy_integer, Vloaded (LVspecified (OVinteger ival))))
      (fun ( _ : floatingType ) (fval : tt ) =>
         (OTy_floating, Vloaded (LVspecified (OVfloating fval))))
      (fun ( _ : ctype ) (ptr_val : tt ) =>
         (OTy_pointer, Vloaded (LVspecified (OVpointer ptr_val))))
      (fun (mem_vals : list (tt )) =>
         match ( lem_list.unzip (List.map loadedValueFromMemValue mem_vals)) with
             (oTys,  lvals) =>
           let oTy := match ( oTys) with | [] =>
                        (* Something went wrong in the MLM *) BOOM
                          "Core_aux.valueFromMemValue ==> empty array"
                        | oTy :: _ => oTy end in
         (OTy_array oTy, Vloaded (LVspecified (OVarray lvals))) end)
      (fun (sym1 : symbol.sym ) (xs : list ((cabs.cabs_identifier *ctype *tt ) % type)) =>
         (OTy_struct sym1, Vloaded (LVspecified (OVstruct sym1 xs))))
      (fun (sym1 : symbol.sym ) (ident : cabs.cabs_identifier ) (mem_val : tt ) =>
         (OTy_union sym1, Vloaded (LVspecified (OVunion sym1 ident mem_val))))
  end.
(* [?]: removed value specification. *)

Program Fixpoint memValueFromValue  (c : ctype ) (cval : generic_value (symbol.sym ))  : option (tt ) := 
  match ( (c,cval)) with (( Ctype annots1 ty),  cval) =>
    match ( (ty, cval)) with | (_,  Vunit) => None | (_,  Vtrue) => None
      | (_,  Vfalse) => None | (_,  Vlist _ _) => None | (_,  Vtuple _) =>
      None | (_,  Vctype _) => None | (_,  Vloaded( LVunspecified ty')) =>
      Some (BOOM ty') (* TODO: check ty = ty'? *)
      | (Basic( Integer ity),  Vloaded( LVspecified( OVinteger ival))) =>
      Some (BOOM ity ival)
      | (Basic( Floating fty),  Vloaded( LVspecified( OVfloating fval))) =>
      Some (BOOM fty fval)
      | (Pointer _ ref_ty,  Vobject( OVpointer ptr_val)) =>
      (* TODO: not sure about this *) Some (BOOM ref_ty ptr_val)
      | (Pointer _ ref_ty,  Vloaded( LVspecified( OVpointer ptr_val))) =>
      Some (BOOM ref_ty ptr_val)
      | (Array elem_ty _,  Vloaded( LVspecified( OVarray lvals))) =>
      (* TODO: check that the sizes match? *) apply
        (maybe None (fun (z : list (tt )) => Some (BOOM z)))
        (List.fold_right
           (fun (lval : generic_loaded_value (symbol.sym )) (acc_opt : option (list (tt )) ) =>
              match ( (memValueFromValue elem_ty (Vloaded lval), acc_opt)) with
                    | (Some mem_val,  Some acc) => Some (mem_val :: acc)
                | _ => None end ) (Some []) lvals)
      | (Struct tag_sym1,  Vloaded( LVspecified( OVstruct tag_sym2 xs))) =>
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 1) []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     String.append "Comparing struct tag symbols: "
                       (String.append (symbol.show_raw tag_sym1)
                          (String.append " = " (symbol.show_raw tag_sym2)))
                   end)) with tt =>
        if core_ctype_aux.are_compatible0
             (no_qualifiers, Ctype [] (Struct tag_sym1))
             (no_qualifiers, Ctype [] (Struct tag_sym2)) then
          Some (BOOM tag_sym1 xs) else None end
      | (Union tag_sym1,  Vloaded( LVspecified( OVunion tag_sym2 ident mem_val))) =>
      if match ( (tag_sym1, tag_sym2)) with
               | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
           if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
             if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                negb
                  ((maybeEqualBy
                      (fun (left : string ) (right : string )=>
                         (string_equal left right)) str_opt1 str_opt2)) then
               match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                         ( 5) []
                         (fun (u : unit ) =>
                            match ( (u) ) with ( tt) =>
                              String.append
                                "[Symbol.symbolEqual] suspicious equality ==> "
                                (String.append
                                   (stringFromMaybe
                                      (fun (s : string )=>
                                         String.append """"
                                           (String.append s """")) str_opt1)
                                   (String.append " <-> "
                                      (stringFromMaybe
                                         (fun (s : string )=>
                                            String.append """"
                                              (String.append s """"))
                                         str_opt2))) end)) with tt => true
               end else true else false end then
        Some (BOOM tag_sym1 ident mem_val) else None | _ =>
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 5) []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     String.append "memValueFromValue("
                       (String.append (BOOM (Ctype [] ty))
                          (String.append ", " (String.append (BOOM cval) ")")))
                   end)) with tt => None end end end.
(* [?]: removed value specification. *)

Definition mk_empty_pat  (bTy : core_base_type )  : generic_pattern (unit ) (symbol.sym ):= 
  Pattern [] (CaseBase (None, bTy)).
(* [?]: removed value specification. *)

Definition mk_sym_pat  (sym1 : symbol.sym ) (bTy : core_base_type )  : generic_pattern (unit ) (symbol.sym ):= 
  Pattern [] (CaseBase (Some sym1, bTy)).
(* [?]: removed value specification. *)

Definition mk_tuple_pat   : list (generic_pattern (unit ) (symbol.sym )) -> generic_pattern (unit ) (symbol.sym ):=  
  fun (x : list (generic_pattern (unit ) (symbol.sym ))) =>
    match (x) with | [] =>
      BOOM "[Core_aux.mk_tuple_pat] called with |pats| = 0" | [pat] => pat
      | pats => Pattern [] (CaseCtor Ctuple pats) end.
(* [?]: removed value specification. *)

Definition mk_specified_pat  (pat : generic_pattern (unit ) (symbol.sym ))  : generic_pattern (unit ) (symbol.sym ):= 
  Pattern [] (CaseCtor Cspecified [pat]).
(* [?]: removed value specification. *)

Definition mk_unspecified_pat  (pat : generic_pattern (unit ) (symbol.sym ))  : generic_pattern (unit ) (symbol.sym ):= 
  Pattern [] (CaseCtor Cunspecified [pat]).
(* [?]: removed value specification. *)

Definition mk_sym_pe  (sym1 : symbol.sym )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEsym sym1).
(* [?]: removed value specification. *)

Definition mk_integer_pe  (n : Z )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (Vobject (OVinteger (BOOM n)))).
(* [?]: removed value specification. *)

Definition mk_floating_value_pe  (fval : tt )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (Vobject (OVfloating fval))).
(* [?]: removed value specification. *)

Definition mk_nullptr_pe  (ref_ty : ctype )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (Vobject (OVpointer (BOOM ref_ty)))).
(* [?]: removed value specification. *)

Definition mk_specified_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
    Pexpr [] tt (PEctor Cspecified [pe]).
(* [?]: removed value specification. *)

Definition mk_unspecified_pe  (ty : ctype )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (Vloaded (LVunspecified ty))).
(* [?]: removed value specification. *)

Definition mk_array_pe  (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor Carray pes).
(* [?]: removed value specification. *)

Definition mk_unit_pe   : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval Vunit).
(* [?]: removed value specification. *)

Definition mk_boolean_pe  (b : bool )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (if b then Vtrue else Vfalse)).
(* [?]: removed value specification. *)

Definition mk_ail_ctype_pe  (ty : ctype )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (Vctype ty)).
(* [?]: removed value specification. *)

Definition mk_ctype_pe  (ty : ctype )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval (Vctype ty)).
(* [?]: removed value specification. *)

Program Fixpoint mk_list_pe  (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt match ( pes) with 
    | [] =>
        PEctor (Cnil tt) []
    | pe :: pes' =>
        PEctor Ccons [pe; mk_list_pe pes']
  end.
(* [?]: removed value specification. *)

Definition mk_tuple_pe  (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor Ctuple pes).
(* [?]: removed value specification. *)

Definition mk_ivmax_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor Civmax [pe]).
(* [?]: removed value specification. *)

Definition mk_ivmin_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor Civmin [pe]).
(* [?]: removed value specification. *)

Definition mk_sizeof_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor Civsizeof [pe]).
(* [?]: removed value specification. *)

Definition mk_alignof_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor Civalignof [pe]).
(* [?]: removed value specification. *)

Definition mk_undef_pe  (loc : unit ) (ub : undefined.undefined_behaviour )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEundef loc ub).
(* [?]: removed value specification. *)

Definition mk_error_pe  (str : string ) (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEerror str pe).
(* [?]: removed value specification. *)

Definition mk_not_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEnot pe).
(* [?]: removed value specification. *)

Definition mk_op_pe  (bop : binop ) (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEop bop pe1 pe2).
(* [?]: removed value specification. *)

Definition mk_let_pe  (pat : generic_pattern (unit ) (symbol.sym )) (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PElet pat pe1 pe2).
(* [?]: removed value specification. *)

Definition mk_if_pe  (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym )) (pe3 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEif pe1 pe2 pe3).
(* [?]: removed value specification. *)

Definition mk_array_shift  (pe1 : generic_pexpr (unit ) (symbol.sym )) (ty : ctype ) (pe2 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEarray_shift pe1 ty pe2).
(* [?]: removed value specification. *)

Definition mk_member_shift_pe  (pe1 : generic_pexpr (unit ) (symbol.sym )) (tag_sym : symbol.sym ) (member_ident : cabs.cabs_identifier )  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEmember_shift pe1 tag_sym member_ident).
(* [?]: removed value specification. *)

Definition mk_case_pe  (pe : generic_pexpr (unit ) (symbol.sym )) (pat_pes : list ((generic_pattern (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEcase pe pat_pes).
(* [?]: removed value specification. *)

Definition mk_neg_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEop OpSub (mk_integer_pe((Zpred (Zpos (P_of_succ_nat 0))))) pe).
(* [?]: removed value specification. *)

Definition mk_struct_pe  (tag_sym : symbol.sym ) (xs : list ((cabs.cabs_identifier *generic_pexpr (unit ) (symbol.sym )) % type))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEstruct tag_sym xs).
(* [?]: removed value specification. *)

Definition mk_union_pe  (tag_sym : symbol.sym ) (memb_ident : cabs.cabs_identifier ) (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEunion tag_sym memb_ident pe).
(* [?]: removed value specification. *)

Definition mk_memberof_pe  (tag_sym : symbol.sym ) (memb_ident : cabs.cabs_identifier ) (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEmemberof tag_sym memb_ident pe).
(* [?]: removed value specification. *)

Definition mk_value_pe  (cval : generic_value (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEval cval).
(* [?]: removed value specification. *)

Definition mk_cfunction_pe  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEcfunction pe).
(* [?]: removed value specification. *)

Definition mk_std_pe  (std : string ) (g : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  match ( (std,g)) with ( std, ( Pexpr annot1 bty pe_)) =>
    Pexpr ((Astd std) :: annot1) bty pe_ end.
(* [?]: removed value specification. *)

Definition mk_std_undef_pe  (loc : unit ) (std : string ) (ub : undefined.undefined_behaviour )  : generic_pexpr (unit ) (symbol.sym ):=  
  apply(mk_std_pe std) (mk_undef_pe loc ub).
(* [?]: removed value specification. *)

Definition mk_std_pair_pe  (std : string ) (p : (generic_pexpr (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type)  : (generic_pexpr (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type:= 
  match ( (std,p)) with ( std,  (pe1,  pe2)) =>
    (mk_std_pe std pe1, mk_std_pe std pe2) end.
(* [?]: removed value specification. *)

Definition mk_call_pe  (nm : generic_name (symbol.sym )) (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEcall nm pes).
(* [?]: removed value specification. *)

Definition mk_are_compatible  (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEare_compatible pe1 pe2).
(* [?]: removed value specification. *)

Definition mk_undef_exceptional_condition  (loc : unit )  : generic_pexpr (unit ) (symbol.sym ):= 
  mk_std_undef_pe loc "§6.5#5" undefined.UB036_exceptional_condition.
(* [?]: removed value specification. *)

(*
val integer_encode_pe:     pexpr -> pexpr -> pexpr
val integer_decode_pe:     pexpr -> pexpr -> pexpr
*)

Definition bitwise_complement_pe  (pe1 : generic_pexpr (unit ) (symbol.sym )) (pe2 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  Pexpr [] tt (PEctor CivCOMPL [pe1; pe2]).
(*
  Pexpr [] () (PEcall (Impl Implementation.Bitwise_complement) [pe1; pe2])
*)
(*
let integer_encode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation.Integer__encode) [pe1; pe2])
let integer_decode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation.Integer__decode) [pe1; pe2])
*)

(* Some aliases for positive actions *)
Definition pcreate {a b c : Type} `{Default c}  (loc : unit ) (al : generic_pexpr b a) (ty : generic_pexpr b a) (pref : symbol.prefix )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (Create al ty pref)))).
Definition pcreate_readonly {a b c : Type} `{Default c}  (loc : unit ) (al : generic_pexpr b a) (ty : generic_pexpr b a) (init1 : generic_pexpr b a) (pref : symbol.prefix )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (CreateReadOnly  al ty init1 pref)))).
Definition palloc {a b c : Type} `{Default c}  (loc : unit ) (al : generic_pexpr b a) (e : generic_pexpr b a) (pref : symbol.prefix )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (Alloc0 al e pref)))).
Definition pkill {a b c : Type} `{Default c}  (loc : unit ) (is_dynamic : bool ) (x : generic_pexpr b a)  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (Kill is_dynamic x)))).
Definition pstore {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n : generic_pexpr b a) (mo1 : cmm_csem.memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (Store0 false ty x n mo1)))).
Definition pstore_lock {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n : generic_pexpr b a) (mo1 : cmm_csem.memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (Store0 true ty x n mo1)))).
Definition pload {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (mo1 : cmm_csem.memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (Load0 ty x mo1)))).
Definition prmw {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n1 : generic_pexpr b a) (n2 : generic_pexpr b a) (mo1 : cmm_csem.memory_order ) (mo2 : cmm_csem.memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (RMW0 ty x n1 n2 mo1 mo2)))).
Definition pcompare_exchange_strong {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n1 : generic_pexpr b a) (n2 : generic_pexpr b a) (mo1 : cmm_csem.memory_order ) (mo2 : cmm_csem.memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (
        Action loc default (CompareExchangeStrong ty x n1 n2 mo1 mo2)))).
Definition pcompare_exchange_weak {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n1 : generic_pexpr b a) (n2 : generic_pexpr b a) (mo1 : cmm_csem.memory_order ) (mo2 : cmm_csem.memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (
        Action loc default (CompareExchangeWeak ty x n1 n2 mo1 mo2)))).
Definition plinux_load {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (mo1 : linux.linux_memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (LinuxLoad ty x mo1)))).
Definition plinux_store {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n : generic_pexpr b a) (mo1 : linux.linux_memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (LinuxStore ty x n mo1)))).
Definition plinux_rmw {a b c : Type} `{Default c}  (loc : unit ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (n : generic_pexpr b a) (mo1 : linux.linux_memory_order )  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (LinuxRMW ty x n mo1)))).

Definition seq_rmw {a b c : Type} `{Default c}  (loc : unit ) (with_forward : bool ) (ty : generic_pexpr b a) (x : generic_pexpr b a) (sym1 : a) (upd : generic_pexpr b a)  : generic_expr c b a:= 
  Expr [] (Eaction (Paction Pos (Action loc default (SeqRMW with_forward ty x sym1 upd)))).





(* for a given Ctype returns the corresponding "zero" value *)
(*val     zeros: AilSyntax.tag_definition -> ctype -> pexpr *)
(* see Â§6.7.9#10 *)
Program Fixpoint zeros_aux  (tagDefs1 : fmap (symbol.sym ) (tag_definition )) (c : ctype )  : tt := 
  match ( (tagDefs1,c)) with ( tagDefs1, ( Ctype _ ty)) =>
    let zero_ival := BOOM ((Zpred (Zpos (P_of_succ_nat 0)))) in
  match ( ty) with | Basic( Integer ity) => BOOM ity zero_ival
    | Basic( Floating fty) => BOOM fty BOOM | Array elem_ty( Some n) =>
    BOOM (lem_list.replicate (Zabs_nat ( n)) (zeros_aux tagDefs1 elem_ty))
  (*
  Mem.array_mval (List.replicate (natFromInteger n) (Mem.integer_value_mval zero_ival))
*)
    | Pointer _ ref_ty => BOOM ref_ty (BOOM ref_ty) | Atomic ty' =>
    zeros_aux tagDefs1 ty' | Struct tag =>
    match ( (fmap_lookup_by
               (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                  ordCompare sym1 sym2) tag tagDefs1)) with
          | Some( StructDef ident_tys) =>
      BOOM tag
        (List.map
           (fun (p : (cabs.cabs_identifier *((qualifiers *ctype ) % type)) % type) =>
              match ( (p) ) with ( (ident,  (_,  ty))) =>
                (ident, ty, zeros_aux tagDefs1 ty) end) ident_tys) | _ =>
      BOOM "Core_aux.zeros_aux, not StructDef" end | Union tag =>
    match ( (fmap_lookup_by
               (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                  ordCompare sym1 sym2) tag tagDefs1)) with
          | Some( UnionDef( (ident,  (_,  ty'))::_)) =>
      BOOM tag ident (zeros_aux tagDefs1 ty') | _ =>
      BOOM "Core_aux.zeros_aux, not UnionDef" end | _ =>
    BOOM "Core_aux.zeros should only be called on complete types" end end.
(* [?]: removed value specification. *)

Definition zeros  (tagDefs1 : fmap (symbol.sym ) (tag_definition )) (ty : ctype )  : generic_pexpr (unit ) (symbol.sym ):= 
  (* TODO: yucky *)
  Pexpr [] tt
(*
    (PEval (Vobject (snd $ objectValueFromMemValue (zeros_aux ty))))
*)
    (PEval ( apply(@ snd _ _) (valueFromMemValue (zeros_aux tagDefs1 ty)))).
(* [?]: removed value specification. *)

Program Fixpoint mk_sseqs  (pat_es : list ((generic_pattern (unit ) (symbol.sym )*generic_expr (unit ) (unit ) (symbol.sym )) % type))  : generic_expr (unit ) (unit ) (symbol.sym ) -> generic_expr (unit ) (unit ) (symbol.sym ):= 
  fun (z : generic_expr (unit ) (unit ) (symbol.sym )) =>
  match ( pat_es) with 
    | [] =>
        z
    | (pat,  e) :: pat_es' =>
        Expr [] (Esseq pat e (mk_sseqs pat_es' z))
  end.



(*
(* val     mk_sseq: forall 'a. list (pattern * expr 'a) -> expr 'a *)
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

(* val     mk_sseq': forall 'a. list (pattern * expr 'a) -> expr 'a -> expr 'a *)
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end
*)


Definition mk_unseq {a b : Type}   : list (generic_expr b (unit ) a) -> generic_expr b (unit ) a:=  
  fun (x : list (generic_expr b (unit ) a)) =>
    match (x) with | [] => Expr [] (Epure (Pexpr [] tt (PEval Vunit)))
      | [e] => e | es => Expr [] (Eunseq es) end.
(* [?]: removed value specification. *)

Program Fixpoint mk_unit_sseq  (es : list (generic_expr (unit ) (unit ) (symbol.sym )))  : generic_expr (unit ) (unit ) (symbol.sym ) -> generic_expr (unit ) (unit ) (symbol.sym ):= 
  fun (z : generic_expr (unit ) (unit ) (symbol.sym )) =>
    match ( es) with 
      | [] =>
          z
(*
      | [e] ->
          e
*)
      | e::es' =>
          Expr [] (Esseq (mk_empty_pat BTy_unit) e (mk_unit_sseq es' z))
    end.
(* [?]: removed value specification. *)

Program Fixpoint mk_bTy_sseqs  (bTy_es : list ((core_base_type *generic_expr (unit ) (unit ) (symbol.sym )) % type))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  match ( bTy_es) with 
    | [] =>
        Expr [] (Epure (Pexpr [] tt (PEval Vunit)))
    | [(_,  e)] =>
        e
    | (bTy,  e) :: bTy_es' =>
        Expr [] (Esseq (mk_empty_pat bTy) e (mk_bTy_sseqs bTy_es'))
  end.

Program Fixpoint concat_sseq {a : Type}  (g : generic_expr a (unit ) (symbol.sym )) (e' : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  match ( (g,e')) with ( (Expr annot1 e_) as e,  e') =>
    match ( e_) with | Esseq pat e1 e2 =>
      Expr annot1 (Esseq pat e1 (concat_sseq e2 e'))
      | Epure( Pexpr _ _( PEval Vunit)) => e' | _ =>
      Expr [] (Esseq (mk_empty_pat BTy_unit) e e') end end.

Definition is_negative {a b c : Type}   : generic_expr c b a -> bool :=  
  fun (x : generic_expr c b a) =>
    match (x) with | Expr _( Eaction( Paction Neg _)) => true | _ => false
    end.

Definition is_negative_action {a b c : Type}   : generic_paction c b a -> bool :=  
  fun (x : generic_paction c b a) =>
    match (x) with |( Paction Neg _) => true | _ => false end.
(* [?]: removed value specification. *)

Definition valueFromPexpr   : generic_pexpr (unit ) (symbol.sym ) -> option (generic_value (symbol.sym )) :=  
  fun (x : generic_pexpr (unit ) (symbol.sym )) =>
    match (x) with | Pexpr _ tt( PEval cval) =>
      Some ((*flatten_constrained_value*) cval) | _ => None end.
(* [?]: removed value specification. *)

Definition valueFromPexprs  (pes : list (generic_pexpr (unit ) (symbol.sym )))  : option (list (generic_value (symbol.sym ))) := 
  List.fold_right (fun (pe : generic_pexpr (unit ) (symbol.sym )) (acc_opt : option (list (generic_value (symbol.sym ))) ) =>
    match ( (valueFromPexpr pe, acc_opt)) with 
      | (Some cval,  Some acc) =>
          Some (cval :: acc)
      | _ =>
          None
    end) (Some []) pes.
(* [?]: removed value specification. *)

Definition valueOrPEconstrainedFromPexpr  (pe : generic_pexpr (unit ) (symbol.sym ))  : option (sum (generic_value (symbol.sym )) (generic_pexpr (unit ) (symbol.sym ))) := 
  match ( pe) with 
    | Pexpr _ tt( PEval cval) =>
        Some (inl cval)
    | Pexpr _ tt( PEconstrained _) =>
        Some (inr pe)
    | _ =>
        None
  end.
(* [?]: removed value specification. *)

Definition valueOrPEconstrainedFromPexprs  (pes : list (generic_pexpr (unit ) (symbol.sym )))  : option (sum (list (generic_value (symbol.sym ))) ((((nat *list ((mem.mem_iv_constraint *generic_pexpr (unit ) (symbol.sym )) % type)) % type)*list (generic_pexpr (unit ) (symbol.sym ))) % type)) := 
  (@ snd _ _) (List.fold_right (
  fun (pe : generic_pexpr (unit ) (symbol.sym )) (p : (nat *option (sum (list (generic_value (symbol.sym ))) ((((nat *list ((mem.mem_iv_constraint *generic_pexpr (unit ) (symbol.sym )) % type)) % type)*list (generic_pexpr (unit ) (symbol.sym ))) % type)) ) % type) =>
    match ( (pe ,p) ) with ( pe ,  (i,  acc)) =>
      (Coq.Init.Peano.plus i ( 1), match ( (valueOrPEconstrainedFromPexpr pe, acc)) with
                                         | (Some( inl cval),  Some( inl cvals)) =>
                                     Some (inl (cval :: cvals))
                                     | (Some( inr( Pexpr _ tt( PEconstrained xs) as pe)),  Some( inl cvals)) =>
                                     Some
                                       (inr
                                          ((i, xs), (pe ::
                                                     (List.map
                                                        (fun (v : generic_value (symbol.sym )) =>
                                                           Pexpr [] tt
                                                             (PEval v)) 
                                                      cvals))))
                                     | (Some( inr pe),  Some( inr (i_xs,  pes))) =>
                                     Some (inr (i_xs, (pe :: pes))) | _ =>
                                     None end) end) ( 0, Some (inl [])) pes).
(* [?]: removed value specification. *)

Definition core_aux_to_integer  (pe : generic_pexpr (unit ) (symbol.sym ))  : option (Z ) := 
  match ( valueFromPexpr pe) with 
    | Some( Vobject( OVinteger ival)) =>
        mem_aux.integerFromIntegerValue ival
    | _ =>
        None
  end.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Program Fixpoint in_pattern  (sym1 : symbol.sym ) (g : generic_pattern (unit ) (symbol.sym ))  : bool := 
  match ( (sym1,g)) with ( sym1, ( Pattern _ pat)) =>
    match ( pat) with | CaseBase (sym_opt,  _) =>
      maybe false
        (fun (sym' : symbol.sym ) =>
           match ( (sym1, sym')) with
                 | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
             if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                  ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
               if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                  negb
                    ((maybeEqualBy
                        (fun (left : string ) (right : string )=>
                           (string_equal left right)) str_opt1 str_opt2)) then
                 match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                           ( 5) []
                           (fun (u : unit ) =>
                              match ( (u) ) with ( tt) =>
                                String.append
                                  "[Symbol.symbolEqual] suspicious equality ==> "
                                  (String.append
                                     (stringFromMaybe
                                        (fun (s : string )=>
                                           String.append """"
                                             (String.append s """")) 
                                      str_opt1)
                                     (String.append " <-> "
                                        (stringFromMaybe
                                           (fun (s : string )=>
                                              String.append """"
                                                (String.append s """"))
                                           str_opt2))) end)) with tt => true
                 end else true else false end) sym_opt | CaseCtor _ pats' =>
      List.existsb (in_pattern sym1) pats' end end.
(* [?]: removed value specification. *)

Program Fixpoint subst_sym_pexpr  (sym1 : symbol.sym ) (cval : generic_value (symbol.sym )) (g : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  match ( (sym1,cval,g)) with ( sym1,  cval, ( Pexpr annot1 bty pexpr_)) =>
    Pexpr annot1 bty
      match ( pexpr_) with | PEsym sym' =>
        if match ( (sym1, sym')) with
                 | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
             if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                  ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
               if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                  negb
                    ((maybeEqualBy
                        (fun (left : string ) (right : string )=>
                           (string_equal left right)) str_opt1 str_opt2)) then
                 match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                           ( 5) []
                           (fun (u : unit ) =>
                              match ( (u) ) with ( tt) =>
                                String.append
                                  "[Symbol.symbolEqual] suspicious equality ==> "
                                  (String.append
                                     (stringFromMaybe
                                        (fun (s : string )=>
                                           String.append """"
                                             (String.append s """")) 
                                      str_opt1)
                                     (String.append " <-> "
                                        (stringFromMaybe
                                           (fun (s : string )=>
                                              String.append """"
                                                (String.append s """"))
                                           str_opt2))) end)) with tt => true
                 end else true else false end then PEval cval else pexpr_
        | PEimpl _ => pexpr_ | PEval _ => pexpr_ | PEconstrained xs =>
        apply PEconstrained
          (List.map
             (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (constrs,  pe)) =>
                  (constrs, subst_sym_pexpr sym1 cval pe) end) xs)
        | PEundef _ _ => pexpr_ | PEerror str pe =>
        PEerror str (subst_sym_pexpr sym1 cval pe) | PEctor ctor1 pes =>
        PEctor ctor1 (List.map (subst_sym_pexpr sym1 cval) pes)
        | PEcase pe xs =>
        PEcase (subst_sym_pexpr sym1 cval pe)
          (List.map
             (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  pe)) => (pat, (
                if in_pattern sym1 pat then pe else
                  subst_sym_pexpr sym1 cval pe)) end ) xs)
        | PEarray_shift pe1 ty pe2 =>
        PEarray_shift (subst_sym_pexpr sym1 cval pe1) ty
          (subst_sym_pexpr sym1 cval pe2)
        | PEmember_shift pe tag_sym memb_ident =>
        PEmember_shift (subst_sym_pexpr sym1 cval pe) tag_sym memb_ident
        | PEnot pe => PEnot (subst_sym_pexpr sym1 cval pe)
        | PEop bop pe1 pe2 =>
        PEop bop (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) | PEstruct tag_sym xs =>
        PEstruct tag_sym
          (List.map
             (fun (p : (cabs.cabs_identifier *generic_pexpr (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (ident,  pe)) =>
                  (ident, subst_sym_pexpr sym1 cval pe) end) xs)
        | PEunion tag_sym ident pe =>
        PEunion tag_sym ident (subst_sym_pexpr sym1 cval pe)
        | PEcfunction pe => PEcfunction (subst_sym_pexpr sym1 cval pe)
        | PEmemberof tag_sym memb_ident pe =>
        PEmemberof tag_sym memb_ident (subst_sym_pexpr sym1 cval pe)
        | PEcall nm pes =>
        PEcall nm (List.map (subst_sym_pexpr sym1 cval) pes)
        | PElet pat pe1 pe2 =>
        PElet pat (subst_sym_pexpr sym1 cval pe1)
          (
          if in_pattern sym1 pat then pe2 else subst_sym_pexpr sym1 cval pe2)
        | PEif pe1 pe2 pe3 =>
        PEif (subst_sym_pexpr sym1 cval pe1) (subst_sym_pexpr sym1 cval pe2)
          (subst_sym_pexpr sym1 cval pe3) | PEis_scalar pe =>
        PEis_scalar (subst_sym_pexpr sym1 cval pe) | PEis_integer pe =>
        PEis_integer (subst_sym_pexpr sym1 cval pe) | PEis_signed pe =>
        PEis_signed (subst_sym_pexpr sym1 cval pe) | PEis_unsigned pe =>
        PEis_unsigned (subst_sym_pexpr sym1 cval pe) | PEbmc_assume pe =>
        PEbmc_assume (subst_sym_pexpr sym1 cval pe)
        | PEare_compatible pe1 pe2 =>
        PEare_compatible (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) end end.
(* [?]: removed value specification. *)

Program Fixpoint subst_sym_expr {a : Type}  (sym1 : symbol.sym ) (cval : generic_value (symbol.sym )) (g : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  match ( (sym1,cval,g)) with ( sym1,  cval, ( Expr annot1 expr_)) =>
    Expr annot1
      match ( expr_) with | Epure pe => Epure (subst_sym_pexpr sym1 cval pe)
        | Ememop memop1 pes =>
        Ememop memop1 (List.map (subst_sym_pexpr sym1 cval) pes)
        | Elet pat pe1 e2 =>
        Elet pat (subst_sym_pexpr sym1 cval pe1)
          (if in_pattern sym1 pat then e2 else subst_sym_expr sym1 cval e2)
        | Eif pe1 e2 e3 =>
        Eif (subst_sym_pexpr sym1 cval pe1) (subst_sym_expr sym1 cval e2)
          (subst_sym_expr sym1 cval e3) | Ecase pe pat_es =>
        Ecase (subst_sym_pexpr sym1 cval pe)
          (List.map
             (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  e)) => (pat, (
                if in_pattern sym1 pat then e else subst_sym_expr sym1 cval e))
                end ) pat_es) | Eccall annot1 pe1 pe2 pes =>
        Eccall annot1 (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2)
          (List.map (subst_sym_pexpr sym1 cval) pes) | Eproc annot1 nm pes =>
        Eproc annot1 nm (List.map (subst_sym_pexpr sym1 cval) pes)
        | Eaction pact => Eaction (subst_sym_paction sym1 cval pact)
        | Eunseq es => Eunseq (List.map (subst_sym_expr sym1 cval) es)
        | Ewseq pat e1 e2 =>
        Ewseq pat (subst_sym_expr sym1 cval e1)
          (if in_pattern sym1 pat then e2 else subst_sym_expr sym1 cval e2)
        | Esseq pat e1 e2 =>
        Esseq pat (subst_sym_expr sym1 cval e1)
          (if in_pattern sym1 pat then e2 else subst_sym_expr sym1 cval e2)
        | Easeq (sym',  bTy) act1 act2 =>
        Easeq (sym', bTy) (subst_sym_action sym1 cval act1)
          (* begin block *)
          if match ( (sym1, sym')) with
                   | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
               if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                    ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
                 if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                    negb
                      ((maybeEqualBy
                          (fun (left : string ) (right : string )=>
                             (string_equal left right)) str_opt1 str_opt2)) then
                   match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                             ( 5) []
                             (fun (u : unit ) =>
                                match ( (u) ) with ( tt) =>
                                  String.append
                                    "[Symbol.symbolEqual] suspicious equality ==> "
                                    (String.append
                                       (stringFromMaybe
                                          (fun (s : string )=>
                                             String.append """"
                                               (String.append s """"))
                                          str_opt1)
                                       (String.append " <-> "
                                          (stringFromMaybe
                                             (fun (s : string )=>
                                                String.append """"
                                                  (String.append s """"))
                                             str_opt2))) end)) with tt =>
                     true end else true else false end then act2 else
            subst_sym_action sym1 cval act2 (* end block *) | Ebound e =>
        Ebound (subst_sym_expr sym1 cval e) | Esave lab_sym sym_bTy_pes e =>
        let sym_bTy_pes' := List.map
                              (fun (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                                 match ( (p) ) with ( (z,  (bTy,  pe))) =>
                                   (z, (bTy, subst_sym_pexpr sym1 cval pe))
                                 end ) sym_bTy_pes in
      if List.existsb
           (fun (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
              match ( (p) ) with ( (z,  _)) =>
                match ( (sym1, z)) with
                      | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
                  if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                       ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
                    if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                       negb
                         ((maybeEqualBy
                             (fun (left : string ) (right : string )=>
                                (string_equal left right)) str_opt1 str_opt2)) then
                      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                                ( 5) []
                                (fun (u : unit ) =>
                                   match ( (u) ) with ( tt) =>
                                     String.append
                                       "[Symbol.symbolEqual] suspicious equality ==> "
                                       (String.append
                                          (stringFromMaybe
                                             (fun (s : string )=>
                                                String.append """"
                                                  (String.append s """"))
                                             str_opt1)
                                          (String.append " <-> "
                                             (stringFromMaybe
                                                (fun (s : string )=>
                                                   String.append """"
                                                     (String.append s """"))
                                                str_opt2))) end)) with tt =>
                        true end else true else false end end) sym_bTy_pes then
        match ( fun (_: list domain) (_: unit -> string) := tt []
                  (fun (u : unit ) =>
                     match ( (u) ) with ( tt) => "subst, Esave ==> shadowing"
                     end)) with tt =>
          (* TODO: check *) Esave lab_sym sym_bTy_pes' e end else
        Esave lab_sym sym_bTy_pes' (subst_sym_expr sym1 cval e)
        | Erun annot1 lab_sym pes =>
        Erun annot1 lab_sym (List.map (subst_sym_pexpr sym1 cval) pes)
        | End es => End (List.map (subst_sym_expr sym1 cval) es) | Epar es =>
        Epar (List.map (subst_sym_expr sym1 cval) es) | Ewait _ => expr_
        | Eannot xs e => Eannot xs (subst_sym_expr sym1 cval e)
        | Eexcluded n act => Eexcluded n (subst_sym_action sym1 cval act)
      (*
    | Eloc loc e ->
        Eloc loc (subst_sym_expr sym cval e)
    | Estd str e ->
        Estd str (subst_sym_expr sym cval e)
*)
      end end
with subst_sym_action_ {a : Type}  (sym1 : symbol.sym ) (cval : generic_value (symbol.sym ))  : generic_action_ (unit ) (symbol.sym ) -> generic_action_ (unit ) (symbol.sym ):= 
  match ( (sym1,cval)) with ( sym1,  cval) =>
    fun (x : generic_action_ (unit ) (symbol.sym )) =>
      match (x) with | Create pe1 pe2 pref =>
        Create (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) pref
        | CreateReadOnly pe1 pe2 pe3 pref =>
        CreateReadOnly (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) (subst_sym_pexpr sym1 cval pe3)
          pref | Alloc0 pe1 pe2 pref =>
        Alloc0 (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) pref | Kill b pe =>
        Kill b (subst_sym_pexpr sym1 cval pe) | Store0 b pe1 pe2 pe3 mo1 =>
        Store0 b (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) (subst_sym_pexpr sym1 cval pe3) 
        mo1 | Load0 pe1 pe2 mo1 =>
        Load0 (subst_sym_pexpr sym1 cval pe1) (subst_sym_pexpr sym1 cval pe2)
          mo1 | SeqRMW b pe1 pe2 sym' pe3 =>
        SeqRMW b (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) sym'
          (* begin block *)
          if match ( (sym1, sym')) with
                   | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
               if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                    ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
                 if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                    negb
                      ((maybeEqualBy
                          (fun (left : string ) (right : string )=>
                             (string_equal left right)) str_opt1 str_opt2)) then
                   match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                             ( 5) []
                             (fun (u : unit ) =>
                                match ( (u) ) with ( tt) =>
                                  String.append
                                    "[Symbol.symbolEqual] suspicious equality ==> "
                                    (String.append
                                       (stringFromMaybe
                                          (fun (s : string )=>
                                             String.append """"
                                               (String.append s """"))
                                          str_opt1)
                                       (String.append " <-> "
                                          (stringFromMaybe
                                             (fun (s : string )=>
                                                String.append """"
                                                  (String.append s """"))
                                             str_opt2))) end)) with tt =>
                     true end else true else false end then pe3 else
            subst_sym_pexpr sym1 cval pe3 (* end block *)
        | RMW0 pe1 pe2 pe3 pe4 mo1 mo2 =>
        RMW0 (subst_sym_pexpr sym1 cval pe1) (subst_sym_pexpr sym1 cval pe2)
          (subst_sym_pexpr sym1 cval pe3) (subst_sym_pexpr sym1 cval pe4) 
        mo1 mo2 | Fence0 mo1 => Fence0 mo1
        | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 =>
        CompareExchangeStrong (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) (subst_sym_pexpr sym1 cval pe3)
          (subst_sym_pexpr sym1 cval pe4) mo1 mo2
        | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 =>
        CompareExchangeWeak (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) (subst_sym_pexpr sym1 cval pe3)
          (subst_sym_pexpr sym1 cval pe4) mo1 mo2 | LinuxFence mo1 =>
        LinuxFence mo1 | LinuxStore pe1 pe2 pe3 mo1 =>
        LinuxStore (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) (subst_sym_pexpr sym1 cval pe3) 
        mo1 | LinuxLoad pe1 pe2 mo1 =>
        LinuxLoad (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) mo1 | LinuxRMW pe1 pe2 pe3 mo1 =>
        LinuxRMW (subst_sym_pexpr sym1 cval pe1)
          (subst_sym_pexpr sym1 cval pe2) (subst_sym_pexpr sym1 cval pe3) 
        mo1 end end
with subst_sym_action {a : Type}  (sym1 : symbol.sym ) (cval : generic_value (symbol.sym )) (g : generic_action a (unit ) (symbol.sym ))  : generic_action a (unit ) (symbol.sym ):= 
  match ( (sym1,cval,g)) with ( sym1,  cval, ( Action loc bs act_)) =>
    Action loc bs (subst_sym_action_ sym1 cval act_) end
with subst_sym_paction {a : Type}  (sym1 : symbol.sym ) (cval : generic_value (symbol.sym )) (g : generic_paction a (unit ) (symbol.sym ))  : generic_paction a (unit ) (symbol.sym ):= 
  match ( (sym1,cval,g)) with ( sym1,  cval, ( Paction p act)) =>
    Paction p (subst_sym_action sym1 cval act) end.
(* [?]: removed value specification. *)

Program Fixpoint subst_pattern_val {a : Type}  (g : generic_pattern (unit ) (symbol.sym )) (cval : generic_value (symbol.sym )) (expr1 : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  match ( (g,cval,expr1)) with (( Pattern _ pat),  cval,  expr1) =>
    match ( (pat, cval)) with | (CaseBase (None,  _),  _) =>
      (* e[_ \ v] = e *) expr1 | (CaseBase (Some sym1,  _),  _) =>
      (* e[sym \ v] *) subst_sym_expr sym1 cval expr1
      | (CaseCtor( Cnil tt) [],  Vlist _ []) => (* empty list (value) *)
    expr1 | (CaseCtor Ccons [pat1;  pat2],  Vlist bTy_elem( cval1::cvals)) =>
      (* populated list (value) *) apply (subst_pattern_val pat1 cval1)
        (subst_pattern_val pat2 (Vlist bTy_elem cvals) expr1)
      | (CaseCtor Ctuple pats',  Vtuple cvals) =>
      List.fold_right
        (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_value (symbol.sym )) % type) (acc : generic_expr a (unit ) (symbol.sym )) =>
           match ( (p ,acc) ) with ( (pat',  cval') ,  acc) =>
             subst_pattern_val pat' cval' acc end ) expr1
        (lem_list.zip pats' cvals)
      | (CaseCtor Cspecified [pat'],  Vloaded( LVspecified oval)) =>
      subst_pattern_val pat' (Vobject oval) expr1
      | (CaseCtor Cunspecified [pat'],  Vloaded( LVunspecified ty)) =>
      subst_pattern_val pat' (Vctype ty) expr1 | (CaseCtor ctor1 pats,  _) =>
      let str_ctor := match ( ctor1) with | Cnil _ => "nil" | Ccons => "cons"
                        | Ctuple => "tuple" | Carray => "array" | Civmax =>
                        "ivmax" | Civmin => "ivmin" | Civsizeof => "ivsizeof"
                        | Civalignof => "ivalignof" | CivCOMPL => "ivCOMPL"
                        | CivAND => "ivAND" | CivOR => "ivOR" | CivXOR =>
                        "ivXOR" | Cspecified => "specified" | Cunspecified =>
                        "unspecified" | Cfvfromint => "fvfromint"
                        | Civfromfloat => "ivfromfloat" end in
    BOOM
      ( String.append "WIP: Core_aux.subst_pattern_val ==> ctor= "
          (String.append str_ctor
             (String.append ", |pats|= "
                (String.append
                   (lem_string_extra.stringFromNat (List.length pats))
                   (String.append " -- " (BOOM cval)))))) end end.
(* [?]: removed value specification. *)

Program Fixpoint unsafe_subst_sym_pexpr  (sym1 : symbol.sym ) (g : generic_pexpr (unit ) (symbol.sym )) (g0 : generic_pexpr (unit ) (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  match ( (sym1,g,g0)) with
      ( sym1,  Pexpr annot1 bty pe_' as pe', ( Pexpr _ _ pe_)) =>
    Pexpr annot1 bty
      match ( pe_) with | PEsym sym' =>
        if match ( (sym1, sym')) with
                 | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
             if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                  ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
               if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                  negb
                    ((maybeEqualBy
                        (fun (left : string ) (right : string )=>
                           (string_equal left right)) str_opt1 str_opt2)) then
                 match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                           ( 5) []
                           (fun (u : unit ) =>
                              match ( (u) ) with ( tt) =>
                                String.append
                                  "[Symbol.symbolEqual] suspicious equality ==> "
                                  (String.append
                                     (stringFromMaybe
                                        (fun (s : string )=>
                                           String.append """"
                                             (String.append s """")) 
                                      str_opt1)
                                     (String.append " <-> "
                                        (stringFromMaybe
                                           (fun (s : string )=>
                                              String.append """"
                                                (String.append s """"))
                                           str_opt2))) end)) with tt => true
                 end else true else false end then pe_' else pe_
        | PEimpl _ => pe_ | PEval _ => pe_ | PEconstrained xs =>
        apply PEconstrained
          (List.map
             (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (constrs,  pe)) =>
                  (constrs, unsafe_subst_sym_pexpr sym1 pe' pe) end) 
           xs) | PEundef _ _ => pe_ | PEerror str pe =>
        PEerror str (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEctor ctor1 pes =>
        PEctor ctor1 (List.map (unsafe_subst_sym_pexpr sym1 pe') pes)
        | PEcase pe xs =>
        PEcase (unsafe_subst_sym_pexpr sym1 pe' pe)
          (List.map
             (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  pe)) => (pat, (
                if in_pattern sym1 pat then pe else
                  unsafe_subst_sym_pexpr sym1 pe' pe)) end ) xs)
        | PEarray_shift pe1 ty pe2 =>
        PEarray_shift (unsafe_subst_sym_pexpr sym1 pe' pe1) ty
          (unsafe_subst_sym_pexpr sym1 pe' pe2)
        | PEmember_shift pe tag_sym memb_ident =>
        PEmember_shift (unsafe_subst_sym_pexpr sym1 pe' pe) tag_sym
          memb_ident | PEnot pe => PEnot (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEop bop pe1 pe2 =>
        PEop bop (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (unsafe_subst_sym_pexpr sym1 pe' pe2) | PEstruct tag_sym xs =>
        PEstruct tag_sym
          (List.map
             (fun (p : (cabs.cabs_identifier *generic_pexpr (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (ident,  pe)) =>
                  (ident, unsafe_subst_sym_pexpr sym1 pe' pe) end) xs)
        | PEunion tag_sym ident pe =>
        PEunion tag_sym ident (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEcfunction pe => PEcfunction (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEmemberof tag_sym memb_ident pe =>
        PEmemberof tag_sym memb_ident (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEcall nm pes =>
        PEcall nm (List.map (unsafe_subst_sym_pexpr sym1 pe') pes)
        | PElet pat pe1 pe2 =>
        PElet pat (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (
          if in_pattern sym1 pat then pe2 else
            unsafe_subst_sym_pexpr sym1 pe' pe2) | PEif pe1 pe2 pe3 =>
        PEif (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (unsafe_subst_sym_pexpr sym1 pe' pe2)
          (unsafe_subst_sym_pexpr sym1 pe' pe3) | PEis_scalar pe =>
        PEis_scalar (unsafe_subst_sym_pexpr sym1 pe' pe) | PEis_integer pe =>
        PEis_integer (unsafe_subst_sym_pexpr sym1 pe' pe) | PEis_signed pe =>
        PEis_signed (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEis_unsigned pe =>
        PEis_unsigned (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEbmc_assume pe =>
        PEbmc_assume (unsafe_subst_sym_pexpr sym1 pe' pe)
        | PEare_compatible pe1 pe2 =>
        PEare_compatible (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (unsafe_subst_sym_pexpr sym1 pe' pe2) end end.
(* [?]: removed value specification. *)

Program Fixpoint unsafe_subst_sym_expr {a : Type}  (sym1 : symbol.sym ) (pe' : generic_pexpr (unit ) (symbol.sym )) (g : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  match ( (sym1,pe',g)) with ( sym1,  pe', ( Expr annot1 expr_)) =>
    Expr annot1
      match ( expr_) with | Epure pe =>
        Epure (unsafe_subst_sym_pexpr sym1 pe' pe) | Ememop memop1 pes =>
        Ememop memop1 (List.map (unsafe_subst_sym_pexpr sym1 pe') pes)
        | Elet pat pe1 e2 =>
        Elet pat (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (
          if in_pattern sym1 pat then e2 else
            unsafe_subst_sym_expr sym1 pe' e2) | Eif pe1 e2 e3 =>
        Eif (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (unsafe_subst_sym_expr sym1 pe' e2)
          (unsafe_subst_sym_expr sym1 pe' e3) | Ecase pe pat_es =>
        Ecase (unsafe_subst_sym_pexpr sym1 pe' pe)
          (List.map
             (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  e)) => (pat, (
                if in_pattern sym1 pat then e else
                  unsafe_subst_sym_expr sym1 pe' e)) end ) pat_es)
        | Eccall annot1 pe1 pe2 pes =>
        Eccall annot1 (unsafe_subst_sym_pexpr sym1 pe' pe1)
          (unsafe_subst_sym_pexpr sym1 pe' pe2)
          (List.map (unsafe_subst_sym_pexpr sym1 pe') pes)
        | Eproc annot1 nm pes =>
        Eproc annot1 nm (List.map (unsafe_subst_sym_pexpr sym1 pe') pes)
        | Eaction pact => Eaction (unsafe_subst_sym_paction sym1 pe' pact)
        | Eunseq es => Eunseq (List.map (unsafe_subst_sym_expr sym1 pe') es)
        | Ewseq pat e1 e2 =>
        Ewseq pat (unsafe_subst_sym_expr sym1 pe' e1)
          (
          if in_pattern sym1 pat then e2 else
            unsafe_subst_sym_expr sym1 pe' e2) | Esseq pat e1 e2 =>
        Esseq pat (unsafe_subst_sym_expr sym1 pe' e1)
          (
          if in_pattern sym1 pat then e2 else
            unsafe_subst_sym_expr sym1 pe' e2)
        | Easeq (sym',  bTy) act1 act2 =>
        Easeq (sym', bTy) (unsafe_subst_sym_action sym1 pe' act1)
          (* begin block *)
          if match ( (sym1, sym')) with
                   | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
               if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                    ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
                 if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                    negb
                      ((maybeEqualBy
                          (fun (left : string ) (right : string )=>
                             (string_equal left right)) str_opt1 str_opt2)) then
                   match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                             ( 5) []
                             (fun (u : unit ) =>
                                match ( (u) ) with ( tt) =>
                                  String.append
                                    "[Symbol.symbolEqual] suspicious equality ==> "
                                    (String.append
                                       (stringFromMaybe
                                          (fun (s : string )=>
                                             String.append """"
                                               (String.append s """"))
                                          str_opt1)
                                       (String.append " <-> "
                                          (stringFromMaybe
                                             (fun (s : string )=>
                                                String.append """"
                                                  (String.append s """"))
                                             str_opt2))) end)) with tt =>
                     true end else true else false end then act2 else
            unsafe_subst_sym_action sym1 pe' act2 (* end block *)
        | Ebound e => Ebound (unsafe_subst_sym_expr sym1 pe' e)
        | Esave lab_sym sym_bTy_pes e =>
        let sym_bTy_pes' := List.map
                              (fun (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                                 match ( (p) ) with ( (z,  (bTy,  pe))) =>
                                   (z, (bTy, unsafe_subst_sym_pexpr sym1 
                                             pe' pe)) end ) sym_bTy_pes in
      if List.existsb
           (fun (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
              match ( (p) ) with ( (z,  _)) =>
                match ( (sym1, z)) with
                      | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
                  if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                       ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
                    if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                       negb
                         ((maybeEqualBy
                             (fun (left : string ) (right : string )=>
                                (string_equal left right)) str_opt1 str_opt2)) then
                      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                                ( 5) []
                                (fun (u : unit ) =>
                                   match ( (u) ) with ( tt) =>
                                     String.append
                                       "[Symbol.symbolEqual] suspicious equality ==> "
                                       (String.append
                                          (stringFromMaybe
                                             (fun (s : string )=>
                                                String.append """"
                                                  (String.append s """"))
                                             str_opt1)
                                          (String.append " <-> "
                                             (stringFromMaybe
                                                (fun (s : string )=>
                                                   String.append """"
                                                     (String.append s """"))
                                                str_opt2))) end)) with tt =>
                        true end else true else false end end) sym_bTy_pes then
        match ( fun (_: list domain) (_: unit -> string) := tt []
                  (fun (u : unit ) =>
                     match ( (u) ) with ( tt) =>
                       "unsafe_subst, Esave ==> shadowing" end)) with tt =>
          (* TODO: check *) Esave lab_sym sym_bTy_pes' e end else
        Esave lab_sym sym_bTy_pes' (unsafe_subst_sym_expr sym1 pe' e)
        | Erun annot1 lab_sym pes =>
        Erun annot1 lab_sym (List.map (unsafe_subst_sym_pexpr sym1 pe') pes)
        | End es => End (List.map (unsafe_subst_sym_expr sym1 pe') es)
        | Epar es => Epar (List.map (unsafe_subst_sym_expr sym1 pe') es)
        | Ewait _ => expr_ | Eannot xs e =>
        Eannot xs (unsafe_subst_sym_expr sym1 pe' e) | Eexcluded n act =>
        Eexcluded n (unsafe_subst_sym_action sym1 pe' act)
      (*
    | Eloc loc e ->
        Eloc loc (unsafe_subst_sym_expr sym pe' e)
    | Estd s e ->
        Estd s (unsafe_subst_sym_expr sym pe' e)
*)
      end end
with unsafe_subst_sym_action_ {a : Type}  (a : symbol.sym ) (pe' : generic_pexpr (unit ) (symbol.sym ))  : generic_action_ (unit ) (symbol.sym ) -> generic_action_ (unit ) (symbol.sym ):= 
  match ( (a,pe')) with ( a,  pe') =>
    fun (x : generic_action_ (unit ) (symbol.sym )) =>
      match (x) with | Create pe1 pe2 pref =>
        Create (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2) pref
        | CreateReadOnly pe1 pe2 pe3 pref =>
        CreateReadOnly (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3) pref | Alloc0 pe1 pe2 pref =>
        Alloc0 (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2) pref | Kill b pe =>
        Kill b (unsafe_subst_sym_pexpr a pe' pe)
        | Store0 b pe1 pe2 pe3 mo1 =>
        Store0 b (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3) mo1 | Load0 pe1 pe2 mo1 =>
        Load0 (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2) mo1
        | SeqRMW b pe1 pe2 sym' pe3 =>
        SeqRMW b (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2) sym'
          (* begin block *)
          if match ( (a, sym')) with
                   | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
               if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                    ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
                 if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                    negb
                      ((maybeEqualBy
                          (fun (left : string ) (right : string )=>
                             (string_equal left right)) str_opt1 str_opt2)) then
                   match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                             ( 5) []
                             (fun (u : unit ) =>
                                match ( (u) ) with ( tt) =>
                                  String.append
                                    "[Symbol.symbolEqual] suspicious equality ==> "
                                    (String.append
                                       (stringFromMaybe
                                          (fun (s : string )=>
                                             String.append """"
                                               (String.append s """"))
                                          str_opt1)
                                       (String.append " <-> "
                                          (stringFromMaybe
                                             (fun (s : string )=>
                                                String.append """"
                                                  (String.append s """"))
                                             str_opt2))) end)) with tt =>
                     true end else true else false end then pe3 else
            unsafe_subst_sym_pexpr a pe' pe3 (* end block *)
        | RMW0 pe1 pe2 pe3 pe4 mo1 mo2 =>
        RMW0 (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3)
          (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2 | Fence0 mo1 =>
        Fence0 mo1 | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 =>
        CompareExchangeStrong (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3)
          (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
        | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 =>
        CompareExchangeWeak (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3)
          (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2 | LinuxFence mo1 =>
        LinuxFence mo1 | LinuxStore pe1 pe2 pe3 mo1 =>
        LinuxStore (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3) mo1 | LinuxLoad pe1 pe2 mo1 =>
        LinuxLoad (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2) mo1
        | LinuxRMW pe1 pe2 pe3 mo1 =>
        LinuxRMW (unsafe_subst_sym_pexpr a pe' pe1)
          (unsafe_subst_sym_pexpr a pe' pe2)
          (unsafe_subst_sym_pexpr a pe' pe3) mo1
      (*
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
*)
      end end
with unsafe_subst_sym_action {a : Type}  (a1 : symbol.sym ) (pe' : generic_pexpr (unit ) (symbol.sym )) (g : generic_action a (unit ) (symbol.sym ))  : generic_action a (unit ) (symbol.sym ):= 
  match ( (a1,pe',g)) with ( a1,  pe', ( Action loc bs act_)) =>
    Action loc bs (unsafe_subst_sym_action_ a1 pe' act_) end
with unsafe_subst_sym_paction {a : Type}  (a1 : symbol.sym ) (pe' : generic_pexpr (unit ) (symbol.sym )) (g : generic_paction a (unit ) (symbol.sym ))  : generic_paction a (unit ) (symbol.sym ):= 
  match ( (a1,pe',g)) with ( a1,  pe', ( Paction p act)) =>
    Paction p (unsafe_subst_sym_action a1 pe' act) end.
(* [?]: removed value specification. *)

Program Fixpoint unsafe_subst_pattern {a : Type}  (g : generic_pattern (unit ) (symbol.sym )) (pe' : generic_pexpr (unit ) (symbol.sym )) (expr1 : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  match ( (g,pe',expr1)) with (( Pattern _ pat),  pe',  expr1) =>
    match ( (pat, pe')) with | (CaseBase (None,  _),  _) => expr1
      | (CaseBase (Some sym1,  _),  _) =>
      unsafe_subst_sym_expr sym1 pe' expr1
      | (CaseCtor( Cnil tt) [],  Pexpr _ _( PEval( Vlist _ []))) =>
      (* empty list (value) *) expr1
      | (CaseCtor( Cnil _) [],  Pexpr _ _( PEctor( Cnil _) [])) =>
      (* empty list (pure expr) *) expr1
      | (CaseCtor Ccons [pat1;  pat2],  Pexpr _ tt( PEval( Vlist bTy_elem( cval::cvals)))) =>
      (* populated list (value) *) apply (subst_pattern_val pat1 cval)
        (subst_pattern_val pat2 (Vlist bTy_elem cvals) expr1)
      | (CaseCtor Ccons [pat1;  pat2],  Pexpr _ _( PEctor Ccons [pe1;  pe2])) =>
      (* populated list (pure expr) *) apply (unsafe_subst_pattern pat1 pe1)
        (unsafe_subst_pattern pat2 pe2 expr1)
      | (CaseCtor Ctuple pats',  Pexpr _ tt( PEval( Vtuple cvals))) =>
      List.fold_right
        (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_value (symbol.sym )) % type) (acc : generic_expr a (unit ) (symbol.sym )) =>
           match ( (p ,acc) ) with ( (pat',  cval) ,  acc) =>
             subst_pattern_val pat' cval acc end ) expr1
        (lem_list.zip pats' cvals)
      | (CaseCtor Ctuple pats',  Pexpr _ _( PEctor Ctuple pes)) =>
      List.fold_right
        (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type) (acc : generic_expr a (unit ) (symbol.sym )) =>
           match ( (p ,acc) ) with ( (pat',  pe) ,  acc) =>
             unsafe_subst_pattern pat' pe acc end ) expr1
        (lem_list.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
      | (CaseCtor Cspecified [pat'],  Pexpr _ tt( PEval( Vloaded( LVspecified oval)))) =>
      subst_pattern_val pat' (Vobject oval) expr1
      | (CaseCtor Cspecified [pat'],  Pexpr _ tt( PEctor Cspecified [pe''])) =>
      unsafe_subst_pattern pat' pe'' expr1
      | (CaseCtor Cunspecified [pat'],  Pexpr _ tt( PEval( Vloaded( LVunspecified ty)))) =>
      subst_pattern_val pat' (Vctype ty) expr1
      | (CaseCtor Cunspecified [pat'],  Pexpr _ tt( PEctor Cunspecified [pe''])) =>
      unsafe_subst_pattern pat' pe'' expr1 | (CaseCtor ctor1 pats,  _) =>
      let str_ctor := match ( ctor1) with | Cnil _ => "nil" | Ccons => "cons"
                        | Ctuple => "tuple" | Carray => "array" | Civmax =>
                        "ivmax" | Civmin => "ivmin" | Civsizeof => "ivsizeof"
                        | Civalignof => "ivalignof" | CivCOMPL => "ivCOMPL"
                        | CivAND => "ivAND" | CivOR => "ivOR" | CivXOR =>
                        "ivXOR" | Cspecified => "specified" | Cunspecified =>
                        "unspecified" | Cfvfromint => "fvfromint"
                        | Civfromfloat => "ivfromfloat" end in
    BOOM
      ( String.append "WIP: Core_aux.unsafe_subst_pattern ==> ctor= "
          (String.append str_ctor
             (String.append ", |pats|= "
                (String.append
                   (lem_string_extra.stringFromNat (List.length pats))
                   (String.append " -- " (BOOM pe')))))) end end.
(* [?]: removed value specification. *)

Program Fixpoint subst_pattern {a : Type}  (g : generic_pattern (unit ) (symbol.sym )) (pe' : generic_pexpr (unit ) (symbol.sym )) (expr1 : generic_expr a (unit ) (symbol.sym ))  : option (generic_expr a (unit ) (symbol.sym )) := 
  match ( (g,pe',expr1)) with (( Pattern _ pat),  pe',  expr1) =>
    match ( (pat, pe')) with | (CaseBase (None,  _),  _) => Some expr1
      | (CaseBase (Some sym1,  _),  _) =>
      apply Some (unsafe_subst_sym_expr sym1 pe' expr1)
      | (CaseCtor( Cnil tt) [],  Pexpr _ _( PEval( Vlist _ []))) =>
      (* empty list (value) *) Some expr1
      | (CaseCtor( Cnil _) [],  Pexpr _ _( PEctor( Cnil _) [])) =>
      (* empty list (pure expr) *) Some expr1
      | (CaseCtor Ccons [pat1;  pat2],  Pexpr _ tt( PEval( Vlist bTy_elem( cval::cvals)))) =>
      (* populated list (value) *) Some
        ( apply (subst_pattern_val pat1 cval)
            (subst_pattern_val pat2 (Vlist bTy_elem cvals) expr1))
      | (CaseCtor Ccons [pat1;  pat2],  Pexpr _ _( PEctor Ccons [pe1;  pe2])) =>
      (* populated list (pure expr) *)
      match ( subst_pattern pat2 pe2 expr1) with | Some e =>
        subst_pattern pat1 pe1 e | None => None end
      | (CaseCtor Ctuple pats',  Pexpr _ tt( PEval( Vtuple cvals))) =>
      apply Some
        (List.fold_right
           (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_value (symbol.sym )) % type) (acc : generic_expr a (unit ) (symbol.sym )) =>
              match ( (p ,acc) ) with ( (pat',  cval) ,  acc) =>
                subst_pattern_val pat' cval acc end ) expr1
           (lem_list.zip pats' cvals))
      | (CaseCtor Ctuple pats',  Pexpr _ _( PEctor Ctuple pes)) =>
      List.fold_right
        (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_pexpr (unit ) (symbol.sym )) % type) (acc : option (generic_expr a (unit ) (symbol.sym )) ) =>
           match ( (p ,acc) ) with ( (pat',  pe) ,  acc) =>
             match ( acc) with | Some e => subst_pattern pat' pe e | None =>
               None end end ) (Some expr1) (lem_list.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
      | (CaseCtor Cspecified [pat'],  Pexpr _ tt( PEval( Vloaded( LVspecified oval)))) =>
      apply Some (subst_pattern_val pat' (Vobject oval) expr1)
      | (CaseCtor Cspecified [pat'],  Pexpr _ tt( PEctor Cspecified [pe''])) =>
      subst_pattern pat' pe'' expr1
      | (CaseCtor Cunspecified [pat'],  Pexpr _ tt( PEval( Vloaded( LVunspecified ty)))) =>
      apply Some (subst_pattern_val pat' (Vctype ty) expr1)
      | (CaseCtor Cunspecified [pat'],  Pexpr _ tt( PEctor Cunspecified [pe''])) =>
      subst_pattern pat' pe'' expr1 | (CaseCtor ctor1 pats,  _) => None end
  end.
(* [?]: removed value specification. *)

Program Fixpoint to_pure {a : Type}  (g : generic_expr a (unit ) (symbol.sym ))  : option (generic_pexpr (unit ) (symbol.sym )) := 
  match ( (g)) with (( Expr annot1 expr_)) =>
    let to_pure_aux  := (fun (pat : generic_pattern (unit ) (symbol.sym )) (pe1 : generic_pexpr (unit ) (symbol.sym )) (e2 : generic_expr a (unit ) (symbol.sym )) =>
                           match ( subst_pattern pat pe1 e2) with | Some e =>
                             to_pure e | None =>
                             match ( to_pure e2) with | None => None
                               | Some pe2 =>
                               Some (Pexpr [] tt (PElet pat pe1 pe2)) end end)
  in
  match ( expr_) with | Epure pe => Some pe | Ememop _ _ => None
    | Elet pat pe1 e2 =>
    match ( to_pure e2) with | Some( Pexpr annot1 bTy _ as pe2) =>
      Some (Pexpr annot1 bTy (PElet pat pe1 pe2)) | _ => None end
    | Eif pe1 e2 e3 =>
    match ( (to_pure e2, to_pure e3)) with
          | (Some( Pexpr annot1 bTy _ as pe2),  Some pe3) =>
      Some (Pexpr annot1 bTy (PEif pe1 pe2 pe3)) | _ => None end
    | Eccall _ _ _ _ => None | Eproc _ _ _ => None | Eaction _ => None
    | Eunseq es =>
    match ( to_pures es) with | Some pes =>
      Some (Pexpr [] tt (PEctor Ctuple pes)) | None => None end
    | Ewseq pat e1 e2 =>
    match ( to_pure e1) with | Some pe1 => to_pure_aux pat pe1 e2 | None =>
      None end | Esseq pat e1 e2 =>
    match ( to_pure e1) with | Some pe1 => to_pure_aux pat pe1 e2 | None =>
      None end | Easeq _ _ _ => None | Ebound e =>
    (* TODO: check *) to_pure e | Esave _ _ _ => None | Erun _ _ _ => None
    | End _ => None | Epar _ => None | Ewait _ => None | Eannot _ _ =>
    BOOM "to_pure Eannot" | Eexcluded _ _ => BOOM "to_pure Eexcluded"
  (*
    | Eloc _ e ->
        to_pure e
    | Estd _ e ->
        to_pure e
*)
    | Ecase pe pat_es =>
    match ( lem_list.unzip pat_es) with (pats,  es) =>
      match ( to_pures es) with | Some( (Pexpr annot1 bTy _ :: _) as pes) =>
        Some (Pexpr annot1 bTy (PEcase pe (lem_list.zip pats pes))) | _ =>
        None end end end end
with to_pures {a : Type}  (l : list (expr a))  : option (list (generic_pexpr (unit ) (symbol.sym ))) := 
  match ( (l)) with ( es) =>
    List.fold_right
      (fun (e : generic_expr a (unit ) (symbol.sym )) (acc_opt : option (list (generic_pexpr (unit ) (symbol.sym ))) ) =>
         match ( (to_pure e, acc_opt)) with | (Some pe,  Some acc) =>
           Some (pe :: acc) | _ => None end) (Some []) es end.
(* [?]: removed value specification. *)

Program Fixpoint subst_wait {a : Type}  (tid1 : nat ) (v : generic_value (symbol.sym )) (g : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  match ( (tid1,v,g)) with ( tid1,  v, ( Expr annot1 expr_)) =>
    Expr annot1
      match ( expr_) with | Epure _ => expr_ | Ememop _ _ => expr_
        | Elet sym1 pe1 e2 => Elet sym1 pe1 (subst_wait tid1 v e2)
        | Eif pe1 e2 e3 =>
        Eif pe1 (subst_wait tid1 v e2) (subst_wait tid1 v e3)
        | Ecase pe pat_es =>
        Ecase pe
          (List.map
             (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  e)) => (pat, subst_wait tid1 v e)
                end) pat_es) | Eccall _ _ _ _ => expr_ | Eproc _ _ _ => expr_
        | Eaction _ => expr_ | Eunseq es =>
        Eunseq (List.map (subst_wait tid1 v) es) | Ewseq _as e1 e2 =>
        Ewseq _as (subst_wait tid1 v e1) (subst_wait tid1 v e2)
        | Esseq _as e1 e2 =>
        Esseq _as (subst_wait tid1 v e1) (subst_wait tid1 v e2)
        | Easeq _ _ _ => expr_ | Ebound e => Ebound (subst_wait tid1 v e)
      (*
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
*)
        | Esave sym1 sym_bTys e => Esave sym1 sym_bTys (subst_wait tid1 v e)
        | Erun _ _ _ => expr_ | End es =>
        End (List.map (subst_wait tid1 v) es) | Epar es =>
        Epar (List.map (subst_wait tid1 v) es) | Ewait tid' =>
        if beq_nat tid1 tid' then
          match ( v) with | Vunit => Epure (Pexpr [] tt (PEval Vunit)) | _ =>
            Epure (Pexpr [] tt (PEval v)) end else Ewait tid'
        | Eannot xs e => Eannot xs (subst_wait tid1 v e) | Eexcluded _ _ =>
        expr_
      (*
   | Eloc loc e ->
       Eloc loc (subst_wait tid v e)
   | Estd s e ->
       Estd s (subst_wait tid v e)
*)
      end end.





Program Fixpoint find_labeled_continuation {a b c : Type} `{Eq a}  (sym1 : a) (g : generic_expr c b a)  : option ((list a*generic_expr c b a) % type) := 
  match ( (sym1,g)) with ( sym1, ( Expr annot1 expr_)) =>
    match ( expr_) with | Epure _ => None | Ememop _ _ => None | Eaction _ =>
      None | Ecase _ pat_es =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation assumes there is atmost single match inside a Ecase"
                   end)) with tt =>
        List.fold_left
          (fun (acc : option ((list a*generic_expr c b a) % type) ) (p : (generic_pattern b a*generic_expr c b a) % type) =>
             match ( (acc ,p) ) with ( acc ,  (_,  e)) =>
               match ( acc) with | Some _ => acc | None =>
                 match ( find_labeled_continuation sym1 e) with | None =>
                   None | Some ret => Some ret end end end ) pat_es None end
      | Elet _ _ e2 => find_labeled_continuation sym1 e2 | Eif _ e2 e3 =>
      (* NOTE: in a well formed Core expr, [sym] cannot be bound in both e2 and e3. *)
      match ( find_labeled_continuation sym1 e2) with | Some z => Some z
        | None => find_labeled_continuation sym1 e3 end | Eccall _ _ _ _ =>
      None | Eproc _ _ _ => None | Eunseq _ =>
      (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
    None | Ewseq pat e1 e2 =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Ewseq don't clash"
                   end)) with tt =>
        match ( find_labeled_continuation sym1 e1) with
              | Some (syms,  cont_expr) =>
          Some (syms, Expr annot1 (Ewseq pat cont_expr e2)) | None =>
          find_labeled_continuation sym1 e2 end end | Esseq pat e1 e2 =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Esseq don't clash"
                   end)) with tt =>
        match ( find_labeled_continuation sym1 e1) with
              | Some (syms,  cont_expr) =>
          Some (syms, Expr annot1 (Esseq pat cont_expr e2)) | None =>
          find_labeled_continuation sym1 e2 end end | Easeq _ _ _ => None
      | Ebound _ =>
      (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
    None | End _ =>
      (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
    None | Esave (sym',  _) sym_bTys e =>
      if sym1 = sym' then Some (List.map (@ fst _ _) sym_bTys, e) else
        find_labeled_continuation sym1 e | Erun annot1 sym1 pes => None
      | Epar es =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation assumes there are no Esave inside par()"
                   end)) with tt => None end | Ewait _ => None
      | Eannot _ _ =>
      (* NOTE: Eannot only appear at runtime, and inside an Ebound, where
                 typing forbids labeled continuation bindings. *)
    None | Eexcluded _ _ =>
      (* NOTE: Eexcluded only appear at runtime, and inside an Eexcluded, where
                 typing forbids labeled continuation bindings. *)
    None
    (*
    | Eloc _ e ->
        find_labeled_continuation sym e
    | Estd _ e ->
        find_labeled_continuation sym e
*)
    end end.
(* [?]: removed value specification. *)

Program Fixpoint find_labeled_continuation2_aux {a : Type}  (acc : fmap (symbol.sym ) ((list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type)) (sym1 : symbol.sym ) (g : generic_expr a (unit ) (symbol.sym ))  : fmap (symbol.sym ) ((list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type):= 
  match ( (acc,sym1,g)) with ( acc,  sym1, ( Expr annot1 expr_)) =>
    match ( expr_) with | Epure _ => acc | Ememop _ _ => acc | Eaction _ =>
      acc | Ecase _ pat_es =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation2_aux assumes there is atmost single match inside a Ecase"
                   end)) with tt =>
        List.fold_left
          (fun (acc' : fmap (symbol.sym ) ((list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type)) (p : (generic_pattern (unit ) (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
             match ( (acc' ,p) ) with ( acc' ,  (_,  e)) =>
               find_labeled_continuation2_aux acc' sym1 e end ) pat_es 
        acc end | Elet _ _ e2 => find_labeled_continuation2_aux acc sym1 e2
      | Eif _ e2 e3 =>
      let acc'  := find_labeled_continuation2_aux acc sym1 e2 in
    find_labeled_continuation2_aux acc' sym1 e3 | Eccall _ _ _ _ => acc
      | Eproc _ _ _ => acc | Eunseq _ =>
      (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
    acc | Ewseq pat e1 e2 =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation2_aux assumes the bindings of an Esave inside a Ewseq don't clash"
                   end)) with tt =>
        let acc'  := fmap_map
                       (fun (p : (list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                          match ( (p) ) with ( (syms,  z)) =>
                            (syms, Expr annot1 (Ewseq pat z e2)) end )
                       (find_labeled_continuation2_aux fmap_empty sym1 e1) in
      find_labeled_continuation2_aux ((@ List.app _) acc acc') sym1 e2 end
      | Esseq pat e1 e2 =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation2_aux assumes the bindings of an Esave inside a Esseq don't clash"
                   end)) with tt =>
        let acc'  := fmap_map
                       (fun (p : (list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                          match ( (p) ) with ( (syms,  z)) =>
                            (syms, Expr annot1 (Esseq pat z e2)) end )
                       (find_labeled_continuation2_aux fmap_empty sym1 e1) in
      find_labeled_continuation2_aux ((@ List.app _) acc acc') sym1 e2 end
      | Easeq _ _ _ => acc | Ebound _ =>
      (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
    acc | End _ =>
      (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
    acc | Esave (sym',  _) sym_bTys e =>
      if match ( (sym1, sym')) with
               | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
           if Z.eqb (fun _: unit _: unit => 0 d1 d2)
                ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
             if nat_gteb (fun _: tt => 0 tt) ( 5) &&
                negb
                  ((maybeEqualBy
                      (fun (left : string ) (right : string )=>
                         (string_equal left right)) str_opt1 str_opt2)) then
               match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt
                         ( 5) []
                         (fun (u : unit ) =>
                            match ( (u) ) with ( tt) =>
                              String.append
                                "[Symbol.symbolEqual] suspicious equality ==> "
                                (String.append
                                   (stringFromMaybe
                                      (fun (s : string )=>
                                         String.append """"
                                           (String.append s """")) str_opt1)
                                   (String.append " <-> "
                                      (stringFromMaybe
                                         (fun (s : string )=>
                                            String.append """"
                                              (String.append s """"))
                                         str_opt2))) end)) with tt => true
               end else true else false end then
        fmap_add sym1 (List.map (@ fst _ _) sym_bTys, e) acc else
        find_labeled_continuation2_aux
          (fmap_add sym' (List.map (@ fst _ _) sym_bTys, e) acc) sym1 
        e | Erun annot1 sym1 pes => acc | Epar es =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Core_aux.find_labeled_continuation2_aux assumes there are no Esave inside par()"
                   end)) with tt => acc end | Ewait _ => acc | Eannot _ _ =>
      (* NOTE: Typing forbids labeled continuation bindings inside annot() *)
    acc | Eexcluded _ _ =>
      (* NOTE: Typing forbids labeled continuation bindings inside excluded() *)
    acc
    (*
    | Eloc _ e ->
        find_labeled_continuation2_aux acc sym e
    | Estd _ e ->
        find_labeled_continuation2_aux acc sym e
*)
    end end.

Definition find_labeled_continuation2 {a : Type}  (sym1 : symbol.sym ) (e : generic_expr a (unit ) (symbol.sym ))  : option ((((list (symbol.sym )*expr a) % type)*fmap (symbol.sym ) ((list (symbol.sym )*expr a) % type)) % type) := 
  let lconts  := find_labeled_continuation2_aux fmap_empty sym1 e in
  match ( (fmap_lookup_by (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>ordCompare sym1 sym2) sym1 lconts)) with  
    | Some cont =>
        Some (cont, lconts)
    | None =>
        None
  end.
(* [?]: removed value specification. *)

Definition unsafe_subst_sym_fun_map {a : Type}  (sym1 : symbol.sym ) (pe' : generic_pexpr (unit ) (symbol.sym )) (funs1 : fmap (symbol.sym ) (generic_fun_map_decl (unit ) a))  : fmap (symbol.sym ) (generic_fun_map_decl (unit ) a):= 
  fmap_map (fun (x : generic_fun_map_decl (unit ) a) =>
  match (x) with | Fun bTy params pe =>
    Fun bTy params (unsafe_subst_sym_pexpr sym1 pe' pe)
    | ProcDecl loc bTy params => ProcDecl loc bTy params
    | BuiltinDecl loc bTy params => BuiltinDecl loc bTy params
    | Proc loc bTy params e =>
    Proc loc bTy params (unsafe_subst_sym_expr sym1 pe' e) end) funs1.
(* [?]: removed value specification. *)

Program Fixpoint collect_labeled_continuations {a : Type}  (g : generic_expr a (unit ) (symbol.sym ))  : fmap (symbol.sym ) ((list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type):= 
  match ( (g)) with (( Expr annot1 expr_)) =>
    match ( expr_) with | Epure _ => fmap_empty | Ememop _ _ => fmap_empty
      | Elet _ _ e2 => collect_labeled_continuations e2 | Eif pe1 e2 e3 =>
      (@ List.app _) (collect_labeled_continuations e2)
        (collect_labeled_continuations e3) | Ecase pe pat_es =>
      fmap_empty (* TODO THIS IS WRONG!!!!! *) | Eproc _ _ _ => fmap_empty
      | Eccall _ _ _ _ => fmap_empty | Eaction _ => fmap_empty | Eunseq _ =>
      fmap_empty | Ewseq _as e1 e2 =>
      (@ List.app _)
        ( apply
            (fmap_map
               (fun (p : (list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                  match ( (p) ) with ( (a_tys,  e)) =>
                    (a_tys, Expr annot1 (Ewseq _as e e2)) end))
            (collect_labeled_continuations e1))
        (collect_labeled_continuations e2) | Esseq _as e1 e2 =>
      (@ List.app _)
        ( apply
            (fmap_map
               (fun (p : (list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                  match ( (p) ) with ( (a_tys,  e)) =>
                    (a_tys, Expr annot1 (Esseq _as e e2)) end))
            (collect_labeled_continuations e1))
        (collect_labeled_continuations e2) | Easeq _ _ _ => fmap_empty
      | Ebound _ => fmap_empty | Esave (sym_lab,  _) sym_bTys e =>
      apply (fmap_add sym_lab (List.map (@ fst _ _) sym_bTys, e))
        (collect_labeled_continuations e) | Erun _ _ _ => fmap_empty
      | End _ => (* TODO: check *) fmap_empty | Epar _ => (* TODO: check *)
    fmap_empty | Ewait _ => fmap_empty | Eannot _ _ => fmap_empty
      | Eexcluded _ _ => fmap_empty
    (*
    | Eloc loc e ->
        collect_labeled_continuations e
    | Estd _ e ->
        collect_labeled_continuations e
*)
    end end.
(* [?]: removed value specification. *)

Definition is_unseq_with_negative {a : Type}   : generic_expr a (unit ) (symbol.sym ) -> bool :=  
  fun (x : generic_expr a (unit ) (symbol.sym )) =>
    match (x) with | Expr _( Eunseq es) => List.existsb is_negative es | _ =>
      false end.
(* [?]: removed value specification. *)

Program Fixpoint match_pattern  (g : generic_pattern (unit ) (symbol.sym )) (cval : generic_value (symbol.sym ))  : option (list ((symbol.sym *generic_value (symbol.sym )) % type)) := 
  match ( (g,cval)) with (( Pattern _ pat),  cval) =>
    match ( (pat, cval)) with | (CaseBase (None,  _),  _) => Some []
      | (CaseBase (Some sym1,  _),  _) => Some [(sym1, cval)]
    (*      | Vobject of (generic_object_value 'sym) *)
      | (CaseCtor Cspecified [pat'],  Vloaded( LVspecified oval)) =>
      match_pattern pat' (Vobject oval)
      | (CaseCtor Cunspecified [pat'],  Vloaded( LVunspecified ty)) =>
      match_pattern pat' (Vctype ty)
    (*      | Vlist of core_base_type * list (generic_value 'sym) *)
      | (CaseCtor Ctuple pats',  Vtuple cvals') =>
      List.fold_right
        (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_value (symbol.sym )) % type) (acc : option (list ((symbol.sym *generic_value (symbol.sym )) % type)) ) =>
           match ( (p ,acc) ) with ( (pat',  cval') ,  acc) =>
             lem_maybe.bind acc
               (fun (xs : list ((symbol.sym *generic_value (symbol.sym )) % type)) =>
                  lem_maybe.bind (match_pattern pat' cval')
                    (fun (x : list ((symbol.sym *generic_value (symbol.sym )) % type)) =>
                       Some ((@ List.app _) x xs) ) ) end ) (Some [])
        (lem_list.zip pats' cvals') | (CaseCtor( Cnil _) [],  Vlist _ []) =>
      match ( fun (_: list domain) (_: unit -> string) := tt []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "Pattern matching nil without checking types!" end)) with
          tt => Some [] end
      | (CaseCtor Ccons [pat_x;  pat_xs],  Vlist ty( x::xs)) =>
      lem_maybe.bind (match_pattern pat_x x)
        (fun (x : list ((symbol.sym *generic_value (symbol.sym )) % type)) =>
           lem_maybe.bind (match_pattern pat_xs (Vlist ty xs))
             (fun (xs : list ((symbol.sym *generic_value (symbol.sym )) % type)) =>
                Some ((@ List.app _) x xs) ) ) | _ => None end end.
(* [?]: removed value specification. *)

Program Fixpoint select_case {a : Type}  (subst_sym : symbol.sym  -> generic_value (symbol.sym ) -> a -> a) (cval : generic_value (symbol.sym ))  : list ((generic_pattern (unit ) (symbol.sym )*a) % type) -> option a :=  
  fun (x : list ((generic_pattern (unit ) (symbol.sym )*a) % type)) =>
    match (x) with | [] =>
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 1) []
                (fun (u : unit ) => match ( (u) ) with ( tt) => "NOTHING" end)) with
          tt => None end | (pat,  pe) :: pat_pes' =>
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 1) []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) => "SELECT_CASE" end)) with tt =>
        match ( match_pattern pat cval) with | None =>
          (* trying the next branch *) select_case subst_sym cval pat_pes'
          | Some( sym_cvals) =>
          apply Some
            (List.fold_right
               (fun (p : (symbol.sym *generic_value (symbol.sym )) % type) (acc : a) =>
                  match ( (p ,acc) ) with ( (sym1,  cval') ,  acc) =>
                    subst_sym sym1 cval' acc end ) pe sym_cvals) end end end.
(* [?]: removed value specification. *)

Definition mk_pure_e {a : Type}  (pe : generic_pexpr (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  Expr [] (Epure pe).
(* [?]: removed value specification. *)

Definition mk_value_e {a : Type}  (cval : generic_value (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  mk_pure_e (mk_value_pe cval).
(* [?]: removed value specification. *)

Definition mk_skip_e   : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Epure (Pexpr [] tt (PEval Vunit))).
(* [?]: removed value specification. *)

Definition mk_unseq_e {a : Type}  (es : list (generic_expr a (unit ) (symbol.sym )))  : generic_expr a (unit ) (symbol.sym ):= 
  Expr [] (Eunseq es).
(* [?]: removed value specification. *)

Definition mk_case_e  (pe : generic_pexpr (unit ) (symbol.sym )) (pat_es : list ((generic_pattern (unit ) (symbol.sym )*generic_expr (unit ) (unit ) (symbol.sym )) % type))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Ecase pe pat_es).
(* [?]: removed value specification. *)

Definition mk_wseq_e {a : Type}  (pat : generic_pattern (unit ) (symbol.sym )) (e1 : generic_expr a (unit ) (symbol.sym )) (e2 : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  Expr [] (Ewseq pat e1 e2).
(* [?]: removed value specification. *)

Definition mk_sseq_e {a : Type}  (pat : generic_pattern (unit ) (symbol.sym )) (e1 : generic_expr a (unit ) (symbol.sym )) (e2 : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  Expr [] (Esseq pat e1 e2).
(* [?]: removed value specification. *)

Definition mk_save_e  (sym_bTy : (symbol.sym *core_base_type ) % type) (sym_bTy_pes : list ((symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type)) (e : generic_expr (unit ) (unit ) (symbol.sym ))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Esave sym_bTy sym_bTy_pes e).
(* [?]: removed value specification. *)

Definition mk_run_e  (sym1 : symbol.sym ) (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Erun tt sym1 pes).
(* [?]: removed value specification. *)

Definition mk_nd_e  (es : list (generic_expr (unit ) (unit ) (symbol.sym )))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (End es).
(* [?]: removed value specification. *)

Definition mk_if_e  (pe : generic_pexpr (unit ) (symbol.sym )) (e1 : generic_expr (unit ) (unit ) (symbol.sym )) (e2 : generic_expr (unit ) (unit ) (symbol.sym ))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Eif pe e1 e2).
(* [?]: removed value specification. *)

Definition mk_let_e  (pat : generic_pattern (unit ) (symbol.sym )) (pe : generic_pexpr (unit ) (symbol.sym )) (e : generic_expr (unit ) (unit ) (symbol.sym ))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Elet pat pe e).
(* [?]: removed value specification. *)

Definition mk_ccall_e  (cty : generic_pexpr (unit ) (symbol.sym )) (pe : generic_pexpr (unit ) (symbol.sym )) (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Eccall tt cty pe pes).
(* [?]: removed value specification. *)

Definition mk_memop_e  (mop : mem_common.memop ) (pes : list (generic_pexpr (unit ) (symbol.sym )))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  Expr [] (Ememop mop pes).
(* [?]: removed value specification. *)

Definition mk_wait_e {a : Type}  (tid1 : nat )  : generic_expr a (unit ) (symbol.sym ):= 
  Expr [] (Ewait tid1).
(* [?]: removed value specification. *)

Definition add_loc  (loc : unit ) (g : generic_expr (unit ) (unit ) (symbol.sym ))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  match ( (loc,g)) with ( loc, ( Expr annot1 expr_)) =>
    Expr (Aloc loc :: annot1) expr_ end.
(* [?]: removed value specification. *)

Definition add_std  (str : string ) (g : generic_expr (unit ) (unit ) (symbol.sym ))  : generic_expr (unit ) (unit ) (symbol.sym ):= 
  match ( (str,g)) with ( str, ( Expr annot1 expr_)) =>
    Expr (Astd str :: annot1) expr_ end.

Record collect_saves_state (a: Type) : Type := {
  tmp_acc:    fmap  symbol.sym   ((list  symbol.sym  * core.expr  a) % type); (*Core.labeled_continuations 'a; *)
  closed_acc: fmap  symbol.sym   ((list  symbol.sym  * core.expr  a) % type) (*Core.labeled_continuations 'a; *)
}.
Notation "{[ r 'with' 'tmp_acc' := e ]}" := ({| tmp_acc := e; closed_acc := closed_acc r |}).
Notation "{[ r 'with' 'closed_acc' := e ]}" := ({| closed_acc := e; tmp_acc := tmp_acc r |}).
Definition collect_saves_state_default{a: Type} : collect_saves_state a := {| tmp_acc := DAEMON; closed_acc := DAEMON |}.

Definition empty_saves {a : Type}   : collect_saves_state a:=  {|tmp_acc:= fmap_empty;closed_acc:= fmap_empty |}.

Definition union_saves {a : Type}  (st1 : collect_saves_state a) (st2 : collect_saves_state a)  : collect_saves_state a:= 
  {|tmp_acc:= ((@ List.app _)(tmp_acc  st1)(tmp_acc  st2));closed_acc:= ((@ List.app _)(closed_acc  st1)(closed_acc  st2)) |}.
(* [?]: removed value specification. *)

Program Fixpoint collect_saves_aux {a : Type}  (st : collect_saves_state a) (g : generic_expr a (unit ) (symbol.sym ))  : collect_saves_state a:= 
  match ( (st,g)) with ( st, ( Expr annots1 expr_)) =>
    match ( expr_) with | Epure _ => st | Ememop _ _ => st | Eaction _ => st
      | Ecase _ pat_es =>
      List.fold_left
        (fun (acc : collect_saves_state a) (p : (generic_pattern (unit ) (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
           match ( (acc ,p) ) with ( acc ,  (_,  e)) =>
             collect_saves_aux acc e end ) pat_es st | Elet _ _ e =>
      collect_saves_aux st e | Eif _ e1 e2 =>
      collect_saves_aux (collect_saves_aux st e1) e2 | Eccall _ _ _ _ => st
      | Eproc _ _ _ => st | Eunseq es =>
      List.fold_left collect_saves_aux es st | Ewseq pat e1 e2 =>
      let st1  := collect_saves_aux empty_saves e1 in
    let st2  := collect_saves_aux empty_saves e2 in
    union_saves st
      (* begin block *)
      union_saves
        {[ st1 with tmp_acc:= fmap_map
                                (fun (p : (list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                                   match ( (p) ) with ( (syms,  e)) =>
                                     (syms, Expr annots1 (Ewseq pat e e2))
                                   end) (tmp_acc  st1)  ]} st2
      (* end block *) | Esseq pat e1 e2 =>
      let st1  := collect_saves_aux empty_saves e1 in
    let st2  := collect_saves_aux empty_saves e2 in
    union_saves st
      (* begin block *)
      union_saves
        {[ st1 with tmp_acc:= fmap_map
                                (fun (p : (list (symbol.sym )*generic_expr a (unit ) (symbol.sym )) % type) =>
                                   match ( (p) ) with ( (syms,  e)) =>
                                     (syms, Expr annots1 (Esseq pat e e2))
                                   end) (tmp_acc  st1)  ]} st2
      (* end block *) | Easeq _ _ _ => st | Ebound _ =>
      (* typing forbids "saves" inside a "bound()" *) st | End _ =>
      (* typing forbids "saves" inside a "nd()" *) st
      | Esave (sym1,  _) params e =>
      collect_saves_aux
        {[ st with tmp_acc:= fmap_add sym1 (List.map (@ fst _ _) params, e)
                               (tmp_acc  st)  ]} e | Erun _ _ _ => st
      | Epar es =>
      let acc  := List.fold_left collect_saves_aux es empty_saves in
    {[ st with closed_acc:=
    (@ List.app _) ((@ List.app _) (tmp_acc  acc) (closed_acc  acc))
      (closed_acc  st)  ]} | Ewait _ => st | Eannot _ _ =>
      (* typing forbids "saves" inside a "annot()" *) st | Eexcluded _ _ =>
      (* typing forbids "saves" inside a "excluded()" *) st end end.
(* [?]: removed value specification. *)
 (*Core.labeled_continuations 'a *)
Definition collect_saves {a : Type}  (expr1 : generic_expr a (unit ) (symbol.sym ))  : fmap (symbol.sym ) ((list (symbol.sym )*expr a) % type):= 
  let st  := collect_saves_aux {|tmp_acc:= fmap_empty;closed_acc:= fmap_empty |} expr1 in
  (@ List.app _)(tmp_acc  st)(closed_acc  st).


Require Import lem_map_extra.
Require Export lem_map_extra.

(* [?]: removed value specification. *)

Definition collect_labeled_continuations_NEW {a : Type}  (file1 : generic_file (unit ) a)  : fmap (symbol.sym ) (fmap (symbol.sym ) ((list (symbol.sym )*expr a) % type)):= 
(*  let xs =  *)
  lem_map_extra.fold (fun (fun_sym : symbol.sym ) (decl : generic_fun_map_decl (unit ) a) (acc : fmap (symbol.sym ) (fmap (symbol.sym ) ((list (symbol.sym )*expr a) % type))) =>
    match ( decl) with 
      | Fun _ _ _ =>
          acc
      | ProcDecl _ _ _ =>
          acc
      | BuiltinDecl _ _ _ =>
          acc
      | Proc _ _ _ e =>
          fmap_add fun_sym (collect_saves e) acc
    end
  ) ((@ List.app _)(stdlib  file1)(funs  file1)) fmap_empty.
(* [?]: removed value specification. *)

Program Fixpoint update_env_aux {a : Type} `{MapKeyType a}  (g : generic_pattern (unit ) a) (cval : generic_value (symbol.sym )) (env1 : fmap a (generic_value (symbol.sym )))  : fmap a (generic_value (symbol.sym )):= 
  match ( (g,cval,env1)) with (( Pattern _ pat),  cval,  env1) =>
    match ( (pat, cval)) with | (CaseBase (None,  _),  _) =>
      (* e[_ \ v] = e *) env1 | (CaseBase (Some sym1,  _),  _) =>
      (* e[sym \ v] *) fmap_add sym1 cval env1
      | (CaseCtor( Cnil tt) [],  Vlist _ []) => (* empty list (value) *) env1
      | (CaseCtor Ccons [pat1;  pat2],  Vlist bTy_elem( cval1::cvals)) =>
      (* populated list (value) *) apply (update_env_aux pat1 cval1)
        (update_env_aux pat2 (Vlist bTy_elem cvals) env1)
      | (CaseCtor Ctuple pats',  Vtuple cvals) =>
      List.fold_right
        (fun (p : (generic_pattern (unit ) a*generic_value (symbol.sym )) % type) (acc : fmap a (generic_value (symbol.sym ))) =>
           match ( (p ,acc) ) with ( (pat',  cval') ,  acc) =>
             update_env_aux pat' cval' acc end ) env1
        (lem_list.zip pats' cvals)
      | (CaseCtor Cspecified [pat'],  Vloaded( LVspecified oval)) =>
      update_env_aux pat' (Vobject oval) env1
      | (CaseCtor Cunspecified [pat'],  Vloaded( LVunspecified ty)) =>
      update_env_aux pat' (Vctype ty) env1 | (CaseCtor ctor1 pats,  _) =>
      let str_ctor := match ( ctor1) with | Cnil _ => "nil" | Ccons => "cons"
                        | Ctuple => "tuple" | Carray => "array" | Civmax =>
                        "ivmax" | Civmin => "ivmin" | Civsizeof => "ivsizeof"
                        | Civalignof => "ivalignof" | CivCOMPL => "ivCOMPL"
                        | CivAND => "ivAND" | CivOR => "ivOR" | CivXOR =>
                        "ivXOR" | Cspecified => "specified" | Cunspecified =>
                        "unspecified" | Cfvfromint => "fvfromint"
                        | Civfromfloat => "ivfromfloat" end in
    BOOM
      ( String.append "WIP: Core_aux.update_env_aux ==> ctor= "
          (String.append str_ctor
             (String.append ", |pats|= "
                (String.append
                   (lem_string_extra.stringFromNat (List.length pats))
                   (String.append " -- " (BOOM cval)))))) end end.

Definition update_env  (pat : generic_pattern (unit ) (symbol.sym )) (cval : generic_value (symbol.sym ))  : list (fmap (symbol.sym ) (generic_value (symbol.sym ))) -> list (fmap (symbol.sym ) (generic_value (symbol.sym ))):=  
  fun (x : list (fmap (symbol.sym ) (generic_value (symbol.sym )))) =>
    match (x) with | [] => BOOM "Core_aux.update_env: found empty env"
      | env1::xs => update_env_aux pat cval env1 :: xs end.


Program Fixpoint lookup_env {a b : Type} `{MapKeyType b}  (sym1 : b)  : list (fmap b a) -> option a :=  
  fun (x : list (fmap b a)) =>
    match (x) with | [] => None | env1 :: xs =>
      match ( (fmap_lookup_by mapKeyCompare sym1 env1)) with | None =>
        lookup_env sym1 xs | Some ret => Some ret end end.

