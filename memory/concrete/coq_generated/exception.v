(* Generated by Lem from ocaml_generated/exception.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.


(* HACK: most of the inlines are only added to prevent Lem's renaming *)


Inductive exceptM (a : Type) (msg : Type) : Type := 
  | Result:  a -> exceptM a msg
  | Exception:  msg -> exceptM a msg.
Definition exceptM_default {a: Type} {msg: Type} : exceptM a msg := Result DAEMON.

Definition except_return {a b : Type}  (a1 : a)  : exceptM a b:=  Result a1.
Definition except_bind {a b c : Type}  (m : exceptM a b) (k : a -> exceptM c b)  : exceptM c b:= 
  match ( m) with 
    | Result a1    => k a1
    | Exception s => Exception s
  end.

Definition rbind {a b c : Type}  (k : c -> exceptM a b) (m : exceptM c b)  : exceptM a b:=  except_bind m k.

Definition throw {a b : Type}  (m : a)  : exceptM b a:=  Exception m.
Definition fail0 {a b : Type}   : b -> exceptM a b:=  throw.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition except_fmap {a b c : Type}  (f : c -> b) (m : exceptM c a)  : exceptM b a:=  except_bind m ( (fun (x : c)=>except_return (f x))).
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Definition of_maybe {a b : Type}  (m : b)  : option a  -> exceptM a b:=  
  fun (x : option a ) =>
    match (x) with | Some a1 => except_return a1 | None => throw m end.

Definition to_bool {a b : Type}   : exceptM b a -> bool :=  
  fun (x : exceptM b a) =>
    match (x) with | Result _ => true | Exception _ => false end.

Module Operators.  
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
End Operators.


Require Import operators.
Require Export operators.

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Program Fixpoint foldlM {a b msg : Type}  (f : a -> b -> exceptM a msg) (a1 : a)  : list b -> exceptM a msg:=  
  fun (x : list b) =>
    match (x) with | [] => except_return a1 | x::xs =>
      except_bind (f a1 x) (fun (z : a) => foldlM f z xs) end.





(*
TODO[not used anymore]

let sequence_map mmap =
  Ocaml.Pmap.fold (fun k m mm->
    m  >>= fun x   ->
    mm >>= fun map ->
    return (Pmap.add k x map)
  ) mmap (return Pmap.empty)

let map_map f m = sequence_map (Ocaml.Pmap.map f m)
*)

Definition inj_right {a b c d : Type}  (f : d -> exceptM b c) (p : (a*d) % type)  : exceptM ((a*b) % type) c:= 
  match ( (f,p)) with ( f,  (a1,  b1)) =>
    except_bind (f b1) (fun (b' : b) => except_return (a1, b')) end.


(*
TODO[newLem] should use the Ord class instead

==> Seems unused

*)
Definition compare0 {a b c d : Type}  (cmp : b -> d -> ordering ) (cmp_msg : a -> c -> ordering ) (a1 : exceptM b a) (a2 : exceptM d c)  : ordering := 
  match ( (a1, a2)) with 
  | (Result r1,  Result r2) => cmp r1 r2
  | (Exception e1,  Exception e2) => cmp_msg e1 e2
  | (Result _,  _) => LT
  | (_,  Result _) => GT
  end.

Definition bind_exception {a b c : Type}  (m : exceptM a c) (k : c -> exceptM a b)  : exceptM a b:= 
  match ( m) with 
    | Result a1 => Result a1
    | Exception s => k s
  end.

Definition rbind_exception {a b c : Type}  (k : a -> exceptM c b) (m : exceptM c a)  : exceptM c b:=  bind_exception m k.
(* [?]: removed value specification. *)

Definition guard {msg : Type}  (pred : bool ) (err : msg)  : exceptM (unit ) msg:= 
  if pred then
    except_return tt
  else
    fail0 err.
(* [?]: removed value specification. *)

Definition onException {a msg : Type}  (m1 : exceptM a msg) (m2 : exceptM a msg)  : exceptM a msg:= 
  match ( m1) with 
    | Result z    => Result z
    | Exception _ => m2
  end.
(* [?]: removed value specification. *)

Program Fixpoint trysM {a b msg : Type}  (err : msg) (f : a -> exceptM b msg)  : list a -> exceptM b msg:=  
  fun (x : list a) =>
    match (x) with | [] => throw err | [x] => f x | x::xs =>
      match ( f x) with | Result b1 => Result b1 | Exception _ =>
        trysM err f xs end end.
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
