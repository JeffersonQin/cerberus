(* Generated by Lem from ocaml_generated/core_reduction.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import utils.
Require Export utils.

Require Import core.
Require Export core.
Require Import core_aux.
Require Export core_aux.
Require Import core_run_aux.
Require Export core_run_aux.


Require Import state.
Require Export state.

Require Import core_eval.
Require Export core_eval.
Require Import cmm_aux.
Require Export cmm_aux.


(* TODO *)
Require Import core_run.
Require Export core_run.


Module Cmm.  
  Require Import cmm_aux.
Require Export cmm_aux.

  Require Import memory_order.
Require Export memory_order.

End Cmm.


(* TODO: duplicate from Core_run *)
Module E.  
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
  
  Definition fresh_excluded_id {a : Type}   : core_run_state  -> exception.exceptM ((undefined.t0 (nat )*core_run_state ) % type) a:= 
    seu.runS (fun (run_st : core_run_state ) =>
    let n :=(excluded_supply  run_st) in
    (n, {[ run_st with excluded_supply:=Coq.Init.Peano.plus n( 1)  ]})
  ).
  
  
  Definition eval_pexpr20 {a : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : a -> exception.exceptM ((undefined.t0 (sum (pexpr ) (value0 ))*a) % type) (errors.core_run_cause ):=  
  match ( debug.print_debug ( 5) []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) => "CALLING Core_run.eval_pexpr2" end )) with
      tt =>
    seu.runEU
      (core_eval.eval_pexpr_aux2 (current_loc  th_st) core_extern
         (env  th_st) (Some mem_st) file pe) end.
End E.

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Program Fixpoint full_eval_pexpr {a b : Type}  (th_st : thread_state ) (core_extern : fmap (symbol.sym ) (symbol.sym )) (mem_st : mem.mem_state ) (file1 : generic_file (unit ) (core_run_annotation )) (pe : generic_pexpr (unit ) (symbol.sym ))  : b -> exception.exceptM ((undefined.t0 (generic_value (symbol.sym ))*b) % type) (errors.core_run_cause ):=  state_exception_undefined.stExceptUndef_bind
  (e.eval_pexpr20 th_st core_extern mem_st file1 pe) (
  fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
    match (x) with | inl pe' =>
      full_eval_pexpr th_st core_extern mem_st file1 pe' | inr cval =>
      state_exception_undefined.stExceptUndef_return cval end).





Inductive action_request2 (a : Type) : Type := 
  (* RequestName  of location * sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest2:  symbol.prefix  ->  unit  ->  unit  -> 
                    (cmm.aid  ->  unit  ->  a) -> action_request2 a
  
  | CreateRequest2:  symbol.prefix  ->  unit  ->  ctype.ctype  ->  option  unit   -> 
                     (cmm.aid  ->  unit  ->  a) -> action_request2 a
  
  | StoreRequest2:  cmm.memory_order  ->  ctype.ctype  ->  (* is_locking *)bool  ->  unit  ->  unit  -> 
                     (cmm.aid  ->  unit  ->  a) -> action_request2 a
  
  | SeqRMWRequest2:  ctype.ctype  ->  unit  ->  (unit  ->  core_runM  unit ) ->  (cmm.aid  ->  unit  ->  unit  ->  unit  ->  a) -> action_request2 a
  
  | LoadRequest2:  (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                    cmm.memory_order  ->  ctype.ctype  ->  unit  ->  symbol.sym  -> 
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *)
                   (cmm.aid  ->  unit  ->  unit  ->  a) -> action_request2 a
  
  (* TODO: RMW, Fence *)
  | KillRequest2:  (* is_dynamic *)bool  ->  unit  ->  (cmm.aid  ->  a) -> action_request2 a.
Definition action_request2_default{a: Type} : action_request2 a := AllocRequest2 prefix_default unit_default unit_default (fun (x78 : cmm.aid ) => (fun (x79 :  unit ) => DAEMON)).


Inductive runstate_step_kind : Type := 
  | RSK_eval:  string  -> runstate_step_kind 
  | RSK_tau:  string  ->  core_run.core_tau_step_kind  -> runstate_step_kind .
Definition runstate_step_kind_default: runstate_step_kind  := RSK_eval string_default.

Inductive core_step2 : Type := 
  | Step_with_runstate2:  runstate_step_kind  ->  core_runM  thread_state  -> core_step2 

  | Step_eval2:  string  ->  core_runM  thread_state  -> core_step2 
  | Step_tau2:  string  ->  core_run.core_tau_step_kind  ->  thread_state  -> core_step2 
  | Step_action_request2:  string  ->  unit  ->  (* set Cmm.aid * set Cmm.aid * set Cmm.aid * *)
                            mem_common.thread_id  -> 
                            core_runM  (action_request2  thread_state ) -> core_step2 
  |Step_aseq:  unit  ->  mem_common.thread_id  ->  action_request2  unit  ->  action_request2  thread_state  -> core_step2 
  
  | Step_blocked2: core_step2 
  | Step_error2:  string  -> core_step2 
  | Step_thread_done2:  mem_common.thread_id  ->  core.value0  -> core_step2 
  | Step_done2:  core.value0  -> core_step2 
  | Step_memop_request2:  mem_common.memop  ->  list  core.value0  ->  mem_common.thread_id  ->  (core.value0  ->  thread_state ) -> core_step2 
  | Step_spawn_threads2:  (list  mem_common.thread_id  ->  thread_state ) ->  list  thread_state  -> core_step2 .
Definition core_step2_default: core_step2  := Step_with_runstate2 runstate_step_kind_default DAEMON. (* initial states for the children *)
(*
  | Step_constrained of string * list (Mem.mem_iv_constraint * core_runM thread_state)
  | Step_fs of thread_state * fs_oper
  | Step_bound of core_runM thread_state
*)





(* ********************************************************************************************** *)

Definition is_irreducible {a b c : Type}   : generic_expr c b a -> bool :=  
  fun (x : generic_expr c b a) =>
    match (x) with
        (* annot(..., annot(..., _)) ==> NOTE THE _ may be a value *)
      | Expr _( Eannot _( Expr _( Eannot _( Expr _( Epure( Pexpr _ _( PEval _))))))) =>
      (* TODO: this makes the function misnamed, but this has a one step reduction *)
    false (* v *) | Expr _( Epure( Pexpr _ _( PEval _))) => true
    (* annot(..., v) *)
      | Expr _( Eannot _( Expr _( Epure( Pexpr _ _( PEval _))))) => true
      | _ => false end.


Require Import debug.
Require Export debug.

(* [?]: removed value specification. *)

Definition do_race  (xs1 : list (dyn_annotation )) (xs2 : list (dyn_annotation ))  : bool := 
  List.existsb (fun (x : dyn_annotation ) =>
  match (x) with | DA_neg id1 exclusion1 fp1 =>
    List.existsb
      (fun (x : dyn_annotation ) =>
         match (x) with | DA_neg id2 exclusion2 fp2 =>
           if lem_list.elem id1 exclusion2 || lem_list.elem id2 exclusion1 then
             false else DAEMON fp1 fp2 | DA_pos exclusion2 fp2 =>
           if lem_list.elem id1 exclusion2 then false else DAEMON fp1 fp2 end)
      xs2 | DA_pos exclusion1 fp1 =>
    List.existsb
      (fun (x : dyn_annotation ) =>
         match (x) with | DA_neg id2 _ fp2 =>
           if lem_list.elem id2 exclusion1 then false else DAEMON fp1 fp2
           | DA_pos _ fp2 => DAEMON fp1 fp2 end) xs2 end) xs1.
(* [?]: removed value specification. *)

Definition combine_dyn_annotations  (xs1 : list (dyn_annotation )) (xs2 : list (dyn_annotation ))  : list (dyn_annotation ):=  
  (@ List.app _)xs1 xs2.

Definition pp_dyn_annotations  (fps : list (dyn_annotation ))  : string := 
  let pp_dyn_annotation := 
  fun (x : dyn_annotation ) =>
    match (x) with | DA_neg n excl fp =>
      String.append "DA_neg("
        (String.append
           (Coq.Numbers.DecimalString.NilZero.string_of_int
              (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n)))
           (String.append ", "
              (String.append
                 (stringFromList
                    (fun (n : nat )=>
                       Coq.Numbers.DecimalString.NilZero.string_of_int
                         (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n))) 
                  excl) ")"))) | DA_pos excl fp =>
      String.append "DA_pos("
        (String.append
           (stringFromList
              (fun (n : nat )=>
                 Coq.Numbers.DecimalString.NilZero.string_of_int
                   (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n))) excl) 
         ")") end in
  stringFromList pp_dyn_annotation fps.



Inductive one_step : Type := 
  | TAU_WITH_RUNSTATE:  string  ->  core_runM  ((list  (fmap  symbol.sym   value0 ) * core.expr  core_run_annotation ) % type) -> one_step 
  | TAU:  string  ->  list  (fmap  symbol.sym   value0 ) ->  core.expr  core_run_annotation  -> one_step 
  | EVAL:  string  ->  core_runM  (core.expr  core_run_annotation ) -> one_step 
  | MEMOP:  mem_common.memop  ->  list  core.value0  -> one_step 
  | UNSEQUENCED_RACE: one_step 
  | ILLTYPED:  string  -> one_step .
Definition one_step_default: one_step  := TAU_WITH_RUNSTATE string_default DAEMON.



Program Fixpoint one_step_unseq_aux {a : Type}  (p : (list (dyn_annotation )*list (generic_value (symbol.sym ))) % type)  : list (generic_expr a (unit ) (symbol.sym )) -> option ((list (dyn_annotation )*list (generic_value (symbol.sym ))) % type) := 
  match ( (p)) with ( (fps_acc,  cvals_acc)) =>
    fun (x : list (generic_expr a (unit ) (symbol.sym ))) =>
      match (x) with | [] => Some (fps_acc, List.rev cvals_acc)
        | Expr _( Epure( Pexpr _ _( PEval cval))) :: xs =>
        one_step_unseq_aux (fps_acc, (cval :: cvals_acc)) xs
        | Expr _( Eannot fps( Expr _( Epure( Pexpr _ _( PEval cval))))) :: xs =>
        if do_race fps fps_acc then
          (* found an unsequenced race *)
          match ( debug.print_debug ( 1) []
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) =>
                         String.append "FOUND RACE: "
                           (String.append (pp_dyn_annotations fps)
                              (String.append " <---> "
                                 (pp_dyn_annotations fps_acc))) end )) with
              tt => None end else
          one_step_unseq_aux
            (combine_dyn_annotations fps fps_acc, (cval :: cvals_acc)) 
          xs | e :: _ =>
        (* all the operand of the unseq() must have already been reduced to values *)
      DAEMON end end.
(* [?]: removed value specification. *)

Definition one_step  (eval_pexpr1 : generic_pexpr (unit ) (symbol.sym ) -> state_exception_undefined.stExceptUndefM (generic_pexpr (unit ) (symbol.sym )) (core_run_state ) (errors.core_run_cause )) (full_eval_pexpr1 : generic_pexpr (unit ) (symbol.sym ) -> core_run_state  -> exception.exceptM ((undefined.t0 (generic_value (symbol.sym ))*core_run_state ) % type) (errors.core_run_cause )) (env1 : list (fmap (symbol.sym ) (value0 ))) (g : generic_expr (core_run_annotation ) (unit ) (symbol.sym ))  : option (one_step ) := 
  match ( (eval_pexpr1,full_eval_pexpr1,env1,g)) with
      ( eval_pexpr1,  full_eval_pexpr1,  env1,  Expr annots1 expr_ as expr1) =>
    if is_irreducible expr1 then None else
      match ( expr_) with (* {A_1} {A_2} E --> {A_1 union A_2} E *)
        | Eannot xs1( Expr annots2( Eannot xs2 e)) =>
        Some
          (TAU "Eannot" env1
             (Expr ( (@ List.app _) annots1 annots2)
                (Eannot (combine_dyn_annotations xs1 xs2) e)))
        | Ememop memop1 pes =>
        Some
          match ( valueFromPexprs pes) with | Some cvals =>
            MEMOP memop1 cvals | None =>
            EVAL "Ememop"
              (* begin block *) state_exception_undefined.stExceptUndef_bind
                                  (state_exception_undefined.stExceptUndef_mapM
                                     eval_pexpr1 pes)
                                  (fun (pes' : list (generic_pexpr (unit ) (symbol.sym ))) =>
                                     state_exception_undefined.stExceptUndef_return
                                       (Expr annots1 (Ememop memop1 pes')))
              (* end block *) end
        | Ecase( Pexpr _ tt( PEconstrained xs)) _ => DAEMON
        | Ecase pe pat_es =>
        Some
          match ( valueFromPexpr pe) with | Some cval =>
            (* TODO: stop using subst? *)
            match ( select_case subst_sym_expr cval pat_es) with | Some e' =>
              TAU "Ecase" env1 e' | None =>
              ILLTYPED
                ( String.append "Ecase, mismatched ==> " (DAEMON expr1)) end
            | None =>
            EVAL "Ecase"
              (* begin block *) state_exception_undefined.stExceptUndef_bind
                                  (eval_pexpr1 pe)
                                  (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
                                     state_exception_undefined.stExceptUndef_return
                                       (Expr annots1 (Ecase pe' pat_es)))
              (* end block *) end
      (*
    | Elet pat pe1 e2 ->
        match valueFromPexpr pe1 with
          | Just cval ->
              (* let pat = v in E2 --> { v / pat } E2 *)
              Just (TAU "Elet" (update_env pat cval env) e2)
          | Nothing ->
              Just begin
                EVAL "Elet" begin
                  eval_pexpr pe1 >>= fun pe1' ->
                  let () = Debug.print_debug 4 [] (fun () ->
                    "Elet ==> " ^ Pp.stringFromCore_pexpr pe1 ^
                    " --> " ^ Pp.stringFromCore_pexpr pe1'
                  ) in
                  E.return (Expr annots (Elet pat pe1' e2))
                end
              end
        end
*)
        | Elet pat pe1 e2 =>
        match ( valueFromPexpr pe1) with | Some cval =>
          (* let pat = v in E2 --> { v / pat } E2 *) Some
            (TAU "Elet" (update_env pat cval env1) e2) | None =>
          Some
            (* begin block *)
            (*              eval e1 = v
                 -------------------------------------
                 let pat = e1 in E2 --> { v / pat } E2 *)
            TAU_WITH_RUNSTATE "Elet"
              (* begin block *) state_exception_undefined.stExceptUndef_bind
                                  (full_eval_pexpr1 pe1)
                                  (fun (cval : generic_value (symbol.sym )) =>
                                     state_exception_undefined.stExceptUndef_return
                                       (update_env pat cval env1, e2))
              (* end block *) (* end block *) end
      (*
    | Eif pe1 e2 e3 ->
        Just match valueFromPexpr pe1 with
          | Just Vtrue ->
              (* if true the E2 else E3 --> E2 *)
              TAU "Eif (true)" env e2
          | Just Vfalse ->
              (* if false the E2 else E3 --> E3 *)
              TAU "Eif (false)" env e3
          | Just _ ->
              ILLTYPED "the first operand of an Eif didn't evaluated to a boolean"
          | Nothing ->
              EVAL "Eif" begin
                eval_pexpr pe1 >>= fun pe1' ->
                E.return (Expr annots (Eif pe1' e2 e3))
              end
        end
*)
        | Eif pe1 e2 e3 =>
        Some
          (* begin block *)
          TAU_WITH_RUNSTATE "Eif"
            (* begin block *) state_exception_undefined.stExceptUndef_bind
                                (full_eval_pexpr1 pe1)
                                (fun (x : generic_value (symbol.sym )) =>
                                   match (x) with | Vtrue =>
                                     state_exception_undefined.stExceptUndef_return
                                       (env1, e2) | Vfalse =>
                                     state_exception_undefined.stExceptUndef_return
                                       (env1, e3) | _ => DAEMON end)
            (* end block *) (* end block *) | Eunseq es =>
        (* assert: List.all is_irreducible es *)
        match ( one_step_unseq_aux ([], []) es) with | None =>
          Some UNSEQUENCED_RACE | Some (fps,  cvals) =>
          (* unseq({A_1}?v1, ..., {A_n}?vn) -->
                 {A_1 ...union... A_n}(v1, ..., v2)    (in the absence of race) *)
          Some
            (TAU "Eunseq" env1
               (Expr annots1 (Eannot fps (caux.mk_value_e (Vtuple cvals)))))
        end | Ewseq pat( Expr pe1_annots( Epure pe1)) e2 =>
        Some
          match ( valueFromPexpr pe1) with | Some cval =>
            (* letw pat = v in E2 --> { v / pat } E2 *) TAU "Ewseq"
              (update_env pat cval env1) e2 | None =>
            let mk_wseq := (fun (z : generic_pexpr (unit ) (symbol.sym )) =>
                              Expr annots1
                                (Ewseq pat (Expr pe1_annots (Epure z)) e2)) in
          EVAL "Ewseq"
            ( state_exception_undefined.stExceptUndef_fmap mk_wseq
                (eval_pexpr1 pe1)) end
        | Esseq pat( Expr pe1_annots( Epure pe1)) e2 =>
        Some
          match ( valueFromPexpr pe1) with | Some cval =>
            (* lets pat = v in E2 --> { v / pat } E2 *) TAU "Esseq"
              (update_env pat cval env1) e2 | None =>
            let mk_sseq := (fun (z : generic_pexpr (unit ) (symbol.sym )) =>
                              Expr annots1
                                (Esseq pat (Expr pe1_annots (Epure z)) e2)) in
          EVAL "Esseq"
            ( state_exception_undefined.stExceptUndef_fmap mk_sseq
                (eval_pexpr1 pe1)) end
        | Ewseq pat( Expr annots11( Eannot xs( Expr annots2( Epure pe1)))) e2 =>
        Some
          match ( valueFromPexpr pe1) with | Some cval =>
            (* letw pat = {A}v in E2 --> {A} { v / pat } E2 *) TAU
              "Ewseq Eannot" (update_env pat cval env1)
              (Expr [] (Eannot xs e2)) | None =>
            let mk_wseq := (fun (z : generic_pexpr (unit ) (symbol.sym )) =>
                              Expr annots1
                                (Ewseq pat
                                   (Expr annots11
                                      (Eannot xs (Expr annots2 (Epure z))))
                                   e2)) in
          EVAL "Ewseq Eannot"
            ( state_exception_undefined.stExceptUndef_fmap mk_wseq
                (eval_pexpr1 pe1)) end
        | Esseq pat( Expr annots11( Eannot xs( Expr annots2( Epure pe1)))) e2 =>
        Some
          match ( valueFromPexpr pe1) with | Some cval =>
            (* lets pat = {A}v in E2 --> {A} { v / pat } E2 *) TAU
              "Esseq Eannot" (update_env pat cval env1)
              (Expr [] (Eannot xs e2)) | None =>
            let mk_sseq := (fun (z : generic_pexpr (unit ) (symbol.sym )) =>
                              Expr annots1
                                (Esseq pat
                                   (Expr annots11
                                      (Eannot xs (Expr annots2 (Epure z))))
                                   e2)) in
          EVAL "Esseq Eannot"
            ( state_exception_undefined.stExceptUndef_fmap mk_sseq
                (eval_pexpr1 pe1)) end | Esave sym_bTy sym_bTy_pes e =>
        Some
          match ( valueFromPexprs
                    (List.map
                       (fun (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                          match ( (p) ) with ( (_,  (_,  z))) => z end)
                       sym_bTy_pes)) with | Some cvals =>
            TAU "Esave"
              (* begin block *)
              List.fold_left
                (fun (acc : list (fmap (symbol.sym ) (value0 ))) (p : (((symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type)*generic_value (symbol.sym )) % type) =>
                   match ( (acc ,p) ) with
                       ( acc ,  ((sym1,  (bTy,  _)),  cval)) =>
                     update_env (caux.mk_sym_pat sym1 bTy) cval acc end )
                (lem_list.zip sym_bTy_pes cvals) env1 (* end block *) 
            e | None =>
            EVAL "Esave"
              (* begin block *) state_exception_undefined.stExceptUndef_bind
                                  (state_exception_undefined.stExceptUndef_mapM
                                     (fun (p : (symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type) =>
                                        match ( (p) ) with
                                            ( (sym1,  (bTy,  pe))) =>
                                          state_exception_undefined.stExceptUndef_bind
                                            (eval_pexpr1 pe)
                                            (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
                                               state_exception_undefined.stExceptUndef_return
                                                 (sym1, (bTy, pe'))) end )
                                     sym_bTy_pes)
                                  (fun (sym_bTy_pes' : list ((symbol.sym *((core_base_type *generic_pexpr (unit ) (symbol.sym )) % type)) % type)) =>
                                     state_exception_undefined.stExceptUndef_return
                                       (Expr annots1
                                          (Esave sym_bTy sym_bTy_pes' e)))
              (* end block *) end | _ => None end end.



Program Fixpoint stringFromContext  (ctx : context )  : string := 
  match ( ctx) with 
    | CTX =>
        "CTX"
    | Cunseq _ _ ctx' _ => 
        String.append"Cunseq["  (String.append(stringFromContext ctx') "]")
    | Cwseq _ _ ctx' _ => 
        String.append"Cwseq["  (String.append(stringFromContext ctx') "]")
    | Csseq _ _ ctx' _ => 
        String.append"Csseq["  (String.append(stringFromContext ctx') "]")
    | Cannot _ _ ctx' => 
        String.append"Cannot["  (String.append(stringFromContext ctx') "]")
    | Cbound _ ctx' => 
        String.append"Cbound["  (String.append(stringFromContext ctx') "]")
  end.
(* [?]: removed value specification. *)

Program Fixpoint get_ctx  (g : generic_expr (core_run_annotation ) (unit ) (symbol.sym ))  : list ((context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type):= 
  match ( (g)) with ( Expr annot1 expr_ as expr1) =>
    if is_irreducible expr1 then [(CTX, expr1)] else
      match ( expr_) with | Epure _ => [(CTX, expr1)] | Ememop _ _ =>
        [(CTX, expr1)] | Eaction _ => [(CTX, expr1)] | Ecase _ _ =>
        [(CTX, expr1)] | Elet _ _ _ => [(CTX, expr1)] | Eif _ _ _ =>
        [(CTX, expr1)] | Eccall _ _ _ _ => [(CTX, expr1)] | Eproc _ _ _ =>
        [(CTX, expr1)] | Eunseq es =>
        if List.forallb is_irreducible es then [(CTX, expr1)] else
          get_ctx_unseq_aux annot1 [] [] es | Ewseq pat e1 e2 =>
        if is_irreducible e1 then [(CTX, expr1)] else
          List.map
            (fun (p : (context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (ctx,  e)) =>
                 (Cwseq annot1 pat ctx e2, e) end ) (get_ctx e1)
        | Esseq pat e1 e2 =>
        if is_irreducible e1 then [(CTX, expr1)] else
          List.map
            (fun (p : (context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (ctx,  e)) =>
                 (Csseq annot1 pat ctx e2, e) end ) (get_ctx e1)
        | Easeq _ _ _ => [(CTX, expr1)] | Ebound e =>
        if is_irreducible e then [(CTX, expr1)] else
          List.map
            (fun (p : (context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (ctx,  e)) => (Cbound annot1 ctx, e) end
            ) (get_ctx e) | End _ => [(CTX, expr1)] | Esave _ _ _ =>
        [(CTX, expr1)] | Erun _ _ _ => [(CTX, expr1)] | Epar _ =>
        [(CTX, expr1)] | Ewait _ => [(CTX, expr1)]
        | Eannot _( Expr _( Eannot _ e)) => [(CTX, expr1)] | Eannot xs e =>
        List.map
          (fun (p : (context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
             match ( (p) ) with ( (ctx,  e)) => (Cannot annot1 xs ctx, e) end
          ) (get_ctx e) | Eexcluded _ _ => [(CTX, expr1)] end end
with get_ctx_unseq_aux  (annot1 : list (annot.annot )) (acc : list ((context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type)) (es1 : list (generic_expr (core_run_annotation ) (unit ) (symbol.sym )))  : list (generic_expr (core_run_annotation ) (unit ) (symbol.sym )) -> list ((context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type):= 
  match ( (annot1,acc,es1)) with ( annot1,  acc,  es1) =>
    fun (x : list (generic_expr (core_run_annotation ) (unit ) (symbol.sym ))) =>
      match (x) with | [] => acc | e :: es2 =>
        if is_irreducible e then
          get_ctx_unseq_aux annot1 acc ( (@ List.app _) es1 [e]) es2 else
          let zs :=
          List.map
            (fun (p : (context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
               match ( (p) ) with ( (ctx,  e)) =>
                 (Cunseq annot1 es1 ctx es2, e) end ) (get_ctx e) in
          get_ctx_unseq_aux annot1 ( (@ List.app _) zs acc)
            ( (@ List.app _) es1 [e]) es2 end end.
(* [?]: removed value specification. *)

Program Fixpoint apply_ctx  (ctx : context ) (expr1 : generic_expr (core_run_annotation ) (unit ) (symbol.sym ))  : generic_expr (core_run_annotation ) (unit ) (symbol.sym ):= 
  match ( ctx) with 
    | CTX =>
        expr1
    | Cunseq annot1 es1 ctx' es2 =>
        Expr annot1 (Eunseq ( (@ List.app _)es1 (apply_ctx ctx' expr1 :: es2)))
    | Cwseq annot1 pat ctx' e2 =>
        Expr annot1 (Ewseq pat (apply_ctx ctx' expr1) e2)
    | Csseq annot1 pat ctx' e2 =>
        Expr annot1 (Esseq pat (apply_ctx ctx' expr1) e2)
    | Cannot annot1 xs ctx' =>
        Expr annot1 (Eannot xs (apply_ctx ctx' expr1))
    | Cbound annot1 ctx' =>
        Expr annot1 (Ebound (apply_ctx ctx' expr1))
  end.


Definition act_valueFromPexpr   : generic_pexpr (unit ) (symbol.sym ) -> option (value0 ) :=  
  fun (x : generic_pexpr (unit ) (symbol.sym )) =>
    match (x) with | Pexpr _ _( PEconstrained _) => DAEMON | z =>
      valueFromPexpr z end.

Inductive action_step : Type := 
  | ACTION_REQUEST:  string  ->  unit  ->  action_request2  (core.expr  core_run_annotation ) -> action_step 
  | ACTION_EVAL:  string  ->  core_runM  (core.action  core_run_annotation ) -> action_step 
  | ACTION_ILLTYPED:  string  -> action_step .
Definition action_step_default: action_step  := ACTION_REQUEST string_default unit_default DAEMON.
(* [?]: removed value specification. *)

Definition step_action  (eval_pexpr1 : generic_pexpr (unit ) (symbol.sym ) -> core_run_state  -> exception.exceptM ((undefined.t0 (generic_pexpr (unit ) (symbol.sym ))*core_run_state ) % type) (errors.core_run_cause )) (is_excluded : option (nat ) ) (g : generic_action (core_run_annotation ) (unit ) (symbol.sym ))  : action_step := 
  match ( (eval_pexpr1,is_excluded,g)) with
      ( eval_pexpr1,  is_excluded, ( Action loc act_annots act)) =>
    let wrap := (fun (z : generic_action_ (unit ) (symbol.sym )) =>
                   Action loc act_annots z) in
  match ( act) with | Create pe1 pe2 pref =>
    match ( (act_valueFromPexpr pe1, act_valueFromPexpr pe2)) with
          | (Some( Vobject( OVinteger ival)),  Some( Vctype ty)) =>
      ACTION_REQUEST "CreateRequest" loc
        (* begin block *)
        CreateRequest2 pref ival ty None
          (fun (aid1 : nat ) (ptrval : unit ) =>
             caux.mk_value_e (Vobject (OVpointer ptrval)) ) (* end block *)
      | (Some _,  Some _) => ACTION_ILLTYPED "Create" | (None,  _) =>
      ACTION_EVAL "first operand of Create"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe1)
                            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Create pe1' pe2 pref)))
        (* end block *) | (_,  None) =>
      ACTION_EVAL "second operand of Create"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe2)
                            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Create pe1 pe2' pref)))
        (* end block *) end | CreateReadOnly pe1 pe2 pe3 pref =>
    match ( (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr
                                                               pe3)) with
          | (Some( Vobject( OVinteger ival)),  Some( Vctype ty),  Some cval3) =>
      match ( memValueFromValue (ctype.Ctype [] (ctype.unatomic_ ty)) cval3) with
            | Some mval =>
        ACTION_REQUEST "CreateRequest" loc
          (* begin block *)
          CreateRequest2 pref ival ty (Some mval)
            (fun (aid1 : nat ) (ptrval : unit ) =>
               caux.mk_value_e (Vobject (OVpointer ptrval)) ) (* end block *)
        | None =>
        ACTION_ILLTYPED
          (* begin block *)
          String.append ("")
            (String.append "the value of a create_readonly("
               (String.append (DAEMON (ctype.Ctype [] (ctype.unatomic_ ty)))
                  (String.append ") didn't match the lvalue type: "
                     (DAEMON cval3)))) (* end block *) end
      | (Some _,  Some _,  Some _) => ACTION_ILLTYPED "CreateReadOnly"
      | (None,  _,  _) =>
      ACTION_EVAL "first operand of CreateReadOnly"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe1)
                            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (CreateReadOnly pe1' pe2 pe3 pref)))
        (* end block *) | (_,  None,  _) =>
      ACTION_EVAL "second operand of CreateReadOnly"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe2)
                            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (CreateReadOnly pe1 pe2' pe3 pref)))
        (* end block *) | (_,  _,  None) =>
      ACTION_EVAL "third operand of CreateReadOnly"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe3)
                            (fun (pe3' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (CreateReadOnly pe1 pe2 pe3' pref)))
        (* end block *) end
    | Store is_locking pe1 pe2( Pexpr _ tt( PEconstrained xs3)) mo1 => DAEMON
    | Store is_locking pe1 pe2 pe3 mo1 =>
    match ( (act_valueFromPexpr pe1, act_valueFromPexpr pe2, act_valueFromPexpr
                                                               pe3)) with
          | (Some( Vctype ty),  Some( Vobject( OVpointer ptrval)),  Some cval) =>
      match ( memValueFromValue (ctype.Ctype [] (ctype.unatomic_ ty)) cval) with
            | Some mval =>
        ACTION_REQUEST "StoreRequest" loc
          (* begin block *)
          StoreRequest2 mo1 ty is_locking ptrval mval
            (fun (aid1 : nat ) (fp : unit ) => let dyn_annots :=
               match ( is_excluded) with | None => [DA_pos [] fp]
                 | Some excl_id => [DA_neg excl_id [] fp] end in
               Expr [] (Eannot dyn_annots (caux.mk_value_e Vunit)) )
          (* end block *) | None =>
        ACTION_ILLTYPED
          (* begin block *)
          String.append ("")
            (String.append "the value of a store("
               (String.append (DAEMON (ctype.Ctype [] (ctype.unatomic_ ty)))
                  (String.append ") didn't match the lvalue type: "
                     (DAEMON cval)))) (* end block *) end
      | (Some _,  Some _,  Some _) => ACTION_ILLTYPED "Store"
      | (None,  _,  _) =>
      ACTION_EVAL "first operand of Store"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe1)
                            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Store is_locking pe1' pe2 pe3 mo1)))
        (* end block *) | (_,  None,  _) =>
      ACTION_EVAL "second operand of Store"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe2)
                            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Store is_locking pe1 pe2' pe3 mo1)))
        (* end block *) | (_,  _,  None) =>
      ACTION_EVAL "third operand of Store"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe3)
                            (fun (pe3' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Store is_locking pe1 pe2 pe3' mo1)))
        (* end block *) end | Load pe1 pe2 mo1 =>
    match ( (act_valueFromPexpr pe1, act_valueFromPexpr pe2)) with
          | (Some( Vctype ty),  Some( Vobject( OVpointer ptrval))) =>
      ACTION_REQUEST "LoadRequest" loc
        (* begin block *) let val_sym := symbol.fresh tt in
        LoadRequest2 mo1 ty ptrval val_sym
          (fun (aid1 : nat ) (fp : unit ) (mval : unit ) => let dyn_annots :=
             match ( is_excluded) with | None => [DA_pos [] fp]
               | Some excl_id => [DA_neg excl_id [] fp] end in
             match ( caux.valueFromMemValue mval) with (_,  cval) =>
               Expr [] (Eannot dyn_annots (caux.mk_value_e cval)) end )
        (* end block *) | (Some _,  Some _) => ACTION_ILLTYPED "Load"
      | (None,  _) =>
      ACTION_EVAL "first operand of Load"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe1)
                            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Load pe1' pe2 mo1))) (* end block *)
      | (_,  None) =>
      ACTION_EVAL "second operand of Load"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe2)
                            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Load pe1 pe2' mo1))) (* end block *)
    end | Alloc pe1 pe2 pref =>
    match ( (act_valueFromPexpr pe1, act_valueFromPexpr pe2)) with
          | (Some( Vobject( OVinteger ival1)),  Some( Vobject( OVinteger ival2))) =>
      ACTION_REQUEST "AllocRequest" loc
        (* begin block *)
        AllocRequest2 pref ival1 ival2
          (fun (aid1 : nat ) (ptrval : unit ) =>
             caux.mk_value_e (Vobject (OVpointer ptrval)) ) (* end block *)
      | (Some _,  Some _) => ACTION_ILLTYPED "Alloc" | (None,  _) =>
      ACTION_EVAL "first operand of Alloc"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe1)
                            (fun (pe1' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Alloc pe1' pe2 pref)))
        (* end block *) | (_,  None) =>
      ACTION_EVAL "second operand of Alloc"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe2)
                            (fun (pe2' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Alloc pe1 pe2' pref)))
        (* end block *) end | Kill is_dynamic pe =>
    match ( act_valueFromPexpr pe) with
          | Some( Vobject( OVpointer ptrval)) =>
      ACTION_REQUEST "KillRequest" loc
        (* begin block *)
        KillRequest2 is_dynamic ptrval
          (fun (aid1 : nat ) => caux.mk_value_e Vunit) (* end block *)
      | Some _ => ACTION_ILLTYPED "Kil" | None =>
      ACTION_EVAL "operand of Kill"
        (* begin block *) state_exception_undefined.stExceptUndef_bind
                            (eval_pexpr1 pe)
                            (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
                               state_exception_undefined.stExceptUndef_return
                                 (wrap (Kill is_dynamic pe')))
        (* end block *) end | SeqRMW _ _ _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | RMW _ _ _ _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | Fence _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | CompareExchangeStrong _ _ _ _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | CompareExchangeWeak _ _ _ _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | LinuxFence _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | LinuxLoad _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | LinuxStore _ _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
    | LinuxRMW _ _ _ _ =>
    action_step_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 530, character 3 to line 715, character 3 *)
  end end.




Definition is_constrained {a b : Type}   : generic_pexpr b a -> bool :=  
  fun (x : generic_pexpr b a) =>
    match (x) with | Pexpr _ _( PEconstrained _) => true | _ => false end.
(* [?]: removed value specification. *)

(*
  | CTX
  | Cunseq of list Annot.annot * list (Core.expr core_run_annotation) * context * list (Core.expr core_run_annotation)
  | Cwseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Csseq of list Annot.annot * Core.pattern * context * Core.expr core_run_annotation
  | Cannot of list Annot.annot * Core.dyn_annotation * context
  | Cbound of list Annot.annot * context
*)

Program Fixpoint break_at_sseq  (ctx : context )  : option ((context *generic_pattern (unit ) (symbol.sym )*context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) := 
  match ( ctx) with 
    | CTX =>
        None
    | Cwseq annots1 pat ctx' e2 =>
        match ( break_at_sseq ctx') with 
          | None =>
              None
          | Some (ctxA,  sseq_pat,  ctxB,  sseq_e2) =>
              Some (Cwseq annots1 pat ctxA e2, sseq_pat, ctxB, sseq_e2)
        end
    | Csseq annots1 pat ctx' e2 =>
        match ( break_at_sseq ctx') with 
          | None =>
              Some (CTX, pat, ctx', e2)
          | Some (in_ctxA,  in_pat,  in_ctxB,  in_e2) =>
              Some (Csseq annots1 pat in_ctxA e2, in_pat, in_ctxB, in_e2)
      end
    | Cunseq annots1 es1 ctx' es2 =>
        match ( break_at_sseq ctx') with 
          | None =>
              None
          | Some (ctxA,  sseq_pat,  ctxB,  sseq_e2) =>
              Some (Cunseq annots1 es1 ctxA es2, sseq_pat, ctxB, sseq_e2)
        end
    | Cannot annots1 xs ctx' =>
        match ( break_at_sseq ctx') with 
          | None =>
              None
          | Some (ctxA,  sseq_pat,  ctxB,  sseq_e2) =>
              Some (Cannot annots1 xs ctxA, sseq_pat, ctxB, sseq_e2)
        end
    | Cbound annots1 ctx' =>
        DAEMON
(*
        match break_at_sseq ctx' with
          | Nothing ->
              Nothing
          | Just (ctxA, sseq_pat, ctxB, sseq_e2) ->
              Just (Cbound annots ctxA, sseq_pat, ctxB, sseq_e2)
        end
*)
  end.

Inductive break : Type := 
  | NO_BOUND: break 
  | BOUND_NO_SSEQ:  context  ->  context  -> break 
  | BOUND_WITH_SSEQ:  context  ->  context  ->  core.pattern  ->  context  ->  core.expr  core_run_annotation  -> break .
Definition break_default: break  := NO_BOUND.

Program Fixpoint break_at_bound_and_sseq  (ctx : context )  : break := 
  match ( ctx) with 
    | CTX =>
        NO_BOUND
    | Cwseq annots1 pat ctx' e2 =>
        match ( break_at_bound_and_sseq ctx') with 
          | NO_BOUND =>
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB =>
              BOUND_NO_SSEQ (Cwseq annots1 pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq =>
              BOUND_WITH_SSEQ (Cwseq annots1 pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
        end
    | Csseq annots1 pat ctx' e2 =>
        match ( break_at_bound_and_sseq ctx') with 
          | NO_BOUND =>
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB =>
              BOUND_NO_SSEQ (Csseq annots1 pat ctxA e2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq =>
              BOUND_WITH_SSEQ (Csseq annots1 pat ctxA e2) ctxB sseq_pat ctxC e2_sseq
      end
    | Cunseq annots1 es1 ctx' es2 =>
        match ( break_at_bound_and_sseq ctx') with 
          | NO_BOUND =>
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB =>
              BOUND_NO_SSEQ (Cunseq annots1 es1 ctxA es2) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq =>
              BOUND_WITH_SSEQ (Cunseq annots1 es1 ctxA es2) ctxB sseq_pat ctxC e2_sseq
        end
    | Cannot annots1 xs ctx' =>
        match ( break_at_bound_and_sseq ctx') with 
          | NO_BOUND =>
              NO_BOUND
          | BOUND_NO_SSEQ ctxA ctxB =>
              BOUND_NO_SSEQ (Cannot annots1 xs ctxA) ctxB
          | BOUND_WITH_SSEQ ctxA ctxB sseq_pat ctxC e2_sseq =>
              BOUND_WITH_SSEQ (Cannot annots1 xs ctxA) ctxB sseq_pat ctxC e2_sseq
        end
    | Cbound annots1 ctx' =>
        match ( break_at_sseq ctx') with 
          | None =>
              BOUND_NO_SSEQ (Cbound annots1 CTX) ctx'
          | Some (ctxA,  sseq_pat,  ctxB,  sseq_e2) =>
              BOUND_WITH_SSEQ (Cbound annots1 CTX) ctxA sseq_pat ctxB sseq_e2
        end
  end.


Program Fixpoint pull_dyn_annotations  (z : context )  : (list (list (dyn_annotation ))*context ) % type:= 
  match ( z) with 
    | CTX =>
        ([], CTX)
    | Cunseq annots1 es1 ctx es2 => 
  match ( pull_dyn_annotations ctx) with (acc,  ctx') =>
    (acc, Cunseq annots1 es1 ctx' es2) end
    | Cwseq annots1 pat ctx e2 => 
  match ( pull_dyn_annotations ctx) with (acc,  ctx') =>
    (acc, Cwseq annots1 pat ctx' e2) end
    | Csseq annots1 pat ctx e2 => 
  match ( pull_dyn_annotations ctx) with (acc,  ctx') =>
    (acc, Csseq annots1 pat ctx' e2) end
    | Cannot annots1 xs ctx => 
  match ( pull_dyn_annotations ctx) with (acc,  ctx') => ((xs :: acc), ctx')
  end
    | Cbound annots1 ctx => 
  match ( pull_dyn_annotations ctx) with (acc,  ctx') =>
    (acc, Cbound annots1 ctx') end
  end.

Program Fixpoint add_exclusion  (n : nat )  : context  -> context :=  
  fun (x : context ) =>
    match (x) with | CTX => CTX | Cunseq annots1 es1 ctx' es2 =>
      Cunseq annots1 es1 (add_exclusion n ctx') es2
      | Cwseq annots1 pat ctx' e2 =>
      Cwseq annots1 pat (add_exclusion n ctx') e2
      | Csseq annots1 pat ctx' e2 =>
      Csseq annots1 pat (add_exclusion n ctx') e2 | Cannot annots1 xs ctx' =>
      let xs' := List.map
                   (fun (x : dyn_annotation ) =>
                      match (x) with | DA_neg id excl fp =>
                        DA_neg id (n :: excl) fp | DA_pos excl fp =>
                        DA_pos (n :: excl) fp end) xs in
    Cannot annots1 xs' (add_exclusion n ctx') | Cbound annots1 ctx' =>
      Cbound annots1 (add_exclusion n ctx') end.
(* [?]: removed value specification. *)

Definition step_ctx  (mem_st : mem.mem_state ) (file1 : generic_file (unit ) (core_run_annotation )) (core_extern : fmap (symbol.sym ) (symbol.sym )) (current_tid : nat ) (p : (option (nat ) *thread_state ) % type)  : list (core_step2 ):= 
  match ( (mem_st,file1,core_extern,current_tid,p)) with
      ( mem_st,  file1,  core_extern,  current_tid,  (parent_tid_opt,  th_st)) =>
    let eval_pexpr1 := (fun (pe : generic_pexpr (unit ) (symbol.sym )) =>
                          state_exception_undefined.stExceptUndef_bind
                            (e.eval_pexpr20 th_st core_extern mem_st file1 pe)
                            (fun (x : sum (generic_pexpr (unit ) (symbol.sym )) (generic_value (symbol.sym ))) =>
                               match (x) with | inl pe' =>
                                 state_exception_undefined.stExceptUndef_return
                                   pe' | inr cval =>
                                 state_exception_undefined.stExceptUndef_return
                                   (caux.mk_value_pe cval) end)) in
  let full_eval_pexpr' := (fun (pe : generic_pexpr (unit ) (symbol.sym )) =>
                             full_eval_pexpr th_st core_extern mem_st 
                             file1 pe) in
  List.map
    (fun (x : (context *generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
       match (x) with
             | (CTX,  Expr e_annots( Epure( Pexpr _ _( PEval cval)))) =>
         match ((stack  th_st)) with | Stack_empty =>
           (*error "impossible ==> step_ctx ctx = CTX and stack = Stack_empty"*)
           (* TODO: this indirection is silly... *) Step_done2 cval
           | Stack_cons2 _ CTX Stack_empty =>
           (* reached the end of the execution of a thread. *)
           match ( parent_tid_opt) with | Some parent_tid =>
             match ( debug.print_debug ( 3) []
                       (fun (u : unit ) =>
                          match ( (u) ) with ( tt) =>
                            "TODO: end of normal thread" end )) with tt =>
               Step_thread_done2 parent_tid cval end | None =>
             match ( debug.print_debug ( 3) []
                       (fun (u : unit ) =>
                          match ( (u) ) with ( tt) =>
                            "TODO: end of startup thread" end )) with tt =>
               (* this was the startup thread *) Step_done2 cval end end
           | Stack_cons2 current_proc_opt CTX( Stack_cons2 parent_proc_opt caller_ctx sk') =>
           match ( debug.print_debug ( 3) []
                     (fun (u : unit ) =>
                        match ( (u) ) with ( tt) => "TODO: end of procedure"
                        end )) with tt =>
             (* reached the end of the execution of a procedure. *)
           let tsk :=
           match ( current_proc_opt) with | Some psym =>
             match ( (fmap_lookup_by
                        (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                           ordCompare sym1 sym2) psym (funinfo  file1))) with
                   | Some (ret_ty,  _,  _,  _) =>
               apply (core_run.TSK_Return psym)
                 (core_aux.memValueFromValue ret_ty cval) | None =>
               core_run.TSK_Misc end | None => core_run.TSK_Misc end in
           Step_tau2 "end of procedure" tsk
             (* begin block *)
             match ((env  th_st)) with | [] => DAEMON | _ :: env' => {[ {[
             {[ th_st with env:= env'  ]} with stack:= Stack_cons2
                                                         parent_proc_opt 
                                                       CTX sk'  ]} with arena:= 
             apply_ctx caller_ctx
               (Expr e_annots (Epure (caux.mk_value_pe cval)))  ]} end
             (* end block *) end | _ =>
           Step_tau2 "value in CTX" core_run.TSK_Misc
             (* begin block *)
             {[ th_st with arena:= (*apply_ctx ctx*) (Expr e_annots
                                                        (Epure
                                                           (caux.mk_value_pe
                                                              cval)))  ]}
             (* end block *) end
         | (CTX, ( Expr _( Eannot _( Expr _( Epure( Pexpr _ _( PEval _))) as expr')))) =>
         (* {A}v -> v   (in empty context) *) Step_tau2 "CTX, Eannot(value)"
           core_run.TSK_Misc
           (* begin block *) {[ th_st with arena:= expr'  ]} (* end block *)
         | (ctx,  expr1) =>
         match ( expr1) with Expr e_annots expr_ =>
           let wrap_expr := (fun (z : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                               {[ th_st with arena:= apply_ctx ctx z  ]}) in
         let process_action := (fun (is_excluded : option (nat ) ) (wrap_act : generic_action (core_run_annotation ) (unit ) (symbol.sym ) -> generic_expr_ (core_run_annotation ) (unit ) (symbol.sym )) (z : generic_action (core_run_annotation ) (unit ) (symbol.sym )) =>
                                  match ( step_action eval_pexpr1 is_excluded
                                            z) with
                                        | ACTION_REQUEST debug_str loc _request =>
                                    Step_action_request2 debug_str loc
                                      current_tid
                                      (* begin block *)
                                      state_exception_undefined.stExceptUndef_return
                                        match ( _request) with
                                              | CreateRequest2 pref ival ty mval_opt mk_expr' =>
                                          CreateRequest2 pref ival ty
                                            mval_opt
                                            (fun (aid1 : nat ) (ptrval : unit ) =>
                                               wrap_expr
                                                 (mk_expr' aid1 ptrval) )
                                          | AllocRequest2 pref ival1 ival2 mk_expr' =>
                                          AllocRequest2 pref ival1 ival2
                                            (fun (aid1 : nat ) (ptrval : unit ) =>
                                               wrap_expr
                                                 (mk_expr' aid1 ptrval) )
                                          | LoadRequest2 mo1 ty ptrval sym1 mk_expr' =>
                                          LoadRequest2 mo1 ty ptrval 
                                          sym1
                                            (fun (aid1 : nat ) (fp : unit ) (mval : unit ) =>
                                               wrap_expr
                                                 (mk_expr' aid1 fp mval) )
                                          | StoreRequest2 mk ty is_locking ptrval mval mk_expr' =>
                                          StoreRequest2 mk ty is_locking
                                            ptrval mval
                                            (fun (aid1 : nat ) (fp : unit ) =>
                                               wrap_expr (mk_expr' aid1 fp) )
                                          | KillRequest2 is_dynamic ptrval mk_expr' =>
                                          KillRequest2 is_dynamic ptrval
                                            (fun (aid1 : nat ) =>
                                               wrap_expr (mk_expr' aid1) )
                                          | SeqRMWRequest2 _ _ _ _ =>
                                          DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1046, character 28 to line 1067, character 21 *)
                                        end (* end block *)
                                    | ACTION_EVAL debug_str eval_m =>
                                    Step_with_runstate2 (RSK_eval debug_str)
                                      (* begin block *) state_exception_undefined.stExceptUndef_bind
                                                          eval_m
                                                          (fun (act' : generic_action (core_run_annotation ) (unit ) (symbol.sym )) =>
                                                             state_exception_undefined.stExceptUndef_return
                                                               (wrap_expr
                                                                  (Expr
                                                                    e_annots
                                                                    (
                                                                    wrap_act
                                                                    act'))))
                                      (* end block *)
                                    | ACTION_ILLTYPED str => Step_error2 str
                                  end) in
         match ( expr_) with | Epure( Pexpr _ _( PEval _)) => DAEMON
           | Epure pe =>
           (* pe is NOT a value *) Step_with_runstate2 (RSK_eval "Epure")
             (* begin block *) state_exception_undefined.stExceptUndef_bind
                                 (eval_pexpr1 pe)
                                 (fun (pe' : generic_pexpr (unit ) (symbol.sym )) =>
                                    state_exception_undefined.stExceptUndef_return
                                      (wrap_expr (Expr e_annots (Epure pe'))))
             (* end block *)
           | Ebound( Expr _( Eannot _( Expr _( Epure( Pexpr _ _( PEval _))) as expr'))) =>
           (* bound({A}v)-> v *) Step_tau2 "CTX, Ebound Eannot(value)"
             core_run.TSK_Misc
             (* begin block *) wrap_expr expr' (* end block *)
           | Ebound( Expr _( Epure( Pexpr _ _( PEval _))) as expr') =>
           (* bound(v)-> v *) Step_tau2 "CTX, Ebound(value)"
             core_run.TSK_Misc
             (* begin block *) wrap_expr expr' (* end block *)
           | Eaction( Paction p( Action loc _( SeqRMW with_forward pe1 pe2 sym1 pe3))) =>
           if classical_boolean_equivalence p Neg then DAEMON else
             Step_action_request2 "SeqRMW" loc current_tid
               (* begin block *) state_exception_undefined.stExceptUndef_bind
                                   (full_eval_pexpr' pe1)
                                   (fun (cval1 : generic_value (symbol.sym )) =>
                                      state_exception_undefined.stExceptUndef_bind
                                        (full_eval_pexpr' pe2)
                                        (fun (cval2 : generic_value (symbol.sym )) =>
                                           match ( (cval1, cval2)) with
                                                 | (Vctype ty,  Vobject( OVpointer ptrval)) =>
                                             state_exception_undefined.stExceptUndef_bind
                                               e.fresh_excluded_id
                                               (fun (n : nat ) =>
                                                  state_exception_undefined.stExceptUndef_return
                                                    (* begin block *)
                                                    SeqRMWRequest2 ty 
                                                    ptrval
                                                      (fun (mval : unit ) =>
                                                         let th_st_tmp :=
                                                         {[ th_st with env:=
                                                         match ((env  th_st)) with
                                                               | [] => DAEMON
                                                           | x :: xs =>
                                                           fmap_add sym1
                                                             ((@ snd _ _)
                                                                (caux.valueFromMemValue
                                                                   mval)) 
                                                           x :: xs end  ]} in 
                                                         state_exception_undefined.stExceptUndef_bind
                                                           (full_eval_pexpr
                                                              th_st_tmp
                                                              core_extern
                                                              mem_st 
                                                            file1 pe3)
                                                           (fun (cval3 : generic_value (symbol.sym )) =>
                                                              match ( 
                                                              memValueFromValue
                                                                (ctype.Ctype
                                                                   []
                                                                   (ctype.unatomic_
                                                                    ty))
                                                                cval3) with
                                                                    | Some mval' =>
                                                                state_exception_undefined.stExceptUndef_return
                                                                  mval'
                                                                | None =>
                                                                DAEMON end))
                                                      (fun (aid1 : nat ) (fp : unit ) (mval : unit ) (mval' : unit ) =>
                                                         let cval_e :=
                                                         caux.mk_value_e
                                                           ((@ snd _ _)
                                                              (caux.valueFromMemValue
                                                                 (
                                                                 if with_forward then
                                                                   mval' else
                                                                   mval))) in
                                                         let mk_annot_e := (
                                                         fun (z : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                                                           Expr []
                                                             (Eannot
                                                                [DA_neg 
                                                                 n [] 
                                                                 fp] 
                                                              z)) in
                                                         (* TODO: try to factorize this with the code for negative actions *)
                                                         match ( break_at_bound_and_sseq
                                                                   ctx) with
                                                               | NO_BOUND =>
                                                           DAEMON
                                                           | BOUND_NO_SSEQ ctx_bound ctxA =>
                                                           let ctxA' := 
                                                         add_exclusion 
                                                         n ctxA in
                                                         let sym1 := 
                                                         symbol.fresh 
                                                         tt in let expr' :=
                                                         caux.mk_wseq_e
                                                           (caux.mk_tuple_pat
                                                              [ caux.mk_empty_pat
                                                                  BTy_unit(*TODO:HACKHACK*)
                                                              ; caux.mk_sym_pat
                                                                  sym1
                                                                  BTy_unit](*TODO:HACKHACK*) )
                                                           (caux.mk_unseq_e
                                                              [ mk_annot_e
                                                                  (caux.mk_value_e
                                                                    Vunit)
                                                              ; apply_ctx
                                                                  ctxA'
                                                                  cval_e] )
                                                           (caux.mk_pure_e
                                                              (caux.mk_sym_pe
                                                                 sym1)) in
                                                         {[ th_st with arena:= 
                                                         apply_ctx ctx_bound
                                                           expr'  ]}
                                                           | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 =>
                                                           (* TODO: check *)
                                                         (* Empty inner context, so no need to pull and annotate for exclusion *)
                                                         {[ th_st with arena:= 
                                                         apply_ctx ctx_bound
                                                           (apply_ctx 
                                                            ctxA
                                                              (caux.mk_sseq_e
                                                                 sseq_pat
                                                                 (mk_annot_e
                                                                    cval_e )
                                                                 sseq_e2))  ]}
                                                           | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 =>
                                                           let ctxB' := 
                                                         add_exclusion 
                                                         n ctxB in
                                                         let expr' :=
                                                         caux.mk_sseq_e
                                                           (caux.mk_tuple_pat
                                                              [ caux.mk_empty_pat
                                                                  BTy_unit(*TODO:HACKHACK*)
                                                              ; sseq_pat] )
                                                           (caux.mk_unseq_e
                                                              [ mk_annot_e
                                                                  (caux.mk_value_e
                                                                    Vunit)
                                                              ; apply_ctx
                                                                  ctxB'
                                                                  cval_e] )
                                                           sseq_e2 in
                                                         {[ th_st with arena:= 
                                                         apply_ctx ctx_bound
                                                           (apply_ctx 
                                                            ctxA expr')  ]}
                                                         end )
                                                    (* end block *)) | _ =>
                                             DAEMON end)) (* end block *)
           | Eaction( Paction p act) =>
           match ( act) with Action loc _ _ =>
             (* DEBUG *) match ( p) with | Pos =>
               process_action None
                 (*not excluded*) (fun (z : generic_action (core_run_annotation ) (unit ) (symbol.sym )) =>
                                     Eaction (Paction p z)) act | Neg =>
               match ( break_at_bound_and_sseq ctx) with | NO_BOUND => DAEMON
                 | BOUND_NO_SSEQ ctx_bound ctxA =>
                 let debug_str := String.append "Neg Action, no break ==> "
                                    ("") in
               Step_with_runstate2 (RSK_tau debug_str core_run.TSK_Misc)
                 (* begin block *) state_exception_undefined.stExceptUndef_bind
                                     e.fresh_excluded_id
                                     (fun (n : nat ) =>
                                        let ctxA' := add_exclusion n ctxA in
                                        let sym1 := symbol.fresh tt in
                                        let expr' :=
                                        caux.mk_wseq_e
                                          (caux.mk_tuple_pat
                                             [ caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                             ; caux.mk_sym_pat sym1 BTy_unit](*TODO:HACKHACK*) )
                                          (caux.mk_unseq_e
                                             [ Expr [] (Eexcluded n act)
                                             ; apply_ctx ctxA'
                                                 (caux.mk_pure_e
                                                    caux.mk_unit_pe)] )
                                          (caux.mk_pure_e
                                             (caux.mk_sym_pe sym1)) in
                                        state_exception_undefined.stExceptUndef_return
                                          {[ th_st with arena:= apply_ctx
                                                                  ctx_bound
                                                                  expr'  ]})
                 (* end block *)
                 | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat CTX sseq_e2 =>
                 (* TODO: check *)
                 (* Empty inner context, so no need to pull and annotate for exclusion *)
                 Step_tau2 "Neg Action, CTX" core_run.TSK_Misc
                   (* begin block *)
                   {[ th_st with arena:= apply_ctx ctx_bound
                                           (apply_ctx ctxA
                                              (caux.mk_sseq_e sseq_pat
                                                 (Expr []
                                                    (Eaction
                                                       (Paction Pos act)))
                                                 sseq_e2))  ]}
                   (* end block *)
                 | BOUND_WITH_SSEQ ctx_bound ctxA sseq_pat ctxB sseq_e2 =>
                 let debug_str := String.append "Neg Action, with break" ("") in
               Step_with_runstate2 (RSK_tau debug_str core_run.TSK_Misc)
                 (* begin block *) state_exception_undefined.stExceptUndef_bind
                                     e.fresh_excluded_id
                                     (fun (n : nat ) =>
                                        let ctxB' := add_exclusion n ctxB in
                                        let expr' :=
                                        caux.mk_sseq_e
                                          (caux.mk_tuple_pat
                                             [ caux.mk_empty_pat BTy_unit(*TODO:HACKHACK*)
                                             ; sseq_pat] )
                                          (caux.mk_unseq_e
                                             [ Expr [] (Eexcluded n act)
                                             ; apply_ctx ctxB'
                                                 (caux.mk_pure_e
                                                    caux.mk_unit_pe)] )
                                          sseq_e2 in
                                        state_exception_undefined.stExceptUndef_return
                                          {[ th_st with arena:= apply_ctx
                                                                  ctx_bound
                                                                  (apply_ctx
                                                                    ctxA
                                                                    expr')  ]})
                 (* end block *) end end end | Eexcluded n act =>
           process_action (Some n)
             (*is excluded*) (fun (z : generic_action (core_run_annotation ) (unit ) (symbol.sym )) =>
                                Eexcluded n z) act
           | Easeq sym_bTy act1 act2 =>
           match ( step_action eval_pexpr1 None (*not excluded*) act1) with
                 | ACTION_EVAL debug_str eval_m =>
             Step_with_runstate2 (RSK_eval debug_str)
               (* begin block *) state_exception_undefined.stExceptUndef_bind
                                   eval_m
                                   (fun (act1' : generic_action (core_run_annotation ) (unit ) (symbol.sym )) =>
                                      state_exception_undefined.stExceptUndef_return
                                        (wrap_expr
                                           (Expr e_annots
                                              (Easeq sym_bTy act1' act2))))
               (* end block *) | ACTION_ILLTYPED str => Step_error2 str
             | ACTION_REQUEST debug_str loc _request => DAEMON
           (*
                    match step_action eval_pexpr Nothing act2 with
                      | ACTION_EVAL debug_str eval_m ->
                          Step_with_runstate2 (RSK_eval debug_str) begin
                            eval_m >>= fun act2' ->
                            E.return (wrap_expr (Expr e_annots (Easeq sym_bTy act1 act2')))
                          end
                      | ACTION_ILLTYPED str ->
                          Step_error2 str
                      | ACTION_REQUEST _ _ _ ->
                          (* TODO: this is a horrible hack: in the previous call we pretended this  *)
                    end
*)
           (*
          match step_action eval_pexpr is_excluded z with
            | ACTION_REQUEST debug_str loc _request ->
                Step_action_request2 debug_str loc current_tid
                  match _request with
                    | CreateRequest2 pref ival ty mval_opt mk_expr' ->
                        CreateRequest2 pref ival ty mval_opt (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | AllocRequest2 pref ival1 ival2 mk_expr' ->
                        AllocRequest2 pref ival1 ival2 (fun aid ptrval ->
                          wrap_expr (mk_expr' aid ptrval)
                        )
                    | LoadRequest2 mo ty ptrval sym mk_expr' ->
                        LoadRequest2 mo ty ptrval sym (fun aid fp mval ->
                          wrap_expr (mk_expr' aid fp mval)
                        )
                    | StoreRequest2 mk ty is_locking ptrval mval mk_expr' ->
                        StoreRequest2 mk ty is_locking ptrval mval (fun aid fp ->
                          wrap_expr (mk_expr' aid fp)
                        )
                    | KillRequest2 is_dynamic ptrval mk_expr' ->
                        KillRequest2 is_dynamic ptrval (fun aid ->
                          wrap_expr (mk_expr' aid)
                        )
                  end
            | ACTION_ILLTYPED str ->
                Step_error2 str
*)
           end | Eccall call_annots ty pe pes =>
           Step_eval2 "Eccall"
             (* begin block *) state_exception_undefined.stExceptUndef_bind
                                 (full_eval_pexpr' pe)
                                 (fun (x : generic_value (symbol.sym )) =>
                                    match (x) with
                                          | Vloaded( LVspecified( OVpointer pv)) =>
                                      state_exception_undefined.stExceptUndef_bind
                                        (state_exception_undefined.stExceptUndef_mapM
                                           full_eval_pexpr' pes)
                                        (fun (cvals : list (generic_value (symbol.sym ))) =>
                                           let case_funptrval := (fun (psym : symbol.sym ) =>
                                                                    let mem_values :=
                                                                    match ( (
                                                                    fmap_lookup_by
                                                                    (
                                                                    fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                                                    ordCompare
                                                                    sym1 
                                                                    sym2)
                                                                    psym
                                                                    (funinfo  file1))) with
                                                                    | Some (_,  param_tys,  _,  _) =>
                                                                    apply
                                                                    (
                                                                    List.map
                                                                    (
                                                                    fun (p : (ctype.ctype *generic_value (symbol.sym )) % type) =>
                                                                    match ( (p) ) with
                                                                    ( (ty,  cval)) =>
                                                                    match ( 
                                                                    core_aux.memValueFromValue
                                                                    (
                                                                    ctype.Ctype
                                                                    []
                                                                    (
                                                                    ctype.Pointer
                                                                    ctype.no_qualifiers
                                                                    ty)) 
                                                                    cval) with
                                                                    | Some mval =>
                                                                    mval
                                                                    | None =>
                                                                    DAEMON
                                                                    end end))
                                                                    (
                                                                    lem_list.zip
                                                                    (
                                                                    List.map
                                                                    (
                                                                    @ 
                                                                    snd 
                                                                    _ 
                                                                    _)
                                                                    param_tys)
                                                                    cvals)
                                                                    | None =>
                                                                    apply
                                                                    (
                                                                    fun (_a : string )=>
                                                                    DAEMON)
                                                                    (
                                                                    String.append
                                                                    "Eccall : function "
                                                                    (
                                                                    String.append
                                                                    match ( psym) with
                                                                    symbol.Symbol0 d n str_opt =>
                                                                    String.append
                                                                    "Symbol"
                                                                    (
                                                                    stringFromPair
                                                                    (
                                                                    fun (n : nat )=>
                                                                    Coq.Numbers.DecimalString.NilZero.string_of_int
                                                                    (
                                                                    Z.to_int
                                                                    (
                                                                    Coq.ZArith.BinIntDef.Z.of_nat
                                                                    n)))
                                                                    (
                                                                    fun (x_opt : option (string ) )=>
                                                                    stringFromMaybe
                                                                    (
                                                                    fun (s : string )=>
                                                                    String.append
                                                                    """"
                                                                    (
                                                                    String.append
                                                                    s 
                                                                    """"))
                                                                    x_opt)
                                                                    (n, str_opt))
                                                                    end
                                                                    " not found"))
                                                                    end in 
                                                                    state_exception_undefined.stExceptUndef_bind
                                                                    (
                                                                    seu.runEU
                                                                    (
                                                                    exception.except_bind
                                                                    (
                                                                    core_run.call_proc
                                                                    core_extern
                                                                    file1
                                                                    psym
                                                                    cvals)
                                                                    exception_undefined.exception_undef_return
                                                                    ))
                                                                    (
                                                                    fun (p : (fmap (symbol.sym ) (value0 )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
                                                                    match ( (p) ) with
                                                                    ( (proc_env,  expr1)) =>
                                                                    state_exception_undefined.stExceptUndef_return
                                                                    {[ {[ {[ {[ th_st with env:= 
                                                                    proc_env
                                                                    ::
                                                                    (env  th_st)
                                                                     ]} with exec_loc:= 
                                                                    push_exec_loc
                                                                    psym
                                                                    (exec_loc  th_st)  ]} with stack:= 
                                                                    Stack_cons2
                                                                    (
                                                                    Some 
                                                                    psym) 
                                                                    CTX
                                                                    (
                                                                    match ((stack  th_st)) with
                                                                    Stack_cons2 sym_opt CTX sk' =>
                                                                    Stack_cons2
                                                                    sym_opt
                                                                    ctx 
                                                                    sk'
                                                                    | Stack_empty =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    | Stack_cons _ _ _ =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    | Stack_cons2 _(Cunseq _ _ _ _) _ =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    | Stack_cons2 _(Cwseq _ _ _ _) _ =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    | Stack_cons2 _(Csseq _ _ _ _) _ =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    | Stack_cons2 _(Cannot _ _ _) _ =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    | Stack_cons2 _(Cbound _ _) _ =>
                                                                    DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1303, character 63 to line 1303, character 147 *)
                                                                    end)  ]} with arena:= expr1  ]}
                                                                    end))
                                           (*
                      Step_tau "Eccall" (TSK_Ccall psym mem_values) (
                        SEU.runEU (
                          Exception.bind (call_proc core_extern file psym cvals)
                            EU.return
                        ) >>= fun (proc_env, expr) ->
                        (* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
                        let a_expr = add_to_sb (Set.map (fun z -> (Pos, z)) annots.sb_before) (* TODO: remove for sequential !!! *) expr in

                        E.return <| th_st with
                          arena= a_expr;
                          stack= push_empty_continuation (Just psym) sk;
                          exec_loc= push_exec_loc psym th_st.exec_loc;
                          env= proc_env :: th_st.env
                        |>
                      )
*)
                                           in
                                           DAEMON pv
                                             (fun ( _ : ctype.ctype ) =>
                                                DAEMON) case_funptrval
                                             (fun ( _ : option (Z ) ) (addr : Z ) =>
                                                (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
                                                match ( DAEMON mem_st pv) with
                                                      | Some sym1 =>
                                                  case_funptrval sym1
                                                  | None => DAEMON end)
                                             (fun ( _ : unit ) => DAEMON))
                                      | _ => DAEMON end) (* end block *)
           | Eproc _ _ _ => DAEMON | End es => DAEMON
           | Erun run_annots sym1 pes =>
           match ((stack  th_st)) with Stack_cons2( Some current_proc) _ _ =>
             Step_eval2 "Erun"
               (* begin block *) state_exception_undefined.stExceptUndef_bind
                                   (state_exception_undefined.runSE
                                      (state_exception.state_except_read
                                         (fun (st : core_run_state ) =>
                                            let proc_sym := match ( (
                                                            fmap_lookup_by
                                                              (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                                                 ordCompare
                                                                   sym1 
                                                                 sym2)
                                                              current_proc
                                                              core_extern)) with
                                                                  | Some proc_sym =>
                                                              proc_sym
                                                              | None =>
                                                              current_proc
                                                            end in
                                            lem_maybe.bind
                                              ((fmap_lookup_by
                                                  (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                                     ordCompare sym1 sym2)
                                                  proc_sym (labeled  st)))
                                              ((fmap_lookup_by
                                                  (fun (sym1 : symbol.sym ) (sym2 : symbol.sym )=>
                                                     ordCompare sym1 sym2)
                                                  sym1)) )))
                                   (fun (x : option ((list (symbol.sym )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) ) =>
                                      match (x) with | None => DAEMON
                                        | Some (syms,  cont_expr) =>
                                        let cont_expr' := List.fold_left
                                                            (fun (acc : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) (p : (symbol.sym *generic_pexpr (unit ) (symbol.sym )) % type) =>
                                                               match ( (acc ,p) ) with
                                                                   ( acc ,  (sym1,  pe)) =>
                                                                 unsafe_subst_sym_expr
                                                                   sym1 
                                                                 pe acc end )
                                                            (lem_list.zip
                                                               syms pes)
                                                            cont_expr in
                                      state_exception_undefined.stExceptUndef_return
                                        {[ th_st with arena:= cont_expr'
                                        (*                        stack= push_empty_continuation (Just current_proc) sk;*) (* TODO check *)
                                         ]} end) (* end block *)
             | Stack_empty =>
             core_step2_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1350, character 15 to line 1371, character 17 *)
             | Stack_cons _ _ _ =>
             core_step2_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1350, character 15 to line 1371, character 17 *)
             | Stack_cons2 None _ _ =>
             core_step2_default (* Incomplete Pattern at File \"ocaml_generated/core_reduction.lem\", line 1350, character 15 to line 1371, character 17 *)
           end | Epar es =>
           (* This step places waiting constructs in the arena and asks the
                 driver to spawn new threads *)
           Step_spawn_threads2
             (fun (tids : list (nat )) =>
                wrap_expr (caux.mk_unseq_e (List.map caux.mk_wait_e tids)))
             (* begin block *)
             List.map
               (fun (e : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                  {|arena:= e;stack:= (push_empty_continuation None
                                         empty_stack);errno:= (DAEMON
                                                                 ctype.signed_int);current_loc:=(current_loc  th_st);exec_loc:= (
                  ELoc_normal []);env:=(env  th_st) |}) es (* end block *)
           | Ewait tid1 => DAEMON | _ =>
           match ( one_step eval_pexpr1 full_eval_pexpr' (env  th_st) expr1) with
                 | None => DAEMON
             | Some( TAU_WITH_RUNSTATE debug_str step_m) =>
             Step_with_runstate2 (RSK_tau debug_str core_run.TSK_Misc)
               (* begin block *) state_exception_undefined.stExceptUndef_bind
                                   step_m
                                   (fun (p : (list (fmap (symbol.sym ) (value0 ))*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
                                      match ( (p) ) with ( (env',  expr')) =>
                                        state_exception_undefined.stExceptUndef_return
                                          {[ {[ th_st with env:= env'  ]} with arena:= 
                                          apply_ctx ctx expr'  ]} end)
               (* end block *) | Some( TAU debug_str env' expr') =>
             Step_tau2 debug_str core_run.TSK_Misc
               {[ {[ th_st with env:= env'  ]} with arena:= apply_ctx 
                                                            ctx expr'  ]}
             | Some( EVAL debug_str eval_m) =>
             Step_with_runstate2 (RSK_eval debug_str)
               (* begin block *) state_exception_undefined.stExceptUndef_bind
                                   eval_m
                                   (fun (expr' : generic_expr (core_run_annotation ) (unit ) (symbol.sym )) =>
                                      state_exception_undefined.stExceptUndef_return
                                        (wrap_expr expr')) (* end block *)
             | Some( MEMOP memop1 cvals) =>
             Step_memop_request2 memop1 cvals current_tid
               (fun (cval : generic_value (symbol.sym )) =>
                  wrap_expr (caux.mk_pure_e (caux.mk_value_pe cval)) )
             | Some UNSEQUENCED_RACE =>
             (* TODO: loc *) Step_eval2 "unsequenced race"
               (* begin block *)
               state_exception_undefined.stExceptUndef_undef tt
                 [undefined.UB035_unsequenced_race] (* end block *)
             | Some( ILLTYPED str) => Step_error2 str end end end end)
    (get_ctx (arena  th_st)) end.
