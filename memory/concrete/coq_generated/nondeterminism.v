(* Generated by Lem from ocaml_generated/nondeterminism.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(*
open import Pervasives String_extra Show
open import List Function
open import Utils
import Debug Dlist Constraints Symbolic Undefined Loc

import Global

import UniqueId
*)

Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import utils.
Require Export utils.
Require Import debug.
Require Export debug.

Require Import undefined.
Require Export undefined.




(* Cause of an execution path termination *)
Inductive kill_reason (err : Type) : Type := 
  | Undef0:  unit  ->  list  undefined.undefined_behaviour  -> kill_reason err
  | Error0:  unit  ->  string  -> kill_reason err
  | Other:  err -> kill_reason err.
Definition kill_reason_default{err: Type} : kill_reason err := Undef0 unit_default DAEMON.


Class Constraints (a: Type): Type := {
  empty:a;
  negate:a ->a;
  concat:a ->a ->a
}.


(* HACK *)
Instance x57_Constraints : Constraints unit := {
   empty  :=  tt;
   negate   x :=  tt;
   concat   x  y :=  tt
}.


Inductive nd_action (a : Type) (info : Type) (err : Type) (cs : Type) (st : Type) : Type := 
  | NDactive:  a -> nd_action a info err cs st
  | NDkilled:  kill_reason  err -> nd_action a info err cs st
  | NDnd:  info ->  list  ((info * ndM  a  info  err  cs  st) % type) -> nd_action a info err cs st
  | NDguard:  info ->  cs ->  ndM  a  info  err  cs  st -> nd_action a info err cs st
  | NDbranch:  info ->  cs ->  ndM  a  info  err  cs  st ->  ndM  a  info  err  cs  st -> nd_action a info err cs st
  | NDstep:  info ->  list  ((info * ndM  a  info  err  cs  st) % type) -> nd_action a info err cs st

with ndM (a : Type) (info : Type) (err : Type) (cs : Type) (st : Type) : Type := 
  ND:  (st ->  ((nd_action  a  info  err  cs  st * st) % type)) -> ndM a info err cs st.
Definition nd_action_default {a: Type} {info: Type} {err: Type} {cs: Type} {st: Type} : nd_action a info err cs st := NDactive DAEMON.
Definition ndM_default {a: Type} {info: Type} {err: Type} {cs: Type} {st: Type} : ndM a info err cs st := ND (fun (x56 : st) => (DAEMON, DAEMON)).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Definition nd_return {a b c d e : Type}  (a1 : a)  : ndM a e d c b:= 
  ND (fun (st : b) => (NDactive a1, st)).
(* [?]: removed top-level value definition. *)

Program Fixpoint nd_bind {a b c d e f : Type}  (n : ndM f b d a c) (f1 : f -> ndM e b d a c)  : ndM e b d a c:= 
  match ( (n,f1)) with (( ND m_act),  f1) =>
    ND
      (fun (st : c) =>
         match ( m_act st) with | (NDactive z,  st') =>
           match ( f1 z) with ND m_act' => m_act' st' end
           | (NDkilled r,  st') => (NDkilled r, st')
           | (NDnd debug_str str_ms,  st') =>
           (NDnd debug_str
              (List.map
                 (fun (p : (b*ndM f b d a c) % type) =>
                    match ( (p) ) with ( (str,  m)) => (str, nd_bind m f1)
                    end) str_ms), st')
           | (NDguard debug_str cs m_act',  st') =>
           (NDguard debug_str cs (nd_bind m_act' f1), st')
           | (NDbranch debug_str cs m_act1 m_act2,  st') =>
           (NDbranch debug_str cs (nd_bind m_act1 f1) (nd_bind m_act2 f1), st')
           | (NDstep info str_ms,  st') =>
           (NDstep info
              (List.map
                 (fun (p : (b*ndM f b d a c) % type) =>
                    match ( (p) ) with ( (str,  m)) => (str, nd_bind m f1)
                    end) str_ms), st') end ) end.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Definition nd_get {a b c d : Type}   : ndM a d c b a:= 
  ND (fun (st : a) => (NDactive st, st)).

Definition nd_put {a b c d : Type}  (st : a)  : ndM (unit ) d c b a:= 
  ND (fun ( _ : a) => (NDactive tt, st)).

Definition nd_update {a b c d : Type}  (f : a -> a)  : ndM (unit ) d c b a:= 
  ND (fun (st : a) => (NDactive tt, f st)).

Definition nd_read {a b c d e : Type}  (f : a -> b)  : ndM b e d c a:= 
  ND (fun (st : a) => (NDactive (f st), st)).
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition bindExhaustive {a b cs err info st : Type}  (m : ndM a info err cs st) (f : a -> ndM b info err cs st)  : ndM b info err cs st:=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 1) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) => "ND2.bindExhaustive is wrong" end
            )) with tt => nd_bind m f end.
(* [?]: removed value specification. *)

Definition kill {a cs err info st : Type}  (r : kill_reason err)  : ndM a info err cs st:= 
  ND (fun (st1 : st) => (NDkilled r, st1)).
(* [?]: removed value specification. *)

Definition log {cs err info st : Type}  (msg : string )  : ndM (unit ) info err cs st:= 
  BOOM "ND2.log".
(* [?]: removed value specification. *)

Definition print_debug {cs err info st : Type}  (level : nat ) (doms : list (domain )) (msg : unit  -> string )  : ndM (unit ) info err cs st:= 
  nd_return (fun (_:nat) (_: list domain) (_: unit -> string) := tt level doms msg).
(* [?]: removed value specification. *)

Definition mplus {a cs err info st : Type}  (m1 : ndM a info err cs st) (m2 : ndM a info err cs st)  : ndM a info err cs st:= 
  BOOM "ND2.mplus".
(* [?]: removed value specification. *)
 
Definition msum {a cs err info st : Type} `{Constraints cs} `{Show info}  (info1 : info)  : list ((info*ndM a info err cs st) % type) -> ndM a info err cs st:=  
  fun (x : list ((info*ndM a info err cs st) % type)) =>
    match (x) with | [] => BOOM "ND2.msum []" | [(_,  m)] => m | info_ms =>
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 1) []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     String.append "ND2.msum (|ms| = "
                       (String.append
                          (lem_string_extra.stringFromNat
                             (List.length info_ms)) ")") end )) with tt =>
        ND (fun (st1 : st) => (NDnd info1 info_ms, st1) ) end end.
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition nd_mapM {a b c d e f : Type}  (f1 : a -> ndM b e f d c)  : list a -> ndM (list b) e f d c:=  (fun (xs : list a)=>List.fold_right
    (fun (m : ndM b e f d c) (m' : ndM (list b) e f d c) =>  nd_bind
      m (fun (x : b)  => nd_bind
      m' (fun (xs : list b) =>
      nd_return (x::xs)))
    ) (nd_return []) ((List.map f1) xs)).
(* [?]: removed top-level value definition. *)


(* GENERIC Monad *)
Definition nd_sequence_ {a b c d e : Type}  (ms : list (ndM e c d b a))  : ndM (unit ) c d b a:=  List.fold_right (fun (m1 : ndM e c d b a) (m2 : ndM (unit ) c d b a) => nd_bind m1 (fun ( _ : e) => m2)) (nd_return tt) ms.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition nd_mapM_ {a b c d e f : Type}  (f1 : a -> ndM f d e c b) (_as : list a)  : ndM (unit ) d e c b:=  nd_sequence_ (List.map f1 _as).
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)
 (* GENERIC Monad *)
Program Fixpoint nd_foldlM {a b cs err info st : Type}  (f : a -> b -> ndM a info err cs st) (a1 : a)  : list b -> ndM a info err cs st:=  
  fun (x : list b) =>
    match (x) with (* GENERIC Monad *) | [] =>
      (* GENERIC Monad *) nd_return a1 (* GENERIC Monad *) | x::xs =>
      nd_bind ( (* GENERIC Monad *) f a1 x)
        (fun (fax : a) => nd_foldlM f fax xs) (* GENERIC Monad *) end.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition pick {a cs err info st : Type} `{Constraints cs} `{Show info}  (info1 : info)  : list a -> ndM a info err cs st:=  
  fun (x : list a) =>
    match (x) with | [] =>
      BOOM
        ( String.append "ND2.pick("
            (String.append (show info1) "), empty list")) | [x] =>
      ND (fun (st1 : st) => (NDactive x, st1) ) | x::xs =>
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 1) []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     String.append "ND2.pick (|ms| = "
                       (String.append
                          (lem_string_extra.stringFromNat
                             (List.length (x :: xs))) ")") end )) with tt =>
        ND
          (fun (st1 : st) =>
             (NDnd info1
                ((info1, nd_return x) ::
                 List.map (fun (z : a) => (info1, nd_return z)) xs), st1) )
      end end.
(* [?]: removed value specification. *)

Definition ifM {a cs err info st : Type}  (debug_str : info) (cs1 : cs) (mThen : ndM a info err cs st) (mElse : ndM a info err cs st)  : ndM a info err cs st:= 
  ND (fun (st1 : st) =>
    (NDbranch debug_str cs1 mThen mElse, st1)
  ).
(* [?]: removed value specification. *)

Definition nd_mem {a b c : Type}  (x : b) (m : c)  : a:= 
  BOOM "ND2.mem".
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition nd_guard {a b c d : Type}  (b1 : bool ) (reason : kill_reason c)  : ndM (unit ) d c b a:= 
  if b1 then nd_return tt else kill reason.
(* [?]: removed top-level value definition. *)


Definition warns_if_no_active_ex {a b : Type}  (m : b)  : a:= 
  BOOM "ND2.warns_if_no_active_ex".
(* [?]: removed value specification. *)

Definition addConstraints {cs err info st : Type}  (debug_str : info) (cs1 : cs)  : ndM (unit ) info err cs st:= 
  ND (fun (st1 : st) =>
    (NDguard debug_str cs1 (nd_return tt), st1)
  ).
(* [?]: removed value specification. *)


Program Fixpoint liftND {a cs err1 err2 info1 info2 st1 st2 : Type}  (get1 : st2 -> st1) (put1 : st2 -> st1 -> st2) (liftInfo : info1 -> info2) (liftErr : err1 -> err2) (n : ndM a info1 err1 cs st1)  : ndM a info2 err2 cs st2:= 
  match ( (get1,put1,liftInfo,liftErr,n)) with
      ( get1,  put1,  liftInfo,  liftErr, ( ND m)) =>
    ND
      (fun (st21 : st2) =>
         match ( m (get1 st21)) with (act,  st1') =>
           (liftAction get1 put1 liftInfo liftErr act, put1 st21 st1') end )
  end
with liftAction {a cs err1 err2 info1 info2 st1 st2 : Type}  (get1 : st2 -> st1) (put1 : st2 -> st1 -> st2) (liftInfo : info1 -> info2) (liftErr : err1 -> err2)  : nd_action a info1 err1 cs st1 -> nd_action a info2 err2 cs st2:= 
  match ( (get1,put1,liftInfo,liftErr)) with
      ( get1,  put1,  liftInfo,  liftErr) =>
    fun (x : nd_action a info1 err1 cs st1) =>
      match (x) with | NDactive a1 => NDactive a1 | NDkilled r =>
        NDkilled
          match ( r) with | Undef0 loc ubs => Undef0 loc ubs
            | Error0 loc str => Error0 loc str | Other err =>
            Other (liftErr err) end | NDnd info str_ms =>
        NDnd (liftInfo info)
          (List.map
             (fun (p : (info1*ndM a info1 err1 cs st1) % type) =>
                match ( (p) ) with ( (info,  m_act)) =>
                  (liftInfo info, liftND get1 put1 liftInfo liftErr m_act)
                end) str_ms) | NDguard info cs1 act =>
        NDguard (liftInfo info) cs1 (liftND get1 put1 liftInfo liftErr act)
        | NDbranch info cs1 m_act1 m_act2 =>
        NDbranch (liftInfo info) cs1
          (liftND get1 put1 liftInfo liftErr m_act1)
          (liftND get1 put1 liftInfo liftErr m_act2) | NDstep info info_ms =>
        NDstep (liftInfo info)
          (List.map
             (fun (p : (info1*ndM a info1 err1 cs st1) % type) =>
                match ( (p) ) with ( (info,  m)) =>
                  (liftInfo info, liftND get1 put1 liftInfo liftErr m) end)
             info_ms) end end.



Definition mk_step {a b c d e : Type}  (info : a) (xs : list ((a*ndM e a d c b) % type))  : ndM e a d c b:= 
  ND (fun (st : b) => (NDstep info xs, st)).





(* ================================================================================================== *)

(*
type nd_action 'a 'st 'err 'cs =
  | NDactive of 'a
  | NDkilled of kill_reason 'err
  | NDnd of string * 'st * list (string * nd_action 'a 'st 'err 'cs)
  | NDguard of string * 'cs * nd_action 'a 'st 'err 'cs
  | NDbranch of string * 'st * 'cs * nd_action 'a 'st 'err 'cs * nd_action 'a 'st 'err 'cs


val     nd_action_bind: forall 'a 'b 'st 'err 'cs. nd_action 'a 'st 'err 'cs -> ('a -> nd_action 'b 'st 'err 'cs) -> nd_action 'b 'st 'err 'cs
let rec nd_action_bind act f =
  match act with
    | NDactive z ->
        f z
    | NDkilled r ->
        NDkilled r
    | NDnd debug_str st str_acts ->
        NDnd debug_str st (List.map (fun (str, act) -> (str, nd_action_bind act f)) str_acts)
    | NDguard debug_str cs act' ->
        NDguard debug_str cs (nd_action_bind act' f)
    | NDbranch debug_str st cs act1 act2 ->
        NDbranch debug_str st cs (nd_action_bind act1 f) (nd_action_bind act2 f)
  end


type ndM 'a 'err 'cs 'st =
  ND of ('st -> nd_action ('a * 'st) 'st 'err 'cs)


(* Monadic operations *)
val return: forall 'a 'err 'cs 'st. 'a -> ndM 'a 'err 'cs 'st
val bind:   forall 'a 'b 'err 'cs 'st. ndM 'a 'err 'cs 'st -> ('a -> ndM 'b 'err 'cs 'st) -> ndM 'b 'err 'cs 'st

let nd_return a =
  ND (fun st -> NDactive (a, st))
let inline return = nd_return

let bind (ND m) f =
  ND (fun st ->
    nd_action_bind (m st) (fun (a, st') ->
      let ND b = (f a) in b st'
    )
  )







(* State operations *)
val get: forall 'err 'cs 'st. ndM 'st 'err 'cs 'st
val put: forall 'err 'cs 'st. 'st -> ndM unit 'err 'cs 'st
val update: forall 'err 'cs 'st. ('st -> 'st) -> ndM unit 'err 'cs 'st
val read: forall 'a 'err 'cs 'st. ('st -> 'a) -> ndM 'a 'err 'cs 'st

let get =
  ND (fun st -> NDactive (st, st))

let put st =
  ND (fun _ -> NDactive ((), st))

let update f =
  ND (fun st -> NDactive ((), f st))

let read f=
  ND (fun st -> NDactive (f st, st))



let inline (>>=) = bind

val bindExhaustive: forall 'a 'b 'err 'cs 'st. ndM 'a 'err 'cs 'st -> ('a -> ndM 'b 'err 'cs 'st) -> ndM 'b 'err 'cs 'st
let bindExhaustive m f =
  let () = Debug.print_debug 1 [] (fun () ->
    "ND2.bindExhaustive is wrong"
  ) in
  bind m f (* error "ND2.bindExhaustive" *)



val kill: forall 'a 'err 'cs 'st. kill_reason 'err -> ndM 'a 'err 'cs 'st
let kill r =
  ND (fun st -> NDkilled r)

val log: forall 'err 'cs 'st. string -> ndM unit 'err 'cs 'st
let log msg =
  error "ND2.log"


val print_debug: forall 'err 'cs 'st. nat -> list Debug.domain -> (unit -> string) -> ndM unit 'err 'cs 'st
let print_debug level doms msg =
  return (Debug.print_debug level doms msg)



(* MonadPlus operations *)
(* val mzero: forall 'a 'err 'cs 'st. ndM 'a 'err 'cs 'st *)
val mplus: forall 'a 'err 'cs 'st. ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st

(*
let mzero =
  error ""
*)

let mplus m1 m2 =
  error "ND2.mplus"

(* GENERIC MonadPlus *)
(*
val msum: forall 'a 'err 'cs 'st. Constraints 'cs => string -> list (string * ndM 'a 'err 'cs 'st) -> ndM 'a 'err 'cs 'st 
let msum debug_str = function
  | [] ->
      error "ND2.msum []"
  | [(_, m)] ->
      m
  | str_ms ->
    let () = Debug.print_debug 1 [] (fun () ->
      "ND2.msum (|ms| = " ^ show (List.length str_ms) ^ ")"
    ) in
    ND (fun st ->
      NDnd debug_str st (List.map (fun (str, ND m) -> (str, m st)) str_ms)
    )
end
*)
(*
let msum debug_str = function
  | [] ->
      error "ND2.msum []"
  | (ND m0 :: ms) ->
        List.foldl (fun acc (ND m) ->
          NDbranch empty acc (m st)
        ) (m0 st) ms
      )
end
*)

(* GENERIC Monad *)
let sequence_ ms = foldr (fun m1 m2 -> bind m1 (fun _ -> m2)) (return ()) ms

(* GENERIC Monad *)
val mapM_: forall 'a 'b 'err 'cs 'st. ('a -> ndM 'b 'err 'cs 'st) -> list 'a -> ndM unit 'err 'cs 'st
let mapM_ f _as = sequence_ (List.map f _as)


(* NOTE: this is foldl *)
val     foldM: forall 'a 'b 'err 'cs 'st. ('a -> 'b -> ndM 'a 'err 'cs 'st) -> 'a -> list 'b -> ndM 'a 'err 'cs 'st (* GENERIC Monad *)
let rec foldM f a = function                                                 (* GENERIC Monad *)
  | [] ->                                                                    (* GENERIC Monad *)
      return a                                                               (* GENERIC Monad *)
  | x::xs ->                                                                 (* GENERIC Monad *)
      f a x >>= fun fax -> foldM f fax xs                                    (* GENERIC Monad *)
end




(* Non-deterministically pick from a list *)
val pick: forall 'a 'err 'cs 'st. Constraints 'cs => string -> list 'a -> ndM 'a 'err 'cs 'st
let pick debug_str = function
  | [] ->
      error ("ND2.pick(" ^ debug_str ^ "), empty list")
  | [x] ->
      ND (fun st ->
        NDactive (x, st)
      )
  | x::xs ->
      let () = Debug.print_debug 1 [] (fun () ->
        "ND2.pick (|ms| = " ^ show (List.length (x::xs)) ^ ")"
      ) in
      ND (fun st ->
        let f z = NDactive (z, st) in
        NDnd debug_str st (("", f x) :: List.map (fun z -> ("", f z)) xs)
(*
        List.foldl (fun acc x' -> NDbranch empty acc (NDactive (x', st))) (NDactive (x, st)) xs
*)
      )
end


val ifM: forall 'a 'err 'cs 'st. string -> 'cs -> ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st
let ifM debug_str cs (ND mThen) (ND mElse) =
  ND (fun st ->
    NDbranch debug_str st cs (mThen st) (mElse st)
  )



(* NOTE: this seems to only be used by the concurrency *)
val mem : forall 'a 'err 'cs 'st. Eq 'a => 'a -> ndM 'a 'err 'cs 'st -> bool
let nd_mem x m =
  error "ND2.mem"
let inline mem = nd_mem


val guard: forall 'err 'cs 'st. bool -> kill_reason 'err -> ndM unit 'err 'cs 'st
let guard b reason =
  if b then return () else kill reason



let warns_if_no_active_ex m =
  error "ND2.warns_if_no_active_ex"




val addConstraints: forall 'err 'cs 'st. string -> 'cs -> ndM unit 'err 'cs 'st
let addConstraints debug_str cs =
  ND (fun st ->
    NDguard debug_str cs (NDactive ((), st))
  )



let rec liftAction liftErr mk_st' = function
  | NDactive (a, st) ->
      NDactive (a, mk_st' st)
  | NDkilled r ->
      NDkilled match r with
        | Undef loc ubs ->
            Undef loc ubs
        | Error loc str ->
            Error loc str
        | Other err ->
            Other (liftErr err)
      end
  | NDnd debug_str st str_acts ->
      NDnd debug_str (mk_st' st) (List.map (fun (str, act) -> (str, liftAction liftErr mk_st' act)) str_acts)
  | NDguard debug_str cs act ->
      NDguard debug_str cs (liftAction liftErr mk_st' act)
  | NDbranch debug_str st cs act1 act2 ->
      NDbranch debug_str (mk_st' st) cs (liftAction liftErr mk_st' act1) (liftAction liftErr mk_st' act2)
end

val liftND: forall 'a 'err1 'err2 'cs 'st1 'st2.
  ('st2 -> 'st1) ->
  ('st2 -> 'st1 -> 'st2) ->
  ('err1 -> 'err2) ->
  ndM 'a 'err1 'cs 'st1 -> ndM 'a 'err2 'cs 'st2
let liftND get put liftErr (ND m) =
  ND (fun st2 ->
    let act = m (get st2) in
    liftAction liftErr (put st2) act
  )

*)





Inductive nd_status (a : Type) (err : Type) : Type := 
  | Active:  a -> nd_status a err
  | Killed:  kill_reason  err -> nd_status a err.
Definition nd_status_default {a: Type} {err: Type} : nd_status a err := Active DAEMON.
