(* Generated by Lem from ocaml_generated/utils.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import lem_map.
Require Export lem_map.

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Class Default (a: Type): Type := {
  default:a
}.


Instance x2_Default : Default unit := {
   default  :=  tt
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Program Fixpoint mkListN_aux  (n : Z )  (i: Z ) (acc : list (Z ))  : list (Z ):= 
  if int_ltb i n then
    mkListN_aux n (Coq.ZArith.BinInt.Zplus i((Zpred (Zpos (P_of_succ_nat 1))))) (i::acc)
  else
    List.rev acc.
Definition mkListN  (n : Z )  : list (Z ):= 
  mkListN_aux n((Zpred (Zpos (P_of_succ_nat 0)))) [].
(* [?]: removed value specification. *)

Program Fixpoint mkListFromTo_aux   (i: Z ) (max1 : Z ) (acc : list (Z ))  : list (Z ):= 
  if int_lteb i max1 then
    mkListFromTo_aux (Coq.ZArith.BinInt.Zplus i((Zpred (Zpos (P_of_succ_nat 1))))) max1 (i::acc)
  else
    List.rev acc.
Definition mkListFromTo  (start : Z ) (max1 : Z )  : list (Z ):= 
  mkListFromTo_aux start max1 [].
(* [?]: removed value specification. *)

Program Fixpoint numerote_ {a : Type}  (n : nat ) (l : list a)  : list ((nat *a) % type):= 
  match ( l) with 
    | []    => []
    | x::xs => (n,x) :: numerote_ (Coq.Init.Peano.plus n( 1)) xs
  end.
Definition numerote {a : Type}  (l : list a)  : list ((nat *a) % type):=  numerote_( 1) l.
(* [?]: removed value specification. *)

Definition unzip3 {a b c : Type}  (xyzs : list ((a*b*c) % type))  : (list a*list b*list c) % type:= 
  List.fold_right (fun (p : (a*b*c) % type) (p0 : (list a*list b*list c) % type) =>
  match ( (p ,p0) ) with ( (x, y, z) ,  (xs, ys, zs)) =>
    ((x :: xs), (y :: ys), (z :: zs)) end) ([],[],[]) xyzs.
(* [?]: removed value specification. *)

Program Fixpoint foldl2 {a b c : Type}  (f : a -> b -> c -> a) (z : a) (xs : list b) (ys : list c)  : a:= 
  match ( (xs, ys)) with 
    | ([], []) =>
        z
    | (a1::xs',  b1::ys') =>
        foldl2 f (f z a1 b1) xs' ys'
    | _ =>
        BOOM "[Global.foldl2] the twos weren't of same length"
  end.
(* [?]: removed value specification. *)

Program Fixpoint map2_ {a b c : Type}  (f : b -> a -> c) (xs : list b) (ys : list a) (acc : list c)  : list c:= 
  match ( (xs, ys)) with 
    | (x::xs',  y::ys') =>
        map2_ f xs' ys' (f x y :: acc)
    | ([], []) =>
        acc
    | _ =>
        BOOM "[Global.foldl2] the twos weren't of same length"
  end.
Definition map2 {a b c : Type}  (f : a -> b -> c) (xs : list a) (ys : list b)  : list c:=  map2_ f xs ys [].

Definition fromJust {a : Type}  (debug_str : string )  : option a  -> a:=  
  fun (x : option a ) =>
    match (x) with | Some z => z | None =>
      BOOM ( String.append "Global.fromJust(" (String.append debug_str ")"))
    end.

Definition fromLeft {a b : Type}   : sum a b -> a:=  
  fun (x : sum a b) =>
    match (x) with | inl z => z | inr _ => BOOM "Global.fromLeft" end.

Definition fromRight {a b : Type}   : sum b a -> a:=  
  fun (x : sum b a) =>
    match (x) with | inl _ => BOOM "Global.fromRight" | inr z => z end.

Program Fixpoint filter_opt {a : Type}  (l : list (option a ))  : list a:=  
  match ( l) with 
    | [] => []
    |( Some z) :: xs => z :: filter_opt xs
    | None  :: xs =>      filter_opt xs
  end.

Program Fixpoint set_from_options {a : Type} `{SetType a}  (xs : list (option a ))  : set a:= 
  match ( xs) with 
    | []            => []
    | Some x  :: xs' => (set_union_by setElemCompare [x] (set_from_options xs'))
    | None :: xs' => set_from_options xs'
end.
(* [?]: removed value specification. *)

Program Fixpoint mapUnzip_ {a b c : Type}  (f : a -> (b*c) % type) (p : (list b*list c) % type) (mylist : list a)  : (list b*list c) % type:= 
  match ( (f,p,mylist)) with ( f,  (xs,  ys),  mylist) =>
    match ( mylist) with | [] => (xs, ys) |( l::ls) =>
      match ( f l) with (x, y) => mapUnzip_ f ((x :: xs), (y :: ys)) ls end
    end end.
Definition mapUnzip {a b c : Type}  (f : a -> (b*c) % type) (l : list a)  : (list b*list c) % type:=  
  match ( mapUnzip_ f ([],[]) l) with (xs,  ys) => (List.rev xs, List.rev ys)
  end.
(* [?]: removed value specification. *)

Program Fixpoint map_option {a b : Type}  (f : a -> option b ) (xs : list a)  : list b:=  
  match ( xs) with  
    | [] =>
        []
    | x::xs =>
        match ( f x) with  
          | None => map_option f xs 
          | Some x  => x :: (map_option f xs)
        end
  end.
(* [?]: removed value specification. *)

Definition transitive_reduction {a : Type} `{Eq a}  (r : list ((a*a) % type))  : option (list ((a*a) % type)) := 
  let transitive_pairs  := 
    apply lem_list.concat
      (List.map (fun (p : (a*a) % type) =>
  match ( (p) ) with ( (a1, a2)) =>
    map_option
      (fun (p : (a*a) % type) =>
         match ( (p) ) with ( (a1', a2')) =>
           if a2 = a1' then Some (a1,a2') else None end) r end
      ) r) in
  (* a partial check for cycles *)
  if List.existsb (fun (p : (a*a) % type) => match ( (p) ) with ( (a1, a2)) => a1 = a2 end) ( (@ List.app _)r transitive_pairs) then 
    None
  else Some (List.filter (
  fun (p : (a*a) % type) =>
    match ( (p) ) with ( (a1, a2)) => negb (elem (a1,a2) transitive_pairs)
    end) r).
(* [?]: removed value specification. *)

Definition is_transitive {a : Type} `{Eq a}  (r : list ((a*a) % type))  : bool := 
  let two_step_edges  := 
    apply lem_list.concat
      (List.map (fun (p : (a*a) % type) =>
  match ( (p) ) with ( (n, n')) =>
    map_option
      (fun (p : (a*a) % type) =>
         match ( (p) ) with ( (n'', n''')) =>
           if n' = n'' then Some (n,n''') else None end) r end
      ) r) in
  List.forallb (fun (p : (a*a) % type) =>
  match ( (p) ) with ( (n, n''')) => elem (n,n''') r end) two_step_edges.


Definition try_to_transitive_reduce {a : Type} `{Eq a}  (rel1 : list ((a*a) % type))  : list ((a*a) % type):= 
  if is_transitive rel1 then
    match ( transitive_reduction rel1) with 
      | Some rel' => rel'
      | None   => rel1
    end
  else
    rel1.
(* END: stolen from cpp *)

(* this will blow up on cyclic relations *)
Definition step {a : Type} `{Eq a}  (s : list a) (rel1 : list ((a*a) % type))  : list a:= 
  List.fold_left (fun (acc : list a) (p : (a*a) % type) =>
  match ( (acc ,p) ) with ( acc ,  (a1, b)) =>
    if elem a1 s && negb (elem b acc) then b :: acc else acc end
  ) rel1 s.

Program Fixpoint replicate_list_ {a : Type}  (x : a)  (n: nat ) (acc : list a)  : list a:= 
  if nat_gtb n( 0) then
    replicate_list_ x (Coq.Init.Peano.minus n( 1)) (x :: acc)
  else
    acc.
(* [?]: removed value specification. *)

Definition replicate_list {a : Type}  (x : a) (n : nat )  : list a:= 
  replicate_list_ x n [].
(* [?]: removed value specification. *)

Definition eq_pair {a b : Type}  (eqA : a -> a -> bool ) (eqB : b -> b -> bool )  : (a*b) % type -> (a*b) % type -> bool :=  
  fun (p : (a*b) % type) (p0 : (a*b) % type) =>
    match ( (p ,p0) ) with ( (a1,  b1) ,  (a2,  b2)) =>
      eqA a1 a2 && eqB b1 b2 end.
(* [?]: removed value specification. *)

Definition eq_triple {a b c : Type}  (eqA : a -> a -> bool ) (eqB : b -> b -> bool ) (eqC : c -> c -> bool )  : (a*b*c) % type -> (a*b*c) % type -> bool :=  
  fun (p : (a*b*c) % type) (p0 : (a*b*c) % type) =>
    match ( (p ,p0) ) with ( (a1,  b1,  c1) ,  (a2,  b2,  c2)) =>
      eqA a1 a2 && (eqB b1 b2 && eqC c1 c2) end.
(* [?]: removed value specification. *)

Program Fixpoint assoc_insert {a b : Type} `{Eq a}  (k : a) (v : b)  : list ((a*b) % type) -> list ((a*b) % type):=  
  fun (x : list ((a*b) % type)) =>
    match (x) with | [] => [(k, v)] | (k', v') :: xs =>
      if k = k' then (k, v) :: xs else (k', v') :: assoc_insert k v xs end.
(* [?]: removed value specification. *)

Program Fixpoint assoc_remove {a b : Type} `{Eq a}  (k : a)  : list ((a*b) % type) -> list ((a*b) % type):=  
  fun (x : list ((a*b) % type)) =>
    match (x) with | [] => [] | (k', v') :: xs =>
      if k = k' then xs else (k', v') :: assoc_remove k xs end.
(* [?]: removed value specification. *)

Program Fixpoint assoc_adjust {a b : Type} `{Eq a}  (f : b -> b) (k : a)  : list ((a*b) % type) -> list ((a*b) % type):=  
  fun (x : list ((a*b) % type)) =>
    match (x) with | [] => [] | (k', v) :: xs =>
      if k = k' then (k, f v) :: xs else (k', v) :: assoc_adjust f k xs end.
(* [?]: removed value specification. *)

Definition list_insert {a : Type} `{Eq a}  (x : a) (xs : list a)  : list a:= 
  if lem_list.elem x xs then
    xs
  else
    x :: xs.
(* [?]: removed value specification. *)

Definition first {a b c : Type}  (f : a -> b) (p : (a*c) % type)  : (b*c) % type:= 
  match ( (f,p)) with ( f,  (x,  y)) => (f x, y) end.
(* [?]: removed value specification. *)

Definition second {a b c : Type}  (f : a -> b) (p : (c*a) % type)  : (c*b) % type:= 
  match ( (f,p)) with ( f,  (x,  y)) => (x, f y) end.
(* [?]: removed value specification. *)

Program Fixpoint list_index_update {a : Type}  (n : nat ) (f : a -> a)  : list a -> list a:=  
  fun (x : list a) =>
    match (x) with | [] => BOOM "Global.list_index_update" | x::xs =>
      if beq_nat n ( 0) then f x :: xs else
        x :: (list_index_update (Coq.Init.Peano.minus n ( 1)) f xs) end.
(* [?]: removed value specification. *)

Program Fixpoint pickWith_ {a : Type}  (pred : a -> bool ) (acc : list a)  : list a -> list ((list a*a*list a) % type):=  
  fun (x : list a) =>
    match (x) with | [] => [] | x::xs =>
      apply
        (
        if pred x then
          fun (z : list ((list a*a*list a) % type)) =>
            (List.rev acc, x, xs) :: z else
          fun (z : list ((list a*a*list a) % type)) => z)
        (pickWith_ pred (x :: acc) xs) end.

Definition pickWith {a : Type}  (pred : a -> bool ) (xs : list a)  : list ((list a*a*list a) % type):= 
  pickWith_ pred [] xs.
(* [?]: removed value specification. *)

Program Fixpoint last_aux {a : Type}  (acc : list a) (xs : list a)  : option ((a*list a) % type) := 
  match ( xs) with 
    | [] =>
        None
    | [x] =>
        Some (x, List.rev acc)
    | x::xs =>
        last_aux (x::acc) xs
  end.
Definition last0 {a : Type}  (xs : list a)  : option ((a*list a) % type) :=  last_aux [] xs.
(* [?]: removed value specification. *)

Program Fixpoint list_unfoldr_aux {a b : Type}  (acc : list b) (ctor1 : a -> option ((b*a) % type) ) (b0 : a)  : list b:= 
  match ( ctor1 b0) with 
    | Some (a1,  b') =>
        list_unfoldr_aux (a1::acc) ctor1 b'
    | None =>
        acc
  end.

Definition list_unfoldr {a b : Type}  (x : b -> option ((a*b) % type) )  : b -> list a:=  list_unfoldr_aux [] x.
(* [?]: removed value specification. *)

Program Fixpoint maybe_mapM_aux {a b : Type}  (acc : list b) (f : a -> option b )  : list a -> option (list b) :=  
  fun (x : list a) =>
    match (x) with | [] => Some acc | x::xs' =>
      match ( f x) with | Some x' => maybe_mapM_aux (x' :: acc) f xs'
        | None => None end end.

Definition maybe_mapM {a b : Type}  (f : a -> option b ) (xs : list a)  : option (list b) :=  maybe_mapM_aux [] f xs.
(* [?]: removed value specification. *)

Definition product_list {a b : Type}  (xs : list a) (ys : list b)  : list ((a*b) % type):= 
  lem_list.concat (List.map (fun (x : a) => List.map (fun (y : b) => (x,y)) ys) xs).

