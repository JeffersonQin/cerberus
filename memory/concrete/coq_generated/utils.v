(* Generated by Lem from ocaml_generated/utils.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import lem_map.
Require Export lem_map.

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Class Default (a: Type): Type := {
  default:a
}.


Instance x0_Default : Default unit := {
   default  :=  tt
}.

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)
 

(* val mkListN: integer -> list integer
 * val mkListFromTo: integer -> integer -> list integer *)

Definition mkListFromTo_integer   (f: Z ) (t3 : Z )  : list (Z ):= 
  let l := replicate (Z.abs_nat ( (Coq.ZArith.BinInt.Zplus(Coq.ZArith.BinInt.Zminus t3 f)(Coq.ZArith.BinIntDef.Z.of_nat 1)))) f in
  lem_list.mapi (fun (i : nat ) ( _ : Z ) => Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinIntDef.Z.of_nat i) f) l.
Definition mkListFromTo_nat   (f: nat ) (t3 : nat )  : list (nat ):= 
  let l := replicate (Coq.Init.Peano.plus(Coq.Init.Peano.minus t3 f)( 1)) f in
  lem_list.mapi (fun (i : nat ) ( _ : nat ) => Coq.Init.Peano.plus i f) l.
Definition mkListFromTo_natural   (f: nat ) (t3 : nat )  : list (nat ):= 
  let l := replicate ( (Coq.Init.Peano.plus(Coq.Init.Peano.minus t3 f)( 1))) f in
  lem_list.mapi (fun (i : nat ) ( _ : nat ) => Coq.Init.Peano.plus ( i) f) l.

Definition mkListN  (n : Z )  : list (Z ):= 
  mkListFromTo_integer(Coq.ZArith.BinIntDef.Z.of_nat 0) (Coq.ZArith.BinInt.Zminus n(Coq.ZArith.BinIntDef.Z.of_nat 1)).
(* [?]: removed value specification. *)

Program Fixpoint numerote_ {a : Type}  (n : nat ) (l : list a)  : list ((nat *a) % type):= 
  match ( l) with 
    | []    => []
    | x::xs => (n,x) :: numerote_ (Coq.Init.Peano.plus n( 1)) xs
  end.
Definition numerote {a : Type}  (l : list a)  : list ((nat *a) % type):=  numerote_( 1) l.
(* [?]: removed value specification. *)

Definition unzip3 {a b c : Type}  (xyzs : list ((a*b*c) % type))  : (list a*list b*list c) % type:= 
  List.fold_right (fun (p : (a*b*c) % type) (p0 : (list a*list b*list c) % type) =>
  match ( (p ,p0) ) with ( (x, y, z) ,  (xs, ys, zs)) =>
    ((x :: xs), (y :: ys), (z :: zs)) end) ([],[],[]) xyzs.
(* [?]: removed value specification. *)


(* CP: can maybe remove the above? *)
Definition foldl2 {a b c : Type}  (f : a -> b -> c -> a) (z : a) (xs : list b) (ys : list c)  : a:=  List.fold_left (
  fun (a1 : a) (p : (b*c) % type) =>
    match ( (a1 ,p) ) with ( a1 ,  (b1, c1)) => f a1 b1 c1 end) (zip xs ys) z.
(* [?]: removed value specification. *)

Definition map2 {a b c : Type}  (f : a -> b -> c) (xs : list a) (ys : list b)  : list c:=  List.map (uncurry f) (lem_list.zip xs ys).

Definition fromJust {a : Type}  (debug_str : string )  : option a  -> a:=  
  fun (x : option a ) => match (x) with | Some z => z | None => DAEMON end.

Definition fromLeft {a b : Type}   : sum a b -> a:=  
  fun (x : sum a b) => match (x) with | inl z => z | inr _ => DAEMON end.

Definition fromRight {a b : Type}   : sum b a -> a:=  
  fun (x : sum b a) => match (x) with | inl _ => DAEMON | inr z => z end.

Program Fixpoint filter_opt {a : Type}  (l : list (option a ))  : list a:=  
  match ( l) with 
    | [] => []
    |( Some z) :: xs => z :: filter_opt xs
    | None  :: xs =>      filter_opt xs
  end.

Program Fixpoint set_from_options {a : Type} `{SetType a}  (xs : list (option a ))  : set a:= 
  match ( xs) with 
    | []            => []
    | Some x  :: xs' => (set_union_by setElemCompare [x] (set_from_options xs'))
    | None :: xs' => set_from_options xs'
end.
(* [?]: removed value specification. *)

Program Fixpoint mapUnzip_ {a b c : Type}  (f : a -> (b*c) % type) (p : (list b*list c) % type) (mylist : list a)  : (list b*list c) % type:= 
  match ( (f,p,mylist)) with ( f,  (xs,  ys),  mylist) =>
    match ( mylist) with | [] => (xs, ys) |( l::ls) =>
      match ( f l) with (x, y) => mapUnzip_ f ((x :: xs), (y :: ys)) ls end
    end end.
Definition mapUnzip {a b c : Type}  (f : a -> (b*c) % type) (l : list a)  : (list b*list c) % type:=  
  match ( mapUnzip_ f ([],[]) l) with (xs,  ys) => (List.rev xs, List.rev ys)
  end.
(* [?]: removed value specification. *)

Program Fixpoint map_option {a b : Type}  (f : a -> option b ) (xs : list a)  : list b:=  
  match ( xs) with  
    | [] =>
        []
    | x::xs =>
        match ( f x) with  
          | None => map_option f xs 
          | Some x  => x :: (map_option f xs)
        end
  end.
(* [?]: removed value specification. *)

Definition transitive_reduction {a : Type} `{Eq a}  (r : list ((a*a) % type))  : option (list ((a*a) % type)) := 
  let transitive_pairs  := 
    apply lem_list.concat
      (List.map (fun (p : (a*a) % type) =>
  match ( (p) ) with ( (a1, a2)) =>
    map_option
      (fun (p : (a*a) % type) =>
         match ( (p) ) with ( (a1', a2')) =>
           if a2 = a1' then Some (a1,a2') else None end) r end
      ) r) in
  (* a partial check for cycles *)
  if List.existsb (fun (p : (a*a) % type) => match ( (p) ) with ( (a1, a2)) => a1 = a2 end) ( (@ List.app _)r transitive_pairs) then 
    None
  else Some (List.filter (
  fun (p : (a*a) % type) =>
    match ( (p) ) with ( (a1, a2)) => negb (elem (a1,a2) transitive_pairs)
    end) r).
(* [?]: removed value specification. *)

Definition is_transitive {a : Type} `{Eq a}  (r : list ((a*a) % type))  : bool := 
  let two_step_edges  := 
    apply lem_list.concat
      (List.map (fun (p : (a*a) % type) =>
  match ( (p) ) with ( (n, n')) =>
    map_option
      (fun (p : (a*a) % type) =>
         match ( (p) ) with ( (n'', n''')) =>
           if n' = n'' then Some (n,n''') else None end) r end
      ) r) in
  List.forallb (fun (p : (a*a) % type) =>
  match ( (p) ) with ( (n, n''')) => elem (n,n''') r end) two_step_edges.


Definition try_to_transitive_reduce {a : Type} `{Eq a}  (rel1 : list ((a*a) % type))  : list ((a*a) % type):= 
  if is_transitive rel1 then
    match ( transitive_reduction rel1) with 
      | Some rel' => rel'
      | None   => rel1
    end
  else
    rel1.
(* END: stolen from cpp *)

(* this will blow up on cyclic relations *)
Definition step {a : Type} `{Eq a}  (s : list a) (rel1 : list ((a*a) % type))  : list a:= 
  List.fold_left (fun (acc : list a) (p : (a*a) % type) =>
  match ( (acc ,p) ) with ( acc ,  (a1, b)) =>
    if elem a1 s && negb (elem b acc) then b :: acc else acc end
  ) rel1 s.
(* [?]: removed value specification. *)

Definition replicate_list {a : Type}   : a -> nat  -> list a:=  flip lem_list.replicate.
(* [?]: removed value specification. *)

Definition eq_pair {a b : Type}  (eqA : a -> a -> bool ) (eqB : b -> b -> bool )  : (a*b) % type -> (a*b) % type -> bool :=  
  fun (p : (a*b) % type) (p0 : (a*b) % type) =>
    match ( (p ,p0) ) with ( (a1,  b1) ,  (a2,  b2)) =>
      eqA a1 a2 && eqB b1 b2 end.
(* [?]: removed value specification. *)

Definition eq_triple {a b c : Type}  (eqA : a -> a -> bool ) (eqB : b -> b -> bool ) (eqC : c -> c -> bool )  : (a*b*c) % type -> (a*b*c) % type -> bool :=  
  fun (p : (a*b*c) % type) (p0 : (a*b*c) % type) =>
    match ( (p ,p0) ) with ( (a1,  b1,  c1) ,  (a2,  b2,  c2)) =>
      eqA a1 a2 && (eqB b1 b2 && eqC c1 c2) end.
(* [?]: removed value specification. *)

Program Fixpoint assoc_insert {a b : Type} `{Eq a}  (k : a) (v : b) (l : list ((a*b) % type))  : list ((a*b) % type):=  
  match ( l) with 
  |  [] =>
      [(k, v)]
  | (k', v') :: xs =>
      if k = k' then
        (k, v) :: xs
      else
        (k', v') :: assoc_insert k v xs
end.
(* [?]: removed value specification. *)

Program Fixpoint assoc_remove {a b : Type} `{Eq a}  (k : a) (l : list ((a*b) % type))  : list ((a*b) % type):=  
  match ( l) with 
  |  [] =>
      []
  | (k', v') :: xs =>
      if k = k' then
        xs
      else
        (k', v') :: assoc_remove k xs
end.
(* [?]: removed value specification. *)

Program Fixpoint assoc_adjust {a b : Type} `{Eq a}  (f : b -> b) (k : a) (l : list ((a*b) % type))  : list ((a*b) % type):=  
  match ( l) with 
  | [] =>
      []
  | (k', v) :: xs =>
      if k = k' then
        (k, f v) :: xs
      else
        (k', v) :: assoc_adjust f k xs
end.
(* [?]: removed value specification. *)

Definition list_insert {a : Type} `{Eq a}  (x : a) (xs : list a)  : list a:= 
  if lem_list.elem x xs then
    xs
  else
    x :: xs.
(* [?]: removed value specification. *)

Definition first {a b c : Type}  (f : a -> b) (p : (a*c) % type)  : (b*c) % type:= 
  match ( (f,p)) with ( f,  (x,  y)) => (f x, y) end.
(* [?]: removed value specification. *)

Definition second {a b c : Type}  (f : a -> b) (p : (c*a) % type)  : (c*b) % type:= 
  match ( (f,p)) with ( f,  (x,  y)) => (x, f y) end.
(* [?]: removed value specification. *)

Program Fixpoint list_index_update {a : Type}  (n : nat ) (f : a -> a) (l : list a)  : list a:=  
  match ( l) with 
  | [] =>
      DAEMON
  | x::xs =>
      if beq_nat n( 0) then
        f x :: xs
      else
        x :: (list_index_update (Coq.Init.Peano.minus n( 1)) f xs)
end.
(* [?]: removed value specification. *)

Program Fixpoint pickWith_ {a : Type}  (pred : a -> bool ) (acc : list a) (l : list a)  : list ((list a*a*list a) % type):=  
  match ( l) with 
  | [] =>
      []
  | x::xs => 
      apply(if pred x then fun (z : list ((list a*a*list a) % type)) => (List.rev acc, x, xs) :: z else fun (z : list ((list a*a*list a) % type)) => z)
        (pickWith_ pred (x::acc) xs)
end.

Definition pickWith {a : Type}  (pred : a -> bool ) (xs : list a)  : list ((list a*a*list a) % type):= 
  pickWith_ pred [] xs.
(* [?]: removed value specification. *)

(* let rec last_aux acc xs =
 *   match xs with
 *     | [] ->
 *         Nothing
 *     | [x] ->
 *         Just (x, List.reverse acc)
 *     | x::xs ->
 *         last_aux (x::acc) xs
 *   end
 * let last xs = last_aux [] xs *)

Definition last {a : Type}  (xs : list a)  : option ((a*list a) % type) :=  option_map (
  fun (p : (list a*a) % type) =>
    match ( (p) ) with ( (v1,  v2)) => (v2, v1) end) (lem_list.dest_init xs).
(* [?]: removed value specification. *)

Program Fixpoint maybe_mapM_aux {a b : Type}  (acc : list b) (f : a -> option b ) (l : list a)  : option (list b) :=  
  match ( l) with 
  | [] =>
      Some acc
  | x::xs' =>
      match ( f x) with 
        | Some x' =>
            maybe_mapM_aux (x'::acc) f xs'
        | None =>
            None
      end
  end.

Definition maybe_mapM {a b : Type}  (f : a -> option b ) (xs : list a)  : option (list b) :=  maybe_mapM_aux [] f xs.
(* [?]: removed value specification. *)

Definition product_list {a b : Type}  (xs : list a) (ys : list b)  : list ((a*b) % type):= 
  lem_list.concat (List.map (fun (x : a) => List.map (fun (y : b) => (x,y)) ys) xs).

