(* Generated by Lem from ocaml_generated/core_run_aux.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.
Require Import lem_show.
Require Export lem_show.
Require Import core.
Require Export core.

Require Import global.
Require Export global.
Require Import dlist.
Require Export dlist.
Require Import pp.
Require Export pp.
Require Import state_exception_undefined.
Require Export state_exception_undefined.
Require Import lem_map_extra.
Require Export lem_map_extra.


Require Import errors.
Require Export errors.
Require Import core.
Require Export core.
Require Import annot.
Require Export annot.

Require Import cmm_csem.
Require Export cmm_csem.
Require Import mem_common.
Require Export mem_common.
Require Import core_aux.
Require Export core_aux.



(* DEBUG *)
(* These inform in the thread what Core global or (stack of) procedure(s) is
   being executed *)
Inductive exec_location : Type := 
  | ELoc_globals: exec_location 
  | ELoc_normal:  list  symbol.sym  -> exec_location .
Definition exec_location_default: exec_location  := ELoc_globals.


(* C11 concurrency partial version of the pre-execution relations. These are
   incrementaly added as annotations to the Core program as it is evaluated *)
Record core_run_annotation : Type := {
  sb_before:  set  ((mem_common.thread_id  * cmm_csem.aid ) % type);
  dd_before:  set  cmm_csem.aid ;
  asw_before: set  cmm_csem.aid 
}.
Notation "{[ r 'with' 'sb_before' := e ]}" := ({| sb_before := e; dd_before := dd_before r; asw_before := asw_before r |}).
Notation "{[ r 'with' 'dd_before' := e ]}" := ({| dd_before := e; sb_before := sb_before r; asw_before := asw_before r |}).
Notation "{[ r 'with' 'asw_before' := e ]}" := ({| asw_before := e; sb_before := sb_before r; dd_before := dd_before r |}).
Definition core_run_annotation_default: core_run_annotation  := {| sb_before := DAEMON; dd_before := DAEMON; asw_before := DAEMON |}.


 (* runtime stuff *)


Inductive context : Type := (* core_run_annotation unit Symbol.sym *) 
  | CTX: context 
  | Cunseq:  list  annot.annot  ->  list  (core.expr  core_run_annotation ) ->  context  ->  list  (core.expr  core_run_annotation ) -> context 
  | Cwseq:  list  annot.annot  ->  core.pattern  ->  context  ->  core.expr  core_run_annotation  -> context 
  | Csseq:  list  annot.annot  ->  core.pattern  ->  context  ->  core.expr  core_run_annotation  -> context 
  | Cannot:  list  annot.annot  ->  core.dyn_annotations  ->  context  -> context 
  | Cbound:  list  annot.annot  ->  context  -> context .
Definition context_default: context  := CTX.



Inductive continuation_element (a : Type) : Type := 
  | Kunseq:  list  annot  ->  list  (core.expr  a) ->  list  (core.expr  a) -> continuation_element a
  | Kwseq:   list  annot  ->  core.pattern  ->  core.expr  a -> continuation_element a
  | Ksseq:   list  annot  ->  core.pattern  ->  core.expr  a -> continuation_element a.
Definition continuation_element_default{a: Type} : continuation_element a := Kunseq DAEMON DAEMON DAEMON.
 (*  | Ktry   list (string * expr 'a) *)

Definition continuation (a: Type) : Type :=  list  (continuation_element  a).
Definition continuation_default{a: Type} : continuation a := DAEMON.
(* type labeled_continuation 'a = list (Symbol.sym * ctype) * expr 'a *)
Definition labeled_continuations (a: Type) : Type :=  fmap  symbol.sym   ((list  symbol.sym  * expr  a) % type).
Definition labeled_continuations_default{a: Type} : labeled_continuations a := DAEMON.


Inductive stack (a : Type) : Type := 
  | Stack_empty: stack a
    (* the symbol is that of the procedure being executed *)
  | Stack_cons:  option  symbol.sym   ->  (*labeled_continuations 'a * *) continuation  a ->  stack  a -> stack a
    (* TODO: this is for Core_reduction, the previous one is for Core_run *)
  | Stack_cons2:  option  symbol.sym   (* name of the current Core procedure, if any *)
                 ->  context           (*  *)
                 ->  stack  a -> stack a.
Definition stack_default{a: Type} : stack a := Stack_empty.
 


Definition subst_wait_continuation_element {a : Type}  (tid1 : nat ) (v : generic_value (symbol.sym ))  : continuation_element a -> continuation_element a:=  
  fun (x : continuation_element a) =>
    match (x) with | Kunseq annots1 es1 es2 =>
      Kunseq annots1 (List.map (core_aux.subst_wait tid1 v) es1)
        (List.map (core_aux.subst_wait tid1 v) es2)
      | Kwseq annots1 syms_opt e2 =>
      Kwseq annots1 syms_opt (core_aux.subst_wait tid1 v e2)
      | Ksseq annots1 syms_opt e2 =>
      Ksseq annots1 syms_opt (core_aux.subst_wait tid1 v e2)
    (*
  | Ktry str_es ->
      Ktry (List.map (fun (str, e) -> (str, subst_wait tid v e)) str_es)
*)
    end.

Definition subst_wait_continuation {a : Type}  (tid1 : nat ) (v : generic_value (symbol.sym )) (cont : list (continuation_element a))  : list (continuation_element a):= 
  List.map (subst_wait_continuation_element tid1 v) cont.

Program Fixpoint subst_wait_stack {a : Type}  (tid1 : nat ) (v : generic_value (symbol.sym ))  : stack a -> stack a:=  
  fun (x : stack a) =>
    match (x) with | Stack_empty => Stack_empty
      | Stack_cons sym_opt cont sk =>
      Stack_cons sym_opt (subst_wait_continuation tid1 v cont)
        (subst_wait_stack tid1 v sk) | Stack_cons2 _ _ _ =>
      DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 76, character 34 to line 82, character 3 *)
    end.
(* [?]: removed value specification. *)

Definition apply_continuation {a : Type}  (cont : list (continuation_element a)) (expr1 : generic_expr a (unit ) (symbol.sym ))  : generic_expr a (unit ) (symbol.sym ):= 
  let f  := (fun (_cont : continuation_element a) (g : generic_expr a (unit ) (symbol.sym )) =>
  match ( (_cont ,g) ) with ( _cont ,  Expr annot1 _ as expr1) =>
    match ( _cont) with | Kwseq annots1 pat e2 =>
      Expr annots1 (Ewseq pat expr1 e2) | Ksseq annots1 pat e2 =>
      Expr annots1 (Esseq pat expr1 e2) | Kunseq annots1 es1 es2 =>
      Expr annots1 ( apply Eunseq ((@ List.app _) es1 (expr1 :: es2)))
    (*
      | Ktry str_es ->
          Etry expr str_es
*) end end) in
  List.fold_left (fun (acc : generic_expr a (unit ) (symbol.sym )) (x : continuation_element a) => f x acc) cont expr1.
(* [?]: removed value specification. *)

Definition empty_stack {a : Type}   : stack a:= 
  Stack_empty.
(* [?]: removed value specification. *)

Definition is_empty_stack {a : Type}   : stack a -> bool :=  
  fun (x : stack a) => match (x) with | Stack_empty => true | _ => false end.
(* [?]: removed value specification. *)

Definition push_empty_continuation {a : Type}  (sym_opt : option (symbol.sym ) ) (sk : stack a)  : stack a:= 
(*  Stack_cons sym_opt [] sk *)
  Stack_cons2 sym_opt CTX sk.
(* [?]: removed value specification. *)

Definition reset_continuation {a : Type}   : stack a -> stack a:=  
  fun (x : stack a) =>
    match (x) with | Stack_empty =>
      (* TODO: are should this fail, just to catch ill-uses? *) Stack_empty
      | Stack_cons sym_opt cont sk => Stack_cons sym_opt [] sk
      | Stack_cons2 _ _ _ =>
      DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 124, character 26 to line 130, character 3 *)
    end.
(* [?]: removed value specification. *)

Definition pop_stack {a : Type}   : stack a -> exception.exceptM ((list (continuation_element a)*stack a) % type) (core_run_cause ):=  
  fun (x : stack a) =>
    match (x) with | Stack_empty =>
      exception.fail0 (Found_empty_stack "pop_stack")
      | Stack_cons _ cont sk => exception.except_return (cont, sk)
      | Stack_cons2 _ _ _ =>
      DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 133, character 17 to line 138, character 3 *)
    end.
(* [?]: removed value specification. *)

Definition pop_continuation_element {a : Type}   : stack a -> exception.exceptM ((continuation_element a*stack a) % type) (core_run_cause ):=  
  fun (x : stack a) =>
    match (x) with | Stack_empty =>
      exception.fail0 (Found_empty_stack "pop_continuation_element")
      | Stack_cons _ [] _ => exception.fail0 Reached_end_of_proc
      | Stack_cons sym_opt( cont_elem :: cont) sk =>
      exception.except_return (cont_elem, Stack_cons sym_opt cont sk)
      | Stack_cons2 _ _ _ =>
      DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 141, character 32 to line 148, character 3 *)
    end.
(* [?]: removed value specification. *)

Definition push_continuation_element {a : Type}  (cont_elem : continuation_element a)  : stack a -> exception.exceptM (stack a) (core_run_cause ):=  
  fun (x : stack a) =>
    match (x) with | Stack_empty =>
      exception.fail0 (Found_empty_stack "push_continuation_element")
      | Stack_cons sym_opt cont sk =>
      exception.except_return (Stack_cons sym_opt (cont_elem :: cont) sk)
      | Stack_cons2 _ _ _ =>
      DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 152, character 43 to line 157, character 3 *)
    end.
(* [?]: removed value specification. *)

Definition append_to_current_continuation {a : Type}  (cont_elem : continuation_element a)  : stack a -> exception.exceptM (stack a) (core_run_cause ):=  
  fun (x : stack a) =>
    match (x) with | Stack_empty =>
      (* A procedure need to currently be running to append *)
      exception.fail0 (Found_empty_stack "append_to_current_continuation")
      | Stack_cons sym_opt cont sk =>
      apply exception.except_return
        (Stack_cons sym_opt (cont_elem :: cont) sk) | Stack_cons2 _ _ _ =>
      DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 162, character 48 to line 168, character 3 *)
    end.





(* The state of a Core thread is a pair of the expressions being executed and
   a stack of continuation. Each element of the stack corresponds a Core
   procedure call  *)
Record thread_state : Type := {
  arena:  expr  core_run_annotation ;
  stack:  stack  core_run_annotation ;
  errno:  tt ;
  env: list  (fmap  symbol.sym   value0 ); (* Scoped environment for the Core symbols *)
  
  (* NON-SEMANTIC stuff *)
  exec_loc: exec_location ;
  current_loc: unit 
}.
Notation "{[ r 'with' 'arena' := e ]}" := ({| arena := e; stack := stack r; errno := errno r; env := env r; exec_loc := exec_loc r; current_loc := current_loc r |}).
Notation "{[ r 'with' 'stack' := e ]}" := ({| stack := e; arena := arena r; errno := errno r; env := env r; exec_loc := exec_loc r; current_loc := current_loc r |}).
Notation "{[ r 'with' 'errno' := e ]}" := ({| errno := e; arena := arena r; stack := stack r; env := env r; exec_loc := exec_loc r; current_loc := current_loc r |}).
Notation "{[ r 'with' 'env' := e ]}" := ({| env := e; arena := arena r; stack := stack r; errno := errno r; exec_loc := exec_loc r; current_loc := current_loc r |}).
Notation "{[ r 'with' 'exec_loc' := e ]}" := ({| exec_loc := e; arena := arena r; stack := stack r; errno := errno r; env := env r; current_loc := current_loc r |}).
Notation "{[ r 'with' 'current_loc' := e ]}" := ({| current_loc := e; arena := arena r; stack := stack r; errno := errno r; env := env r; exec_loc := exec_loc r |}).
Definition thread_state_default: thread_state  := {| arena := DAEMON; stack := DAEMON; errno := tt_default; env := DAEMON; exec_loc := exec_location_default; current_loc := unit_default |}.


Record io_state : Type := {
  stdout: dlist.dlist  string ;
  stderr: dlist.dlist  string 
}.
Notation "{[ r 'with' 'stdout' := e ]}" := ({| stdout := e; stderr := stderr r |}).
Notation "{[ r 'with' 'stderr' := e ]}" := ({| stderr := e; stdout := stdout r |}).
Definition io_state_default: io_state  := {| stdout := DAEMON; stderr := DAEMON |}.

Record core_state : Type := {
  (* the [maybe thread_id] is that of the parent thread if any *)
  thread_states: list  ((mem_common.thread_id  *
                       ((option  mem_common.thread_id   * thread_state ) % type)) % type);
  io: io_state 
}.
Notation "{[ r 'with' 'thread_states' := e ]}" := ({| thread_states := e; io := io r |}).
Notation "{[ r 'with' 'io' := e ]}" := ({| io := e; thread_states := thread_states r |}).
Definition core_state_default: core_state  := {| thread_states := DAEMON; io := io_state_default |}.


(* State of Core evaluator *)
Record core_run_state : Type := {
  tid_supply:      mem_common.thread_id ;
  aid_supply:      cmm_csem.aid ;
  excluded_supply: nat ;
  
  (* Pre-calculated map of labeled continuations (aka. save()).
     the map is over procedure symbols (NOTE: read-only) *)
  labeled: fmap  symbol.sym   (labeled_continuations  core_run_annotation )
}.
Notation "{[ r 'with' 'tid_supply' := e ]}" := ({| tid_supply := e; aid_supply := aid_supply r; excluded_supply := excluded_supply r; labeled := labeled r |}).
Notation "{[ r 'with' 'aid_supply' := e ]}" := ({| aid_supply := e; tid_supply := tid_supply r; excluded_supply := excluded_supply r; labeled := labeled r |}).
Notation "{[ r 'with' 'excluded_supply' := e ]}" := ({| excluded_supply := e; tid_supply := tid_supply r; aid_supply := aid_supply r; labeled := labeled r |}).
Notation "{[ r 'with' 'labeled' := e ]}" := ({| labeled := e; tid_supply := tid_supply r; aid_supply := aid_supply r; excluded_supply := excluded_supply r |}).
Definition core_run_state_default: core_run_state  := {| tid_supply := thread_id_default; aid_supply := aid_default; excluded_supply := nat_default; labeled := DAEMON |}.

(* Monad of the core evaluator (State + Exception + Undefined) *)
Definition core_runM (a: Type) : Type := 
  state_exception_undefined.stExceptUndefM  a  core_run_state   core_run_cause .
Definition core_runM_default{a: Type} : core_runM a := DAEMON.


Definition push_exec_loc  (sym1 : symbol.sym )  : exec_location  -> exec_location :=  
  fun (x : exec_location ) =>
    match (x) with | ELoc_globals => ELoc_normal [sym1] | ELoc_normal syms =>
      ELoc_normal (sym1 :: syms) end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Definition initial_io_state   : io_state :=  {|stdout:= dlist.nil0;stderr:= dlist.nil0
|}.

Definition initial_core_state   : core_state :=  {|thread_states:= [];io:= initial_io_state
|}.

Definition initial_core_run_state  (xs : fmap (symbol.sym ) (labeled_continuations (core_run_annotation )))  : core_run_state :=  {|tid_supply:=( 0);aid_supply:=( 0);excluded_supply:=( 0);labeled:= xs
|}.


Definition empty_annotation   : core_run_annotation :=  {|sb_before  := [];dd_before  := [];asw_before := []
|}.

Instance x120_Default : Default core_run_annotation := {
   default  :=  empty_annotation
}.

(* [?]: removed value specification. *)

Definition has_sbBefore_on_thread  (tid1 : nat ) (annot1 : core_run_annotation )  : bool := 
  set_any (fun (p : (nat *nat ) % type) =>
  match ( (p) ) with ( (tid',  _)) => beq_nat tid1 tid' end
  )(sb_before  annot1).
(* [?]: removed value specification. *)

Program Fixpoint add_to_sb  (p_aids : set ((polarity *((mem_common.thread_id *cmm_csem.aid ) % type)) % type)) (g : generic_expr (core_run_annotation ) (unit ) (symbol.sym ))  : generic_expr (core_run_annotation ) (unit ) (symbol.sym ):= 
  match ( (p_aids,g)) with ( p_aids,  Expr annot1 expr_ as expr1) =>
    if false then
      Expr annot1
        match ( expr_) with | Epure _ => (* no change *) expr_
          | Ememop _ _ => (* no change *) expr_
          | Eaction( Paction p'( Action loc annots1 a)) =>
          Eaction
            (Paction p'
               (Action loc
                  {[ annots1 with sb_before:= (set_union_by
                                                 (pairCompare
                                                    (genericCompare nat_ltb
                                                       beq_nat)
                                                    (genericCompare nat_ltb
                                                       beq_nat))
                                                 (lem_set.map (@ snd _ _)
                                                    p_aids)
                                                 (sb_before  annots1))  ]} 
                a)) | Ecase pe pat_es =>
          Ecase pe
            (List.map
               (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
                  match ( (p) ) with ( (pat,  e)) =>
                    (pat, add_to_sb p_aids e) end) pat_es) | Elet a pe1 e2 =>
          Elet a pe1 (add_to_sb p_aids e2) | Eif pe1 e2 e3 =>
          Eif pe1 (add_to_sb p_aids e2) (add_to_sb p_aids e3)
          | Eccall annots1 ty pe pes =>
          Eccall
            {[ annots1 with sb_before:= (set_union_by
                                           (pairCompare
                                              (genericCompare nat_ltb beq_nat)
                                              (genericCompare nat_ltb beq_nat))
                                           (lem_set.map (@ snd _ _) p_aids)
                                           (sb_before  annots1))  ]} 
          ty pe pes | Eproc annots1 nm pes =>
          Eproc
            {[ annots1 with sb_before:= (set_union_by
                                           (pairCompare
                                              (genericCompare nat_ltb beq_nat)
                                              (genericCompare nat_ltb beq_nat))
                                           (lem_set.map (@ snd _ _) p_aids)
                                           (sb_before  annots1))  ]} 
          nm pes | Eunseq es => Eunseq (List.map (add_to_sb p_aids) es)
          | Ewseq _as e1 e2 =>
          let is_positive := fun (x : (polarity *((mem_common.thread_id *cmm_csem.aid ) % type)) % type) =>
                               match (x) with | (Pos,  _) => true | _ =>
                                 false end in
        Ewseq _as (add_to_sb p_aids e1)
          (add_to_sb (lem_set.filter is_positive p_aids) e2)
          | Esseq _as e1 e2 =>
          Esseq _as (add_to_sb p_aids e1) (add_to_sb p_aids e2)
          | Easeq _ _ _ => BOOM "Core_run_aux.add_to_sb, Easeq" | Ebound _ =>
          BOOM "Core_run_aux.add_to_sb, Ebound" | End es =>
          End (List.map (add_to_sb p_aids) es) | Esave sym_bTy xs e =>
          Esave sym_bTy xs (add_to_sb p_aids e) | Erun annots1 sym1 pes =>
          Erun
            {[ annots1 with sb_before:= (set_union_by
                                           (pairCompare
                                              (genericCompare nat_ltb beq_nat)
                                              (genericCompare nat_ltb beq_nat))
                                           (lem_set.map (@ snd _ _) p_aids)
                                           (sb_before  annots1))  ]} 
          sym1 pes | Epar es => Epar (List.map (add_to_sb p_aids) es)
          | Ewait _ => (* no change *) expr_ | Eannot _ _ =>
          BOOM "Core_run_aux.add_to_sb, Eannot" | Eexcluded _ _ =>
          BOOM "Core_run_aux.add_to_sb, Eexcluded" end else expr1 end.
(* [?]: removed value specification. *)


Program Fixpoint add_to_sb_continuation  (p_aids : set ((polarity *((mem_common.thread_id *cmm_csem.aid ) % type)) % type))  : list (continuation_element (core_run_annotation )) -> list (continuation_element (core_run_annotation )):=  
  fun (x : list (continuation_element (core_run_annotation ))) =>
    match (x) with | [] => [] | Kunseq annots1 es1 es2 :: cont =>
      Kunseq annots1 es1 es2 :: add_to_sb_continuation p_aids cont
      | Kwseq annots1 _as e2 :: cont =>
      let is_positive := fun (x : (polarity *((mem_common.thread_id *cmm_csem.aid ) % type)) % type) =>
                           match (x) with | (Pos,  _) => true | _ => false
                           end in
    Kwseq annots1 _as (add_to_sb (lem_set.filter is_positive p_aids) e2) ::
    add_to_sb_continuation p_aids cont | Ksseq annots1 _as e2 :: cont =>
      Ksseq annots1 _as (add_to_sb p_aids e2) ::
      add_to_sb_continuation p_aids cont end.
Program Fixpoint add_to_sb_stack  (p_aids : set ((polarity *((mem_common.thread_id *cmm_csem.aid ) % type)) % type)) (sk : stack (core_run_annotation ))  : stack (core_run_annotation ):= 
  if false then match ( sk) with | Stack_empty => Stack_empty
   | Stack_cons proc_opt cont sk =>
   match ( fun (_: list domain) (_: unit -> string) := tt []
             (fun (u : unit ) =>
                match ( (u) ) with ( tt) =>
                  "(UNSURE) Core_run_aux.add_to_sb_stack ==> is not touching lconts"
                end)) with tt =>
     Stack_cons proc_opt (add_to_sb_continuation p_aids cont)
       (add_to_sb_stack p_aids sk) end | Stack_cons2 _ _ _ =>
   DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 353, character 5 to line 359, character 6 *)
 end
  else
    sk.
(* [?]: removed value specification. *)

Program Fixpoint add_to_asw  (aids : set (nat )) (g : generic_expr (core_run_annotation ) (unit ) (symbol.sym ))  : generic_expr (core_run_annotation ) (unit ) (symbol.sym ):= 
  match ( (aids,g)) with ( aids,  Expr annot1 expr_ as expr1) =>
    if false then
      match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
              ( 5) [debug.DB_driver; debug.DB_concurrency]
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) => "HELLO add_to_asw ====" end)) with
          tt =>
        Expr annot1
          match ( expr_) with | Epure _ => (* no change *) expr_
            | Ememop _ _ => (* no change *) expr_
            | Eaction( Paction p'( Action loc annots1 a)) =>
            let _ := lem_set.map
                       (fun (aid1 : nat ) =>
                          fun (_:nat) (_: list domain) (_: unit -> string) := tt
                            ( 5) [debug.DB_driver; debug.DB_concurrency]
                            (fun (u : unit ) =>
                               match ( (u) ) with ( tt) =>
                                 String.append "ADD_TO_ASW ==> "
                                   (lem_string_extra.stringFromNat aid1) end)
                       ) aids in
          Eaction
            (Paction p'
               (Action loc
                  {[ annots1 with asw_before:= (set_union_by
                                                  (genericCompare nat_ltb
                                                     beq_nat) aids
                                                  (asw_before  annots1))  ]}
                  a)) | Ecase pe pat_es =>
            Ecase pe
              (List.map
                 (fun (p : (generic_pattern (unit ) (symbol.sym )*generic_expr (core_run_annotation ) (unit ) (symbol.sym )) % type) =>
                    match ( (p) ) with ( (pat,  e)) =>
                      (pat, add_to_asw aids e) end) pat_es)
            | Elet a pe1 e2 => Elet a pe1 (add_to_asw aids e2)
            | Eif pe1 e2 e3 =>
            Eif pe1 (add_to_asw aids e2) (add_to_asw aids e3)
            | Eccall annots1 ty pe pes =>
            Eccall
              {[ annots1 with asw_before:= (set_union_by
                                              (genericCompare nat_ltb beq_nat)
                                              aids (asw_before  annots1))  ]}
              ty pe pes | Eproc annots1 nm pes =>
            Eproc
              {[ annots1 with asw_before:= (set_union_by
                                              (genericCompare nat_ltb beq_nat)
                                              aids (asw_before  annots1))  ]}
              nm pes | Eunseq es => Eunseq (List.map (add_to_asw aids) es)
            | Ewseq _as e1 e2 =>
            Ewseq _as (add_to_asw aids e1) (add_to_asw aids e2) (* TODO this is wrong *)
            | Esseq _as e1 e2 =>
            Esseq _as (add_to_asw aids e1) (add_to_asw aids e2) (* TODO this is wrong *)
            | Easeq _ _ _ => BOOM "Core_run_aux.add_to_asw, Easeq"
            | Ebound _ => BOOM "Core_run_aux.add_to_asw, Ebound"
            | Esave sym_bTy xs e => Esave sym_bTy xs (add_to_asw aids e)
            | Erun annots1 sym1 pes =>
            Erun
              {[ annots1 with asw_before:= (set_union_by
                                              (genericCompare nat_ltb beq_nat)
                                              aids (asw_before  annots1))  ]}
              sym1 pes | End es => End (List.map (add_to_asw aids) es)
            | Epar es => Epar (List.map (add_to_asw aids) es) | Ewait _ =>
            (* no change *) expr_ | Eannot _ _ =>
            BOOM "Core_run_aux.add_to_asw, Eannot" | Eexcluded _ _ =>
            BOOM "Core_run_aux.add_to_asw, Eexcluded" end end else expr1 end.
(* [?]: removed value specification. *)


Program Fixpoint add_to_asw_continuation  (aids : set (cmm_csem.aid ))  : list (continuation_element (core_run_annotation )) -> list (continuation_element (core_run_annotation )):=  
  fun (x : list (continuation_element (core_run_annotation ))) =>
    match (x) with | [] => [] | Kunseq annots1 es1 es2 :: cont =>
      Kunseq annots1 (List.map (add_to_asw aids) es1)
        (List.map (add_to_asw aids) es2) :: add_to_asw_continuation aids cont
      | Kwseq annots1 _as e2 :: cont =>
      Kwseq annots1 _as (add_to_asw aids e2) ::
      add_to_asw_continuation aids cont | Ksseq annots1 _as e2 :: cont =>
      Ksseq annots1 _as (add_to_asw aids e2) ::
      add_to_asw_continuation aids cont end.
Program Fixpoint add_to_asw_stack  (aids : set (cmm_csem.aid )) (sk : stack (core_run_annotation ))  : stack (core_run_annotation ):=  
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5)
            [debug.DB_driver; debug.DB_concurrency]
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) => "BOOM add_to_asw_stack ==> " end(* ^ Pp.stringFromCore_stack sk*) )) with
      tt =>
    if false then
      match ( sk) with | Stack_empty => Stack_empty
        | Stack_cons proc_opt cont sk =>
        Stack_cons proc_opt (add_to_asw_continuation aids cont)
          (add_to_asw_stack aids sk) | Stack_cons2 _ _ _ =>
        DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 436, character 5 to line 441, character 7 *)
      end else sk end.
(* [?]: removed value specification. *)

Program Fixpoint comma_list {a : Type}  (f : a -> string )  : list a -> string :=  
  fun (x : list a) =>
    match (x) with | [] => "" | x::xs =>
      String.append (f x) (String.append ", " (comma_list f xs)) end.
(* [?]: removed value specification. *)

Definition convert_ctor {bty : Type}   : generic_ctor bty -> generic_ctor (unit ):=  
  fun (x : generic_ctor bty) =>
    match (x) with | Cnil _ => Cnil tt | Ccons => Ccons | Ctuple => Ctuple
      | Carray => Carray | Civmax => Civmax | Civmin => Civmin | Civsizeof =>
      Civsizeof | Civalignof => Civalignof | CivCOMPL => CivCOMPL | CivAND =>
      CivAND | CivOR => CivOR | CivXOR => CivXOR | Cspecified => Cspecified
      | Cunspecified => Cunspecified | Cfvfromint => Cfvfromint
      | Civfromfloat => Civfromfloat end.
(* [?]: removed value specification. *)

Program Fixpoint convert_pattern {bty : Type}  (g : generic_pattern bty (symbol.sym ))  : generic_pattern (unit ) (symbol.sym ):= 
  match ( (g)) with (( Pattern annots1 pat)) =>
    apply (Pattern annots1)
      match ( pat) with | CaseBase (sym_opt,  bTy) => CaseBase (sym_opt, bTy)
        | CaseCtor ctor1 pats =>
        CaseCtor (convert_ctor ctor1) (List.map convert_pattern pats) end end.
(* [?]: removed value specification. *)

Program Fixpoint convert_pexpr {bty : Type}  (g : generic_pexpr bty (symbol.sym ))  : generic_pexpr (unit ) (symbol.sym ):= 
  match ( (g)) with (( Pexpr annot1 _ pexpr_)) =>
    Pexpr annot1 tt
      match ( pexpr_) with | PEsym sym1 => PEsym sym1 | PEimpl iCst =>
        PEimpl iCst | PEval cval => PEval cval | PEconstrained xs =>
        PEconstrained
          (List.map
             (fun (p : (mem_common.mem_constraint (tt )*generic_pexpr bty (symbol.sym )) % type) =>
                match ( (p) ) with ( (constrs,  pe)) =>
                  (constrs, convert_pexpr pe) end) xs) | PEundef loc ub =>
        PEundef loc ub | PEerror str pe => PEerror str (convert_pexpr pe)
        | PEctor ctor1 pes =>
        PEctor (convert_ctor ctor1) (List.map convert_pexpr pes)
        | PEcase pe pat_pes =>
        PEcase (convert_pexpr pe)
          (List.map
             (fun (p : (generic_pattern bty (symbol.sym )*generic_pexpr bty (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  pe)) =>
                  (convert_pattern pat, convert_pexpr pe) end) pat_pes)
        | PEarray_shift pe1 ty pe2 =>
        PEarray_shift (convert_pexpr pe1) ty (convert_pexpr pe2)
        | PEmember_shift pe sym1 ident =>
        PEmember_shift (convert_pexpr pe) sym1 ident | PEnot pe =>
        PEnot (convert_pexpr pe) | PEop bop pe1 pe2 =>
        PEop bop (convert_pexpr pe1) (convert_pexpr pe2)
        | PEstruct sym1 ident_pes =>
        PEstruct sym1
          (List.map
             (fun (p : (cabs.cabs_identifier *generic_pexpr bty (symbol.sym )) % type) =>
                match ( (p) ) with ( (ident,  pe)) =>
                  (ident, convert_pexpr pe) end) ident_pes)
        | PEunion sym1 ident pe => PEunion sym1 ident (convert_pexpr pe)
        | PEcfunction pe => PEcfunction (convert_pexpr pe)
        | PEmemberof tag_sym memb_ident pe =>
        PEmemberof tag_sym memb_ident (convert_pexpr pe) | PEcall nm pes =>
        PEcall nm (List.map convert_pexpr pes) | PElet pat pe1 pe2 =>
        PElet (convert_pattern pat) (convert_pexpr pe1) (convert_pexpr pe2)
        | PEif pe1 pe2 pe3 =>
        PEif (convert_pexpr pe1) (convert_pexpr pe2) (convert_pexpr pe3)
        | PEis_scalar pe => PEis_scalar (convert_pexpr pe)
        | PEis_integer pe => PEis_integer (convert_pexpr pe)
        | PEis_signed pe => PEis_signed (convert_pexpr pe)
        | PEis_unsigned pe => PEis_unsigned (convert_pexpr pe)
        | PEbmc_assume pe => PEbmc_assume (convert_pexpr pe)
        | PEare_compatible pe1 pe2 =>
        PEare_compatible (convert_pexpr pe1) (convert_pexpr pe2) end end.
(* [?]: removed value specification. *)

Program Fixpoint convert_expr {a bty : Type}  (g : generic_expr a bty (symbol.sym ))  : generic_expr (core_run_annotation ) (unit ) (symbol.sym ):= 
  match ( (g)) with (( Expr annot1 expr_)) =>
    Expr annot1
      match ( expr_) with | Epure pe => Epure (convert_pexpr pe)
        | Ememop memop1 pes => Ememop memop1 (List.map convert_pexpr pes)
        | Elet pat pe1 e2 =>
        Elet (convert_pattern pat) (convert_pexpr pe1) (convert_expr e2)
        | Eif pe1 e2 e3 =>
        Eif (convert_pexpr pe1) (convert_expr e2) (convert_expr e3)
        | Ecase pe pat_es =>
        Ecase (convert_pexpr pe)
          (List.map
             (fun (p : (generic_pattern bty (symbol.sym )*generic_expr a bty (symbol.sym )) % type) =>
                match ( (p) ) with ( (pat,  e)) =>
                  (convert_pattern pat, convert_expr e) end) pat_es)
        | Eccall _ ty pe pes =>
        Eccall empty_annotation (convert_pexpr ty) (convert_pexpr pe)
          (List.map convert_pexpr pes) | Eproc _ nm pes =>
        Eproc empty_annotation nm (List.map convert_pexpr pes)
        | Eaction pact => Eaction (convert_paction pact) | Eunseq es =>
        Eunseq (List.map convert_expr es) | Ewseq pat e1 e2 =>
        Ewseq (convert_pattern pat) (convert_expr e1) (convert_expr e2)
        | Esseq pat e1 e2 =>
        Esseq (convert_pattern pat) (convert_expr e1) (convert_expr e2)
        | Easeq sym_opt act1 act2 =>
        Easeq sym_opt (convert_action act1) (convert_action act2)
        | Ebound e => Ebound (convert_expr e) | Esave sym1 xs e =>
        Esave sym1
          (List.map
             (fun (p : (symbol.sym *((core_base_type *generic_pexpr bty (symbol.sym )) % type)) % type) =>
                match ( (p) ) with ( (sym1,  (bTy,  pe))) =>
                  (sym1, (bTy, convert_pexpr pe)) end) xs) (convert_expr e)
        | Erun _ sym1 pes =>
        Erun empty_annotation sym1 (List.map convert_pexpr pes) | End es =>
        End (List.map convert_expr es) | Epar es =>
        Epar (List.map convert_expr es) | Ewait tid1 => Ewait tid1
        | Eannot _ _ =>
        DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 576, character 14 to line 619, character 5 *)
        | Eexcluded _ _ =>
        DAEMON (* Incomplete Pattern at File \"ocaml_generated/core_run_aux.lem\", line 576, character 14 to line 619, character 5 *)
      (*
    | Eloc loc e ->
        Eloc loc (convert_expr e)
    | Estd s e ->
        Estd s (convert_expr e)
*)
      end end
with convert_action_ {a bty : Type}  (act_ : generic_action_ bty (symbol.sym ))  : generic_action_ (unit ) (symbol.sym ):= 
  match ( (act_)) with ( act_) =>
    match ( act_) with | Create pe1 pe2 pref =>
      Create (convert_pexpr pe1) (convert_pexpr pe2) pref
      | CreateReadOnly pe1 pe2 pe3 pref =>
      CreateReadOnly (convert_pexpr pe1) (convert_pexpr pe2)
        (convert_pexpr pe3) pref | Alloc0 pe1 pe2 pref =>
      Alloc0 (convert_pexpr pe1) (convert_pexpr pe2) pref | Kill b pe =>
      Kill b (convert_pexpr pe) | Store0 b pe1 pe2 pe3 mo1 =>
      Store0 b (convert_pexpr pe1) (convert_pexpr pe2) (convert_pexpr pe3)
        mo1 | SeqRMW b pe1 pe2 sym1 pe3 =>
      SeqRMW b (convert_pexpr pe1) (convert_pexpr pe2) sym1
        (convert_pexpr pe3) | Load0 pe1 pe2 mo1 =>
      Load0 (convert_pexpr pe1) (convert_pexpr pe2) mo1
      | RMW0 pe1 pe2 pe3 pe4 mo1 mo2 =>
      RMW0 (convert_pexpr pe1) (convert_pexpr pe2) (convert_pexpr pe3)
        (convert_pexpr pe4) mo1 mo2 | Fence0 mo1 => Fence0 mo1
      | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 =>
      CompareExchangeStrong (convert_pexpr pe1) (convert_pexpr pe2)
        (convert_pexpr pe3) (convert_pexpr pe4) mo1 mo2
      | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 =>
      CompareExchangeWeak (convert_pexpr pe1) (convert_pexpr pe2)
        (convert_pexpr pe3) (convert_pexpr pe4) mo1 mo2 | LinuxFence mo1 =>
      LinuxFence mo1 | LinuxStore pe1 pe2 pe3 mo1 =>
      LinuxStore (convert_pexpr pe1) (convert_pexpr pe2) (convert_pexpr pe3)
        mo1 | LinuxLoad pe1 pe2 mo1 =>
      LinuxLoad (convert_pexpr pe1) (convert_pexpr pe2) mo1
      | LinuxRMW pe1 pe2 pe3 mo1 =>
      LinuxRMW (convert_pexpr pe1) (convert_pexpr pe2) (convert_pexpr pe3)
        mo1 end end
with convert_action {a bty : Type}  (act : generic_action a bty (symbol.sym ))  : generic_action (core_run_annotation ) (unit ) (symbol.sym ):= 
  match ( (act)) with ( act) =>
    match ( act) with | Action loc _ act_ =>
      Action loc empty_annotation (convert_action_ act_) end end
with convert_paction {a bty : Type}  (pact : generic_paction a bty (symbol.sym ))  : generic_paction (core_run_annotation ) (unit ) (symbol.sym ):= 
  match ( (pact)) with ( pact) =>
    match ( pact) with | Paction p act => Paction p (convert_action act) end
  end.

Definition convert_impl_decl {a : Type}   : generic_impl_decl a -> generic_impl_decl (unit ):=  
  fun (x : generic_impl_decl a) =>
    match (x) with | Def bTy pe => Def bTy (convert_pexpr pe)
      | IFun bTy sym_bTys pe => IFun bTy sym_bTys (convert_pexpr pe) end.

Definition convert_globs {a b c : Type}  (p : (a*generic_globs b c) % type)  : (a*generic_globs (core_run_annotation ) (unit )) % type:= 
  match ( (p)) with ( (name1,  glb)) =>
    (name1, match ( glb) with | GlobalDef bTy e =>
              GlobalDef bTy (convert_expr e) | GlobalDecl bTy =>
              GlobalDecl bTy end) end.
(* [?]: removed value specification. *)

Definition convert_file {a bty : Type}  (file1 : generic_file bty a)  : generic_file (unit ) (core_run_annotation ):= 
  let convert_fun_map_decl  := 
  fun (x : generic_fun_map_decl bty a) =>
    match (x) with | Fun bTy params pe => Fun bTy params (convert_pexpr pe)
      | ProcDecl loc bTy params => ProcDecl loc bTy params
      | BuiltinDecl loc bTy params => BuiltinDecl loc bTy params
      | Proc loc bTy params e => Proc loc bTy params (convert_expr e) end in

 {|main:=(main     file1);tagDefs:=(tagDefs  file1);stdlib:=  (fmap_map convert_fun_map_decl(stdlib  file1));impl:=    (fmap_map convert_impl_decl(impl  file1));globs:=   (List.map convert_globs(globs  file1));funs:=    (fmap_map convert_fun_map_decl(funs  file1));extern:=(extern   file1);funinfo:=(funinfo  file1)
 |}.
(* END silly *)
