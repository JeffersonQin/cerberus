(* Generated by Lem from ocaml_generated/AilSyntax.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import loc.
Require Export loc.
Require Import ctype.
Require Export ctype.

Require Import symbol.
Require Export symbol.


Definition identifier : Type :=  symbol.sym .
Definition identifier_default: identifier  := sym_default.

Definition reg : Type :=  nat .
Definition reg_default: reg  := nat_default.

Inductive integerSuffix : Type :=  
 | U: integerSuffix 
 | UL: integerSuffix 
 | ULL: integerSuffix 
 | L: integerSuffix 
 | LL: integerSuffix .
Definition integerSuffix_default: integerSuffix  := U.

Inductive basis : Type := 
  | Octal: basis 
  | Decimal: basis 
  | Hexadecimal: basis .
Definition basis_default: basis  := Octal.

Inductive integerConstant : Type := 
  | IConstant:  Z  ->  basis  ->  option  integerSuffix   -> integerConstant 
  | IConstantMax:  integerType  -> integerConstant 
  | IConstantMin:  integerType  -> integerConstant .
Definition integerConstant_default: integerConstant  := IConstant Z_default basis_default DAEMON.

Inductive floatingSuffix : Type := 
  | Fsuf_F: floatingSuffix 
  | Fsuf_L: floatingSuffix .
Definition floatingSuffix_default: floatingSuffix  := Fsuf_F.

Definition floatingConstant : Type := ( string  * option  floatingSuffix  ) % type.
Definition floatingConstant_default: floatingConstant  := (string_default, DAEMON).

Inductive characterPrefix : Type := 
  | Pref_L: characterPrefix 
  | Pref_u: characterPrefix 
  | Pref_U: characterPrefix .
Definition characterPrefix_default: characterPrefix  := Pref_L.

Definition characterConstant : Type := ( option  characterPrefix   * string ) % type.
Definition characterConstant_default: characterConstant  := (DAEMON, string_default).

Inductive encodingPrefix : Type := 
  | Enc_u8: encodingPrefix 
  | Enc_u: encodingPrefix 
  | Enc_U: encodingPrefix 
  | Enc_L: encodingPrefix .
Definition encodingPrefix_default: encodingPrefix  := Enc_u8.

Definition stringLiteral : Type := ( option  encodingPrefix   * list  string ) % type.
Definition stringLiteral_default: stringLiteral  := (DAEMON, DAEMON).

Inductive arithmeticOperator : Type := 
  (* STD Â§6.5.5 Multiplicative operators *)
  | Mul: arithmeticOperator  | Div: arithmeticOperator  | Mod: arithmeticOperator 
  (* STD Â§6.5.6 Additive operators *)
  | Add: arithmeticOperator  | Sub: arithmeticOperator 
  (* STD Â§6.5.7 Bitwise shift operators *)
  | Shl: arithmeticOperator  | Shr: arithmeticOperator 
  (* STD Â§6.5.10 Bitwise AND operator *)
  | Band: arithmeticOperator 
  (* STD Â§6.5.11 Bitwise exclusive OR operator *)
  | Bxor: arithmeticOperator 
  (* STD Â§6.5.12 Bitwise inclusive OR operator *)
  | Bor: arithmeticOperator .
Definition arithmeticOperator_default: arithmeticOperator  := Mul.

Inductive constant : Type := 
  | ConstantIndeterminate:  ctype  -> constant 
  | ConstantNull: constant 
  | ConstantInteger:        integerConstant  -> constant 
  | ConstantFloating:       floatingConstant  -> constant 
  | ConstantCharacter:      characterConstant  -> constant 
  | ConstantArray:          ctype  ->  list  constant  -> constant 
  | ConstantStruct:         symbol.sym  ->  list  ((cabs.cabs_identifier  * constant ) % type) -> constant 
  | ConstantUnion:          symbol.sym  ->  cabs.cabs_identifier  ->  constant  -> constant .
Definition constant_default: constant  := ConstantIndeterminate ctype_default.

Inductive unaryOperator : Type := 
  | Plus: unaryOperator 
  | Minus: unaryOperator 
  | Bnot: unaryOperator 
  | Address: unaryOperator 
  | Indirection: unaryOperator 
  | PostfixIncr: unaryOperator  (*r Note: Appears prefix in concrete syntax. *)
  | PostfixDecr: unaryOperator .
Definition unaryOperator_default: unaryOperator  := Plus. (*r Note: Appears prefix in concrete syntax. *)

Inductive binaryOperator : Type :=   (*r Group of operators also used for assignments *)
  | Arithmetic:  arithmeticOperator  -> binaryOperator  (*r 6.5.17 Comma operator *)
  | Comma: binaryOperator  (*r 6.5.13 Logical AND operator *)
  | And: binaryOperator  (*r 6.5.14 Logical OR operator *)
  | Or: binaryOperator  (*r 6.5.8 Relational operators *)
  | Lt: binaryOperator 
  | Gt: binaryOperator 
  | Le: binaryOperator 
  | Ge: binaryOperator  (*r 6.5.9 Equality operators *)
  | Eq: binaryOperator 
  | Ne: binaryOperator .
Definition binaryOperator_default: binaryOperator  := Arithmetic arithmeticOperator_default.

Inductive ail_builtin_atomic : Type := 
  | AilBAthread_fence: ail_builtin_atomic 
  | AilBAstore: ail_builtin_atomic 
  | AilBAload: ail_builtin_atomic 
  | AilBAexchange: ail_builtin_atomic 
  | AilBAcompare_exchange_strong: ail_builtin_atomic 
  | AilBAcompare_exchange_weak: ail_builtin_atomic 
  | AilBAfetch_key: ail_builtin_atomic .
Definition ail_builtin_atomic_default: ail_builtin_atomic  := AilBAthread_fence.

Inductive ail_builtin_linux : Type := 
  | AilBLfence: ail_builtin_linux 
  | AilBLread: ail_builtin_linux 
  | AilBLwrite: ail_builtin_linux 
  | AilBLrmw: ail_builtin_linux .
Definition ail_builtin_linux_default: ail_builtin_linux  := AilBLfence.

(* NOTE: add new constructors here when adding new builtins to Ail *)
Inductive ail_builtin : Type := 
  | AilBatomic:  ail_builtin_atomic  -> ail_builtin 
  | AilBlinux:  ail_builtin_linux  -> ail_builtin .
Definition ail_builtin_default: ail_builtin  := AilBatomic ail_builtin_atomic_default.

Inductive expression_ (a : Type) : Type :=  
  | AilEunary:  unaryOperator  ->  expression  a -> expression_ a
  | AilEbinary:  expression  a ->  binaryOperator  ->  expression  a -> expression_ a
  | AilEassign:  expression  a ->  expression  a -> expression_ a
  | AilEcompoundAssign:  expression  a ->  arithmeticOperator  ->  expression  a -> expression_ a
  | AilEcond:  expression  a ->  expression  a ->  expression  a -> expression_ a
  | AilEcast:  qualifiers  ->  ctype  ->  expression  a -> expression_ a
  | AilEcall:  expression  a ->  list  (expression  a) -> expression_ a
  | AilEassert:  expression  a -> expression_ a
  | AilEoffsetof:  ctype  ->  cabs.cabs_identifier  -> expression_ a
  | AilEgeneric:  expression  a ->  list  (generic_association  a) -> expression_ a
  (* NOTE: these don't exist in C (apart from in decl)
   * the boolean says whether this array was created from a string literal
   * used to initialise a pointer to an array of character *)
  | AilEarray:  bool  ->  ctype  ->  list  (option  (expression  a) ) -> expression_ a
  | AilEstruct:  identifier  ->  list  ((cabs.cabs_identifier  * option  (expression  a) ) % type) -> expression_ a (* tag, pairs of member id, expression *)
  | AilEunion:  identifier  ->  cabs.cabs_identifier  ->  option  (expression  a)  -> expression_ a
  (* NOTE: the expression obviously need to match the type, and will typically
   * be a AilEarray or AilEstruct *)
  | AilEcompound:  qualifiers  ->  ctype  ->  expression  a -> expression_ a
  | AilEmemberof:  expression  a ->  cabs.cabs_identifier  -> expression_ a
  | AilEmemberofptr:  expression  a ->  cabs.cabs_identifier  -> expression_ a
  | AilEbuiltin:  ail_builtin  -> expression_ a
  | AilEstr:  stringLiteral  -> expression_ a
  | AilEconst:  constant  -> expression_ a
  | AilEident:  identifier  -> expression_ a
  | AilEsizeof:  qualifiers  ->  ctype  -> expression_ a
  | AilEsizeof_expr:  expression  a -> expression_ a
  | AilEalignof:  qualifiers  ->  ctype  -> expression_ a
  (* NOTE: type annotation on expression, used to remember the type of desugared
   * enumeration constants *)
  | AilEannot:  ctype  ->  (expression  a) -> expression_ a
  | AilEva_start:  expression  a ->  identifier  -> expression_ a
  | AilEva_arg:  expression  a ->  ctype  -> expression_ a
  | AilEva_copy:  expression  a ->  expression  a -> expression_ a
  | AilEva_end:  expression  a -> expression_ a
  | AilEprint_type:  expression  a -> expression_ a
  | AilEbmc_assume:  expression  a -> expression_ a
  | AilEreg_load:  reg  -> expression_ a
    (* Â§6.3.2.1#2, the result of a non-array lvalue conversion *)
  | AilErvalue:  expression  a -> expression_ a (* NOTE: never generated by the desugaring *)
    (* Â§6.3.2.1#3 *)
  | AilEarray_decay:  expression  a -> expression_ a (* NOTE: never generated by the desugaring *)
    (* Â§6.3.2.1#4 *)
  | AilEfunction_decay:  expression  a -> expression_ a (* NOTE: never generated by the desugaring *)

with generic_association (a : Type) : Type := 
  | AilGAtype:  ctype  ->  expression  a -> generic_association a
  | AilGAdefault:  expression  a -> generic_association a

with expression (a : Type) : Type := 
  | AnnotatedExpression:  a ->  list  string  ->  unit  ->  expression_  a -> expression a.
Definition expression__default{a: Type} : expression_ a := AilEunary unaryOperator_default DAEMON.
Definition generic_association_default{a: Type} : generic_association a := AilGAtype ctype_default DAEMON.
Definition expression_default{a: Type} : expression a := AnnotatedExpression DAEMON DAEMON unit_default DAEMON.

Instance x38_Located{a: Type} : Located (expression  a):= {
   locOf   a_expr :=  
  match ( a_expr) with ( AnnotatedExpression _ _ loc _) => loc end
}.


(* STD Â§6.2.4#1 *)
Inductive storageDuration : Type := 
 | Static: storageDuration 
 | Thread: storageDuration 
 | Automatic: storageDuration 
 | Allocated: storageDuration .
Definition storageDuration_default: storageDuration  := Static.

(* the boolean tells whether the object was declared with the register
 * storage-class *)
Definition bindings : Type := 
  list  ((identifier  * ((((unit  * storageDuration  * bool ) % type) * qualifiers  * ctype ) % type)) % type).
Definition bindings_default: bindings  := DAEMON.

Inductive statement_ (a : Type) : Type := 
  | AilSskip: statement_ a
  | AilSexpr:  expression  a -> statement_ a
  | AilSblock:  bindings  ->  list  (statement  a) -> statement_ a
  | AilSif:  expression  a ->  statement  a ->  statement  a -> statement_ a
  | AilSwhile:  expression  a ->  statement  a -> statement_ a
  | AilSdo:  statement  a ->  expression  a -> statement_ a
  | AilSbreak: statement_ a
  | AilScontinue: statement_ a
  | AilSreturnVoid: statement_ a
  | AilSreturn:  expression  a -> statement_ a
  | AilSswitch:  expression  a ->  statement  a -> statement_ a
  | AilScase:  integerConstant  ->  statement  a -> statement_ a
  | AilSdefault:  statement  a -> statement_ a
  | AilSlabel:  identifier  ->  statement  a -> statement_ a
  | AilSgoto:  identifier  -> statement_ a
  | AilSdeclaration:  list  ((identifier  * expression  a) % type) -> statement_ a
  | AilSpar:  list  (statement  a) -> statement_ a (* NON-STD cppmem threads *)
  | AilSreg_store:  reg  ->  expression  a -> statement_ a
with statement (a : Type) : Type := 
  | AnnotatedStatement:  unit  ->  statement_  a -> statement a.
Definition statement__default{a: Type} : statement_ a := AilSskip.
Definition statement_default{a: Type} : statement a := AnnotatedStatement unit_default DAEMON.

Instance x37_Located{a: Type} : Located (statement  a):= {
   locOf   stmt :=  match ( stmt) with ( AnnotatedStatement loc _) => loc end
}.


Inductive declaration0 : Type := 
  | Decl_object:    ((storageDuration  * bool ) % type) ->  qualifiers  ->  ctype  -> declaration0 
  | Decl_function:  bool  (* has_prototype *)
                   ->  ((qualifiers  * ctype ) % type) (* return qualifiers *)
                   ->  (list  ((qualifiers  * ctype  * (* isRegister *)bool ) % type))
                   ->  bool  (* is_variadic *)
                   ->  bool  (* is_inline *)
                   ->  bool  -> declaration0 .
Definition declaration0_default: declaration0  := Decl_object (storageDuration_default, bool_default) qualifiers_default ctype_default. (* is_Noreturn *)

(* external identifier kind *)
Inductive id_kind : Type := 
  | IK_declaration: id_kind 
  | IK_tentative: id_kind 
  | IK_definition: id_kind .
Definition id_kind_default: id_kind  := IK_declaration.

Record sigma (a: Type) : Type := {
  declarations: list  ((identifier  * ((unit  * declaration0 ) % type)) % type);
  object_definitions: list  ((identifier  * (expression  a)) % type);
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: list  ((identifier  * ((unit  * list  identifier  * statement  a) % type)) % type);
  static_assertions: list  ((expression  a * stringLiteral ) % type);
  tag_definitions: list  ((identifier  * tag_definition ) % type);
  extern_idmap: fmap  cabs.cabs_identifier   ((identifier  * id_kind ) % type)
}.
Notation "{[ r 'with' 'declarations' := e ]}" := ({| declarations := e; object_definitions := object_definitions r; function_definitions := function_definitions r; static_assertions := static_assertions r; tag_definitions := tag_definitions r; extern_idmap := extern_idmap r |}).
Notation "{[ r 'with' 'object_definitions' := e ]}" := ({| object_definitions := e; declarations := declarations r; function_definitions := function_definitions r; static_assertions := static_assertions r; tag_definitions := tag_definitions r; extern_idmap := extern_idmap r |}).
Notation "{[ r 'with' 'function_definitions' := e ]}" := ({| function_definitions := e; declarations := declarations r; object_definitions := object_definitions r; static_assertions := static_assertions r; tag_definitions := tag_definitions r; extern_idmap := extern_idmap r |}).
Notation "{[ r 'with' 'static_assertions' := e ]}" := ({| static_assertions := e; declarations := declarations r; object_definitions := object_definitions r; function_definitions := function_definitions r; tag_definitions := tag_definitions r; extern_idmap := extern_idmap r |}).
Notation "{[ r 'with' 'tag_definitions' := e ]}" := ({| tag_definitions := e; declarations := declarations r; object_definitions := object_definitions r; function_definitions := function_definitions r; static_assertions := static_assertions r; extern_idmap := extern_idmap r |}).
Notation "{[ r 'with' 'extern_idmap' := e ]}" := ({| extern_idmap := e; declarations := declarations r; object_definitions := object_definitions r; function_definitions := function_definitions r; static_assertions := static_assertions r; tag_definitions := tag_definitions r |}).
Definition sigma_default{a: Type} : sigma a := {| declarations := DAEMON; object_definitions := DAEMON; function_definitions := DAEMON; static_assertions := DAEMON; tag_definitions := DAEMON; extern_idmap := DAEMON |}.


Definition gamma : Type :=  list  ((identifier  * ((((unit  * storageDuration  * bool ) % type) * qualifiers  * ctype ) % type)) % type).
Definition gamma_default: gamma  := DAEMON.

Definition ail_program (a: Type) : Type := ( option  identifier   * sigma  a) % type.
Definition ail_program_default{a: Type} : ail_program a := (DAEMON, DAEMON).

