(* Generated by Lem from ocaml_generated/symbol.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.
Require Import lem_show.
Require Export lem_show.
Require Import lem_show_extra.
Require Export lem_show_extra.
Require Import enum.
Require Export enum.
Require Import loc.
Require Export loc.

Require Import debug.
Require Export debug.


Inductive identifier : Type := 
  | Identifier0:  unit  ->  string  -> identifier .
Definition identifier_default: identifier  := Identifier0 unit_default string_default.

Instance x91_Eq : Eq identifier := {
   isEqual   ident1  ident2 :=  
  match ( ident1) with ( Identifier0 _ str1) =>
    match ( ident2) with ( Identifier0 _ str2) => (string_equal str1 str2)
    end end;
   isInequal   ident1  ident2 :=  
  match ( ident1) with ( Identifier0 _ str1) =>
    match ( ident2) with ( Identifier0 _ str2) =>
      negb ((string_equal str1 str2)) end end
}.


Instance x90_SetType : SetType identifier := {
   setElemCompare   ident1  ident2 :=  
  match ( ident1) with ( Identifier0 _ str1) =>
    match ( ident2) with ( Identifier0 _ str2) => EQ end end
}.


Instance x89_Located : Located identifier := {
   locOf   ident :=  match ( ident) with ( Identifier0 loc _) => loc end
}.


Instance x88_Show : Show identifier := {
   show   ident :=  match ( ident) with Identifier0 _ str => str end
}.


(* fix the below *)
Inductive digest : Type :=  Digest0:  unit  -> digest .
Definition digest_default: digest  := Digest0 unit_default.
(* [?]: removed value specification. *)

Definition digest0   tt  : digest :=  Digest0 tt.
(* [?]: removed value specification. *)

Definition digest_compare0  ( _ : digest ) ( _ : digest )  : Z := Coq.ZArith.BinIntDef.Z.of_nat 0.
(* [?]: removed value specification. *)

Definition string_of_digest0  ( _ : digest )  : string :=  "".

Instance x87_Eq : Eq digest := {
   isEqual   x  y :=  Z.eqb (digest_compare0 x y)(Coq.ZArith.BinIntDef.Z.of_nat 0);
   isInequal   x  y :=  negb (Z.eqb (digest_compare0 x y)(Coq.ZArith.BinIntDef.Z.of_nat 0))
}.


Instance x86_Ord : Ord digest := {
   compare   x  y := 
    let cmp := digest_compare0 x y in
    if int_ltb cmp(Coq.ZArith.BinIntDef.Z.of_nat 0) then LT else if Z.eqb cmp(Coq.ZArith.BinIntDef.Z.of_nat 0) then EQ else GT;
   isLess   x  y :=  int_ltb
    (digest_compare0 x y)(Coq.ZArith.BinIntDef.Z.of_nat 0);
   isLessEqual   x  y :=  int_lteb
    (digest_compare0 x y)(Coq.ZArith.BinIntDef.Z.of_nat 0);
   isGreater   x  y :=  int_gtb
    (digest_compare0 x y)(Coq.ZArith.BinIntDef.Z.of_nat 0);
   isGreaterEqual   x  y :=  int_gteb
    (digest_compare0 x y)(Coq.ZArith.BinIntDef.Z.of_nat 0)
}.


Instance x85_Show : Show digest := {
   show   d :=  string_of_digest0 d
}.



(* Symbolic identifiers *)
Inductive sym : Type := 
  Symbol0:  digest  ->  nat  ->  option  string   -> sym .
Definition sym_default: sym  := Symbol0 digest_default nat_default DAEMON.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
Definition symbolEqual0   : sym  -> sym  -> bool :=  (fun (sym1 : sym ) (sym2 : sym )=>match ( (sym1, sym2)) with 
    | (Symbol0 d1 n1 str_opt1,  Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (digest_compare0 d1 d2)(Coq.ZArith.BinIntDef.Z.of_nat 0) && beq_nat n1 n2 then
          if nat_gteb (debug.get_level tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( debug.print_debug ( 5) []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end).
(* [?]: removed value specification. *)

Definition symbol_compare0  (s : sym ) (s0 : sym )  : ordering := 
  match ( (s,s0)) with (( Symbol0 d1 n1 _), ( Symbol0 d2 n2 _)) =>
    if Z.eqb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) then
      (genericCompare nat_ltb beq_nat n1 n2) else
      let cmp := digest_compare0 d1 d2 in
      if int_ltb cmp (Coq.ZArith.BinIntDef.Z.of_nat 0) then LT else
        if Z.eqb cmp (Coq.ZArith.BinIntDef.Z.of_nat 0) then EQ else GT end.

Instance x84_Eq : Eq sym := {
   isEqual             :=  symbolEqual0;
   isInequal   sym1  sym2 :=  negb (symbolEqual0 sym1 sym2)
}.


Instance x83_Ord : Ord sym := {
   compare   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      if Z.eqb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) then
        (genericCompare nat_ltb beq_nat n1 n2) else
        let cmp := digest_compare0 d1 d2 in
        if int_ltb cmp (Coq.ZArith.BinIntDef.Z.of_nat 0) then LT else
          if Z.eqb cmp (Coq.ZArith.BinIntDef.Z.of_nat 0) then EQ else GT end
  end;
   isLess   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_ltb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) ||
      ( Z.eqb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) &&
        nat_ltb n1 n2) end end;
   isLessEqual   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_lteb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) ||
      ( Z.eqb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) &&
        nat_lteb n1 n2) end end;
   isGreater   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_gtb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) ||
      ( Z.eqb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) &&
        nat_gtb n1 n2) end end;
   isGreaterEqual   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_gteb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) ||
      ( Z.eqb (digest_compare0 d1 d2) (Coq.ZArith.BinIntDef.Z.of_nat 0) &&
        nat_gteb n1 n2) end end
}.


Instance x82_NumSucc : NumSucc sym := {
   succ   sym :=  match ( sym) with ( Symbol0 d n str_opt) =>
   Symbol0 d (Coq.Init.Peano.plus n ( 1)) str_opt end
}.


Instance x81_SetType : SetType sym := {
   setElemCompare   sym1  sym2 :=  ordCompare sym1 sym2
}.


Instance x80_Show : Show sym := {
   show   sym :=  match ( sym) with Symbol0 d n str_opt =>
   String.append "Symbol"
     (stringFromPair
        (fun  n=>
           Coq.Numbers.DecimalString.NilZero.string_of_int
             (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n)))
        (fun  x_opt=>
           stringFromMaybe
             (fun  s=> String.append """" (String.append s """")) x_opt)
        (n, str_opt)) end
}.


Definition show_raw0  (s : sym )  : string := 
  match ( (s)) with (( Symbol0 d n str_opt)) =>
    String.append "Symbol("
      (String.append (string_of_digest0 d)
         (String.append ", "
            (String.append
               (Coq.Numbers.DecimalString.NilZero.string_of_int
                  (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n)))
               (String.append ", "
                  (String.append
                     (stringFromMaybe
                        (fun (s : string )=>
                           String.append """" (String.append s """")) 
                      str_opt) ")"))))) end.


(* Location prefix *)
Inductive prefix : Type := 
  | PrefSource0:  unit  ->  list  sym  -> prefix 
  | PrefFunArg0:  unit  ->  digest  ->  Z  -> prefix 
  | PrefStringLiteral0:  unit  ->  digest  -> prefix 
  | PrefCompoundLiteral0:  unit  ->  digest  -> prefix 
  | PrefMalloc0: prefix 
  | PrefOther0:  string  -> prefix .
Definition prefix_default: prefix  := PrefSource0 unit_default DAEMON.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition digest_of_sym0  (s : sym )  : digest := 
  match ( (s)) with (( Symbol0 dig _ _)) => dig end.
(* [?]: removed value specification. *)

Definition fresh0   tt  : sym := 
  Symbol0 (digest0 tt) (DAEMON tt) None.
(* [?]: removed value specification. *)

Definition fresh_pretty0  (str : string )  : sym := 
  Symbol0 (digest0 tt) (DAEMON tt) (Some str).
(* [?]: removed value specification. *)

Definition fresh_pretty_with_id0  (mkStr : nat  -> string )  : sym := 
  let id := DAEMON tt in
  Symbol0 (digest0 tt) id (Some (mkStr id)).
(* [?]: removed value specification. *)

Definition fresh_fancy0   : option (string )  -> sym :=  
  fun (x : option (string ) ) =>
    match (x) with | Some str => fresh_pretty0 str | None => fresh0 tt end.
(* [?]: removed value specification. *)

Definition from_same_translation_unit0  (sym1 : sym ) (sym2 : sym )  : bool :=  Z.eqb(Coq.ZArith.BinIntDef.Z.of_nat 0) (digest_compare0 (digest_of_sym0 sym1) (digest_of_sym0 sym2)).
