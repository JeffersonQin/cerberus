(* Generated by Lem from ocaml_generated/symbol.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.
Require Import lem_show.
Require Export lem_show.
Require Import lem_show_extra.
Require Export lem_show_extra.
Require Import enum.
Require Export enum.

Require Import loc.
Require Export loc.
Require Import debug.
Require Export debug.

(* 

Inductive digest : Type := .
Definition digest_default: digest  := DAEMON. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Instance x131_Eq : Eq unit  := {
   isEqual   x  y :=  Z.eqb (fun _: unit _: unit => 0 x y)((Zpred (Zpos (P_of_succ_nat 0))));
   isInequal   x  y :=  negb (Z.eqb (fun _: unit _: unit => 0 x y)((Zpred (Zpos (P_of_succ_nat 0)))))
}.


Instance x130_Ord : Ord unit  := {
   compare   x  y := 
    let cmp := fun _: unit _: unit => 0 x y in
    if int_ltb cmp((Zpred (Zpos (P_of_succ_nat 0)))) then LT else if Z.eqb cmp((Zpred (Zpos (P_of_succ_nat 0)))) then EQ else GT;
   isLess   x  y :=  int_ltb
    (fun _: unit _: unit => 0 x y)((Zpred (Zpos (P_of_succ_nat 0))));
   isLessEqual   x  y :=  int_lteb
    (fun _: unit _: unit => 0 x y)((Zpred (Zpos (P_of_succ_nat 0))));
   isGreater   x  y :=  int_gtb
    (fun _: unit _: unit => 0 x y)((Zpred (Zpos (P_of_succ_nat 0))));
   isGreaterEqual   x  y :=  int_gteb
    (fun _: unit _: unit => 0 x y)((Zpred (Zpos (P_of_succ_nat 0))))
}.


Instance x129_Show : Show unit  := {
   show   d :=  fun _: tt => EmptyString d
}.



(* Symbolic identifiers *)
Inductive sym : Type := 
  Symbol0:  unit   ->  nat  ->  option  string   -> sym .
Definition sym_default: sym  := Symbol0 digest_default nat_default DAEMON.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition symbol_compare0  (s : sym ) (s0 : sym )  : ordering := 
  match ( (s,s0)) with (( Symbol0 d1 n1 _), ( Symbol0 d2 n2 _)) =>
    if Z.eqb (fun _: unit _: unit => 0 d1 d2)
         ((Zpred (Zpos (P_of_succ_nat 0)))) then
      (genericCompare nat_ltb beq_nat n1 n2) else
      let cmp := fun _: unit _: unit => 0 d1 d2 in
      if int_ltb cmp ((Zpred (Zpos (P_of_succ_nat 0)))) then LT else
        if Z.eqb cmp ((Zpred (Zpos (P_of_succ_nat 0)))) then EQ else GT end.

Instance x128_Eq : Eq sym := {
   isEqual             :=  (fun  sym1  sym2=>match ( (sym1, sym2)) with 
    | (Symbol0 d1 n1 str_opt1,  Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun  left  right=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun u =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun  s=> String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun  s=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end);
   isInequal   sym1  sym2 :=  negb (match ( (sym1, sym2)) with 
    | (Symbol0 d1 n1 str_opt1,  Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun  left  right=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun u =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun  s=> String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun  s=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end)
}.


Instance x127_Ord : Ord sym := {
   compare   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      if Z.eqb (fun _: unit _: unit => 0 d1 d2)
           ((Zpred (Zpos (P_of_succ_nat 0)))) then
        (genericCompare nat_ltb beq_nat n1 n2) else
        let cmp := fun _: unit _: unit => 0 d1 d2 in
        if int_ltb cmp ((Zpred (Zpos (P_of_succ_nat 0)))) then LT else
          if Z.eqb cmp ((Zpred (Zpos (P_of_succ_nat 0)))) then EQ else GT end
  end;
   isLess   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_ltb (fun _: unit _: unit => 0 d1 d2)
        ((Zpred (Zpos (P_of_succ_nat 0)))) ||
      ( Z.eqb (fun _: unit _: unit => 0 d1 d2)
          ((Zpred (Zpos (P_of_succ_nat 0)))) && nat_ltb n1 n2) end end;
   isLessEqual   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_lteb (fun _: unit _: unit => 0 d1 d2)
        ((Zpred (Zpos (P_of_succ_nat 0)))) ||
      ( Z.eqb (fun _: unit _: unit => 0 d1 d2)
          ((Zpred (Zpos (P_of_succ_nat 0)))) && nat_lteb n1 n2) end end;
   isGreater   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_gtb (fun _: unit _: unit => 0 d1 d2)
        ((Zpred (Zpos (P_of_succ_nat 0)))) ||
      ( Z.eqb (fun _: unit _: unit => 0 d1 d2)
          ((Zpred (Zpos (P_of_succ_nat 0)))) && nat_gtb n1 n2) end end;
   isGreaterEqual   sym1  sym2 :=  
  match ( sym1) with ( Symbol0 d1 n1 _) =>
    match ( sym2) with ( Symbol0 d2 n2 _) =>
      int_gteb (fun _: unit _: unit => 0 d1 d2)
        ((Zpred (Zpos (P_of_succ_nat 0)))) ||
      ( Z.eqb (fun _: unit _: unit => 0 d1 d2)
          ((Zpred (Zpos (P_of_succ_nat 0)))) && nat_gteb n1 n2) end end
}.


Instance x126_NumSucc : NumSucc sym := {
   succ   sym :=  match ( sym) with ( Symbol0 d n str_opt) =>
   Symbol0 d (Coq.Init.Peano.plus n ( 1)) str_opt end
}.


Instance x125_SetType : SetType sym := {
   setElemCompare   sym1  sym2 :=  ordCompare sym1 sym2
}.


Instance x124_Show : Show sym := {
   show   sym :=  match ( sym) with Symbol0 d n str_opt =>
   String.append "Symbol"
     (stringFromPair lem_string_extra.stringFromNat
        (fun  x_opt=>
           stringFromMaybe
             (fun  s=> String.append """" (String.append s """")) x_opt)
        (n, str_opt)) end
}.


Definition show_raw0  (s : sym )  : string := 
  match ( (s)) with (( Symbol0 d n str_opt)) =>
    String.append "Symbol("
      (String.append (fun _: tt => EmptyString d)
         (String.append ", "
            (String.append (lem_string_extra.stringFromNat n)
               (String.append ", "
                  (String.append
                     (stringFromMaybe
                        (fun (s : string )=>
                           String.append """" (String.append s """")) 
                      str_opt) ")"))))) end.


(* Location prefix *)
Inductive prefix : Type := 
  | PrefSource0:  unit  ->  list  sym  -> prefix 
  | PrefFunArg0:  unit  ->  unit   ->  Z  -> prefix 
  | PrefStringLiteral0:  unit  ->  unit   -> prefix 
  | PrefCompoundLiteral0:  unit  ->  unit   -> prefix 
  | PrefMalloc0: prefix 
  | PrefOther0:  string  -> prefix .
Definition prefix_default: prefix  := PrefSource0 unit_default DAEMON.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition digest_of_sym0  (s : sym )  : unit  := 
  match ( (s)) with (( Symbol0 dig _ _)) => dig end.
(* [?]: removed value specification. *)

Definition fresh0   tt  : sym := 
  Symbol0 (fun _: unit => tttt) (BOOM tt) None.
(* [?]: removed value specification. *)

Definition fresh_pretty0  (str : string )  : sym := 
  Symbol0 (fun _: unit => tttt) (BOOM tt) (Some str).
(* [?]: removed value specification. *)

Definition fresh_pretty_with_id0  (mkStr : nat  -> string )  : sym := 
  let id := BOOM tt in
  Symbol0 (fun _: unit => tttt) id (Some (mkStr id)).
(* [?]: removed value specification. *)

Definition fresh_fancy0   : option (string )  -> sym :=  
  fun (x : option (string ) ) =>
    match (x) with | Some str => fresh_pretty0 str | None => fresh0 tt end.
(* [?]: removed value specification. *)

Definition from_same_translation_unit0  (sym1 : sym ) (sym2 : sym )  : bool :=  Z.eqb((Zpred (Zpos (P_of_succ_nat 0)))) (fun _: unit _: unit => 0 (digest_of_sym0 sym1) (digest_of_sym0 sym2)).
