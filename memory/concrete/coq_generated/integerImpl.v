(* Generated by Lem from ocaml_generated/IntegerImpl.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.
Require Import range.
Require Export range.
Require Import ctype.
Require Export ctype.


Inductive binaryMode : Type := 
  | Two'sComplement: binaryMode 
  | One'sComplement: binaryMode 
  | SignPlusMagnitude: binaryMode .
Definition binaryMode_default: binaryMode  := Two'sComplement.
(* [?]: removed value specification. *)

Definition min_precision   : integerBaseType  -> nat :=  
  fun (x : integerBaseType ) =>
    match (x) with | Ichar =>  8 | Short =>  16 | Int_ =>  16 | Long => 
     32 | LongLong =>  64 (* TODO: check the following *) | IntN_t n => n
      | Int_leastN_t n => n | Int_fastN_t n => n | Intmax_t =>
       64 (* TODO: hack *) | Intptr_t =>  64 (* TODO: hack *) end.

Record implementation : Type := {
  impl_binary_mode: binaryMode ;
  impl_signed:      integerType  ->  bool ;
  impl_precision:   integerType  ->  nat ;
  impl_size_t:      integerType ;
  impl_ptrdiff_t:   integerType 
}.
Notation "{[ r 'with' 'impl_binary_mode' := e ]}" := ({| impl_binary_mode := e; impl_signed := impl_signed r; impl_precision := impl_precision r; impl_size_t := impl_size_t r; impl_ptrdiff_t := impl_ptrdiff_t r |}).
Notation "{[ r 'with' 'impl_signed' := e ]}" := ({| impl_signed := e; impl_binary_mode := impl_binary_mode r; impl_precision := impl_precision r; impl_size_t := impl_size_t r; impl_ptrdiff_t := impl_ptrdiff_t r |}).
Notation "{[ r 'with' 'impl_precision' := e ]}" := ({| impl_precision := e; impl_binary_mode := impl_binary_mode r; impl_signed := impl_signed r; impl_size_t := impl_size_t r; impl_ptrdiff_t := impl_ptrdiff_t r |}).
Notation "{[ r 'with' 'impl_size_t' := e ]}" := ({| impl_size_t := e; impl_binary_mode := impl_binary_mode r; impl_signed := impl_signed r; impl_precision := impl_precision r; impl_ptrdiff_t := impl_ptrdiff_t r |}).
Notation "{[ r 'with' 'impl_ptrdiff_t' := e ]}" := ({| impl_ptrdiff_t := e; impl_binary_mode := impl_binary_mode r; impl_signed := impl_signed r; impl_precision := impl_precision r; impl_size_t := impl_size_t r |}).
Definition implementation_default: implementation  := {| impl_binary_mode := binaryMode_default; impl_signed := (fun (x60 :       integerType ) => bool_default); impl_precision := (fun (x61 :    integerType ) => nat_default); impl_size_t := integerType_default; impl_ptrdiff_t := integerType_default |}.
(* [?]: removed value specification. *)

Definition make_implementation  (binary_mode : binaryMode ) (signed : integerType  -> bool ) (precision : integerType  -> nat ) (size_ity : integerType ) (ptrdiff_ity : integerType )  : implementation :=  {|impl_binary_mode:= binary_mode;impl_signed:=      signed;impl_precision:=   precision;impl_size_t:=      size_ity;impl_ptrdiff_t:=   ptrdiff_ity
|}.
(* [?]: removed value specification. *)

Definition integer_range  (P : implementation ) (ity : integerType )  : (Z *Z ) % type:= 
  let prec :=(impl_precision  P) ity in
  if(impl_signed  P) ity then
    match ((impl_binary_mode  P)) with 
    | Two'sComplement   => make_range ((Coq.ZArith.BinInt.Zminus Z0 ( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec)))
                                      ( Coq.ZArith.BinInt.Zminus( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec)(Coq.ZArith.BinIntDef.Z.of_nat 1))
    | One'sComplement   => make_range ( Coq.ZArith.BinInt.Zplus((Coq.ZArith.BinInt.Zminus Z0 (( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec))))(Coq.ZArith.BinIntDef.Z.of_nat 1))
                                      ( Coq.ZArith.BinInt.Zminus( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec)(Coq.ZArith.BinIntDef.Z.of_nat 1))
    | SignPlusMagnitude => make_range ( Coq.ZArith.BinInt.Zplus((Coq.ZArith.BinInt.Zminus Z0 (( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec))))(Coq.ZArith.BinIntDef.Z.of_nat 1))
                                      ( Coq.ZArith.BinInt.Zminus( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec)(Coq.ZArith.BinIntDef.Z.of_nat 1))
    end
  else
    make_range(Coq.ZArith.BinIntDef.Z.of_nat 0) ( Coq.ZArith.BinInt.Zminus( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec)(Coq.ZArith.BinIntDef.Z.of_nat 1)).
(* [?]: removed value specification. *)

Definition min_range_unsigned  (ibty : integerBaseType )  : (Z *Z ) % type:= 
  let prec := min_precision ibty in
  make_range(Coq.ZArith.BinIntDef.Z.of_nat 0) ( Coq.ZArith.BinInt.Zminus( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) prec)(Coq.ZArith.BinIntDef.Z.of_nat 1)).
(* [?]: removed value specification. *)

Definition min_range_signed  (ibty : integerBaseType )  : (Z *Z ) % type:= 
  let prec := (min_precision ibty) (* - 1 *) in
  make_range ( Coq.ZArith.BinInt.Zplus((Coq.ZArith.BinInt.Zminus Z0 ( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) ( Coq.Init.Peano.minus prec( 1)))))(Coq.ZArith.BinIntDef.Z.of_nat 1))
             ( Coq.ZArith.BinInt.Zminus( Coq.ZArith.Zpower.Zpower_nat(Coq.ZArith.BinIntDef.Z.of_nat 2) ( Coq.Init.Peano.minus prec( 1)))(Coq.ZArith.BinIntDef.Z.of_nat 1)).
(* [?]: removed value specification. *)

Definition min_integer_range   : integerType  -> (Z *Z ) % type:=  
  fun (x : integerType ) =>
    match (x) with | Char =>
      make_range (Coq.ZArith.BinIntDef.Z.of_nat 0)
        ( Coq.ZArith.BinInt.Zminus
            ( Coq.ZArith.Zpower.Zpower_nat (Coq.ZArith.BinIntDef.Z.of_nat 2)
                (Coq.Init.Peano.minus (min_precision Ichar) ( 1)))
            (Coq.ZArith.BinIntDef.Z.of_nat 1)) | Bool =>
      make_range (Coq.ZArith.BinIntDef.Z.of_nat 0)
        (Coq.ZArith.BinIntDef.Z.of_nat 1) | Unsigned ibty =>
      min_range_unsigned ibty | Signed ibty => min_range_signed ibty
    (* TODO: making an implementation choice here (see ÃÂ§6.7.2.3#4) *)
      | Enum _ => min_range_signed Int_ | Size_t => DAEMON | Wchar_t =>
      DAEMON | Wint_t => DAEMON | Ptrdiff_t => DAEMON end.
(* [?]: removed value specification. *)

Definition min_implementation_signed_char   : implementation := 
  make_implementation
    SignPlusMagnitude
    ( fun (x : integerType ) =>
   match (x) with | Char => true | Signed _ => true | Bool => false
     | Unsigned _ => false
   (* TODO: making an implementation choice here (see ÃÂ§6.7.2.3#4) *)
     | Enum _ => true | Size_t => DAEMON | Wchar_t => DAEMON | Wint_t =>
     DAEMON | Ptrdiff_t => DAEMON end
    )
    ( fun (x : integerType ) =>
   match (x) with | Char =>  7 | Bool =>  1 | Signed Ichar =>  7
     | Unsigned Ichar =>  8 | Signed Short =>  15 | Unsigned Short => 
    16 | Signed Int_ =>  15 | Unsigned Int_ =>  16 | Signed Long =>  31
     | Unsigned Long =>  32 | Signed LongLong =>  63 | Unsigned LongLong =>
      64 | Signed( IntN_t n) => Coq.Init.Peano.minus n ( 1)
     | Unsigned( IntN_t n) => n | Signed( Int_leastN_t _) => DAEMON
     | Unsigned( Int_leastN_t _) => DAEMON | Signed( Int_fastN_t n) => DAEMON
     | Unsigned( Int_fastN_t n) => DAEMON | Signed Intmax_t => DAEMON
     | Unsigned Intmax_t => DAEMON | Signed Intptr_t => DAEMON
     | Unsigned Intptr_t => DAEMON
   (* TODO: making an implementation choice here (see ÃÂ§6.7.2.3#4) *)
     | Enum _ =>  15 | Size_t => DAEMON | Wchar_t => DAEMON | Wint_t =>
     DAEMON | Ptrdiff_t => DAEMON end
    )
    (Unsigned Long)
    (Signed   Long).
(* [?]: removed value specification. *)

Definition min_implementation_unsigned_char   : implementation := 
  make_implementation
    SignPlusMagnitude
    ( fun (x : integerType ) =>
   match (x) with | Signed _ => true | Char => false | Bool => false
     | Unsigned _ => false
   (* TODO: making an implementation choice here (see ÃÂ§6.7.2.3#4) *)
     | Enum _ => true | Size_t => DAEMON | Wchar_t => DAEMON | Wint_t =>
     DAEMON | Ptrdiff_t => DAEMON end
    )
    ( fun (x : integerType ) =>
   match (x) with | Char =>  8 | Bool =>  1 | Signed Ichar =>  7
     | Unsigned Ichar =>  8 | Signed Short =>  15 | Unsigned Short => 
    16 | Signed Int_ =>  15 | Unsigned Int_ =>  16 | Signed Long =>  31
     | Unsigned Long =>  32 | Signed LongLong =>  63 | Unsigned LongLong =>
      64 | Signed( IntN_t n) => Coq.Init.Peano.minus n ( 1)
     | Unsigned( IntN_t n) => n | Signed( Int_leastN_t _) => DAEMON
     | Unsigned( Int_leastN_t _) => DAEMON | Signed( Int_fastN_t n) => DAEMON
     | Unsigned( Int_fastN_t n) => DAEMON | Signed Intmax_t => DAEMON
     | Unsigned Intmax_t => DAEMON | Signed Intptr_t => DAEMON
     | Unsigned Intptr_t => DAEMON
   (* TODO: making an implementation choice here (see ÃÂ§6.7.2.3#4) *)
     | Enum _ =>  15 | Size_t => DAEMON | Wchar_t => DAEMON | Wint_t =>
     DAEMON | Ptrdiff_t => DAEMON end
    )
    (Unsigned Long)
    (Signed   Long).

