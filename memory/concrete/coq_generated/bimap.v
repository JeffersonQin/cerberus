(* Generated by Lem from ocaml_generated/bimap.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.


(* type bimap 'a 'b =
 *   map 'a 'b * map 'b 'a
 * 
 * 
 * 
 * 
 * val lookupL:  forall 'a 'b. MapKeyType 'a, MapKeyType 'b => 'a -> bimap 'a 'b -> maybe 'b
 * let lookupL a (mapa, _) =
 *   Map.lookup a mapa
 * 
 * val lookupR:  forall 'a 'b. MapKeyType 'a, MapKeyType 'b => 'b -> bimap 'a 'b -> maybe 'a
 * let lookupR b (_, mapb) =
 *   Map.lookup b mapb
 * 
 * 
 * val fromList: forall 'a 'b. MapKeyType 'a, MapKeyType 'b => list ('a * 'b) -> bimap 'a 'b
 * let rec fromList_aux ((mapa, mapb) as acc) xs =
 *   match xs with
 *   | [] ->
 *       acc
 *   | (a, b) :: xs ->
 *       fromList_aux ((Map.insert a b mapa), (Map.insert b a mapb)) xs
 *   end
 * 
 * let fromList =
 *   fromList_aux (Map.empty, Map.empty) *)





Definition bimap_list  (a: Type) (b: Type) : Type :=  list  ((a * b) % type).
Definition bimap_list_default {a: Type} {b: Type} : bimap_list a b := DAEMON.
Definition bimap  (a: Type) (b: Type) : Type :=  list  ((a * b) % type).
Definition bimap_default {a: Type} {b: Type} : bimap a b := DAEMON.
(* [?]: removed value specification. *)

Definition lookupL {a b : Type} `{Eq a}  (a1 : a) (l : list ((a*b) % type))  : option b :=  (lookupBy (fun x y => x = y) a1 l).


Program Fixpoint lookupR_aux {a b : Type} `{Eq b}  (b1 : b) (l : list ((a*b) % type))  : option a :=  
  match ( l) with 
  | [] => None
  | (a', b')::l' => if b1 = b' then Some a' else lookupR_aux b1 l'
  end.
(* [?]: removed value specification. *)

Definition lookupR {a b : Type} `{Eq b}  (b1 : b) (l : list ((a*b) % type))  : option a :=  lookupR_aux b1 l.
(* [?]: removed value specification. *)

Definition fromList0 {a b : Type} `{Eq a} `{Eq b}   : list ((a*b) % type) -> list ((a*b) % type):=  (fun (x : list ((a*b) % type))=>x).
