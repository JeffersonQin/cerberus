(* Generated by Lem from ocaml_generated/ErrorMonad.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import typingError.
Require Export typingError.
Require Import utils.
Require Export utils.

Require Import loc.
Require Export loc.
Require Import exception.
Require Export exception.


(* NOTE: most of the inlines are only added to prevent Lem's renaming *)

Definition annots : Type :=  list  (list  string ).
Definition annots_default: annots  := DAEMON.

Inductive errorM (a : Type) : Type := 
  ErrorM:  (annots  ->  sum  ((unit  * typing_error ) % type)  ((a * annots ) % type)) -> errorM a.
Definition errorM_default{a: Type} : errorM a := ErrorM (fun (x47 : annots ) => DAEMON).
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition add  (a : string )  : errorM (unit ):=  ErrorM (fun (ts : list (list (string ))) =>
    match ( ts) with 
    | [] => inr (tt, [[a]])
    | q::qs => inr (tt, ((a::q)::qs))
    end).
(* [?]: removed value specification. *)

Definition pack   : errorM (unit ):=  ErrorM (fun (ts : list (list (string ))) => inr (tt, ([]::ts))).
(* [?]: removed value specification. *)

Definition unpack   : errorM (list (string )):=  ErrorM (fun (ts : list (list (string ))) =>
  match ( ts) with 
    | [] => inr ([], [])
    | q::qs => inr (q, qs)
  end).
(* [?]: removed value specification. *)

Definition run {a : Type}  (e : errorM a) (ts : list (list (string )))  : sum ((unit *typing_error ) % type) ((a*annots ) % type):= 
  match ( (e,ts)) with (( ErrorM m),  ts) => m ts end.
(* [?]: removed value specification. *)

Definition bind1 {a b : Type}  (e : errorM a) (f : a -> errorM b)  : errorM b:= 
  match ( (e,f)) with (( ErrorM m),  f) =>
    ErrorM
      (fun (ts : list (list (string ))) =>
         match ( m ts) with | inl l => inl l | inr (a1,  ts') =>
           run (f a1) ts' end) end.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition tryM {a b : Type}  (e : errorM a) (f : a -> errorM b) (errCase : errorM b)  : errorM b:= 
  match ( (e,f,errCase)) with (( ErrorM m),  f,  errCase) =>
    ErrorM
      (fun (ts : list (list (string ))) =>
         match ( m ts) with | inl _ => run errCase ts | inr (a1,  ts') =>
           run (f a1) ts' end) end.
(* [?]: removed value specification. *)

Definition runErrorMonad {a : Type}  (m : errorM a)  : sum ((unit *typing_error ) % type) a:= 
  match ( run m []) with 
    | inl l => inl l
    | inr (r,  _) => inr r
  end.
(* [?]: removed value specification. *)

Definition to_exception {a msg : Type}  (f : (unit *typing_error ) % type -> msg) (m : errorM a)  : exception.exceptM ((a*list (list (string ))) % type) msg:= 
  match ( run m []) with 
    | inl loc_err => exception.Exception (f loc_err)
    | inr (z,  annots1) => exception.Result (z, annots1)
  end.
(* [?]: removed value specification. *)

Program Fixpoint ailErr_mapM {a b : Type}  (f : a -> errorM b) (ys : list a)  : errorM (list b):= 
  match ( ys) with 
  | []      => ErrorM (fun (ts : list (list (string ))) => inr ([], ts))
  |( x::xs) =>       bind1 (f x) (fun (z : b)  => bind1 (ailErr_mapM f xs) (fun (zs : list b) =>
               ErrorM (fun (ts : list (list (string ))) => inr ((z::zs), ts))))
end.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)
 (* GENERIC Monad *)
Program Fixpoint ailErr_foldM {a b : Type}  (f : a -> b -> errorM a) (a1 : a)  : list b -> errorM a:=  
  fun (x : list b) =>
    match (x) with (* GENERIC Monad *) | [] =>
      (* GENERIC Monad *) ErrorM
        (fun (ts : list (list (string ))) => inr (a1, ts)) (* GENERIC Monad *)
      | x::xs =>
      bind1 ( (* GENERIC Monad *) f a1 x)
        (fun (fax : a) => ailErr_foldM f fax xs) (* GENERIC Monad *) end.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
