(* Generated by Lem from ocaml_generated/state_exception.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.

Require Import exception.
Require Export exception.


(* HACK: most of the inlines are only added to prevent Lem's renaming *)


Definition stExceptM  (a: Type) (st: Type) (msg: Type) : Type := 
  st ->  exception.exceptM  ((a * st) % type)  msg.
Definition stExceptM_default {a: Type} {st: Type} {msg: Type} : stExceptM a st msg := (fun (x119 : 
  st) => DAEMON).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)


Definition stExpect_return {a msg s : Type}  (a1 : a)  : s -> exception.exceptM ((a*s) % type) msg:= 
  fun (s1 : s) => exception.except_return (a1, s1).

Definition stExpect_bind {a b msg s : Type}  (m : s -> exception.exceptM ((a*s) % type) msg) (f : a -> s -> exception.exceptM ((b*s) % type) msg)  : s -> exception.exceptM ((b*s) % type) msg:=  fun (s1 : s) =>
  exception.except_bind (m s1) (
  fun (p : (a*s) % type) => match ( (p) ) with ( (a1,  s')) => (f a1) s' end).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(*
TODO: UNUSED
val papp: forall 'a 'b 's 'msg. stExceptM ('a -> 'b) 's 'msg -> 'a -> stExceptM 'b 's 'msg
let papp mf x = bind mf (fun f -> return (f x))
*)

Module Operators.  
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
End Operators.

Require Import operators.
Require Export operators.

(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition stExpect_mapM {a b msg s : Type}  (f : a -> s -> exception.exceptM ((b*s) % type) msg)  : list a -> s -> exception.exceptM ((list b*s) % type) msg:=  (fun (xs : list a)=>List.fold_right
    (fun (m : s -> exception.exceptM ((b*s) % type) msg) (m' : s -> exception.exceptM ((list b*s) % type) msg) =>  stExpect_bind
      m (fun (x : b)  => stExpect_bind
      m' (fun (xs : list b) =>
      stExpect_return (x::xs)))
    ) (stExpect_return []) ((List.map f) xs)).
(* [?]: removed value specification. *)

Definition mapiM {a b msg s : Type}  (f : nat  -> a -> s -> exception.exceptM ((b*s) % type) msg)  : list a -> s -> exception.exceptM ((list b*s) % type) msg:=  (fun (xs : list a)=>List.fold_right
    (fun (m : s -> exception.exceptM ((b*s) % type) msg) (m' : s -> exception.exceptM ((list b*s) % type) msg) =>  stExpect_bind
      m (fun (x : b)  => stExpect_bind
      m' (fun (xs : list b) =>
      stExpect_return (x::xs)))
    ) (stExpect_return []) ((lem_list.mapi f) xs)).
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Program Fixpoint stExcept_foldlM {a b msg s : Type}  (f : a -> b -> s -> exception.exceptM ((a*s) % type) msg) (a1 : a)  : list b -> s -> exception.exceptM ((a*s) % type) msg:=  
  fun (x : list b) =>
    match (x) with | [] => stExpect_return a1 | b1::bs =>
      stExpect_bind (f a1 b1) (fun (a' : a) => stExcept_foldlM f a' bs) end.
(* [?]: removed value specification. *)

Program Fixpoint foldrM {a b msg s : Type}  (f : a -> b -> stExceptM b s msg) (a1 : b)  : list a -> s -> exception.exceptM ((b*s) % type) msg:=  
  fun (x : list a) =>
    match (x) with | [] => stExpect_return a1 | x::xs =>
      stExpect_bind (foldrM f a1 xs) (f x) end.
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)

Definition of_option {a b c : Type}  (msg : b)  : option a  -> c -> exception.exceptM ((a*c) % type) b:=  
  fun (x : option a ) =>
    match (x) with | Some a1 => stExpect_return a1 | None =>
      fun ( _ : c) => exception.fail0 msg end.

Definition option0 {a b c : Type}  (msg : a) (m : b -> exception.exceptM ((option c *b) % type) a)  : b -> exception.exceptM ((c*b) % type) a:= 
  let f  := (fun (o : option c ) =>
    match ( o) with 
      | Some a1  => stExpect_return a1
      | None => fun ( _ : b) => exception.fail0 msg
    end) in
  stExpect_bind m f.
(* [?]: removed value specification. *)

Definition tryWith {a msg s : Type}  (msg1 : msg) (m : s -> exception.exceptM ((a*s) % type) msg)  : s -> exception.exceptM ((a*s) % type) msg:= 
  fun (st : s) =>
    exception.bind_exception (m st) (fun ( _ : msg) => exception.fail0 msg1).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition state_except_read {a b c : Type}  (f : a -> b)  : a -> exception.exceptM ((b*a) % type) c:=  fun (s : a) => exception.except_return (f s, s).
Definition state_except_update {a b c : Type}  (f : a -> b)  : a -> exception.exceptM ((unit *b) % type) c:=  fun (s : a) => exception.except_return (tt, f s).
Definition state_except_modify {a b c : Type}  (f : a -> b)  : a -> exception.exceptM b c:=  fun (s : a) => exception.except_return (f s).
Definition state_except_eval {a b c d : Type}  (m : a -> exception.exceptM ((c*b) % type) d)  : a -> exception.exceptM c d:=  fun (s : a) => exception.except_fmap (@ fst _ _) (m s).
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition state_except_get {a b : Type}   : a -> exception.exceptM ((a*a) % type) b:=  fun (st : a) => exception.except_return (st, st).
Definition state_except_put {a b c : Type}  (st : a)  : c -> exception.exceptM ((unit *a) % type) b:=  fun ( _ : c) => exception.except_return (tt, st).
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition state_except_run {a b : Type}  (m : a -> b)  : a -> b:=  fun (st : a) => m st.
(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition liftException {a msg state : Type}  (m : exception.exceptM a msg)  : state -> exception.exceptM ((a*state) % type) msg:= 
  fun (st : state) => exception.except_fmap (fun (z : a) => (z, st)) m.
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
(* [?]: removed top-level value definition. *)
