(* Generated by Lem from ocaml_generated/cmm_csem.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(*========================================================================*)
(*                                                                        *)
(*             cppmem model exploration tool                              *)
(*                                                                        *)
(*                    Mark Batty                                          *)
(*                    Scott Owens                                         *)
(*                    Jean Pichon                                         *)
(*                    Susmit Sarkar                                       *)
(*                    Peter Sewell                                        *)
(*                                                                        *)
(*  This file is copyright 2011, 2012 by the above authors.               *)
(*                                                                        *)
(*  Redistribution and use in source and binary forms, with or without    *)
(*  modification, are permitted provided that the following conditions    *)
(*  are met:                                                              *)
(*  1. Redistributions of source code must retain the above copyright     *)
(*  notice, this list of conditions and the following disclaimer.         *)
(*  2. Redistributions in binary form must reproduce the above copyright  *)
(*  notice, this list of conditions and the following disclaimer in the   *)
(*  documentation and/or other materials provided with the distribution.  *)
(*  3. The names of the authors may not be used to endorse or promote     *)
(*  products derived from this software without specific prior written    *)
(*  permission.                                                           *)
(*                                                                        *)
(*  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS    *)
(*  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED     *)
(*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    *)
(*  ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY       *)
(*  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    *)
(*  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE     *)
(*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS         *)
(*  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHE   *)
(*  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR       *)
(*  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN   *)
(*  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                         *)
(*========================================================================*)

(* emacs fontification -*-caml-*- *)

(*

Log:

20/03/13 - a savage and hasty tidy, following r10282

--- Introduction ---

This file contains a mathematical version of the relaxed memory model
of C11 and C++11, written in the specification language of Lem. Lem
can compile it to Ocaml, HOL, Isabelle or Latex. The basic model is
faithful to the intent of the 2011 standard and included here in
full. In addition, there are several simplified models that either remove
redundant concepts or provide simplifications for programs that
restrict the input language of programs.

There are lots of definitions that make up the models. To help you
navigate them, the following table of contents (with unique key
phrases) can be used to search the document. Where appropriate, there
are comments describing or explaining the definitions. These are
especially important for the top-level definitions of the simplified models.

--- Contents ---


1 - Relational definitions

2 - Type definitions and projections

  - 2.1 - Action and location types

  - 2.2 - Execution records

  - 2.3 - Projection functions 

  - 2.4 - Location kinds

  - 2.5  - Well formed action

  - 2.6  - Well formed threads

3 - Memory_Model simplified, single thread, no atomics

4 - Memory_Model simplified, multi-thread, no atomics, yes locks

5 - relaxed - memory_model simplified for programs without sc,
consumes, release or acquire

6 - release acquire - memory_model simplified for programs without sc,
consumes or relaxed

7 - release_acquire_relaxed - memory_model simplified for programs without sc,
consumes or relaxed

8 - release_acquire_fenced

9 - sc, no sc fences

10 - sc_fences, no consume

11 - with consume

12 - the standard model

13 - release acquire SC - for programs without consumes or relaxed

14 - SC - for programs without release, acquire, consumes or relaxed

15 - tot - sequential consistency

16 - Meta-theory

17 - release acquire, no locks - memory_model simplified for programs without sc,
consumes, relaxed or locks

18 - (not much there)

19 - overlap

*)

Require Import lem_show.
Require Export lem_show.
Require Import lem_show_extra.
Require Export lem_show_extra.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import lem_relation.
Require Export lem_relation.
Require Import lem_set.
Require Export lem_set.


(* for reference, this actually uses the following parts of Pervasives *)
(*
open import Basic_classes
open import Bool
(*open import Tuple*)
open import Maybe
(*open import Either*)
(*open import Function*)
open import Num
(*open import Map*)
open import Set
open import List
(*open import String*)
(*open import Word*)
(*open import Sorting*)
open import Relation
*)
Require Import cmm_aux.
Require Export cmm_aux.






(*************************************************** *)
(* 1 - Relational definitions *)
(*************************************************** *)

Definition relation_over {a : Type} `{SetType a}  (s : set a) (rel1 : set ((a*a) % type))  : bool :=  relOver rel1 s.

Definition inj_on {a b : Type} `{Eq a} `{Eq b}  (f : a -> b) (A : set a)  : bool :=  (set_for_all  
  (fun (x : a) =>
     (set_for_all (fun (y : a) => ((negb (f x = f y)) || (x = y))) A)) A).

Definition strict_total_order_over {a : Type} `{Eq a} `{SetType a}  (s : set a) (ord : set ((a*a) % type))  : bool := 
    relation_over s ord && isTotalOrderOn ord s.

Definition adjacent_less_than {a : Type} `{SetType a}  (ord : set ((a*a) % type)) (s : set a) (x : a) (y : a)  : bool :=  (set_member_by (pairCompare setElemCompare setElemCompare)
    (x,y) ord) && negb (set_any  
  (fun (z : a) =>
     (set_member_by (pairCompare setElemCompare setElemCompare) (x,z) ord) &&
     (set_member_by (pairCompare setElemCompare setElemCompare) (z,y) ord)) s).
    
Definition adjacent_less_than_such_that {a : Type} `{SetType a}  (pred : a -> bool ) (ord : set ((a*a) % type)) (s : set a) (x : a) (y : a)  : bool := 
    pred x && ((set_member_by (pairCompare setElemCompare setElemCompare) (x,y) ord) && negb (set_any  
  (fun (z : a) =>
     pred z &&
     ((set_member_by (pairCompare setElemCompare setElemCompare) (x,z) ord)
      &&
      (set_member_by (pairCompare setElemCompare setElemCompare) (z,y) ord))) s)).
(* [?]: removed value specification. *)

Definition finite_prefixes {a : Type} `{SetType a} `{Eq a}  (r : set ((a*a) % type)) (s : set a)  : bool :=  true.
(* [?]: removed value specification. *)

Definition minimal_elements {a : Type}  (s : set a) (r : set ((a*a) % type))  : set a:=  s.




(*************************************************** *)
(* 2 - Type definitions and projections *)
(*************************************************** *)


(*************************************************** *)
(* - 2.1 - Action and location types *)
(*************************************************** *)


(**** Cppmem base types ****)

Definition aid : Type :=  aid_impl .
Definition aid_default: aid  := aid_impl_default.
Definition program : Type :=  program_impl .
Definition program_default: program  := program_impl_default.
Definition tid : Type :=  tid_impl .
Definition tid_default: tid  := tid_impl_default.
Definition location : Type :=  location_impl .
Definition location_default: location  := location_impl_default.
Definition cvalue : Type :=  cvalue_impl .
Definition cvalue_default: cvalue  := cvalue_impl_default.


Inductive memory_order : Type := 
  | NA: memory_order 
  | Seq_cst: memory_order 
  | Relaxed: memory_order 
  | Release: memory_order 
  | Acquire: memory_order 
  | Consume: memory_order 
  | Acq_rel: memory_order .
Definition memory_order_default: memory_order  := NA.

Instance x101_Eq : Eq memory_order := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.


Instance x100_SetType : SetType memory_order := {
   setElemCompare  :=  (fun  x  y=>EQ)
}.


Instance x99_Show : Show memory_order := {
   show   mo := 
    match ( mo) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end
}.


Inductive lock_outcome : Type := 
    Locked: lock_outcome 
  | Blocked: lock_outcome .
Definition lock_outcome_default: lock_outcome  := Locked.

Instance x98_Eq : Eq lock_outcome := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.


Instance x97_SetType : SetType lock_outcome := {
   setElemCompare  :=  (fun  x  y=>EQ)
}.


Instance x96_Show : Show lock_outcome := {
   show   lo := 
    match ( lo) with 
    | Locked  => "Locked"
    | Blocked => "Blocked"
    end
}.


Inductive action : Type := 
  | Lock:  aid  ->  tid  ->  location  ->  lock_outcome  -> action 
  | Unlock:  aid  ->  tid  ->  location  -> action 
  | Load:  aid  ->  tid  ->  memory_order  ->  location  ->  cvalue  -> action 
  | Store:  aid  ->  tid  ->  memory_order  ->  location  ->  cvalue  -> action 
  | RMW:  aid  ->  tid  ->  memory_order  ->  location  ->  cvalue  ->  cvalue  -> action 
  | Fence:  aid  ->  tid  ->  memory_order  -> action 
  | Blocked_rmw:  aid  ->  tid  ->  location  -> action 
  | Alloc:  aid  ->  tid  ->  location  -> action    (* CSEM *)
  | Dealloc:  aid  ->  tid  ->  location  -> action .
Definition action_default: action  := Lock aid_default tid_default location_default lock_outcome_default. (* CSEM *)

Definition aid_of  (a : action )  : nat := 
    match ( a) with 
    | Lock aid1 _ _ _            => aid1
    | Unlock aid1 _ _            => aid1
    | Load aid1 _ _ _ _          => aid1
    | Store aid1 _ _ _ _         => aid1
    | RMW aid1 _ _ _ _ _         => aid1
    | Fence aid1 _ _             => aid1
    | Blocked_rmw aid1 _ _       => aid1
    | Alloc aid1 _ _             => aid1 (* CSEM *)
    | Dealloc aid1 _ _           => aid1 (* CSEM *)
    end.
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)

Instance x95_Eq : Eq action := {                              (* CSEM *)
   isEqual   :=  (fun  a1  a2=>classical_boolean_equivalence a1 a2);                      (* CSEM *)
   isInequal  :=  fun  x  y => negb (classical_boolean_equivalence x y)
}. (* CSEM *)
                                               (* CSEM *)

Instance x94_SetType : SetType action := {                                        (* CSEM *)
   setElemCompare   x  y :=  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))
}.  (* CSEM *)
                                                              (* CSEM *)



Instance x93_Show : Show action := {
   show   a := 
    match ( a) with 
    | Lock aid1 tid1 loc lock        => 
      String.append"Lock (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  
      (String.append"TODO"  (String.append", "  (String.appendmatch ( lock) with 
    | Locked  => "Locked"
    | Blocked => "Blocked"
    end ")")))))))
    | Unlock aid1 tid1 loc           => 
      String.append"Unlock (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  
      (String.append"TODO" ")")))))
    | Load aid1 tid1 mo1 loc val1     => 
      String.append"Load (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val: "  (String.append"TODO" ")")))))))))
    | Store aid1 tid1 mo1 loc val1    => 
      String.append"Store (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val: "  (String.append"TODO" ")")))))))))
    | RMW aid1 tid1 mo1 loc val1 val2 => 
      String.append"RMW (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val1: "  (String.append"TODO"  (String.append", val2: "  (String.append"TODO" ")")))))))))))
    | Fence aid1 tid1 mo1             => 
      String.append"Fence (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end ")")))))
    | Blocked_rmw aid1 tid1 loc      => 
      String.append"Blocked_rmw (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")")))))
    | Alloc aid1 tid1 loc            =>                                                  (* CSEM *)
      String.append"Alloc (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")")))))   (* CSEM *)
    | Dealloc aid1 tid1 loc          =>                                                  (* CSEM *)
      String.append"Dealloc (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")"))))) (* CSEM *)
    end
}.




(*********************************************** *)
(*  - 2.2 - Execution records *)
(*********************************************** *)

Inductive location_kind : Type := 
    Mutex: location_kind 
  | Non_Atomic: location_kind 
  | Atomic0: location_kind .
Definition location_kind_default: location_kind  := Mutex.

Instance x92_Eq : Eq location_kind := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.


Instance x91_SetType : SetType location_kind := {
   setElemCompare  :=  (fun  x  y=>EQ)
}.


Instance x90_Show : Show location_kind := {
   show   loc :=  
    match ( loc) with 
    | Mutex      => "Mutex"
    | Non_Atomic => "Non_Atomic"
    | Atomic0     => "Atomic"
    end
}.    


Record pre_execution : Type :=
  {  actions : set  (action );
      threads : set  (tid );
      lk      : location  ->  location_kind ;
      sb      : set  ((action  * action ) % type) ;
      asw     : set  ((action  * action ) % type) ;
      dd      : set  ((action  * action ) % type)
  }.
Notation "{[ r 'with' 'actions' := e ]}" := ({| actions := e; threads := threads r; lk := lk r; sb := sb r; asw := asw r; dd := dd r |}).
Notation "{[ r 'with' 'threads' := e ]}" := ({| threads := e; actions := actions r; lk := lk r; sb := sb r; asw := asw r; dd := dd r |}).
Notation "{[ r 'with' 'lk' := e ]}" := ({| lk := e; actions := actions r; threads := threads r; sb := sb r; asw := asw r; dd := dd r |}).
Notation "{[ r 'with' 'sb' := e ]}" := ({| sb := e; actions := actions r; threads := threads r; lk := lk r; asw := asw r; dd := dd r |}).
Notation "{[ r 'with' 'asw' := e ]}" := ({| asw := e; actions := actions r; threads := threads r; lk := lk r; sb := sb r; dd := dd r |}).
Notation "{[ r 'with' 'dd' := e ]}" := ({| dd := e; actions := actions r; threads := threads r; lk := lk r; sb := sb r; asw := asw r |}).
Definition pre_execution_default: pre_execution  := {| actions := DAEMON; threads := DAEMON; lk := (fun (x89 :  location ) => location_kind_default); sb := DAEMON; asw := DAEMON; dd := DAEMON |}.
(* [?]: removed value specification. *)

Definition action_rel_tostring  (rel1 : set ((action *action ) % type))  : string := 
  let aid_of_rel := lem_set.map (
  fun (p : (action *action ) % type) =>
    match ( (p) ) with ( (a,  b)) => (aid_of a, aid_of b) end) rel1 in
  lem_show_extra.stringFromRelation (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) aid_of_rel.
(* [?]: removed value specification. *)

Definition aid_of_rel2  (s : set ((action *action ) % type))  : set ((nat *nat ) % type):= 
  lem_set.map (fun (p : (action *action ) % type) =>
  match ( (p) ) with ( (a,  b)) => (aid_of a, aid_of b) end) s.

Instance x88_Show : Show pre_execution := {
   show   pre :=  
    String.append"actions: "  (String.append(stringFromSet (fun  a=>match ( a) with 
    | Lock aid1 tid1 loc lock        => 
      String.append"Lock (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  
      (String.append"TODO"  (String.append", "  (String.appendmatch ( lock) with 
    | Locked  => "Locked"
    | Blocked => "Blocked"
    end ")")))))))
    | Unlock aid1 tid1 loc           => 
      String.append"Unlock (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  
      (String.append"TODO" ")")))))
    | Load aid1 tid1 mo1 loc val1     => 
      String.append"Load (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val: "  (String.append"TODO" ")")))))))))
    | Store aid1 tid1 mo1 loc val1    => 
      String.append"Store (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val: "  (String.append"TODO" ")")))))))))
    | RMW aid1 tid1 mo1 loc val1 val2 => 
      String.append"RMW (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  
      (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end  (String.append", loc: "  (String.append"TODO"  (String.append", val1: "  (String.append"TODO"  (String.append", val2: "  (String.append"TODO" ")")))))))))))
    | Fence aid1 tid1 mo1             => 
      String.append"Fence (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", mo: "  (String.appendmatch ( mo1) with 
    | NA      => "NA"
    | Seq_cst => "Seq_cst"
    | Relaxed => "Relaxed"
    | Release => "Release"
    | Acquire => "Acquire"
    | Consume => "Consume"
    | Acq_rel => "Acq_rel"
    end ")")))))
    | Blocked_rmw aid1 tid1 loc      => 
      String.append"Blocked_rmw (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")")))))
    | Alloc aid1 tid1 loc            =>                                                  (* CSEM *)
      String.append"Alloc (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")")))))   (* CSEM *)
    | Dealloc aid1 tid1 loc          =>                                                  (* CSEM *)
      String.append"Dealloc (aid: "  (String.append(lem_string_extra.stringFromNat aid1)  (String.append", tid: "  (String.append(lem_string_extra.stringFromNat tid1)  (String.append", loc: "  (String.append"TODO" ")"))))) (* CSEM *)
    end)(actions  pre))  
    (String.append", threads: "  (String.append(stringFromSet lem_string_extra.stringFromNat(threads  pre)) 
    (String.append", lk: "  (String.append"?" 
    (String.append", sb: "  (String.append(action_rel_tostring(sb  pre)) 
    (String.append", asw: "  (String.append(action_rel_tostring(asw  pre))  
    (String.append", dd: " (action_rel_tostring(dd  pre))))))))))))
}.


(* this is wrong by design: we can't write a compare function for lk *)
Definition pre_execution_setElemCompare  (cmpa : set (action ) -> set (action ) -> ordering ) (cmpb : set (tid ) -> set (tid ) -> ordering ) (cmpc : set ((action *action ) % type) -> set ((action *action ) % type) -> ordering ) (x : pre_execution ) (y : pre_execution )  : ordering := 
  pairCompare
    cmpa
    (pairCompare
       cmpb
       (pairCompare
          cmpc
          (pairCompare
             cmpc
             cmpc)))
    ((actions x), ((threads x), ((sb x), ((asw x),(dd  x)))))
    ((actions y), ((threads y), ((sb y), ((asw y),(dd  y))))).
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)              (* CSEM *)

Instance x87_Eq : Eq pre_execution := {                                       (* CSEM *)
   isEqual   :=  (fun  pre1  pre2=>classical_boolean_equivalence pre1 pre2);                                  (* CSEM *)
   isInequal  :=  fun  pre1  pre2 => negb (classical_boolean_equivalence pre1 pre2)
}. (* CSEM *)
                                                               (* CSEM *)

Instance x86_SetType : SetType pre_execution := {      (* CSEM *)
   setElemCompare  :=  (fun  x  y=>EQ)
}. (* CSEM *)
                                   (* CSEM *)


Inductive order_kind : Type := 
     Global_order: order_kind 
   | Per_location_order: order_kind .
Definition order_kind_default: order_kind  := Global_order.

Record relation_usage_flags : Type :=
  {  rf_flag  : bool ;
      mo_flag  : bool ;
      sc_flag  : bool ;
      lo_flag  : bool ;
      tot_flag : bool   }.
Notation "{[ r 'with' 'rf_flag' := e ]}" := ({| rf_flag := e; mo_flag := mo_flag r; sc_flag := sc_flag r; lo_flag := lo_flag r; tot_flag := tot_flag r |}).
Notation "{[ r 'with' 'mo_flag' := e ]}" := ({| mo_flag := e; rf_flag := rf_flag r; sc_flag := sc_flag r; lo_flag := lo_flag r; tot_flag := tot_flag r |}).
Notation "{[ r 'with' 'sc_flag' := e ]}" := ({| sc_flag := e; rf_flag := rf_flag r; mo_flag := mo_flag r; lo_flag := lo_flag r; tot_flag := tot_flag r |}).
Notation "{[ r 'with' 'lo_flag' := e ]}" := ({| lo_flag := e; rf_flag := rf_flag r; mo_flag := mo_flag r; sc_flag := sc_flag r; tot_flag := tot_flag r |}).
Notation "{[ r 'with' 'tot_flag' := e ]}" := ({| tot_flag := e; rf_flag := rf_flag r; mo_flag := mo_flag r; sc_flag := sc_flag r; lo_flag := lo_flag r |}).
Definition relation_usage_flags_default: relation_usage_flags  := {| rf_flag := bool_default; mo_flag := bool_default; sc_flag := bool_default; lo_flag := bool_default; tot_flag := bool_default |}.

Record execution_witness : Type :=
  {  rf      : set  ((action  * action ) % type);
      mo      : set  ((action  * action ) % type);
      sc      : set  ((action  * action ) % type);
      lo      : set  ((action  * action ) % type);
      tot     : set  ((action  * action ) % type)
 }.
Notation "{[ r 'with' 'rf' := e ]}" := ({| rf := e; mo := mo r; sc := sc r; lo := lo r; tot := tot r |}).
Notation "{[ r 'with' 'mo' := e ]}" := ({| mo := e; rf := rf r; sc := sc r; lo := lo r; tot := tot r |}).
Notation "{[ r 'with' 'sc' := e ]}" := ({| sc := e; rf := rf r; mo := mo r; lo := lo r; tot := tot r |}).
Notation "{[ r 'with' 'lo' := e ]}" := ({| lo := e; rf := rf r; mo := mo r; sc := sc r; tot := tot r |}).
Notation "{[ r 'with' 'tot' := e ]}" := ({| tot := e; rf := rf r; mo := mo r; sc := sc r; lo := lo r |}).
Definition execution_witness_default: execution_witness  := {| rf := DAEMON; mo := DAEMON; sc := DAEMON; lo := DAEMON; tot := DAEMON |}.

Instance x85_Show : Show execution_witness := {
   show   wit :=     
    String.append"rf: "  (String.append(action_rel_tostring(rf  wit))   
    (String.append", mo: "  (String.append(action_rel_tostring(mo  wit))   
    (String.append", sc: "  (String.append(action_rel_tostring(sc  wit))   
    (String.append", lo: "  (String.append(action_rel_tostring(lo  wit))  
    (String.append", tot: " (action_rel_tostring(tot  wit))))))))))
}.


Definition execution_witness_setElemCompare  (cmp : set ((action *action ) % type) -> set ((action *action ) % type) -> ordering ) (x : execution_witness ) (y : execution_witness )  : ordering := 
  pairCompare
    cmp
    (pairCompare
       cmp
       (pairCompare
          cmp
          (pairCompare
             cmp
             cmp)))
    ((rf x), ((mo x), ((sc x), ((lo x),(tot  x)))))
    ((rf y), ((mo y), ((sc y), ((lo y),(tot  y))))).

Instance x84_SetType : SetType execution_witness := {  (* CSEM *) (* WIP *)
   setElemCompare  :=  (fun  x  y=>EQ)
}. (* CSEM *)

(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)                  (* CSEM *)

Instance x83_Eq : Eq execution_witness := {                        (* CSEM *)
   isEqual  :=  (fun  wit1  wit2=>classical_boolean_equivalence wit1 wit2);                    (* CSEM *)
   isInequal   w1  w2 :=  negb (classical_boolean_equivalence w1 w2)
}. (* CSEM *)
 
(* [?]: removed value specification. *)

Definition empty_witness   : execution_witness :=  
  {|rf := [];mo := [];sc := [];lo := [];tot := []
  |}.

Definition relation_list : Type :=  list  ((string  * set  ((action  * action ) % type)) % type).
Definition relation_list_default: relation_list  := DAEMON.
(* [?]: removed value specification. *)

Definition relation_list_tostring  (l : list ((string *set ((action *action ) % type)) % type))  : string :=  
  stringFromList (stringFromPair (fun (s : string )=> String.append""""  (String.append s """")) action_rel_tostring) l. 

Definition candidate_execution : Type :=  ((pre_execution  * execution_witness  * relation_list ) % type).
Definition candidate_execution_default: candidate_execution  := (pre_execution_default, execution_witness_default, relation_list_default).
(* [?]: removed value specification. *)

Definition candidate_execution_tostring  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : string := 
  match ( (p)) with ( (pre,  wit,  rel1)) =>
    String.append "("
      (String.append
         (String.append "actions: "
            (String.append
               (stringFromSet
                  (fun (a : action )=>
                     match ( a) with | Lock aid1 tid1 loc lock =>
                       String.append "Lock (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", loc: "
                                     (String.append "TODO"
                                        (String.append ", "
                                           (String.append
                                              match ( lock) with | Locked =>
                                                "Locked" | Blocked =>
                                                "Blocked" end ")")))))))
                       | Unlock aid1 tid1 loc =>
                       String.append "Unlock (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", loc: "
                                     (String.append "TODO" ")")))))
                       | Load aid1 tid1 mo1 loc val1 =>
                       String.append "Load (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", mo: "
                                     (String.append
                                        match ( mo1) with | NA => "NA"
                                          | Seq_cst => "Seq_cst" | Relaxed =>
                                          "Relaxed" | Release => "Release"
                                          | Acquire => "Acquire" | Consume =>
                                          "Consume" | Acq_rel => "Acq_rel"
                                        end
                                        (String.append ", loc: "
                                           (String.append "TODO"
                                              (String.append ", val: "
                                                 (String.append "TODO" ")")))))))))
                       | Store aid1 tid1 mo1 loc val1 =>
                       String.append "Store (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", mo: "
                                     (String.append
                                        match ( mo1) with | NA => "NA"
                                          | Seq_cst => "Seq_cst" | Relaxed =>
                                          "Relaxed" | Release => "Release"
                                          | Acquire => "Acquire" | Consume =>
                                          "Consume" | Acq_rel => "Acq_rel"
                                        end
                                        (String.append ", loc: "
                                           (String.append "TODO"
                                              (String.append ", val: "
                                                 (String.append "TODO" ")")))))))))
                       | RMW aid1 tid1 mo1 loc val1 val2 =>
                       String.append "RMW (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", mo: "
                                     (String.append
                                        match ( mo1) with | NA => "NA"
                                          | Seq_cst => "Seq_cst" | Relaxed =>
                                          "Relaxed" | Release => "Release"
                                          | Acquire => "Acquire" | Consume =>
                                          "Consume" | Acq_rel => "Acq_rel"
                                        end
                                        (String.append ", loc: "
                                           (String.append "TODO"
                                              (String.append ", val1: "
                                                 (String.append "TODO"
                                                    (String.append ", val2: "
                                                       (String.append 
                                                        "TODO" ")")))))))))))
                       | Fence aid1 tid1 mo1 =>
                       String.append "Fence (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", mo: "
                                     (String.append
                                        match ( mo1) with | NA => "NA"
                                          | Seq_cst => "Seq_cst" | Relaxed =>
                                          "Relaxed" | Release => "Release"
                                          | Acquire => "Acquire" | Consume =>
                                          "Consume" | Acq_rel => "Acq_rel"
                                        end ")")))))
                       | Blocked_rmw aid1 tid1 loc =>
                       String.append "Blocked_rmw (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", loc: "
                                     (String.append "TODO" ")")))))
                       | Alloc aid1 tid1 loc =>
                       (* CSEM *) String.append "Alloc (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", loc: "
                                     (String.append "TODO" ")"))))) (* CSEM *)
                       | Dealloc aid1 tid1 loc =>
                       (* CSEM *) String.append "Dealloc (aid: "
                         (String.append (lem_string_extra.stringFromNat aid1)
                            (String.append ", tid: "
                               (String.append
                                  (lem_string_extra.stringFromNat tid1)
                                  (String.append ", loc: "
                                     (String.append "TODO" ")"))))) (* CSEM *)
                     end) (actions  pre))
               (String.append ", threads: "
                  (String.append
                     (stringFromSet lem_string_extra.stringFromNat
                        (threads  pre))
                     (String.append ", lk: "
                        (String.append "?"
                           (String.append ", sb: "
                              (String.append (action_rel_tostring (sb  pre))
                                 (String.append ", asw: "
                                    (String.append
                                       (action_rel_tostring (asw  pre))
                                       (String.append ", dd: "
                                          (action_rel_tostring (dd  pre)))))))))))))
         (String.append ", "
            (String.append
               (String.append "rf: "
                  (String.append (action_rel_tostring (rf  wit))
                     (String.append ", mo: "
                        (String.append (action_rel_tostring (mo  wit))
                           (String.append ", sc: "
                              (String.append (action_rel_tostring (sc  wit))
                                 (String.append ", lo: "
                                    (String.append
                                       (action_rel_tostring (lo  wit))
                                       (String.append ", tot: "
                                          (action_rel_tostring (tot  wit)))))))))))
               (String.append ", "
                  (String.append (relation_list_tostring rel1) ")"))))) end.

Definition observable_execution : Type :=  ((pre_execution  * execution_witness ) % type).
Definition observable_execution_default: observable_execution  := (pre_execution_default, execution_witness_default).

Inductive program_behaviours : Type := 
    Defined0:  set  (observable_execution ) -> program_behaviours 
  | Undefined: program_behaviours .
Definition program_behaviours_default: program_behaviours  := Defined0 DAEMON.

Definition program_behaviours_eq  (x : program_behaviours ) (y : program_behaviours )  : bool := 
  match ( (x, y)) with 
  | (Defined0 s1,  Defined0 s2) => (set_equal_by (pairCompare (fun (x : pre_execution ) (y : pre_execution )=>EQ) (fun (x : execution_witness ) (y : execution_witness )=>EQ)) s1 s2)
  | (Undefined,  Undefined) => true
  | _ => false
  end.

Instance x82_Eq : Eq program_behaviours := {          (* CSEM *) (* WIP *)
   isEqual   :=  classical_boolean_equivalence;   (* CSEM *)
   isInequal  :=  unsafe_structural_inequality
}. (* CSEM *)
                                       (* CSEM *)



Definition rf_observable_execution : Type :=  ((pre_execution  * set  ((action  * action ) % type)) % type).
Definition rf_observable_execution_default: rf_observable_execution  := (pre_execution_default, DAEMON).

Inductive rf_program_behaviours : Type := 
    rf_Defined:  set  (rf_observable_execution ) -> rf_program_behaviours 
  | rf_Undefined: rf_program_behaviours .
Definition rf_program_behaviours_default: rf_program_behaviours  := rf_Defined DAEMON.

Definition rf_program_behaviours_eq  (x : rf_program_behaviours ) (y : rf_program_behaviours )  : bool := 
  match ( (x, y)) with 
  | (rf_Defined s1,  rf_Defined s2) => (set_equal_by (pairCompare (fun (x : pre_execution ) (y : pre_execution )=>EQ) (set_compare_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))))) s1 s2)
  | (rf_Undefined,  rf_Undefined) => true
  | _ => false
  end.

Instance x81_Eq : Eq rf_program_behaviours := {       (* CSEM *) (* WIP *)
   isEqual   :=  classical_boolean_equivalence;   (* CSEM *)
   isInequal  :=  unsafe_structural_inequality
}. (* CSEM *)
                                       (* CSEM *)


Inductive named_predicate_tree : Type := 
    Leaf:  (candidate_execution  ->  bool ) -> named_predicate_tree 
  | Node:  list  ((string  * named_predicate_tree ) % type) -> named_predicate_tree .
Definition named_predicate_tree_default: named_predicate_tree  := Leaf (fun (x80 : candidate_execution ) => bool_default).
(* [?]: removed value specification. *)

Definition named_predicate_tree_measure  (t3 : named_predicate_tree )  : nat := 
  match ( t3) with 
    | Leaf _ => 0
    | Node l => Coq.Init.Peano.plus( 1) (List.length l)
  end.

Program Fixpoint apply_tree  (pred_tree : named_predicate_tree ) (X : (pre_execution *execution_witness *relation_list ) % type)  : bool := 
  match ( pred_tree) with 
    | Leaf p => p X
    | Node l => List.forallb (
  fun (p : (string *named_predicate_tree ) % type) =>
    match ( (p) ) with ( (name1,  branch)) => apply_tree branch X end) l
  end.


Inductive fault_setgen : Type := 
    One:  ((string  * (candidate_execution  ->  set  (action ))) % type) -> fault_setgen 
  | Two:  ((string  * (candidate_execution  ->  set  ((action  * action ) % type))) % type) -> fault_setgen .
Definition fault_setgen_default: fault_setgen  := One (string_default, (fun (x79 : candidate_execution ) => DAEMON)).

(* The above type (fault_setgen) is used for the
   undefinedness-predicates, where the kind of undefinedness is
   denoted by a string. To make it easier to work with, we provide
   alternative definitions of the undefinedness-predicates, that
   return a list of the following type. *)

Inductive undefinedness : Type := 
  | DataRaces:  set  ((action  * action ) % type) -> undefinedness 
  | UnsequencedRaces:  set  ((action  * action ) % type) -> undefinedness 
  | IndeterminateReads:  set  action  -> undefinedness 
  | BadMutexes:  set  action  -> undefinedness 
  | NotInSublanguage: undefinedness .
Definition undefinedness_default: undefinedness  := DataRaces DAEMON.    (* e.g. a fence in the lock-only model *)

Instance x78_Show : Show undefinedness := {
   show   d :=  
    match ( d) with 
    | DataRaces s          =>  String.append"DataRaces: " (stringFromSet (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) (aid_of_rel2 s))
    | UnsequencedRaces s   =>  String.append"UnsequencedRaces: " (stringFromSet (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) (aid_of_rel2 s))
    | IndeterminateReads s =>  String.append"IndeterminateReads: " (stringFromSet lem_string_extra.stringFromNat (lem_set.map aid_of s))
    | BadMutexes s         =>  String.append"BadMutexes: " (stringFromSet lem_string_extra.stringFromNat (lem_set.map aid_of s))
    | NotInSublanguage     => "NotInSublanguage"
    end
}.



Definition opsem_t : Type :=  program  ->  pre_execution  ->  bool .
Definition opsem_t_default: opsem_t  := (fun (x76 :  program ) => (fun (x77 :  pre_execution ) => bool_default)).

Definition condition_t : Type :=  set  candidate_execution  ->  bool .
Definition condition_t_default: condition_t  := (fun (x75 :  set  candidate_execution ) => bool_default).

Definition true_condition {a : Type}  ( _ : a)  : bool :=  true.



Record memory_model : Type :=
  {  consistent : named_predicate_tree ;
      relation_calculation : pre_execution  ->  execution_witness  -> 
  relation_list ;
      undefined : list  (fault_setgen );
      relation_flags : relation_usage_flags 
  }.
Notation "{[ r 'with' 'consistent' := e ]}" := ({| consistent := e; relation_calculation := relation_calculation r; undefined := undefined r; relation_flags := relation_flags r |}).
Notation "{[ r 'with' 'relation_calculation' := e ]}" := ({| relation_calculation := e; consistent := consistent r; undefined := undefined r; relation_flags := relation_flags r |}).
Notation "{[ r 'with' 'undefined' := e ]}" := ({| undefined := e; consistent := consistent r; relation_calculation := relation_calculation r; relation_flags := relation_flags r |}).
Notation "{[ r 'with' 'relation_flags' := e ]}" := ({| relation_flags := e; consistent := consistent r; relation_calculation := relation_calculation r; undefined := undefined r |}).
Definition memory_model_default: memory_model  := {| consistent := named_predicate_tree_default; relation_calculation := (fun (x73 :  pre_execution ) => (fun (x74 :  execution_witness ) => relation_list_default)); undefined := DAEMON; relation_flags := relation_usage_flags_default |}.





(*************************************************** *)
(*   - 2.3 - Projection functions *)
(*************************************************** *)

(* The unpack functions are not used in the model itself, but are probably 
   needed by every user of the model. *)

Definition not_alloc_or_dealloc   : action  -> bool :=  
  fun (x : action ) =>
    match (x) with (* CSEM *) | Lock _ _ _ _ => true (* CSEM *)
      | Unlock _ _ _ => true (* CSEM *) | Load _ _ _ _ _ => true (* CSEM *)
      | Store _ _ _ _ _ => true (* CSEM *) | RMW _ _ _ _ _ _ =>
      true (* CSEM *) | Fence _ _ _ => true (* CSEM *) | Blocked_rmw _ _ _ =>
      true (* CSEM *) | Alloc _ _ _ => false (* CSEM *) | Dealloc _ _ _ =>
      false (* CSEM *) end.                                 (* CSEM *)



Definition is_fault  (faults_list : list (fault_setgen )) (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) (a : action )  : bool := 
  match ( (faults_list,p,a)) with ( faults_list,  (Xo, Xw, rl),  a) =>
    let is_particular_fault := (fun (f : fault_setgen ) =>
                                  match ( f) with One (_name, setgen) =>
                                    ( (set_member_by
                                         (fun (x : action ) (y : action )=>
                                            (genericCompare nat_ltb beq_nat
                                               (aid_of x) (aid_of y))) 
                                       a (setgen (Xo,Xw,rl))))
                                    | Two (_name, setgen) =>
                                    set_any
                                      (fun (b : action ) =>
                                         ( (set_member_by
                                              (pairCompare
                                                 (fun (x : action ) (y : action )=>
                                                    (genericCompare nat_ltb
                                                       beq_nat (aid_of x)
                                                       (aid_of y)))
                                                 (fun (x : action ) (y : action )=>
                                                    (genericCompare nat_ltb
                                                       beq_nat (aid_of x)
                                                       (aid_of y)))) 
                                            (a,b) (setgen (Xo,Xw,rl)))) ||
                                         ( (set_member_by
                                              (pairCompare
                                                 (fun (x : action ) (y : action )=>
                                                    (genericCompare nat_ltb
                                                       beq_nat (aid_of x)
                                                       (aid_of y)))
                                                 (fun (x : action ) (y : action )=>
                                                    (genericCompare nat_ltb
                                                       beq_nat (aid_of x)
                                                       (aid_of y)))) 
                                            (b,a) (setgen (Xo,Xw,rl)))))
                                      (actions  Xo) end) in
  List.existsb is_particular_fault faults_list end.

Definition each_empty  (faults_list : list (fault_setgen )) (X : (pre_execution *execution_witness *relation_list ) % type)  : bool := 
    let faults_empty := (fun (f : fault_setgen ) =>
      match ( f) with 
        One (_name, setgen) => set_is_empty (setgen X)
      | Two (_name, setgen) => set_is_empty (setgen X) end) in
    List.forallb faults_empty faults_list.
(* [?]: removed value specification. *)

Definition statically_satisfied  (condition : set ((pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) -> bool ) (opsem : nat  -> pre_execution  -> bool )  (p : program )  : bool := 
  let Xs :=(* XXX: setcomp *) in
  condition Xs.
(* [?]: removed value specification. *)

Definition observable_filter  (X : set ((pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type))  : set ((pre_execution *execution_witness ) % type):=  let x2 := 
  [] in set_fold
   (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) (x2 : set ((pre_execution *execution_witness ) % type)) =>
      match ( (p ,x2) ) with ((Xo, Xw, _rl) ,  x2) =>
        if true then set_add (Xo,Xw) x2 else x2 end) X x2.
(* [?]: removed value specification. *)

Definition behaviour  (M : memory_model ) (condition : set ((pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) -> bool ) (opsem : nat  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  let consistent_executions :=(* XXX: setcomp *) in
  if condition consistent_executions &&
     set_for_all  (fun (X : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    each_empty (undefined  M) X) consistent_executions
  then Defined0 (observable_filter consistent_executions)
  else Undefined.
(* [?]: removed value specification. *)

Definition rf_observable_filter   : set ((pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) -> set ((pre_execution *set ((action *action ) % type)) % type):=  lem_set.map (
  fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) => (Xo,(rf Xw)) end).
(* [?]: removed value specification. *)

Definition rf_behaviour  (M : memory_model ) (condition : set ((pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) -> bool ) (opsem : nat  -> pre_execution  -> bool )  (p : program )  : rf_program_behaviours := 
  let consistent_executions :=(* XXX: setcomp *) in
  if condition consistent_executions &&
     set_for_all  (fun (X : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    each_empty (undefined  M) X) consistent_executions
  then rf_Defined (rf_observable_filter consistent_executions)
  else rf_Undefined.




Definition tid_of  (a : action )  : nat := 
    match ( a) with 
      Lock _ tid1 _ _           => tid1
    | Unlock _ tid1 _           => tid1
    | Load _ tid1 _ _ _         => tid1
    | Store _ tid1 _ _ _        => tid1
    | RMW _ tid1 _ _ _ _        => tid1
    | Fence _ tid1 _            => tid1
    | Blocked_rmw _ tid1 _      => tid1
    | Alloc _ tid1 _            => tid1 (* CSEM *)
    | Dealloc _ tid1 _          => tid1 (* CSEM *)
    end.

Definition loc_of  (a : action )  : option (tt ) := 
    match ( a) with 
      Lock _ _ l _           => Some l
    | Unlock _ _ l           => Some l
    | Load _ _ _ l _         => Some l
    | Store _ _ _ l _        => Some l
    | RMW _ _ _ l _ _        => Some l
    | Fence _ _ _            => None
    | Blocked_rmw _ _ l      => Some l
    | Alloc _ _ l            => Some l (* CSEM *)
    | Dealloc _ _ l          => Some l (* CSEM *)
    end.

Definition value_read_by  (a : action )  : option (tt ) := 
    match ( a) with 
      Load _ _ _ _ v         => Some v
    | RMW _ _ _ _ v _        => Some v
    | _                      => None
    end.

Definition value_written_by  (a : action )  : option (tt ) := 
    match ( a) with 
      Store _ _ _ _ v        => Some v
    | RMW _ _ _ _ _ v        => Some v
    | _                      => None
    end.

Definition is_lock  (a : action )  : bool := 
    match ( a) with 
      Lock _ _ _ _ => true
    | _            => false
    end.

Definition is_successful_lock  (a : action )  : bool := 
    match ( a) with 
      Lock _ _ _ Locked => true
    | _                  => false
    end.

Definition is_blocked_lock  (a : action )  : bool := 
    match ( a) with 
      Lock _ _ _ Blocked => true
    | _                  => false
    end.

Definition is_unlock  (a : action )  : bool := 
    match ( a) with 
      Unlock _ _ _ => true
    | _            => false
    end.

Definition is_atomic_load  (a : action )  : bool := 
    match ( a) with 
      Load _ _ mo1 _ _ => unsafe_structural_inequality mo1 NA
    | _               => false
    end.

Definition is_atomic_store  (a : action )  : bool := 
    match ( a) with 
      Store _ _ mo1 _ _ => unsafe_structural_inequality mo1 NA
    | _                => false
    end.

Definition is_RMW  (a : action )  : bool := 
    match ( a) with 
      RMW _ _ _ _ _ _ => true
    | _               => false
    end.

Definition is_blocked_rmw  (a : action )  : bool := 
    match ( a) with 
      Blocked_rmw _ _ _ => true
    | _                 => false
    end.

Definition is_NA_load  (a : action )  : bool := 
    match ( a) with 
      Load _ _ mo1 _ _ => classical_boolean_equivalence mo1 NA
    | _               => false
    end.

Definition is_NA_store  (a : action )  : bool := 
    match ( a) with 
      Store _ _ mo1 _ _ => classical_boolean_equivalence mo1 NA
    | _                => false
    end.

Definition is_load  (a : action )  : bool := 
    match ( a) with 
      Load _ _ _ _ _ => true
    | _              => false
    end.

Definition is_store  (a : action )  : bool := 
    match ( a) with 
      Store _ _ _ _ _ => true
    | _               => false
    end.

Definition is_fence  (a : action )  : bool := 
    match ( a) with 
      Fence _ _ _ => true
    | _           => false
    end.

Definition is_alloc  (a : action )  : bool :=           (* CSEM *)
  match ( a) with             (* CSEM *)
  | Alloc _ _ _  => true  (* CSEM *)
  | _            => false (* CSEM *)
end.                       (* CSEM *)

Definition is_dealloc  (a : action )  : bool :=          (* CSEM *)
  match ( a) with              (* CSEM *)
  | Dealloc _ _ _ => true  (* CSEM *)
  | _             => false (* CSEM *)
 end.                       (* CSEM *)


Definition is_atomic_action  (a : action )  : bool := 
    match ( a) with 
      Load _ _ mo1 _ _   => unsafe_structural_inequality mo1 NA
    | Store _ _ mo1 _ _  => unsafe_structural_inequality mo1 NA
    | RMW _ _ _ _ _ _   => true
    | Blocked_rmw _ _ _ => true
    | _                 => false
    end.

Definition is_read  (a : action )  : bool := 
    match ( a) with 
      Load _ _ _ _ _  => true
    | RMW _ _ _ _ _ _ => true
    | _               => false
    end.

Definition is_write  (a : action )  : bool := 
    match ( a) with 
      Store _ _ _ _ _ => true
    | RMW _ _ _ _ _ _ => true
    | _               => false
    end.


(* It is important to note that seq_cst atomics are both acquires and releases *)


Definition is_acquire  (a : action )  : bool :=  
    match ( a) with 
      Load _ _ mo1 _ _  => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Acquire; Seq_cst])
    | RMW _ _ mo1 _ _ _ => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Acquire; Acq_rel; Seq_cst])
    | Fence _ _ mo1     => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Acquire; Consume; Acq_rel; Seq_cst])
    | _                => false
    end.

Definition is_release  (a : action )  : bool :=  
    match ( a) with 
      Store _ _ mo1 _ _  => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Release; Seq_cst])
    | RMW _ _ mo1 _ _ _  => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Release; Acq_rel; Seq_cst])
    | Fence _ _ mo1      => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Release; Acq_rel; Seq_cst])
    | _                 => false
    end.

Definition is_consume  (a : action )  : bool :=  
    match ( a) with 
      Load _ _ mo1 _ _  => classical_boolean_equivalence mo1 Consume
    | _                => false
    end.


Definition is_seq_cst  (a : action )  : bool := 
    match ( a) with 
      Load _ _ mo1 _ _  => classical_boolean_equivalence mo1 Seq_cst
    | Store _ _ mo1 _ _ => classical_boolean_equivalence mo1 Seq_cst
    | RMW _ _ mo1 _ _ _ => classical_boolean_equivalence mo1 Seq_cst
    | Fence _ _ mo1     => classical_boolean_equivalence mo1 Seq_cst
    | _                => false
    end.


Definition threadwise {a : Type}  (s : a) (rel1 : set ((action *action ) % type))  : bool :=  set_for_all  
  (fun (p : (action *action ) % type) =>
     match ( (p) ) with ( (a, b)) => beq_nat (tid_of a) (tid_of b) end) rel1.

Definition interthread {a : Type}  (s : a) (rel1 : set ((action *action ) % type))  : bool :=  set_for_all  
  (fun (p : (action *action ) % type) =>
     match ( (p) ) with ( (a, b)) => negb (beq_nat (tid_of a) (tid_of b)) end) rel1.

Definition locationwise {a : Type}  (s : a) (rel1 : set ((action *action ) % type))  : bool :=  set_for_all  
  (fun (p : (action *action ) % type) =>
     match ( (p) ) with ( (a, b)) =>
       (maybeEqualBy classical_boolean_equivalence (loc_of a) (loc_of b)) end) rel1.

Definition per_location_total  (s : set (action )) (rel1 : set ((action *action ) % type))  : bool := 
    set_for_all  (fun (a : action ) =>
    set_for_all
      (fun (b : action ) =>
         ((negb
             (maybeEqualBy classical_boolean_equivalence (loc_of a)
                (loc_of b))) ||
          ((set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (a,b) rel1) ||
           ((set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (b,a) rel1) || ( classical_boolean_equivalence a b))))) 
    s) s.

(**************************************** *)
(*   - 2.4 - Location kinds *)
(**************************************** *)

(* TODO: the following definition should use
action_respects_location_kind, instead of cloning the function
body. This hasn't been done yet, because it might break existing
proofs. *)

Definition actions_respect_location_kinds  (actions1 : set (action )) (lk1 : tt  -> location_kind )  : bool := 
 set_for_all  (fun (a : action ) =>
    match ( a) with | Lock _ _ l _ =>
      classical_boolean_equivalence (lk1 l) Mutex | Unlock _ _ l =>
      classical_boolean_equivalence (lk1 l) Mutex | Load _ _ mo1 l _ =>
      ( classical_boolean_equivalence mo1 NA &&
        classical_boolean_equivalence (lk1 l) Non_Atomic) ||
      ( unsafe_structural_inequality mo1 NA &&
        classical_boolean_equivalence (lk1 l) Atomic0) | Store _ _ mo1 l _ =>
      ( classical_boolean_equivalence mo1 NA &&
        classical_boolean_equivalence (lk1 l) Non_Atomic) ||
      classical_boolean_equivalence (lk1 l) Atomic0 | RMW _ _ _ l _ _ =>
      classical_boolean_equivalence (lk1 l) Atomic0 | Fence _ _ _ => true
      | Blocked_rmw _ _ l => classical_boolean_equivalence (lk1 l) Atomic0
      | Alloc _ _ _ => true (* CSEM *) | Dealloc _ _ _ => true (* CSEM *) end) actions1.

Definition action_respects_location_kinds {a : Type}  (action2 : a) (lk1 : tt  -> location_kind ) (a1 : action )  : bool :=  
  match ( a1) with 
    | Lock _ _ l _            => classical_boolean_equivalence (lk1 l) Mutex
    | Unlock _ _ l            => classical_boolean_equivalence (lk1 l) Mutex
    | Load _ _ mo1 l _         =>
        ( classical_boolean_equivalence mo1 NA && classical_boolean_equivalence (lk1 l) Non_Atomic) || ( unsafe_structural_inequality mo1 NA && classical_boolean_equivalence (lk1 l) Atomic0)
    | Store _ _ mo1 l _        =>
        ( classical_boolean_equivalence mo1 NA && classical_boolean_equivalence (lk1 l) Non_Atomic) || classical_boolean_equivalence (lk1 l) Atomic0
    | RMW _ _ _ l _ _         => classical_boolean_equivalence (lk1 l) Atomic0
    | Fence _ _ _             => true
    | Blocked_rmw _ _ l       => classical_boolean_equivalence (lk1 l) Atomic0
    | Alloc _ _ _             => true (* CSEM *)
    | Dealloc _ _ _           => true (* CSEM *)
    end.


Definition is_at_mutex_location  (lk1 : tt  -> location_kind ) (a : action )  : bool := 
    match ( loc_of a) with 
      Some l => ( classical_boolean_equivalence(lk1 l) Mutex)
    | None   => false
    end.

Definition is_at_non_atomic_location  (lk1 : tt  -> location_kind ) (a : action )  : bool := 
    match ( loc_of a) with 
    | Some l => ( classical_boolean_equivalence(lk1 l) Non_Atomic)
    | None   => false
    end.

Definition is_at_atomic_location  (lk1 : tt  -> location_kind ) (a : action )  : bool := 
    match ( loc_of a) with 
      Some l => ( classical_boolean_equivalence(lk1 l) Atomic0)
    | None   => false
    end.



(**************************************** *)
(*   - 2.5 - Well formed action *)
(**************************************** *)


(* used in cppmem *)
Definition locations_of  (actions1 : set (action ))  : set (tt ):= 
let x2 := [] in set_fold
   (fun (x1 : option (tt ) ) (x2 : set (tt )) =>
      match ( x1) with Some l => if true then set_add l x2 else x2 | _ => x2
      end)
   (let x2 := [] in set_fold
                      (fun (a : action ) (x2 : set (option (tt ) )) =>
                         if true then set_add (loc_of a) x2 else x2) 
                    actions1 x2) x2.


Definition well_formed_action  (a : action )  : bool := 
  match ( a) with 
    | Load  _ _ mo1 _ _ => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [NA; Relaxed; Acquire; Seq_cst; Consume])
    | Store _ _ mo1 _ _ => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [NA; Relaxed; Release; Seq_cst])
    | RMW _ _ mo1 _ _ _ => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Relaxed; Release; Acquire; Acq_rel; Seq_cst])
    | Fence _ _ mo1     => (set_member_by (fun (x : memory_order ) (y : memory_order )=>EQ) mo1 [Relaxed; Release; Acquire; Acq_rel; Consume; Seq_cst])
    | _                => true
    end.
(* [?]: removed value specification. *)

Definition assumptions  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    finite_prefixes (rf  Xw) (actions  Xo) &&
    (finite_prefixes (mo  Xw) (actions  Xo) &&
     (finite_prefixes (sc  Xw) (actions  Xo) &&
      finite_prefixes (lo  Xw) (actions  Xo))) end.




Definition blocking_observed  (actions1 : set (action )) (sb1 : set ((action *action ) % type))  : bool := 
    (set_for_all  (fun (a : action ) =>
    ((negb (is_blocked_rmw a || is_blocked_lock a)) ||
     negb
       (set_any
          (fun (b : action ) =>
             (set_member_by
                (pairCompare
                   (fun (x : action ) (y : action )=>
                      (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                   (fun (x : action ) (y : action )=>
                      (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
                (a,b) sb1)) actions1))) actions1).

(* Indeterminate sequencing from 1.9p15, noting that all atomic and
lock calls are functions. *)
Definition indeterminate_sequencing  (Xo : pre_execution )  : bool := 
    set_for_all  (fun (a : action ) =>
    set_for_all
      (fun (b : action ) =>
         ((negb
             (( beq_nat (tid_of a) (tid_of b)) &&
              (( ((fun (x : action ) (y : action ) =>
                     negb (classical_boolean_equivalence x y)) a b)) &&
               negb
                 (is_at_non_atomic_location (lk  Xo) a &&
                  is_at_non_atomic_location (lk  Xo) b)))) ||
          ((set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (a,b) (sb  Xo)) ||
           (set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (b,a) (sb  Xo))))) (actions  Xo))(actions  Xo).


Definition sbasw  (Xo : pre_execution )  : set ((action *action ) % type):=  (set_tc (fun (a1 : action ) (a2 : action )=>classical_boolean_equivalence a1 a2) ( (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))(sb Xo)(asw  Xo)))).

(* 7.22.3 p1 "Each such allocation shall yield a pointer to an object disjoint from any other object."  (* CSEM *)
   When we are going to make a distinction between regions and objects we have to revise this           (* CSEM *)
   (7.22.3 p1 says that the objects do not overlap, so only unused parts of                             (* CSEM *)
   the malloced regions overlap and that might be not-racy. *)                                          (* CSEM *)
Definition disjoint_allocs  (actions1 : set (action ))  : bool :=                                                                           (* CSEM *)
  (set_for_all  (fun (a : action ) =>
    set_for_all
      (fun (b : action ) =>
         ((negb
             (is_alloc a &&
              (is_alloc b &&
               ( (maybeEqualBy classical_boolean_equivalence (loc_of a)
                    (loc_of b)))))) || ( classical_boolean_equivalence a b)))
      actions1) actions1).
(* [?]: removed value specification. *)

Definition well_formed_threads  (p : (pre_execution *execution_witness *relation_list ) % type)  : bool := 
  match ( (p)) with ( (Xo, _, _)) =>
    (set_for_all (fun (a : action ) => well_formed_action a) (actions  Xo))
    &&
    (actions_respect_location_kinds (actions  Xo) (lk  Xo) &&
     (blocking_observed (actions  Xo) (sb  Xo) &&
      (inj_on aid_of (actions  Xo) &&
       (relation_over (actions  Xo) (sb  Xo) &&
        (relation_over (actions  Xo) (asw  Xo) &&
         (threadwise (actions  Xo) (sb  Xo) &&
          (interthread (actions  Xo) (asw  Xo) &&
           (isStrictPartialOrder (sb  Xo) &&
            (isStrictPartialOrder (dd  Xo) &&
             ((set_subset_by
                 (pairCompare
                    (fun (x : action ) (y : action )=>
                       (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                    (fun (x : action ) (y : action )=>
                       (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
                 (dd  Xo) (sb  Xo)) &&
              (indeterminate_sequencing Xo &&
               (isIrreflexive (sbasw Xo) &&
                (finite_prefixes (sbasw Xo) (actions  Xo) &&
                 disjoint_allocs (actions  Xo)))))))))))))) end. (* CSEM *)

(*
Conjuncts removed from above:


*)


Definition pre_execution_mask  (Xo : pre_execution ) (A : set (action ))  : pre_execution := 
  let B := (set_inter_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) A(actions  Xo)) in
  {|actions := B;threads :=(threads  Xo);lk      :=(lk  Xo);sb      := (relRestrict(sb  Xo) B);asw     := (relRestrict(asw  Xo) B);dd      := (relRestrict(dd  Xo) B)
  |}.




Definition replace_read_value  (a : action ) (v : tt )  : action :=  
  match ( a) with | Lock aid1 tid1 loc out => Lock aid1 tid1 loc Blocked
    | Unlock aid1 tid1 loc => a | Load aid1 tid1 ord loc rval =>
    Load aid1 tid1 ord loc v | Store aid1 tid1 ord loc wval => a
    | RMW aid1 tid1 ord loc rval wval => RMW aid1 tid1 ord loc v wval
    | Fence aid1 tid1 ord => a | Blocked_rmw aid1 tid1 loc => a
    | Alloc _ _ _ =>
    action_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1060, character 3 to line 1068, character 5 *)
    | Dealloc _ _ _ =>
    action_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1060, character 3 to line 1068, character 5 *)
  end.
(* [?]: removed value specification. *)

Definition
    downclosed  (A : set (action )) (R : set ((action *action ) % type))  : bool :=  set_for_all  
  (fun (p : (action *action ) % type) =>
     match ( (p) ) with ( (a, b)) =>
       ((negb
           (set_member_by
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
            b A)) ||
        (set_member_by
           (fun (x : action ) (y : action )=>
              (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
         a A)) end) R.

Definition is_prefix {a : Type}  (opsem : a -> pre_execution  -> bool ) (p : a) (Xo : pre_execution ) (A : set (action ))  : bool := 
  opsem p Xo && ((set_subset_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) A(actions  Xo)) && (downclosed A (sbasw Xo) && true)).


Definition fringe_set  (Xo : pre_execution ) (A : set (action ))  : set (action ):=  minimal_elements ( (set_diff_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(actions Xo) A)) (sbasw Xo).
(* [?]: removed value specification. *)

Definition
    relation_plug  (R : set ((action *action ) % type)) (a : action ) (a' : action )  : set ((action *action ) % type):= (* XXX: setcomp *).



Definition pre_execution_plug  (Xo : pre_execution ) (a : action ) (a' : action )  : pre_execution := 
  {|actions := (set_union_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) ( (set_diff_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(actions Xo) [a])) [a']);threads :=(threads  Xo);lk      :=(lk  Xo);sb      := (relation_plug(sb  Xo) a a');asw     := (relation_plug(asw  Xo) a a');dd      := (relation_plug(dd  Xo) a a')
  |}.



Definition same_prefix  (Xo1 : pre_execution ) (Xo2 : pre_execution ) (A : set (action ))  : bool := 
  let AF := (set_union_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) A (fringe_set Xo1 A)) in
  ( classical_boolean_equivalence (pre_execution_mask Xo1 AF) (pre_execution_mask Xo2 AF)) &&
  ( (set_equal_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))(fringe_set Xo1 A) (fringe_set Xo2 A))).
(* [?]: removed value specification. *)




(* If some property holds for a chain of prefixes, growing at least by the fringe actions at each step, then it holds for some full Xo.

What about finite executions? Their fringe action sets become empty at some point *)

Definition holds_over_prefix {a : Type}  (opsem : a -> pre_execution  -> bool ) (p : a) (Xo : pre_execution ) (A : set (action )) (P : pre_execution  -> bool )  : bool := 
  is_prefix opsem p Xo A && P (pre_execution_mask Xo A).
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* 
Definition
    produce_well_formed_threads   (opsem:opsem_t )  : bool := forall Xo  p,(exists Xw  rl,( --> opsem p Xo well_formed_threads (Xo,Xw,rl) : Prop) : Prop). *)




Definition opsem_assumptions  (opsem : program  -> pre_execution  -> bool )  : bool := 
  BOOM opsem &&
  BOOM opsem.


(*********************************************** *)
(* 3 - Memory_Model simplified, single thread, no atomics *)
(*********************************************** *)


Definition visible_side_effect_set  (actions1 : set (action )) (hb : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (p : (action *action ) % type) (x2 : set ((action *action ) % type)) =>
      match ( (p ,x2) ) with ((a, b) ,  x2) =>
        if
        is_write a &&
        (is_read b &&
         (( (maybeEqualBy classical_boolean_equivalence (loc_of a) (loc_of b)))
          &&
          negb
            ( set_any
                (fun (c : action ) =>
                   negb
                     ( (set_member_by
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y))) c [a; b])) &&
                   (is_write c &&
                    (( (maybeEqualBy classical_boolean_equivalence (loc_of c)
                          (loc_of b))) &&
                     ((set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (a,c) hb) &&
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (c,b) hb))))) actions1))) then
          set_add (a,b) x2 else x2 end) hb x2.
(* [?]: removed value specification. *)

Definition det_read  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _::("vse", vse)::_)) =>
    set_for_all
      (fun (r : action ) =>
         ((negb (is_load r)) ||
          Bool.eqb
            (set_any
               (fun (w : action ) =>
                  (set_member_by
                     (pairCompare
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))) (w,r) vse)) (actions  Xo))
            (set_any
               (fun (w' : action ) =>
                  (set_member_by
                     (pairCompare
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))) (w',r) (rf  Xw))) (actions  Xo))))
      (actions  Xo) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1196, character 1 to line 1200, character 50 *)
    | (( _,  _,  _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1196, character 1 to line 1200, character 50 *)
    | (( _,  _,  _::( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1196, character 1 to line 1200, character 50 *)
  end.
(* [?]: removed value specification. *)

Definition det_read_alt  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    set_for_all
      (fun (r : action ) =>
         ((negb (is_load r)) ||
          Bool.eqb
            (set_any
               (fun (w : action ) =>
                  (set_member_by
                     (pairCompare
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))) (w,r) hb) &&
                  (is_write w &&
                   ( (maybeEqualBy classical_boolean_equivalence (loc_of w)
                        (loc_of r))))) (actions  Xo))
            (set_any
               (fun (w' : action ) =>
                  (set_member_by
                     (pairCompare
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))) (w',r) (rf  Xw))) (actions  Xo))))
      (actions  Xo) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1204, character 1 to line 1208, character 50 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1204, character 1 to line 1208, character 50 *)
  end.
(* [?]: removed value specification. *)

Definition consistent_non_atomic_rf  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _::("vse", vse)::_)) =>
    set_for_all
      (fun (p : (action *action ) % type) =>
         match ( (p) ) with ( (w, r)) =>
           ((negb (is_at_non_atomic_location (lk  Xo) r)) ||
            (set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (w,r) vse)) end) (rf  Xw) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1211, character 1 to line 1213, character 18 *)
    | (( _,  _,  _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1211, character 1 to line 1213, character 18 *)
    | (( _,  _,  _::( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1211, character 1 to line 1213, character 18 *)
  end.
(* [?]: removed value specification. *)

Definition well_formed_rf  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    set_for_all
      (fun (p : (action *action ) % type) =>
         match ( (p) ) with ( (a, b)) =>
           (set_member_by
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
            a (actions  Xo)) &&
           ((set_member_by
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
             b (actions  Xo)) &&
            ((maybeEqualBy classical_boolean_equivalence (loc_of a)
                (loc_of b)) &&
             (is_write a &&
              (is_read b &&
               ((maybeEqualBy classical_boolean_equivalence (value_read_by b)
                   (value_written_by a)) &&
                set_for_all
                  (fun (a' : action ) =>
                     ((negb
                         (set_member_by
                            (pairCompare
                               (fun (x : action ) (y : action )=>
                                  (genericCompare nat_ltb beq_nat (aid_of x)
                                     (aid_of y)))
                               (fun (x : action ) (y : action )=>
                                  (genericCompare nat_ltb beq_nat (aid_of x)
                                     (aid_of y)))) (a',b) (rf  Xw))) ||
                      ( classical_boolean_equivalence a a'))) (actions  Xo))))))
         end) (rf  Xw) end.
(* [?]: removed value specification. *)

Definition sc_mo_lo_empty  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (_, Xw, _)) =>
    set_is_empty (sc  Xw) && (set_is_empty (mo  Xw) && set_is_empty (lo  Xw))
  end.
(* [?]: removed value specification. *)

Definition sc_mo_empty  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (_, Xw, _)) =>
    set_is_empty (sc  Xw) && set_is_empty (mo  Xw) end.
(* [?]: removed value specification. *)

Definition sc_empty  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (_, Xw, _)) => (set_is_empty (sc  Xw)) end.
(* [?]: removed value specification. *)

Definition tot_empty  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (_, Xw, _)) => (set_is_empty (tot  Xw)) end.


Definition single_thread_relations {a : Type}  (Xo : pre_execution ) (Xw : a)  : list ((string *set ((action *action ) % type)) % type):= 
    let hb    :=(sb  Xo) in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse)] .

Definition single_thread_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("sc_mo_lo_empty", Leaf sc_mo_lo_empty);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf)] )] .
(* [?]: removed value specification. *)

Definition indeterminate_reads  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set (action ):= 
  match ( (p)) with ( (Xo, Xw, _)) =>
    let x2 := [] in set_fold
                      (fun (b : action ) (x2 : set (action )) =>
                         if is_read b &&
                            negb
                              (set_any
                                 (fun (a : action ) =>
                                    (set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (a,b) (rf  Xw))) (actions  Xo)) then
                           set_add b x2 else x2) (actions  Xo) x2 end.
(* [?]: removed value specification. *)

Definition unsequenced_races  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set ((action *action ) % type):= 
  match ( (p)) with ( (Xo, _, _)) =>
    let x2 := [] in set_fold
                      (fun (a : action ) (x2 : set ((action *action ) % type)) =>
                         set_fold
                           (fun (b : action ) (x2 : set ((action *action ) % type)) =>
                              if
                              is_at_non_atomic_location (lk  Xo) a &&
                              (negb ( classical_boolean_equivalence a b) &&
                               (( (maybeEqualBy classical_boolean_equivalence
                                     (loc_of a) (loc_of b))) &&
                                ((is_write a || is_write b) &&
                                 (( beq_nat (tid_of a) (tid_of b)) &&
                                  negb
                                    ( (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (a,b)
                                         (sb  Xo)) ||
                                      (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (b,a)
                                         (sb  Xo))))))) then set_add (a,b) x2
                              else x2) (actions  Xo) x2) (actions  Xo) 
                    x2 end.


Definition single_thread_undefined_behaviour   : list (fault_setgen ):= 
  [ Two ("unsequenced_races", unsequenced_races);
    One ("indeterminate_reads", indeterminate_reads)] .

Definition no_CK  (Xo : pre_execution )  : bool :=                                    (* CSEM *)
  set_for_all  (fun (a : action ) => not_alloc_or_dealloc a)(actions  Xo).
(* [?]: removed value specification. *)

Definition single_thread_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_any
        (fun (b : action ) =>
           set_for_all
             (fun (a : action ) =>
                ( beq_nat (tid_of a) (tid_of b)) &&
                match ( (loc_of a)) with None => false | Some l =>
                  ( classical_boolean_equivalence ((lk Xo) l) Non_Atomic) end)
             (actions  Xo)) (actions  Xo) end) Xs.

Definition single_thread_memory_model   : memory_model := 
  {|consistent := single_thread_consistent_execution;relation_calculation := single_thread_relations;undefined := single_thread_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := false;sc_flag  := false;lo_flag  := false;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition single_thread_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour single_thread_memory_model single_thread_condition opsem p.



(*********************************************** *)
(* 4 - Memory_Model simplified, multi-thread, no atomics, yes locks *)
(*********************************************** *)


Definition locks_only_sw {a : Type}  (actions1 : a) (asw1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type)) (a1 : action ) (b : action )  : bool := 
  ( negb (beq_nat (tid_of a1) (tid_of b))) &&
  ( (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (* thread sync *)
    (a1,b) asw1) ||
    (* mutex sync *)
    (is_unlock a1 && (is_lock b && (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (a1,b) lo1)))
  ).

Definition locks_only_sw_set  (actions1 : set (action )) (asw1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if locks_only_sw actions1 asw1 lo1 a b then set_add (a,b) x2 else
             x2) actions1 x2) actions1 x2.
(* [?]: removed value specification. *)

Definition locks_only_sw_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  locks_only_sw_set(actions  Xo)(asw  Xo)(lo  Xw).

Definition no_consume_hb {a : Type} `{Eq a} `{SetType a}  (sb1 : set ((a*a) % type)) (sw : set ((a*a) % type))  : set ((a*a) % type):= 
    (set_tc (fun x y => x = y) ( (set_union_by (pairCompare setElemCompare setElemCompare)sb1 sw))).
(* [?]: removed value specification. *)

Definition locks_only_hb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  no_consume_hb(sb  Xo) (locks_only_sw_set_alt Xo Xw).
(* [?]: removed value specification. *)

Definition locks_only_vse  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  visible_side_effect_set(actions  Xo) (locks_only_hb Xo Xw).

Definition locks_only_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let sw    := locks_only_sw_set(actions  Xo)(asw  Xo)(lo  Xw) in
    let hb    := no_consume_hb(sb  Xo) sw in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw)] .
(* [?]: removed value specification. *)

Definition locks_only_relations_alt  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    [ ("hb", locks_only_hb Xo Xw);
      ("vse", locks_only_vse Xo Xw);
      ("sw", locks_only_sw_set_alt Xo Xw)] .


Definition locks_only_consistent_lo  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    relation_over (actions  Xo) (lo  Xw) &&
    (isTransitive (lo  Xw) &&
     (isIrreflexive (lo  Xw) &&
      set_for_all
        (fun (a : action ) =>
           set_for_all
             (fun (b : action ) =>
                ( ((negb
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (a,b) (lo  Xw))) ||
                   negb
                     ( (set_member_by
                          (pairCompare
                             (fun (x : action ) (y : action )=>
                                (genericCompare nat_ltb beq_nat (aid_of x)
                                   (aid_of y)))
                             (fun (x : action ) (y : action )=>
                                (genericCompare nat_ltb beq_nat (aid_of x)
                                   (aid_of y)))) (b,a) hb)))) &&
                (
                Bool.eqb
                  ( (set_member_by
                       (pairCompare
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))) (a,b) (lo  Xw)) ||
                    (set_member_by
                       (pairCompare
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))) (b,a) (lo  Xw)))
                  ( (negb ( classical_boolean_equivalence a b)) &&
                    ((is_lock a || is_unlock a) &&
                     ((is_lock b || is_unlock b) &&
                      (( (maybeEqualBy classical_boolean_equivalence
                            (loc_of a) (loc_of b))) &&
                       is_at_mutex_location (lk  Xo) a))) ) )) (actions  Xo))
        (actions  Xo))) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1358, character 1 to line 1372, character 7 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1358, character 1 to line 1372, character 7 *)
  end.
(* [?]: removed value specification. *)

Definition locks_only_consistent_locks  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    (set_for_all
       (fun (p : (action *action ) % type) =>
          match ( (p) ) with ( (a, c)) =>
            ((negb (is_successful_lock a && is_successful_lock c)) ||
             (set_any
                (fun (b : action ) =>
                   is_unlock b &&
                   ((set_member_by
                       (pairCompare
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))) (a,b) (lo  Xw)) &&
                    (set_member_by
                       (pairCompare
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))) (b,c) (lo  Xw)))) (actions  Xo)))
          end) (lo  Xw)) end.
(* [?]: removed value specification. *)

Definition consistent_hb  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, _, ("hb", hb)::_)) =>
    isIrreflexive
      ((set_tc
          (fun (a1 : action ) (a2 : action )=>
             classical_boolean_equivalence a1 a2) hb)) &&
    finite_prefixes hb (actions  Xo) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1384, character 1 to line 1386, character 33 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1384, character 1 to line 1386, character 33 *)
  end.


Definition locks_only_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("sc_mo_empty", Leaf sc_mo_empty);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf)] )] .


(*********************************************** *)

Definition locks_only_good_mutex_use {a : Type}  (actions1 : set (action )) (lk1 : a) (sb1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type)) (a1 : action )  : bool := 
    (* violated requirement: The calling thread shall own the mutex. *)
    (
      ((negb (is_unlock a1)) || ( set_any  
  (fun (al : action ) =>
     is_successful_lock al &&
     ((set_member_by
         (pairCompare
            (fun (x : action ) (y : action )=>
               (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
            (fun (x : action ) (y : action )=>
               (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
         (al,a1) sb1) &&
      ((set_member_by
          (pairCompare
             (fun (x : action ) (y : action )=>
                (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
             (fun (x : action ) (y : action )=>
                (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
          (al,a1) lo1) &&
       set_for_all
         (fun (au : action ) =>
            ((negb (is_unlock au)) ||
             negb
               ( (set_member_by
                    (pairCompare
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))) (al,au) lo1) &&
                 (set_member_by
                    (pairCompare
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))) (au,a1) lo1)))) actions1))) actions1
        ))
    ) &&
    (* violated requirement: The calling thread does not own the mutex. *)
    (
      ((negb (is_lock a1)) || set_for_all  
  (fun (al : action ) =>
     ((negb
         (is_successful_lock al &&
          ((set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (al,a1) sb1) &&
           (set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (al,a1) lo1)))) ||
      set_any
        (fun (au : action ) =>
           is_unlock au &&
           ((set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (al,au) lo1) &&
            (set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (au,a1) lo1))) actions1)) actions1)
    ).
(* [?]: removed value specification. *)

Definition locks_only_bad_mutexes  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set (action ):= 
  match ( (p)) with ( (Xo, Xw, _)) =>
    let x2 := [] in set_fold
                      (fun (a : action ) (x2 : set (action )) =>
                         if
                         negb
                           (locks_only_good_mutex_use (actions  Xo) (lk  Xo)
                              (sb  Xo) (lo  Xw) a) then set_add a x2 else 
                         x2) (actions  Xo) x2 end.
(* [?]: removed value specification. *)

Definition data_races  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : set ((action *action ) % type):= 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    let x2 := [] in set_fold
                      (fun (a : action ) (x2 : set ((action *action ) % type)) =>
                         set_fold
                           (fun (b : action ) (x2 : set ((action *action ) % type)) =>
                              if
                              negb ( classical_boolean_equivalence a b) &&
                              (( (maybeEqualBy classical_boolean_equivalence
                                    (loc_of a) (loc_of b))) &&
                               ((is_write a || is_write b) &&
                                (( negb (beq_nat (tid_of a) (tid_of b))) &&
                                 (negb
                                    (is_atomic_action a && is_atomic_action b)
                                  &&
                                  negb
                                    ( (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (a,b) 
                                       hb) ||
                                      (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (b,a) 
                                       hb)))))) then set_add (a,b) x2 else 
                              x2) (actions  Xo) x2) (actions  Xo) x2
    | (( _,  _, [])) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1432, character 1 to line 1437, character 43 *)
    | (( _,  _, ( _,  _):: _)) =>
    DAEMON (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1432, character 1 to line 1437, character 43 *)
  end.


Definition locks_only_undefined_behaviour   : list (fault_setgen ):= 
  [ Two ("unsequenced_races", unsequenced_races);
    Two ("data_races", data_races);
    One ("indeterminate_reads", indeterminate_reads);
    One ("locks_only_bad_mutexes", locks_only_bad_mutexes)] .
(* [?]: removed value specification. *)

Definition locks_only_undefined_behaviour_alt  (ex : (pre_execution *execution_witness *relation_list ) % type)  : list (undefinedness ):= 
  let unseq_races := unsequenced_races ex in
  let data_races1 := data_races ex in
  let indet_reads := indeterminate_reads ex in
  let bad_mutexes := locks_only_bad_mutexes ex in
    if negb (set_is_empty unseq_races) then
      [UnsequencedRaces unseq_races]
    else
  
      (@ List.app _)[]
    (if negb (set_is_empty data_races1) then
      [DataRaces data_races1]
    else
   
      (@ List.app _)[]
    (if negb (set_is_empty indet_reads) then
      [IndeterminateReads indet_reads]
    else
  
      (@ List.app _)[]
    (if negb (set_is_empty bad_mutexes) then
      [BadMutexes bad_mutexes]
    else
      []))).
(* [?]: removed value specification. *)

Definition locks_only_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( (loc_of a)) with None => false | Some l =>
             ( (set_member_by
                  (fun (x : location_kind ) (y : location_kind )=> EQ)
                  ((lk Xo) l) [Mutex; Non_Atomic])) end) (actions  Xo) end) Xs.

Definition locks_only_memory_model   : memory_model := 
  {|consistent := locks_only_consistent_execution;relation_calculation := locks_only_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := false;sc_flag  := false;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition locks_only_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour locks_only_memory_model locks_only_condition opsem p.
(* [?]: removed value specification. *)

Definition consistent_atomic_rf  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    set_for_all
      (fun (p : (action *action ) % type) =>
         match ( (p) ) with ( (w, r)) =>
           ((negb (is_at_atomic_location (lk  Xo) r && is_load r)) ||
            negb
              ( (set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (r,w) hb))) end) (rf  Xw)
    | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1509, character 1 to line 1511, character 25 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1509, character 1 to line 1511, character 25 *)
  end.
(* [?]: removed value specification. *)

Definition rmw_atomicity  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    set_for_all
      (fun (b : action ) =>
         set_for_all
           (fun (a : action ) =>
              ((negb (is_RMW b)) ||
               ( Bool.eqb (adjacent_less_than (mo  Xw) (actions  Xo) a b)
                   ( (set_member_by
                        (pairCompare
                           (fun (x : action ) (y : action )=>
                              (genericCompare nat_ltb beq_nat (aid_of x)
                                 (aid_of y)))
                           (fun (x : action ) (y : action )=>
                              (genericCompare nat_ltb beq_nat (aid_of x)
                                 (aid_of y)))) (a,b) (rf  Xw))))))
           (actions  Xo)) (actions  Xo) end.
(* [?]: removed value specification. *)

Definition coherent_memory_use  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    ( negb
        ( set_any
            (fun (p : (action *action ) % type) =>
               match ( (p) ) with ( (a, b)) =>
                 set_any
                   (fun (p : (action *action ) % type) =>
                      match ( (p) ) with ( (c, d)) =>
                        (set_member_by
                           (pairCompare
                              (fun (x : action ) (y : action )=>
                                 (genericCompare nat_ltb beq_nat (aid_of x)
                                    (aid_of y)))
                              (fun (x : action ) (y : action )=>
                                 (genericCompare nat_ltb beq_nat (aid_of x)
                                    (aid_of y)))) (b,d) hb) &&
                        (set_member_by
                           (pairCompare
                              (fun (x : action ) (y : action )=>
                                 (genericCompare nat_ltb beq_nat (aid_of x)
                                    (aid_of y)))
                              (fun (x : action ) (y : action )=>
                                 (genericCompare nat_ltb beq_nat (aid_of x)
                                    (aid_of y)))) (c,a) (mo  Xw)) end)
                   (rf  Xw) end) (rf  Xw) ) ) &&
    (
    (* CoWR *) ( negb
                   ( set_any
                       (fun (p : (action *action ) % type) =>
                          match ( (p) ) with ( (a, b)) =>
                            set_any
                              (fun (c : action ) =>
                                 (set_member_by
                                    (pairCompare
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))) 
                                  (c,b) hb) &&
                                 (set_member_by
                                    (pairCompare
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))) 
                                  (a,c) (mo  Xw))) (actions  Xo) end)
                       (rf  Xw) ) ) &&
    (
    (* CoRW *) ( negb
                   ( set_any
                       (fun (p : (action *action ) % type) =>
                          match ( (p) ) with ( (a, b)) =>
                            set_any
                              (fun (c : action ) =>
                                 (set_member_by
                                    (pairCompare
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))) 
                                  (b,c) hb) &&
                                 (set_member_by
                                    (pairCompare
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))) 
                                  (c,a) (mo  Xw))) (actions  Xo) end)
                       (rf  Xw) ) ) &&
    (* CoWW *)
    ( negb
        (set_any
           (fun (p : (action *action ) % type) =>
              match ( (p) ) with ( (a, b)) =>
                (set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (b,a) (mo  Xw)) end) hb) )))
    | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1520, character 1 to line 1531, character 50 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1520, character 1 to line 1531, character 50 *)
  end.
(* [?]: removed value specification. *)

Definition consistent_mo  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    relation_over (actions  Xo) (mo  Xw) &&
    (isTransitive (mo  Xw) &&
     (isIrreflexive (mo  Xw) &&
      set_for_all
        (fun (a : action ) =>
           set_for_all
             (fun (b : action ) =>
                Bool.eqb
                  ( (set_member_by
                       (pairCompare
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))) (a,b) (mo  Xw)) ||
                    (set_member_by
                       (pairCompare
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))
                          (fun (x : action ) (y : action )=>
                             (genericCompare nat_ltb beq_nat (aid_of x)
                                (aid_of y)))) (b,a) (mo  Xw)))
                  ( (negb ( classical_boolean_equivalence a b)) &&
                    (is_write a &&
                     (is_write b &&
                      (( (maybeEqualBy classical_boolean_equivalence
                            (loc_of a) (loc_of b))) &&
                       is_at_atomic_location (lk  Xo) a))) )) (actions  Xo))
        (actions  Xo))) end.


Definition relaxed_only_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("sc_empty", Leaf sc_empty);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_mo", Leaf consistent_mo);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("consistent_atomic_rf", Leaf consistent_atomic_rf);
                  ("coherent_memory_use", Leaf coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity)] )] .
(* [?]: removed value specification. *)

Definition relaxed_only_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             (set_member_by
                (fun (x : memory_order ) (y : memory_order )=> EQ) mo1
                [NA; Relaxed]) | Store _ _ mo1 _ _ =>
             (set_member_by
                (fun (x : memory_order ) (y : memory_order )=> EQ) mo1
                [NA; Relaxed]) | RMW _ _ mo1 _ _ _ =>
             (set_member_by
                (fun (x : memory_order ) (y : memory_order )=> EQ) mo1
                [Relaxed]) | Fence _ _ _ => false | Blocked_rmw _ _ _ => true
             | Alloc _ _ _ => false (* CSEM *) | Dealloc _ _ _ =>
             false (* CSEM *) end) (actions  Xo) end) Xs.


(*********************************************** *)


Definition relaxed_only_memory_model   : memory_model := 
  {|consistent := relaxed_only_consistent_execution;relation_calculation := locks_only_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := false;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition relaxed_only_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour relaxed_only_memory_model relaxed_only_condition opsem p.
(* [?]: removed value specification. *)

Definition release_acquire_coherent_memory_use  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    ( negb
        ( set_any
            (fun (p : (action *action ) % type) =>
               match ( (p) ) with ( (a, b)) =>
                 set_any
                   (fun (c : action ) =>
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (c,b) hb) &&
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (a,c) (mo  Xw)))
                   (actions  Xo) end) (rf  Xw) ) ) &&
    (* CoWW *)
    ( negb
        (set_any
           (fun (p : (action *action ) % type) =>
              match ( (p) ) with ( (a, b)) =>
                (set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (b,a) (mo  Xw)) end) hb) )
    | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1611, character 1 to line 1616, character 50 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 1611, character 1 to line 1616, character 50 *)
  end.
(* [?]: removed value specification. *)

Definition atomic_initialisation_first  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, _, _)) =>
    set_for_all
      (fun (a : action ) =>
         set_for_all
           (fun (b : action ) =>
              ((negb
                  (is_at_atomic_location (lk  Xo) a &&
                   (is_NA_store a &&
                    (is_write b &&
                     (( (maybeEqualBy classical_boolean_equivalence
                           (loc_of a) (loc_of b))) &&
                      ( ((fun (x : action ) (y : action ) =>
                            negb (classical_boolean_equivalence x y)) 
                         a b))))))) ||
               (( (set_member_by
                     (pairCompare
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))) (a,b)
                     (set_tc
                        (fun (a1 : action ) (a2 : action )=>
                           classical_boolean_equivalence a1 a2)
                        ( (set_union_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) (sb Xo) (asw  Xo)))))) &&
                negb (is_NA_store b)))) (actions  Xo)) (actions  Xo) end.
(* [?]: removed value specification. *)

Definition release_acquire_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      atomic_initialisation_first (Xo,Xw,rl) &&
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release])) | RMW _ _ mo1 _ _ _ =>
             classical_boolean_equivalence mo1 Acq_rel | Fence _ _ _ => false
             | Blocked_rmw _ _ _ => true | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.


Definition release_acquire_synchronizes_with {a b : Type}  (actions1 : a) (sb1 : b) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type)) (a1 : action ) (b1 : action )  : bool := 
  ( negb (beq_nat (tid_of a1) (tid_of b1))) &&
  ( (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (* thread sync *)
    (a1,b1) asw1) ||
    (
    (* mutex sync *)(is_unlock a1 && (is_lock b1 && (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (a1,b1) lo1))) ||
    (* rel/acq sync *)
    ( is_release a1 && (is_acquire b1 && (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (a1,b1) rf1)) ))
  ).

Definition release_acquire_synchronizes_with_set {a : Type}  (actions1 : set (action )) (sb1 : a) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if
           release_acquire_synchronizes_with actions1 sb1 asw1 rf1 lo1 a b then
             set_add (a,b) x2 else x2) actions1 x2) actions1 x2.
(* [?]: removed value specification. *)

Definition sw_asw  (Xo : pre_execution )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (p : (action *action ) % type) (x2 : set ((action *action ) % type)) =>
      match ( (p ,x2) ) with ((a,  b) ,  x2) =>
        if (set_member_by
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
            a (actions  Xo)) &&
           ((set_member_by
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
             b (actions  Xo)) && negb (beq_nat (tid_of a) (tid_of b))) then
          set_add (a, b) x2 else x2 end) (asw  Xo) x2.
(* [?]: removed value specification. *)

Definition sw_lock  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (p : (action *action ) % type) (x2 : set ((action *action ) % type)) =>
      match ( (p ,x2) ) with ((a, b) ,  x2) =>
        if (set_member_by
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
            a (actions  Xo)) &&
           ((set_member_by
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
             b (actions  Xo)) &&
            (negb (beq_nat (tid_of a) (tid_of b)) &&
             (is_unlock a && is_lock b))) then set_add (a, b) x2 else 
        x2 end) (lo  Xw) x2.
(* [?]: removed value specification. *)

Definition sw_rel_acq  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if negb (beq_nat (tid_of a) (tid_of b)) &&
              (is_release a &&
               (is_acquire b &&
                (set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (a,b) (rf  Xw)))) then
             set_add (a, b) x2 else x2) (actions  Xo) x2) (actions  Xo) 
 x2.
(* [?]: removed value specification. *)

Definition release_acquire_synchronizes_with_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):=  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
  (sw_asw Xo) (sw_lock Xo Xw)) (sw_rel_acq Xo Xw)).
(* [?]: removed value specification. *)

Definition release_acquire_hb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  no_consume_hb(sb  Xo) (release_acquire_synchronizes_with_set_alt Xo Xw).
(* [?]: removed value specification. *)

Definition release_acquire_vse  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  visible_side_effect_set(actions  Xo) (release_acquire_hb Xo Xw).

Definition release_acquire_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let sw    := release_acquire_synchronizes_with_set(actions 
                  Xo)(sb  Xo)(asw  Xo)(rf  Xw)(lo  Xw) in
    let hb    := no_consume_hb(sb  Xo) sw in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw)] .
(* [?]: removed value specification. *)

Definition release_acquire_relations_alt  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    [ ("hb", release_acquire_hb Xo Xw);
      ("vse", release_acquire_vse Xo Xw);
      ("sw", release_acquire_synchronizes_with_set_alt Xo Xw)] .


(*********************************************** *)


(* Unused currently, see R/A coherence above *)
Definition release_acquire_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("sc_empty", Leaf sc_empty);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_mo", Leaf consistent_mo);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("consistent_atomic_rf", Leaf consistent_atomic_rf);
                  ("release_acquire_coherent_memory_use", Leaf release_acquire_coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity)] )] .


Definition release_acquire_memory_model   : memory_model := 
  {|consistent := relaxed_only_consistent_execution;relation_calculation := release_acquire_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := false;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition release_acquire_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour release_acquire_memory_model release_acquire_condition opsem p.
(* [?]: removed value specification. *)

Definition release_acquire_relaxed_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire; Relaxed])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release; Relaxed])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Acq_rel; Acquire; Release; Relaxed])) | Fence _ _ _ =>
             false | Blocked_rmw _ _ _ => true | Alloc _ _ _ =>
             false (* CSEM *) | Dealloc _ _ _ => false (* CSEM *) end)
        (actions  Xo) end) Xs.


Definition release_acquire_relaxed_synchronizes_with {a b : Type} `{SetType a}  (actions1 : set a) (sb1 : b) (asw1 : set ((action *action ) % type)) (rf1 : set ((a*action ) % type)) (lo1 : set ((action *action ) % type)) (rs : set ((action *a) % type)) (a1 : action ) (b1 : action )  : bool := 
  ( negb (beq_nat (tid_of a1) (tid_of b1))) &&
  ( (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (* thread sync *)
    (a1,b1) asw1) ||
    (
    (* mutex sync *)(is_unlock a1 && (is_lock b1 && (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (a1,b1) lo1))) ||
    (* rel/acq sync *)
    ( is_release a1 && (is_acquire b1 &&
      (set_any  (fun (c : a) =>
    (set_member_by
       (pairCompare
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
          setElemCompare) (a1,c) rs) &&
    (set_member_by
       (pairCompare setElemCompare
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) 
     (c,b1) rf1)) actions1)) ))
  ).

Definition release_acquire_relaxed_synchronizes_with_set {a : Type}  (actions1 : set (action )) (sb1 : a) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type)) (rs : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if
           release_acquire_relaxed_synchronizes_with actions1 sb1 asw1 
           rf1 lo1 rs a b then set_add (a,b) x2 else x2) actions1 x2)
   actions1 x2.

Definition rs_element  (head1 : action ) (a : action )  : bool := 
    ( beq_nat(tid_of a) (tid_of head1)) || is_RMW a.

Definition release_sequence_set {a : Type}  (actions1 : set (action )) (lk1 : a) (mo1 : set ((action *action ) % type))  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (rel1 : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if
           is_release rel1 &&
           ( ( classical_boolean_equivalence b rel1) ||
             ( (set_member_by
                  (pairCompare
                     (fun (x : action ) (y : action )=>
                        (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                     (fun (x : action ) (y : action )=>
                        (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
                  (rel1,b) mo1) &&
               (rs_element rel1 b &&
                set_for_all
                  (fun (c : action ) =>
                     ((negb
                         ( (set_member_by
                              (pairCompare
                                 (fun (x : action ) (y : action )=>
                                    (genericCompare nat_ltb beq_nat
                                       (aid_of x) (aid_of y)))
                                 (fun (x : action ) (y : action )=>
                                    (genericCompare nat_ltb beq_nat
                                       (aid_of x) (aid_of y)))) (rel1,c) 
                            mo1) &&
                           (set_member_by
                              (pairCompare
                                 (fun (x : action ) (y : action )=>
                                    (genericCompare nat_ltb beq_nat
                                       (aid_of x) (aid_of y)))
                                 (fun (x : action ) (y : action )=>
                                    (genericCompare nat_ltb beq_nat
                                       (aid_of x) (aid_of y)))) (c,b) 
                            mo1))) || rs_element rel1 c)) actions1) ) ) then
             set_add (rel1,b) x2 else x2) actions1 x2) actions1 x2.
(* [?]: removed value specification. *)

Definition release_sequence_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw).
(* [?]: removed value specification. *)

Definition sw_rel_acq_rs  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if negb (beq_nat (tid_of a) (tid_of b)) &&
              (is_release a &&
               (is_acquire b &&
                (set_any
                   (fun (c : action ) =>
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (a,c)
                         (release_sequence_set_alt Xo Xw)) &&
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (c,b) (rf  Xw)))
                   (actions  Xo)))) then set_add (a, b) x2 else x2)
        (actions  Xo) x2) (actions  Xo) x2.
(* [?]: removed value specification. *)

Definition release_acquire_relaxed_synchronizes_with_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):=  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
  (sw_asw Xo) (sw_lock Xo Xw)) (sw_rel_acq_rs Xo Xw)).
(* [?]: removed value specification. *)

Definition release_acquire_relaxed_hb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  no_consume_hb(sb  Xo) (release_acquire_relaxed_synchronizes_with_set_alt Xo Xw).
(* [?]: removed value specification. *)

Definition release_acquire_relaxed_vse  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  visible_side_effect_set(actions  Xo) (release_acquire_relaxed_hb Xo Xw).

Definition release_acquire_relaxed_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let rs    := release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let sw    := release_acquire_relaxed_synchronizes_with_set(actions  Xo)(sb  Xo)(asw  Xo)(rf  Xw)(lo  Xw) rs in
    let hb    := no_consume_hb(sb  Xo) sw in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("rs", rs)] .
(* [?]: removed value specification. *)

Definition release_acquire_relaxed_relations_alt  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    [ ("hb", release_acquire_relaxed_hb Xo Xw);
      ("vse", release_acquire_relaxed_vse Xo Xw);
      ("sw", release_acquire_relaxed_synchronizes_with_set_alt Xo Xw);
      ("rs", release_sequence_set_alt Xo Xw)] .


(*********************************************** *)


Definition release_acquire_relaxed_memory_model   : memory_model := 
  {|consistent := relaxed_only_consistent_execution;relation_calculation := release_acquire_relaxed_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := false;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition release_acquire_relaxed_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour release_acquire_relaxed_memory_model release_acquire_relaxed_condition opsem p.
(* [?]: removed value specification. *)

Definition release_acquire_fenced_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire; Relaxed])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release; Relaxed])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Acq_rel; Acquire; Release; Relaxed])) | Fence _ _ mo1 =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Release; Acquire; Relaxed])) | Blocked_rmw _ _ _ => true
             | Alloc _ _ _ => false (* CSEM *) | Dealloc _ _ _ =>
             false (* CSEM *) end) (actions  Xo) end) Xs.


Definition release_acquire_fenced_synchronizes_with  (actions1 : set (action )) (sb1 : set ((action *action ) % type)) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type)) (rs : set ((action *action ) % type)) (hrs : set ((action *action ) % type)) (a : action ) (b : action )  : bool := 
  ( negb (beq_nat (tid_of a) (tid_of b))) &&
  ( (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (* thread sync *)
    (a,b) asw1) ||
    (
    (* mutex sync *)(is_unlock a && (is_lock b && (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (a,b) lo1))) ||
    (
    (* rel/acq sync *)( is_release a && (is_acquire b &&
      (set_any  (fun (c : action ) =>
    (set_member_by
       (pairCompare
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) 
     (a,c) rs) &&
    (set_member_by
       (pairCompare
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
          (fun (x : action ) (y : action )=>
             (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) 
     (c,b) rf1)) actions1)) ) ||
    (
    (* fence synchronisation *)( is_fence a && (is_release a && (is_fence b && (is_acquire b &&
      set_any  (fun (x : action ) =>
    set_any
      (fun (z : action ) =>
         set_any
           (fun (y : action ) =>
              (set_member_by
                 (pairCompare
                    (fun (x : action ) (y : action )=>
                       (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                    (fun (x : action ) (y : action )=>
                       (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
                 (a,x) sb1) &&
              ((set_member_by
                  (pairCompare
                     (fun (x : action ) (y : action )=>
                        (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                     (fun (x : action ) (y : action )=>
                        (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
                  (x,z) hrs) &&
               ((set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (z,y) rf1) &&
                (set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (y,b) sb1)))) actions1) actions1) actions1)))) ||
    (( is_fence a && (is_release a && (is_acquire b &&
      set_any  (fun (x : action ) =>
    set_any
      (fun (y : action ) =>
         (set_member_by
            (pairCompare
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
            (a,x) sb1) &&
         ((set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (x,y) hrs) &&
          (set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (y,b) rf1))) actions1) actions1)) ) ||
    ( is_release a && (is_fence b && (is_acquire b &&
      set_any  (fun (y : action ) =>
    set_any
      (fun (x : action ) =>
         (set_member_by
            (pairCompare
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
            (a,y) rs) &&
         ((set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (y,x) rf1) &&
          (set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (x,b) sb1))) actions1) actions1))))))) ).

Definition release_acquire_fenced_synchronizes_with_set  (actions1 : set (action )) (sb1 : set ((action *action ) % type)) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type)) (lo1 : set ((action *action ) % type)) (rs : set ((action *action ) % type)) (hrs : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if
           release_acquire_fenced_synchronizes_with actions1 sb1 asw1 
           rf1 lo1 rs hrs a b then set_add (a,b) x2 else x2) actions1 
      x2) actions1 x2.

Definition hypothetical_release_sequence_set {a : Type}  (actions1 : set (action )) (lk1 : a) (mo1 : set ((action *action ) % type))  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if
           is_atomic_action a &&
           (is_write a &&
            ( ( classical_boolean_equivalence b a) ||
              ( (set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (a,b) mo1) &&
                (rs_element a b &&
                 set_for_all
                   (fun (c : action ) =>
                      ((negb
                          ( (set_member_by
                               (pairCompare
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))) (a,c) 
                             mo1) &&
                            (set_member_by
                               (pairCompare
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))) (c,b) 
                             mo1))) || rs_element a c)) actions1) ) )) then
             set_add (a,b) x2 else x2) actions1 x2) actions1 x2.
(* [?]: removed value specification. *)

Definition hypothetical_release_sequence_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  hypothetical_release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw).
(* [?]: removed value specification. *)

Definition sw_fence_sb_hrs_rf_sb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if negb (beq_nat (tid_of a) (tid_of b)) &&
              (is_fence a &&
               (is_release a &&
                (is_fence b &&
                 (is_acquire b &&
                  (set_any
                     (fun (x : action ) =>
                        set_any
                          (fun (y : action ) =>
                             set_any
                               (fun (z : action ) =>
                                  (set_member_by
                                     (pairCompare
                                        (fun (x : action ) (y : action )=>
                                           (genericCompare nat_ltb beq_nat
                                              (aid_of x) (aid_of y)))
                                        (fun (x : action ) (y : action )=>
                                           (genericCompare nat_ltb beq_nat
                                              (aid_of x) (aid_of y)))) 
                                   (a,x) (sb  Xo)) &&
                                  ((set_member_by
                                      (pairCompare
                                         (fun (x : action ) (y : action )=>
                                            (genericCompare nat_ltb beq_nat
                                               (aid_of x) (aid_of y)))
                                         (fun (x : action ) (y : action )=>
                                            (genericCompare nat_ltb beq_nat
                                               (aid_of x) (aid_of y)))) 
                                    (x,y)
                                      (hypothetical_release_sequence_set_alt
                                         Xo Xw)) &&
                                   ((set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (y,z) (rf  Xw)) &&
                                    (set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (z,b) (sb  Xo))))) (actions  Xo))
                          (actions  Xo)) (actions  Xo)))))) then
             set_add (a, b) x2 else x2) (actions  Xo) x2) (actions  Xo) 
 x2.
(* [?]: removed value specification. *)

Definition sw_fence_sb_hrs_rf  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if negb (beq_nat (tid_of a) (tid_of b)) &&
              (is_fence a &&
               (is_release a &&
                (is_acquire b &&
                 (set_any
                    (fun (x : action ) =>
                       set_any
                         (fun (y : action ) =>
                            (set_member_by
                               (pairCompare
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))) (a,x)
                               (sb  Xo)) &&
                            ((set_member_by
                                (pairCompare
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))) (x,y)
                                (hypothetical_release_sequence_set_alt Xo Xw))
                             &&
                             (set_member_by
                                (pairCompare
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))) (y,b)
                                (rf  Xw)))) (actions  Xo)) (actions  Xo))))) then
             set_add (a, b) x2 else x2) (actions  Xo) x2) (actions  Xo) 
 x2.
(* [?]: removed value specification. *)

Definition sw_fence_rs_rf_sb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if negb (beq_nat (tid_of a) (tid_of b)) &&
              (is_release a &&
               (is_fence b &&
                (is_acquire b &&
                 (set_any
                    (fun (x : action ) =>
                       set_any
                         (fun (y : action ) =>
                            (set_member_by
                               (pairCompare
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))
                                  (fun (x : action ) (y : action )=>
                                     (genericCompare nat_ltb beq_nat
                                        (aid_of x) (aid_of y)))) (a,x)
                               (release_sequence_set_alt Xo Xw)) &&
                            ((set_member_by
                                (pairCompare
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))) (x,y)
                                (rf  Xw)) &&
                             (set_member_by
                                (pairCompare
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))
                                   (fun (x : action ) (y : action )=>
                                      (genericCompare nat_ltb beq_nat
                                         (aid_of x) (aid_of y)))) (y,b)
                                (sb  Xo)))) (actions  Xo)) (actions  Xo))))) then
             set_add (a, b) x2 else x2) (actions  Xo) x2) (actions  Xo) 
 x2.
(* [?]: removed value specification. *)

Definition release_acquire_fenced_synchronizes_with_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):=  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
  (sw_asw Xo) (sw_lock Xo Xw)) (sw_rel_acq_rs Xo Xw))
  (sw_fence_sb_hrs_rf_sb Xo Xw)) (sw_fence_sb_hrs_rf Xo Xw)) (sw_fence_rs_rf_sb Xo Xw)).
(* [?]: removed value specification. *)

Definition release_acquire_fenced_hb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  no_consume_hb(sb  Xo) (release_acquire_fenced_synchronizes_with_set_alt Xo Xw).
(* [?]: removed value specification. *)

Definition release_acquire_fenced_vse  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  visible_side_effect_set(actions  Xo) (release_acquire_fenced_hb Xo Xw).
(* [?]: removed value specification. *)

Definition release_acquire_fenced_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let hrs   := hypothetical_release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let rs    := release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let sw    := release_acquire_fenced_synchronizes_with_set(actions  Xo)(sb  Xo)(asw  Xo)(rf  Xw)(lo  Xw) rs hrs in
    let hb    := no_consume_hb(sb  Xo) sw in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs)] .
(* [?]: removed value specification. *)

Definition release_acquire_fenced_relations_alt  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    [ ("hb", release_acquire_fenced_hb Xo Xw);
      ("vse", release_acquire_fenced_vse Xo Xw);
      ("sw", release_acquire_fenced_synchronizes_with_set_alt Xo Xw);
      ("rs", release_sequence_set_alt Xo Xw);
      ("hrs", hypothetical_release_sequence_set_alt Xo Xw)] .


(*********************************************** *)


Definition release_acquire_fenced_memory_model   : memory_model := 
  {|consistent := relaxed_only_consistent_execution;relation_calculation := release_acquire_fenced_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := false;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition release_acquire_fenced_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour release_acquire_fenced_memory_model release_acquire_fenced_condition opsem p.
(* [?]: removed value specification. *)

Definition sc_accesses_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire; Relaxed; Seq_cst])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release; Relaxed; Seq_cst])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Acq_rel; Acquire; Release; Relaxed; Seq_cst]))
             | Fence _ _ mo1 =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Release; Acquire; Relaxed])) | Blocked_rmw _ _ _ => true
             | Alloc _ _ _ => false (* CSEM *) | Dealloc _ _ _ =>
             false (* CSEM *) end) (actions  Xo) end) Xs.
(* [?]: removed value specification. *)

Definition sc_accesses_consistent_sc  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    relation_over (actions  Xo) (sc  Xw) &&
    (isTransitive (sc  Xw) &&
     (isIrreflexive (sc  Xw) &&
      set_for_all
        (fun (a : action ) =>
           set_for_all
             (fun (b : action ) =>
                ( ((negb
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (a,b) (sc  Xw))) ||
                   negb
                     ( (set_member_by
                          (pairCompare
                             (fun (x : action ) (y : action )=>
                                (genericCompare nat_ltb beq_nat (aid_of x)
                                   (aid_of y)))
                             (fun (x : action ) (y : action )=>
                                (genericCompare nat_ltb beq_nat (aid_of x)
                                   (aid_of y)))) (b,a)
                          (set_union_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) hb (mo  Xw)))))) &&
                ( Bool.eqb
                    ( (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (a,b) (sc  Xw)) ||
                      (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (b,a) (sc  Xw)))
                    ( (negb ( classical_boolean_equivalence a b)) &&
                      (is_seq_cst a && is_seq_cst b)) )) (actions  Xo))
        (actions  Xo))) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2094, character 1 to line 2102, character 7 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2094, character 1 to line 2102, character 7 *)
  end.
(* [?]: removed value specification. *)

Definition sc_accesses_sc_reads_restricted  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, ("hb", hb)::_)) =>
    set_for_all
      (fun (p : (action *action ) % type) =>
         match ( (p) ) with ( (w, r)) =>
           ((negb (is_seq_cst r)) ||
            (( is_seq_cst w &&
               ((set_member_by
                   (pairCompare
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))
                      (fun (x : action ) (y : action )=>
                         (genericCompare nat_ltb beq_nat (aid_of x)
                            (aid_of y)))) (w,r) (sc  Xw)) &&
                negb
                  (set_any
                     (fun (w' : action ) =>
                        is_write w' &&
                        (( (maybeEqualBy classical_boolean_equivalence
                              (loc_of w) (loc_of w'))) &&
                         ((set_member_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) (w,w') (sc  Xw)) &&
                          (set_member_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) (w',r) (sc  Xw)))))
                     (actions  Xo) )) ) ||
             ( negb (is_seq_cst w) &&
               negb
                 (set_any
                    (fun (w' : action ) =>
                       is_write w' &&
                       (( (maybeEqualBy classical_boolean_equivalence
                             (loc_of w) (loc_of w'))) &&
                        ((set_member_by
                            (pairCompare
                               (fun (x : action ) (y : action )=>
                                  (genericCompare nat_ltb beq_nat (aid_of x)
                                     (aid_of y)))
                               (fun (x : action ) (y : action )=>
                                  (genericCompare nat_ltb beq_nat (aid_of x)
                                     (aid_of y)))) (w,w') hb) &&
                         (set_member_by
                            (pairCompare
                               (fun (x : action ) (y : action )=>
                                  (genericCompare nat_ltb beq_nat (aid_of x)
                                     (aid_of y)))
                               (fun (x : action ) (y : action )=>
                                  (genericCompare nat_ltb beq_nat (aid_of x)
                                     (aid_of y)))) (w',r) (sc  Xw)))))
                    (actions  Xo) ) ))) end) (rf  Xw) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2106, character 1 to line 2115, character 45 *)
    | (( _,  _, ( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2106, character 1 to line 2115, character 45 *)
  end.


Definition sc_accesses_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_mo", Leaf consistent_mo);
         ("sc_accesses_consistent_sc", Leaf sc_accesses_consistent_sc);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("consistent_atomic_rf", Leaf consistent_atomic_rf);
                  ("coherent_memory_use", Leaf coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity);
                  ("sc_accesses_sc_reads_restricted", Leaf sc_accesses_sc_reads_restricted)] )] .


(*********************************************** *)


Definition sc_accesses_memory_model   : memory_model := 
  {|consistent := sc_accesses_consistent_execution;relation_calculation := release_acquire_fenced_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition sc_accesses_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour sc_accesses_memory_model sc_accesses_condition opsem p.
(* [?]: removed value specification. *)

Definition sc_fenced_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire; Relaxed; Seq_cst])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release; Relaxed; Seq_cst])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Acq_rel; Acquire; Release; Relaxed; Seq_cst]))
             | Fence _ _ mo1 =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Release; Acquire; Relaxed; Seq_cst]))
             | Blocked_rmw _ _ _ => true | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.
(* [?]: removed value specification. *)

Definition sc_fenced_sc_fences_heeded  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    set_for_all
      (fun (f : action ) =>
         set_for_all
           (fun (f' : action ) =>
              set_for_all
                (fun (r : action ) =>
                   set_for_all
                     (fun (w : action ) =>
                        set_for_all
                          (fun (w' : action ) =>
                             negb
                               ( is_fence f &&
                                 (is_fence f' &&
                                  ( (* fence restriction N3291 29.3p4 *)
                                    ( (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (w,w')
                                         (mo  Xw)) &&
                                      ((set_member_by
                                          (pairCompare
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))) (w',f)
                                          (sc  Xw)) &&
                                       ((set_member_by
                                           (pairCompare
                                              (fun (x : action ) (y : action )=>
                                                 (genericCompare nat_ltb
                                                    beq_nat (aid_of x)
                                                    (aid_of y)))
                                              (fun (x : action ) (y : action )=>
                                                 (genericCompare nat_ltb
                                                    beq_nat (aid_of x)
                                                    (aid_of y)))) (f,r)
                                           (sb  Xo)) &&
                                        (set_member_by
                                           (pairCompare
                                              (fun (x : action ) (y : action )=>
                                                 (genericCompare nat_ltb
                                                    beq_nat (aid_of x)
                                                    (aid_of y)))
                                              (fun (x : action ) (y : action )=>
                                                 (genericCompare nat_ltb
                                                    beq_nat (aid_of x)
                                                    (aid_of y)))) (w,r)
                                           (rf  Xw)))) ) ||
                                    (
                                    (* fence restriction N3291 29.3p5 *) ( 
                                    (set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (w,w') (mo  Xw)) &&
                                    ((set_member_by
                                        (pairCompare
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y)))
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y))))
                                        (w',f) (sb  Xo)) &&
                                     ((set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (f,r)
                                         (sc  Xw)) &&
                                      (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (w,r)
                                         (rf  Xw)))) ) ||
                                    (
                                    (* fence restriction N3291 29.3p6 *) ( 
                                    (set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (w,w') (mo  Xw)) &&
                                    ((set_member_by
                                        (pairCompare
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y)))
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y))))
                                        (w',f) (sb  Xo)) &&
                                     ((set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (f,f')
                                         (sc  Xw)) &&
                                      ((set_member_by
                                          (pairCompare
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))) (f',r)
                                          (sb  Xo)) &&
                                       (set_member_by
                                          (pairCompare
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))) (w,r)
                                          (rf  Xw))))) ) ||
                                    (
                                    (* SC fences impose mo N3291 29.3p7 *) ( 
                                    (set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (w',f) (sb  Xo)) &&
                                    ((set_member_by
                                        (pairCompare
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y)))
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y))))
                                        (f,f') (sc  Xw)) &&
                                     ((set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (f',w)
                                         (sb  Xo)) &&
                                      (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (w,w')
                                         (mo  Xw)))) ) ||
                                    (
                                    (* N3291 29.3p7, w collapsed first write*) ( 
                                    (set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (w',f) (sc  Xw)) &&
                                    ((set_member_by
                                        (pairCompare
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y)))
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y))))
                                        (f,w) (sb  Xo)) &&
                                     (set_member_by
                                        (pairCompare
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y)))
                                           (fun (x : action ) (y : action )=>
                                              (genericCompare nat_ltb 
                                               beq_nat (aid_of x) (aid_of y))))
                                        (w,w') (mo  Xw))) ) ||
                                    (* N3291 29.3p7, w collapsed second write*)
                                    ( (set_member_by
                                         (pairCompare
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))
                                            (fun (x : action ) (y : action )=>
                                               (genericCompare nat_ltb
                                                  beq_nat (aid_of x)
                                                  (aid_of y)))) (w',f)
                                         (sb  Xo)) &&
                                      ((set_member_by
                                          (pairCompare
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))) (f,w)
                                          (sc  Xw)) &&
                                       (set_member_by
                                          (pairCompare
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))) (w,w')
                                          (mo  Xw))) ))))) )) ))
                          (actions  Xo)) (actions  Xo)) (actions  Xo))
           (actions  Xo)) (actions  Xo) end.

Definition sc_fenced_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_mo", Leaf consistent_mo);
         ("sc_accesses_consistent_sc", Leaf sc_accesses_consistent_sc);
         ("sc_fenced_sc_fences_heeded", Leaf sc_fenced_sc_fences_heeded);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("consistent_atomic_rf", Leaf consistent_atomic_rf);
                  ("coherent_memory_use", Leaf coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity);
                  ("sc_accesses_sc_reads_restricted", Leaf sc_accesses_sc_reads_restricted)] )] .


(*********************************************** *)

Definition sc_fenced_memory_model   : memory_model := 
  {|consistent := sc_fenced_consistent_execution;relation_calculation := release_acquire_fenced_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition sc_fenced_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour sc_fenced_memory_model sc_fenced_condition opsem p.
(* [?]: removed value specification. *)


(* For backward compatibility we inline "true_condition" for non-csem
   users. *)

Definition with_consume_condition   (Xs:set  candidate_execution )  : bool :=  (* CSEM *)
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      (* CSEM *) set_for_all
        (fun (a : action ) =>
           (* CSEM *) match ( a) with (* CSEM *) | Lock _ _ _ _ =>
             true (* CSEM *) | Unlock _ _ _ => true (* CSEM *)
             | Load _ _ mo1 _ _ => true (* CSEM *) | Store _ _ mo1 _ _ =>
             true (* CSEM *) | RMW _ _ mo1 _ _ _ => true (* CSEM *)
             | Fence _ _ mo1 => true (* CSEM *) | Blocked_rmw _ _ _ =>
             true (* CSEM *) | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.                                                 (* CSEM *)

Definition with_consume_cad_set {a b : Type} `{Eq a} `{SetType a}  (actions1 : b) (sb1 : set ((a*a) % type)) (dd1 : set ((a*a) % type)) (rf1 : set ((a*a) % type))  : set ((a*a) % type):=  (set_tc (fun x y => x = y) ( (set_union_by (pairCompare setElemCompare setElemCompare) ( (set_inter_by (pairCompare setElemCompare setElemCompare)rf1 sb1)) dd1) )).
(* [?]: removed value specification. *)

Definition with_consume_cad_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  with_consume_cad_set(actions  Xo)(sb  Xo)(dd  Xo)(rf  Xw).

Definition with_consume_dob  (actions1 : set (action )) (rf1 : set ((action *action ) % type)) (rs : set ((action *action ) % type)) (cad : set ((action *action ) % type)) (w : action ) (a : action )  : bool :=  negb (beq_nat (tid_of w) (tid_of a)) &&
    set_any  (fun (w' : action ) =>
    set_any
      (fun (r : action ) =>
         is_consume r &&
         ((set_member_by
             (pairCompare
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
             (w,w') rs) &&
          ((set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (w',r) rf1) &&
           ( (set_member_by
                (pairCompare
                   (fun (x : action ) (y : action )=>
                      (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                   (fun (x : action ) (y : action )=>
                      (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
                (r,a) cad) || ( classical_boolean_equivalence r a) ))))
      actions1) actions1.


Definition dependency_ordered_before  (actions1 : set (action )) (rf1 : set ((action *action ) % type)) (rs : set ((action *action ) % type)) (cad : set ((action *action ) % type)) (a : action ) (d : action )  : bool :=  (set_member_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
     a actions1) && ((set_member_by (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) d actions1) &&
     ( set_any  (fun (b : action ) =>
    is_release a &&
    (is_consume b &&
     ((set_any
         (fun (e : action ) =>
            (set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (a,e) rs) &&
            (set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (e,b) rf1)) actions1) &&
      ( (set_member_by
           (pairCompare
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
           (b,d) cad) || ( classical_boolean_equivalence b d) )))) actions1 )).


Definition with_consume_dob_set  (actions1 : set (action )) (rf1 : set ((action *action ) % type)) (rs : set ((action *action ) % type)) (cad : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if dependency_ordered_before actions1 rf1 rs cad a b then
             set_add (a,b) x2 else x2) actions1 x2) actions1 x2.
(* [?]: removed value specification. *)

Definition with_consume_dob_set_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  with_consume_dob_set(actions  Xo)(rf  
                       Xw) 
                       (release_sequence_set_alt Xo Xw) 
                       (with_consume_cad_set_alt Xo Xw).


Definition compose {a b c : Type} `{Eq a} `{SetType b} `{SetType c}  (R1 : set ((b*a) % type)) (R2 : set ((a*c) % type))  : set ((b*c) % type):= 
    let x2  := [] in set_fold
   (fun (p : (b*a) % type) (x2 : set ((b*c) % type)) =>
      match ( (p ,x2) ) with ((w, x) ,  x2) =>
        set_fold
          (fun (p : (a*c) % type) (x2 : set ((b*c) % type)) =>
             match ( (p ,x2) ) with ((y, z) ,  x2) =>
               if (x = y) then set_add (w,z) x2 else x2 end) R2 x2 end) 
 R1 x2.


Definition inter_thread_happens_before {a b : Type} `{Eq a} `{SetType a}  (actions1 : b) (sb1 : set ((a*a) % type)) (sw : set ((a*a) % type)) (dob : set ((a*a) % type))  : set ((a*a) % type):= 
    let r  := (set_union_by (pairCompare setElemCompare setElemCompare) (set_union_by (pairCompare setElemCompare setElemCompare) sw dob) (compose sw sb1)) in
      (set_tc (fun x y => x = y) ( (set_union_by (pairCompare setElemCompare setElemCompare)r (compose sb1 r)))).
(* [?]: removed value specification. *)

Definition inter_thread_happens_before_r  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) 
  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
        (release_acquire_fenced_synchronizes_with_set_alt Xo Xw) (with_consume_dob_set_alt Xo Xw)) (compose (release_acquire_fenced_synchronizes_with_set_alt Xo Xw) ((sb Xo)))).
(* [?]: removed value specification. *)

Definition inter_thread_happens_before_step  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):=  (set_union_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
  (inter_thread_happens_before_r Xo Xw) (compose(sb  Xo) (inter_thread_happens_before_r Xo Xw))).
(* [?]: removed value specification. *)

Definition inter_thread_happens_before_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  (set_tc (fun (a1 : action ) (a2 : action )=>classical_boolean_equivalence a1 a2) (inter_thread_happens_before_step Xo Xw)).

Definition happens_before {a b : Type} `{SetType a}  (actions1 : b) (sb1 : set a) (ithb : set a)  : set a:=  (set_union_by setElemCompare
    sb1 ithb).
(* [?]: removed value specification. *)

Definition with_consume_hb  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  happens_before(actions  Xo)(sb  Xo) (inter_thread_happens_before_alt Xo Xw).
(* [?]: removed value specification. *)

Definition with_consume_vse  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  visible_side_effect_set(actions  Xo) (with_consume_hb Xo Xw).
(* [?]: removed value specification. *)

Definition with_consume_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let hrs   := hypothetical_release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let rs    := release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let sw    := release_acquire_fenced_synchronizes_with_set(actions  Xo)(sb  Xo)(asw  Xo)(rf  Xw)(lo  Xw) rs hrs in
    let cad   := with_consume_cad_set(actions  Xo)(sb  Xo)(dd  Xo)(rf  Xw) in
    let dob   := with_consume_dob_set(actions  Xo)(rf  Xw) rs cad in
    let ithb  := inter_thread_happens_before(actions  Xo)(sb  Xo) sw dob in
    let hb    := happens_before(actions  Xo)(sb  Xo) ithb in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs);
      ("dob", dob);
      ("cad", cad)] .
(* [?]: removed value specification. *)

Definition with_consume_relations_alt  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    [ ("hb", with_consume_hb Xo Xw);
      ("vse", with_consume_vse Xo Xw);
      ("ithb", inter_thread_happens_before_alt Xo Xw);
      ("sw", release_acquire_fenced_synchronizes_with_set_alt Xo Xw);
      ("rs", release_sequence_set_alt Xo Xw);
      ("hrs", hypothetical_release_sequence_set_alt Xo Xw);
      ("dob", with_consume_dob_set_alt Xo Xw);
      ("cad", with_consume_cad_set_alt Xo Xw)] .

Definition with_consume_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_mo", Leaf consistent_mo);
         ("sc_accesses_consistent_sc", Leaf sc_accesses_consistent_sc);
         ("sc_fenced_sc_fences_heeded", Leaf sc_fenced_sc_fences_heeded);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("consistent_atomic_rf", Leaf consistent_atomic_rf);
                  ("coherent_memory_use", Leaf coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity);
                  ("sc_accesses_sc_reads_restricted", Leaf sc_accesses_sc_reads_restricted)] )] .


(*********************************************** *)


Definition with_consume_memory_model   : memory_model := 
  {|consistent := with_consume_consistent_execution;relation_calculation := with_consume_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition with_consume_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour with_consume_memory_model with_consume_condition opsem p.



(*********************************************** *)
(* 12 - the standard model *)
(*********************************************** *)

Definition dummy12   : bool :=  true.

Definition standard_vsses  (actions1 : set (action )) (lk1 : tt  -> location_kind ) (mo1 : set ((action *action ) % type)) (hb : set ((action *action ) % type)) (vse : set ((action *action ) % type))  : set ((action *action ) % type):= 
  let x2 := [] in set_fold
   (fun (v : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (r : action ) (x2 : set ((action *action ) % type)) =>
           set_fold
             (fun (head1 : action ) (x2 : set ((action *action ) % type)) =>
                if
                is_at_atomic_location lk1 r &&
                ((set_member_by
                    (pairCompare
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))) (head1,r) vse) &&
                 (negb
                    (set_any
                       (fun (v' : action ) =>
                          (set_member_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) (v',r) vse) &&
                          (set_member_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) (head1,v') mo1)) 
                     actions1) &&
                  ( ( classical_boolean_equivalence v head1) ||
                    ( (set_member_by
                         (pairCompare
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))
                            (fun (x : action ) (y : action )=>
                               (genericCompare nat_ltb beq_nat (aid_of x)
                                  (aid_of y)))) (head1,v) mo1) &&
                      (negb
                         ( (set_member_by
                              (pairCompare
                                 (fun (x : action ) (y : action )=>
                                    (genericCompare nat_ltb beq_nat
                                       (aid_of x) (aid_of y)))
                                 (fun (x : action ) (y : action )=>
                                    (genericCompare nat_ltb beq_nat
                                       (aid_of x) (aid_of y)))) (r,v) 
                            hb)) &&
                       set_for_all
                         (fun (w : action ) =>
                            ((negb
                                ( (set_member_by
                                     (pairCompare
                                        (fun (x : action ) (y : action )=>
                                           (genericCompare nat_ltb beq_nat
                                              (aid_of x) (aid_of y)))
                                        (fun (x : action ) (y : action )=>
                                           (genericCompare nat_ltb beq_nat
                                              (aid_of x) (aid_of y))))
                                     (head1,w) mo1) &&
                                  (set_member_by
                                     (pairCompare
                                        (fun (x : action ) (y : action )=>
                                           (genericCompare nat_ltb beq_nat
                                              (aid_of x) (aid_of y)))
                                        (fun (x : action ) (y : action )=>
                                           (genericCompare nat_ltb beq_nat
                                              (aid_of x) (aid_of y)))) 
                                   (w,v) mo1))) ||
                             negb
                               ( (set_member_by
                                    (pairCompare
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))
                                       (fun (x : action ) (y : action )=>
                                          (genericCompare nat_ltb beq_nat
                                             (aid_of x) (aid_of y)))) 
                                  (r,w) hb)))) actions1) ) ))) then
                  set_add (v,r) x2 else x2) actions1 x2) actions1 x2)
   actions1 x2.
(* [?]: removed value specification. *)

Definition standard_vsses_alt  (Xo : pre_execution ) (Xw : execution_witness )  : set ((action *action ) % type):= 
  standard_vsses(actions  Xo)(lk  
                 Xo)(mo  
                 Xw) 
                 (with_consume_hb Xo Xw) 
                 (with_consume_vse Xo Xw).

Definition standard_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let hrs   := hypothetical_release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let rs    := release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let sw    := release_acquire_fenced_synchronizes_with_set(actions  Xo)(sb  Xo)(asw  Xo)(rf  Xw)(lo  Xw) rs hrs in
    let cad   := with_consume_cad_set(actions  Xo)(sb  Xo)(dd  Xo)(rf  Xw) in
    let dob   := with_consume_dob_set(actions  Xo)(rf  Xw) rs cad in
    let ithb  := inter_thread_happens_before(actions  Xo)(sb  Xo) sw dob in
    let hb    := happens_before(actions  Xo)(sb  Xo) ithb in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    let vsses := standard_vsses(actions  Xo)(lk  Xo)(mo  Xw) hb vse in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("vsses", vsses);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs);
      ("dob", dob);
      ("cad", cad)] .
(* [?]: removed value specification. *)

Definition standard_relations_alt  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    [ ("hb", with_consume_hb Xo Xw);
      ("vse", with_consume_vse Xo Xw);
      ("ithb", inter_thread_happens_before_alt Xo Xw);
      ("vsses", standard_vsses_alt Xo Xw);
      ("sw", release_acquire_fenced_synchronizes_with_set_alt Xo Xw);
      ("rs", release_sequence_set_alt Xo Xw);
      ("hrs", hypothetical_release_sequence_set_alt Xo Xw);
      ("dob", with_consume_dob_set_alt Xo Xw);
      ("cad", with_consume_cad_set_alt Xo Xw)] .
(* [?]: removed value specification. *)

Definition standard_consistent_atomic_rf  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _::_::_::("vsses", vsses)::_)) =>
    set_for_all
      (fun (p : (action *action ) % type) =>
         match ( (p) ) with ( (w, r)) =>
           ((negb (is_at_atomic_location (lk  Xo) r && is_load r)) ||
            (set_member_by
               (pairCompare
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                  (fun (x : action ) (y : action )=>
                     (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
               (w,r) vsses)) end) (rf  Xw) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2491, character 1 to line 2493, character 22 *)
    | (( _,  _,  _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2491, character 1 to line 2493, character 22 *)
    | (( _,  _,  _:: _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2491, character 1 to line 2493, character 22 *)
    | (( _,  _,  _:: _:: _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2491, character 1 to line 2493, character 22 *)
    | (( _,  _,  _:: _:: _::( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2491, character 1 to line 2493, character 22 *)
  end.


Definition standard_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("locks_only_consistent_locks", Leaf locks_only_consistent_locks);
         ("locks_only_consistent_lo", Leaf locks_only_consistent_lo);
         ("consistent_mo", Leaf consistent_mo);
         ("sc_accesses_consistent_sc", Leaf sc_accesses_consistent_sc);
         ("sc_fenced_sc_fences_heeded", Leaf sc_fenced_sc_fences_heeded);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("standard_consistent_atomic_rf",
                     Leaf standard_consistent_atomic_rf);
                  ("coherent_memory_use", Leaf coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity);
                  ("sc_accesses_sc_reads_restricted",
                     Leaf sc_accesses_sc_reads_restricted)] )] .


(*********************************************** *)


Definition standard_memory_model   : memory_model := 
  {|consistent := standard_consistent_execution;relation_calculation := standard_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition standard_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour standard_memory_model with_consume_condition opsem p.
(* [?]: removed value specification. *)

Definition release_acquire_SC_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      atomic_initialisation_first (Xo,Xw,rl) &&
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire; Seq_cst])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release; Seq_cst])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Acq_rel; Seq_cst])) | Fence _ _ mo1 =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Seq_cst])) | Blocked_rmw _ _ _ => true | Alloc _ _ _ =>
             false (* CSEM *) | Dealloc _ _ _ => false (* CSEM *) end)
        (actions  Xo) end) Xs.

(*********************************************** *)



Definition release_acquire_SC_memory_model   : memory_model := 
  {|consistent := sc_fenced_consistent_execution;relation_calculation := release_acquire_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition release_acquire_SC_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour release_acquire_SC_memory_model release_acquire_SC_condition opsem p.
(* [?]: removed value specification. *)

Definition release_acquire_SC_rf_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : rf_program_behaviours := 
  rf_behaviour release_acquire_SC_memory_model release_acquire_SC_condition opsem p.
(* [?]: removed value specification. *)

Definition SC_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      atomic_initialisation_first (Xo,Xw,rl) &&
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Seq_cst])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Seq_cst])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Seq_cst])) | Fence _ _ mo1 => false
             | Blocked_rmw _ _ _ => true | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.

(*********************************************** *)



Definition SC_memory_model   : memory_model := 
  {|consistent := sc_accesses_consistent_execution;relation_calculation := release_acquire_relations;undefined := locks_only_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition SC_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour SC_memory_model SC_condition opsem p.
(* [?]: removed value specification. *)

Definition atomic_initialisation_before_all  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, _, _)) =>
    set_for_all
      (fun (a : action ) =>
         set_for_all
           (fun (b : action ) =>
              ((negb
                  (is_at_atomic_location (lk  Xo) a &&
                   (is_NA_store a &&
                    (( (maybeEqualBy classical_boolean_equivalence (loc_of a)
                          (loc_of b))) &&
                     ( ((fun (x : action ) (y : action ) =>
                           negb (classical_boolean_equivalence x y)) 
                        a b)))))) ||
               (( (set_member_by
                     (pairCompare
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))
                        (fun (x : action ) (y : action )=>
                           (genericCompare nat_ltb beq_nat (aid_of x)
                              (aid_of y)))) (a,b)
                     (set_tc
                        (fun (a1 : action ) (a2 : action )=>
                           classical_boolean_equivalence a1 a2)
                        ( (set_union_by
                             (pairCompare
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))
                                (fun (x : action ) (y : action )=>
                                   (genericCompare nat_ltb beq_nat (aid_of x)
                                      (aid_of y)))) (sb Xo) (asw  Xo)))))) &&
                negb (is_NA_store b)))) (actions  Xo)) (actions  Xo) end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition tot_condition   (Xs:set  candidate_execution )  : bool := 
  BOOM Xs &&
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      atomic_initialisation_before_all (Xo,Xw,rl) &&
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => true | Unlock _ _ _ => true
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Seq_cst])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Seq_cst])) | RMW _ _ mo1 _ _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [Seq_cst])) | Fence _ _ mo1 => false
             | Blocked_rmw _ _ _ => true | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.



Definition tot_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let vse   := visible_side_effect_set(actions  Xo)(tot  Xw) in
    [ ("empty", []);
      ("vse", vse) ]
    .
(* [?]: removed value specification. *)

Definition tot_det_read  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _::("vse", vse)::_)) =>
    set_for_all
      (fun (r : action ) =>
         Bool.eqb
           (set_any
              (fun (w : action ) =>
                 (set_member_by
                    (pairCompare
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))) (w,r) vse)) (actions  Xo))
           (set_any
              (fun (w' : action ) =>
                 (set_member_by
                    (pairCompare
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))
                       (fun (x : action ) (y : action )=>
                          (genericCompare nat_ltb beq_nat (aid_of x)
                             (aid_of y)))) (w',r) (rf  Xw))) (actions  Xo)))
      (actions  Xo) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2688, character 1 to line 2691, character 50 *)
    | (( _,  _,  _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2688, character 1 to line 2691, character 50 *)
    | (( _,  _,  _::( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2688, character 1 to line 2691, character 50 *)
  end.
(* [?]: removed value specification. *)

Definition tot_consistent_rf  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _::("vse", vse)::_)) =>
    set_for_all
      (fun (p : (action *action ) % type) =>
         match ( (p) ) with ( (w, r)) =>
           (set_member_by
              (pairCompare
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
                 (fun (x : action ) (y : action )=>
                    (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
              (w,r) vse) end) (rf  Xw) | (( _,  _, [])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2694, character 1 to line 2695, character 41 *)
    | (( _,  _,  _::[])) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2694, character 1 to line 2695, character 41 *)
    | (( _,  _,  _::( _,  _):: _)) =>
    bool_default (* Incomplete Pattern at File \"ocaml_generated/cmm_csem.lem\", line 2694, character 1 to line 2695, character 41 *)
  end.
(* [?]: removed value specification. *)

Definition tot_consistent_locks  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    (set_for_all
       (fun (p : (action *action ) % type) =>
          match ( (p) ) with ( (a, c)) =>
            ((negb
                (is_successful_lock a &&
                 (is_successful_lock c &&
                  ( (maybeEqualBy classical_boolean_equivalence (loc_of a)
                       (loc_of c)))))) ||
             (set_any
                (fun (b : action ) =>
                   ( (maybeEqualBy classical_boolean_equivalence (loc_of a)
                        (loc_of b))) &&
                   (is_unlock b &&
                    ((set_member_by
                        (pairCompare
                           (fun (x : action ) (y : action )=>
                              (genericCompare nat_ltb beq_nat (aid_of x)
                                 (aid_of y)))
                           (fun (x : action ) (y : action )=>
                              (genericCompare nat_ltb beq_nat (aid_of x)
                                 (aid_of y)))) (a,b) (tot  Xw)) &&
                     (set_member_by
                        (pairCompare
                           (fun (x : action ) (y : action )=>
                              (genericCompare nat_ltb beq_nat (aid_of x)
                                 (aid_of y)))
                           (fun (x : action ) (y : action )=>
                              (genericCompare nat_ltb beq_nat (aid_of x)
                                 (aid_of y)))) (b,c) (tot  Xw)))))
                (actions  Xo))) end) (tot  Xw)) end.
(* [?]: removed value specification. *)

Definition tot_consistent_tot  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    relation_over (actions  Xo) (tot  Xw) &&
    (isTransitive (tot  Xw) &&
     (isIrreflexive (tot  Xw) &&
      (isTrichotomousOn (tot  Xw) (actions  Xo) &&
       ((set_subset_by
           (pairCompare
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
              (fun (x : action ) (y : action )=>
                 (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
           (sb  Xo) (tot  Xw)) &&
        ((set_subset_by
            (pairCompare
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))
            (asw  Xo) (tot  Xw)) && finite_prefixes (tot  Xw) (actions  Xo))))))
  end.
(* [?]: removed value specification. *)

Definition tot_assumptions  (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) => finite_prefixes (rf  Xw) (actions  Xo)
  end.



Definition tot_consistent_execution   : named_predicate_tree := 
  Node [ ("tot_assumptions", Leaf tot_assumptions);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("tot_conistent_tot", Leaf tot_consistent_tot);
         ("tot_consistent_locks", Leaf tot_consistent_locks);
         ("consistent_rf",
           Node [ ("det_read", Leaf tot_det_read);
                  ("tot_consistent_rf", Leaf tot_consistent_rf)]
                )
         ]
       .



Definition tot_bad_mutexes {a : Type}  (p : (pre_execution *execution_witness *a) % type)  : set (action ):= 
  match ( (p)) with ( (Xo, Xw, _)) =>
    let x2 := [] in set_fold
                      (fun (a : action ) (x2 : set (action )) =>
                         if
                         let lo1 := let x2 := [] in set_fold
                                                      (fun (a : action ) (x2 : set ((action *action ) % type)) =>
                                                         set_fold
                                                           (fun (b : action ) (x2 : set ((action *action ) % type)) =>
                                                              if
                                                              ( (set_member_by
                                                                   (pairCompare
                                                                    (
                                                                    fun (x : action ) (y : action )=>
                                                                    (genericCompare
                                                                    nat_ltb
                                                                    beq_nat
                                                                    (
                                                                    aid_of x)
                                                                    (
                                                                    aid_of y)))
                                                                    (
                                                                    fun (x : action ) (y : action )=>
                                                                    (genericCompare
                                                                    nat_ltb
                                                                    beq_nat
                                                                    (
                                                                    aid_of x)
                                                                    (
                                                                    aid_of y))))
                                                                   (a,b)
                                                                   (tot  Xw)))
                                                              &&
                                                              (( (maybeEqualBy
                                                                    classical_boolean_equivalence
                                                                    (
                                                                    loc_of a)
                                                                    (
                                                                    loc_of b)))
                                                               &&
                                                               is_at_mutex_location
                                                                 (lk  Xo) 
                                                               a) then
                                                                set_add 
                                                                (a,b) 
                                                                x2 else 
                                                              x2)
                                                           (actions  Xo) 
                                                         x2) (actions  Xo) 
                                                    x2 in
                         negb
                           (locks_only_good_mutex_use (actions  Xo) (lk  Xo)
                              (sb  Xo) lo1 a) then set_add a x2 else 
                         x2) (actions  Xo) x2 end.


Definition tot_data_races {a : Type}  (p : (pre_execution *execution_witness *a) % type)  : set ((action *action ) % type):= 
  match ( (p)) with ( (Xo, Xw, _)) =>
    let x2 := [] in set_fold
                      (fun (a : action ) (x2 : set ((action *action ) % type)) =>
                         set_fold
                           (fun (b : action ) (x2 : set ((action *action ) % type)) =>
                              if
                              negb ( classical_boolean_equivalence a b) &&
                              (( (maybeEqualBy classical_boolean_equivalence
                                    (loc_of a) (loc_of b))) &&
                               ((is_write a || is_write b) &&
                                (( negb (beq_nat (tid_of a) (tid_of b))) &&
                                 (negb
                                    (is_atomic_action a && is_atomic_action b)
                                  &&
                                  (negb
                                     ( (set_member_by
                                          (pairCompare
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))
                                             (fun (x : action ) (y : action )=>
                                                (genericCompare nat_ltb
                                                   beq_nat (aid_of x)
                                                   (aid_of y)))) (a,b)
                                          (asw  Xo))) &&
                                   ((set_member_by
                                       (pairCompare
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y)))
                                          (fun (x : action ) (y : action )=>
                                             (genericCompare nat_ltb 
                                              beq_nat (aid_of x) (aid_of y))))
                                       (a,b) (tot  Xw)) &&
                                    negb
                                      (set_any
                                         (fun (c : action ) =>
                                            ( (set_member_by
                                                 (pairCompare
                                                    (fun (x : action ) (y : action )=>
                                                       (genericCompare
                                                          nat_ltb beq_nat
                                                          (aid_of x)
                                                          (aid_of y)))
                                                    (fun (x : action ) (y : action )=>
                                                       (genericCompare
                                                          nat_ltb beq_nat
                                                          (aid_of x)
                                                          (aid_of y)))) 
                                               (a,c) (tot  Xw))) &&
                                            ( (set_member_by
                                                 (pairCompare
                                                    (fun (x : action ) (y : action )=>
                                                       (genericCompare
                                                          nat_ltb beq_nat
                                                          (aid_of x)
                                                          (aid_of y)))
                                                    (fun (x : action ) (y : action )=>
                                                       (genericCompare
                                                          nat_ltb beq_nat
                                                          (aid_of x)
                                                          (aid_of y)))) 
                                               (c,b) (tot  Xw))))
                                         (actions  Xo)))))))) then
                                set_add (a,b) x2 else x2) (actions  Xo) 
                         x2) (actions  Xo) x2 end.



Definition tot_undefined_behaviour   : list (fault_setgen ):= 
  [ Two ("unsequenced_races", unsequenced_races);
    Two ("data_races", tot_data_races);
    One ("indeterminate_reads", indeterminate_reads);
    One ("tot_bad_mutexes", tot_bad_mutexes)] .



(*********************************************** *)




Definition tot_memory_model   : memory_model := 
  {|consistent := tot_consistent_execution;relation_calculation := tot_relations;undefined := tot_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := false;sc_flag  := false;lo_flag  := false;tot_flag := true |}
  |}.
(* [?]: removed value specification. *)

Definition tot_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour tot_memory_model tot_condition opsem p.
(* [?]: removed value specification. *)

Definition tot_rf_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : rf_program_behaviours := 
  rf_behaviour tot_memory_model tot_condition opsem p.
(* [?]: removed value specification. *)

Definition 
cond  (opsem : program  -> pre_execution  -> bool ) (p : nat )  : bool :=  statically_satisfied sc_fenced_condition opsem p.

Definition M1   : memory_model :=  tot_memory_model.
Definition M2   : memory_model :=  tot_memory_model.
Definition P1   : set (candidate_execution ) -> bool :=  tot_condition.
Definition P2   : set (candidate_execution ) -> bool :=  tot_condition.
(* [?]: removed value specification. *)

Definition release_acquire_no_locks_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => false | Unlock _ _ _ => false
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release])) | RMW _ _ mo1 _ _ _ =>
             classical_boolean_equivalence mo1 Acq_rel | Fence _ _ _ => false
             | Blocked_rmw _ _ _ => true | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.


Definition release_acquire_no_locks_synchronizes_with {a b : Type}  (actions1 : a) (sb1 : b) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type)) (a1 : action ) (b1 : action )  : bool := 
  ( negb (beq_nat (tid_of a1) (tid_of b1))) &&
  ( (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (* thread sync *)
    (a1,b1) asw1) ||
    (* rel/acq sync *)
    ( is_release a1 && (is_acquire b1 && (set_member_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y)))) (a1,b1) rf1)) )
  ).

Definition release_acquire_no_locks_synchronizes_with_set {a : Type}  (actions1 : set (action )) (sb1 : a) (asw1 : set ((action *action ) % type)) (rf1 : set ((action *action ) % type))  : set ((action *action ) % type):= 
    let x2 := [] in set_fold
   (fun (a : action ) (x2 : set ((action *action ) % type)) =>
      set_fold
        (fun (b : action ) (x2 : set ((action *action ) % type)) =>
           if
           release_acquire_no_locks_synchronizes_with actions1 sb1 asw1 
           rf1 a b then set_add (a,b) x2 else x2) actions1 x2) actions1 
 x2.

Definition release_acquire_no_locks_relations  (Xo : pre_execution ) (Xw : execution_witness )  : list ((string *set ((action *action ) % type)) % type):= 
    let sw    := release_acquire_no_locks_synchronizes_with_set(actions 
                  Xo)(sb  Xo)(asw  Xo)(rf  Xw) in
    let hb    := no_consume_hb(sb  Xo) sw in
    let vse   := visible_side_effect_set(actions  Xo) hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw)] .


Definition sc_lo_empty {a b : Type}  (p : (b*execution_witness *a) % type)  : bool := 
  match ( (p)) with ( (_, Xw, _)) =>
    set_is_empty (sc  Xw) && set_is_empty (lo  Xw) end.


Definition release_acquire_no_locks_consistent_execution   : named_predicate_tree := 
  Node [ ("assumptions", Leaf assumptions);
         ("sc_lo_empty", Leaf sc_empty);
         ("tot_empty", Leaf tot_empty);
         ("well_formed_threads", Leaf well_formed_threads);
         ("well_formed_rf", Leaf well_formed_rf);
         ("consistent_mo", Leaf consistent_mo);
         ("consistent_hb", Leaf consistent_hb);
         ("consistent_rf",
           Node [ ("det_read", Leaf det_read);
                  ("consistent_non_atomic_rf", Leaf consistent_non_atomic_rf);
                  ("consistent_atomic_rf", Leaf consistent_atomic_rf);
                  ("coherent_memory_use", Leaf coherent_memory_use);
                  ("rmw_atomicity", Leaf rmw_atomicity)] )] .


(*********************************************** *)

Definition release_acquire_no_locks_undefined_behaviour   : list (fault_setgen ):= 
  [ Two ("unsequenced_races", unsequenced_races);
    Two ("data_races", data_races);
    One ("indeterminate_reads", indeterminate_reads) ] .



Definition release_acquire_no_locks_memory_model   : memory_model := 
  {|consistent := release_acquire_no_locks_consistent_execution;relation_calculation := release_acquire_no_locks_relations;undefined := release_acquire_no_locks_undefined_behaviour;relation_flags :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := false;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition release_acquire_no_locks_behaviour  (opsem : program  -> pre_execution  -> bool )  (p : program )  : program_behaviours := 
  behaviour release_acquire_no_locks_memory_model release_acquire_no_locks_condition opsem p.
(* [?]: removed value specification. *)

Definition release_acquire_lifetime_no_locks_condition   (Xs:set  candidate_execution )  : bool := 
  set_for_all  (fun (p : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type) =>
    match ( (p) ) with ( (Xo, Xw, rl)) =>
      set_for_all
        (fun (a : action ) =>
           match ( a) with | Lock _ _ _ _ => false | Unlock _ _ _ => false
             | Load _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Acquire])) | Store _ _ mo1 _ _ =>
             ( (set_member_by
                  (fun (x : memory_order ) (y : memory_order )=> EQ) 
                mo1 [NA; Release])) | RMW _ _ mo1 _ _ _ =>
             classical_boolean_equivalence mo1 Acq_rel | Fence _ _ _ => false
             | Blocked_rmw _ _ _ => true | Alloc _ _ _ => false (* CSEM *)
             | Dealloc _ _ _ => false (* CSEM *) end) (actions  Xo) end) Xs.

(*********************************************** *)     

(*
(* 6.2.4 p2: "If an object is referred to outside of its lifetime, the behavior is undefined." 
   together with 7.22.3 p1 "The lifetime of an allocated object extends from the allocation until the deallocation." *)
let reads_outside_lifetime (Xo,Xw,("hb",hb)::_) =
    { a | forall (a IN Xo.actions) |
     not (exists (b IN Xo.actions). is_alloc b && (loc_of a = loc_of b) && (b, a) IN hb) ||
     (exists (b IN Xo.actions). is_dealloc b && (loc_of a = loc_of b) && not ((a, b) IN hb))}

(* 7.22.3.3 p2 (similar to C++ 18.6.1.3) says that Deallocs without a 
  happens before Alloc are undefined and that a Dealloc that happens after 
  another Dealloc is undefined. The standard does not say anything about Deallocs that 
  are hb-unrelated. We have decided to treat that as undefined behaviour. *)
let bad_deallocs (Xo,Xw,("hb",hb)::_) =
    { a | forall (a IN Xo.actions) |
      is_dealloc a && ((not (exists (b IN Xo.actions). is_alloc b && (b, a) IN hb)) || 
                    (exists (c IN Xo.actions). is_dealloc c && a <> c))}
      
let release_acquire_lifetime_no_locks_undefined_behaviour =
  [ Two ("unsequenced_races", unsequenced_races);
    Two ("data_races", data_races);
    One ("indeterminate_reads", indeterminate_reads);
    One ("reads_outside_lifetime", reads_outside_lifetime);
    One ("bad_deallocs", bad_deallocs); ]

let release_acquire_lifetime_no_locks_memory_model =
  <| consistent = release_acquire_no_locks_consistent_execution;
     relation_calculation = release_acquire_no_locks_relations;
     undefined = release_acquire_lifetime_no_locks_undefined_behaviour;
     relation_flags =
       <|  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = true;
           tot_flag = false |>
  |>

val release_acquire_lifetime_no_locks_behaviour : forall. opsem_t -> program -> program_behaviours
let {hol; isabelle; tex; coq}release_acquire_lifetime_no_locks_behaviour  opsem (p : program) =
  behaviour release_acquire_lifetime_no_locks_memory_model release_acquire_lifetime_no_locks_condition opsem p

*)


(*********************************************** *)
(* 19 - overlap - memory_model where writes and reads can have
   distinct but overlapping footprints. *)
(*********************************************** *)

(* Footprints *)

Definition footprint0 : Type :=  footprint_impl .
Definition footprint0_default: footprint0  := footprint_impl_default.
(* [?]: removed value specification. *)

Definition footprint_of_loc   : location_impl  -> footprint_impl :=  footprint_of_loc_impl.
(* [?]: removed value specification. *)

Definition footprint_leq0   : footprint_impl  -> footprint_impl  -> bool :=  footprint_leq_impl.
(* [?]: removed value specification. *)

Definition footprint_empty   : footprint_impl :=  footprint_empty_impl.
(* [?]: removed value specification. *)

Definition footprint_is_empty   : footprint_impl  -> bool :=  footprint_is_empty_impl.
(* [?]: removed value specification. *)

Definition footprint_difference   : footprint_impl  -> footprint_impl  -> footprint_impl :=  footprint_difference_impl.
(* [?]: removed value specification. *)

Definition footprint_intersection   : footprint_impl  -> footprint_impl  -> footprint_impl :=  footprint_intersection_impl.
(* [?]: removed value specification. *)

Definition footprint_bigunion   : set (footprint_impl ) -> footprint_impl :=  footprint_bigunion_impl.
(* [?]: removed value specification. *)

Definition footprint_of  (a : action )  : footprint_impl := 
  match ( loc_of a) with 
  | None => footprint_empty
  | Some l  => footprint_of_loc l
  end.
(* [?]: removed value specification. *)

Definition combine_cvalues0   : set ((cvalue *footprint0 *footprint0 ) % type) -> option (tt ) :=  combine_cvalues_impl.



(* ********************************************** *)

(* We model the readsfrom relation as follows, see csem/notes/notes40
   and notes39 for a discussion of the alternatives. *)

Record execution_witness_fp : Type :=
  {  rf_fp   : set  ((action  * footprint0  * action ) % type);
      mo_fp   : set  ((action  * action ) % type);
      sc_fp   : set  ((action  * action ) % type);
      lo_fp   : set  ((action  * action ) % type);
      tot_fp  : set  ((action  * action ) % type)
 }.
Notation "{[ r 'with' 'rf_fp' := e ]}" := ({| rf_fp := e; mo_fp := mo_fp r; sc_fp := sc_fp r; lo_fp := lo_fp r; tot_fp := tot_fp r |}).
Notation "{[ r 'with' 'mo_fp' := e ]}" := ({| mo_fp := e; rf_fp := rf_fp r; sc_fp := sc_fp r; lo_fp := lo_fp r; tot_fp := tot_fp r |}).
Notation "{[ r 'with' 'sc_fp' := e ]}" := ({| sc_fp := e; rf_fp := rf_fp r; mo_fp := mo_fp r; lo_fp := lo_fp r; tot_fp := tot_fp r |}).
Notation "{[ r 'with' 'lo_fp' := e ]}" := ({| lo_fp := e; rf_fp := rf_fp r; mo_fp := mo_fp r; sc_fp := sc_fp r; tot_fp := tot_fp r |}).
Notation "{[ r 'with' 'tot_fp' := e ]}" := ({| tot_fp := e; rf_fp := rf_fp r; mo_fp := mo_fp r; sc_fp := sc_fp r; lo_fp := lo_fp r |}).
Definition execution_witness_fp_default: execution_witness_fp  := {| rf_fp := DAEMON; mo_fp := DAEMON; sc_fp := DAEMON; lo_fp := DAEMON; tot_fp := DAEMON |}.
(* [?]: removed value specification. *)

Definition aid_of_rel2_fp  (s : set ((action *footprint_impl *action ) % type))  : set ((nat *footprint_impl ) % type):=  lem_set.map (
  fun (p : (action *footprint_impl *action ) % type) =>
    match ( (p) ) with ( (w, f, r)) => (aid_of w, f) end) s.

Instance x72_Show : Show execution_witness_fp := {
   show   wit :=     
    String.append"rf: "  (String.append(stringFromSet (stringFromPair lem_string_extra.stringFromNat (fun  x=>"FOOTPRINT")) (aid_of_rel2_fp(rf_fp  wit)))   
    (String.append", mo: "  (String.append(stringFromSet (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) (aid_of_rel2(mo_fp  wit)))   
    (String.append", sc: "  (String.append(stringFromSet (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) (aid_of_rel2(sc_fp  wit)))   
    (String.append", lo: "  (String.append(stringFromSet (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) (aid_of_rel2(lo_fp  wit)))  
    (String.append", tot: " (stringFromSet (stringFromPair lem_string_extra.stringFromNat lem_string_extra.stringFromNat) (aid_of_rel2(tot_fp  wit)))))))))))
}.


Definition execution_witness_fp_setElemCompare  (cmpa : set ((action *footprint0 *action ) % type) -> set ((action *footprint0 *action ) % type) -> ordering ) (cmpb : set ((action *action ) % type) -> set ((action *action ) % type) -> ordering ) (x : execution_witness_fp ) (y : execution_witness_fp )  : ordering := 
  pairCompare
    cmpa
    (pairCompare
       cmpb
       (pairCompare
          cmpb
          (pairCompare
             cmpb
             cmpb)))
    ((rf_fp x), ((mo_fp x), ((sc_fp x), ((lo_fp x),(tot_fp  x)))))
    ((rf_fp y), ((mo_fp y), ((sc_fp y), ((lo_fp y),(tot_fp  y))))).

Instance x71_SetType : SetType execution_witness_fp := {
   setElemCompare   x  y :=  execution_witness_fp_setElemCompare (set_compare_by (tripleCompare (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun  x  y=>EQ) (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) (set_compare_by (pairCompare (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) x y
}.

(* [?]: removed value specification. *)

Definition project_witness_fp  (wit : execution_witness_fp )  : execution_witness := 
  {|rf := (lem_set.map (
  fun (p : (action *footprint_impl *action ) % type) =>
    match ( (p) ) with ( (w,  f,  r)) => (w, r) end)(rf_fp  wit));mo :=(mo_fp  wit);sc :=(sc_fp  wit);lo :=(lo_fp  wit);tot :=(tot_fp  wit)
  |}.

Record relation_list_fp : Type :=
(* The name hb clashes with variable names hb in Isabelle (same for
   vse). *)
  { hb_fp : set  ((action  * action ) % type); 
     vse_fp : set  ((action  * footprint0  * action ) % type);
     rest : relation_list  (* TODO: find a better name *)
  }.
Notation "{[ r 'with' 'hb_fp' := e ]}" := ({| hb_fp := e; vse_fp := vse_fp r; rest := rest r |}).
Notation "{[ r 'with' 'vse_fp' := e ]}" := ({| vse_fp := e; hb_fp := hb_fp r; rest := rest r |}).
Notation "{[ r 'with' 'rest' := e ]}" := ({| rest := e; hb_fp := hb_fp r; vse_fp := vse_fp r |}).
Definition relation_list_fp_default: relation_list_fp  := {| hb_fp := DAEMON; vse_fp := DAEMON; rest := relation_list_default |}.

Definition relation_list_fp_eq  (x : relation_list_fp ) (y : relation_list_fp )  : bool :=  ((tuple_equal_by (set_equal_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) ((fun (left : (set ((action *footprint0 *action ) % type)*list ((string *set ((action *action ) % type)) % type)) % type) (right : (set ((action *footprint0 *action ) % type)*list ((string *set ((action *action ) % type)) % type)) % type)=>(tuple_equal_by (set_equal_by (tripleCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : footprint_impl ) (y : footprint_impl )=>EQ) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) (list_equal_by ((fun (left : (string *set ((action *action ) % type)) % type) (right : (string *set ((action *action ) % type)) % type)=>(tuple_equal_by (fun (left : string ) (right : string )=>(string_equal left right)) (set_equal_by (pairCompare (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun (x : action ) (y : action )=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) left right)))) left right))) ((hb_fp x), ((vse_fp x),(rest  x))) ((hb_fp y), ((vse_fp y),(rest  y))))).

Instance x70_Eq : Eq relation_list_fp := {
   isEqual   x  y :=  relation_list_fp_eq x y;
   isInequal   x  y :=  negb (relation_list_fp_eq x y)
}.


Definition relation_list_fp_setElemCompare {a : Type}  (cmp : (set ((action *action ) % type)*((set ((action *footprint0 *action ) % type)*list ((string *set ((action *action ) % type)) % type)) % type)) % type -> (set ((action *action ) % type)*((set ((action *footprint0 *action ) % type)*list ((string *set ((action *action ) % type)) % type)) % type)) % type -> a) (x : relation_list_fp ) (y : relation_list_fp )  : a:= 
  cmp ((hb_fp x), ((vse_fp x),(rest  x))) ((hb_fp y), ((vse_fp y),(rest  y))).

Instance x69_SetType : SetType relation_list_fp := {
   setElemCompare   x  y :=  relation_list_fp_setElemCompare (pairCompare (set_compare_by (pairCompare (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) (pairCompare (set_compare_by (tripleCompare (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun  x  y=>EQ) (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))) (lexicographicCompareBy (pairCompare (fun  x  y=>EQ) (set_compare_by (pairCompare (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) (fun  x  y=>(genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))))))))) x y
}.

(* [?]: removed value specification. *)

Definition project_relation_list_fp  (l : relation_list_fp )  : list ((string *set ((action *action ) % type)) % type):= 
  let new_vse := lem_set.map (
  fun (p : (action *footprint_impl *action ) % type) =>
    match ( (p) ) with ( (w,  f,  r)) => (w, r) end)(vse_fp  l) in
  ("hb",(hb_fp  l))::(("vse", new_vse)::(rest l)).

Definition candidate_execution_fp : Type :=  
  ((pre_execution  * execution_witness_fp  * relation_list_fp ) % type).
Definition candidate_execution_fp_default: candidate_execution_fp  := (pre_execution_default, execution_witness_fp_default, relation_list_fp_default).
(* [?]: removed value specification. *)

Definition project_candidate_execution_fp  (p : (pre_execution *execution_witness_fp *relation_list_fp ) % type)  : (pre_execution *execution_witness *list ((string *set ((action *action ) % type)) % type)) % type:= 
  match ( (p)) with ( (Xo,  Xw,  rel1)) =>
    (Xo, project_witness_fp Xw, project_relation_list_fp rel1) end.

Definition observable_execution_fp : Type :=  
  ((pre_execution  * execution_witness_fp ) % type).
Definition observable_execution_fp_default: observable_execution_fp  := (pre_execution_default, execution_witness_fp_default).

(* Because the type of candidate execution changed, we need a
   footprint-variant of the rest of the framework as well. *)

Inductive named_predicate_tree_fp : Type := 
  | Leaf_fp:  (candidate_execution_fp  ->  bool ) -> named_predicate_tree_fp 
  | Leaf_non_fp:  (candidate_execution  ->  bool ) -> named_predicate_tree_fp 
  | Node_fp:  list  ((string  * named_predicate_tree_fp ) % type) -> named_predicate_tree_fp .
Definition named_predicate_tree_fp_default: named_predicate_tree_fp  := Leaf_fp (fun (x68 : candidate_execution_fp ) => bool_default).
(* [?]: removed value specification. *)

Program Fixpoint apply_tree_fp_aux  (pred_tree : named_predicate_tree_fp ) (ex_fp : (pre_execution *execution_witness_fp *relation_list_fp ) % type) (ex : (pre_execution *execution_witness *relation_list ) % type)  : bool := 
  match ( pred_tree) with 
    | Leaf_fp p     => p ex_fp
    | Leaf_non_fp p => p ex
    | Node_fp l     => List.forallb (
  fun (p : (string *named_predicate_tree_fp ) % type) =>
    match ( (p) ) with ( (_,  branch)) => apply_tree_fp_aux branch ex_fp ex
    end) l
  end.
(* [?]: removed value specification. *)

Definition apply_tree_fp  (tree : named_predicate_tree_fp ) (ex_fp : (pre_execution *execution_witness_fp *relation_list_fp ) % type)  : bool := 
  apply_tree_fp_aux tree ex_fp (project_candidate_execution_fp ex_fp).

Record memory_model_fp : Type :=
  {  consistent_fp :           named_predicate_tree_fp ;
      relation_calculation_fp : pre_execution  ->  execution_witness_fp  ->  relation_list_fp ;
      undefined_fp :            list  (fault_setgen );
      relation_flags_fp :       relation_usage_flags 
  }.
Notation "{[ r 'with' 'consistent_fp' := e ]}" := ({| consistent_fp := e; relation_calculation_fp := relation_calculation_fp r; undefined_fp := undefined_fp r; relation_flags_fp := relation_flags_fp r |}).
Notation "{[ r 'with' 'relation_calculation_fp' := e ]}" := ({| relation_calculation_fp := e; consistent_fp := consistent_fp r; undefined_fp := undefined_fp r; relation_flags_fp := relation_flags_fp r |}).
Notation "{[ r 'with' 'undefined_fp' := e ]}" := ({| undefined_fp := e; consistent_fp := consistent_fp r; relation_calculation_fp := relation_calculation_fp r; relation_flags_fp := relation_flags_fp r |}).
Notation "{[ r 'with' 'relation_flags_fp' := e ]}" := ({| relation_flags_fp := e; consistent_fp := consistent_fp r; relation_calculation_fp := relation_calculation_fp r; undefined_fp := undefined_fp r |}).
Definition memory_model_fp_default: memory_model_fp  := {| consistent_fp := named_predicate_tree_fp_default; relation_calculation_fp := (fun (x66 :  pre_execution ) => (fun (x67 :  execution_witness_fp ) => relation_list_fp_default)); undefined_fp := DAEMON; relation_flags_fp := relation_usage_flags_default |}.

Inductive program_behaviours_fp : Type := 
    Defined_fp:  set  (observable_execution_fp ) -> program_behaviours_fp 
  | Undefined_fp: program_behaviours_fp .
Definition program_behaviours_fp_default: program_behaviours_fp  := Defined_fp DAEMON.
(* [?]: removed value specification. *)

Definition observable_filter_fp  (X : set ((pre_execution *execution_witness_fp *relation_list_fp ) % type))  : set ((pre_execution *execution_witness_fp ) % type):=  let x2 := 
  [] in set_fold
   (fun (p : (pre_execution *execution_witness_fp *relation_list_fp ) % type) (x2 : set ((pre_execution *execution_witness_fp ) % type)) =>
      match ( (p ,x2) ) with ((Xo, Xw, _rl) ,  x2) =>
        if true then set_add (Xo,Xw) x2 else x2 end) X x2.
(* [?]: removed value specification. *)

Definition behaviour_fp  (M : memory_model_fp ) (condition : set ((pre_execution *execution_witness *relation_list ) % type) -> bool ) (opsem : nat  -> pre_execution  -> bool )  (p : program )  : program_behaviours_fp := 
  let consistent_executions_fp :=(* XXX: setcomp *) in
  let consistent_executions := 
    lem_set.map project_candidate_execution_fp consistent_executions_fp in
  if condition consistent_executions &&
     set_for_all  (fun (X : (pre_execution *execution_witness *relation_list ) % type) =>
    each_empty (undefined_fp  M) X) consistent_executions
  then Defined_fp (observable_filter_fp consistent_executions_fp)
  else Undefined_fp.
(* [?]: removed value specification. *)

Definition well_formed_rf_fp  (p : (pre_execution *execution_witness_fp *relation_list_fp ) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, _)) =>
    (set_for_all
       (fun (p : (action *footprint_impl *action ) % type) =>
          match ( (p) ) with ( (w, f, r)) =>
            (set_member_by
               (fun (x : action ) (y : action )=>
                  (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
             w (actions  Xo)) &&
            ((set_member_by
                (fun (x : action ) (y : action )=>
                   (genericCompare nat_ltb beq_nat (aid_of x) (aid_of y))) 
              r (actions  Xo)) &&
             (is_write w &&
              (is_read r &&
               (negb (footprint_is_empty f) &&
                (( ((negb (is_at_non_atomic_location (lk  Xo) r)) ||
                    (set_for_all
                       (fun (p : (action *footprint_impl *action ) % type) =>
                          match ( (p) ) with ( (w', f', r')) =>
                            ((negb
                                (( classical_boolean_equivalence r r') &&
                                 ( classical_boolean_equivalence w w'))) ||
                             classical_boolean_equivalence f f') end)
                       (rf_fp  Xw)))) &&
                 ( ((negb (is_at_atomic_location (lk  Xo) r)) ||
                    (set_for_all
                       (fun (p : (action *footprint_impl *action ) % type) =>
                          match ( (p) ) with ( (w', f', r')) =>
                            ((negb ( classical_boolean_equivalence r r')) ||
                             (( classical_boolean_equivalence w w') &&
                              ( classical_boolean_equivalence f f'))) end)
                       (rf_fp  Xw))))))))) end) (rf_fp  Xw)) &&
    (set_for_all
       (fun (r : action ) =>
          let writes_of_r := let x2 := [] in set_fold
                                               (fun (p : (action *footprint_impl *action ) % type) (x2 : set ((action *footprint_impl ) % type)) =>
                                                  match ( (p ,x2) ) with
                                                      ((w,  f,  r') ,  x2) =>
                                                    if ( classical_boolean_equivalence
                                                           r r') then
                                                      set_add (w, f) x2 else
                                                      x2 end) (rf_fp  Xw) 
                                             x2 in ((negb
                                                       (negb
                                                          (set_is_empty
                                                             writes_of_r)))
                                                    ||
                                                    (footprint_leq0
                                                       (footprint_bigunion
                                                          (let x2 := 
                                                          [] in set_fold
                                                                  (fun (p : (action *footprint_impl ) % type) (x2 : set (footprint_impl )) =>
                                                                    match ( (p ,x2) ) with
                                                                    ((w,  f) ,  x2) =>
                                                                    if 
                                                                    true then
                                                                    set_add 
                                                                    f 
                                                                    x2 else
                                                                    x2 end)
                                                                  writes_of_r
                                                                  x2))
                                                       (footprint_of r) &&
                                                     (maybeEqualBy
                                                        classical_boolean_equivalence
                                                        (value_read_by r)
                                                        (combine_cvalues0
                                                           (lem_set.setMapMaybe
                                                              (fun (p : (action *footprint_impl ) % type) =>
                                                                 match ( (p) ) with
                                                                    ( (w,  f)) =>
                                                                   match ( 
                                                                   value_written_by
                                                                    w) with
                                                                    | Some v =>
                                                                    Some
                                                                    (v, 
                                                                    footprint_of
                                                                    w, f)
                                                                    | None =>
                                                                    None end
                                                                 end)
                                                              writes_of_r))))))
       (actions  Xo)) end.
(* [?]: removed value specification. *)

Definition consistent_non_atomic_rf_fp  (p : (pre_execution *execution_witness_fp *relation_list_fp ) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, rel1)) =>
    set_for_all
      (fun (p : (action *footprint_impl *action ) % type) =>
         match ( (p) ) with ( (w, f, r)) =>
           ((negb (is_at_non_atomic_location (lk  Xo) r)) ||
            set_any
              (fun (p : (action *footprint_impl *action ) % type) =>
                 match ( (p) ) with ( (w', f', r')) =>
                   ( classical_boolean_equivalence w w') &&
                   (( classical_boolean_equivalence r r') &&
                    footprint_leq0 f f') end) (vse_fp  rel1)) end)
      (rf_fp  Xw) end.
(* [?]: removed value specification. *)

Definition det_read_fp  (p : (pre_execution *execution_witness_fp *relation_list_fp ) % type)  : bool := 
  match ( (p)) with ( (Xo, Xw, rel1)) =>
    set_for_all
      (fun (r : action ) =>
         ((negb (is_load r)) ||
          classical_boolean_equivalence
            (footprint_bigunion
               (let x2 := [] in set_fold
                                  (fun (p : (action *footprint_impl *action ) % type) (x2 : set (footprint_impl )) =>
                                     match ( (p ,x2) ) with
                                         ((w, f, r') ,  x2) =>
                                       if ( classical_boolean_equivalence 
                                            r r') then set_add f x2 else 
                                       x2 end) (vse_fp  rel1) x2))
            (footprint_bigunion
               (let x2 := [] in set_fold
                                  (fun (p : (action *footprint_impl *action ) % type) (x2 : set (footprint_impl )) =>
                                     match ( (p ,x2) ) with
                                         ((w, f, r') ,  x2) =>
                                       if ( classical_boolean_equivalence 
                                            r r') then set_add f x2 else 
                                       x2 end) (rf_fp  Xw) x2))))
      (actions  Xo) end.
(* [?]: removed value specification. *)

Definition overlap_consistent_execution   : named_predicate_tree_fp := 
  Node_fp [ ("assumptions", Leaf_non_fp assumptions);
            ("tot_empty", Leaf_non_fp tot_empty);
            ("well_formed_threads", Leaf_non_fp well_formed_threads);
            ("well_formed_rf_fp", Leaf_fp well_formed_rf_fp);
            ("locks_only_consistent_locks", Leaf_non_fp locks_only_consistent_locks);
            ("locks_only_consistent_lo", Leaf_non_fp locks_only_consistent_lo);
            ("consistent_mo", Leaf_non_fp consistent_mo);
            ("sc_accesses_consistent_sc", Leaf_non_fp sc_accesses_consistent_sc);
            ("sc_fenced_sc_fences_heeded", Leaf_non_fp sc_fenced_sc_fences_heeded);
            ("consistent_hb", Leaf_non_fp consistent_hb);
            ("consistent_rf",
              Node_fp [ ("det_read_fp", Leaf_fp det_read_fp);
                        ("consistent_non_atomic_rf_fp", Leaf_fp consistent_non_atomic_rf_fp);
                        ("consistent_atomic_rf", Leaf_non_fp consistent_atomic_rf);
                        ("coherent_memory_use", Leaf_non_fp coherent_memory_use);
                        ("rmw_atomicity", Leaf_non_fp rmw_atomicity);
                        ("sc_accesses_sc_reads_restricted", Leaf_non_fp sc_accesses_sc_reads_restricted)] )] .
(* [?]: removed value specification. *)

Definition visible_side_effect_set_fp  (actions1 : set (action )) (hb : set ((action *action ) % type))  : set ((action *footprint_impl *action ) % type):= 
  let x := (fun (p : (action *action ) % type) =>
  match ( (p) ) with ( (a, b)) => let overwriting_footprint :=
  footprint_bigunion
    (let x2 := [] in set_fold
                       (fun (c : action ) (x2 : set (footprint_impl )) =>
                          if negb
                               ( (set_member_by
                                    (fun (x : action ) (y : action )=>
                                       (genericCompare nat_ltb beq_nat
                                          (aid_of x) (aid_of y))) c [a; b]))
                             &&
                             (is_write c &&
                              ((set_member_by
                                  (pairCompare
                                     (fun (x : action ) (y : action )=>
                                        (genericCompare nat_ltb beq_nat
                                           (aid_of x) (aid_of y)))
                                     (fun (x : action ) (y : action )=>
                                        (genericCompare nat_ltb beq_nat
                                           (aid_of x) (aid_of y)))) (a, c) 
                                hb) &&
                               (set_member_by
                                  (pairCompare
                                     (fun (x : action ) (y : action )=>
                                        (genericCompare nat_ltb beq_nat
                                           (aid_of x) (aid_of y)))
                                     (fun (x : action ) (y : action )=>
                                        (genericCompare nat_ltb beq_nat
                                           (aid_of x) (aid_of y)))) (c, b) 
                                hb))) then set_add (footprint_of c) x2 else
                            x2) actions1 x2) in
  let remaining_footprint_of_a :=
  footprint_difference (footprint_of a) overwriting_footprint in
  let footprint_between_a_and_b :=
  footprint_intersection (footprint_of b) remaining_footprint_of_a in
  (a, footprint_between_a_and_b, b) end) in
    let x2 := [] in set_fold
   (fun (p : (action *footprint_impl *action ) % type) (x2 : set ((action *footprint_impl *action ) % type)) =>
      match ( (p ,x2) ) with ((a, f, b) ,  x2) =>
        if is_write a && (is_read b && negb (footprint_is_empty f)) then
          set_add (a,f,b) x2 else x2 end) (lem_set.map x hb) x2.
(* [?]: removed value specification. *)

Definition overlap_relations  (Xo : pre_execution ) (Xw_fp : execution_witness_fp )  : relation_list_fp := 
    let Xw    := project_witness_fp Xw_fp in
    let hrs   := hypothetical_release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let rs    := release_sequence_set(actions  Xo)(lk  Xo)(mo  Xw) in
    let sw    := release_acquire_fenced_synchronizes_with_set(actions  Xo)(sb  Xo)(asw  Xo)(rf  Xw)(lo  Xw) rs hrs in
    let hb    := no_consume_hb(sb  Xo) sw in
    let vse   := visible_side_effect_set_fp(actions  Xo) hb in
    {|hb_fp := hb;vse_fp := vse;rest := [ ("sw", sw); ("rs", rs); ("hrs", hrs)]  
    |}.
(* [?]: removed value specification. *)

Definition overlap_memory_model   : memory_model_fp := 
  {|consistent_fp := overlap_consistent_execution;relation_calculation_fp := overlap_relations;undefined_fp := locks_only_undefined_behaviour;relation_flags_fp :=
       {|rf_flag  := true;mo_flag  := true;sc_flag  := true;lo_flag  := true;tot_flag := false |}
  |}.
(* [?]: removed value specification. *)

Definition overlap_behaviour  (opsem : program  -> pre_execution  -> bool ) (p : nat )  : program_behaviours_fp := 
  behaviour_fp overlap_memory_model sc_fenced_condition opsem p.
