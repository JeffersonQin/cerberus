(* Generated by Lem from ocaml_generated/ctype.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(* (C) Justus Matthiesen
 *     Kayvan Memarian
 *     Victor Gomes
 *)

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import loc.
Require Export loc.
Require Import lem_show.
Require Export lem_show.

Require Import symbol.
Require Export symbol.
Require Import annot.
Require Export annot.
Require Import cabs.
Require Export cabs.


Inductive integerBaseType : Type := 
 | Ichar: integerBaseType 
 | Short: integerBaseType 
 | Int_: integerBaseType 
 | Long: integerBaseType 
 | LongLong: integerBaseType 
   (* Things defined in the standard libraries *)
 | IntN_t:  nat  -> integerBaseType 
 | Int_leastN_t:  nat  -> integerBaseType 
 | Int_fastN_t:  nat  -> integerBaseType 
 | Intmax_t: integerBaseType 
 | Intptr_t: integerBaseType .
Definition integerBaseType_default: integerBaseType  := Ichar.

(* STD Â§6.2.5#17, sentence 1 *)
Inductive integerType : Type := (* [name = "^\\(\\|\\([a-z A-Z]+_\\)\\)ity[0-9]*'?$"] *) 
 | Char: integerType 
 | Bool: integerType 
 | Signed:  integerBaseType  -> integerType 
 | Unsigned:  integerBaseType  -> integerType 
 | Enum:  symbol.sym  -> integerType 
   (* Things defined in the standard libraries *)
 | Wchar_t: integerType 
 | Wint_t: integerType 
 | Size_t: integerType 
 | Ptrdiff_t: integerType .
Definition integerType_default: integerType  := Char.

(* STD Â§6.2.5#10, sentence 1 *)
Inductive realFloatingType : Type := 
  | Float: realFloatingType 
  | Double: realFloatingType 
  | LongDouble: realFloatingType .
Definition realFloatingType_default: realFloatingType  := Float.

(* STD Â§6.2.5#11, sentence 2 *)
Inductive floatingType : Type := 
  | RealFloating:  realFloatingType  -> floatingType .
Definition floatingType_default: floatingType  := RealFloating realFloatingType_default.
(*  | Complex of floatingType (* STD Â§6.2.5#11, sentence 1 *) *)

(* STD Â§6.2.5#14, sentence 1 *)
Inductive basicType : Type := 
 | Integer:  integerType  -> basicType 
 | Floating:  floatingType  -> basicType .
Definition basicType_default: basicType  := Integer integerType_default.

(* STD Â§6.2.5#26, sentence 1-2 *)
Record qualifiers : Type (*[name = "^\\(\\|\\([a-z A-Z]+_\\)\\)qs[0-9]*'?$"]*) := {
  const    : bool ;
  restrict : bool ;
  volatile : bool 
  (* NOTE: the desugaring collapse _Atomic qualifiers and specifiers *)
}.
Notation "{[ r 'with' 'const' := e ]}" := ({| const := e; restrict := restrict r; volatile := volatile r |}).
Notation "{[ r 'with' 'restrict' := e ]}" := ({| restrict := e; const := const r; volatile := volatile r |}).
Notation "{[ r 'with' 'volatile' := e ]}" := ({| volatile := e; const := const r; restrict := restrict r |}).
Definition qualifiers_default: qualifiers  := {| const := bool_default; restrict := bool_default; volatile := bool_default |}.

Inductive ctype_ : Type := (*[name = "^\\([a-z A-Z]*_\\)?ty[0-9]*'?$"]*) 
 | Void: ctype_ 
 | Basic:  basicType  -> ctype_ 
   (* INVARIANT if the element ctype is an array, the qualifiers must be empty *)
   (* the qualifiers are that of the element type (Â§6.7.3#9) *)
   (* STD Â§6.2.5#20, bullet 1 *)
 | Array:  ctype  ->  (option  Z  ) -> ctype_ 
   (* NOTE: the qualifiers associated to a ctype in the
            list of parameters is that of the parameter lvalue. For example if
            we have a parameter with type "restrict pointer to a const char",
            the qualifiers in the tuple will be:
              {no_qualifiers with restrict=true} *)
   (* STD Â§6.2.5#20, bullet 4 *)
 | Function:  (* has_proto *)bool  ->  ((qualifiers  * ctype ) % type)
             ->  list  ((qualifiers  * ctype  * (* is_register *)bool ) % type)
             ->  (* is_variadic *)bool  -> ctype_ 
   (* STD Â§6.2.5#20, bullet 5 *)
   (* NOTE: the qualifiers are that of the referenced type *)
 | Pointer:  qualifiers  ->  ctype  -> ctype_ 
   (* STD Â§6.2.5#20, bullet 6 *)
 | Atomic:  ctype  -> ctype_ 
 | Struct:  symbol.sym  -> ctype_ 
 | Union:  symbol.sym  -> ctype_ 
with ctype : Type := 
  Ctype:  list  annot.annot  ->  ctype_  -> ctype .
Definition ctype__default: ctype_  := Void.
Definition ctype_default: ctype  := Ctype DAEMON ctype__default.

Definition struct_tag : Type :=  symbol.sym .
Definition struct_tag_default: struct_tag  := sym_default.
Definition union_tag : Type :=   symbol.sym .
Definition union_tag_default: union_tag  := sym_default.
Definition member_id : Type :=   symbol.sym .
Definition member_id_default: member_id  := sym_default.

Instance x34_Located : Located ctype := {
   locOf   cty :=  match ( cty) with ( Ctype annots1 _) => annot.get_loc_ annots1 end
}.


Inductive tag_definition : Type := 
  | StructDef:  list  ((cabs.cabs_identifier  * ((qualifiers  * ctype ) % type)) % type) -> tag_definition 
  | UnionDef:  list  ((cabs.cabs_identifier  * ((qualifiers  * ctype ) % type)) % type) -> tag_definition .
Definition tag_definition_default: tag_definition  := StructDef DAEMON.

(** Type class instances *)

Definition integerBaseTypeEqual  (ibty1 : integerBaseType ) (ibty2 : integerBaseType )  : bool := 
  let ord := fun (x : integerBaseType ) =>
   match (x) with | Ichar => ( 0 : nat ) | Short =>  1 | Int_ =>  2 | Long =>
      3 | LongLong =>  4 | IntN_t _ =>  5 | Int_leastN_t _ =>  6
     | Int_fastN_t _ =>  7 | Intmax_t =>  8 | Intptr_t =>  9 end in
  match ( (ibty1, ibty2)) with 
    | (IntN_t n1,  IntN_t n2) => beq_nat
        n1 n2
    | (Int_leastN_t n1,  Int_leastN_t n2) => beq_nat
        n1 n2
    | (Int_fastN_t n1,  Int_fastN_t n2) => beq_nat
        n1 n2
    | _ => beq_nat
        (ord ibty1) (ord ibty2)
  end.

Instance x33_Eq : Eq integerBaseType := {
   isEqual   :=  integerBaseTypeEqual;
   isInequal  :=  fun  ibty1  ibty2 => negb (integerBaseTypeEqual ibty1 ibty2)
}.


Definition integerTypeEqual  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  let ord := fun (x : integerType ) =>
   match (x) with | Char => ( 0 : nat ) | Bool =>  1 | Signed _ =>  2
     | Unsigned _ =>  3 | Enum _ =>  4 | Size_t =>  5 | Wchar_t =>  6
     | Wint_t =>  7 | Ptrdiff_t =>  8 end in
  match ( (ity1, ity2)) with 
    | (Signed ibty1,  Signed ibty2) => integerBaseTypeEqual
        ibty1 ibty2
    | (Unsigned ibty1,  Unsigned ibty2) => integerBaseTypeEqual
        ibty1 ibty2
    | (Enum sym1,  Enum sym2) => match ( (sym1, sym2)) with 
    | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
        if Z.eqb (fun _: unit _: unit => 0 d1 d2)((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
          if nat_gteb (fun _: tt => 0 tt)( 5) && negb ((maybeEqualBy (fun (left : string ) (right : string )=>(string_equal left right)) str_opt1 str_opt2)) then 
  match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt ( 5) 
          []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 String.append
                   "[Symbol.symbolEqual] suspicious equality ==> "
                   (String.append
                      (stringFromMaybe
                         (fun (s : string )=>
                            String.append """" (String.append s """"))
                         str_opt1)
                      (String.append " <-> "
                         (stringFromMaybe
                            (fun (s : string )=>
                               String.append """" (String.append s """"))
                            str_opt2))) end)) with tt => true end
          else
            true
        else
          false
  end
    | _ => beq_nat
        (ord ity1) (ord ity2)
  end.

Instance x32_Eq : Eq integerType := {
   isEqual   :=  integerTypeEqual;
   isInequal  :=  fun  ity1  ity2 => negb (integerTypeEqual ity1 ity2)
}.


Instance x31_Eq : Eq realFloatingType := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.


Instance x30_Eq : Eq floatingType := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.



(* STD Â§6.2.5#14, sentence 3 *)
Definition basicTypeEqual  (bty1 : basicType ) (bty2 : basicType )  : bool := 
  let ord := fun (x : basicType ) =>
   match (x) with | Integer _ => ( 0 : nat ) | Floating _ =>  1 end in
  match ( (bty1, bty2)) with 
    | (Integer ity1,  Integer ity2) => integerTypeEqual
        ity1 ity2
    | (Floating fty1,  Floating fty2) => classical_boolean_equivalence
        fty1 fty2
    | _ => beq_nat
        (ord bty1) (ord bty2)
  end.

Instance x29_Eq : Eq basicType := {
   isEqual   :=  basicTypeEqual;
   isInequal  :=  fun  bty1  bty2 => negb (basicTypeEqual bty1 bty2)
}.



Definition qualifiersEqual  (qs1 : qualifiers ) (qs2 : qualifiers )  : bool :=     Bool.eqb(const  
     qs1)(const  qs2)
  && (Bool.eqb(restrict  qs1)(restrict  qs2)
  && Bool.eqb(volatile  qs1)(volatile  qs2)).

Instance x28_Eq : Eq qualifiers := {
   isEqual   :=  qualifiersEqual;
   isInequal  :=  fun  qs1  qs2 => negb (qualifiersEqual qs1 qs2)
}.



Program Fixpoint ctypeEqual  (c : ctype ) (c0 : ctype )  : bool := 
  match ( (c,c0)) with (( Ctype _ ty1), ( Ctype _ ty2)) =>
    let ord := fun (x : ctype_ ) =>
                 match (x) with | Void => ( 0 : nat ) | Basic _ =>  1
                   | Array _ _ =>  2 | Function _ _ _ _ =>  3
                   | Pointer _ _ =>  4 | Atomic _ =>  5 | Struct _ => 
                  6 | Union _ =>  7 end in
  let paramsEqual := (fun (p : (qualifiers *ctype *bool ) % type) (p0 : (qualifiers *ctype *bool ) % type) =>
                        match ( (p ,p0) ) with
                            ( (qs1,  ty1,  b1) ,  (qs2,  ty2,  b2)) =>
                          qualifiersEqual qs1 qs2 &&
                          (ctypeEqual ty1 ty2 && Bool.eqb b1 b2) end) in
  match ( (ty1, ty2)) with | (Basic bty1,  Basic bty2) =>
    basicTypeEqual bty1 bty2 | (Array ty1 n1_opt,  Array ty2 n2_opt) =>
    ctypeEqual ty1 ty2 && (maybeEqualBy Z.eqb n1_opt n2_opt)
    | (Function has_proto1 (qs1,  ty1) params1 b1, 
  Function has_proto2 (qs2,  ty2) params2 b2) =>
    Bool.eqb has_proto1 has_proto2 &&
    (qualifiersEqual qs1 qs2 &&
     (ctypeEqual ty1 ty2 &&
      (List.forallb (uncurry paramsEqual) (lem_list.zip params1 params2) &&
       Bool.eqb b1 b2))) | (Atomic ty1,  Atomic ty2) => ctypeEqual ty1 ty2
    | (Struct id1,  Struct id2) =>
    match ( (id1, id2)) with
          | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
      if Z.eqb (fun _: unit _: unit => 0 d1 d2)
           ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
        if nat_gteb (fun _: tt => 0 tt) ( 5) &&
           negb
             ((maybeEqualBy
                 (fun (left : string ) (right : string )=>
                    (string_equal left right)) str_opt1 str_opt2)) then
          match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                  ( 5) []
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) =>
                         String.append
                           "[Symbol.symbolEqual] suspicious equality ==> "
                           (String.append
                              (stringFromMaybe
                                 (fun (s : string )=>
                                    String.append """" (String.append s """"))
                                 str_opt1)
                              (String.append " <-> "
                                 (stringFromMaybe
                                    (fun (s : string )=>
                                       String.append """"
                                         (String.append s """")) str_opt2)))
                       end)) with tt => true end else true else false end
    | (Union id1,  Union id2) =>
    match ( (id1, id2)) with
          | (symbol.Symbol0 d1 n1 str_opt1,  symbol.Symbol0 d2 n2 str_opt2) =>
      if Z.eqb (fun _: unit _: unit => 0 d1 d2)
           ((Zpred (Zpos (P_of_succ_nat 0)))) && beq_nat n1 n2 then
        if nat_gteb (fun _: tt => 0 tt) ( 5) &&
           negb
             ((maybeEqualBy
                 (fun (left : string ) (right : string )=>
                    (string_equal left right)) str_opt1 str_opt2)) then
          match ( fun (_:nat) (_: list domain) (_: unit -> string) := tt 
                  ( 5) []
                    (fun (u : unit ) =>
                       match ( (u) ) with ( tt) =>
                         String.append
                           "[Symbol.symbolEqual] suspicious equality ==> "
                           (String.append
                              (stringFromMaybe
                                 (fun (s : string )=>
                                    String.append """" (String.append s """"))
                                 str_opt1)
                              (String.append " <-> "
                                 (stringFromMaybe
                                    (fun (s : string )=>
                                       String.append """"
                                         (String.append s """")) str_opt2)))
                       end)) with tt => true end else true else false end
    | _ => beq_nat (ord ty1) (ord ty2) end end.

Instance x27_Eq : Eq ctype := {
   isEqual   :=  ctypeEqual;
   isInequal  :=  fun  ty1  ty2 => negb (ctypeEqual ty1 ty2)
}.


Definition setElemCompare_integerBaseType  (ibty1 : integerBaseType ) (ibty2 : integerBaseType )  : ordering := 
  let ord := fun (x : integerBaseType ) =>
   match (x) with | Ichar => ( 0 : nat ) | Short =>  1 | Int_ =>  2 | Long =>
      3 | LongLong =>  4 | IntN_t _ =>  5 | Int_leastN_t _ =>  6
     | Int_fastN_t _ =>  7 | Intmax_t =>  8 | Intptr_t =>  9 end in
  match ( (ibty1, ibty2)) with 
    | (IntN_t n1,  IntN_t n2) =>
        (genericCompare nat_ltb beq_nat n1 n2)
    | (Int_leastN_t n1,  Int_leastN_t n2) =>
        (genericCompare nat_ltb beq_nat n1 n2)
    | (Int_fastN_t n1,  Int_fastN_t n2) =>
        (genericCompare nat_ltb beq_nat n1 n2)
    | _ =>
        (genericCompare nat_ltb beq_nat (ord ibty1) (ord ibty2))
  end.

Instance x26_SetType : SetType integerBaseType := {
   setElemCompare  :=  setElemCompare_integerBaseType
}.


Definition setElemCompare_integerType  (ity1 : integerType ) (ity2 : integerType )  : ordering := 
  let ord := fun (x : integerType ) =>
   match (x) with | Char => ( 0 : nat ) | Bool =>  1 | Signed _ =>  2
     | Unsigned _ =>  3 | Enum _ =>  4 | Size_t =>  5 | Wchar_t =>  6
     | Wint_t =>  7 | Ptrdiff_t =>  8 end in
  match ( (ity1, ity2)) with 
    | (Signed ibty1,  Signed ibty2) =>
        setElemCompare_integerBaseType ibty1 ibty2
    | (Unsigned ibty1,  Unsigned ibty2) =>
        setElemCompare_integerBaseType ibty1 ibty2
    | (Enum sym1,  Enum sym2) =>
        ordCompare sym1 sym2
    | _ =>
        (genericCompare nat_ltb beq_nat (ord ity1) (ord ity2))
  end.

Instance x25_SetType : SetType integerType := {
   setElemCompare  :=  setElemCompare_integerType
}.



Definition setElemCompare_basicType  (bty1 : basicType ) (bty2 : basicType )  : ordering := 
  let ord := fun (x : basicType ) =>
   match (x) with | Integer _ => ( 0 : nat ) | Floating _ =>  1 end in
  match ( (bty1, bty2)) with 
    | (Integer ity1,  Integer ity2) =>
        setElemCompare_integerType ity1 ity2
    | (Floating str1,  Floating str2) =>
        EQ
    | _ =>
        (genericCompare nat_ltb beq_nat (ord bty1) (ord bty2))
  end.

Instance x24_SetType : SetType basicType := {
   setElemCompare  :=  setElemCompare_basicType
}.



Instance x23_SetType : SetType qualifiers := {
   setElemCompare   qs1  qs2 := 
    (tripleCompare boolCompare boolCompare boolCompare ((const qs1),(restrict  qs1),(volatile  qs1))
                   ((const qs2),(restrict  qs2),(volatile  qs2)))
}.



Instance x22_Show : Show tag_definition := {
   show   def := 
    let string_of_identifiers := (fun  tag_defs => 
      String.append(List.fold_left (
  fun acc p =>
    match ( (acc ,p) ) with ( acc ,  (cabs.CabsIdentifier _ str,  _)) =>
      String.append acc (String.append str "; ") end
      ) tag_defs "[") "]")
    in
    match ( def) with 
      | StructDef tag_defs => string_of_identifiers tag_defs
      | UnionDef tag_defs => string_of_identifiers tag_defs
    end
}.

(* [?]: removed value specification. *)

Definition proj_ctype_  (c : ctype )  : ctype_ := 
  match ( (c)) with (( Ctype _ ty_)) => ty_ end.

(* NOTE: a well-formed ctype cannot have an Atomic inside another one *)
Definition unatomic  (c : ctype )  : ctype := 
  match ( (c)) with ( Ctype annots1 ty_ as ty) =>
    match ( ty_) with | Atomic ty => ty | _ => ty end end.

Definition unatomic_  (ty : ctype )  : ctype_ := 
  proj_ctype_ (unatomic ty).
(* [?]: removed value specification. *)

Definition make_qualifiers  (c : bool ) (r : bool ) (v : bool )  : qualifiers :=  {|const    := c;restrict := r;volatile := v
|}.
(* [?]: removed value specification. *)

Definition no_qualifiers   : qualifiers :=  {|const    := false;restrict := false;volatile := false
|}.
(* [?]: removed value specification. *)

Definition combine_qualifiers  (qs1 : qualifiers ) (qs2 : qualifiers )  : qualifiers :=  {|const    := ((const qs1)    ||(const  qs2))   ;restrict := ((restrict qs1) ||(restrict  qs2));volatile := ((volatile qs1) ||(volatile  qs2))
|}.


(* Some constructors *)

Definition mk_ctype_pointer  (qs : qualifiers ) (ty : ctype )  : ctype := 
  Ctype [] (Pointer qs ty).

Definition mk_ctype_integer  (ity : integerType )  : ctype := 
  Ctype [] (Basic (Integer ity)).

Definition mk_ctype_atomic  (cty : ctype )  : ctype := 
  Ctype [] (Atomic cty).
(* [?]: removed value specification. *)

Definition void   : ctype := 
  Ctype [] Void.
(* [?]: removed value specification. *)

Definition char   : ctype := 
  Ctype [] (Basic (Integer Char)).
(* [?]: removed value specification. *)

Definition signed_char   : ctype := 
  Ctype [] (Basic (Integer (Signed Ichar))).
(* [?]: removed value specification. *)

Definition signed_short   : ctype := 
  Ctype [] (Basic (Integer (Signed Short))).
(* [?]: removed value specification. *)

Definition signed_int   : ctype := 
  Ctype [] (Basic (Integer (Signed Int_))).
(* [?]: removed value specification. *)

Definition signed_long   : ctype := 
  Ctype [] (Basic (Integer (Signed Long))).
(* [?]: removed value specification. *)

Definition signed_long_long   : ctype := 
  Ctype [] (Basic (Integer (Signed LongLong))).
(* [?]: removed value specification. *)

Definition intptr_t   : ctype := 
  Ctype [] (Basic (Integer (Signed Intptr_t))).
(* [?]: removed value specification. *)

Definition intmax_t   : ctype := 
  Ctype [] (Basic (Integer (Signed Intmax_t))).
(* [?]: removed value specification. *)

Definition unsigned_char   : ctype := 
  Ctype [] (Basic (Integer (Unsigned (Ichar)))).
(* [?]: removed value specification. *)

Definition unsigned_short   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Short))).
(* [?]: removed value specification. *)

Definition unsigned_int   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Int_))).
(* [?]: removed value specification. *)

Definition unsigned_long   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Long))).
(* [?]: removed value specification. *)

Definition unsigned_long_long   : ctype := 
  Ctype [] (Basic (Integer (Unsigned LongLong))).
(* [?]: removed value specification. *)

Definition uintptr_t   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Intptr_t))).
(* [?]: removed value specification. *)

Definition uintmax_t   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Intmax_t))).
(* [?]: removed value specification. *)

Definition char16_t   : ctype := 
  (* STD Â§7.28#2 *)
  Ctype [] (Basic (Integer (Unsigned (Int_leastN_t( 16))))).
(* [?]: removed value specification. *)

Definition char32_t   : ctype := 
  (* STD Â§7.28#2 *)
  Ctype [] (Basic (Integer (Unsigned (Int_leastN_t( 32))))).
(* [?]: removed value specification. *)

Definition wchar_t   : ctype := 
  Ctype [] (Basic (Integer Wchar_t)).
(* [?]: removed value specification. *)

Definition size_t   : ctype := 
  Ctype [] (Basic (Integer Size_t)).
(* [?]: removed value specification. *)

Definition ptrdiff_t   : ctype := 
  Ctype [] (Basic (Integer Ptrdiff_t)).

