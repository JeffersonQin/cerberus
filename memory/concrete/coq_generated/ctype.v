(* Generated by Lem from ocaml_generated/ctype.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(* (C) Justus Matthiesen
 *     Kayvan Memarian
 *     Victor Gomes
 *)

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import loc.
Require Export loc.
Require Import lem_show.
Require Export lem_show.
Require Import symbol.
Require Export symbol.

Require Import annot.
Require Export annot.


Inductive integerBaseType : Type := 
 | Ichar: integerBaseType 
 | Short: integerBaseType 
 | Int_: integerBaseType 
 | Long: integerBaseType 
 | LongLong: integerBaseType 
   (* Things defined in the standard libraries *)
 | IntN_t:  nat  -> integerBaseType 
 | Int_leastN_t:  nat  -> integerBaseType 
 | Int_fastN_t:  nat  -> integerBaseType 
 | Intmax_t: integerBaseType 
 | Intptr_t: integerBaseType .
Definition integerBaseType_default: integerBaseType  := Ichar.

(* STD Â§6.2.5#17, sentence 1 *)
Inductive integerType : Type := (* [name = "^\\(\\|\\([a-z A-Z]+_\\)\\)ity[0-9]*'?$"] *) 
 | Char: integerType 
 | Bool: integerType 
 | Signed:  integerBaseType  -> integerType 
 | Unsigned:  integerBaseType  -> integerType 
 | Enum:  symbol.sym  -> integerType 
   (* Things defined in the standard libraries *)
 | Wchar_t: integerType 
 | Wint_t: integerType 
 | Size_t: integerType 
 | Ptrdiff_t: integerType .
Definition integerType_default: integerType  := Char.

(* STD Â§6.2.5#10, sentence 1 *)
Inductive realFloatingType : Type := 
  | Float: realFloatingType 
  | Double: realFloatingType 
  | LongDouble: realFloatingType .
Definition realFloatingType_default: realFloatingType  := Float.

(* STD Â§6.2.5#11, sentence 2 *)
Inductive floatingType : Type := 
  | RealFloating:  realFloatingType  -> floatingType .
Definition floatingType_default: floatingType  := RealFloating realFloatingType_default.
(*  | Complex of floatingType (* STD Â§6.2.5#11, sentence 1 *) *)

(* STD Â§6.2.5#14, sentence 1 *)
Inductive basicType : Type := 
 | Integer:  integerType  -> basicType 
 | Floating:  floatingType  -> basicType .
Definition basicType_default: basicType  := Integer integerType_default.

(* STD Â§6.2.5#26, sentence 1-2 *)
Record qualifiers : Type (*[name = "^\\(\\|\\([a-z A-Z]+_\\)\\)qs[0-9]*'?$"]*) := {
  const    : bool ;
  restrict : bool ;
  volatile : bool 
  (* NOTE: the desugaring collapse _Atomic qualifiers and specifiers *)
}.
Notation "{[ r 'with' 'const' := e ]}" := ({| const := e; restrict := restrict r; volatile := volatile r |}).
Notation "{[ r 'with' 'restrict' := e ]}" := ({| restrict := e; const := const r; volatile := volatile r |}).
Notation "{[ r 'with' 'volatile' := e ]}" := ({| volatile := e; const := const r; restrict := restrict r |}).
Definition qualifiers_default: qualifiers  := {| const := bool_default; restrict := bool_default; volatile := bool_default |}.

Inductive ctype_ : Type := (*[name = "^\\([a-z A-Z]*_\\)?ty[0-9]*'?$"]*) 
 | Void: ctype_ 
 | Basic:  basicType  -> ctype_ 
   (* INVARIANT if the element ctype is an array, the qualifiers must be empty *)
   (* the qualifiers are that of the element type (Â§6.7.3#9) *)
   (* STD Â§6.2.5#20, bullet 1 *)
 | Array:  ctype  ->  (option  Z  ) -> ctype_ 
   (* NOTE: the qualifiers associated to a ctype in the
            list of parameters is that of the parameter lvalue. For example if
            we have a parameter with type "restrict pointer to a const char",
            the qualifiers in the tuple will be:
              {no_qualifiers with restrict=true} *)
   (* STD Â§6.2.5#20, bullet 4 *)
 | Function:  (* has_proto *)bool  ->  ((qualifiers  * ctype ) % type)
             ->  list  ((qualifiers  * ctype  * (* is_register *)bool ) % type)
             ->  (* is_variadic *)bool  -> ctype_ 
   (* STD Â§6.2.5#20, bullet 5 *)
   (* NOTE: the qualifiers are that of the referenced type *)
 | Pointer:  qualifiers  ->  ctype  -> ctype_ 
   (* STD Â§6.2.5#20, bullet 6 *)
 | Atomic:  ctype  -> ctype_ 
 | Struct:  symbol.sym  -> ctype_ 
 | Union:  symbol.sym  -> ctype_ 
with ctype : Type := 
  Ctype:  list  annot.annot  ->  ctype_  -> ctype .
Definition ctype__default: ctype_  := Void.
Definition ctype_default: ctype  := Ctype DAEMON ctype__default.

Definition struct_tag : Type :=  symbol.sym .
Definition struct_tag_default: struct_tag  := sym_default.
Definition union_tag : Type :=   symbol.sym .
Definition union_tag_default: union_tag  := sym_default.
Definition member_id : Type :=   symbol.sym .
Definition member_id_default: member_id  := sym_default.

Instance x25_Located : Located ctype := {
   locOf   cty :=  match ( cty) with ( Ctype annots1 _) => annot.get_loc_ annots1 end
}.


Inductive tag_definition : Type := 
  | StructDef:  list  ((symbol.identifier  * ((qualifiers  * ctype ) % type)) % type) -> tag_definition 
  | UnionDef:  list  ((symbol.identifier  * ((qualifiers  * ctype ) % type)) % type) -> tag_definition .
Definition tag_definition_default: tag_definition  := StructDef DAEMON.

(** Type class instances *)

Definition integerBaseTypeEqual  (ibty1 : integerBaseType ) (ibty2 : integerBaseType )  : bool := 
  let ord := fun (x : integerBaseType ) =>
   match (x) with | Ichar => ( 0 : nat ) | Short =>  1 | Int_ =>  2 | Long =>
      3 | LongLong =>  4 | IntN_t _ =>  5 | Int_leastN_t _ =>  6
     | Int_fastN_t _ =>  7 | Intmax_t =>  8 | Intptr_t =>  9 end in
  match ( (ibty1, ibty2)) with 
    | (IntN_t n1,  IntN_t n2) => beq_nat
        n1 n2
    | (Int_leastN_t n1,  Int_leastN_t n2) => beq_nat
        n1 n2
    | (Int_fastN_t n1,  Int_fastN_t n2) => beq_nat
        n1 n2
    | _ => beq_nat
        (ord ibty1) (ord ibty2)
  end.

Instance x24_Eq : Eq integerBaseType := {
   isEqual   :=  integerBaseTypeEqual;
   isInequal  :=  fun  ibty1  ibty2 => negb (integerBaseTypeEqual ibty1 ibty2)
}.


Definition integerTypeEqual  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  let ord := fun (x : integerType ) =>
   match (x) with | Char => ( 0 : nat ) | Bool =>  1 | Signed _ =>  2
     | Unsigned _ =>  3 | Enum _ =>  4 | Size_t =>  5 | Wchar_t =>  6
     | Wint_t =>  7 | Ptrdiff_t =>  8 end in
  match ( (ity1, ity2)) with 
    | (Signed ibty1,  Signed ibty2) => integerBaseTypeEqual
        ibty1 ibty2
    | (Unsigned ibty1,  Unsigned ibty2) => integerBaseTypeEqual
        ibty1 ibty2
    | (Enum sym1,  Enum sym2) => symbolEqual0
        sym1 sym2
    | _ => beq_nat
        (ord ity1) (ord ity2)
  end.

Instance x23_Eq : Eq integerType := {
   isEqual   :=  integerTypeEqual;
   isInequal  :=  fun  ity1  ity2 => negb (integerTypeEqual ity1 ity2)
}.


Instance x22_Eq : Eq realFloatingType := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.


Instance x21_Eq : Eq floatingType := {
   isEqual   :=  classical_boolean_equivalence;
   isInequal  :=  unsafe_structural_inequality
}.



(* STD Â§6.2.5#14, sentence 3 *)
Definition basicTypeEqual  (bty1 : basicType ) (bty2 : basicType )  : bool := 
  let ord := fun (x : basicType ) =>
   match (x) with | Integer _ => ( 0 : nat ) | Floating _ =>  1 end in
  match ( (bty1, bty2)) with 
    | (Integer ity1,  Integer ity2) => integerTypeEqual
        ity1 ity2
    | (Floating fty1,  Floating fty2) => classical_boolean_equivalence
        fty1 fty2
    | _ => beq_nat
        (ord bty1) (ord bty2)
  end.

Instance x20_Eq : Eq basicType := {
   isEqual   :=  basicTypeEqual;
   isInequal  :=  fun  bty1  bty2 => negb (basicTypeEqual bty1 bty2)
}.



Definition qualifiersEqual  (qs1 : qualifiers ) (qs2 : qualifiers )  : bool :=     Bool.eqb(const  
     qs1)(const  qs2)
  && (Bool.eqb(restrict  qs1)(restrict  qs2)
  && Bool.eqb(volatile  qs1)(volatile  qs2)).

Instance x19_Eq : Eq qualifiers := {
   isEqual   :=  qualifiersEqual;
   isInequal  :=  fun  qs1  qs2 => negb (qualifiersEqual qs1 qs2)
}.

Definition ctypeEqual   : ctype  -> ctype  -> bool :=  classical_boolean_equivalence. (* CHECK *)

Instance x18_Eq : Eq ctype := {
   isEqual   :=  ctypeEqual;
   isInequal  :=  fun  ty1  ty2 => negb (ctypeEqual ty1 ty2)
}.


Definition setElemCompare_integerBaseType  (ibty1 : integerBaseType ) (ibty2 : integerBaseType )  : ordering := 
  let ord := fun (x : integerBaseType ) =>
   match (x) with | Ichar => ( 0 : nat ) | Short =>  1 | Int_ =>  2 | Long =>
      3 | LongLong =>  4 | IntN_t _ =>  5 | Int_leastN_t _ =>  6
     | Int_fastN_t _ =>  7 | Intmax_t =>  8 | Intptr_t =>  9 end in
  match ( (ibty1, ibty2)) with 
    | (IntN_t n1,  IntN_t n2) =>
        (genericCompare nat_ltb beq_nat n1 n2)
    | (Int_leastN_t n1,  Int_leastN_t n2) =>
        (genericCompare nat_ltb beq_nat n1 n2)
    | (Int_fastN_t n1,  Int_fastN_t n2) =>
        (genericCompare nat_ltb beq_nat n1 n2)
    | _ =>
        (genericCompare nat_ltb beq_nat (ord ibty1) (ord ibty2))
  end.

Instance x17_SetType : SetType integerBaseType := {
   setElemCompare  :=  setElemCompare_integerBaseType
}.


Definition setElemCompare_integerType  (ity1 : integerType ) (ity2 : integerType )  : ordering := 
  let ord := fun (x : integerType ) =>
   match (x) with | Char => ( 0 : nat ) | Bool =>  1 | Signed _ =>  2
     | Unsigned _ =>  3 | Enum _ =>  4 | Size_t =>  5 | Wchar_t =>  6
     | Wint_t =>  7 | Ptrdiff_t =>  8 end in
  match ( (ity1, ity2)) with 
    | (Signed ibty1,  Signed ibty2) =>
        setElemCompare_integerBaseType ibty1 ibty2
    | (Unsigned ibty1,  Unsigned ibty2) =>
        setElemCompare_integerBaseType ibty1 ibty2
    | (Enum sym1,  Enum sym2) =>
        ordCompare sym1 sym2
    | _ =>
        (genericCompare nat_ltb beq_nat (ord ity1) (ord ity2))
  end.

Instance x16_SetType : SetType integerType := {
   setElemCompare  :=  setElemCompare_integerType
}.



Definition setElemCompare_basicType  (bty1 : basicType ) (bty2 : basicType )  : ordering := 
  let ord := fun (x : basicType ) =>
   match (x) with | Integer _ => ( 0 : nat ) | Floating _ =>  1 end in
  match ( (bty1, bty2)) with 
    | (Integer ity1,  Integer ity2) =>
        setElemCompare_integerType ity1 ity2
    | (Floating str1,  Floating str2) =>
        EQ
    | _ =>
        (genericCompare nat_ltb beq_nat (ord bty1) (ord bty2))
  end.

Instance x15_SetType : SetType basicType := {
   setElemCompare  :=  setElemCompare_basicType
}.



Instance x14_SetType : SetType qualifiers := {
   setElemCompare   qs1  qs2 := 
    (tripleCompare boolCompare boolCompare boolCompare ((const qs1),(restrict  qs1),(volatile  qs1))
                   ((const qs2),(restrict  qs2),(volatile  qs2)))
}.



Instance x13_Show : Show tag_definition := {
   show   def := 
    let string_of_identifiers := (fun  tag_defs => 
      String.append(List.fold_left (
  fun acc p =>
    match ( (acc ,p) ) with ( acc ,  (i, _)) =>
      String.append acc
        (String.append (match ( i) with Identifier0 _ str => str end) "; ")
    end
      ) tag_defs "[") "]")
    in
    match ( def) with 
      | StructDef tag_defs => string_of_identifiers tag_defs
      | UnionDef tag_defs => string_of_identifiers tag_defs
    end
}.

(* [?]: removed value specification. *)

Definition proj_ctype_  (c : ctype )  : ctype_ := 
  match ( (c)) with (( Ctype _ ty_)) => ty_ end.

(* NOTE: a well-formed ctype cannot have an Atomic inside another one *)
Definition unatomic  (c : ctype )  : ctype := 
  match ( (c)) with ( Ctype annots1 ty_ as ty) =>
    match ( ty_) with | Atomic ty => ty | _ => ty end end.

Definition unatomic_  (ty : ctype )  : ctype_ := 
  proj_ctype_ (unatomic ty).
(* [?]: removed value specification. *)

Definition make_qualifiers  (c : bool ) (r : bool ) (v : bool )  : qualifiers :=  {|const    := c;restrict := r;volatile := v
|}.
(* [?]: removed value specification. *)

Definition no_qualifiers   : qualifiers :=  {|const    := false;restrict := false;volatile := false
|}.
(* [?]: removed value specification. *)

Definition combine_qualifiers  (qs1 : qualifiers ) (qs2 : qualifiers )  : qualifiers :=  {|const    := ((const qs1)    ||(const  qs2))   ;restrict := ((restrict qs1) ||(restrict  qs2));volatile := ((volatile qs1) ||(volatile  qs2))
|}.


(* Some constructors *)

Definition mk_ctype_pointer  (qs : qualifiers ) (ty : ctype )  : ctype := 
  Ctype [] (Pointer qs ty).

Definition mk_ctype_integer  (ity : integerType )  : ctype := 
  Ctype [] (Basic (Integer ity)).

Definition mk_ctype_atomic  (cty : ctype )  : ctype := 
  Ctype [] (Atomic cty).
(* [?]: removed value specification. *)

Definition void   : ctype := 
  Ctype [] Void.
(* [?]: removed value specification. *)

Definition char   : ctype := 
  Ctype [] (Basic (Integer Char)).
(* [?]: removed value specification. *)

Definition signed_char   : ctype := 
  Ctype [] (Basic (Integer (Signed Ichar))).
(* [?]: removed value specification. *)

Definition signed_short   : ctype := 
  Ctype [] (Basic (Integer (Signed Short))).
(* [?]: removed value specification. *)

Definition signed_int   : ctype := 
  Ctype [] (Basic (Integer (Signed Int_))).
(* [?]: removed value specification. *)

Definition signed_long   : ctype := 
  Ctype [] (Basic (Integer (Signed Long))).
(* [?]: removed value specification. *)

Definition signed_long_long   : ctype := 
  Ctype [] (Basic (Integer (Signed LongLong))).
(* [?]: removed value specification. *)

Definition intptr_t   : ctype := 
  Ctype [] (Basic (Integer (Signed Intptr_t))).
(* [?]: removed value specification. *)

Definition intmax_t   : ctype := 
  Ctype [] (Basic (Integer (Signed Intmax_t))).
(* [?]: removed value specification. *)

Definition unsigned_char   : ctype := 
  Ctype [] (Basic (Integer (Unsigned (Ichar)))).
(* [?]: removed value specification. *)

Definition unsigned_short   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Short))).
(* [?]: removed value specification. *)

Definition unsigned_int   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Int_))).
(* [?]: removed value specification. *)

Definition unsigned_long   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Long))).
(* [?]: removed value specification. *)

Definition unsigned_long_long   : ctype := 
  Ctype [] (Basic (Integer (Unsigned LongLong))).
(* [?]: removed value specification. *)

Definition uintptr_t   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Intptr_t))).
(* [?]: removed value specification. *)

Definition uintmax_t   : ctype := 
  Ctype [] (Basic (Integer (Unsigned Intmax_t))).
(* [?]: removed value specification. *)

Definition char16_t   : ctype := 
  (* STD Â§7.28#2 *)
  Ctype [] (Basic (Integer (Unsigned (Int_leastN_t( 16))))).
(* [?]: removed value specification. *)

Definition char32_t   : ctype := 
  (* STD Â§7.28#2 *)
  Ctype [] (Basic (Integer (Unsigned (Int_leastN_t( 32))))).
(* [?]: removed value specification. *)

Definition wchar_t   : ctype := 
  Ctype [] (Basic (Integer Wchar_t)).
(* [?]: removed value specification. *)

Definition size_t   : ctype := 
  Ctype [] (Basic (Integer Size_t)).
(* [?]: removed value specification. *)

Definition ptrdiff_t   : ctype := 
  Ctype [] (Basic (Integer Ptrdiff_t)).

