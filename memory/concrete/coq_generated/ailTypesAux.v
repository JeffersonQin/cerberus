(* Generated by Lem from ocaml_generated/AilTypesAux.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import utils.
Require Export utils.
Require Import ailSyntax.
Require Export ailSyntax.
Require Import errorMonad.
Require Export errorMonad.
Require Import typingError.
Require Export typingError.
Require Import annot.
Require Export annot.
Require Import ctype.
Require Export ctype.

Require Import implementation.
Require Export implementation.
Require Import integerImpl.
Require Export integerImpl.
Require Import loc.
Require Export loc.
Require Import debug.
Require Export debug.

(* [?]: removed value specification. *)

Definition is_unqualified   : qualifiers  -> bool :=  
  fun (x : qualifiers ) =>
    match (((const x),(restrict x),(volatile x))) with
        ( false,  false,  false) => true | ( _,  _,  _) => false end.
(* [?]: removed value specification. *)

Definition sub_qualifiers  (qs1 : qualifiers ) (qs2 : qualifiers )  : bool := 
     (    ((negb(const  qs1)) ||(const  qs2)))
  && (( ((negb(restrict  qs1)) ||(restrict  qs2)))
  && ( ((negb(volatile  qs1)) ||(volatile  qs2)))).
(* [?]: removed value specification. *)

Program Fixpoint is_signed_ity  (ity : integerType )  : bool := 
  match ( ity) with 
    | Char =>
        Coq_implementation.Impl.is_signed_ity Char
    | Bool =>
        false
    | Signed _ =>
        true
    | Unsigned _ =>
        false
    | Enum tag_sym =>
        is_signed_ity (Coq_implementation.Impl.typeof_enum tag_sym)
    | Size_t =>
        (* STD Â§7.19#2 *)
        false
    | Wchar_t =>
        Coq_implementation.Impl.is_signed_ity Wchar_t
    | Wint_t =>
        Coq_implementation.Impl.is_signed_ity Wint_t
    | Ptrdiff_t =>
        (* STD Â§7.19#2 *)
        true
  end.
(* [?]: removed value specification. *)

Definition is_unsigned_ity  (ity : integerType )  : bool := 
  negb (is_signed_ity ity).
(* [?]: removed value specification. *)

Definition is_integer  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Basic( Integer _) => true | _ => false end end.
(* [?]: removed value specification. *)

Definition is_floating  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Basic( Floating _) => true | _ => false end end.
(* [?]: removed value specification. *)

Definition is_void  (ty : ctype )  : bool := 
  match ( unatomic_ ty) with 
  | Void =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_pointer  (ty : ctype )  : bool := 
   (* STD Â§6.2.5#22, sentence 3-4 *)
  match ( unatomic_ ty) with 
  | Pointer _ _ =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_atomic   : ctype  -> bool :=  
  fun (x : ctype ) =>
    match (x) with | Ctype _( Atomic _) => (* STD ÃÂ§6.2.5#20, bullet 6 *)
    true | _ => false end.
(* [?]: removed value specification. *)

Definition atomic_qualified_unqualified  (pred : ctype  -> bool )  : ctype  -> bool :=  
  fun (x : ctype ) =>
    match (x) with | Ctype _( Atomic ty) => pred ty | ty => pred ty end.
(* [?]: removed value specification. *)

Definition is_character  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Basic( Integer Char) =>
      true
  | Basic( Integer( Signed Ichar)) =>
      true
  | Basic( Integer( Unsigned Ichar)) =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_Bool  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Basic( Integer Bool) =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_array  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Array _ _ =>
      true
(*  | Builtin "jmp_buf" ->
      true
  | Builtin "fpos_t" ->
      false *)
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_array_unknown_size  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
    | Array _ None =>
        true
    | _ =>
        false
  end.
(* [?]: removed value specification. *)

Definition is_array_of_character  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Array elem_ty _ =>
      is_character elem_ty
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_function  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Function _ _ _ _ =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_struct  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Struct _ =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_union  (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Union _ =>
      true
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_struct_or_union  (ty : ctype )  : bool := 
  is_struct ty || is_union ty.
(* [?]: removed value specification. *)

Definition has_flexible_array_member {a : Type}  (sigm : sigma a) (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
    | Struct tag_sym =>
        match ( (lookupBy symbol.symbolEqual0 tag_sym(tag_definitions  sigm))) with 
          | Some( StructDef membersDefs) =>
              match ( lem_list.dest_init membersDefs) with 
                | Some (_,  (_,  (_,  last_ty))) =>
                    (* NOTE: this assumes membersDefs is wf
                       (i.e. it has more than one element) *)
                    is_array_unknown_size last_ty
                | None =>
                    false
              end
          | _ =>
              DAEMON
        end
    | _ =>
        false
end.
(* [?]: removed value specification. *)

Definition is_object  (ty : ctype )  : bool := 
  negb (is_function ty).
(* [?]: removed value specification. *)

Definition is_arithmetic  (ty : ctype )  : bool := 
  is_integer ty || is_floating ty.
(* [?]: removed value specification. *)

Definition is_scalar  (ty : ctype )  : bool := 
  is_pointer ty || is_arithmetic ty.
(* [?]: removed value specification. *)

Definition is_aggregate  (ty : ctype )  : bool := 
  is_array ty || is_struct ty.
(* [?]: removed value specification. *)

Definition is_derived  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Array _ _ => true | Struct _ => true | Union _ => true
      | Function _ _ _ _ => true | Pointer _ _ => true | Atomic _ => true
      | _ => false end end.
(* [?]: removed value specification. *)

Definition is_derived_declarator  (ty : ctype )  : bool := 
  match ( unatomic_ ty) with 
  | Array _ _ => true
  | Function _ _ _ _ => true
  | Pointer _ _ => true
  | _ => false
  end.
(* [?]: removed value specification. *)

Definition is_complete {a : Type}  (sigm : sigma a) (ty : ctype )  : bool := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Void =>
      (* STD Â§6.2.5#19 *)
      false
  | Basic _ =>
      (* STD Â§6.2.5#14, sentence 2 *)
      true
  | Pointer _ _ =>
      true
  | Array _ n_opt =>
      (* STD Â§6.2.5#22, sentence 1-2 *)
      (* STD Â§6.7.6.2#4, sentence 1 *)
      isJust n_opt
    (* STD Â§6.2.5#22, sentence 3-4 *)
  | Struct sym1 =>
      match ( (lookupBy symbol.symbolEqual0 sym1(tag_definitions  sigm))) with 
        | Some( StructDef _) =>
            true
        | _ =>
            let _ := debug.print_debug( 5) [debug.DB_ail_typing]
                (fun (u : unit ) =>
  match ( (u) ) with ( tt) =>
    String.append "is_complete failed on struct tag: "
      (String.append
         match ( sym1) with symbol.Symbol0 d n str_opt =>
           String.append "Symbol"
             (stringFromPair
                (fun (n : nat )=>
                   Coq.Numbers.DecimalString.NilZero.string_of_int
                     (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n)))
                (fun (x_opt : option (string ) )=>
                   stringFromMaybe
                     (fun (s : string )=>
                        String.append """" (String.append s """")) x_opt)
                (n, str_opt)) end
         (String.append " with env: "
            (stringFromList
               (stringFromPair
                  (fun (sym1 : symbol.sym )=>
                     match ( sym1) with symbol.Symbol0 d n str_opt =>
                       String.append "Symbol"
                         (stringFromPair
                            (fun (n : nat )=>
                               Coq.Numbers.DecimalString.NilZero.string_of_int
                                 (Z.to_int (Coq.ZArith.BinIntDef.Z.of_nat n)))
                            (fun (x_opt : option (string ) )=>
                               stringFromMaybe
                                 (fun (s : string )=>
                                    String.append """" (String.append s """"))
                                 x_opt) (n, str_opt)) end)
                  (fun (def : tag_definition )=>
                     let string_of_identifiers := (fun (tag_defs : list ((symbol.identifier *((qualifiers *ctype ) % type)) % type)) =>
                                                     String.append
                                                       (List.fold_left
                                                          (fun (acc : string ) (p : (symbol.identifier *((qualifiers *ctype ) % type)) % type) =>
                                                             match ( (acc ,p) ) with
                                                                 ( acc ,  (i, _)) =>
                                                               String.append
                                                                 acc
                                                                 (String.append
                                                                    (
                                                                    match ( i) with
                                                                    symbol.Identifier0 _ str =>
                                                                    str end)
                                                                    "; ") end
                                                          ) tag_defs 
                                                        "[") "]") in
                     match ( def) with | StructDef tag_defs =>
                       string_of_identifiers tag_defs | UnionDef tag_defs =>
                       string_of_identifiers tag_defs end))
               (tag_definitions  sigm)))) end) in
            false
      end
    (* STD Â§6.2.5#22, sentence 3-4 *)
  | Union sym1 =>
      match ( (lookupBy symbol.symbolEqual0 sym1(tag_definitions  sigm))) with 
        | Some( UnionDef _) =>
            true
        | _ =>
            false
      end
  | _ =>
      false
end.
(* [?]: removed value specification. *)

Definition is_incomplete {a : Type}  (sigm : sigma a) (ty : ctype )  : bool := 
  negb (is_complete sigm ty).
(* [?]: removed value specification. *)

Definition in_integer_range  (impl1 : integerImpl.implementation ) (n : Z ) (ity : integerType )  : bool := 
  range.mem n (integerImpl.integer_range impl1 ity).
(* [?]: removed value specification. *)

Definition in_min_integer_range  (n : Z ) (ity : integerType )  : bool := 
  range.mem n (integerImpl.min_integer_range ity).
(* [?]: removed value specification. *)

Definition normalise_integerType  (ity : integerType )  : integerType := 
  match ( ity) with 
   | Enum tag_sym =>
       Coq_implementation.Impl.typeof_enum tag_sym
   | _ =>
       ity
  end.
(* [?]: removed value specification. *)

Definition le_integer_range  (impl1 : integerImpl.implementation ) (ity1 : integerType ) (ity2 : integerType )  : bool := 
  if integerTypeEqual ity1 ity2 then
    (* reflexive cases *)
    true
  else match ( (normalise_integerType ity1, normalise_integerType ity2)) with 
    | (Char,  Signed Ichar) =>
        Coq_implementation.Impl.is_signed_ity Char
    | (Char,  Signed ibty) =>
        Coq_implementation.Impl.is_signed_ity Char || ((fun (m1 : option (nat ) ) => (fun (m2 : option (nat ) ) => (ordering_equal (maybeCompare (genericCompare nat_ltb beq_nat) m1 m2) LT))) (Coq_implementation.Impl.precision_ity Char) (Coq_implementation.Impl.precision_ity (Signed ibty)))
    | (Signed Ichar,  Char) =>
        Coq_implementation.Impl.is_signed_ity Char
    | (Signed ibty,  Char) =>
        Coq_implementation.Impl.is_signed_ity Char && (maybeEqualBy beq_nat (Coq_implementation.Impl.precision_ity (Signed ibty)) (Coq_implementation.Impl.precision_ity Char))
    | (Unsigned Ichar,  Char) =>
        negb (Coq_implementation.Impl.is_signed_ity Char)
    | (Unsigned ibty,  Char) =>
        negb (Coq_implementation.Impl.is_signed_ity Char) && (maybeEqualBy beq_nat (Coq_implementation.Impl.precision_ity (Unsigned ibty)) (Coq_implementation.Impl.precision_ity Char))
    | (Char,  Unsigned _) =>
        negb (Coq_implementation.Impl.is_signed_ity Char)
    | (Char,  Bool) =>
        negb (Coq_implementation.Impl.is_signed_ity Char) && (maybeEqualBy beq_nat (Coq_implementation.Impl.precision_ity Char) (Coq_implementation.Impl.precision_ity Bool))
    | (Bool,  Char) =>
        negb (Coq_implementation.Impl.is_signed_ity Char) || ((fun (m1 : option (nat ) ) => (fun (m2 : option (nat ) ) => (ordering_equal (maybeCompare (genericCompare nat_ltb beq_nat) m1 m2) LT))) (Coq_implementation.Impl.precision_ity Bool) (Coq_implementation.Impl.precision_ity Char))

    | (Signed Ichar,  Signed _) =>
        true
    | (Signed Short,  Signed Int_) =>
        true
    | (Signed Short,  Signed Long) =>
        true
    | (Signed Short,  Signed LongLong) =>
        true
    | (Signed Int_,  Signed Long) =>
        true
    | (Signed Int_,  Signed LongLong) =>
        true
    | (Signed Long,  Signed LongLong) =>
        true
    | (Signed ibty1,  Signed ibty2) => (maybeEqualBy beq_nat
        (Coq_implementation.Impl.precision_ity (Signed ibty1)) (Coq_implementation.Impl.precision_ity (Signed ibty2)))
    | (Signed _,  Bool) =>
        false
    | (Bool,  Signed ibty2) => ((fun (m1 : option (nat ) ) => (fun (m2 : option (nat ) ) => (ordering_equal (maybeCompare (genericCompare nat_ltb beq_nat) m1 m2) LT)))
        (Coq_implementation.Impl.precision_ity Bool) (Coq_implementation.Impl.precision_ity (Signed ibty2)))
    
    | (Bool,  Unsigned _) =>
        true
    | (Unsigned Ichar,  Unsigned _) =>
        true
    | (Unsigned Short,  Unsigned Int_) =>
        true
    | (Unsigned Short,  Unsigned Long) =>
        true
    | (Unsigned Short,  Unsigned LongLong) =>
        true
    | (Unsigned Int_,  Unsigned Long) =>
        true
    | (Unsigned Int_,  Unsigned LongLong) =>
        true
    | (Unsigned Long,  Unsigned LongLong) =>
        true
    | (Unsigned ibty,  Bool) => (maybeEqualBy beq_nat
        (Coq_implementation.Impl.precision_ity (Unsigned ibty)) (Coq_implementation.Impl.precision_ity Bool))
    | (Unsigned ibty1,  Unsigned ibty2) => (maybeEqualBy beq_nat
        (Coq_implementation.Impl.precision_ity (Unsigned ibty1)) (Coq_implementation.Impl.precision_ity (Unsigned ibty2)))
    
    | (Signed _,  Unsigned _) =>
        false
    
    | (Unsigned _,  Signed Ichar) =>
        false
    | (Unsigned Short,  Signed Short) =>
        false
    | (Unsigned Int_,  Signed Int_) =>
        false
    | (Unsigned Long,  Signed Long) =>
        false
    | (Unsigned LongLong,  Signed LongLong) =>
        false
    | (Unsigned ibty1,  Signed ibty2) => ((fun (m1 : option (nat ) ) => (fun (m2 : option (nat ) ) => (ordering_equal (maybeCompare (genericCompare nat_ltb beq_nat) m1 m2) LT)))
        (Coq_implementation.Impl.precision_ity (Unsigned ibty1)) (Coq_implementation.Impl.precision_ity (Signed ibty2)))
      
  | (Char,  Char) => true
  | (Bool,  Bool) => true
  | (Size_t,  Size_t) => true
  | (Wchar_t,  Wchar_t) => true
  | (Ptrdiff_t,  Ptrdiff_t) => true
  | (Enum _,  Enum _) =>
      (* impossible *)
      DAEMON
  
  | (Char,  Size_t) =>
      DAEMON
  | (Char,  Ptrdiff_t) =>
      DAEMON
  | (Char,  Enum _) =>
      DAEMON
  
  | (Bool,  Size_t) =>
      DAEMON
  | (Bool,  Ptrdiff_t) =>
      DAEMON
  | (Bool,  Enum _) =>
      (* impossible *)
      DAEMON
  
  | (Signed _,  Size_t) =>
      DAEMON
  | (Signed _,  Ptrdiff_t) =>
      DAEMON
  | (Signed _,  Enum _) =>
      (* impossible *)
      DAEMON
  
  | (Unsigned _,  Size_t) =>
      DAEMON
  | (Unsigned _,  Ptrdiff_t) =>
      DAEMON
  | (Unsigned _,  Enum _) =>
      (* impossible *)
      DAEMON
  
  | (Ptrdiff_t,  Char) =>
      DAEMON
  | (Ptrdiff_t,  Bool) =>
      DAEMON
  | (Ptrdiff_t,  Signed _) =>
      DAEMON
  | (Ptrdiff_t,  Unsigned _) =>
      DAEMON
  | (Ptrdiff_t,  Enum _) =>
      (* impossible *)
      DAEMON
  | (Ptrdiff_t,  Size_t) =>
      DAEMON
  
  | (Size_t,  Char) =>
      DAEMON
  | (Size_t,  Bool) =>
      DAEMON
  | (Size_t,  Signed _) =>
      DAEMON
  | (Size_t,  Unsigned _) =>
      DAEMON
  | (Size_t,  Enum _) =>
      (* impossible *)
      DAEMON
  | (Size_t,  Ptrdiff_t) =>
      DAEMON
  
  | (Enum _,  Char) =>
      (* impossible *)
      DAEMON
  | (Enum _,  Bool) =>
      (* impossible *)
      DAEMON
  | (Enum _,  Signed _) =>
      (* impossible *)
      DAEMON
  | (Enum _,  Unsigned _) =>
      (* impossible *)
      DAEMON
  | (Enum _,  Size_t) =>
      (* impossible *)
      DAEMON
  | (Enum _,  Ptrdiff_t) =>
      (* impossible *)
      DAEMON

  | (Wchar_t,  _) =>
      DAEMON
  | (_,  Wchar_t) =>
      DAEMON
  | (Wint_t,  _) =>
      DAEMON
  | (_,  Wint_t) =>
      DAEMON
  end.
(* [?]: removed value specification. *)

Definition eq_integer_rank_base  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  match ( (ity1, ity2)) with 
  (* STD Â§6.3.1.1#1, bullet 4 *)
  | (Signed ibty1,  Unsigned ibty2) => integerBaseTypeEqual
      ibty1 ibty2
  | (Unsigned ibty1,  Signed ibty2) => integerBaseTypeEqual
      ibty1 ibty2
  (* STD Â§6.3.1.1#1, bullet 6 *)
  | (Char,  Unsigned Ichar) =>
      true
  | (Char,  Signed Ichar) =>
      true
  | (Unsigned Ichar,  Char) =>
      true
  | (Signed Ichar,  Char) =>
      true
  | _ =>
      false
  end.
(* [?]: removed value specification. *)

Definition eq_integer_rank  (ity1 : integerType ) (ity2 : integerType )  : bool :=  integerTypeEqual
  ity1 ity2 || eq_integer_rank_base ity1 ity2.
(* [?]: removed value specification. *)

Definition lt_integer_rank  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  match ( (ity1, ity2)) with 
    | (_,  Bool) =>
        false
    | (Bool,  _) =>
        true
    
    | (_,  Char) =>
        false
    | (_,  Signed Ichar) =>
        false
    | (_,  Unsigned Ichar) =>
        false
    | (Char,  Signed _) =>
        true
    | (Char,  Unsigned _) =>
        true
    | (Signed Ichar,  Signed _) =>
        true
    | (Signed Ichar,  Unsigned _) =>
        true
    | (Unsigned Ichar,  Signed _) =>
        true
    | (Unsigned Ichar,  Unsigned _) =>
        true
    
    | (_,  Signed Short) =>
        false
    | (_,  Unsigned Short) =>
        false
    | (Signed Short,  Signed _) =>
        true
    | (Signed Short,  Unsigned _) =>
        true
    | (Unsigned Short,  Signed _) =>
        true
    | (Unsigned Short,  Unsigned _) =>
        true
    
    | (_,  Signed Int_) =>
        false
    | (_,  Unsigned Int_) =>
        false
    | (Signed Int_,  Signed _) =>
        true
    | (Signed Int_,  Unsigned _) =>
        true
    | (Unsigned Int_,  Signed _) =>
        true
    | (Unsigned Int_,  Unsigned _) =>
        true
    
    | (_,  Signed Long) =>
        false
    | (_,  Unsigned Long) =>
        false
    | (Signed Long,  Signed _) =>
        true
    | (Signed Long,  Unsigned _) =>
        true
    | (Unsigned Long,  Signed _) =>
        true
    | (Unsigned Long,  Unsigned _) =>
        true
    
    | _ =>
        (* TODO: this is probably wrong for macro types *)
        false
  end.
(* [?]: removed value specification. *)

Definition le_integer_rank  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  eq_integer_rank ity1 ity2 || lt_integer_rank ity1 ity2.
(* [?]: removed value specification. *)

Definition ge_integer_rank  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  le_integer_rank ity2 ity1.
(* [?]: removed value specification. *)

Definition le_real_floating_range  (fty1 : realFloatingType ) (fty2 : realFloatingType )  : bool := 
  match ( (fty1, fty2)) with 
  | (Float,  _) => true
  | (Double,  Double) => true
  | (_,  LongDouble) => true
  | _ => false
  end.
(* [?]: removed value specification. *)

Definition is_corresponding_unsigned  (ity1 : integerType ) (ity2 : integerType )  : bool := 
  match ( (ity1, ity2)) with 
    | (Signed ibty1,  Unsigned ibty2) => integerBaseTypeEqual
        ibty1 ibty2
    | (_,  _) =>
        false
  end.
(* [?]: removed value specification. *)

Definition corresponding_unsigned   : integerType  -> option (integerType ) :=  
  fun (x : integerType ) =>
    match (x) with | Signed ibty => Some (Unsigned ibty) | _ => None end.
(* [?]: removed value specification. *)

Definition make_corresponding_unsigned   : integerType  -> integerType :=  
  fun (x : integerType ) =>
    match (x) with | Signed ibty => Unsigned ibty | ity => ity end.
(* [?]: removed value specification. *)

Definition integer_promotion  (impl1 : integerImpl.implementation )  : integerType  -> integerType :=  
  fun (x : integerType ) =>
    match (x) with | Signed Int_ => Signed Int_ | Unsigned Int_ =>
      Unsigned Int_ | Size_t =>
      (* TODO: this is not standard, but in cerberus we don't treat size_t as an aliased type *)
    Size_t | Signed Intptr_t =>
      (* TODO: this is not standard, but in cerberus we don't treat intptr_t as aliased types *)
      Signed Intptr_t | Unsigned Intptr_t =>
      (* TODO: this is not standard, but in cerberus we don't treat uintptr_t as aliased types *)
      Unsigned Intptr_t | ity =>
      if le_integer_rank ity (Signed Int_) then
        if le_integer_range impl1 ity (Signed Int_) then Signed Int_ else
          Unsigned Int_ else ity end.
(* [?]: removed value specification. *)

Definition promotion  (impl1 : integerImpl.implementation )  : ctype  -> option (ctype ) :=  
  fun (x : ctype ) =>
    match (x) with | Ctype annots1( Basic( Integer ity)) =>
      Some (Ctype annots1 (Basic (Integer (integer_promotion impl1 ity))))
      | _ => None end.
(* [?]: removed value specification. *)

Definition usual_arithmetic_integer  (impl1 : integerImpl.implementation ) (ity1 : integerType ) (ity2 : integerType )  : integerType :=  
  (* TODO: this is not standard, but in cerberus we don't treat (u)intptr_t and size_t as an aliased types *)
  match ( debug.warn []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "NON STD: usual_arithmetic_integer ==> if any operand is of type size_t, then the common type is size_t"
               end )) with tt =>
    match ( (ity1, ity2)) with | (Size_t,  _) => Size_t | (_,  Size_t) =>
      Size_t | (Signed Intptr_t,  Unsigned Intptr_t) => Unsigned Intptr_t
      | (Signed Intptr_t,  _) => Signed Intptr_t
      | (Unsigned Intptr_t,  Signed Intptr_t) => Unsigned Intptr_t
      | (_,  Signed Intptr_t) => Signed Intptr_t | (Unsigned Intptr_t,  _) =>
      Unsigned Intptr_t | (_,  Unsigned Intptr_t) => Unsigned Intptr_t | _ =>
      let promoted_ity1 := integer_promotion impl1 ity1 in
    let promoted_ity2 := integer_promotion impl1 ity2 in
    if (is_signed_ity promoted_ity1 && is_signed_ity promoted_ity2) ||
       (is_unsigned_ity promoted_ity1 && is_unsigned_ity promoted_ity2) then
      if lt_integer_rank promoted_ity1 promoted_ity2 then promoted_ity2 else
        promoted_ity1 else
      if is_unsigned_ity promoted_ity1 &&
         ge_integer_rank promoted_ity1 promoted_ity2 then promoted_ity1 else
        if is_unsigned_ity promoted_ity2 &&
           ge_integer_rank promoted_ity2 promoted_ity1 then promoted_ity2
        else
          if is_signed_ity promoted_ity1 then
            if le_integer_range impl1 promoted_ity2 promoted_ity1 then
              promoted_ity1 else make_corresponding_unsigned promoted_ity1
          else
            (* if is_signed_ity promoted_ity2 then *)
            if le_integer_range impl1 promoted_ity1 promoted_ity2 then
              promoted_ity2 else make_corresponding_unsigned promoted_ity2
    (*
        let promoted_ity1 = integer_promotion impl ity1 in
        let promoted_ity2 = integer_promotion impl ity2 in
        if is_signed_ity promoted_ity1 then
          if is_signed_ity promoted_ity2 then
            if lt_integer_rank promoted_ity2 promoted_ity1 then
              promoted_ity1
            else
              promoted_ity2
          else
            if le_integer_rank promoted_ity1 promoted_ity2 then
              promoted_ity2
            else
              if le_integer_range impl promoted_ity2 promoted_ity1 then
                promoted_ity1
              else
                make_corresponding_unsigned promoted_ity1
        else
          if is_unsigned_ity promoted_ity2 then
            if lt_integer_rank promoted_ity2 promoted_ity1 then
              promoted_ity1
            else
              promoted_ity2
          else
            if le_integer_rank promoted_ity2 promoted_ity1 then
              promoted_ity1
            else if le_integer_range impl promoted_ity1 promoted_ity2 then
              promoted_ity2
            else
              make_corresponding_unsigned promoted_ity2
*)
    end end.
(* [?]: removed value specification. *)

Definition usual_arithmetic_floating  (impl1 : integerImpl.implementation ) (ty1 : floatingType ) (ty2 : floatingType )  : floatingType :=  ty1.
(* [?]: removed value specification. *)

Definition corresponding_real_type  (c : ctype )  : option (realFloatingType ) := 
  match ( (c)) with ( Ctype _ ty as cty) =>
    if is_floating cty then
      match ( ty) with | Basic( Floating( RealFloating rfty)) => Some rfty
      (*
    | Basic (Floating (Complex fty))
        Basic (Floating fty)
*)
        | _ => DAEMON end else None end.
(* [?]: removed value specification. *)

Definition modifiable {a : Type}  (sigm : sigma a) (qs : qualifiers ) (ty : ctype )  : bool := 
  negb (is_array ty) &&
  (negb ((const qs)) &&
  (is_object ty &&
  negb (is_incomplete sigm ty))).
(* [?]: removed value specification. *)

Definition is_real  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Basic( Integer _) => true
      | Basic( Floating( RealFloating _)) => true | _ => false end end.
(* [?]: removed value specification. *)

Program Fixpoint        are_compatible  (p : (qualifiers *ctype ) % type) (p0 : (qualifiers *ctype ) % type)  : bool := 
  match ( (p,p0)) with ( (qs1,  Ctype _ ty1),  (qs2,  Ctype _ ty2)) =>
    qualifiersEqual qs1 qs2 &&
    match ( (ty1, ty2)) with | (Void,  Void) => true
      | (Basic bty1,  Basic bty2) =>
      match ( match ( (bty1, bty2)) with
                    | (Integer( Enum tag_sym1),  Integer( Enum tag_sym2)) =>
                (Integer (Coq_implementation.Impl.typeof_enum tag_sym1), 
              Integer (Coq_implementation.Impl.typeof_enum tag_sym2))
                | (Integer( Enum tag_sym1),  _) =>
                (Integer (Coq_implementation.Impl.typeof_enum tag_sym1), bty2)
                | (_,  Integer( Enum tag_sym2)) =>
                (bty1, Integer (Coq_implementation.Impl.typeof_enum tag_sym2))
                | _ => (bty1, bty2) end) with (bty1',  bty2') =>
        basicTypeEqual bty1' bty2' end
      | (Array elem_ty1 n1_opt,  Array elem_ty2 n2_opt) =>
      (* STD ÃÂ§6.7.6.2#6 *) are_compatible (no_qualifiers, elem_ty1)
        (no_qualifiers, elem_ty2) &&
      match ( (n1_opt, n1_opt)) with | (Some n1,  Some n2) => Z.eqb n1 n2
        | (Some _ ,  None) => true | (None,  Some _) => true
        | (None,  None) => true end
      | (Function _ (ret_qs1,  ret_ty1) params1 isVariadic1,  Function _ (ret_qs2,  ret_ty2) params2 isVariadic2) =>
      (* STD ÃÂ§6.7.6.3#15 *)
      (* TODO: when the two types do not both have a param list *)
      are_compatible (ret_qs1, ret_ty1) (ret_qs2, ret_ty2) &&
      (are_compatible_params params1 params2 &&
       Bool.eqb isVariadic1 isVariadic2)
      | (Pointer ref_qs1 ref_ty1,  Pointer ref_qs2 ref_ty2) =>
      (* STD ÃÂ§6.7.6.1#2 *) are_compatible (ref_qs1, ref_ty1)
        (ref_qs2, ref_ty2) | (Struct tag1,  Struct tag2) =>
      symbol.symbolEqual0
        (* STD ÃÂ§6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *) tag1 
      tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
      | (Union tag1,  Union tag2) =>
      symbol.symbolEqual0
        (* STD ÃÂ§6.2.7#1 *)
        (* TODO: being conservative here (aka STD compliant) *) tag1 
      tag2 (* TODO/NOTE: just looking at the tag should be enough since we only have one translation unit (?) *)
      | (Atomic atom_ty1,  Atomic atom_ty2) =>
      are_compatible (no_qualifiers, atom_ty1) (no_qualifiers, atom_ty2)
      | _ =>
      (* TODO: we can't see Enum types here and there is some impl-def stuff *)
    false end end
with are_compatible_params_aux  (acc : bool )  : (list ((qualifiers *ctype *bool ) % type)*list ((qualifiers *ctype *bool ) % type)) % type -> bool := 
  match ( (acc)) with ( acc) =>
    fun (x : (list ((qualifiers *ctype *bool ) % type)*list ((qualifiers *ctype *bool ) % type)) % type) =>
      match (x) with | ([],  []) => acc
        | (((qs1,  ty1,  _) :: params1), ( (qs2,  ty2,  _) :: params2)) =>
        are_compatible_params_aux
          (
          (* NOTE(unsure): but as far as I can tell the twos parameters can differ
           on whether they have the register storage-class *)
          acc && are_compatible (qs1, ty1) (qs2, ty2) ) (params1, params2)
        | _ =>
        (* the list of params must have the same length to be compatible *)
      false end end
with are_compatible_params  (params1 : list ((qualifiers *ctype *bool ) % type)) (params2 : list ((qualifiers *ctype *bool ) % type))  : bool := 
  match ( (params1,params2)) with ( params1,  params2) =>
    are_compatible_params_aux true (params1, params2) end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition array_coercion  (c : ctype )  : ctype := 
  match ( (c)) with (( Ctype loc ty)) =>
    apply (Ctype loc)
      match ( ty) with | Array elem_ty _ => Pointer no_qualifiers elem_ty
        | ty => ty end end.
(* [?]: removed value specification. *)

Definition function_coercion  (c : ctype )  : ctype := 
  match ( (c)) with (( Ctype loc ty)) =>
    apply (Ctype loc)
      match ( ty) with | Function hasProto ret_qs_ty params isVariadic =>
        Pointer no_qualifiers
          (Ctype [] (Function hasProto ret_qs_ty params isVariadic)) | ty =>
        ty end end.
(* [?]: removed value specification. *)

Definition lvalue_convertible {a : Type}  (S1 : sigma a) (ty : ctype )  : bool := 
  negb (is_array ty) && is_complete S1 ty.
(* [?]: removed value specification. *)

Definition lvalue_coercion {a : Type}  (S1 : sigma a) (ty : ctype )  : errorM (ctype ):= 
  if lvalue_convertible S1 ty then
    ErrorM (fun (ts : list (list (string ))) => inr (ty, ts))
  else if is_array ty then
    ErrorM (fun (ts : list (list (string ))) => inr ((array_coercion ty), ts))
  else
    ErrorM (fun ( _ : list (list (string ))) => inl ((
  match ( ty) with ( Ctype annots1 _) => annot.get_loc_ annots1 end), (TError_UndefinedBehaviour undefined.UB020_nonarray_incomplete_lvalue_conversion))).
(* [?]: removed value specification. *)

Definition rvalue_coercion  (ty : ctype )  : ctype := 
  if is_array ty then
    array_coercion ty
  else if is_function ty then
    function_coercion ty
  else
    ty.
(* [?]: removed value specification. *)

Definition is_pointer_to_complete_object {a : Type}  (S1 : sigma a)  : ctype  -> bool :=  
  fun (x : ctype ) =>
    match (x) with | Ctype _( Pointer _ ty) => is_complete S1 ty | _ => false
    end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition is_pointer_to_object  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Pointer _ ref_ty => is_object ref_ty | _ => false end
  end.
(* [?]: removed value specification. *)

Definition is_pointer_to_void  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Pointer _( Ctype _ Void) => true | _ => false end end.
(* [?]: removed value specification. *)

Definition is_pointer_to_function  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Pointer _ ref_ty => is_function ref_ty | _ => false
    end end.
(* [?]: removed value specification. *)

(* [?]: removed value specification. *)

Definition is_standard_signed_integer_type  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Basic( Integer( Signed Ichar)) => true
      | Basic( Integer( Signed Short)) => true
      | Basic( Integer( Signed Int_)) => true
      | Basic( Integer( Signed Long)) => true
      | Basic( Integer( Signed LongLong)) => true | _ => false end end.
(* [?]: removed value specification. *)

Definition is_extended_signed_integer_type  ( _ : ctype )  : bool := 
  false.
(* [?]: removed value specification. *)

Definition is_signed_integer_type  (ty : ctype )  : bool := 
  is_standard_signed_integer_type ty || is_extended_signed_integer_type ty.
(* [?]: removed value specification. *)

Definition is_standard_unsigned_integer_type  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Basic( Integer Bool) => true
      | Basic( Integer( Unsigned Ichar)) => true
      | Basic( Integer( Unsigned Short)) => true
      | Basic( Integer( Unsigned Int_)) => true
      | Basic( Integer( Unsigned Long)) => true
      | Basic( Integer( Unsigned LongLong)) => true | _ => false end end.
(* [?]: removed value specification. *)

Definition is_extended_unsigned_integer_type  ( _ : ctype )  : bool := 
  false.
(* [?]: removed value specification. *)

Definition is_unsigned_integer_type  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Basic( Integer ity) => is_unsigned_ity ity | _ =>
      false end end.
(* [?]: removed value specification. *)

Definition variably_modified  ( _ : ctype )  : bool :=  
  match ( debug.warn []
            (fun (u : unit ) =>
               match ( (u) ) with ( tt) =>
                 "AilTypesAux.variably_modified is BOGUS" end)) with tt =>
    (* TODO *) false end.
(* [?]: removed value specification. *)

Definition has_unknown_size {a : Type}   : a -> bool :=  
  fun (x : a) => match (x) with | _ => false (* TODO !!!!!!! *) end.
(* [?]: removed value specification. *)

Definition is_vla   : ctype  -> bool :=  
  fun (x : ctype ) => match (x) with | _ => false (* TODO !!!!!!! *) end.
(* [?]: removed value specification. *)

Definition is_complete_object {a : Type}  (S1 : sigma a) (ty : ctype )  : bool := 
  is_complete S1 ty && is_object ty.
(* [?]: removed value specification. *)

Definition adjust  (qs : qualifiers ) (c : ctype )  : (qualifiers *ctype ) % type:= 
  match ( (qs,c)) with ( qs, ( Ctype a ty)) =>
    match ( ty) with | Array elem_ty _ => (* STD ÃÂ§6.7.6.3#7 *)
    (* TODO: now that I removed qualifiers from Array, this function doesn't
         doesn't do the right thing. Cabs_to_ail should not use it anymore
         (at least not for Array) *)
    (no_qualifiers, Ctype a (Pointer qs elem_ty))
      | Function hasProto ret_qs_ty params isVariadic =>
      (* STD ÃÂ§6.7.6.3#8 *)
      match ( debug.warn []
                (fun (u : unit ) =>
                   match ( (u) ) with ( tt) =>
                     "(unsure) AilTypesAux.Function, qualifiers" end )) with
          tt =>
        (no_qualifiers, Ctype a
                          (Pointer qs
                             (Ctype []
                                (Function hasProto ret_qs_ty params
                                   isVariadic)))) end | ty =>
      (qs, Ctype a ty) end end.
(* [?]: removed value specification. *)

Definition lvalue_conversion {a : Type}  (S1 : sigma a) (cty : ctype )  : errorM (ctype ):= 
  if is_array cty then
    DAEMON
  
  else if is_incomplete S1 cty && negb (is_array cty) then
    ErrorM (fun ( _ : list (list (string ))) => inl ((
  match ( cty) with ( Ctype annots1 _) => annot.get_loc_ annots1 end), (TError_UndefinedBehaviour undefined.UB020_nonarray_incomplete_lvalue_conversion)))
  
  (* STD Â§6.3.2.1#2, sentence 2 *)
  else match ( cty) with 
    | Ctype _( Atomic cty') =>
        ErrorM (fun (ts : list (list (string ))) => inr (cty', ts))
    | _ =>
        (* NOTE: since the qualifiers of ty are not passed to this function, we
           have already "unqualified" the type *)
        ErrorM (fun (ts : list (list (string ))) => inr (cty, ts))
  end.
(* [?]: removed value specification. *)

Definition compatibleWithQualifiedUnqualifiedVersionOf  (ty : ctype ) (tys : list (ctype ))  : bool := 
  List.existsb (fun (ty' : ctype ) =>
    are_compatible (no_qualifiers, ty) (no_qualifiers, ty')
  ) tys.
(* [?]: removed value specification. *)

Definition referenced_type  (ty : ctype )  : option (ctype ) := 
  (* TODO: check atomic *)
  match ( unatomic_ ty) with 
  | Pointer _ ty' =>
      Some ty'
  | _ =>
      None
end.
(* [?]: removed value specification. *)

Program Fixpoint has_pointer_at_leafs  (c : ctype )  : bool := 
  match ( (c)) with (( Ctype _ ty)) =>
    match ( ty) with | Void => false | Basic _ => false | Array elem_ty _ =>
      has_pointer_at_leafs elem_ty | Function _ _ _ _ => false
      | Pointer _ _ => true | Atomic ty => has_pointer_at_leafs ty
      | Struct _ => false | Union _ => false end end.

