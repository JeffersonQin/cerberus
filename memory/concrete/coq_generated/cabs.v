(* Generated by Lem from ocaml_generated/cabs.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_pervasives.
Require Export lem_pervasives.
Require Import loc.
Require Export loc.


Inductive cabs_identifier : Type := 
  | CabsIdentifier:  unit  ->  string  -> cabs_identifier .
Definition cabs_identifier_default: cabs_identifier  := CabsIdentifier unit_default string_default.

Instance x21_Eq : Eq cabs_identifier := {
   isEqual   ident1  ident2 :=  
  match ( ident1) with ( CabsIdentifier _ str1) =>
    match ( ident2) with ( CabsIdentifier _ str2) => (string_equal str1 str2)
    end end;
   isInequal   ident1  ident2 :=  
  match ( ident1) with ( CabsIdentifier _ str1) =>
    match ( ident2) with ( CabsIdentifier _ str2) =>
      negb ((string_equal str1 str2)) end end
}.


Instance x20_SetType : SetType cabs_identifier := {
   setElemCompare   ident1  ident2 :=  
  match ( ident1) with ( CabsIdentifier _ str1) =>
    match ( ident2) with ( CabsIdentifier _ str2) => EQ end end
}.


Instance x19_Located : Located cabs_identifier := {
   locOf   ident :=  match ( ident) with ( CabsIdentifier loc _) => loc end
}.


Instance x18_Show : Show cabs_identifier := {
   show   ident :=  match ( ident) with CabsIdentifier _ str => str end
}.



(* Â§6.4.4 Constants *)
Inductive cabs_integer_suffix : Type := 
  | CabsSuffix_U: cabs_integer_suffix 
  | CabsSuffix_UL: cabs_integer_suffix 
  | CabsSuffix_ULL: cabs_integer_suffix 
  | CabsSuffix_L: cabs_integer_suffix 
  | CabsSuffix_LL: cabs_integer_suffix .
Definition cabs_integer_suffix_default: cabs_integer_suffix  := CabsSuffix_U.

Definition cabs_integer_constant : Type := (
  string  * option  cabs_integer_suffix  ) % type.
Definition cabs_integer_constant_default: cabs_integer_constant  := (string_default, DAEMON).

Inductive cabs_floating_suffix : Type := 
  | CabsFloatingSuffix_F: cabs_floating_suffix 
  | CabsFloatingSuffix_L: cabs_floating_suffix .
Definition cabs_floating_suffix_default: cabs_floating_suffix  := CabsFloatingSuffix_F.

Definition cabs_floating_constant : Type := (
  string  * option  cabs_floating_suffix  ) % type.
Definition cabs_floating_constant_default: cabs_floating_constant  := (string_default, DAEMON).

Inductive cabs_character_prefix : Type := 
  | CabsPrefix_L: cabs_character_prefix 
  | CabsPrefix_u: cabs_character_prefix 
  | CabsPrefix_U: cabs_character_prefix .
Definition cabs_character_prefix_default: cabs_character_prefix  := CabsPrefix_L.

Definition cabs_character_constant : Type := (
  option  cabs_character_prefix   * string ) % type.
Definition cabs_character_constant_default: cabs_character_constant  := (DAEMON, string_default).

Inductive cabs_constant : Type := 
  | CabsInteger_const:      cabs_integer_constant  -> cabs_constant 
  | CabsFloating_const:     cabs_floating_constant  -> cabs_constant 
  | CabsCharacter_const:    cabs_character_constant  -> cabs_constant .
Definition cabs_constant_default: cabs_constant  := CabsInteger_const cabs_integer_constant_default.


(* Â§6.4.5 String literals *)
Inductive cabs_encoding_prefix : Type := 
  | CabsEncPrefix_u8: cabs_encoding_prefix 
  | CabsEncPrefix_u: cabs_encoding_prefix 
  | CabsEncPrefix_U: cabs_encoding_prefix 
  | CabsEncPrefix_L: cabs_encoding_prefix .
Definition cabs_encoding_prefix_default: cabs_encoding_prefix  := CabsEncPrefix_u8.

Definition cabs_string_literal : Type := ( option  cabs_encoding_prefix   * list  string ) % type.
Definition cabs_string_literal_default: cabs_string_literal  := (DAEMON, DAEMON).


(* Â§6.5 Expressions *)
Inductive cabs_expression_ : Type := 
  (* Â§6.5.1 Primary expressions, Syntax *)
  | CabsEident:  cabs_identifier  -> cabs_expression_ 
  | CabsEconst:  cabs_constant  -> cabs_expression_ 
  | CabsEstring:  cabs_string_literal  -> cabs_expression_ 
  | CabsEgeneric:  cabs_expression  ->  list  cabs_generic_association  -> cabs_expression_ 
  (* Â§6.5.2 Postfix operators, Syntax *)
  | CabsEsubscript:  cabs_expression  ->  cabs_expression  -> cabs_expression_ 
  | CabsEcall:  cabs_expression  ->  list  cabs_expression  -> cabs_expression_ 
  | CabsEmemberof:  cabs_expression  ->  cabs_identifier  -> cabs_expression_ 
  | CabsEmemberofptr:  cabs_expression  ->  cabs_identifier  -> cabs_expression_ 
  | CabsEpostincr:  cabs_expression  -> cabs_expression_ 
  | CabsEpostdecr:  cabs_expression  -> cabs_expression_ 
  | CabsEcompound:  type_name  ->  list  ((option  (list  designator )  * initializer_ ) % type) -> cabs_expression_ 
  (* Â§6.5.3 Unary operators, Syntax *)
  | CabsEpreincr:  cabs_expression  -> cabs_expression_ 
  | CabsEpredecr:  cabs_expression  -> cabs_expression_ 
  | CabsEunary:  cabs_unary_operator  ->  cabs_expression  -> cabs_expression_ 
  | CabsEsizeof_expr:  cabs_expression  -> cabs_expression_ 
  | CabsEsizeof_type:  type_name  -> cabs_expression_ 
  | CabsEalignof:  type_name  -> cabs_expression_ 
  (* Â§6.5.4 Cast operators, Syntax *)
  | CabsEcast:  type_name  ->  cabs_expression  -> cabs_expression_ 
  (* Â§6.5.5-14 Multiplicative/... operators, Syntax *)
  | CabsEbinary:  cabs_binary_operator  ->  cabs_expression  ->  cabs_expression  -> cabs_expression_ 
  (* Â§6.5.15 Conditional operator, Syntax *)
  | CabsEcond:  cabs_expression  ->  cabs_expression  ->  cabs_expression  -> cabs_expression_ 
  (* Â§6.5.16 Assignment operators, Syntax *)
  | CabsEassign:  cabs_assignment_operator  ->  cabs_expression  ->  cabs_expression  -> cabs_expression_ 
  (* Â§6.5.17 Comma operator, Syntax *)
  | CabsEcomma:  cabs_expression  ->  cabs_expression  -> cabs_expression_ 
  (* NOTE: the following are suppose to be in the library, but need
     special treatment *)
  | CabsEassert:  cabs_expression  -> cabs_expression_ 
  | CabsEoffsetof:  type_name  ->  cabs_identifier  -> cabs_expression_ 
  | CabsEva_start:  cabs_expression  ->  cabs_identifier  -> cabs_expression_ 
  | CabsEva_copy:  cabs_expression  ->  cabs_expression  -> cabs_expression_ 
  | CabsEva_arg:  cabs_expression  ->  type_name  -> cabs_expression_ 
  | CabsEva_end:  cabs_expression  -> cabs_expression_ 
  | CabsEprint_type:  cabs_expression  -> cabs_expression_  (* CERBERUS EXTENSION *)
  | CabsEbmc_assume:  cabs_expression  -> cabs_expression_ 
with cabs_expression : Type := 
  | CabsExpression:  unit  ->  cabs_expression_  -> cabs_expression 

(* Â§6.5.1.1 Generic selection, Syntax *)
with cabs_generic_association : Type := 
  | GA_type:  type_name  ->  cabs_expression  -> cabs_generic_association 
  | GA_default:  cabs_expression  -> cabs_generic_association 


(* Â§6.5.3 Unary operators, Syntax *)
with cabs_unary_operator : Type := 
  | CabsAddress: cabs_unary_operator 
  | CabsIndirection: cabs_unary_operator 
  | CabsPlus: cabs_unary_operator 
  | CabsMinus: cabs_unary_operator 
  | CabsBnot: cabs_unary_operator 
  | CabsNot: cabs_unary_operator 

with cabs_binary_operator : Type := 
  (* Â§6.5.5 Multiplicative operators, Syntax *)
  | CabsMul: cabs_binary_operator  | CabsDiv: cabs_binary_operator  | CabsMod: cabs_binary_operator 
  (* Â§6.5.6 Additive operators, Syntax *)
  | CabsAdd: cabs_binary_operator  | CabsSub: cabs_binary_operator 
  (* Â§6.5.7 Shift operators, Syntax *)
  | CabsShl: cabs_binary_operator  | CabsShr: cabs_binary_operator 
  (* Â§6.5.8 Relational operators, Syntax *)
  | CabsLt: cabs_binary_operator  | CabsGt: cabs_binary_operator  | CabsLe: cabs_binary_operator  | CabsGe: cabs_binary_operator 
  (* Â§6.5.9 Equality operators, Syntax *)
  | CabsEq: cabs_binary_operator  | CabsNe: cabs_binary_operator 
  (* Â§6.5.10 Bitwise AND operator, Syntax *)
  | CabsBand: cabs_binary_operator 
  (* Â§6.5.11 Bitwise exclusive OR operator, Syntax *)
  | CabsBxor: cabs_binary_operator 
  (* Â§6.5.12 Bitwise inclusive OR operator, Syntax *)
  | CabsBor: cabs_binary_operator 
  (* Â§6.5.13 Logical AND operator *)
  | CabsAnd: cabs_binary_operator 
  (* Â§6.5.14 Logical OR operator, Syntax *)
  | CabsOr: cabs_binary_operator 

(* Â§6.5.16 Assignment operators, Syntax *)
with cabs_assignment_operator : Type := 
  | Assign: cabs_assignment_operator 
  | Assign_Mul: cabs_assignment_operator 
  | Assign_Div: cabs_assignment_operator 
  | Assign_Mod: cabs_assignment_operator 
  | Assign_Add: cabs_assignment_operator 
  | Assign_Sub: cabs_assignment_operator 
  | Assign_Shl: cabs_assignment_operator 
  | Assign_Shr: cabs_assignment_operator 
  | Assign_Band: cabs_assignment_operator 
  | Assign_Bxor: cabs_assignment_operator 
  | Assign_Bor: cabs_assignment_operator 


(* Â§6.7 Declarations, Syntax *)
with declaration : Type := 
  | Declaration_base:  specifiers  ->  list  init_declarator  -> declaration 
  | Declaration_static_assert:  static_assert_declaration  -> declaration 

with specifiers : Type  (* tyexp_record *)


with init_declarator : Type := 
  | InitDecl:  unit  ->  declarator  ->  option  initializer_   -> init_declarator 


(* Â§6.7.1 Storage-class specifiers, Syntax *)
with storage_class_specifier : Type := 
  | SC_typedef: storage_class_specifier 
  | SC_extern: storage_class_specifier 
  | SC_static: storage_class_specifier 
  | SC_Thread_local: storage_class_specifier 
  | SC_auto: storage_class_specifier 
  | SC_register: storage_class_specifier 


(* Â§6.7.2 Type specifiers, Syntax *)
with cabs_type_specifier_ : Type := 
  | TSpec_void: cabs_type_specifier_ 
  | TSpec_char: cabs_type_specifier_ 
  | TSpec_short: cabs_type_specifier_ 
  | TSpec_int: cabs_type_specifier_ 
  | TSpec_long: cabs_type_specifier_ 
  | TSpec_float: cabs_type_specifier_ 
  | TSpec_double: cabs_type_specifier_ 
  | TSpec_signed: cabs_type_specifier_ 
  | TSpec_unsigned: cabs_type_specifier_ 
  | TSpec_Bool: cabs_type_specifier_ 
  | TSpec_Complex: cabs_type_specifier_ 
  | TSpec_Atomic:  type_name  -> cabs_type_specifier_  (* Â§6.7.2.4 Atomic type specifiers, Syntax *)
  | TSpec_struct:  option  cabs_identifier   ->  option  (list  struct_declaration )  -> cabs_type_specifier_ 
  | TSpec_union:   option  cabs_identifier   ->  option  (list  struct_declaration )  -> cabs_type_specifier_ 
  | TSpec_enum:    option  cabs_identifier   ->  option  (list  ((cabs_identifier  * option 
                                                           cabs_expression  ) % type))  -> cabs_type_specifier_ 
  | TSpec_name:    cabs_identifier  -> cabs_type_specifier_ 
with cabs_type_specifier : Type := 
  | TSpec:  unit  ->  cabs_type_specifier_  -> cabs_type_specifier 

(* Â§6.7.2.1 Structure and union specifiers, Syntax *)
with struct_declaration : Type := 
  | Struct_declaration:  list  cabs_type_specifier  ->  list  cabs_type_qualifier  ->  list  alignment_specifier  ->  list  struct_declarator  -> struct_declaration 
  | Struct_assert:       static_assert_declaration  -> struct_declaration 

with struct_declarator : Type := 
  | SDecl_simple:    declarator  -> struct_declarator 
  | SDecl_bitfield:  option  declarator   ->  cabs_expression  -> struct_declarator 

(* Â§6.7.3 Type qualifiers, Syntax *)
with cabs_type_qualifier : Type := 
  | Q_const: cabs_type_qualifier 
  | Q_restrict: cabs_type_qualifier 
  | Q_volatile: cabs_type_qualifier 
  | Q_Atomic: cabs_type_qualifier 


(* Â§6.7.4 Function specifiers, Syntax *)
with function_specifier : Type := 
  | FS_inline: function_specifier 
  | FS_Noreturn: function_specifier 


(* Â§6.7.5 Alignment specifier, Syntax *)
with alignment_specifier : Type := 
  | AS_type:  type_name  -> alignment_specifier 
  | AS_expr:  cabs_expression  -> alignment_specifier 


(* Â§6.7.6 Declarators, Syntax *)
with declarator : Type := 
  | Declarator:  option  pointer_declarator   ->  direct_declarator  -> declarator 

with direct_declarator : Type := 
  | DDecl_identifier:  cabs_identifier  -> direct_declarator 
  | DDecl_declarator:  declarator  -> direct_declarator 
  | DDecl_array:       direct_declarator  ->  array_declarator  -> direct_declarator 
  | DDecl_function:    direct_declarator  ->  parameter_type_list  -> direct_declarator 
with array_declarator : Type := 
    (* the bool indicate the occurence of the static keyword *)
  | ADecl:  unit  ->  list  cabs_type_qualifier  ->  bool  ->  option  array_declarator_size   -> array_declarator 
with array_declarator_size : Type := 
  | ADeclSize_expression:  cabs_expression  -> array_declarator_size 
  | ADeclSize_asterisk: array_declarator_size 

with pointer_declarator : Type := 
  | PDecl:  unit  ->  list  cabs_type_qualifier  ->  option  pointer_declarator   -> pointer_declarator 

with parameter_type_list : Type := 
  | Params:  list  parameter_declaration  ->  bool  -> parameter_type_list  (* the boolean indicate a
                                                 * variadic function *)

with parameter_declaration : Type := 
  | PDeclaration_decl:      specifiers  ->  declarator  -> parameter_declaration 
  | PDeclaration_abs_decl:  specifiers  ->  option  abstract_declarator   -> parameter_declaration 


(* Â§6.7.7 Type names, Syntax *)
with type_name : Type := 
  | Type_name:  list  cabs_type_specifier  ->  list  cabs_type_qualifier 
               ->  list  alignment_specifier  ->  option  abstract_declarator   -> type_name 

with abstract_declarator : Type := 
  | AbsDecl_pointer:  pointer_declarator  -> abstract_declarator 
  | AbsDecl_direct:   option  pointer_declarator   ->  direct_abstract_declarator  -> abstract_declarator 

with direct_abstract_declarator : Type := 
  | DAbs_abs_declarator:  abstract_declarator  -> direct_abstract_declarator 
  | DAbs_array:           option  direct_abstract_declarator   ->  array_declarator  -> direct_abstract_declarator 
  | DAbs_function:        option  direct_abstract_declarator   ->  parameter_type_list  -> direct_abstract_declarator 


(* Â§6.7.9 Initialization, Syntax *)
with initializer_ : Type := 
  | Init_expr:  cabs_expression  -> initializer_ 
  | Init_list:  list  ((option  (list  designator )  * initializer_ ) % type) -> initializer_ 

with designator : Type := 
  | Desig_array:  cabs_expression  -> designator 
  | Desig_member:  cabs_identifier  -> designator 


(* Â§6.7.10 Static assertions *)
with static_assert_declaration : Type := 
 | Static_assert:  cabs_expression  ->  cabs_string_literal  -> static_assert_declaration .
Definition cabs_expression__default: cabs_expression_  := CabsEident cabs_identifier_default.
Definition cabs_expression_default: cabs_expression  := CabsExpression unit_default cabs_expression__default.
Definition cabs_generic_association_default: cabs_generic_association  := GA_type type_name_default cabs_expression_default.
Definition cabs_unary_operator_default: cabs_unary_operator  := CabsAddress.
Definition cabs_binary_operator_default: cabs_binary_operator  := CabsMul.
Definition cabs_assignment_operator_default: cabs_assignment_operator  := Assign.
Definition declaration_default: declaration  := Declaration_base specifiers_default DAEMON.
Definition specifiers_default: specifiers  := {| storage_classes := DAEMON; type_specifiers := DAEMON; type_qualifiers := DAEMON; function_specifiers := DAEMON; alignment_specifiers := DAEMON |}.
Definition init_declarator_default: init_declarator  := InitDecl unit_default declarator_default DAEMON.
Definition storage_class_specifier_default: storage_class_specifier  := SC_typedef.
Definition cabs_type_specifier__default: cabs_type_specifier_  := TSpec_void.
Definition cabs_type_specifier_default: cabs_type_specifier  := TSpec unit_default cabs_type_specifier__default.
Definition struct_declaration_default: struct_declaration  := Struct_declaration DAEMON DAEMON DAEMON DAEMON.
Definition struct_declarator_default: struct_declarator  := SDecl_simple declarator_default.
Definition cabs_type_qualifier_default: cabs_type_qualifier  := Q_const.
Definition function_specifier_default: function_specifier  := FS_inline.
Definition alignment_specifier_default: alignment_specifier  := AS_type type_name_default.
Definition declarator_default: declarator  := Declarator DAEMON direct_declarator_default.
Definition direct_declarator_default: direct_declarator  := DDecl_identifier cabs_identifier_default.
Definition array_declarator_default: array_declarator  := ADecl unit_default DAEMON bool_default DAEMON.
Definition array_declarator_size_default: array_declarator_size  := ADeclSize_expression cabs_expression_default.
Definition pointer_declarator_default: pointer_declarator  := PDecl unit_default DAEMON DAEMON.
Definition parameter_type_list_default: parameter_type_list  := Params DAEMON bool_default.
Definition parameter_declaration_default: parameter_declaration  := PDeclaration_decl specifiers_default declarator_default.
Definition type_name_default: type_name  := Type_name DAEMON DAEMON DAEMON DAEMON.
Definition abstract_declarator_default: abstract_declarator  := AbsDecl_pointer pointer_declarator_default.
Definition direct_abstract_declarator_default: direct_abstract_declarator  := DAbs_abs_declarator abstract_declarator_default.
Definition initializer__default: initializer_  := Init_expr cabs_expression_default.
Definition designator_default: designator  := Desig_array cabs_expression_default.
Definition static_assert_declaration_default: static_assert_declaration  := Static_assert cabs_expression_default cabs_string_literal_default.

(* Â§6.7.2.2 Enumeration specifiers, Syntax *)
Definition enumerator : Type := ( cabs_identifier  * option  cabs_expression  ) % type.
Definition enumerator_default: enumerator  := (cabs_identifier_default, DAEMON).

(* Â§6.8 Statements and blocks, Syntax *)
Inductive cabs_statement_ : Type := 
  (* Â§6.8.1 Labeled statements, Syntax *)
  | CabsSlabel:  cabs_identifier  ->  cabs_statement  -> cabs_statement_ 
  | CabsScase:  cabs_expression  ->  cabs_statement  -> cabs_statement_ 
  | CabsSdefault:  cabs_statement  -> cabs_statement_ 
  (* Â§6.8.2 Compound statement, Syntax *)
  | CabsSblock:  list  cabs_statement  -> cabs_statement_ 
  (* Â§, Syntax *)
  | CabsSdecl:  declaration  -> cabs_statement_ 
  (* Â§6.8.3 Expression and null statements, Syntax *)
  | CabsSnull: cabs_statement_ 
  | CabsSexpr:  cabs_expression  -> cabs_statement_ 
  (* Â§6.8.4 Selection statements, Syntax *)
  | CabsSif:  cabs_expression  ->  cabs_statement  ->  option  cabs_statement   -> cabs_statement_ 
  | CabsSswitch:  cabs_expression  ->  cabs_statement  -> cabs_statement_ 
  (* Â§6.8.5 Iteration statements, Syntax *)
  | CabsSwhile:  cabs_expression  ->  cabs_statement  -> cabs_statement_ 
  | CabsSdo:  cabs_expression  ->  cabs_statement  -> cabs_statement_ 
  | CabsSfor:  option  for_clause   ->  option  cabs_expression   ->  option  cabs_expression   ->  cabs_statement  -> cabs_statement_ 
  (* Â§6.8.6 Jump statements, Syntax *)
  | CabsSgoto:  cabs_identifier  -> cabs_statement_ 
  | CabsScontinue: cabs_statement_ 
  | CabsSbreak: cabs_statement_ 
  | CabsSreturn:  option  cabs_expression   -> cabs_statement_ 
  (* NON-STD cppmem par construct *)
  | CabsSpar:  list  cabs_statement  -> cabs_statement_ 

with cabs_statement : Type := 
  | CabsStatement:  unit  ->  cabs_statement_  -> cabs_statement 

with for_clause : Type := 
 | FC_expr:  cabs_expression  -> for_clause 
 | FC_decl:  declaration  -> for_clause .
Definition cabs_statement__default: cabs_statement_  := CabsSlabel cabs_identifier_default cabs_statement_default.
Definition cabs_statement_default: cabs_statement  := CabsStatement unit_default cabs_statement__default.
Definition for_clause_default: for_clause  := FC_expr cabs_expression_default.


(* Â§6.9 External definitions, Syntax *)
Inductive translation_unit : Type := 
  | TUnit:  list  external_declaration  -> translation_unit 

with external_declaration : Type := 
  | EDecl_func:  function_definition  -> external_declaration 
  | EDecl_decl:  declaration  -> external_declaration 

(* Â§6.9.1 Function definitions, Syntax *)
with function_definition : Type := 
  | FunDef:  unit  ->  specifiers  ->  declarator  ->  cabs_statement  -> function_definition .
Definition translation_unit_default: translation_unit  := TUnit DAEMON.
Definition external_declaration_default: external_declaration  := EDecl_func function_definition_default.
Definition function_definition_default: function_definition  := FunDef unit_default specifiers_default declarator_default cabs_statement_default.


(* This type's sole purpose it to allow the construction of multiset of base
   type specifiers *)
Inductive cabs_base_type_specifier : Type := 
  | BTSpec_void: cabs_base_type_specifier 
  | BTSpec_char: cabs_base_type_specifier 
  | BTSpec_short: cabs_base_type_specifier 
  | BTSpec_int: cabs_base_type_specifier 
  | BTSpec_long: cabs_base_type_specifier 
  | BTSpec_float: cabs_base_type_specifier 
  | BTSpec_double: cabs_base_type_specifier 
  | BTSpec_signed: cabs_base_type_specifier 
  | BTSpec_unsigned: cabs_base_type_specifier 
  | BTSpec_Bool: cabs_base_type_specifier 
  | BTSpec_Complex: cabs_base_type_specifier .
Definition cabs_base_type_specifier_default: cabs_base_type_specifier  := BTSpec_void.


Instance x17_Located : Located cabs_expression := {
   locOf   expr :=  match ( expr) with ( CabsExpression loc _) => loc end
}.


Instance x16_Located : Located cabs_statement := {
   locOf   stmt :=  match ( stmt) with ( CabsStatement loc _) => loc end
}.


Instance x15_Located : Located cabs_type_specifier := {
   locOf   tspec :=  match ( tspec) with ( TSpec loc _) => loc end
}.


(* NOTE: It returns the location of the identifier *)
Program Fixpoint loc_of_direct_declarator  (ddecl : direct_declarator )  : unit := 
  match ( ddecl) with 
    | DDecl_identifier id => 
  match ( id) with ( CabsIdentifier loc _) => loc end
    | DDecl_declarator( Declarator _ ddecl) =>
        loc_of_direct_declarator ddecl
    | DDecl_array ddecl _ =>
        loc_of_direct_declarator ddecl
    | DDecl_function ddecl _ =>
        loc_of_direct_declarator ddecl
  end.
Instance x14_Located : Located direct_declarator := {
   locOf  :=  loc_of_direct_declarator
}.


(* NOTE: It returns the location of the identifier *)
Instance x13_Located : Located declarator := {
   locOf   decl :=  match ( decl) with ( Declarator _ ddecl) => loc_of_direct_declarator ddecl
 end
}.


(* NOTE: It returns the location of the identifier *)
Instance x12_Located : Located external_declaration := {
   locOf   edecl := 
    match ( edecl) with 
      | EDecl_func( FunDef _ _ decl _) => 
  match ( decl) with ( Declarator _ ddecl) => loc_of_direct_declarator ddecl
  end
      | EDecl_decl( Declaration_base _ idecls) =>
          (* NOTE: Return just the first InitDecl location *)
          match ( idecls) with 
            | [] => tt
            |( InitDecl _ decl _)::_ => 
  match ( decl) with ( Declarator _ ddecl) => loc_of_direct_declarator ddecl
  end
          end
      | EDecl_decl( Declaration_static_assert( Static_assert e _)) => 
  match ( e) with ( CabsExpression loc _) => loc end
    end
}.


Instance x11_SetType : SetType cabs_base_type_specifier := {
   setElemCompare   bspecif1  bspecif2 := 
    let ord := fun x =>
   match (x) with | BTSpec_void => ( 0 : nat ) | BTSpec_char =>  1
     | BTSpec_short =>  2 | BTSpec_int =>  3 | BTSpec_long =>  4
     | BTSpec_float =>  5 | BTSpec_double =>  6 | BTSpec_signed =>  7
     | BTSpec_unsigned =>  8 | BTSpec_Bool =>  9 | BTSpec_Complex => 
    10 end in
    (genericCompare nat_ltb beq_nat (ord bspecif1) (ord bspecif2))
}.


