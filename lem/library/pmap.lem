(* TODO: This is not the right type *)
type ('a,'b) map = ('a,'b) Hol.Finite_map.fmap

val empty : forall 'a 'b. ('a,'b) map
let inline {hol} empty = Hol.FEMPTY
let inline {ocaml} empty = (Ocaml.Pmap.empty Ocaml.Pervasives.compare)

val add : forall 'key 'a. 'key -> 'a -> ('key,'a) map -> ('key,'a) map
let inline {hol} add k a m = Hol.FUPDATE m (k,a)
let inline {ocaml} add = Ocaml.Pmap.add

val mem : forall 'key 'a. 'key -> ('key,'a) map -> bool
let inline {hol} mem k m = k IN Hol.FDOM m
let inline {ocaml} mem = Ocaml.Pmap.mem

val find : forall 'key 'a. 'key -> ('key,'a) map -> 'a
let inline {hol} find k m = Hol.FAPPLY m k
let inline {ocaml} find = Ocaml.Pmap.find

val fold : forall 'key 'a 'b. ('key -> 'a -> 'b -> 'b) -> ('key, 'a) map -> 'b -> 'b
let inline {ocaml} fold = Ocaml.Pmap.fold

val for_all : forall 'key 'a. ('key -> 'a -> bool) -> ('key, 'a) map -> bool
let inline {ocaml} for_all = Ocaml.Pmap.for_all

val map : forall 'key 'a 'b. ('a -> 'b) -> ('key, 'a) map -> ('key, 'b) map
let inline {ocaml} map = Ocaml.Pmap.map

val bindings: forall 'key 'a.  ('key,'a) map -> ('key * 'a) list
let inline {ocaml} bindings = Ocaml.Pmap.bindings

val concat: forall 'key 'a. ('key, 'a) map -> ('key, 'a) map -> ('key, 'a) map
let inline {ocaml} concat = Ocaml.Pmap.concat

val remove: forall 'key 'a. 'key -> ('key, 'a) map -> ('key, 'a) map
let inline {ocaml} remove = Ocaml.Pmap.remove

