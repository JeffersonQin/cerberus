(* TODO: make the following work *)
(*sub [hol] for_all f xs = forall (x IN xs). f x*)
val for_all : forall 'a. ('a -> bool) -> 'a set -> bool
sub [ocaml] for_all = Pset.for_all
sub [hol] for_all f xs = EVERY f (SET_TO_LIST xs)
sub [isabelle] for_all P S = Set.Ball S P

val exists : forall 'a. ('a -> bool) -> 'a set -> bool
sub [ocaml] exists = Pset.exists
sub [hol] exists f xs = EXISTS f (SET_TO_LIST xs)
sub [isabelle] exists P S = Set.Bex S P 

val cardinal : forall 'a. 'a set -> num
sub [ocaml] cardinal = Pset.cardinal
sub [hol] cardinal = CARD

val from_list : forall 'a. 'a list -> 'a set
sub [ocaml] from_list = Pset.from_list Pervasives.compare
sub [hol] from_list = LIST_TO_SET
sub [isabelle] from_list = List.set

val to_list : forall 'a. 'a set -> 'a list
sub [ocaml] to_list = Pset.elements
sub [hol] to_list = SET_TO_LIST

val is_empty : forall 'a. 'a set -> bool
sub [ocaml] is_empty = Pset.is_empty
sub [hol] is_empty xs = xs = EMPTY
sub [isabelle] is_empty xs = (xs = Set.empty)

val choose : forall 'a. 'a set -> 'a
sub [ocaml] choose = Pset.choose
sub [hol] choose = CHOICE

val fold : forall 'a 'b. ('a -> 'b -> 'b) -> 'a set -> 'b -> 'b
sub [ocaml] fold = Pset.fold
sub [hol] fold = ITSET
sub [isabelle] fold = Finite_Set.fold

val add : forall 'a. 'a -> 'a set -> 'a set
sub [hol] add = INSERT
sub [ocaml] add = Pset.add
sub [isabelle] add = Set.insert

val equal : forall 'a. 'a set -> 'a set -> bool
sub [ocaml] equal = Pset.equal 
sub [hol] equal xs ys = xs = ys

val partition : forall 'a. ('a -> bool) -> 'a set -> 'a set * 'a set
sub [ocaml] partition = Pset.partition

val product : forall 'a 'b. 'a set -> 'b set -> ('a * 'b) set
sub [hol] product = CROSS

val diff : forall 'a. 'a set -> 'a set -> 'a set
sub [ocaml] diff = Pset.diff

val map : forall 'a 'b. ('a -> 'b) -> 'a set -> 'b set
sub [ocaml] map = Pset.map Pervasives.compare
