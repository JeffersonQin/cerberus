type 'a reln = ('a * 'a) set

val acyclic : forall 'a. 'a reln -> bool
val all_choices : forall 'a. 'a set set -> 'a set set
val antisym : forall 'a. 'a reln -> bool
val chain : forall 'a. 'a set -> 'a reln -> bool
val domain : forall 'a. 'a reln -> 'a set
val finite_prefixes : forall 'a. 'a reln -> 'a set -> bool
val irreflexive : forall 'a. 'a reln -> 'a set -> bool
val linear_order : forall 'a. 'a reln -> 'a set -> bool
val maximal_elements : forall 'a. 'a set -> 'a reln -> 'a set
val minimal_elements : forall 'a. 'a set -> 'a reln -> 'a set
val num_order : forall 'a. ('a -> num) -> 'a set -> 'a reln
val partial_order : forall 'a. 'a reln -> 'a set -> bool
val per : forall 'a. 'a set -> 'a set set -> bool
val per_restrict : forall 'a. 'a set set -> 'a set -> 'a set
val range : forall 'a. 'a reln -> 'a set
val rcomp : forall 'a. 'a reln -> 'a reln -> 'a reln
val reflexive : forall 'a. 'a reln -> 'a set -> bool
val rrestrict : forall 'a. 'a reln -> 'a set -> 'a reln
val strict : forall 'a. 'a reln -> 'a reln
val strict_linear_order : forall 'a. 'a reln -> 'a set -> bool
val tc : forall 'a. 'a reln -> 'a reln
val transitive : forall 'a. 'a reln -> 'a reln
val univ_reln : forall 'a. 'a set -> 'a reln
val upper_bounds : forall 'a. 'a set -> 'a reln -> 'a set
