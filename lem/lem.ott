indexvar n , i , j , k ::=
  {{ phantom }}
  {{ com Index variables for meta-lists }}

metavar num ::=
  {{ phantom }}
  {{ lex numeric }}
  {{ ocaml terminal * int }}
  {{ hol num }}
  {{ com Numeric literals }}

metavar string ::=
  {{ phantom }}
  {{ ocaml terminal * string }}
  {{ hol string }}
  {{ com String literals }}

embed
{{ ocaml

type text = BatRope.t

type l =
  | Unknown
  | Trans of string
  | Range of Lexing.position * Lexing.position

exception Parse_error_locn of l * string

type ml_comment = 
  | Chars of BatRope.t
  | Comment of ml_comment list

type lex_skip =
  | Com of ml_comment
  | Ws of BatRope.t
  | Nl

type lex_skips = lex_skip list option

let combine_lex_skips s1 s2 =
  match (s1,s2) with
    | (None,_) -> s2
    | (_,None) -> s1
    | (Some(s1),Some(s2)) -> Some(s2@s1)

type terminal = lex_skips

}}


metavar x , y , z ::=
  {{ ocaml terminal * text }}
  {{ hol string }}
  {{ com Variables }}
  {{ ocamlvar "[[x]]" }}

metavar ix ::=
  {{ lex alphanum }}
  {{ ocaml terminal * text }}
  {{ hol string }}
  {{ com Variables }}
  {{ ocamlvar "[[x]]" }}



grammar

l :: '' ::=					{{ phantom }}
						{{ ocaml l }}
						{{ hol unit }}
  {{ com Source locations }}
  | 						:: :: Unknown
    {{ ocaml Unknown }}
    {{ hol () }}

x_l {{ tex \ottnt{x}^{l} }} , y_l {{ tex \ottnt{y}^{l} }} , z_l {{ tex \ottnt{z}^{l} }} :: '' ::=
  {{ com Location-annotated names }}
  | x l						:: :: X_l
  | ( ix ) l					:: :: PreX_l
    {{ com Remove infix status }}

ix_l {{ tex \ottnt{ix}^{l} }} :: '' ::=
  {{ com Location-annotated infix names }}
  | ix l					:: :: SymX_l
  | ` x ` l					:: :: InX_l
    {{ com Add infix status }}

embed
{{ ocaml
let xl_to_l = function
  | X_l(_,l) -> l
  | PreX_l(_,_,_,l) -> l

let ixl_to_l = function
  | SymX_l(_,l) -> l
  | InX_l(_,_,_,l) -> l
}}

grammar

a {{ tex \alpha }} :: '' ::=
						{{ ocaml terminal * text }}
						{{ hol string }}
  {{ com Type variables }}
  | ' x 					:: :: A
    {{ hol [[x]] }}
    {{ ocaml [[x]] }}

a_l {{ tex \alpha^{l} }} :: '' ::=
  {{ com Location-annotated type variables }}
  | a l						:: :: A_l

id :: '' ::=
  {{ com Long identifers }}
  | x_l1 . .. x_ln . x_l l				:: :: Id

tyvars :: '' ::=				{{ phantom }}
						{{ hol a_l list }}
						{{ ocaml terminal * (a_l * terminal) list * terminal }}
  {{ com Type variable lists }}
  | ( a_l1 , .. , a_ln )			:: :: Tvs_l
    {{ com Must have $>1$ type variables }}
    {{ hol [[a_l1..a_ln]] }}
    {{ ocaml [[a_l1..a_ln]] }}
  | a_l						:: S :: Tvs_single
    {{ hol [ [[a_l]] ] }}
    {{ ocaml [ [[a_l]] ] }}
  |						:: S :: Tvs_none
    {{ hol [] }}
    {{ ocaml [] }}

typ_aux :: 'Typ_' ::=
  {{ com Types }}
  | _						:: :: wild
    {{ com Unspecified type }}
  | a_l						:: :: var
    {{ com Type variables }}
  | typ1 -> typ2				:: :: fn
    {{ com Function types }}
  | typ1 * .... * typn				:: :: tup
    {{ com Tuple types }}
  | ( typ1 , .. , typn ) id			:: :: app
    {{ com Type applications, must have $>1$ type arguments }}
  | typ id					:: S :: app1
    {{ hol (Typ_app [ [[typ]] ] [[id]]) }}
    {{ ocaml (Typ_app([ [[typ]] ], [[id]])) }}
    {{ com Type applications (single argument) }}
  | id				        	:: S :: app0
    {{ hol (Typ_app [] [[id]]) }}
    {{ ocaml (Typ_app([], [[id]])) }}
    {{ com Type applications (no argument) }}
  | ( typ )					:: :: paren

typ :: '' ::=
  {{ com Location-annotated types }}
  | typ_aux l					:: :: Typ_l

parsing

Typ_tup <= Typ_tup
Typ_fn right Typ_fn
Typ_fn <= Typ_tup
Typ_fn right Typ_app1
Typ_tup right Typ_app1

grammar

lit_aux :: 'L_' ::=
  {{ com Literal constants }}
  | true						:: :: true
  | false						:: :: false
  | num							:: :: num
  | string						:: :: string
  | ( )							:: :: unit

lit :: '' ::=
  | lit_aux l						:: :: Lit_l
    {{ com Location-annotated literal constants }}

semi_opt {{ tex \ottnt{;}^{?} }} :: 'semi_' ::=		{{ phantom }}
							{{ ocaml terminal * bool }}
							{{ hol bool }}
  {{ com Optional semi-colons }}
  |  							:: :: no
    {{ hol F }}
    {{ ocaml false }}
  | ';'							:: :: yes
    {{ hol T }}
    {{ ocaml true }}


pat_aux :: 'P_' ::= 
  {{ com Patterns }}
  | _							:: :: wild  
    {{ com Wildcards }}
  | pat as x_l						:: :: as
    {{ com Named patterns }}
  | ( pat : typ )					:: :: typ
    {{ com Typed patterns }}
  | id pat1 .. patn					:: :: app
    {{ com Single variable and constructor patterns }}
  | <| fpat1 ; ... ; fpatn semi_opt |>			:: :: record
    {{ com Record patterns }}
  | ( pat1 , .... , patn )				:: :: tup
    {{ com Tuple patterns }}
  | [ pat1 ; .. ; patn semi_opt ]			:: :: list
    {{ com List patterns }}
  | ( pat )						:: :: paren
  | pat1 '::' pat2					:: :: cons
    {{ com Cons patterns }}
  | lit							:: :: lit
    {{ com Literal constant patterns }}

pat :: '' ::=
  {{ com Location-annotated patterns }}
  | pat_aux l						::  :: Pat_l

fpat :: '' ::=
  {{ com Field patterns }}
  | id = pat l						:: :: Fpat

parsing
P_app <= P_app
P_app <= P_as

grammar

bar_opt {{ tex \ottkw{|}^{?} }} :: 'bar_' ::=		{{ phantom }}
							{{ ocaml terminal * bool }}
							{{ hol bool }}
  {{ com Optional bars }}
  |  							:: :: no
    {{ hol F }}
    {{ ocaml false }}
  | '|'							:: :: yes
    {{ hol T }}
    {{ ocaml true }}

exp_aux :: '' ::=
  {{ com Expressions }}
  | id							:: :: Ident
    {{ com Identifiers }}
  | fun psexp						:: :: Fun 
    {{ com Curried functions }}
  | function bar_opt pexp1 '|' ... '|' pexpn end	:: :: Function
    {{ com Functions with pattern matching }}
  | exp1 exp2						:: :: App
    {{ com Function applications }}
  | exp1 ix_l exp2					:: :: Infix
    {{ com Infix applications }}
  | <| fexps |>						:: :: Record
    {{ com Records }}
  | <| exp with fexps |>				:: :: Recup
    {{ com Functional update for records }}
  | exp . id						:: :: Field
    {{ com Field projection for records }}
  | match exp with bar_opt pexp1 '|' ... '|' pexpn l end :: :: Case
    {{ com Pattern matching expressions }}
  | ( exp : typ )					:: :: Typed
    {{ com Type-annotated expressions }}
  | let letbind in exp					:: :: Let
    {{ com Let expressions }}
  | ( exp1 , .... , expn )				:: :: Tup
    {{ com Tuples }}
  | [ exp1 ; .. ; expn semi_opt ]			:: :: List
    {{ com Lists }}
  | ( exp )						:: :: Paren
  | begin exp end					:: :: Begin
    {{ com Alternate syntax for $\ottnt(exp)$ }}
  | if exp1 then exp2 else exp3				:: :: If
    {{ com Conditionals }}
  | exp1 '::' exp2					:: :: Cons
    {{ com Cons expressions }}
  | lit							:: :: Lit
    {{ com Literal constants }}
  | { exp1 | exp2 }					:: :: Setcomp
    {{ com Set comprehensions }}
  | { exp1 | forall qbind1 .. qbindn | exp2 }		:: :: Setcomp_binding
    {{ com Set comprehensions with explicit binding }}
  | { exp1 ; .. ; expn semi_opt }			:: :: Set
    {{ com Sets }}
  | q qbind1 ... qbindn . exp				:: :: Quant
    {{ com Logical quantifications }}
  | [ exp1 | forall qbind1 .. qbindn | exp2 ]		:: :: Listcomp
    {{ com List comprehensions (all binders must be quantified) }}

exp  :: '' ::=
  {{ com Location-annotated expressions }}
  | exp_aux l						:: :: Expr_l

q :: 'Q_' ::=
  {{ com Quantifiers }}
  | forall					:: :: forall
  | exist					:: :: exists

qbind :: 'Qb_' ::=
  {{ com Bindings for quantifiers}}
  | x_l							:: :: var		
  | ( pat 'IN' exp )					:: :: restr
    {{ com Restricted quantifications over sets}}
  | ( pat MEM exp )					:: :: list_restr
    {{ com Restricted quantifications over lists }}

fexp :: '' ::=
  {{ com Field-expressions }}
  | id = exp l						:: :: Fexp

fexps :: '' ::=
  {{ com Field-expression lists }}
  | fexp1 ; ... ; fexpn semi_opt l			:: :: Fexps

pexp :: '' ::=
  {{ com Pattern matches }}
  | pat -> exp l					:: :: Patexp

psexp :: '' ::=
  {{ com Multi-pattern matches }}
  | pat1 ... patn -> exp l				:: :: Patsexp

tannot_opt {{ tex \ottnt{tannot}^? }} :: 'Typ_annot_' ::=
  {{ com Optional type annotations }}
  | 							:: :: none
  | : typ						:: :: some 

funcl_aux :: '' ::=
  {{ com Function clauses }}
  | x_l pat1 ... patn tannot_opt = exp			:: :: Funcl

letbind_aux :: '' ::=
  {{ com Let bindings }}
  | pat tannot_opt = exp 				:: :: Let_val
    {{ com Value bindings }}
  | funcl_aux						:: :: Let_fun
    {{ com Function bindings }}

letbind :: '' ::=
  {{ com Location-annotated let bindings }}
  | letbind_aux l					:: :: Letbind

funcl :: '' ::=
  {{ com Location-annotated function clauses }}
  | funcl_aux l						:: :: Rec_l

rule_aux :: '' ::=
  {{ com Inductively defined relation clauses }}
  | forall x_l1 .. x_ln . exp ==> x_l exp1 .. expi	:: :: Rule

rule :: '' ::=
  {{ com Location-annotated inductively defined relation clauses }}
  | rule_aux l						:: :: Rule_l

parsing

P_app right Let_val

P_app <= Fun

Fun right App
Function right App
Case right App
Let right App

Fun <= Field
Function <= Field
App <= Field
Case <= Field
Let <= Field

App left App

grammar

typs :: '' ::=						{{ phantom }}
							{{ ocaml (typ * terminal) list }}
							{{ hol typ list }}
  {{ com Type lists }}
  | typ1 * ... * typn					:: :: Typs
    {{ hol [[typ1...typn]] }}
    {{ ocaml [[typ1...typn]] }}

parsing
Typ_tup <= Typs

grammar

ctor_def :: '' ::=
  {{ com Datatype definition clauses }}
  | x_l of typs						:: :: Cte
  | x_l							:: S :: Cte_s
    {{ com Constant constructors }}
    {{ ocaml (Cte([[x_l]],[])) }}
    {{ hol (Cte [[x_l]] []) }}

texp :: 'Te_' ::=
  {{ com Type definition bodies }}
  | typ							:: :: abbrev
    {{ com Type abbreviations }}
  | <| x_l1 : typ1 ; ... ; x_ln : typn semi_opt |>	:: :: record
    {{ com Record types }}
  | bar_opt ctor_def1 '|' ... '|' ctor_defn		:: :: variant
    {{ com Variant types }}

td :: '' ::=
  {{ com Type definitions }}
  | tyvars x_l = texp			 			:: :: Td
  | tyvars x_l							:: :: Td_opaque
    {{ com Definitions of opaque types }}

c :: '' ::=
  {{ com Typeclass constraints }}
  | ( id a_l )							:: :: C

cs :: 'Cs_' ::=
  {{ com Typeclass constraint lists }}
  | 								:: :: empty
  | c1 .. ci =>							:: :: list
    {{ com Must have $>0$ constraints }}


c_pre :: 'C_pre_' ::=
  {{ com Type and instance scheme prefixes }}
  |								:: :: empty
  | forall a_l1 .. a_ln . cs					:: :: forall
    {{ com Must have $>0$ type variables }}

typschm :: '' ::=
    {{ com Type schemes }}
  | c_pre typ							:: :: Ts

instschm :: '' ::=
    {{ com Instance schemes }}
  | c_pre ( id typ )						:: :: Is

target :: 'Target_' ::=
  {{ com Backend target names }}
  | hol								:: :: hol
  | isabelle							:: :: isa
  | ocaml							:: :: ocaml
  | coq								:: :: coq
  | tex								:: :: tex

targets :: 'Targets_' ::=
  {{ com Backend target name lists }}
  | { target1 ; ... ; targetn }					:: :: concrete

targets_opt {{ tex \ensuremath{\ottnt{targets}^?} }} :: 'Targ_' ::= {{ phantom }}
								{{ hol targets option }}
								{{ ocaml targets option }}
   {{ com Optional targets }}
  |								:: :: none
    {{ ocaml None }}
    {{ hol NONE }}
  | targets							:: :: some
    {{ ocaml (Some([[targets]])) }}
    {{ hol (SOME([[targets]])) }}

val_def :: '' ::= 
  {{ com Value definitions }}
  | let targets_opt letbind					:: :: Let_def
    {{ com Non-recursive value definitions }}
  | let rec targets_opt funcl1 and ... and funcln		:: :: Let_rec
    {{ com Recursive function definitions }}

val_spec :: '' ::=
  {{ com Value type specifications }} 
  | val x_l : typschm						:: :: Val_spec

def_aux :: '' ::=
  {{ com Top-level definitions }}
  | type td1 and ... and tdn					:: :: Type_def
    {{ com Type definitions }}
  | val_def							:: :: Val_def
    {{ com Value definitions }}
  | module x_l = struct defs end				:: :: Module
    {{ com Module definitions }}
  | module x_l = id						:: :: Rename
    {{ com Module renamings }}
  | open id							:: :: Open
    {{ com Opening modules }}
%  | include id							:: :: Include
%    {{ com Including modules }}
  | indreln targets_opt rule1 and ... and rulen			:: :: Indreln
    {{ com Inductively defined relations }}
  | val_spec 							:: :: Spec_def
    {{ com Top-level type constraints }}
  | sub [ target ] x_l x_l1 .. x_li = exp			:: :: Subst
    {{ com Target-specific functions to inline }}
  | class ( x_l a_l ) val x_l1 : typ1 l1 ... val x_ln : typn ln end	:: :: Class
    {{ com Typeclass definitions }}
  | instance instschm val_def1 l1 ... val_defn ln end 		:: :: Instance
    {{ com Typeclass instantiations }}

def :: '' ::=
  {{ com Location-annotated definitions }}
  | def_aux l							:: :: Def_l

semisemi_opt {{ tex \ottkw{;;}^? }} :: 'semisemi_' ::=		{{ phantom }}
								{{ ocaml terminal * bool }}
								{{ hol bool }}
  {{ com Optional double-semi-colon }}
  | 	 							:: :: no
    {{ hol F }}
    {{ ocaml false }}
  | ;;								:: :: yes
    {{ hol T }}
    {{ ocaml true }}

defs :: '' ::=
  {{ com Definition sequences }}
  | def1 semisemi_opt1 .. defn semisemi_optn			:: :: Defs


grammar


p :: 'Path_' ::=
  {{ com Unique paths }}
  | x1 . .. xn . x				:: :: def
  | __list					:: :: list	
    {{ tex \ottkw{\_\_list}  }}
  | __bool					:: :: bool
    {{ tex \ottkw{\_\_bool}  }}
  | __num					:: :: num
    {{ tex \ottkw{\_\_num}  }}
  | __set					:: :: set
    {{ tex \ottkw{\_\_set}  }}
  | __string					:: :: string
    {{ tex \ottkw{\_\_string}  }}
  | __unit					:: :: unit
    {{ tex \ottkw{\_\_unit}  }}

t_subst {{ tex \ensuremath{\sigma} }} :: '' ::=	{{ phantom }}
						{{ hol (a # t) list }}
  {{ com Type variable substitutions }}
  | { a1 |-> t1 .. an |-> tn }			:: :: T_subst
    {{ ocaml (assert false) }}
    {{ hol ([[a1 t1 .. an tn]]) }}

t , u :: 'T_' ::=
  {{ com Internal types }}
  | a						:: :: var
  | t1 -> t2					:: :: fn
  | t1 * .... * tn				:: :: tup
  | t_args p					:: :: app 
  | t_subst ( t	)				:: M :: subst_app
    {{ com Multiple substitutions }}
    {{ ocaml (assert false) }}
    {{ hol (t_subst_t [[t_subst]] [[t]]) }}
  | curry ( t_multi ,  t )			:: M :: multifn
    {{ com Curried, multiple argument functions }}
    {{ ocaml (assert false) }}
    {{ hol (FOLDR T_fn [[t]] [[t_multi]]) }}

t_args :: '' ::=
  {{ com Lists of types }}
  | ( t1 , .. , tn )				:: :: T_args
  | t_subst ( t_args )				:: M :: T_args_subst_app
    {{ com Multiple substitutions }}
    {{ ocaml (assert false) }}
    {{ hol (t_subst_t_args [[t_subst]] [[t_args]]) }}

t_multi :: '' ::=				{{ phantom }}
						{{ hol t list }}
						{{ ocaml t list }}
  {{ com Lists of types }}
  | ( t1 * .. * tn )				:: :: T_multi
    {{ hol [[t1..tn]] }}
  | t_subst ( t_multi )				:: M :: T_multi_subst_app
    {{ com Multiple substitutions }}
    {{ ocaml (assert false) }}
    {{ hol (MAP (t_subst_t [[t_subst]]) [[t_multi]]) }}

parsing
T_fn right T_fn
T_tup <= T_multi

grammar

tvs :: '' ::=					{{ hol a list }}
						{{ ocaml a list }}
  {{ com Type variable lists }}
  | a1 .. an					:: :: Tvs
    {{ hol [[a1..an]] }}
    {{ ocaml [[a1..an]] }}

names :: '' ::=					{{ phantom }}
						{{ hol v set }}
						{{ ocaml Set.Make(String).t }}
  {{ com Sets of names }}
  | { x1 , .. , xn }				:: :: Names
    {{ hol (LIST_TO_SET [[x1..xn]]) }}

semC {{ tex \ensuremath{\mathcal{C} } }} :: '' ::=
								{{ hol (p#a) list }}
  {{ com Typeclass constraint lists }}
  | ( p1 a1 ) .. ( pn an )					:: :: SemC_concrete
    {{ hol ([[p1 a1..pn an]]) }}

v_desc :: 'V_' ::=
  {{ com Value descriptions }}
  | < forall tvs . t_multi -> p , ( x of names ) >		:: :: constr
    {{ com Constructors }}
  | < forall tvs . p -> t , ( x of names ) >			:: :: field
    {{ com Fields }}
  | forall tvs . semC => t					:: :: val
    {{ com Values }}

kind :: 'K_' ::=
  {{ com Sorts of value bindings }}
  | ctor							:: :: ctor
  | field							:: :: field
  | mthd							:: :: method
  | let								:: :: let
  | spec							:: :: spec
  | target							:: :: target

kinds {{ tex \ensuremath{\kappa} }}:: 'Ks_' ::=			{{ hol kind set }}
  | { kind1 ; .. ; kindn }					:: :: concrete
    {{ hol (LIST_TO_SET [[kind1..kindn]]) }}
  | kinds1 union kinds2							:: M :: union
    {{ hol ([[kinds1]] UNION [[kinds2]]) }}
    {{ ocaml assert false }}

embed
{{ hol
load "fmaptreeTheory";
val _ = 
  Hol_datatype 
    `env_body = <| env_p : v|->p; env_v : v|->kinds#v_desc |>`;

val _ = Define `
  env_union e1 e2 =
    let i1 = item e1 in
    let m1 = map e1 in
    let i2 = item e2 in
    let m2 = map e2 in
      FTNode <| env_p:=FUNION i1.env_p i2.env_p; 
                env_v:=FUNION i1.env_v i2.env_v |>
             (FUNION m1 m2)`;
}}

grammar


S {{ tex \ensuremath{\Sigma} }} :: '' ::=			{{ phantom }}
								{{ hol (p#t) list }}
  {{ com Typeclass constraints }}
  | { ( p1 t1 ) , .. , ( pn tn ) }				:: :: S_concrete
    {{ hol [[p1 t1 .. pn tn]] }}
  | S1 union .. union Sn					:: M :: S_union
    {{ hol (FLAT [[S1..Sn]]) }}
    {{ ocaml assert false }}

E :: '' ::=							{{ phantom }}
								{{ hol ((string,env_body) fmaptree) }}
  {{ com Environments }}
  | < E_m , E_p , E_x >						:: :: E
    {{ hol (FTNode <|env_p:=[[E_p]]; env_v:=[[E_x]]|> ([[E_m]])) }}
  | E1 u+ E2							:: M :: E_union
    {{ hol (env_union [[E1]] [[E2]]) }}
    {{ ocaml assert false }}
  | empty							:: M :: E_empty
    {{ hol (FTNode <|env_p:=FEMPTY; env_v:=FEMPTY|> FEMPTY) }}
    {{ ocaml assert false }}

E_x {{ tex \ottnt{E}^{\textsc{x} } }} :: 'E_x_' ::=		{{ phantom }}
								{{ hol (x |-> kinds#v_desc) }}
  {{ com Value environments }}
  | { x1 |-> kinds1 v_desc1 , .. , xn |-> kindsn v_descn }	:: :: concrete
    {{ hol (FOLDR (\(k1,k2,x) E. E |+ (k1,(k2,x))) FEMPTY [[x1 kinds1 v_desc1 .. xn kindsn v_descn]]) }}
  | E_x1 u+ .. u+ E_xn						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_x1..E_xn]]) }}
    {{ ocaml (assert false) }}

E_m {{ tex \ottnt{E}^{\textsc{m} } }} :: 'E_m_' ::=		{{ phantom }}
								{{ hol (string |-> (string,env_body) fmaptree) }}
  {{ com Module environments }}
  | { x1 |-> E1 , .. , xn |-> En }				:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 E1 .. xn En]]) }}

E_p {{ tex \ottnt{E}^{\textsc{p} } }} :: 'E_p_' ::=		{{ phantom }}
								{{ hol (x |-> p) }}
  {{ com Path environments }}
  | { x1 |-> p1 , .. , xn |-> pn }				:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 p1 .. xn pn]]) }}
  | E_p1 u+ .. u+ E_pn						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_p1..E_pn]]) }}
    {{ ocaml (assert false) }}

E_l {{ tex \ottnt{E}^{\textsc{l} } }} :: 'E_l_' ::=		{{ phantom }}
								{{ hol (x |-> t) }}
  {{ com Lexical bindings }}
  | { x1 |-> t1 , .. , xn |-> tn }				:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 t1 .. xn tn]]) }}
  | E_l1 u+ .. u+ E_ln						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_l1..E_ln]]) }}
    {{ ocaml (assert false) }}

tc_abbrev :: 'Tc_abbrev_' ::=					{{ phantom }}
								{{ hol t option }}
								{{ ocaml t option }}
  {{ com Type abbreviations }}
  | . t								:: :: some
    {{ hol (SOME [[t]]) }}
  | 								:: :: none
    {{ hol NONE }}

tc_def :: '' ::=
  {{ com Type and class constructor definitions }} 
  | tvs tc_abbrev						:: :: Tc_def
    {{ com Type constructors }}

TD {{ tex \ensuremath{\Delta} }} :: 'TD_' ::=			{{ phantom }}
								{{ hol p |-> tc_def }}
  {{ com Type constructor definitions }}
  | { p1 |-> tc_def1 , .. , pn |-> tc_defn }			:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[p1 tc_def1 .. pn tc_defn]]) }}
    {{ ocaml (assert false) }}
  | TD1 u+ TD2							:: M :: union
    {{ hol (FUNION [[TD1]] [[TD2]]) }}
    {{ ocaml (assert false) }}

TC {{ tex \ensuremath{\delta} }} :: '' ::=			{{ phantom }}
								{{ hol p |-> x list }}
  {{ com Typeclass  definitions }}
  | { p1 |-> xs1 , .. , pn |-> xsn }				:: :: TC_concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[p1 xs1 .. pn xsn]]) }}
    {{ ocaml (assert false) }}
  | TC1 u+ TC2							:: M :: TC_union
    {{ hol (FUNION [[TC1]] [[TC2]]) }}
    {{ ocaml (assert false) }}


inst :: '' ::=
  {{ com A typeclass instance, t must not contain nested types }}
  | semC => ( p t )						:: :: Inst

I :: '' ::=							{{ phantom }}
								{{ hol inst list }}
  {{ com Global instances }}
  | { inst1 , .. , instn }					:: :: I_concrete
    {{ hol [[inst1 .. instn]] }}
  | I1 union I2							:: M :: I_union
    {{ hol ([[I1]] ++ [[I2]]) }}
    {{ ocaml assert false }}
 

D :: 'D_' ::=							{{ phantom }}
								{{ hol ((p |-> tc_def) # (p |-> v list) # (inst list)) }}
  {{ com Global type definition store }}
  | < TD , TC , I >							:: :: concrete
    {{ hol ([[TD]], [[TC]], [[I]]) }}
  | D1 u+ D2							:: M :: union
    {{ hol (case ([[D1]],[[D2]]) of ((x1,x2,x3),(y1,y2,y3)) -> (FUNION x1 y1, FUNION x2 y2, x3 ++ y3)) }}
    {{ ocaml (assert false) }}
  | empty							:: M :: empty
    {{ hol (FEMPTY, FEMPTY, []) }}
    {{ ocaml assert false }}

parsing
E_union left E_union


grammar

xs :: '' ::=					{{ phantom }}
						{{ hol string list }}
  | x1 .. xn					:: :: Xs
    {{ hol [[x1..xn]] }}


terminals :: '' ::=
  | ->					:: :: arrow
    {{ tex \ensuremath{\rightarrow} }}
    {{ com \texttt{->} }}
  | ==> 				:: :: Longrightarrow
    {{ tex \ensuremath{\Longrightarrow} }}
    {{ com \texttt{==>} }}
  | <|					:: :: startrec
    {{ tex \ensuremath{\langle|} }}
    {{ com \texttt{<|} }}
  | |>					:: :: endrec
    {{ tex \ensuremath{|\rangle} }}
    {{ com \texttt{|>} }}
  | inter				:: :: inter
    {{ tex \ensuremath{\cap} }}
  | union				:: :: union
    {{ tex \ensuremath{\cup} }}
  | u+					:: :: uplus
    {{ tex \ensuremath{\uplus} }}
  | NOTIN 				:: :: notin
    {{ tex \ensuremath{\not\in} }}
  | SUBSET				:: :: subset
    {{ tex \ensuremath{\subset} }}
  | NOTEQ				:: :: noteq
    {{ tex \ensuremath{\not=} }}
  | emptyset				:: :: emptyset
    {{ tex \ensuremath{\emptyset} }}
  | < 					:: :: lt
    {{ tex \ensuremath{\langle} }}
  | > 					:: :: gt
    {{ tex \ensuremath{\rangle} }}
  | |-					:: :: vdash
    {{ tex \ensuremath{\vdash} }}
  | '					:: :: quote
    {{ tex \mbox{'} }}
  | |-> 				:: :: mapsto
    {{ tex \ensuremath{\mapsto} }}
  | gives				:: :: gives
    {{ tex \ensuremath{\triangleright} }}
  | ~>					:: :: leadsto
    {{ tex \ensuremath{\leadsto} }}
  | => 					:: :: Rightarrow
    {{ tex \ensuremath{\Rightarrow} }}
  | --					:: :: dashdash
    {{ tex \mbox{--} }}
  | empty				:: :: empty
    {{ tex \ensuremath{\epsilon} }}
 

formula :: formula_ ::=
  | judgement							:: :: judgement

  | formula1 .. formulan					:: :: dots

  | E_m ( x ) gives E						:: :: lookup_m
    {{ com Module lookup }}
    {{ hol (FLOOKUP [[E_m]] [[x]] = SOME [[E]]) }}

  | E_p ( x ) gives p						:: :: lookup_p
    {{ com Path lookup }}
    {{ hol (FLOOKUP [[E_p]] [[x]] = SOME [[p]]) }}

  | E_x ( x ) gives kinds v_desc				:: :: lookup_v
    {{ com Value lookup }}
    {{ hol (FLOOKUP [[E_x]] [[x]] = SOME ([[kinds]],[[v_desc]])) }}

  | E_l ( x ) gives t						:: :: lookup_l
    {{ com Lexical binding lookup }}
    {{ hol (FLOOKUP [[E_l]] [[x]] = SOME [[t]]) }}

  | TD ( p ) gives tc_def					:: :: lookup_tc
    {{ com Type constructor lookup }}
    {{ hol (FLOOKUP [[TD]] [[p]] = SOME [[tc_def]]) }}

  | TC ( p ) gives xs						:: :: lookup_class
    {{ com Type constructor lookup }}
    {{ hol (FLOOKUP [[TC]] [[p]] = SOME [[xs]]) }}

  | dom ( E_m1 ) inter dom ( E_m2 ) = emptyset			:: :: E_m_disjoint
    {{ hol (DISJOINT (FDOM [[E_m1]]) (FDOM [[E_m2]])) }}

  | dom ( E_x1 ) inter dom ( E_x2 ) = emptyset			:: :: E_x_disjoint
    {{ hol (DISJOINT (FDOM [[E_x1]]) (FDOM [[E_x2]])) }}

  | dom ( E_p1 ) inter dom ( E_p2 ) = emptyset			:: :: E_p_disjoint
    {{ hol (DISJOINT (FDOM [[E_p1]]) (FDOM [[E_p2]])) }}

  | disjoint doms ( E_l1 , .. , E_ln )				:: :: E_l_disjoint
    {{ hol (FOLDR (\E b. case b of NONE -> NONE || SOME s -> if DISJOINT (FDOM E) s then SOME (FDOM E UNION s) else NONE) (SOME {}) [[E_l1..E_ln]] <> NONE) }}
    {{ com Pairwise disjoint domains }}

  | disjoint doms ( E_x1 , .. , E_xn )				:: :: E_x_disjoint_many
    {{ hol (FOLDR (\E b. case b of NONE -> NONE || SOME s -> if DISJOINT (FDOM E) s then SOME (FDOM E UNION s) else NONE) (SOME {}) [[E_x1..E_xn]] <> NONE) }}
    {{ com Pairwise disjoint domains }}

  | compatible overlap ( { x1 |-> t1 } , .. , { xn |-> tn } )	:: :: E_l_compat
    {{ hol (!__n __m. MEM __m [[x1 t1 .. xn tn]] /\ MEM __n [[x1 t1..xn tn]] /\ (FST __m  = FST __n) ==> (SND __m = SND __n)) }}
    {{ com $(\ottnt{x}_i = \ottnt{x}_j) [[==>]] (\ottnt{t}_i = \ottnt{t}_j)$ }}

  | duplicates ( tvs ) = emptyset				:: :: no_dups_tvs
    {{ hol (ALL_DISTINCT [[tvs]]) }}

  | duplicates ( x1 , .. , xn )	= emptyset			:: :: no_dups
    {{ hol (ALL_DISTINCT [[x1..xn]]) }}

  | x NOTIN dom ( E_l )						:: :: notin_dom_l
    {{ hol ([[x]] NOTIN FDOM [[E_l]]) }}

  | x NOTIN dom ( E_x )						:: :: notin_dom_v
    {{ hol ([[x]] NOTIN FDOM [[E_x]]) }}

  | p NOTIN dom ( TC )						:: :: notin_dom_tc
    {{ hol ([[p]] NOTIN FDOM [[TC]]) }}

  | p NOTIN dom ( TD )						:: :: notin_dom_td
    {{ hol ([[p]] NOTIN FDOM [[TD]]) }}

  | kind NOTIN kinds						:: :: kind_notin
    {{ hol ([[kind]] NOTIN [[kinds]]) }}

  | kind In kinds						:: :: kind_in
    {{ hol ([[kind]] IN [[kinds]]) }}
    {{ tex [[kind]] \in [[kinds]] }}

  | kinds1 inter kinds2 = emptyset				:: :: kinds_disj
    {{ hol ([[kinds1]] INTER [[kinds2]] = {}) }}

  | kinds1 NOTEQ kinds2 					:: :: kinds_noteq
    {{ hol ([[kinds1]] <> [[kinds2]]) }}

  | FV ( t ) SUBSET tvs						:: :: FV_t
    {{ com Free type variables }}
    {{ hol (LIST_TO_SET (ftv_t [[t]]) SUBSET LIST_TO_SET [[tvs]]) }}

  | FV ( t_multi ) SUBSET tvs					:: :: FV_t_multi
    {{ com Free type variables }}
    {{ hol (LIST_TO_SET (FLAT (MAP ftv_t [[t_multi]])) SUBSET LIST_TO_SET [[tvs]]) }}

  | FV ( semC ) SUBSET tvs					:: :: FV_semC
    {{ com Free type variables }}
    {{ hol (LIST_TO_SET (MAP SND [[semC]]) SUBSET LIST_TO_SET [[tvs]]) }}

  | inst 'IN' I							:: :: inst_in
    {{ hol (MEM [[inst]] [[I]]) }}

  | ( p t ) NOTIN I						:: :: notin_I
    {{ hol (~?__semC__. MEM (Inst __semC__ [[p]] [[t]]) [[I]]) }}

  | E_l1 = E_l2							:: :: E_l_eqn
    {{ hol ([[E_l1]] = [[E_l2]]) }}

  | E_x1 = E_x2							:: :: E_x_eqn
    {{ hol ([[E_x1]] = [[E_x2]]) }}

  | E1 = E2							:: :: E_eqn
    {{ hol ([[E1]] = [[E2]]) }}

  | TD1 = TD2							:: :: TD_eqn
    {{ hol ([[TD1]] = [[TD2]]) }}

  | TC1 = TC2							:: :: TC_eqn
    {{ hol ([[TC1]] = [[TC2]]) }}

  | I1 = I2							:: :: I_eqn
    {{ hol ([[I1]] = [[I2]]) }}

  | names1 = names2						:: :: names_eq
    {{ hol ([[names1]] = [[names2]]) }}

  | t1 = t2							:: :: t_eq
    {{ hol ([[t1]] = [[t2]]) }}

  | t_subst1 = t_subst2						:: :: t_subst_eq
    {{ hol ([[t_subst1]] = [[t_subst2]]) }}

  | p1 = p2							:: :: p_eq
    {{ hol ([[p1]] = [[p2]]) }}

  | xs1 = xs2							:: :: xs_eq
    {{ hol ([[xs1]] = [[xs2]]) }}

  | tvs1 = tvs2							:: :: tvs_eq
    {{ hol ([[tvs1]] = [[tvs2]]) }}

% Substitutions and freevars are not correctly generated for the OCaml ast.ml
%substitutions
%multiple t a :: t_subst
%
%freevars
%t a :: ftv

defns
convert_tvs :: '' ::=

defn
tyvars ~> tvs :: :: convert_tvs :: convert_tvs_
by

------------------------------------------------------------ :: none
(a1 l1,..,an ln) ~> a1..an

defns
look_m :: '' ::=

defn
E1 ( x_l1 .. x_ln ) gives E2 :: :: look_m :: look_m_ 
{{ com Name path lookup }}
by

------------------------------------------------------------ :: none
E() gives E

E_m(x) gives E1
E1(y_l1 .. y_ln) gives E2
------------------------------------------------------------ :: some
<E_m,E_p,E_x>(x l y_l1 .. y_ln) gives E2

defns
look_m_id :: '' ::=
 
defn
E1 ( id ) gives E2 :: :: look_m_id :: look_m_id_ 
{{ com Module identifier lookup }}
by

E1(y_l1 .. y_ln x l1) gives E2
------------------------------------------------------------ :: all
E1(y_l1 . .. y_ln . x l1 l2) gives E2

defns
look_tc :: '' ::=

defn
E ( id ) gives p :: :: look_tc :: look_tc_ 
{{ com Path identifier lookup }}
by

E(y_l1 .. y_ln) gives <E_m,E_p,E_x>
E_p(x) gives p
------------------------------------------------------------ :: all
E(y_l1 . .. y_ln . x l1 l2) gives p

defns
look_val :: '' ::=

defn
E ( id ) gives kinds v_desc :: :: look_val :: look_var_ 
{{ com Value identifier lookup }}
by

E(y_l1 .. y_ln) gives <E_m,E_p,E_x>
E_x(x) gives kinds v_desc
------------------------------------------------------------ :: all
E(y_l1 . .. y_ln . x l1 l2) gives kinds v_desc


defns
check_t :: '' ::=

defn
TD |- t ok :: :: check_t :: check_t_ 
{{ com Well-formed types }}
by


------------------------------------------------------------ :: var
TD |- a ok

TD |- t1 ok
TD |- t2 ok
------------------------------------------------------------ :: fn
TD |- t1 -> t2 ok

TD |- t1 ok .... TD |- tn ok
------------------------------------------------------------ :: tup
TD |- t1 * .... * tn ok

TD |- t1 ok .. TD |- tn ok
TD(p) gives a1..an tc_abbrev
------------------------------------------------------------ :: app
TD |- (t1, .., tn) p ok

defns
teq :: '' ::=

defn
TD |- t1 = t2 :: :: teq :: teq_ 
{{ com Type equality }}
by

TD |- t ok
------------------------------------------------------------ :: refl
TD |- t = t

TD |- t2 = t1
------------------------------------------------------------ :: sym
TD |- t1 = t2

TD |- t1 = t2
TD |- t2 = t3
------------------------------------------------------------ :: trans
TD |- t1 = t3

TD |- t1 = t3
TD |- t2 = t4
------------------------------------------------------------ :: arrow
TD |- t1 -> t2 = t3 -> t4

TD |- t1 = u1 .... TD |- tn = un
------------------------------------------------------------ :: tup
TD |- t1*....*tn = u1*....*un

TD |- t1 = u1 .. TD |- tn = un
------------------------------------------------------------ :: app
TD |- (t1,..,tn) p = (u1,..,un) p

TD(p) gives a1..an . u 
------------------------------------------------------------ :: expand
TD |- (t1,..,tn) p = {a1|->t1..an|->tn}(u)


defns
convert_typ :: '' ::=

defn
TD , E |- typ ~> t :: :: convert_typ :: convert_typ_ 
{{ com Convert source types to internal types }}
by

% TODO : Can't allow things like type t = _, but it's useful to have things 
% like f (x : (_, int)) = snd x
%TD |- t ok
%------------------------------------------------------------ :: wild
%TD,E |- _ l ~> t

------------------------------------------------------------ :: var
TD,E |- a l' l ~> a

TD,E |- typ1 ~> t1
TD,E |- typ2 ~> t2
------------------------------------------------------------ :: fn
TD,E |- typ1->typ2 l ~> t1->t2

TD,E |- typ1 ~> t1 .... TD,E |- typn ~> tn
------------------------------------------------------------ :: tup
TD,E |- typ1 * .... * typn l ~> t1 * .... * tn

TD,E |- typ1 ~> t1 .. TD,E |- typn ~> tn
E(id) gives p
TD(p) gives a1..an tc_abbrev
------------------------------------------------------------ :: app
TD,E |- (typ1, .., typn) id l ~> (t1, .., tn) p

TD,E |- typ ~> t
------------------------------------------------------------ :: paren
TD,E |- (typ) l ~> t


TD,E |- typ ~> t1
TD |- t1 = t2
------------------------------------------------------------ :: eq
TD,E |- typ ~> t2

defns
convert_typs :: '' ::=

defn
TD , E |- typs ~> t_multi :: :: convert_typs :: convert_typs_ by

TD,E |- typ1 ~> t1 .. TD,E |- typn ~> tn
------------------------------------------------------------ :: all
TD,E |- typ1 * .. * typn ~> (t1 * .. * tn)

defns
check_lit :: '' ::=

defn
|- lit : t :: :: check_lit :: check_lit_ 
{{ com Typing literal constants }}
by

------------------------------------------------------------ :: true
|- true l : () __bool

------------------------------------------------------------ :: false
|- false l : () __bool

------------------------------------------------------------ :: num
|- num l : () __num

------------------------------------------------------------ :: string
|- string l : () __string

------------------------------------------------------------ :: unit
|- () l : () __unit


defns
inst_field :: '' ::=

defn
TD , E |- field id : t_args p -> t gives ( x of names ) :: :: inst_field :: inst_field_
{{ com Field typing (also returns canonical field names) }} 
by

E(id) gives {field} <forall a1..an. p -> t, (x of names)>
TD |- t1 ok .. TD |- tn ok
------------------------------------------------------------ :: all
TD,E |- field id : (t1, .., tn) p -> {a1|->t1..an|->tn}(t) gives (x of names)


defns
inst_ctor :: '' ::=

defn
TD , E |- ctor id : t_multi -> t_args p gives ( x of names ) :: :: inst_ctor :: inst_ctor_ 
{{ com Data constructor typing (also returns canonical constructor names) }} 
by

E(id) gives {ctor} <forall a1..an. t_multi -> p, (x of names)>
TD |- t1 ok .. TD |- tn ok
------------------------------------------------------------ :: all
TD,E |- ctor id : {a1|->t1..an|->tn}(t_multi) -> (t1,..,tn)p gives (x of names)


defns
inst_val :: '' ::=

defn
TD , E |- val id : t gives S :: :: inst_val :: inst_val_
{{ com Typing top-level bindings, collecting typeclass constraints }}
by

E(id) gives kinds forall a1..an. (p1 a'1) .. (pi a'i) => t
TD |- t1 ok .. TD |- tn ok
t_subst = {a1|->t1..an|->tn}
kinds NOTEQ {spec}
------------------------------------------------------------ :: all
TD, E |- val id : t_subst(t) gives {(p1 t_subst(a'1)), .., (pi t_subst(a'i))}


defns
not_ctor :: '' ::=

defn
E , E_l |- x not ctor :: :: not_ctor :: not_ctor_ 
{{ com $\ottnt{v}$ is not bound to a data constructor }}
by

E_l(x) gives t
------------------------------------------------------------ :: val
E,E_l |- x not ctor

x NOTIN dom(E_x)
------------------------------------------------------------ :: unbound
<E_m,E_p,E_x>,E_l |- x not ctor

E_x(x) gives kinds v_desc
ctor NOTIN kinds
------------------------------------------------------------ :: bound
<E_m,E_p,E_x>,E_l |- x not ctor

defns
not_shadowed :: '' ::=

defn
E_l |- id not shadowed :: :: not_shadowed :: not_shadowed_ 
{{ com $\ottnt{id}$ is not lexically shadowed }}
by

x NOTIN dom(E_l)
------------------------------------------------------------ :: sing
E_l |- x l1 l2 not shadowed

------------------------------------------------------------ :: multi
E_l |- x_l1. .. x_ln.y_l.z_l l not shadowed


defns
check_pat :: '' ::=

defn
TD , E , E_l1 |- pat : t gives E_l2 :: :: check_pat :: check_pat_ 
{{ com Typing patterns, building their binding environment }}
by

:check_pat_aux: TD,E,E_l1 |- pat_aux : t gives E_l2
------------------------------------------------------------ :: all
TD,E,E_l1 |- pat_aux l : t gives E_l2

defn
TD , E , E_l1 |- pat_aux : t gives E_l2 :: :: check_pat_aux :: check_pat_aux_ 
{{ com Typing patterns, building their binding environment }}
by

TD |- t ok
------------------------------------------------------------ :: wild
TD,E,E_l |- _ : t gives {}

TD,E,E_l1 |- pat : t gives E_l2
x NOTIN dom(E_l2)
------------------------------------------------------------ :: as
TD,E,E_l1 |- pat as x l : t gives E_l2 u+ {x|->t}

TD,E,E_l1 |- pat : t gives E_l2
TD,E |- typ ~> t
------------------------------------------------------------ :: typ
TD,E,E_l1 |- (pat : typ) : t gives E_l2

TD,E |- ctor id : (t1*..*tn) -> t_args p gives (x of names)
E_l |- id not shadowed
TD,E,E_l |- pat1 : t1 gives E_l1 .. TD,E,E_l |- patn : tn gives E_ln
disjoint doms(E_l1,..,E_ln)
------------------------------------------------------------ :: ident_constr
TD,E,E_l |- id pat1 .. patn : t_args p gives E_l1 u+ .. u+ E_ln

TD |- t ok
E,E_l |- x not ctor
------------------------------------------------------------ :: var
TD,E,E_l |- x l1 l2 : t gives {x|->t}

E_l |- id1 not shadowed ... E_l |- idn not shadowed
TD,E |- field id1 : t_args p -> t1 gives (x1 of names) ... TD,E |- field idn : t_args p -> tn gives (xn of names)
TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
disjoint doms(E_l1,...,E_ln)
duplicates(x1,...,xn) = emptyset
------------------------------------------------------------ :: record
TD,E,E_l |- <| id1 = pat1 l1; ...; idn = patn ln semi_opt |> : t_args p gives E_l1 u+ ... u+ E_ln

TD,E,E_l |- pat1 : t1 gives E_l1 .... TD,E,E_l |- patn : tn gives E_ln
disjoint doms(E_l1,....,E_ln)
------------------------------------------------------------ :: tup
TD,E,E_l |- (pat1, ...., patn) : t1 * .... * tn gives E_l1 u+ .... u+ E_ln 

TD |- t ok
TD,E,E_l |- pat1 : t gives E_l1 .. TD,E,E_l |- patn : t gives E_ln
disjoint doms(E_l1,..,E_ln)
------------------------------------------------------------ :: list
TD,E,E_l |- [pat1; ..; patn semi_opt] : (t) __list gives E_l1 u+ .. u+ E_ln 

TD,E,E_l1 |- pat : t gives E_l2
------------------------------------------------------------ :: paren
TD,E,E_l1 |- (pat) : t gives E_l2

TD,E,E_l1 |- pat1 : t gives E_l2
TD,E,E_l1 |- pat2 : (t) __list gives E_l3
disjoint doms(E_l2,E_l3)
------------------------------------------------------------ :: cons
TD,E,E_l1 |- pat1 :: pat2 : t gives E_l2 u+ E_l3

|- lit : t
------------------------------------------------------------ :: lit
TD,E,E_l |- lit : t gives {}

defns
check_exp :: '' ::=

defn
TD , E , E_l |- exp : t gives S :: :: check_exp :: check_exp_ 
{{ com Typing expressions, collecting typeclass constraints }}
by

:check_exp_aux: TD,E,E_l |- exp_aux : t gives S
------------------------------------------------------------ :: all
TD,E,E_l  |- exp_aux l : t gives S

defn
TD , E , E_l |- exp_aux : t gives S :: :: check_exp_aux :: check_exp_aux_
{{ com Typing expressions, collecting typeclass constraints }}
by

E_l(x) gives t
------------------------------------------------------------ :: ident_val
TD,E,E_l |- x l1 l2 : t gives {}

TD,E |- ctor id : t_multi -> t_args p gives (x of names)
E_l |- id not shadowed
------------------------------------------------------------ :: ident_constr
TD,E,E_l |- id : curry(t_multi, t_args p) gives {}

TD,E |- val id : t gives S
E_l |- id not shadowed
------------------------------------------------------------ :: ident_const
TD,E,E_l |- id : t gives S

TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
TD,E,E_l u+ E_l1 u+ ... u+ E_ln |- exp : u gives S
disjoint doms(E_l1,...,E_ln)
------------------------------------------------------------ :: fn
TD,E,E_l |- fun pat1 ... patn -> exp l : curry((t1*...*tn), u) gives S

TD,E,E_l |- pat1 : t gives E_l1 ... TD,E,E_l |- patn : t gives E_ln
TD,E,E_l u+ E_l1 |- exp1 : u gives S1 ... TD,E,E_l u+ E_ln |- expn : u gives Sn
------------------------------------------------------------ :: function
TD,E,E_l |- function bar_opt pat1 -> exp1 l1 | ... | patn -> expn ln end : t -> u gives S1 union ... union Sn 

TD,E,E_l |- exp1 : t1 -> t2 gives S1
TD,E,E_l |- exp2 : t1 gives S2
------------------------------------------------------------ :: app
TD,E,E_l |- exp1 exp2 : t2 gives S1 union S2

:check_exp_aux: TD,E,E_l |- (ix) : t1 -> t2 -> t3 gives S1
TD,E,E_l |- exp1 : t1 gives S2
TD,E,E_l |- exp2 : t2 gives S3
------------------------------------------------------------ :: infix_app1
TD,E,E_l |- exp1 ix l exp2 : t3 gives S1 union S2 union S3

:check_exp_aux: TD,E,E_l |- x : t1 -> t2 -> t3 gives S1
TD,E,E_l |- exp1 : t1 gives S2
TD,E,E_l |- exp2 : t2 gives S3
------------------------------------------------------------ :: infix_app2
TD,E,E_l |- exp1 `x` l exp2 : t3 gives S1 union S2 union S3

E_l |- id1 not shadowed ... E_l |- idn not shadowed
TD,E |- field id1 : t_args p -> t1 gives (x1 of names) ... TD,E |- field idn : t_args p -> tn gives (xn of names)
TD,E,E_l |- exp1 : t1 gives S1 ... TD,E,E_l |- expn : tn gives Sn
duplicates(x1,...,xn) = emptyset
names = {x1,...,xn}
------------------------------------------------------------ :: record
TD,E,E_l |- <| id1 = exp1 l1 ; ... ; idn = expn ln semi_opt l |> : t_args p gives S1 union ... union Sn

E_l |- id1 not shadowed ... E_l |- idn not shadowed
TD,E |- field id1 : t_args p -> t1 gives (x1 of names) ... TD,E |- field idn : t_args p -> tn gives (xn of names)
TD,E,E_l |- exp1 : t1 gives S1 ... TD,E,E_l |- expn : tn gives Sn
duplicates(x1,...,xn) = emptyset
TD,E,E_l |- exp : t_args p gives S'
------------------------------------------------------------ :: recup
TD,E,E_l |- <| exp with id1 = exp1 l1 ; ... ; idn = expn ln semi_opt l |> : t_args p gives S' union S1 union ... union Sn

E_l |- id not shadowed
TD,E |- field id : t_args p -> t gives (x of names)
TD,E,E_l |- exp : t_args p gives S
------------------------------------------------------------ :: field
TD,E,E_l |- exp.id : t gives S

TD,E,E_l |- pat1 : t gives E_l1 ... TD,E,E_l |- patn : t gives E_ln
TD,E,E_l u+ E_l1 |- exp1 : u gives S1 ... TD,E,E_l u+ E_ln |- expn : u gives Sn
TD,E,E_l |- exp : t gives S'
------------------------------------------------------------ :: case
TD,E,E_l |- match exp with bar_opt pat1 -> exp1 l1 | ... | patn -> expn ln l end : u gives S' union S1 union ... union Sn

TD,E,E_l |- exp : t gives S
TD,E |- typ ~> t
------------------------------------------------------------ :: typed
TD,E,E_l |- (exp : typ) : t gives S

TD,E,E_l1 |- letbind gives E_l2, S1
TD,E,E_l1 u+ E_l2 |- exp : t gives S2
------------------------------------------------------------ :: let
TD,E,E_l |- let letbind in exp : t gives S1 union S2

TD,E,E_l |- exp1 : t1 gives S1 .... TD,E,E_l |- expn : tn gives Sn
------------------------------------------------------------ :: tup
TD,E,E_l |- (exp1, ...., expn) : t1 * .... * tn gives S1 union .... union Sn

TD |- t ok
TD,E,E_l |- exp1 : t gives S1 .. TD,E,E_l |- expn : t gives Sn
------------------------------------------------------------ :: list
TD,E,E_l |- [exp1; ..; expn semi_opt] : (t) __list gives S1 union .. union Sn

TD,E,E_l |- exp : t gives S
------------------------------------------------------------ :: paren
TD,E,E_l |- (exp) : t gives S

TD,E,E_l |- exp : t gives S
------------------------------------------------------------ :: begin
TD,E,E_l |- begin exp end : t gives S

TD,E,E_l |- exp1 : () __bool gives S1
TD,E,E_l |- exp2 : t gives S2
TD,E,E_l |- exp3 : t gives S3
------------------------------------------------------------ :: if
TD,E,E_l |- if exp1 then exp2 else exp3 : t gives S1 union S2 union S3

TD,E,E_l |- exp1 : t gives S1
TD,E,E_l |- exp2 : (t) __list gives S2
------------------------------------------------------------ :: cons
TD,E,E_l |- exp1 :: exp2 : (t) __list gives S1 union S2

|- lit : t
------------------------------------------------------------ :: lit
TD,E,E_l |- lit : t gives {}

TD |- t1 ok .. TD |- tn ok
TD,E,E_l u+ {x1|->t1,..,xn|->tn} |- exp1 : t gives S1
TD,E,E_l u+ {x1|->t1,..,xn|->tn} |- exp2 : () __bool gives S2
disjoint doms(E_l, {x1|->t1,..,xn|->tn})
E = <E_m,E_p,E_x>
x1 NOTIN dom(E_x) .. xn NOTIN dom(E_x)
------------------------------------------------------------ :: set_comp
TD,E,E_l |- { exp1 | exp2 } : (t) __set gives S1 union S2

TD,E,E_l1 |- qbind1 .. qbindn gives E_l2,S1
TD,E,E_l1 u+ E_l2 |- exp1 : t gives S2
TD,E,E_l1 u+ E_l2 |- exp2 : () __bool gives S3
------------------------------------------------------------ :: set_comp_binding
TD,E,E_l1 |- { exp1 | forall qbind1 .. qbindn | exp2 } : (t) __set gives S1 union S2 union S3

TD |- t ok
TD,E,E_l |- exp1 : t gives S1 .. TD,E,E_l |- expn : t gives Sn
------------------------------------------------------------ :: set
TD,E,E_l |- { exp1; ..; expn semi_opt } : (t) __set gives S1 union .. union Sn

TD,E,E_l1 |- qbind1 ... qbindn gives E_l2,S1
TD,E,E_l1 u+ E_l2 |- exp : () __bool gives S2
------------------------------------------------------------ :: quant
TD,E,E_l1 |- q qbind1 ... qbindn . exp : () __bool gives S1 union S2

TD,E,E_l1 |- list qbind1 .. qbindn gives E_l2,S1
TD,E,E_l1 u+ E_l2 |- exp1 : t gives S2
TD,E,E_l1 u+ E_l2 |- exp2 : () __bool gives S3
------------------------------------------------------------ :: list_comp_binding
TD,E,E_l1 |- [ exp1 | forall qbind1 .. qbindn | exp2 ] : (t) __list gives S1 union S2 union S3

defn
TD , E , E_l1 |- qbind1 .. qbindn gives E_l2 , S :: :: check_listquant_binding
:: check_listquant_binding_
{{ com Build the environment for quantifier bindings, collecting typeclass constraints }}
 by

------------------------------------------------------------ :: empty
TD,E,E_l |- gives {},{}

TD |- t ok
TD,E,E_l1 u+ {x |-> t} |- qbind1 .. qbindn gives E_l2,S1
disjoint doms({x |-> t}, E_l2)
------------------------------------------------------------ :: var
TD,E,E_l1 |- x l qbind1 .. qbindn gives {x |-> t} u+ E_l2,S1

TD,E,E_l1 |- pat : t gives E_l3
TD,E,E_l1 |- exp : (t) __set gives S1
TD,E,E_l1 u+ E_l3 |- qbind1 .. qbindn gives E_l2,S2
disjoint doms(E_l3, E_l2)
------------------------------------------------------------ :: restr
TD,E,E_l1 |- (pat IN exp) qbind1 .. qbindn gives E_l2 u+ E_l3,S1 union S2

TD,E,E_l1 |- pat : t gives E_l3
TD,E,E_l1 |- exp : (t) __list gives S1
TD,E,E_l1 u+ E_l3 |- qbind1 .. qbindn gives E_l2,S2
disjoint doms(E_l3, E_l2)
------------------------------------------------------------ :: list_restr
TD,E,E_l1 |- (pat MEM exp) qbind1 .. qbindn gives E_l2 u+ E_l3,S1 union S2

defn
TD , E , E_l1 |- list qbind1 .. qbindn gives E_l2 , S :: :: check_quant_binding :: check_quant_binding_
{{ com Build the environment for quantifier bindings, collecting typeclass constraints }}
 by

------------------------------------------------------------ :: empty
TD,E,E_l |- list gives {},{}

TD,E,E_l1 |- pat : t gives E_l3
TD,E,E_l1 |- exp : (t) __list gives S1
TD,E,E_l1 u+ E_l3 |- qbind1 .. qbindn gives E_l2,S2
disjoint doms(E_l3, E_l2)
------------------------------------------------------------ :: restr
TD,E,E_l1 |- list (pat MEM exp) qbind1 .. qbindn gives E_l2 u+ E_l3,S1 union S2


defn
TD , E , E_l |- funcl gives { x |-> t } , S :: :: check_funcl :: check_funcl_
{{ com Build the environment for a function definition clause, collecting typeclass constraints }}
by

TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
TD,E,E_l u+ E_l1 u+ ... u+ E_ln |- exp : u gives S
disjoint doms(E_l1,...,E_ln)
TD,E |- typ ~> u
------------------------------------------------------------ :: annot
TD,E,E_l |- x l1 pat1 ... patn : typ = exp l2 gives {x |-> curry((t1 * ... * tn), u)}, S

TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
TD,E,E_l u+ E_l1 u+ ... u+ E_ln |- exp : u gives S
disjoint doms(E_l1,...,E_ln)
------------------------------------------------------------ :: noannot
TD,E,E_l |- x l1 pat1 ... patn = exp l2 gives {x |-> curry((t1 * ... * tn), u)}, S


defn
TD , E , E_l1 |- letbind gives E_l2 , S :: :: check_letbind :: check_letbind_ 
{{ com Build the environment for a let binding, collecting typeclass constraints }}
by

TD,E,E_l1 |- pat : t gives E_l2
TD,E,E_l1 |- exp : t gives S
TD,E |- typ ~> t
------------------------------------------------------------ :: val_annot
TD,E,E_l1 |- pat : typ = exp l gives E_l2,S

TD,E,E_l1 |- pat : t gives E_l2
TD,E,E_l1 |- exp : t gives S
------------------------------------------------------------ :: val_noannot
TD,E,E_l1 |- pat = exp l gives E_l2,S

:check_funcl:TD,E,E_l1 |- funcl_aux l gives {x|->t},S
------------------------------------------------------------ :: fn
TD,E,E_l1 |- funcl_aux l gives {x|->t},S

defns
check_rule :: '' ::=

defn
TD , E , E_l |- rule gives { x |-> t } , S :: :: check_rule :: check_rule_
{{ com Build the environment for an inductive relation clause, collecting typeclass constraints }}
by

TD |- t1 ok .. TD |- tn ok
E_l2 = {y1|->t1,..,yn|->tn} 
TD,E,E_l1 u+ E_l2 |- exp' : () __bool gives S'
TD,E,E_l1 u+ E_l2 |- exp1 : u1 gives S1 .. TD,E,E_l1 u+ E_l2 |- expi : ui gives Si
------------------------------------------------------------ :: rule
TD,E,E_l1 |- forall y1 l1 .. yn ln . exp' ==> x l exp1 .. expi l' gives {x|->curry((u1 * .. * ui) , () __bool)}, S' union S1 union .. union Si

defns
check_texp_tc :: '' ::=

defn
xs , TD1 , E |- tc td gives TD2 , E_p :: :: check_texp_tc :: check_texp_tc_
{{ com Extract the type constructor information }}
by

tyvars ~> tvs
TD,E |- typ ~> t
duplicates(tvs) = emptyset
FV(t) SUBSET tvs
y1. .. yn.x NOTIN dom(TD)
------------------------------------------------------------ :: abbrev
y1..yn,TD,E |- tc tyvars x l = typ gives {y1. .. yn.x|->tvs.t},{x|->y1. .. yn.x}

tyvars ~> tvs
duplicates(tvs) = emptyset
y1. .. yn.x NOTIN dom(TD)
------------------------------------------------------------ :: abstract
y1..yn,TD,E1 |- tc tyvars x l gives {y1. .. yn.x|->tvs},{x|->y1. .. yn.x}

tyvars ~> tvs
duplicates(tvs) = emptyset
y1. .. yn.x NOTIN dom(TD)
------------------------------------------------------------ :: rec
y1..yn,TD1,E |- tc tyvars x l = <| x_l1 : typ1 ; ... ; x_lj : typj semi_opt |> gives {y1. .. yn.x|->tvs},{x|->y1. .. yn.x}

tyvars ~> tvs
duplicates(tvs) = emptyset
y1. .. yn.x NOTIN dom(TD)
------------------------------------------------------------ :: var
y1..yn,TD1,E |- tc tyvars x l = bar_opt ctor_def1 | ... | ctor_defj gives {y1. .. yn.x|->tvs},{x|->y1. .. yn.x}

defns
check_texps_tc :: '' ::=

defn
xs , TD1 , E |- tc td1 .. tdi gives TD2 , E_p :: :: check_texps_tc :: check_texps_tc_
{{ com Extract the type constructor information }}
by

------------------------------------------------------------ :: empty
xs,TD,E |- tc gives {},{}

:check_texp_tc: xs,TD1,E |- tc td gives TD2,E_p2
xs,TD1 u+ TD2,E u+ <{},E_p2,{}> |- tc td1..tdi gives TD3,E_p3
dom(E_p2) inter dom(E_p3) = emptyset
------------------------------------------------------------ :: abbrev
xs,TD1,E |- tc td td1..tdi gives TD2 u+ TD3,E_p2 u+ E_p3

defns
check_texp :: '' ::=

defn
TD , E |- tvs p = texp gives E_x :: :: check_texp :: check_texp_ 
{{ com Check a type definition, with its path already resolved }}
by

------------------------------------------------------------ :: abbrev
TD,E |- tvs p = typ gives {}

TD,E |- typ1 ~> t1 ... TD,E |- typn ~> tn
names = {x1,...,xn}
duplicates(x1,...,xn) = emptyset
FV(t1) SUBSET tvs ... FV(tn) SUBSET tvs
E_x = {x1|->{field} <forall tvs. p -> t1, (x1 of names)>, ..., xn|->{field} <forall tvs. p -> tn, (xn of names)>}
------------------------------------------------------------ :: rec
TD,E |- tvs p = <| x_l1:typ1; ...; x_ln:typn semi_opt |> gives E_x

TD,E |- typs1 ~> t_multi1 ... TD,E |- typsn ~> t_multin
names = {x1,...,xn}
duplicates(x1,...,xn) = emptyset
FV(t_multi1) SUBSET tvs ... FV(t_multin) SUBSET tvs
E_x = {x1|->{ctor}<forall tvs. t_multi1 -> p, (x1 of names)>, ..., xn|->{ctor}<forall tvs. t_multin -> p, (xn of names)>}
------------------------------------------------------------ :: var
TD,E |- tvs p = bar_opt x_l1 of typs1 | ... | x_ln of typsn gives E_x

defns
check_texps :: '' ::=

defn
xs , TD , E |- td1 .. tdn gives E_x :: :: check_texps :: check_texps_ by

------------------------------------------------------------ :: empty
xs,TD,E |- gives {}

tyvars ~> tvs
TD,E1 |- tvs y1. .. yn.x = texp gives E_x1
y1..yn,TD,E |- td1..tdi gives E_x2
dom(E_x1) inter dom(E_x2) = emptyset
------------------------------------------------------------ :: cons_concrete
y1..yn,TD,E |- tyvars x l = texp td1..tdi gives E_x1 u+ E_x2

xs,TD,E |- td1..tdn gives E_x
------------------------------------------------------------ :: cons_abstract
xs,TD,E |- tyvars x l td1..tdn gives E_x

defns
convert_class :: '' ::=

defn
TC , E |- id ~> p :: :: convert_class :: convert_class_
{{ com Lookup a type class }}
by

E(id) gives p
TC(p) gives xs
------------------------------------------------------------ :: all
TC,E |- id ~> p

defns
solve_class_constraint :: '' ::=

defn
I |- ( p t ) 'IN' semC :: :: solve_class_constraint :: solve_class_constraint_
{{ com Solve class constraint }}
by

------------------------------------------------------------ :: immediate
I |- (p a) IN (p1 a1) .. (pi ai) (p a) (p'1 a'1) .. (p'j a'j)

(p1 a1)..(pn an)=>(p t) IN I 
I |- (p1 t_subst(a1)) IN semC .. I |- (pn t_subst(an)) IN semC
------------------------------------------------------------ :: chain
I |- (p t_subst(t)) IN semC

defns
solve_class_constraints :: '' ::=

defn
I |- S gives semC :: :: solve_class_constraints :: solve_class_constraints_
{{ com Solve class constraints }}
by

I |- (p1 t1) IN semC ..  I |- (pn tn) IN semC
------------------------------------------------------------ :: all
I |- {(p1 t1), .., (pn tn)} gives semC

defns
targets_opt_to_kinds :: '' ::=

defn
targets_opt ~> kinds :: :: targets_opt_to_kinds :: targets_opts_to_kinds_
{{ com Get the binding type for an optional target }}
by

------------------------------------------------------------ :: none
~> {let}

------------------------------------------------------------ :: some
{target1;..;targetn} ~> {target1;..;targetn}

defns
check_val_def :: '' ::=

defn
TD , I , E |- val_def gives E_x :: :: check_val_def :: check_val_def_
{{ com Check a value definition }}
by

TD,E,{} |- letbind gives {x1|->t1, .., xn|->tn},S
I |- S gives semC
FV(t1) SUBSET tvs .. FV(tn) SUBSET tvs
FV(semC) SUBSET tvs
targets_opt ~> kinds
------------------------------------------------------------ :: val
TD,I,E1 |- let targets_opt letbind gives {x1 |->kinds forall tvs. semC => t1, .., xn |->kinds forall tvs. semC => tn}

TD,E,E_l |- funcl1 gives {x1|->t1},S1 ... TD,E,E_l |- funcln gives {xn|->tn},Sn
I |- S gives semC
FV(t1) SUBSET tvs ... FV(tn) SUBSET tvs
FV(semC) SUBSET tvs
compatible overlap({x1|->t1}, ..., {xn|->tn})
E_l = {x1|->t1,...,xn|->tn}
targets_opt ~> kinds
------------------------------------------------------------ :: recfun
TD,I,E |- let rec targets_opt funcl1 and ... and funcln gives {x1 |->kinds forall tvs. semC => t1, ..., xn|->kinds forall tvs. semC => tn}

defns
check_t_instance :: '' ::=

defn

TD , ( a1 , .. , an ) |- t instance :: :: check_t_instance :: check_t_instance_
{{ com Check that $\ottnt{t}$ be a typeclass instance }}
by

------------------------------------------------------------ :: var
TD , (a) |- a instance

------------------------------------------------------------ :: tup 
TD , (a1, ...., an) |- a1 * .... * an instance

------------------------------------------------------------ :: fn
TD , (a1, a2) |- a1 -> an instance

TD(p) gives a'1..a'n
------------------------------------------------------------ :: tc
TD , (a1, .., an) |- (a1,..,an) p instance

defns
convert_v_env :: '' ::=

defn
E_x1 |- E_x2 ~> E_x3 :: :: convert_v_env :: convert_v_env_ 
{{ com Check that new definitions are compatible with existing ones }}
by

------------------------------------------------------------ :: empty
E_x1 |- {} ~> {}

x NOTIN dom(E_x1)
E_x1 |- E_x2 ~> E_x3
------------------------------------------------------------ :: first
E_x1 |- E_x2 u+ {x |-> kinds v_desc} ~> E_x3 u+ {x |-> kinds v_desc}

E_x1(x) gives kinds' v_desc
kinds inter kinds' = emptyset
kinds inter {mthd; ctor; field} = emptyset
kinds' inter {mthd; ctor; field} = emptyset
spec In kinds
E_x1 |- E_x2 ~> E_x3
------------------------------------------------------------ :: duplicate
E_x1 |- E_x2 u+ {x |-> kinds v_desc} ~> E_x3 u+ {x |-> kinds union kinds' v_desc}


defns
check_defs :: '' ::=

defn

xs , D1 , E1 |- def gives D2 , E2 :: :: check_def :: check_def_ 
{{ com Check a definition }}
by


xs,TD1,E |- tc td1 ... tdn gives TD2,E_p
xs,TD1 u+ TD2,E u+ <{},E_p,{}> |- td1 ... tdn gives E_x
------------------------------------------------------------ :: type 
xs,<TD1,TC,I>,E |- type td1 and ... and tdn l gives <TD2,{},{}>,<{},E_p,E_x>

TD,I,E |- val_def gives E_x
------------------------------------------------------------ :: val_def
xs,<TD,TC,I>,E |- val_def l gives empty,<{},{},E_x>

TD,E1,E_l |- rule1 gives {x1|->t1},S1 ... TD,E1,E_l |- rulen gives {xn|->tn},Sn
I |- S1 union ... union Sn gives semC
FV(t1) SUBSET tvs ... FV(tn) SUBSET tvs
FV(semC) SUBSET tvs
compatible overlap({x1|->t1}, ..., {xn|->tn})
E_l = {x1|->t1,...,xn|->tn}
targets_opt ~> kinds
E2 = <{},{},{x1 |->kinds forall tvs. semC => t1, ..., xn |->kinds forall tvs. semC => tn}> 
------------------------------------------------------------ :: indreln
xs,<TD,TC,I>,E1 |- indreln targets_opt rule1 and ... and rulen l gives empty,E2

x1..xn x,D1,E1,{} |- defs gives D2,E2
------------------------------------------------------------ :: module
x1..xn,D1,E1 |- module x l1 = struct defs end l2 gives D2,<{x|->E2},{},{}>

E1(id) gives E2
------------------------------------------------------------ :: module_rename
xs,D,E1 |- module x l1 = id l2 gives empty,<{x|->E2},{},{}>

TD,E |- typ ~> t
FV(t) SUBSET a1..ai
FV(a'1 * .. * a'j) SUBSET a1..ai
TC,E |- id1 ~> p1 .. TC,E |- idj ~> pj
E' = <{},{},{x|->{spec} forall a1..ai. (p1 a'1) .. (pj a'j) => t}>
------------------------------------------------------------ :: spec
xs,<TD,TC,I>,E |- val x l1 : forall a1 l''1 .. ai l''i. (id1 a'1 l'1) .. (idj a'j l'j) => typ l2 gives empty,E'

TD |- t1 ok .. TD |- tn ok
disjoint doms({y1|->t1},..,{yn|->tn})
TD,E1,{y1|->t1, .., yn|->tn} |- exp : t gives {}
t' = curry((t1 * .. * tn), t)
FV(t') SUBSET tvs
E2 = <{},{},{x |->{target} forall tvs. => t'}> 
------------------------------------------------------------ :: sub
xs,<TD,TC,I>,E1 |- sub [ target ] x l y1 l1 .. yn ln = exp l' gives empty,E2

TD,E1 |- typ1 ~> t1 ... TD,E1 |- typn ~> tn
FV(t1) SUBSET a ... FV(tn) SUBSET a
p = z1...zi.x
E2 = <{},{x|->p},{y1 |->{mthd} forall a. (p a) => t1, ..., yn |->{mthd} forall a. (p a) => tn}>
TC2 = {p|->y1...yn}
p NOTIN dom(TC1)
------------------------------------------------------------ :: class
z1..zi,<TD,TC1,I>,E1 |- class (x l a l'') val y1 l1 : typ1 l1 ... val yn ln : typn ln end l' gives <{},TC2,{}>,E2

E = <E_m,E_p,E_x>
TD,E |- typ' ~> t'
TD,(a1,..,ai) |- t' instance
tvs = a1..ai
duplicates(tvs) = emptyset
TC,E |- id1 ~> p1 .. TC,E |- idj ~> pj
FV(a'1 * .. * a'j) SUBSET tvs
E(id) gives p
TC(p) gives xs
I2 = { => (p1 a'1), .., => (pj a'j) }
TD,I union I2,E |- val_def1 gives E_x1 ... TD,I union I2,E|- val_defn gives E_xn
disjoint doms(E_x1,...,E_xn)
E_x(x1) gives {mthd} forall a''. (p a'') => t1 .. E_x(xk) gives {mthd} forall a''. (p a'') => tk
{x1 |->{let} forall tvs. => {a''|->t'}(t1) , .., xk |->{let} forall tvs. => {a''|->t'}(tk)} = E_x1 u+ ... u+ E_xn
x1..xk = xs
I3 = {(p1 a'1) .. (pj a'j) => (p t')}
(p {a1 |-> a'''1 .. ai |-> a'''i}(t')) NOTIN I
------------------------------------------------------------ :: instance_tc
xs,<TD,TC,I>,E |- instance forall a1 l'1 .. ai l'i. (id1 a'1 l''1) .. (idj a'j l''j) => (id typ') val_def1 l1 ... val_defn ln end l' gives <{},{},I3>,empty


defn
xs , D1 , E1 , E_x |- defs gives D2 , E2 :: :: check_defs :: check_defs_ 
{{ com Check definitions }}
by

------------------------------------------------------------ :: empty
xs,D,E,E_x |- gives empty,empty

% TODO: Ensure that a value name is not defined after its first use.
:check_def: xs,D1,E1 |- def gives D2,E2
E2 = <E_m2,E_p2,E_x2>
E_x1 |- E_x2 ~> E_x4
xs,D1 u+ D2,E1 u+ <E_m2,E_p2,E_x4>,E_x1 u+ E_x4 |- def1 semisemi_opt1 .. defn semisemi_optn gives D3,E3
E3 = <E_m3,E_p3,E_x3>
dom(E_m2) inter dom(E_m3) = emptyset
dom(E_p2) inter dom(E_p3) = emptyset
------------------------------------------------------------ :: def 
xs,D1,E1,E_x1 |- def semisemi_opt def1 semisemi_opt1 .. defn semisemi_optn gives D2 u+ D3, E2 u+ E3

E1(id) gives E3
xs,D1,E1 u+ E3,E_x |- def1 semisemi_opt1 .. defn semisemi_optn gives D2,E2
------------------------------------------------------------ :: open
xs,D1,E1,E_x |- open id l semisemi_opt def1 semisemi_opt1 .. defn semisemi_optn gives D2,E2

