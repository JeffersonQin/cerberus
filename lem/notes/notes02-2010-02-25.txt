S,P   Thu Feb 25 13:46:05 GMT 2010


Things needed before a parser can be built:

  resolution of var.field  modulename.var   - choose some scheme...
    done


  filenames in locations
    done


  for caml import compatibility:
   - more type annots
       done

   - hack for constructor applied to a syntactic tuple (with turn-off switch)
       done



----------------

write a yacc parser
  done

----------------

sort out the type classes

----------------

Extending the language to make is more useful:


  add logical stuff (bool, if, inductive relations)
     done

  sort out some way to make the l's less obvious (tex-hom into flying
  superscripts or just into oblivion)


<------ can socialise from this point-------->


----------------------

Backends

  HOL4 at least






----------------------

More extensions

  consider removing as patterns - depending on the compilation story


  consider adding nested modules  (and compilation strategy)


  add function prototypes


  module import renaming


  (more speculative:  user-supplied variable name constraints)

  A syntax for doing { THE (f x) | forall x IN S | f x <> None } in an
    extractable way

  Better record update, e.g. { r with f1.f2.f3 = 12 }

------------------

What's the compilation/logical story for all this


------------------

fancy syntax 

 - for now, determinedly punt  (except maybe for simple infixes)

 - because long-term, we'd want to pick some particular fancy parser
   generator and work with it.


Match

MATCH

match

[[  ]]

------------------
