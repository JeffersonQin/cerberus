% -*-LaTeX-*-

Notes on Lem -> Latex   Sat Apr 16 12:11:42 BST 2011    P


============
Overall plan
============

For each X.lem input file, we'll produce: 

- an X.tex file representing more-or-less the entire input file, and

- an X-inc.tex file of tex definitions, roughly one for each top-level
   Lem definition, so that they can be quoted in latex documents.

For each X.mng input file, we'll produce:

- an X.tex output file, with any [[ XXX ]] regions replaced by the tex
   pretty print of lem parsing of XXX, in the context of all the .lem
   inputs.  And <| |>, proper treatment of tex comments, rule-name
   invocation, etc. as in HOLDoc. 



Sundry issues:

For the X-inc.tex latex definitions:

- I guess that all the lem module structure except the file-level
modules should be flattened out  (and names replaced by compound
names, or not?)

- and we should have latex commands for typesetting each module and
file (that invoke the specific commands for the included definitions)

- As in HOLDoc, for each definition we want two versions, one with
just the definition body and one with the LHS  ("x = ").

- For mutually recursive definitions, we want a latex command for
each individual one and one for the collection.  And for inductively
defined relations, one for each rule.

Within definitions, we need tunable printing of comments - at least two kinds:
- perhaps (**  ... *)    and (* ... *)       (as coqdoc?)
- or perhaps (*: ... :*)  and (* ... *)      (as HOLDoc)
with the first always printed and the second optionally suppressed.

Between definitions, for the X.tex files, I guess we want to be able
to write arbitrary embedded latex, that gets copied into the X.tex at
top level, not inside { } or visible (* *).

Both comments and top-level-embedded latex should be allowed to
contain [[ ]].  Should that have to type-check in the current scope?
Unclear...


================================
HOLDoc generated latex structure
================================

Unpicking the latex that HOLDoc generates, for a HOL definition of
set_option_map it produces a latex command like this:

\newcommand{\defnsetToptionTmap}
{

  \ddefnn                    % typeset a definition in an \rrenbox

     {setToptionTmap}          % latex label

     {\iA{set\_option\_map}}   % index and contents line stuff

     {                         % put in \rrenside - basically tabbing math displaystyle

       \subddefnA                 % prefix the math with an optional description

         {set\_option\_map}       % ignored argument of subddefnA   

         {
         \tsaux{set\_option\_map} \;\tsunknown{f} \;\tsunknown{xs} ={}\\{}

         \{ (\Mcase  \;\tsunknown{f} \;\tsunknown{x} \;\Mof  \;\tscon{Some} \;\tsunknown{y} \Mtotype  \tsunknown{y}) \mid  \tsunknown{x} \mid  (\tsunknown{x} \;\in  \;\tsunknown{xs}) \Mwedge  \Mcase  \;\tsunknown{f} \;\tsunknown{x} \;\Mof  \;\tscon{Some} \;\tsunknown{\_} \Mtotype  \Mtrue  \Mdpipe  \tscon{None} \Mtotype  \Mfalse  \}

         }
     }

     {}                        % ignored argument of ddefnn

}



===========
Indentation
===========

Indentation:  the basic plan is to have some fixed amount of
indentation for each initial space character.  

In HOLDoc, that's refined by using tabbing for record brackets.
From ltsmunge.sty:

  % tabbing command handling: just disable them when not in tabbing env
  \newif\ifltsm@gicalign\ltsm@gicalignfalse

  % symbols:

  \newcommand{\Mlrec}{\langle\![}
  \newcommand{\Mrrec}{]\!\rangle}

  \newcommand{\Mmagiclrec}{%
    \ifltsm@gicalign$\=\+$\displaystyle\Mlrec\;$\=\+$\displaystyle\else\Mlrec\fi}
  \newcommand{\Mmagicrrec}{%
    \ifltsm@gicalign$\-\-$\displaystyle\fi\Mrrec}
  \newcommand{\Mmagicbolrrec}{%                    
    \ifltsm@gicalign$\<\-\-$\displaystyle\fi\Mrrec}

the last is used for a record-end at the beginning of a line.


where (http://www.tug.org/tutorials/latex2e/tabbing.html):

      \= Sets a tab stop at the current position.

      \+ Moves the left margin of the next and all the following
      commands one tab stop to the right.

      \- Moves the left margin of the next and all the following
      commands one tab stop to the left.

      \< This command allows you to put something to the left of the
      local margin without changing the margin. Can only be used at
      the start of the line.

and also:

      \> Advances to the next tab stop.
      \' Moves everything that you have typed so far in the current column, i.e. everything from the most recent \>, \<, \', \\, or \kill command, to the right of the previous column, flush against the current column's tab stop.
      \` Allows you to put text flush right against any tab stop, including tab stop 0. However, it can't move text to the right of the last column because there's no tab stop there. The \` command moves all the text that follows it, up to the \\ or \end{tabbing} command that ends the line, to the right margin of the tabbing environment. There must be no \> or \' command between the \` and the command that ends the line.
      \kill Sets tab stops without producing text. Works just like \\ except that it throws away the current line instead of producing output for it. The effect of any \=, \+ or \- commands in that line remain in effect.
      \pushtabs Saves all current tab stop positions. Useful for temporarily changing tab stop positions in the middle of a tabbing environment.
      \poptabs Restores the tab stop positions saved by the last \pushtabs.
      \a In a tabbing environment, the commands \=, \' and \` do not produce accents as normal. Instead, the commands \a=, \a' and \a` are used. 


Why do we need tabbing?  I guess really because in a record

      <| f1=v1;
         f2=v2;
         f3=v3 |>

we want the fi left-aligned, but the first one f1 typically is not the
first non-whitespace thing on its line, so the user can't just use the
same amount of initial whitespace.   Record type definitions
similarly. 

What other Lem constructs need special treatment?  

Pattern matching doesn't, as there the | characters are all typically
the first non-whitespace thing on their lines.  I don't care about
supporting

   match x with | Foo -> 
                | Bar ->

For the irritating optional first |, we can just output a latex phantom.

Record update does - here we want alignment after the "with":

  <| i with f1=v1; 
            ... 
            fn=vn |>

Set and list comprehensions do too, eg:

   { foo 
   | q  
   | bar 
     more-bar }

and:

   { foo | q  
   | bar 
     more-bar }



==========
Latex homs
==========

For vanilla identifier homs, we could either do it on the basis of the
identifier string or at binding points. 

For top-level definitions, the latter is nicer (proper, and perfectly
easy). For locally bound names, eg if we have many occurrences of
[[forall s. P]] and all such [[s]]'s should be typeset as \sigma,
it'd be horrible and error-prone to have to repeat the {{ tex \sigma}}
at every binder. 

The string-based approach works better when we have variant strings,
eg G, G', G0 which should be typeset as \Gamma, \Gamma', and \Gamma_0.

This ties in with the idea of specifying the legal identifier strings
for identifiers of a Lem type - if we were doing that, by adding an OCaml
regexp to the type definition, we could add a replace-string for the
tex. 



For curried homs:
Lem has binary application and infix application.  But 
I guess we can tell internally how many arguments something is applied
to, and so we can have separate homs for something that's fully applied
and the same thing that's not at all applied. 

We might really prefer some more general AST pattern-matching hom, eg
so we could replace (a,b) IN po by   a \tran{po} b  without having to
rephrase the source into a cpp-model-like   I a po b.   Though the
latter does improve source readability. 


constant x y z  -> K (\xs ys zs. ...)  .... [[x]]    [[z]] ....


In the cpp model, our sedscript also did a lot of suppression of extra
arguments.  In Lem that would be more properly done with a Coq-like
Section and Variable mechanism, eg:

  Section RELSEM.
  Variable ge: Cminor.genv.
  ...
  End RELSEM.  




Looking ahead to generating Lem from Ott, it'd be nice if we could
generate Lem homs from the general case of Ott homs.



Then we have the question of what to do with the intervening
whitespace comments...  Go back to explicit specification for some,
and warning + default-positioning where there isn't really a sensible
place to put them?


==================
Lem implementation
==================

Start extending backend.ml, for the non-inc output, and see how it
goes?



