open Batteries_uni

let get_lexbuf fn =
  let lexbuf = Lexing.from_channel (open_in fn) in
    lexbuf.Lexing.lex_curr_p <- { Lexing.pos_fname = fn;
                                  Lexing.pos_lnum = 1;
                                  Lexing.pos_bol = 0;
                                  Lexing.pos_cnum = 0; };
    lexbuf

let print_pos p =
  Format.printf "File \"%s\", line %d, character %d:\n"
    p.Lexing.pos_fname p.Lexing.pos_lnum (p.Lexing.pos_cnum - p.Lexing.pos_bol)

let print_pos2 p1 p2 =
  Format.printf "File \"%s\", line %d, character %d to line %d, character %d:\n"
    p1.Lexing.pos_fname 
    p1.Lexing.pos_lnum (p1.Lexing.pos_cnum - p1.Lexing.pos_bol + 1)
    p2.Lexing.pos_lnum (p2.Lexing.pos_cnum - p2.Lexing.pos_bol)

let print_msg l m1 m2 =
  match l with
    | Ast.Unknown ->
        Format.printf "%s: %s\n" m1 m2
    | Ast.Range(p1,p2) ->
        print_pos2 p1 p2;
        Format.printf "%s: %s\n" m1 m2
    | Ast.Trans(s) ->
        Format.printf "Generated code: %s\n" s;
        Format.printf "%s: %s\n" m1 m2

let parse_file (f : string) : (Ast.defs * Ast.lex_skips) =
  let lexbuf = get_lexbuf f in
    try
      Parser.file (Lexer.token []) lexbuf
    with
      | Parsing.Parse_error ->
          let pos = Lexing.lexeme_start_p lexbuf in
            print_pos pos;
            Format.printf "Syntax error\n";
            raise Exit
      | Ast.Parse_error_locn(l,m) ->
          print_msg l "Syntax error" m;
          raise Exit
      | Lexer.LexError(c,p) ->
          print_pos p;
          Format.printf "Lexical error: unknown character %c\n" c;
          raise Exit

type instances = Types.instance list Types.Pfmap.t

let check_ast (mod_path : Name.t list) 
      ((tdefs,env) : ((Types.type_defs * instances) * Typed_ast.env)) 
      (ast, end_lex_skips)
      : (Types.type_defs * instances * instances) * Typed_ast.env * (Typed_ast.def list * Ast.lex_skips) =
  try
    let (defs,env,tast) = 
      Typecheck.check_defs mod_path tdefs env ast 
    in
      (defs,env,(tast,end_lex_skips))
  with
    | Types.No_type(l,m) ->
        print_msg l "Type error" m;
        raise Exit

let check_ast_as_module (mod_path : Name.t list)
      (e : ((Types.type_defs * instances) * Typed_ast.env)) 
      (mod_name : BatRope.t) (ast, end_lex_skips)
      : (Types.type_defs * instances * instances) * Typed_ast.env * (Typed_ast.def list * Ast.lex_skips) =
  check_ast mod_path e
    (Ast.Defs([(Ast.Def_l(Ast.Module(None, Ast.X_l((None,mod_name),Ast.Unknown), None, None, ast, None), Ast.Unknown), 
                None,
                false)]), end_lex_skips)

let generated_line f = 
  BatPrint.sprintf p" generated by Lem from %s " f

let tex_preamble = 
  "\\documentclass{article}\n" ^
  "\\usepackage{amsmath,amssymb}\n" ^
  "\\usepackage{color}\n" ^
  "\\usepackage{geometry}\n" ^
  "\\usepackage{alltt}\n" ^
  "\\usepackage{lem}\n" ^
  "\\geometry{a4paper,dvips,twoside,left=22.5mm,right=22.5mm,top=20mm,bottom=30mm}\n" ^
  "\\begin{document}\n"^
  "\\tableofcontents\n\\newpage\n"
  
let tex_postamble = 
  "\\end{document}\n"

let output1 libpath targ avoid type_info m alldoc_accum alldoc_inc_accum =
  let module C = struct
    let avoid = avoid
  end
  in
  let module B = Backend.Make(C) in
  let open Typed_ast in
  let f' = Filename.basename (Filename.chop_extension m.filename) in
    match targ with
      | None ->
          let r = B.ident_defs m.typed_ast in
            BatPrint.printf p"%rope" r
      | Some(Typed_ast.Target_hol) ->
          begin
            let r = B.hol_defs m.typed_ast in
            let o = open_out (m.module_name ^ "Script.sml") in
              BatPrint.fprintf o p"(*%s*)\n" (generated_line m.filename);
              BatPrint.fprintf o p"open bossLib Theory Parse res_quanTheory\n";
              BatPrint.fprintf o p"open finite_mapTheory listTheory pairTheory pred_setTheory\n";
              BatPrint.fprintf o p"open set_relationTheory sortingTheory stringTheory wordsTheory\n\n";
              BatPrint.fprintf o p"val _ = new_theory \"%s\"\n\n" m.module_name;
              (*
               BatPrint.fprintf o p"val _ = Parse.temp_add_infix(\"-->\",200,HOLgrammars.RIGHT);\n";
               BatPrint.fprintf o p"val _ = Definition.new_definition(\"-->\", ``$--> = $==>``);\n\n";
               *)
              begin
                if m.predecessor_modules <> [] then
                  begin
                    BatPrint.fprintf o p"open";
                    List.iter
                      (fun f -> BatPrint.fprintf o p" %s" f; BatPrint.fprintf o p"Theory")
                      m.predecessor_modules;
                    BatPrint.fprintf o p"\n\n"
                  end
                else 
                  ()
              end;
              BatPrint.fprintf o p"%rope" r;
              BatPrint.fprintf o p"val _ = export_theory()\n\n";
              close_out o
          end
      | Some(Typed_ast.Target_tex) -> 
          begin
            let r = B.tex_defs m.typed_ast in
            (* complete tex document, wrapped in tex_preamble and tex_postamble *)
            let (^^^^) = BatRope.(^^^) in
            let r' = r"\\section{" ^^^^ Output.tex_escape (BatRope.of_string f') ^^^^ r"}\n" ^^^^ r in
              alldoc_accum := (!alldoc_accum) @ [r'];
              let o = open_out (f' ^ ".tex") in
                BatPrint.fprintf o p"%%%s\n" (generated_line m.filename);
                BatPrint.fprintf o p"%s" tex_preamble;
                BatPrint.fprintf o p"%rope" r;
                BatPrint.fprintf o p"%s" tex_postamble;
                close_out o;
                (* tex definitions to include in other documents *)
                let r = B.tex_inc_defs m.typed_ast in
                  alldoc_inc_accum := (!alldoc_inc_accum) @ [r'];
                  let o = open_out (f' ^ "-inc.tex") in
                    BatPrint.fprintf o p"%%%s\n" (generated_line m.filename);
                    BatPrint.fprintf o p"%rope" r;
                    close_out o
          end
      | Some(Typed_ast.Target_ocaml) -> 
          begin
            let r = B.ocaml_defs m.typed_ast in
            let o = open_out (f' ^ ".ml") in
              BatPrint.fprintf o p"(*%s*)\n" (generated_line m.filename);
              BatPrint.fprintf o p"open Nat_num\n\n";
              BatPrint.fprintf o p"type 'a set = 'a Pset.set\n\n";
              BatPrint.fprintf o p"%rope" r;
              close_out o
          end
      | Some(Typed_ast.Target_isa) -> 
          begin
            let r = B.isa_defs m.typed_ast in
            let r1 = B.isa_header_defs m.typed_ast in
              try
                let o = open_out (m.module_name ^ ".thy") in 
                  BatPrint.fprintf o p"header{*%s*}\n\n" (generated_line m.filename);
                  BatPrint.fprintf o p"theory \"%s\" \n\n" m.module_name;
                  BatPrint.fprintf o p"imports \n \t \"%s/num_type\" \n" libpath;

                  BatPrint.fprintf o p"%rope" r1;

                  begin 
                    if m.predecessor_modules <> [] then 
                      begin
                        List.iter (fun f -> BatPrint.fprintf o p"\t \"%s\" \n" m.filename) m.predecessor_modules;
                      end
                    else ()
                  end;

                  BatPrint.fprintf o p"\nbegin \n\n";
                  BatPrint.fprintf o p"%rope" r;
                  BatPrint.fprintf o p"end\n";
                  close_out o
              with
                | Trans.Trans_error(l,msg) ->
                    print_msg l "Header translation error" msg;
                    raise Exit
          end
      | Some(Typed_ast.Target_coq) -> 
          begin
            let r = B.coq_defs m.typed_ast in
            let o = open_out (f' ^ ".v") in
              BatPrint.fprintf o p"(*%s*)\n" (generated_line m.filename);
              BatPrint.fprintf o p"(* let's see what we get... *)\n\n";
              BatPrint.fprintf o p"Notation num := nat.\n";
              BatPrint.fprintf o p"Require Import List.\n\n";
              BatPrint.fprintf o p"%rope" r;
              close_out o
          end

let output libpath targ consts type_info mods alldoc_accum alldoc_inc_accum =
  List.iter
    (fun m ->
       output1 libpath targ consts type_info m alldoc_accum alldoc_inc_accum)
    mods


let output_alldoc f' fs alldoc_accum alldoc_inc_accum = 
  let rs = !alldoc_accum in
  let o = open_out (f' ^ ".tex") in
  BatPrint.fprintf o p"%%%s\n" (generated_line fs);
  BatPrint.fprintf o p"%s" tex_preamble;
  BatPrint.fprintf o p"%rope" (BatRope.concat r"" rs);
  BatPrint.fprintf o p"%s" tex_postamble;
  close_out o;
  let rs = !alldoc_inc_accum in
  let o = open_out (f' ^ "-inc.tex") in
  BatPrint.fprintf o p"%%%s\n" (generated_line fs);
  BatPrint.fprintf o p"%rope" (BatRope.concat r"" rs);
  close_out o
