indexvar n , i , j , k ::=
  {{ phantom }}
  {{ com Index variables for meta-lists }}

metavar num ::=
  {{ phantom }}
  {{ lex numeric }}
  {{ ocaml terminal * int }}
  {{ hol num }}
  {{ com Numeric literals }}

%KATHYMOD
metavar hex ::=
  {{ phantom }}
  {{ lex numeric }}
  {{ com Bit vector literal, specified by C-style hex number }}

metavar oct ::=  
  {{ phantom }}
  {{ lex numeric }}
  {{ com Bit vector literal, specified by C-style octal number }}
  
metavar bin ::=
  {{ phantom }}
  {{ lex numeric }}
  {{ com Bit vector literal, specified by C-style binary number }}  
%ENDMOD

metavar string ::=
  {{ phantom }}
  {{ ocaml terminal * string }}
  {{ hol string }}
  {{ com String literals }}

embed
{{ ocaml

type text = Ulib.Text.t

type l =
  | Unknown
  | Trans of string
  | Range of Lexing.position * Lexing.position

exception Parse_error_locn of l * string

type ml_comment = 
  | Chars of Ulib.Text.t
  | Comment of ml_comment list

type lex_skip =
  | Com of ml_comment
  | Ws of Ulib.Text.t
  | Nl

type lex_skips = lex_skip list option

let pp_lex_skips ppf sk = 
  match sk with
    | None -> ()
    | Some(sks) ->
        List.iter
          (fun sk ->
             match sk with
               | Com(ml_comment) ->
                   (* TODO: fix? *)
                   Format.fprintf ppf "(**)"
               | Ws(r) ->
                   Format.fprintf ppf "%s" (Ulib.Text.to_string r)
               | Nl -> Format.fprintf ppf "\\n")
          sks

let combine_lex_skips s1 s2 =
  match (s1,s2) with
    | (None,_) -> s2
    | (_,None) -> s1
    | (Some(s1),Some(s2)) -> Some(s2@s1)

type terminal = lex_skips

}}


metavar x , y , z ::=
  {{ ocaml terminal * text }}
  {{ hol string }}
  {{ com Variables }}
  {{ ocamlvar "[[x]]" }}

metavar ix ::=
  {{ lex alphanum }}
  {{ ocaml terminal * text }}
  {{ hol string }}
  {{ com Variables }}
  {{ ocamlvar "[[ix]]" }}



grammar

l :: '' ::=					{{ phantom }}
						{{ ocaml l }}
						{{ hol unit }}
  {{ com Source locations }}
  | 						:: :: Unknown
    {{ ocaml Unknown }}
    {{ hol () }}

x_l {{ tex \ottnt{x}^{l} }} , y_l {{ tex \ottnt{y}^{l} }} , z_l {{ tex \ottnt{z}^{l} }} :: '' ::=
  {{ com Location-annotated names }}
  | x l						:: :: X_l
  | ( ix ) l					:: :: PreX_l
    {{ com Remove infix status }}

ix_l {{ tex \ottnt{ix}^{l} }} :: '' ::=
  {{ com Location-annotated infix names }}
  | ix l					:: :: SymX_l
  | ` x ` l					:: :: InX_l
    {{ com Add infix status }}

embed
{{ ocaml
let xl_to_l = function
  | X_l(_,l) -> l
  | PreX_l(_,_,_,l) -> l

let ixl_to_l = function
  | SymX_l(_,l) -> l
  | InX_l(_,_,_,l) -> l
}}

grammar

a {{ tex \alpha }} :: '' ::=
						{{ ocaml terminal * text }}
						{{ hol string }}
  {{ com Type variables }}
  | ' x 					:: :: A
    {{ hol [[x]] }}
    {{ ocaml [[x]] }}

a_l {{ tex \alpha^{l} }} :: '' ::=
  {{ com Location-annotated type variables }}
  | a l						:: :: A_l

%% KATHYMOD
%% Additional type var for vector lengths
nty {{ tex \nu }} :: '' ::=
                                                   {{ ocaml terminal * text }}
                                                   {{ hol string }}
    {{ com Dependent type variables }} 
    | ' ' x                                        :: :: N
      {{ hol [[x]] }}
      {{ ocaml [[x]] }}            

nty_l {{ tex \nu^{l} }} :: '' ::=
  {{ com Location-annotated dependent type variables }}
  | nty l                                           :: :: N_l

%% ENDMOD

id :: '' ::=
  {{ com Long identifers }}
  | x_l1 . .. x_ln . x_l l				:: :: Id

%% KATHYMOD
% Original
%tyvars :: '' ::=				{{ phantom }}
%						{{ hol a_l list }}
%						{{ ocaml terminal * (a_l * terminal) list * terminal }}
%  {{ com Type variable lists }}
%  | ( a_l1 , .. , a_ln )			:: :: Tvs_l
%    {{ com Must have $>1$ type variables }}
%    {{ hol [[a_l1..a_ln]] }}
%    {{ ocaml [[a_l1..a_ln]] }}
%  | a_l						:: S :: Tvs_single
%    {{ hol [ [[a_l]] ] }}
%    {{ ocaml [ [[a_l]] ] }}
%  |						:: S :: Tvs_none
%    {{ hol [] }}
%    {{ ocaml [] }}

tyvar :: '' ::=                                {{ phantom }}
   {{ com Union of type variables and dependent type variables }}
   | a_l                                         :: :: Av
   | nty_l                                        :: :: Nv

%We may not need tyvars anymore, since they're not under lists
tyvars :: '' ::=				{{ phantom }}
						{{ hol tyvar list }}
						{{ ocaml tyvar list }}
  {{ com Type variable lists }}
  | tyvar1 .. tyvarn		:: :: Tvs_l
    {{ hol [[tyvar1..tyvarn]] }}
    {{ ocaml [[tyvar1..tyvarn]] }}
%ENDMOD

%KATHYMOD
%
length_aux :: 'Length_' ::=  
  {{ com Length expressions }}
  | nty                                          :: :: var
  | num                                      :: :: constant
  | num * nty                                :: :: times
  | length1 + length2			:: :: sum

length :: '' ::=
  {{ com Location-annotated vector lengths }}
  | length_aux l				:: :: Length_l

length_constraint :: '' ::=
  {{ com Whether a vector is bounded or fixed size }}
  | length					:: :: fixed
  | >= length				:: :: bounded

%ENDMOD

typ_aux :: 'Typ_' ::=
  {{ com Types }}
  | _						:: :: wild
    {{ com Unspecified type }}
  | a_l						:: :: var
    {{ com Type variables }}
  | typ1 -> typ2				:: :: fn
    {{ com Function types }}
  | typ1 * .... * typn				:: :: tup
    {{ com Tuple types }}
%KATHYMOD
  | id typ_len1 .. typ_lenn			:: :: app
  {{ com Type applications }}
% Types to support dependently-typed bit vectors, remove for AST keep for now for discussions
  | bit						:: :: bit
  {{ com Type for bit constants }}
  | vector length typ                    :: :: vector
  {{ com Type for vectors, including length constraint }}
%ENDMOD  
  | ( typ )					:: :: paren

typ :: '' ::=
  {{ com Location-annotated types }}
  | typ_aux l					:: :: Typ_l

typ_len :: 'TypL_' ::=
  {{ com Type or length }}
  | typ						:: :: typ
  | length					:: :: len

parsing

Typ_tup <= Typ_tup
Typ_fn right Typ_fn
Typ_fn <= Typ_tup
%Typ_fn right Typ_app1
%Typ_tup right Typ_app1

grammar

lit_aux :: 'L_' ::=
  {{ com Literal constants }}
  | true						:: :: true
  | false						:: :: false
  | num						:: :: num
%KATHYMOD
  | hex						:: :: hex
  {{ com hex, oct, and bin are constant bit vectors, entered as C-style hex, octal, or binaries }}
  | oct						:: :: oct
  | bin						:: :: bin
%ENDMOD  
  | string						:: :: string
  | ( )							:: :: unit
%KATHYMOD
  | bitzero						:: :: zero
  {{ com bitzero and bitone are constant bits, if commonly used we will consider overloading 0 and 1 }}
  | bitone						:: :: one

lit :: '' ::=
  | lit_aux l						:: :: Lit_l
    {{ com Location-annotated literal constants }}

semi_opt {{ tex \ottnt{;}^{?} }} :: 'semi_' ::=		{{ phantom }}
							{{ ocaml terminal * bool }}
							{{ hol bool }}
  {{ com Optional semi-colons }}
  |  							:: :: no
    {{ hol F }}
    {{ ocaml false }}
  | ';'							:: :: yes
    {{ hol T }}
    {{ ocaml true }}


pat_aux :: 'P_' ::= 
  {{ com Patterns }}
  | _							:: :: wild  
    {{ com Wildcards }}
  | ( pat as x_l )					:: :: as
    {{ com Named patterns }}
  | ( pat : typ )					:: :: typ
    {{ com Typed patterns }}
  | id pat1 .. patn					:: :: app
    {{ com Single variable and constructor patterns }}
  | <| fpat1 ; ... ; fpatn semi_opt |>			:: :: record
    {{ com Record patterns }}
%KATHYMOD
%Patterns for vectors
  | [| pat1 ; .. ; patn |]				:: :: vector
   {{ com Vector patterns }}
  | [| pat1  ..  patn |]	 			:: :: vectorC
  {{ com Concatenated vector patterns }} 
%ENDMOD    
  | ( pat1 , .... , patn )				:: :: tup
    {{ com Tuple patterns }}
  | [ pat1 ; .. ; patn semi_opt ]			:: :: list
    {{ com List patterns }}
  | ( pat )						:: :: paren
  | pat1 '::' pat2					:: :: cons
    {{ com Cons patterns }}
  | lit							:: :: lit
    {{ com Literal constant patterns }}

pat :: '' ::=
  {{ com Location-annotated patterns }}
  | pat_aux l						::  :: Pat_l

fpat :: '' ::=
  {{ com Field patterns }}
  | id = pat l						:: :: Fpat

parsing
P_app <= P_app
P_app <= P_as

grammar

bar_opt {{ tex \ottkw{|}^{?} }} :: 'bar_' ::=		{{ phantom }}
							{{ ocaml terminal * bool }}
							{{ hol bool }}
  {{ com Optional bars }}
  |  							:: :: no
    {{ hol F }}
    {{ ocaml false }}
  | '|'							:: :: yes
    {{ hol T }}
    {{ ocaml true }}

exp_aux :: '' ::=
  {{ com Expressions }}
  | id							:: :: Ident
    {{ com Identifiers }}
  | fun psexp						:: :: Fun 
    {{ com Curried functions }}
  | function bar_opt pexp1 '|' ... '|' pexpn end	:: :: Function
    {{ com Functions with pattern matching }}
  | exp1 exp2						:: :: App
    {{ com Function applications }}
  | exp1 ix_l exp2					:: :: Infix
    {{ com Infix applications }}
  | <| fexps |>						:: :: Record
    {{ com Records }}
  | <| exp with fexps |>				:: :: Recup
    {{ com Functional update for records }}
  | exp . id						:: :: Field
    {{ com Field projection for records }}
%KATHYMOD
%Expressions for creating and accessing vectors
  | [| exp1 ; ..  ; expn |]				:: :: Vector
  {{ com Explicit vector instantiation, 0 based }}
  | [| exp1 @ ..  @ expn |]				:: :: VConcat
  {{ com Vector concatenation }}
  | exp . ( length ) 					:: :: VAccess
  {{ com Vector access }}
  | exp . ( length1 . . length2 )			:: :: VAccessR
  {{ com Subvector extraction }}
  | [| exp1 , exp2 | foreach pat1 , pat2 | exp3 |]	:: :: Vmap2
  {{ com Map over two vectors }}
  | [| exp1 | letbind in exp2 |]				:: :: Vfoldl
  {{ com Vector fold left }}
  | [| letbind in exp1 | exp2 |]				:: :: Vfoldr
  {{ com Vector fold right }}
%ENDMOD    
  | match exp with bar_opt pexp1 '|' ... '|' pexpn l end :: :: Case
    {{ com Pattern matching expressions }}
  | ( exp : typ )					:: :: Typed
    {{ com Type-annotated expressions }}
  | let letbind in exp					:: :: Let
    {{ com Let expressions }}
  | ( exp1 , .... , expn )				:: :: Tup
    {{ com Tuples }}
  | [ exp1 ; .. ; expn semi_opt ]			:: :: List
    {{ com Lists }}
  | ( exp )						:: :: Paren
  | begin exp end					:: :: Begin
    {{ com Alternate syntax for $\ottnt(exp)$ }}
  | if exp1 then exp2 else exp3				:: :: If
    {{ com Conditionals }}
  | exp1 '::' exp2					:: :: Cons
    {{ com Cons expressions }}
  | lit							:: :: Lit
    {{ com Literal constants }}
  | { exp1 | exp2 }					:: :: Setcomp
    {{ com Set comprehensions }}
  | { exp1 | forall qbind1 .. qbindn | exp2 }		:: :: Setcomp_binding
    {{ com Set comprehensions with explicit binding }}
  | { exp1 ; .. ; expn semi_opt }			:: :: Set
    {{ com Sets }}
  | q qbind1 ... qbindn . exp				:: :: Quant
    {{ com Logical quantifications }}
  | [ exp1 | forall qbind1 .. qbindn | exp2 ]		:: :: Listcomp
    {{ com List comprehensions (all binders must be quantified) }}

exp  :: '' ::=
  {{ com Location-annotated expressions }}
  | exp_aux l						:: :: Expr_l

q :: 'Q_' ::=
  {{ com Quantifiers }}
  | forall					:: :: forall
  | exists					:: :: exists

qbind :: 'Qb_' ::=
  {{ com Bindings for quantifiers}}
  | x_l							:: :: var		
  | ( pat 'IN' exp )					:: :: restr
    {{ com Restricted quantifications over sets}}
  | ( pat MEM exp )					:: :: list_restr
    {{ com Restricted quantifications over lists }}

fexp :: '' ::=
  {{ com Field-expressions }}
  | id = exp l						:: :: Fexp

fexps :: '' ::=
  {{ com Field-expression lists }}
  | fexp1 ; ... ; fexpn semi_opt l			:: :: Fexps

pexp :: '' ::=
  {{ com Pattern matches }}
  | pat -> exp l					:: :: Patexp

psexp :: '' ::=
  {{ com Multi-pattern matches }}
  | pat1 ... patn -> exp l				:: :: Patsexp

tannot_opt {{ tex \ottnt{tannot}^? }} :: 'Typ_annot_' ::=
  {{ com Optional type annotations }}
  | 							:: :: none
  | : typ						:: :: some 

funcl_aux :: '' ::=
  {{ com Function clauses }}
  | x_l pat1 ... patn tannot_opt = exp			:: :: Funcl

letbind_aux :: '' ::=
  {{ com Let bindings }}
  | pat tannot_opt = exp 				:: :: Let_val
    {{ com Value bindings }}
  | funcl_aux						:: :: Let_fun
    {{ com Function bindings }}

letbind :: '' ::=
  {{ com Location-annotated let bindings }}
  | letbind_aux l					:: :: Letbind

funcl :: '' ::=
  {{ com Location-annotated function clauses }}
  | funcl_aux l						:: :: Rec_l

rule_aux :: '' ::=
  {{ com Inductively defined relation clauses }}
  | forall x_l1 .. x_ln . exp ==> x_l exp1 .. expi	:: :: Rule

rule :: '' ::=
  {{ com Location-annotated inductively defined relation clauses }}
  | rule_aux l						:: :: Rule_l

parsing

P_app right Let_val

P_app <= Fun

Fun right App
Function right App
Case right App
Let right App

Fun <= Field
Function <= Field
App <= Field
Case <= Field
Let <= Field

App left App

grammar

typs :: '' ::=						{{ phantom }}
							{{ ocaml (typ * terminal) list }}
							{{ hol typ list }}
  {{ com Type lists }}
  | typ1 * ... * typn					:: :: Typs
    {{ hol [[typ1...typn]] }}
    {{ ocaml [[typ1...typn]] }}

parsing
Typ_tup <= Typs

grammar

ctor_def :: '' ::=
  {{ com Datatype definition clauses }}
  | x_l of typs						:: :: Cte
  | x_l							:: S :: Cte_s
    {{ com Constant constructors }}
    {{ ocaml (Cte([[x_l]],[])) }}
    {{ hol (Cte [[x_l]] []) }}

texp :: 'Te_' ::=
  {{ com Type definition bodies }}
  | typ							:: :: abbrev
    {{ com Type abbreviations }}
  | <| x_l1 : typ1 ; ... ; x_ln : typn semi_opt |>	:: :: record
    {{ com Record types }}
  | bar_opt ctor_def1 '|' ... '|' ctor_defn		:: :: variant
    {{ com Variant types }}

td :: '' ::=
  {{ com Type definitions }}
  | x_l tyvars = texp			 			:: :: Td
  | x_l	tyvars							:: :: Td_opaque
    {{ com Definitions of opaque types }}

c :: '' ::=
  {{ com Typeclass constraints }}
  | id a_l							:: :: C

cs :: 'Cs_' ::=
  {{ com Typeclass constraint lists }}
  | 								:: :: empty
  | c1 , .. , ci =>							:: :: list
    {{ com Must have $>0$ constraints }}

%KATHYMOD
%Include quantification across kind num 
%c_pre :: 'C_pre_' ::=
%  {{ com Type and instance scheme prefixes }}
%  |								:: :: empty
%  | forall a_l1 .. a_ln . cs					:: :: forall
%    {{ com Must have $>0$ type variables }}
c_pre :: 'C_pre_' ::=
  {{ com Type and instance scheme prefixes }}
  |								:: :: empty
  | forall tyvar1 .. tyvarn . cs					:: :: forall
    {{ com Must have $>0$ type variables }}
%ENDMOD

typschm :: '' ::=
    {{ com Type schemes }}
  | c_pre typ							:: :: Ts

instschm :: '' ::=
    {{ com Instance schemes }}
  | c_pre ( id typ )						:: :: Is

target :: 'Target_' ::=
  {{ com Backend target names }}
  | hol								:: :: hol
  | isabelle							:: :: isa
  | ocaml							:: :: ocaml
  | coq								:: :: coq
  | tex								:: :: tex

targets {{ tex \ensuremath{\tau} }} :: 'Targets_' ::=		{{ hol target list }}
  {{ com Backend target name lists }}
  | { target1 ; .. ; targetn }					:: :: concrete
    {{ hol [[target1..targetn]] }}

targets_opt {{ tex \ensuremath{\tau^?} }} :: 'Targ_' ::= {{ phantom }}
								{{ hol targets option }}
								{{ ocaml targets option }}
   {{ com Optional targets }}
  |								:: :: none
    {{ ocaml None }}
    {{ hol NONE }}
  | targets							:: :: some
    {{ ocaml (Some([[targets]])) }}
    {{ hol (SOME([[targets]])) }}

val_def :: '' ::= 
  {{ com Value definitions }}
  | let targets_opt letbind					:: :: Let_def
    {{ com Non-recursive value definitions }}
  | let rec targets_opt funcl1 and ... and funcln		:: :: Let_rec
    {{ com Recursive function definitions }}
  | let inline targets_opt letbind 				:: :: Let_inline
    {{ com Function definitions to be inlined }}

val_spec :: '' ::=
  {{ com Value type specifications }} 
  | val x_l : typschm						:: :: Val_spec

def_aux :: '' ::=
  {{ com Top-level definitions }}
  | type td1 and ... and tdn					:: :: Type_def
    {{ com Type definitions }}
  | val_def							:: :: Val_def
    {{ com Value definitions }}
  | module x_l = struct defs end				:: :: Module
    {{ com Module definitions }}
  | module x_l = id						:: :: Rename
    {{ com Module renamings }}
  | open id							:: :: Open
    {{ com Opening modules }}
%  | include id							:: :: Include
%    {{ com Including modules }}
  | indreln targets_opt rule1 and ... and rulen			:: :: Indreln
    {{ com Inductively defined relations }}
  | val_spec 							:: :: Spec_def
    {{ com Top-level type constraints }}
  | class ( x_l a_l ) val x_l1 : typ1 l1 ... val x_ln : typn ln end	:: :: Class
    {{ com Typeclass definitions }}
  | instance instschm val_def1 l1 ... val_defn ln end 		:: :: Instance
    {{ com Typeclass instantiations }}

def :: '' ::=
  {{ com Location-annotated definitions }}
  | def_aux l							:: :: Def_l

semisemi_opt {{ tex \ottkw{;;}^? }} :: 'semisemi_' ::=		{{ phantom }}
								{{ ocaml terminal * bool }}
								{{ hol bool }}
  {{ com Optional double-semi-colon }}
  | 	 							:: :: no
    {{ hol F }}
    {{ ocaml false }}
  | ;;								:: :: yes
    {{ hol T }}
    {{ ocaml true }}

defs :: '' ::=
  {{ com Definition sequences }}
  | def1 semisemi_opt1 .. defn semisemi_optn			:: :: Defs


grammar


p :: 'Path_' ::=
  {{ com Unique paths }}
  | x1 . .. xn . x				:: :: def
  | __list					:: :: list	
    {{ tex \ottkw{\_\_list}  }}
  | __bool					:: :: bool
    {{ tex \ottkw{\_\_bool}  }}
  | __num					:: :: num
    {{ tex \ottkw{\_\_num}  }}
  | __set					:: :: set
    {{ tex \ottkw{\_\_set}  }}
  | __string					:: :: string
    {{ tex \ottkw{\_\_string}  }}
  | __unit					:: :: unit
    {{ tex \ottkw{\_\_unit}  }}
%KATHYMOD
  | __bit					:: :: bit
    {{ tex \ottkw{\_\_bit}  }}
%ENDMOD

%KATHYMOD
%Problem with tyvar having locations attached still
%t_subst {{ tex \ensuremath{\sigma} }} :: '' ::=	{{ phantom }}
%						{{ hol (a # t) list }}
%  {{ com Type variable substitutions }}
%  | { a1 |-> t1 .. an |-> tn }			:: :: T_subst
%    {{ ocaml (assert false) }}
%    {{ hol ([[a1 t1 .. an tn]]) }}
t_subst {{ tex \ensuremath{\sigma} }} :: '' ::=	{{ phantom }}
						{{ hol (a # t) list }}
  {{ com Type variable substitutions }}
  | { tyvar1 |-> t1 .. tyvarn |-> tn }			:: :: T_subst
    {{ ocaml (assert false) }}
    {{ hol ([[tyvar1 t1 .. tyvarn tn]]) }}
%ENDMOD

t , u :: 'T_' ::=
  {{ com Internal types }}
  | a						:: :: var
  | t1 -> t2					:: :: fn
  | t1 * .... * tn				:: :: tup
  | p t_args					:: :: app 
%KATHYMOD
  | vector length t				:: :: vector
%ENDMOD
  | t_subst ( t	)				:: M :: subst_app
    {{ com Multiple substitutions }}
    {{ ocaml (assert false) }}
    {{ hol (t_subst_t [[t_subst]] [[t]]) }}
  | curry ( t_multi ,  t )			:: M :: multifn
    {{ com Curried, multiple argument functions }}
    {{ ocaml (assert false) }}
    {{ hol (FOLDR T_fn [[t]] [[t_multi]]) }}

t_args :: '' ::=
  {{ com Lists of types }}
  | t_len1 .. t_lenn 				:: :: T_args
  | t_subst ( t_args )				:: M :: T_args_subst_app
    {{ com Multiple substitutions }}
    {{ ocaml (assert false) }}
    {{ hol (t_subst_t_args [[t_subst]] [[t_args]]) }}

t_len :: 'TL_' ::=
  {{ com Type or length }}
  | t						:: :: t
  | length					:: :: len

t_multi :: '' ::=				{{ phantom }}
						{{ hol t list }}
						{{ ocaml t list }}
  {{ com Lists of types }}
  | ( t1 * .. * tn )				:: :: T_multi
    {{ hol [[t1..tn]] }}
  | t_subst ( t_multi )				:: M :: T_multi_subst_app
    {{ com Multiple substitutions }}
    {{ ocaml (assert false) }}
    {{ hol (MAP (t_subst_t [[t_subst]]) [[t_multi]]) }}

parsing
T_fn right T_fn
T_tup <= T_multi

grammar

%KATHYMOD
tvs :: '' ::=					{{ hol a list }}
						{{ ocaml a list }}
  {{ com Type variable lists }}
% Need a tyvar without location
  | tyvar1 .. tyvarn				:: :: Tvs
    {{ hol [[tyvar1..tyvarn]] }}
    {{ ocaml [[tyvar1..tyvarn]] }}
%ENDMOD

names :: '' ::=					{{ phantom }}
						{{ hol x set }}
						{{ ocaml Set.Make(String).t }}
  {{ com Sets of names }}
  | { x1 , .. , xn }				:: :: Names
    {{ hol (LIST_TO_SET [[x1..xn]]) }}

semC {{ tex \ensuremath{\mathcal{C} } }} :: '' ::=
								{{ hol (p#a) list }}
  {{ com Typeclass constraint lists }}
  | ( p1 a1 ) .. ( pn an )					:: :: SemC_concrete
    {{ hol ([[p1 a1..pn an]]) }}

env_tag :: '' ::=
  {{ com Tags for the (non-constructor) value descriptions }}
  | method							:: :: method
    {{ com Bound to a method }}
  | val								:: :: spec
    {{ com Specified with val }}
  | let								:: :: def
    {{ com Defined with let or indreln }}

v_desc :: 'V_' ::=
  {{ com Value descriptions }}
  | < forall tvs . t_multi -> p , ( x of names ) >		:: :: constr
    {{ com Constructors }}
  | < forall tvs . semC => t , env_tag >			:: :: val
    {{ com Values }}

f_desc :: 'F_' ::=
  | < forall tvs . p -> t , ( x of names ) >			:: :: field
    {{ com Fields }}

embed
{{ hol
load "fmaptreeTheory";
val _ = 
  Hol_datatype 
    `env_body = <| env_p : x|->p; env_f : x|->f_desc; env_v : x|->v_desc |>`;

val _ = Define `
  env_union e1 e2 =
    let i1 = item e1 in
    let m1 = map e1 in
    let i2 = item e2 in
    let m2 = map e2 in
      FTNode <| env_p:=FUNION i1.env_p i2.env_p; 
                env_f:=FUNION i1.env_f i2.env_f;
                env_v:=FUNION i1.env_v i2.env_v |>
             (FUNION m1 m2)`;
}}

grammar


S {{ tex \ensuremath{\Sigma} }} :: '' ::=			{{ phantom }}
								{{ hol (p#t) list }}
  {{ com Typeclass constraints }}
  | { ( p1 t1 ) , .. , ( pn tn ) }				:: :: S_concrete
    {{ hol [[p1 t1 .. pn tn]] }}
  | S1 union .. union Sn					:: M :: S_union
    {{ hol (FLAT [[S1..Sn]]) }}
    {{ ocaml assert false }}

E :: '' ::=							{{ phantom }}
								{{ hol ((string,env_body) fmaptree) }}
  {{ com Environments }}
  | < E_m , E_p , E_f , E_x >						:: :: E
    {{ hol (FTNode <|env_p:=[[E_p]]; env_f:=[[E_f]]; env_v:=[[E_x]]|> ([[E_m]])) }}
  | E1 u+ E2							:: M :: E_union
    {{ hol (env_union [[E1]] [[E2]]) }}
    {{ ocaml assert false }}
  | empty							:: M :: E_empty
    {{ hol (FTNode <|env_p:=FEMPTY; env_f:=FEMPTY; env_v:=FEMPTY|> FEMPTY) }}
    {{ ocaml assert false }}

E_x {{ tex \ottnt{E}^{\textsc{x} } }} :: 'E_x_' ::=		{{ phantom }}
								{{ hol (x|-> v_desc) }}
  {{ com Value environments }}
  | { x1 |-> v_desc1 , .. , xn |-> v_descn }	:: :: concrete
    {{ hol (FOLDR (\(k1,k2) E. E |+ (k1,k2)) FEMPTY [[x1 v_desc1 .. xn v_descn]]) }}
  | E_x1 u+ .. u+ E_xn						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_x1..E_xn]]) }}
    {{ ocaml (assert false) }}

E_f {{ tex \ottnt{E}^{\textsc{f} } }} :: 'E_f_' ::=		{{ phantom }}
								{{ hol (x |-> f_desc) }}
  {{ com Field environments }}
  | { x1 |-> f_desc1 , .. , xn |-> f_descn }			:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 f_desc1 .. xn f_descn]]) }}
  | E_f1 u+ .. u+ E_fn						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_f1..E_fn]]) }}
    {{ ocaml (assert false) }}

E_m {{ tex \ottnt{E}^{\textsc{m} } }} :: 'E_m_' ::=		{{ phantom }}
								{{ hol (string |-> (string,env_body) fmaptree) }}
  {{ com Module environments }}
  | { x1 |-> E1 , .. , xn |-> En }				:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 E1 .. xn En]]) }}

E_p {{ tex \ottnt{E}^{\textsc{p} } }} :: 'E_p_' ::=		{{ phantom }}
								{{ hol (x |-> p) }}
  {{ com Path environments }}
  | { x1 |-> p1 , .. , xn |-> pn }				:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 p1 .. xn pn]]) }}
  | E_p1 u+ .. u+ E_pn						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_p1..E_pn]]) }}
    {{ ocaml (assert false) }}

E_l {{ tex \ottnt{E}^{\textsc{l} } }} :: 'E_l_' ::=		{{ phantom }}
								{{ hol (x |-> t) }}
  {{ com Lexical bindings }}
  | { x1 |-> t1 , .. , xn |-> tn }				:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[x1 t1 .. xn tn]]) }}
  | E_l1 u+ .. u+ E_ln						:: M :: union
    {{ hol (FOLDR FUNION FEMPTY [[E_l1..E_ln]]) }}
    {{ ocaml (assert false) }}

tc_abbrev :: 'Tc_abbrev_' ::=					{{ phantom }}
								{{ hol t option }}
								{{ ocaml t option }}
  {{ com Type abbreviations }}
  | . t								:: :: some
    {{ hol (SOME [[t]]) }}
  | 								:: :: none
    {{ hol NONE }}

tc_def :: '' ::=
  {{ com Type and class constructor definitions }} 
  | tvs tc_abbrev						:: :: Tc_def
    {{ com Type constructors }}

TD {{ tex \ensuremath{\Delta} }} :: 'TD_' ::=			{{ phantom }}
								{{ hol p |-> tc_def }}
  {{ com Type constructor definitions }}
  | { p1 |-> tc_def1 , .. , pn |-> tc_defn }			:: :: concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[p1 tc_def1 .. pn tc_defn]]) }}
    {{ ocaml (assert false) }}
  | TD1 u+ TD2							:: M :: union
    {{ hol (FUNION [[TD1]] [[TD2]]) }}
    {{ ocaml (assert false) }}

TC {{ tex \ensuremath{\delta} }} :: '' ::=			{{ phantom }}
								{{ hol p |-> x list }}
  {{ com Typeclass  definitions }}
  | { p1 |-> xs1 , .. , pn |-> xsn }				:: :: TC_concrete
    {{ hol (FOLDR (\x E. E |+ x) FEMPTY [[p1 xs1 .. pn xsn]]) }}
    {{ ocaml (assert false) }}
  | TC1 u+ TC2							:: M :: TC_union
    {{ hol (FUNION [[TC1]] [[TC2]]) }}
    {{ ocaml (assert false) }}


inst :: '' ::=
  {{ com A typeclass instance, t must not contain nested types }}
  | semC => ( p t )						:: :: Inst

I :: '' ::=							{{ phantom }}
								{{ hol inst list }}
  {{ com Global instances }}
  | { inst1 , .. , instn }					:: :: I_concrete
    {{ hol [[inst1 .. instn]] }}
  | I1 union I2							:: M :: I_union
    {{ hol ([[I1]] ++ [[I2]]) }}
    {{ ocaml assert false }}
 

D :: 'D_' ::=							{{ phantom }}
								{{ hol ((p |-> tc_def) # (p |-> x list) # (inst list)) }}
  {{ com Global type definition store }}
  | < TD , TC , I >							:: :: concrete
    {{ hol ([[TD]], [[TC]], [[I]]) }}
  | D1 u+ D2							:: M :: union
    {{ hol (case ([[D1]],[[D2]]) of ((x1,x2,x3),(y1,y2,y3)) => (FUNION x1 y1, FUNION x2 y2, x3 ++ y3)) }}
    {{ ocaml (assert false) }}
  | empty							:: M :: empty
    {{ hol (FEMPTY, FEMPTY, []) }}
    {{ ocaml assert false }}

parsing
E_union left E_union


grammar

xs :: '' ::=					{{ phantom }}
						{{ hol string list }}
  | x1 .. xn					:: :: Xs
    {{ hol [[x1..xn]] }}


terminals :: '' ::=
  | >=					:: :: geq
    {{ tex \ensuremath{\geq} }}
    {{ com \texttt{>=} }}
  | ->					:: :: arrow
    {{ tex \ensuremath{\rightarrow} }}
    {{ com \texttt{->} }}
  | ==> 				:: :: Longrightarrow
    {{ tex \ensuremath{\Longrightarrow} }}
    {{ com \texttt{==>} }}
  | <|					:: :: startrec
    {{ tex \ensuremath{\langle|} }}
    {{ com \texttt{<|} }}
  | |>					:: :: endrec
    {{ tex \ensuremath{|\rangle} }}
    {{ com \texttt{|>} }}
  | inter				:: :: inter
    {{ tex \ensuremath{\cap} }}
  | union				:: :: union
    {{ tex \ensuremath{\cup} }}
  | u+					:: :: uplus
    {{ tex \ensuremath{\uplus} }}
  | NOTIN 				:: :: notin
    {{ tex \ensuremath{\not\in} }}
  | SUBSET				:: :: subset
    {{ tex \ensuremath{\subset} }}
  | NOTEQ				:: :: noteq
    {{ tex \ensuremath{\not=} }}
  | emptyset				:: :: emptyset
    {{ tex \ensuremath{\emptyset} }}
  | < 					:: :: lt
    {{ tex \ensuremath{\langle} }}
  | > 					:: :: gt
    {{ tex \ensuremath{\rangle} }}
  | |-					:: :: vdash
    {{ tex \ensuremath{\vdash} }}
  | '					:: :: quote
    {{ tex \mbox{'} }}
  | |-> 				:: :: mapsto
    {{ tex \ensuremath{\mapsto} }}
  | gives				:: :: gives
    {{ tex \ensuremath{\triangleright} }}
  | ~>					:: :: leadsto
    {{ tex \ensuremath{\leadsto} }}
  | => 					:: :: Rightarrow
    {{ tex \ensuremath{\Rightarrow} }}
  | --					:: :: dashdash
    {{ tex \mbox{--} }}
  | empty				:: :: empty
    {{ tex \ensuremath{\epsilon} }}
 

formula :: formula_ ::=
  | judgement							:: :: judgement

  | formula1 .. formulan					:: :: dots

  | E_m ( x ) gives E						:: :: lookup_m
    {{ com Module lookup }}
    {{ hol (FLOOKUP [[E_m]] [[x]] = SOME [[E]]) }}

  | E_p ( x ) gives p						:: :: lookup_p
    {{ com Path lookup }}
    {{ hol (FLOOKUP [[E_p]] [[x]] = SOME [[p]]) }}

  | E_f ( x ) gives f_desc					:: :: lookup_f
    {{ com Field lookup }}
    {{ hol (FLOOKUP [[E_f]] [[x]] = SOME [[f_desc]]) }}

  | E_x ( x ) gives v_desc					:: :: lookup_v
    {{ com Value lookup }}
    {{ hol (FLOOKUP [[E_x]] [[x]] = SOME [[v_desc]]) }}

  | E_l ( x ) gives t						:: :: lookup_l
    {{ com Lexical binding lookup }}
    {{ hol (FLOOKUP [[E_l]] [[x]] = SOME [[t]]) }}

  | TD ( p ) gives tc_def					:: :: lookup_tc
    {{ com Type constructor lookup }}
    {{ hol (FLOOKUP [[TD]] [[p]] = SOME [[tc_def]]) }}

  | TC ( p ) gives xs						:: :: lookup_class
    {{ com Type constructor lookup }}
    {{ hol (FLOOKUP [[TC]] [[p]] = SOME [[xs]]) }}

  | dom ( E_m1 ) inter dom ( E_m2 ) = emptyset			:: :: E_m_disjoint
    {{ hol (DISJOINT (FDOM [[E_m1]]) (FDOM [[E_m2]])) }}

  | dom ( E_x1 ) inter dom ( E_x2 ) = emptyset			:: :: E_x_disjoint
    {{ hol (DISJOINT (FDOM [[E_x1]]) (FDOM [[E_x2]])) }}

  | dom ( E_p1 ) inter dom ( E_p2 ) = emptyset			:: :: E_p_disjoint
    {{ hol (DISJOINT (FDOM [[E_p1]]) (FDOM [[E_p2]])) }}

  | disjoint doms ( E_l1 , .... , E_ln )			:: :: E_l_disjoint
    {{ hol (FOLDR (\E b. case b of NONE => NONE | SOME s => if DISJOINT (FDOM
E) s then SOME (FDOM E UNION s) else NONE) (SOME {}) [[E_l1....E_ln]] <> NONE) }}
    {{ com Pairwise disjoint domains }}

  | disjoint doms ( E_x1 , .... , E_xn )			:: :: E_x_disjoint_many
    {{ hol (FOLDR (\E b. case b of NONE => NONE | SOME s => if DISJOINT (FDOM
E) s then SOME (FDOM E UNION s) else NONE) (SOME {}) [[E_x1....E_xn]] <> NONE) }}
    {{ com Pairwise disjoint domains }}

  | compatible overlap ( x1 |-> t1 , .. , xn |-> tn )		:: :: E_l_compat
    {{ hol (!__n __m. MEM __m [[x1 t1 .. xn tn]] /\ MEM __n [[x1 t1..xn tn]] /\ (FST __m  = FST __n) ==> (SND __m = SND __n)) }}
    {{ com $(\ottnt{x}_i = \ottnt{x}_j) \ensuremath{\Longrightarrow} (\ottnt{t}_i = \ottnt{t}_j)$ }}

  | duplicates ( tvs ) = emptyset				:: :: no_dups_tvs
    {{ hol (ALL_DISTINCT [[tvs]]) }}

  | duplicates ( x1 , .. , xn )	= emptyset			:: :: no_dups
    {{ hol (ALL_DISTINCT [[x1..xn]]) }}

  | x NOTIN dom ( E_l )						:: :: notin_dom_l
    {{ hol ([[x]] NOTIN FDOM [[E_l]]) }}

  | x NOTIN dom ( E_x )						:: :: notin_dom_v
    {{ hol ([[x]] NOTIN FDOM [[E_x]]) }}

  | x NOTIN dom ( E_f )						:: :: notin_dom_f
    {{ hol ([[x]] NOTIN FDOM [[E_f]]) }}

  | p NOTIN dom ( TC )						:: :: notin_dom_tc
    {{ hol ([[p]] NOTIN FDOM [[TC]]) }}

  | p NOTIN dom ( TD )						:: :: notin_dom_td
    {{ hol ([[p]] NOTIN FDOM [[TD]]) }}

  | FV ( t ) SUBSET tvs						:: :: FV_t
    {{ com Free type variables }}
    {{ hol (LIST_TO_SET (ftv_t [[t]]) SUBSET LIST_TO_SET [[tvs]]) }}

  | FV ( t_multi ) SUBSET tvs					:: :: FV_t_multi
    {{ com Free type variables }}
    {{ hol (LIST_TO_SET (FLAT (MAP ftv_t [[t_multi]])) SUBSET LIST_TO_SET [[tvs]]) }}

  | FV ( semC ) SUBSET tvs					:: :: FV_semC
    {{ com Free type variables }}
    {{ hol (LIST_TO_SET (MAP SND [[semC]]) SUBSET LIST_TO_SET [[tvs]]) }}

  | inst 'IN' I							:: :: inst_in
    {{ hol (MEM [[inst]] [[I]]) }}

  | ( p t ) NOTIN I						:: :: notin_I
    {{ hol (~?__semC__. MEM (Inst __semC__ [[p]] [[t]]) [[I]]) }}

  | E_l1 = E_l2							:: :: E_l_eqn
    {{ hol ([[E_l1]] = [[E_l2]]) }}

  | E_x1 = E_x2							:: :: E_x_eqn
    {{ hol ([[E_x1]] = [[E_x2]]) }}

  | E_f1 = E_f2							:: :: E_f_eqn
    {{ hol ([[E_f1]] = [[E_f2]]) }}

  | E1 = E2							:: :: E_eqn
    {{ hol ([[E1]] = [[E2]]) }}

  | TD1 = TD2							:: :: TD_eqn
    {{ hol ([[TD1]] = [[TD2]]) }}

  | TC1 = TC2							:: :: TC_eqn
    {{ hol ([[TC1]] = [[TC2]]) }}

  | I1 = I2							:: :: I_eqn
    {{ hol ([[I1]] = [[I2]]) }}

  | names1 = names2						:: :: names_eq
    {{ hol ([[names1]] = [[names2]]) }}

  | t1 = t2							:: :: t_eq
    {{ hol ([[t1]] = [[t2]]) }}

  | t_subst1 = t_subst2						:: :: t_subst_eq
    {{ hol ([[t_subst1]] = [[t_subst2]]) }}

  | p1 = p2							:: :: p_eq
    {{ hol ([[p1]] = [[p2]]) }}

  | xs1 = xs2							:: :: xs_eq
    {{ hol ([[xs1]] = [[xs2]]) }}

  | tvs1 = tvs2							:: :: tvs_eq
    {{ hol ([[tvs1]] = [[tvs2]]) }}

% Substitutions and freevars are not correctly generated for the OCaml ast.ml
%substitutions
%multiple t a :: t_subst
%
%freevars
%t a :: ftv

defns
convert_tvs :: '' ::=

defn
tyvars ~> tvs :: :: convert_tvs :: convert_tvs_
by

%KATHYMOD
%shoud strip locations

------------------------------------------------------------ :: none
tyvar1 .. tyvarn  ~> tyvar1 .. tyvarn
%ENDMOD

defns
look_m :: '' ::=

defn
E1 ( x_l1 .. x_ln ) gives E2 :: :: look_m :: look_m_ 
{{ com Name path lookup }}
by

------------------------------------------------------------ :: none
E() gives E

E_m(x) gives E1
E1(</y_li//i/>) gives E2
------------------------------------------------------------ :: some
<E_m,E_p,E_f,E_x>(x l </y_li//i/>) gives E2

defns
look_m_id :: '' ::=
 
defn
E1 ( id ) gives E2 :: :: look_m_id :: look_m_id_ 
{{ com Module identifier lookup }}
by

E1(</y_li//i/> x l1) gives E2
------------------------------------------------------------ :: all
E1(</y_li.//i/> x l1 l2) gives E2

defns
look_tc :: '' ::=

defn
E ( id ) gives p :: :: look_tc :: look_tc_ 
{{ com Path identifier lookup }}
by

E(</y_li//i/>) gives <E_m,E_p,E_f,E_x>
E_p(x) gives p
------------------------------------------------------------ :: all
E(</y_li.//i/> x l1 l2) gives p


%KATHYMOD
defns
check_t :: '' ::=

defn
TD |- t ok :: :: check_t :: check_t_ 
{{ com Well-formed types }}
by


------------------------------------------------------------ :: var
TD |- a ok

TD |- t1 ok
TD |- t2 ok
------------------------------------------------------------ :: fn
TD |- t1 -> t2 ok

TD |- t1 ok .... TD |- tn ok
------------------------------------------------------------ :: tup
TD |- t1 * .... * tn ok

TD(p) gives tyvar1..tyvarn tc_abbrev
TD,tyvar1 |- t_len1 ok .. TD,tyvarn |- t_lenn ok
------------------------------------------------------------ :: app
TD |- p t_len1 .. t_lenn ok

TD |- t ok
------------------------------------------------------------ :: vector
TD |- vector length t ok

defn
TD , tyvar |- t_len ok :: :: check_tlen :: check_tlen_ 
{{ com Well-formed type/lengths }}
by

TD |- t ok
------------------------------------------------------------ :: t
TD,a |- t ok

------------------------------------------------------------ :: len
TD,nty |- length ok

%ENDMOD

%TODO type equality isn't right; neither is type conversion

defns
teq :: '' ::=

defn
TD |- t1 = t2 :: :: teq :: teq_ 
{{ com Type equality }}
by

TD |- t ok
------------------------------------------------------------ :: refl
TD |- t = t

TD |- t2 = t1
------------------------------------------------------------ :: sym
TD |- t1 = t2

TD |- t1 = t2
TD |- t2 = t3
------------------------------------------------------------ :: trans
TD |- t1 = t3

TD |- t1 = t3
TD |- t2 = t4
------------------------------------------------------------ :: arrow
TD |- t1 -> t2 = t3 -> t4

TD |- t1 = u1 .... TD |- tn = un
------------------------------------------------------------ :: tup
TD |- t1*....*tn = u1*....*un

TD |- t1 = u1 .. TD |- tn = un
------------------------------------------------------------ :: app
TD |- p  t1 .. tn = p u1 .. un

TD(p) gives a1..an . u 
------------------------------------------------------------ :: expand
TD |- p t1 .. tn = {a1|->t1..an|->tn}(u)


defns
convert_typ :: '' ::=

defn
TD , E |- typ ~> t :: :: convert_typ :: convert_typ_ 
{{ com Convert source types to internal types }}
by

% TODO : Can't allow things like type t = _, but it's useful to have things 
% like f (x : (_, int)) = snd x
%TD |- t ok
%------------------------------------------------------------ :: wild
%TD,E |- _ l ~> t

------------------------------------------------------------ :: var
TD,E |- a l' l ~> a

TD,E |- typ1 ~> t1
TD,E |- typ2 ~> t2
------------------------------------------------------------ :: fn
TD,E |- typ1->typ2 l ~> t1->t2

TD,E |- typ1 ~> t1 .... TD,E |- typn ~> tn
------------------------------------------------------------ :: tup
TD,E |- typ1 * .... * typn l ~> t1 * .... * tn

TD,E |- typ1 ~> t1 .. TD,E |- typn ~> tn
E(id) gives p
TD(p) gives a1..an tc_abbrev
------------------------------------------------------------ :: app
TD,E |- id typ1 .. typn l ~> p t1 .. tn

TD,E |- typ ~> t
------------------------------------------------------------ :: paren
TD,E |- (typ) l ~> t


TD,E |- typ ~> t1
TD |- t1 = t2
------------------------------------------------------------ :: eq
TD,E |- typ ~> t2

defns
convert_typs :: '' ::=

defn
TD , E |- typs ~> t_multi :: :: convert_typs :: convert_typs_ by

TD,E |- typ1 ~> t1 .. TD,E |- typn ~> tn
------------------------------------------------------------ :: all
TD,E |- typ1 * .. * typn ~> (t1 * .. * tn)

defns
check_lit :: '' ::=

defn
|- lit : t :: :: check_lit :: check_lit_ 
{{ com Typing literal constants }}
by

------------------------------------------------------------ :: true
|- true l : __bool

------------------------------------------------------------ :: false
|- false l : __bool

------------------------------------------------------------ :: num
|- num l : __num

%KATHYMOD
%TODO: hex -> num for length, oct and bin too

------------------------------------------------------------ :: hex
|- hex l : vector num __bit

------------------------------------------------------------ :: oct 
|- oct l : vector num __bit

------------------------------------------------------------ :: bin 
|- bin l : vector num __bit
%ENDMOD

------------------------------------------------------------ :: string
|- string l : __string

------------------------------------------------------------ :: unit
|- () l : __unit

%KATHYMOD
------------------------------------------------------------ :: bitzero
|- bitzero l : __bit

------------------------------------------------------------ :: bitone
|- bitone l : __bit
%ENDMOD


defns
inst_field :: '' ::=

defn
TD , E |- field id : p t_args -> t gives ( x of names ) :: :: inst_field :: inst_field_
{{ com Field typing (also returns canonical field names) }} 
by

E(</x_li//i/>) gives <E_m,E_p,E_f,E_x>
E_f(y) gives <forall a1..an. p -> t, (z of names)>
TD |- t1 ok .. TD |- tn ok
------------------------------------------------------------ :: all
TD,E |- field </x_li.//i/> y l1 l2: p t1 .. tn -> {a1|->t1..an|->tn}(t) gives (z of names)


defns
inst_ctor :: '' ::=

defn
TD , E |- ctor id : t_multi -> p t_args gives ( x of names ) :: :: inst_ctor :: inst_ctor_ 
{{ com Data constructor typing (also returns canonical constructor names) }} 
by

E(</x_li//i/>) gives <E_m,E_p,E_f,E_x>
E_x(y) gives <forall a1..an. t_multi -> p, (z of names)>
TD |- t1 ok .. TD |- tn ok
------------------------------------------------------------ :: all
TD,E |- ctor </x_li.//i/> y l1 l2 : {a1|->t1..an|->tn}(t_multi) -> p t1 .. tn gives (z of names)

defns
inst_val :: '' ::=

defn
TD , E |- val id : t gives S :: :: inst_val :: inst_val_
{{ com Typing top-level bindings, collecting typeclass constraints }}
by

%TODO: Should a val tag be allowed here?

E(</x_li//i/>) gives <E_m,E_p,E_f,E_x>
E_x(y) gives <forall a1..an. (p1 a'1) .. (pi a'i) => t,env_tag>
TD |- t1 ok .. TD |- tn ok
t_subst = {a1|->t1..an|->tn}
------------------------------------------------------------ :: all
TD, E |- val </x_li.//i/> y l1 l2 : t_subst(t) gives {(p1 t_subst(a'1)), .., (pi t_subst(a'i))}

defns
not_ctor :: '' ::=

defn
E , E_l |- x not ctor :: :: not_ctor :: not_ctor_ 
{{ com $\ottnt{v}$ is not bound to a data constructor }}
by

E_l(x) gives t
------------------------------------------------------------ :: val
E,E_l |- x not ctor

x NOTIN dom(E_x)
------------------------------------------------------------ :: unbound
<E_m,E_p,E_f,E_x>,E_l |- x not ctor

E_x(x) gives <forall a1..an. (p1 a'1)..(pi a'i) => t,env_tag>
------------------------------------------------------------ :: bound
<E_m,E_p,E_f,E_x>,E_l |- x not ctor

defns
not_shadowed :: '' ::=

defn
E_l |- id not shadowed :: :: not_shadowed :: not_shadowed_ 
{{ com $\ottnt{id}$ is not lexically shadowed }}
by

x NOTIN dom(E_l)
------------------------------------------------------------ :: sing
E_l |- x l1 l2 not shadowed

------------------------------------------------------------ :: multi
E_l |- x_l1. .. x_ln.y_l.z_l l not shadowed


defns
check_pat :: '' ::=

defn
TD , E , E_l1 |- pat : t gives E_l2 :: :: check_pat :: check_pat_ 
{{ com Typing patterns, building their binding environment }}
by

:check_pat_aux: TD,E,E_l1 |- pat_aux : t gives E_l2
------------------------------------------------------------ :: all
TD,E,E_l1 |- pat_aux l : t gives E_l2

defn
TD , E , E_l1 |- pat_aux : t gives E_l2 :: :: check_pat_aux :: check_pat_aux_ 
{{ com Typing patterns, building their binding environment }}
by

TD |- t ok
------------------------------------------------------------ :: wild
TD,E,E_l |- _ : t gives {}

TD,E,E_l1 |- pat : t gives E_l2
x NOTIN dom(E_l2)
------------------------------------------------------------ :: as
TD,E,E_l1 |- (pat as x l) : t gives E_l2 u+ {x|->t}

TD,E,E_l1 |- pat : t gives E_l2
TD,E |- typ ~> t
------------------------------------------------------------ :: typ
TD,E,E_l1 |- (pat : typ) : t gives E_l2

TD,E |- ctor id : (t1*..*tn) -> p t_args gives (x of names)
E_l |- id not shadowed
TD,E,E_l |- pat1 : t1 gives E_l1 .. TD,E,E_l |- patn : tn gives E_ln
disjoint doms(E_l1,..,E_ln)
------------------------------------------------------------ :: ident_constr
TD,E,E_l |- id pat1 .. patn : p t_args gives E_l1 u+ .. u+ E_ln

TD |- t ok
E,E_l |- x not ctor
------------------------------------------------------------ :: var
TD,E,E_l |- x l1 l2 : t gives {x|->t}

</TD,E |- field idi : p t_args -> ti gives (xi of names) // i />
</TD,E,E_l |- pati : ti gives E_li//i/>
disjoint doms(</E_li//i/>)
duplicates(</xi//i/>) = emptyset
------------------------------------------------------------ :: record
TD,E,E_l |- <| </idi = pati li//i/> semi_opt |> : p t_args gives u+ </E_li//i/>

TD,E,E_l |- pat1 : t1 gives E_l1 .... TD,E,E_l |- patn : tn gives E_ln
disjoint doms(E_l1,....,E_ln)
------------------------------------------------------------ :: tup
TD,E,E_l |- (pat1, ...., patn) : t1 * .... * tn gives E_l1 u+ .... u+ E_ln 

TD |- t ok
TD,E,E_l |- pat1 : t gives E_l1 .. TD,E,E_l |- patn : t gives E_ln
disjoint doms(E_l1,..,E_ln)
------------------------------------------------------------ :: list
TD,E,E_l |- [pat1; ..; patn semi_opt] : __list t gives E_l1 u+ .. u+ E_ln 

TD,E,E_l1 |- pat : t gives E_l2
------------------------------------------------------------ :: paren
TD,E,E_l1 |- (pat) : t gives E_l2

TD,E,E_l1 |- pat1 : t gives E_l2
TD,E,E_l1 |- pat2 : __list t gives E_l3
disjoint doms(E_l2,E_l3)
------------------------------------------------------------ :: cons
TD,E,E_l1 |- pat1 :: pat2 : __list t gives E_l2 u+ E_l3

|- lit : t
------------------------------------------------------------ :: lit
TD,E,E_l |- lit : t gives {}

defns
id_field :: '' ::=

defn
E |- id field :: :: id_field :: id_field_
{{ com Check that the identifier is a permissible field identifier }}
by

E_f(x) gives f_desc
------------------------------------------------------------ :: empty
<E_m,E_p,E_f,E_x> |- x l1 l2 field


E_m(x) gives E
x NOTIN dom(E_f)
E |- </y_li.//i/> z_l l2 field
------------------------------------------------------------ :: cons
<E_m,E_p,E_f,E_x> |- x l1.</y_li.//i/> z_l l2 field

defns
id_value :: '' ::=

defn
E |- id value :: :: id_value :: id_value_
{{ com Check that the identifier is a permissible value identifier }}
by

E_x(x) gives v_desc
------------------------------------------------------------ :: empty
<E_m,E_p,E_f,E_x> |- x l1 l2 value


E_m(x) gives E
x NOTIN dom(E_x)
E |- </y_li.//i/> z_l l2 value
------------------------------------------------------------ :: cons
<E_m,E_p,E_f,E_x> |- x l1.</y_li.//i/> z_l l2 value

defns
check_exp :: '' ::=

defn
TD , E , E_l |- exp : t gives S :: :: check_exp :: check_exp_ 
{{ com Typing expressions, collecting typeclass constraints }}
by

:check_exp_aux: TD,E,E_l |- exp_aux : t gives S
------------------------------------------------------------ :: all
TD,E,E_l  |- exp_aux l : t gives S

defn
TD , E , E_l |- exp_aux : t gives S :: :: check_exp_aux :: check_exp_aux_
{{ com Typing expressions, collecting typeclass constraints }}
by

E_l(x) gives t
------------------------------------------------------------ :: var
TD,E,E_l |- x l1 l2 : t gives {}

E_l |- id not shadowed
E |- id value
TD,E |- ctor id : t_multi -> p t_args gives (x of names)
------------------------------------------------------------ :: ctor
TD,E,E_l |- id : curry(t_multi, p t_args) gives {}

E_l |- id not shadowed
E |- id value
TD, E |- val id : t gives S
------------------------------------------------------------ :: val
TD,E,E_l |- id : t gives S 


TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
TD,E,E_l u+ E_l1 u+ ... u+ E_ln |- exp : u gives S
disjoint doms(E_l1,...,E_ln)
------------------------------------------------------------ :: fn
TD,E,E_l |- fun pat1 ... patn -> exp l : curry((t1*...*tn), u) gives S

</TD,E,E_l |- pati : t gives E_li//i/>
</TD,E,E_l u+ E_li |- expi : u gives Si//i/>
------------------------------------------------------------ :: function
TD,E,E_l |- function bar_opt </pati -> expi li//i/> end : t -> u gives </Si//i/> 

TD,E,E_l |- exp1 : t1 -> t2 gives S1
TD,E,E_l |- exp2 : t1 gives S2
------------------------------------------------------------ :: app
TD,E,E_l |- exp1 exp2 : t2 gives S1 union S2

:check_exp_aux: TD,E,E_l |- (ix) : t1 -> t2 -> t3 gives S1
TD,E,E_l |- exp1 : t1 gives S2
TD,E,E_l |- exp2 : t2 gives S3
------------------------------------------------------------ :: infix_app1
TD,E,E_l |- exp1 ix l exp2 : t3 gives S1 union S2 union S3

:check_exp_aux: TD,E,E_l |- x : t1 -> t2 -> t3 gives S1
TD,E,E_l |- exp1 : t1 gives S2
TD,E,E_l |- exp2 : t2 gives S3
------------------------------------------------------------ :: infix_app2
TD,E,E_l |- exp1 `x` l exp2 : t3 gives S1 union S2 union S3

</TD,E |- field idi : p t_args -> ti gives (xi of names)//i/>
</TD,E,E_l |- expi : ti gives Si//i/>
duplicates(</xi//i/>) = emptyset
names = {</xi//i/>}
------------------------------------------------------------ :: record
TD,E,E_l |- <| </idi = expi li//i/> semi_opt l |> : p t_args gives </Si//i/>

</TD,E |- field idi : p t_args -> ti gives (xi of names)//i/>
</TD,E,E_l |- expi : ti gives Si//i/>
duplicates(</xi//i/>) = emptyset
TD,E,E_l |- exp : p t_args gives S'
------------------------------------------------------------ :: recup
TD,E,E_l |- <| exp with </idi = expi li//i/> semi_opt l |> : p t_args gives S' union </Si//i/>

E |- id field
TD,E |- field id : p t_args -> t gives (x of names)
TD,E,E_l |- exp : p t_args gives S
------------------------------------------------------------ :: field
TD,E,E_l |- exp.id : t gives S

</TD,E,E_l |- pati : t gives E_li//i/>
</TD,E,E_l u+ E_li |- expi : u gives Si//i/>
TD,E,E_l |- exp : t gives S'
------------------------------------------------------------ :: case
TD,E,E_l |- match exp with bar_opt </pati -> expi li//i/> l end : u gives S' union </Si//i/>

TD,E,E_l |- exp : t gives S
TD,E |- typ ~> t
------------------------------------------------------------ :: typed
TD,E,E_l |- (exp : typ) : t gives S

TD,E,E_l1 |- letbind gives E_l2, S1
TD,E,E_l1 u+ E_l2 |- exp : t gives S2
------------------------------------------------------------ :: let
TD,E,E_l |- let letbind in exp : t gives S1 union S2

TD,E,E_l |- exp1 : t1 gives S1 .... TD,E,E_l |- expn : tn gives Sn
------------------------------------------------------------ :: tup
TD,E,E_l |- (exp1, ...., expn) : t1 * .... * tn gives S1 union .... union Sn

TD |- t ok
TD,E,E_l |- exp1 : t gives S1 .. TD,E,E_l |- expn : t gives Sn
------------------------------------------------------------ :: list
TD,E,E_l |- [exp1; ..; expn semi_opt] : __list t gives S1 union .. union Sn

TD,E,E_l |- exp : t gives S
------------------------------------------------------------ :: paren
TD,E,E_l |- (exp) : t gives S

TD,E,E_l |- exp : t gives S
------------------------------------------------------------ :: begin
TD,E,E_l |- begin exp end : t gives S

TD,E,E_l |- exp1 : __bool gives S1
TD,E,E_l |- exp2 : t gives S2
TD,E,E_l |- exp3 : t gives S3
------------------------------------------------------------ :: if
TD,E,E_l |- if exp1 then exp2 else exp3 : t gives S1 union S2 union S3

TD,E,E_l |- exp1 : t gives S1
TD,E,E_l |- exp2 : __list t gives S2
------------------------------------------------------------ :: cons
TD,E,E_l |- exp1 :: exp2 : __list t gives S1 union S2

|- lit : t
------------------------------------------------------------ :: lit
TD,E,E_l |- lit : t gives {}

% TODO: should require that each xi actually appears free in exp1
</TD |- ti ok//i/>
TD,E,E_l u+ {</xi|->ti//i/>} |- exp1 : t gives S1
TD,E,E_l u+ {</xi|->ti//i/>} |- exp2 : __bool gives S2
disjoint doms(E_l, {</xi|->ti//i/>})
E = <E_m,E_p,E_f,E_x>
</xi NOTIN dom(E_x)//i/>
------------------------------------------------------------ :: set_comp
TD,E,E_l |- { exp1 | exp2 } : __set t gives S1 union S2

TD,E,E_l1 |- </qbindi//i/> gives E_l2,S1
TD,E,E_l1 u+ E_l2 |- exp1 : t gives S2
TD,E,E_l1 u+ E_l2 |- exp2 :  __bool gives S3
------------------------------------------------------------ :: set_comp_binding
TD,E,E_l1 |- { exp1 | forall </qbindi//i/> | exp2 } : __set t gives S1 union S2 union S3

TD |- t ok
TD,E,E_l |- exp1 : t gives S1 .. TD,E,E_l |- expn : t gives Sn
------------------------------------------------------------ :: set
TD,E,E_l |- { exp1; ..; expn semi_opt } : __set t gives S1 union .. union Sn

TD,E,E_l1 |- </qbindi//i/> gives E_l2,S1
TD,E,E_l1 u+ E_l2 |- exp : __bool gives S2
------------------------------------------------------------ :: quant
TD,E,E_l1 |- q </qbindi//i/> . exp : __bool gives S1 union S2

TD,E,E_l1 |- list </qbindi//i/> gives E_l2,S1
TD,E,E_l1 u+ E_l2 |- exp1 : t gives S2
TD,E,E_l1 u+ E_l2 |- exp2 : __bool gives S3
------------------------------------------------------------ :: list_comp_binding
TD,E,E_l1 |- [ exp1 | forall </qbindi//i/> | exp2 ] : __list t gives S1 union S2 union S3

defn
TD , E , E_l1 |- qbind1 .. qbindn gives E_l2 , S :: :: check_listquant_binding
:: check_listquant_binding_
{{ com Build the environment for quantifier bindings, collecting typeclass constraints }}
 by

------------------------------------------------------------ :: empty
TD,E,E_l |- gives {},{}

TD |- t ok
TD,E,E_l1 u+ {x |-> t} |- </qbindi//i/> gives E_l2,S1
disjoint doms({x |-> t}, E_l2)
------------------------------------------------------------ :: var
TD,E,E_l1 |- x l </qbindi//i/> gives {x |-> t} u+ E_l2,S1

TD,E,E_l1 |- pat : t gives E_l3
TD,E,E_l1 |- exp : __set t gives S1
TD,E,E_l1 u+ E_l3 |- </qbindi//i/> gives E_l2,S2
disjoint doms(E_l3, E_l2)
------------------------------------------------------------ :: restr
TD,E,E_l1 |- (pat IN exp) </qbindi//i/> gives E_l2 u+ E_l3,S1 union S2

TD,E,E_l1 |- pat : t gives E_l3
TD,E,E_l1 |- exp : __list t gives S1
TD,E,E_l1 u+ E_l3 |- </qbindi//i/> gives E_l2,S2
disjoint doms(E_l3, E_l2)
------------------------------------------------------------ :: list_restr
TD,E,E_l1 |- (pat MEM exp) </qbindi//i/> gives E_l2 u+ E_l3,S1 union S2

defn
TD , E , E_l1 |- list qbind1 .. qbindn gives E_l2 , S :: :: check_quant_binding :: check_quant_binding_
{{ com Build the environment for quantifier bindings, collecting typeclass constraints }}
 by

------------------------------------------------------------ :: empty
TD,E,E_l |- list gives {},{}

TD,E,E_l1 |- pat : t gives E_l3
TD,E,E_l1 |- exp : __list t gives S1
TD,E,E_l1 u+ E_l3 |- </qbindi//i/> gives E_l2,S2
disjoint doms(E_l3, E_l2)
------------------------------------------------------------ :: restr
TD,E,E_l1 |- list (pat MEM exp) </qbindi//i/> gives E_l2 u+ E_l3,S1 union S2


defn
TD , E , E_l |- funcl gives { x |-> t } , S :: :: check_funcl :: check_funcl_
{{ com Build the environment for a function definition clause, collecting typeclass constraints }}
by

TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
TD,E,E_l u+ E_l1 u+ ... u+ E_ln |- exp : u gives S
disjoint doms(E_l1,...,E_ln)
TD,E |- typ ~> u
------------------------------------------------------------ :: annot
TD,E,E_l |- x l1 pat1 ... patn : typ = exp l2 gives {x |-> curry((t1 * ... * tn), u)}, S

TD,E,E_l |- pat1 : t1 gives E_l1 ... TD,E,E_l |- patn : tn gives E_ln
TD,E,E_l u+ E_l1 u+ ... u+ E_ln |- exp : u gives S
disjoint doms(E_l1,...,E_ln)
------------------------------------------------------------ :: noannot
TD,E,E_l |- x l1 pat1 ... patn = exp l2 gives {x |-> curry((t1 * ... * tn), u)}, S


defn
TD , E , E_l1 |- letbind gives E_l2 , S :: :: check_letbind :: check_letbind_ 
{{ com Build the environment for a let binding, collecting typeclass constraints }}
by

TD,E,E_l1 |- pat : t gives E_l2
TD,E,E_l1 |- exp : t gives S
TD,E |- typ ~> t
------------------------------------------------------------ :: val_annot
TD,E,E_l1 |- pat : typ = exp l gives E_l2,S

TD,E,E_l1 |- pat : t gives E_l2
TD,E,E_l1 |- exp : t gives S
------------------------------------------------------------ :: val_noannot
TD,E,E_l1 |- pat = exp l gives E_l2,S

:check_funcl:TD,E,E_l1 |- funcl_aux l gives {x|->t},S
------------------------------------------------------------ :: fn
TD,E,E_l1 |- funcl_aux l gives {x|->t},S

defns
check_rule :: '' ::=

defn
TD , E , E_l |- rule gives { x |-> t } , S :: :: check_rule :: check_rule_
{{ com Build the environment for an inductive relation clause, collecting typeclass constraints }}
by

</TD |- ti ok//i/>
E_l2 = {</yi|->ti//i/>} 
TD,E,E_l1 u+ E_l2 |- exp' : __bool gives S'
TD,E,E_l1 u+ E_l2 |- exp1 : u1 gives S1 .. TD,E,E_l1 u+ E_l2 |- expn : un gives Sn
------------------------------------------------------------ :: rule
TD,E,E_l1 |- forall </yi li//i/> . exp' ==> x l exp1 .. expn l' gives {x|->curry((u1 * .. * un) , __bool)}, S' union S1 union .. union Sn

defns
check_texp_tc :: '' ::=

defn
xs , TD1 , E |- tc td gives TD2 , E_p :: :: check_texp_tc :: check_texp_tc_
{{ com Extract the type constructor information }}
by

tyvars ~> tvs
TD,E |- typ ~> t
duplicates(tvs) = emptyset
FV(t) SUBSET tvs
</yi.//i/>x NOTIN dom(TD)
------------------------------------------------------------ :: abbrev
</yi//i/>,TD,E |- tc x l tyvars = typ gives {</yi.//i/>x|->tvs.t},{x|-></yi.//i/>x}

tyvars ~> tvs
duplicates(tvs) = emptyset
</yi.//i/>x NOTIN dom(TD)
------------------------------------------------------------ :: abstract
</yi//i/>,TD,E1 |- tc x l tyvars gives {</yi.//i/>x|->tvs},{x|-></yi.//i/>x}

tyvars ~> tvs
duplicates(tvs) = emptyset
</yi.//i/>x NOTIN dom(TD)
------------------------------------------------------------ :: rec
</yi//i/>,TD1,E |- tc x l tyvars = <| x_l1 : typ1 ; ... ; x_lj : typj semi_opt |> gives {</yi.//i/>x|->tvs},{x|-></yi.//i/>x}

tyvars ~> tvs
duplicates(tvs) = emptyset
</yi.//i/>x NOTIN dom(TD)
------------------------------------------------------------ :: var
</yi//i/>,TD1,E |- tc x l tyvars = bar_opt ctor_def1 | ... | ctor_defj gives {</yi.//i/>x|->tvs},{x|-></yi.//i/>x}

defns
check_texps_tc :: '' ::=

defn
xs , TD1 , E |- tc td1 .. tdi gives TD2 , E_p :: :: check_texps_tc :: check_texps_tc_
{{ com Extract the type constructor information }}
by

------------------------------------------------------------ :: empty
xs,TD,E |- tc gives {},{}

:check_texp_tc: xs,TD1,E |- tc td gives TD2,E_p2
xs,TD1 u+ TD2,E u+ <{},E_p2,{},{}> |- tc </tdi//i/> gives TD3,E_p3
dom(E_p2) inter dom(E_p3) = emptyset
------------------------------------------------------------ :: abbrev
xs,TD1,E |- tc td </tdi//i/> gives TD2 u+ TD3,E_p2 u+ E_p3

defns
check_texp :: '' ::=

defn
TD , E |- tvs p = texp gives < E_f , E_x > :: :: check_texp :: check_texp_ 
{{ com Check a type definition, with its path already resolved }}
by

------------------------------------------------------------ :: abbrev
TD,E |- tvs p = typ gives <{},{}>

</TD,E |- typi ~> ti//i/>
names = {</xi//i/>}
duplicates(</xi//i/>) = emptyset
</FV(ti) SUBSET tvs//i/>
E_f = {</xi|-> <forall tvs. p -> ti, (xi of names)>//i/>}
------------------------------------------------------------ :: rec
TD,E |- tvs p = <| </x_li:typi//i/> semi_opt |> gives <E_f,{}>

</TD,E |- typsi ~> t_multii//i/>
names = {</xi//i/>}
duplicates(</xi//i/>) = emptyset
</FV(t_multii) SUBSET tvs//i/>
E_x = {</xi|-><forall tvs. t_multii -> p, (xi of names)>//i/>}
------------------------------------------------------------ :: var
TD,E |- tvs p = bar_opt </x_li of typsi//i/> gives <{},E_x>

defns
check_texps :: '' ::=

defn
xs , TD , E |- td1 .. tdn gives < E_f , E_x > :: :: check_texps :: check_texps_ by

------------------------------------------------------------ :: empty
</yi//i/>,TD,E |- gives <{},{}>

tyvars ~> tvs
TD,E1 |- tvs </yi.//i/>x = texp gives <E_f1,E_x1>
</yi//i/>,TD,E |- </tdj//j/> gives <E_f2,E_x2>
dom(E_x1) inter dom(E_x2) = emptyset
dom(E_f1) inter dom(E_f2) = emptyset
------------------------------------------------------------ :: cons_concrete
</yi//i/>,TD,E |- x l tyvars = texp </tdj//j/> gives <E_f1 u+ E_f2, E_x1 u+ E_x2>

</yi//i/>,TD,E |- </tdj//j/> gives <E_f,E_x>
------------------------------------------------------------ :: cons_abstract
</yi//i/>,TD,E |- x l tyvars </tdj//j/> gives <E_f,E_x>

defns
convert_class :: '' ::=

defn
TC , E |- id ~> p :: :: convert_class :: convert_class_
{{ com Lookup a type class }}
by

E(id) gives p
TC(p) gives xs
------------------------------------------------------------ :: all
TC,E |- id ~> p

defns
solve_class_constraint :: '' ::=

defn
I |- ( p t ) 'IN' semC :: :: solve_class_constraint :: solve_class_constraint_
{{ com Solve class constraint }}
by

------------------------------------------------------------ :: immediate
I |- (p a) IN (p1 a1) .. (pi ai) (p a) (p'1 a'1) .. (p'j a'j)

(p1 a1)..(pn an)=>(p t) IN I 
I |- (p1 t_subst(a1)) IN semC .. I |- (pn t_subst(an)) IN semC
------------------------------------------------------------ :: chain
I |- (p t_subst(t)) IN semC

defns
solve_class_constraints :: '' ::=

defn
I |- S gives semC :: :: solve_class_constraints :: solve_class_constraints_
{{ com Solve class constraints }}
by

I |- (p1 t1) IN semC ..  I |- (pn tn) IN semC
------------------------------------------------------------ :: all
I |- {(p1 t1), .., (pn tn)} gives semC

defns
check_val_def :: '' ::=

defn
TD , I , E |- val_def gives E_x :: :: check_val_def :: check_val_def_
{{ com Check a value definition }}
by

TD,E,{} |- letbind gives {</xi|->ti//i/>},S
I |- S gives semC
</FV(ti) SUBSET tvs//i/>
FV(semC) SUBSET tvs
------------------------------------------------------------ :: val
TD,I,E1 |- let targets_opt letbind gives {</xi |-> <forall tvs. semC => ti, let>//i/>}

</TD,E,E_l |- funcli gives {xi|->ti},Si//i/>
I |- S gives semC
</FV(ti) SUBSET tvs//i/>
FV(semC) SUBSET tvs
compatible overlap(</xi|->ti//i/>)
E_l = {</xi|->ti//i/>}
------------------------------------------------------------ :: recfun
TD,I,E |- let rec targets_opt </funcli//i/> gives {</xi|-><forall tvs. semC => ti,let>//i/>}

defns
check_t_instance :: '' ::=

defn

TD , ( a1 , .. , an ) |- t instance :: :: check_t_instance :: check_t_instance_
{{ com Check that $\ottnt{t}$ be a typeclass instance }}
by

------------------------------------------------------------ :: var
TD , (a) |- a instance

------------------------------------------------------------ :: tup 
TD , (a1, ...., an) |- a1 * .... * an instance

------------------------------------------------------------ :: fn
TD , (a1, a2) |- a1 -> an instance

TD(p) gives a'1..a'n
------------------------------------------------------------ :: tc
TD , (a1, .., an) |- p a1 .. an instance

defns
check_defs :: '' ::=

defn

</ zj // j /> , D1 , E1 |- def gives D2 , E2 :: :: check_def :: check_def_ 
{{ com Check a definition }}
by


</zj//j/>,TD1,E |- tc </tdi//i/> gives TD2,E_p
</zj//j/>,TD1 u+ TD2,E u+ <{},E_p,{},{}> |- </tdi//i/> gives <E_f,E_x>
------------------------------------------------------------ :: type 
</zj//j/>,<TD1,TC,I>,E |- type </tdi//i/> l gives <TD2,{},{}>,<{},E_p,E_f,E_x>

TD,I,E |- val_def gives E_x
------------------------------------------------------------ :: val_def
</zj//j/>,<TD,TC,I>,E |- val_def l gives empty,<{},{},{},E_x>

</TD,E1,E_l |- rulei gives {xi|->ti},Si//i/>
I |- </Si//i/> gives semC
</FV(ti) SUBSET tvs//i/>
FV(semC) SUBSET tvs
compatible overlap(</xi|->ti//i/>)
E_l = {</xi|->ti//i/>}
E2 = <{},{},{},{</xi |-><forall tvs. semC => ti,let>//i/>}>
------------------------------------------------------------ :: indreln
</zj//j/>,<TD,TC,I>,E1 |- indreln targets_opt </rulei//i/> l gives empty,E2

</zj//j/> x,D1,E1 |- defs gives D2,E2
------------------------------------------------------------ :: module
</zj//j/>,D1,E1 |- module x l1 = struct defs end l2 gives D2,<{x|->E2},{},{},{}>

E1(id) gives E2
------------------------------------------------------------ :: module_rename
</zj//j/>,D,E1 |- module x l1 = id l2 gives empty,<{x|->E2},{},{},{}>

TD,E |- typ ~> t
FV(t) SUBSET </ai//i/>
FV(</a'k//k/>) SUBSET </ai//i/>
</TC,E |- idk ~> pk//k/>
E' = <{},{},{},{x|-><forall </ai//i/>. </(pk a'k)//k/> => t,val>}>
------------------------------------------------------------ :: spec
</zj//j/>,<TD,TC,I>,E |- val x l1 : forall </ai l''i//i/>. </idk a'k l'k//k/> => typ l2 gives empty,E'

TD |- t1 ok .. TD |- tn ok
disjoint doms({y1|->t1},..,{yn|->tn})
TD,E1,{y1|->t1, .., yn|->tn} |- exp : t gives {}
t' = curry((t1 * .. * tn), t)
FV(t') SUBSET tvs
E2 = <{},{},{},{x |-><forall tvs. => t',let>}> 
------------------------------------------------------------ :: sub
</zj//j/>,<TD,TC,I>,E1 |- sub [ target ] x l y1 l1 .. yn ln = exp l' gives empty,E2

</TD,E1 |- typi ~> ti//i/>
</FV(ti) SUBSET a//i/>
p = </zj.//j/>x
E2 = <{},{x|->p},{},{</yi |-><forall a. (p a) => ti,method>//i/>}>
TC2 = {p|-></yi//i/>}
p NOTIN dom(TC1)
------------------------------------------------------------ :: class
</zj//j/>,<TD,TC1,I>,E1 |- class (x l a l'') </val yi li : typi li//i/> end l' gives <{},TC2,{}>,E2

E = <E_m,E_p,E_f,E_x>
TD,E |- typ' ~> t'
TD,(</ai//i/>) |- t' instance
tvs = </ai//i/>
duplicates(tvs) = emptyset
</TC,E |- idk ~> pk//k/>
FV(</a'k//k/>) SUBSET tvs
E(id) gives p
TC(p) gives </zj//j/>
I2 = { </=> (pk a'k)//k/> }
</TD,I union I2,E |- val_defn gives E_xn//n/>
disjoint doms(</E_xn//n/>)
</E_x(xk) gives <forall a''. (p a'') => tk,method>//k/>
{</xk |-> <forall tvs. => {a''|->t'}(tk),let>//k/>} = </E_xn//n/>
</xk//k/> = </zj//j/>
I3 = {</(pk a'k) => (p t')//k/>}
(p {</ai |-> a'''i//i/>}(t')) NOTIN I
------------------------------------------------------------ :: instance_tc
</zj//j/>,<TD,TC,I>,E |- instance forall </ai l'i//i/>. </idk a'k l''k//k/> => (id typ') </val_defn ln//n/> end l' gives <{},{},I3>,empty

defn
</ zj // j /> , D1 , E1 |- defs gives D2 , E2 :: :: check_defs :: check_defs_ 
{{ com Check definitions, given module path, definitions and environment }}
by

% TODO: Check compatibility for duplicate definitions

------------------------------------------------------------ :: empty
</zj//j/>,D,E |- gives empty,empty

:check_def: </zj//j/>,D1,E1 |- def gives D2,E2
</zj//j/>,D1 u+ D2,E1 u+ E2 |- </defi semisemi_opti // i/> gives D3,E3
------------------------------------------------------------ :: relevant_def 
</zj//j/>,D1,E1 |- def semisemi_opt </defi semisemi_opti // i/> gives D2 u+ D3, E2 u+ E3

E1(id) gives E2
</zj//j/>,D1,E1 u+ E2 |- </defi semisemi_opti // i/> gives D3,E3
------------------------------------------------------------ :: open
</zj//j/>,D1,E1 |- open id l semisemi_opt </defi semisemi_opti // i/> gives D3,E3

