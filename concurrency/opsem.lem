(* An operational semantics of concurrent C11, Kyndylan Nienhuis *)

(* This version covers rel, acq and sc atomics, non-atomics and
   locks. *)

open import Pervasives_extra
open import Cmm_aux
open import Cmm_master
open import Opsem_aux

(* ---------------------------------------------------------------- *)

(* We define wrappers around functions from Cmm to make the proofs
   less fiddly *)

val calcSw: pre_execution -> execution_witness -> set (action * action)
let calcSw pre wit = 
  release_acquire_synchronizes_with_set 
    pre.actions pre.sb pre.asw wit.rf wit.lo

val calcHb: pre_execution -> execution_witness -> set (action * action)
let calcHb pre wit = no_consume_hb pre.sb (calcSw pre wit)

val calcVse: pre_execution -> execution_witness -> set (action * action)
let calcVse pre wit = visible_side_effect_set pre.actions (calcHb pre wit)

val calcRel: pre_execution -> execution_witness -> relation_list
let calcRel pre wit =  
  [ ("hb",  calcHb pre wit);
    ("vse", calcVse pre wit);
    ("sw",  calcSw pre wit) ]

val assumptions2: pre_execution -> execution_witness -> bool
let assumptions2 pre wit = assumptions (pre, wit, calcRel pre wit)

val well_formed_threads2: pre_execution -> execution_witness -> bool
let well_formed_threads2 pre wit = well_formed_threads (pre, wit, calcRel pre wit)

val well_formed_rf2: pre_execution -> execution_witness -> bool
let well_formed_rf2 pre wit = well_formed_rf (pre, wit, calcRel pre wit)

val locks_only_consistent_locks2: pre_execution -> execution_witness -> bool
let locks_only_consistent_locks2 pre wit = locks_only_consistent_locks (pre, wit, calcRel pre wit)

val locks_only_consistent_lo2: pre_execution -> execution_witness -> bool
let locks_only_consistent_lo2 pre wit = locks_only_consistent_lo (pre, wit, calcRel pre wit)

val consistent_mo2: pre_execution -> execution_witness -> bool
let consistent_mo2 pre wit = consistent_mo (pre, wit, calcRel pre wit)

val sc_accesses_consistent_sc2: pre_execution -> execution_witness -> bool
let sc_accesses_consistent_sc2 pre wit = sc_accesses_consistent_sc (pre, wit, calcRel pre wit)

val sc_fenced_sc_fences_heeded2: pre_execution -> execution_witness -> bool
let sc_fenced_sc_fences_heeded2 pre wit = sc_fenced_sc_fences_heeded (pre, wit, calcRel pre wit)

val consistent_hb2: pre_execution -> execution_witness -> bool
let consistent_hb2 pre wit = consistent_hb (pre, wit, calcRel pre wit)

val det_read2: pre_execution -> execution_witness -> bool
let det_read2 pre wit = det_read (pre, wit, calcRel pre wit)

val consistent_non_atomic_rf2: pre_execution -> execution_witness -> bool
let consistent_non_atomic_rf2 pre wit = consistent_non_atomic_rf (pre, wit, calcRel pre wit)

val consistent_atomic_rf2: pre_execution -> execution_witness -> bool
let consistent_atomic_rf2 pre wit = consistent_atomic_rf (pre, wit, calcRel pre wit)

val coherent_memory_use2: pre_execution -> execution_witness -> bool
let coherent_memory_use2 pre wit = coherent_memory_use (pre, wit, calcRel pre wit)

val rmw_atomicity2: pre_execution -> execution_witness -> bool
let rmw_atomicity2 pre wit = rmw_atomicity (pre, wit, calcRel pre wit)

val sc_accesses_sc_reads_restricted2: pre_execution -> execution_witness -> bool
let sc_accesses_sc_reads_restricted2 pre wit = sc_accesses_sc_reads_restricted (pre, wit, calcRel pre wit)

val exIsConsistent: pre_execution -> execution_witness -> bool
let exIsConsistent pre wit = 
  assumptions2 pre wit &&
  well_formed_threads2 pre wit &&
  well_formed_rf2 pre wit &&
  locks_only_consistent_locks2 pre wit &&
  locks_only_consistent_lo2 pre wit &&
  consistent_mo2 pre wit &&
  sc_accesses_consistent_sc2 pre wit &&
  sc_fenced_sc_fences_heeded2 pre wit &&
  consistent_hb2 pre wit &&
  det_read2 pre wit &&
  consistent_non_atomic_rf2 pre wit &&
  consistent_atomic_rf2 pre wit &&
  coherent_memory_use2 pre wit &&
  rmw_atomicity2 pre wit &&
  sc_accesses_sc_reads_restricted2 pre wit

val unsequenced_races2: pre_execution -> execution_witness -> bool
let unsequenced_races2 pre wit = 
  not (Set.null (unsequenced_races (pre, wit, calcRel pre wit)))

val data_races2: pre_execution -> execution_witness -> bool
let data_races2 pre wit = 
  not (Set.null (data_races (pre, wit, calcRel pre wit)))

val indeterminate_reads2: pre_execution -> execution_witness -> bool
let indeterminate_reads2 pre wit = 
  not (Set.null (indeterminate_reads (pre, wit, calcRel pre wit)))

val locks_only_bad_mutexes2: pre_execution -> execution_witness -> bool
let locks_only_bad_mutexes2 pre wit = 
  not (Set.null (locks_only_bad_mutexes (pre, wit, calcRel pre wit)))

val exIsDefined: pre_execution -> execution_witness -> bool
let exIsDefined pre wit = 
  not (unsequenced_races2 pre wit ||
       data_races2 pre wit ||
       indeterminate_reads2 pre wit ||
       locks_only_bad_mutexes2 pre wit)




(* ---------------------------------------------------------------- *)

(* Incremental view on pre_executions and execution_witnesses *)

val defaultLk: location_kind
let defaultLk = Non_Atomic

val initialPreEx: pre_execution
let initialPreEx = 
  <| actions = {}; 
     threads = {};
     lk = (fun _ -> defaultLk);
     sb = {};
     asw = {};
     dd = {}; 
  |>

(* Holds information to extend a pre_ex with one action *)
type preExStep = 
<| action:    action;
   locKind:   location_kind;
   prevSb:    set action;
   prevAsw:   set action;
   prevDd:    set action;
|>

(* A sanity check on preExSteps. Obsolete. *)
val isValidPreExStep: preExStep -> pre_execution -> bool
let isValidPreExStep step pre = 
  aid_of step.action NIN (Set.map aid_of pre.actions)

(* Extends an existing pre_ex with a new action *)
val extendPreEx: pre_execution -> preExStep -> pre_execution
let extendPreEx preEx step =
  <| actions = Set.insert step.action preEx.actions;
     threads = Set.insert (tid_of step.action) preEx.threads;
     lk      = fun x -> (match loc_of step.action with
                         | Nothing  -> preEx.lk x
                         | Just loc -> if x = loc then step.locKind else preEx.lk x
                         end);
     sb      = preEx.sb union (Set.cross step.prevSb {step.action});
     asw     = preEx.asw union (Set.cross step.prevAsw {step.action});
     dd      = preEx.dd union (Set.cross step.prevDd {step.action});
  |>

(* Assembles a pre_ex from preExSteps *)
val assemblePreEx: list preExStep -> pre_execution
let rec assemblePreEx l =
  match l with
  | []   -> initialPreEx
  | h::t -> extendPreEx (assemblePreEx t) h
  end

val initialWitness: execution_witness
let initialWitness = 
<| rf = {};
   mo = {};
   sc = {};
   lo = {};
   ao = {};
   tot = {};
|>

(* Obsolete *)
val witnessUnion: execution_witness -> execution_witness -> execution_witness
let witnessUnion left right = 
<| rf = left.rf union right.rf;
   mo = left.mo union right.mo;
   sc = left.sc union right.sc;
   lo = left.lo union right.lo;
   ao = left.ao union right.ao;
   tot = left.tot union right.tot;
|>

(* Obsolete *)
val setDisjoint: forall 'a. SetType 'a => set 'a -> set 'a -> bool
let setDisjoint left right = 
  Set.intersection left right = Set.empty

(* Obsolete *)
val witnessDisjoint: execution_witness -> execution_witness -> bool
let witnessDisjoint left right = 
  setDisjoint left.rf right.rf &&
  setDisjoint left.mo right.mo &&
  setDisjoint left.sc right.sc &&
  setDisjoint left.lo right.lo &&
  setDisjoint left.ao right.ao &&
  setDisjoint left.tot right.tot

(* Obsolete *)
val witnessDifference: execution_witness -> execution_witness -> execution_witness
let witnessDifference left right =
<| rf = Set.difference left.rf right.rf;
   mo = Set.difference left.mo right.mo;
   sc = Set.difference left.sc right.sc;
   lo = Set.difference left.lo right.lo;
   ao = Set.difference left.ao right.ao;
   tot = Set.difference left.tot right.tot;
|>

(* Obsolete *)
val witnessSubset: execution_witness -> execution_witness -> bool
let witnessSubset left right =
  left.rf subset right.rf &&
  left.mo subset right.mo &&
  left.sc subset right.sc &&
  left.lo subset right.lo &&
  left.ao subset right.ao &&
  left.tot subset right.tot

(* Holds information to extend a ex_wit with new relations. We can
   reuse the type execution_witness, but morally it is a different
   type. *)

(* Obsolete *)
type witnessStep = execution_witness

(* Obsolete *)
type exStep = 
<| preExStep:   preExStep;
   witnessStep: witnessStep;
|>

(* Obsolete *)
(* Extends an execution with an exStep *)
val extendEx: observable_execution -> exStep -> observable_execution
let extendEx ex step =
  (extendPreEx (fst ex) step.preExStep, witnessUnion (snd ex) step.witnessStep)

(* Obsolete *)
(* Assembles an execution from exSteps *)
val assembleEx: list exStep -> observable_execution
let rec assembleEx steps =
  match steps with
  | []   -> (initialPreEx, initialWitness)
  | h::t -> extendEx (assembleEx t) h
  end

(* Restrictions of executions *)

val actionsOfTrace: list preExStep -> set action
let rec actionsOfTrace l =
  match l with
  | []   -> {}
  | h::t -> Set.insert h.action (actionsOfTrace t)
  end

val isHbPrefix: set action -> pre_execution -> execution_witness -> bool
let isHbPrefix actions pre wit =
  forall ((a, b) IN calcHb pre wit). b IN actions --> a IN actions

val respectsHb: list preExStep -> pre_execution -> execution_witness -> bool
let rec respectsHb l pre wit = 
  isHbPrefix (actionsOfTrace l) pre wit &&
  match l with
  | []   -> true
  | _::t -> respectsHb t pre wit
  end

val preExRestrict: pre_execution -> set action -> pre_execution
let preExRestrict pre actions = 
<| actions = Set.intersection pre.actions actions;
   threads = Set.intersection pre.threads (Set.map tid_of actions);
   lk = fun x -> if (Set.any (fun a -> loc_of a = Just x) actions) then pre.lk x else defaultLk;
   sb = Relation.relRestrict pre.sb actions;
   asw = Relation.relRestrict pre.asw actions;
   dd = Relation.relRestrict pre.dd actions;
|>

val witnessRestrict: execution_witness -> set action -> execution_witness
let witnessRestrict wit actions = 
<| rf = Relation.relRestrict wit.rf actions;
   mo = Relation.relRestrict wit.mo actions;
   sc = Relation.relRestrict wit.sc actions;
   lo = Relation.relRestrict wit.lo actions;
   ao = Relation.relRestrict wit.ao actions;
   tot = Relation.relRestrict wit.tot actions;
|>

val exRestrict: observable_execution -> set action -> observable_execution
let exRestrict ex actions = 
  (preExRestrict (fst ex) actions, witnessRestrict (snd ex) actions)




(* ---------------------------------------------------------------- *)

(* Threadwise opsem (twop) *)

type twop = 
<| init: program -> twopState;
   step: twopState -> twopState -> maybe preExStep -> bool;
|>

(* Transitive closure of twop.step (and appending the steps to a trace) *)
indreln
[twopTrace: twop -> twopState -> twopState -> list preExStep -> bool]

twopReflexive: forall twop x. 
  true
==>
  twopTrace twop x x []

and
twopStep: forall twop x y z h t.
  twopTrace twop x y t && twop.step y z (Just h)  
==>
  twopTrace twop x z (h::t)

and
twopInternalStep: forall twop x y z t.
  twopTrace twop x y t && twop.step y z Nothing  
==>
  twopTrace twop x z t

(* Traces from initial state *)
val twopInitTrace: twop -> program -> list preExStep -> bool
let ~{ocaml} twopInitTrace twop p trace = 
  exists s. twopTrace twop (twop.init p) s trace

(* Define twop of axiomatic model, they are called tls (thread local semantics) *)
val twopToTls: twop -> opsem_t
let ~{ocaml} twopToTls twop = fun p ex ->
  exists trace. twopInitTrace twop p trace && assemblePreEx trace = ex             

(* A condition on twops needed for completeness of the combined
   semantics. It says that if a twop is able to produce a pre_ex, it
   should be able to produce it in all possible ways. *)
val twopIsReorderingClosed: twop -> bool
let ~{ocaml} twopIsReorderingClosed twop =
  forall p trace trace'.
    assemblePreEx trace = assemblePreEx trace' -->
    twopInitTrace twop p trace -->
    twopInitTrace twop p trace'




(* ---------------------------------------------------------------- *)

(* Axiomatic semantics, parametrized by twops *)

(* We use the twop as the thread local semantics, as defined in Cmm *)

val axiomConsistent: twop -> program -> observable_execution -> bool
let ~{ocaml} axiomConsistent twop c ex =
  (twopToTls twop) c (fst ex) && exIsConsistent (fst ex) (snd ex)

val axiomUndefined: twop -> program -> observable_execution -> bool
let ~{ocaml} axiomUndefined twop c ex =
  axiomConsistent twop c ex && not (exIsDefined (fst ex) (snd ex))

val axiomBehaviour: twop -> program -> Cmm_master.program_behaviours
let ~{ocaml} axiomBehaviour twop c =
  if (exists ex. axiomUndefined twop c ex)
  then Undefined
  else Defined {ex | axiomConsistent twop c ex}





(* ---------------------------------------------------------------- *)

(* For some consistency predicates we define a speculative variant *)  

val det_read2_spec: pre_execution -> execution_witness -> bool
let det_read2_spec pre wit = 
  forall (r IN pre.actions).
    is_load r -->
    (exists (w' IN pre.actions). (w',r) IN wit.rf) --> 
    (exists (w  IN pre.actions). (w, r) IN calcVse pre wit)

val det_read2_resolved: pre_execution -> execution_witness -> bool
let det_read2_resolved pre wit = 
  forall (r IN pre.actions).
    is_load r -->
    (exists (w  IN pre.actions). (w, r) IN calcVse pre wit) -->
    (exists (w' IN pre.actions). (w',r) IN wit.rf)  
      
val rmw_atomicity2_spec: pre_execution -> execution_witness -> bool
let rmw_atomicity2_spec Xo Xw =  
    forall (b IN Xo.actions) (a IN Xo.actions).
      is_RMW b --> 
      ((a,b) IN Xw.rf) --> 
      adjacent_less_than Xw.mo Xo.actions a b
      
val rmw_atomicity2_resolved: pre_execution -> execution_witness -> bool
let rmw_atomicity2_resolved Xo Xw =  
    forall (b IN Xo.actions) (a IN Xo.actions).
      is_RMW b --> 
      adjacent_less_than Xw.mo Xo.actions a b --> 
      ((a,b) IN Xw.rf)

val exIsConsistent_spec: pre_execution -> execution_witness -> bool
let exIsConsistent_spec pre wit = 
  assumptions2 pre wit &&
  well_formed_threads2 pre wit &&
  well_formed_rf2 pre wit &&
  locks_only_consistent_locks2 pre wit &&
  locks_only_consistent_lo2 pre wit &&
  consistent_mo2 pre wit &&
  sc_accesses_consistent_sc2 pre wit &&
  sc_fenced_sc_fences_heeded2 pre wit &&
  consistent_hb2 pre wit &&
  det_read2_spec pre wit &&
  consistent_non_atomic_rf2 pre wit &&
  consistent_atomic_rf2 pre wit &&
  coherent_memory_use2 pre wit &&
  rmw_atomicity2_spec pre wit &&
  sc_accesses_sc_reads_restricted2 pre wit

val allSpecsAreResolved: pre_execution -> execution_witness -> bool
let allSpecsAreResolved pre wit = 
  det_read2_resolved pre wit &&
  rmw_atomicity2_resolved pre wit





(* ---------------------------------------------------------------- *)

(* Concurrent opsem *)

type state = 
<| twopState:      twopState;
   preEx:          pre_execution;
   exWitness:      execution_witness;
   stateIsDefined: bool;
|>

val initialState: twop -> program -> state
let initialState twop p = 
<| twopState      = twop.init p;
   preEx          = initialPreEx;
   exWitness      = initialWitness;
   stateIsDefined = true;
|>


val opsemStep: twop -> state -> state -> preExStep -> bool
let opsemStep twop s1 s2 preExStep =
  
  (* The twop part *)
  twop.step s1.twopState s2.twopState (Just preExStep) &&
  s2.preEx = extendPreEx s1.preEx preExStep &&

  (* We find a suitable witness *)
  exIsConsistent_spec s2.preEx s2.exWitness &&
  witnessRestrict s2.exWitness s1.preEx.actions = s1.exWitness &&

  (* Definedness *)
  s2.stateIsDefined = exIsDefined s2.preEx s2.exWitness



indreln
[opsemTrace: twop -> state -> state -> list preExStep -> bool]

opsemReflexive: forall twop s. 
  true
==>
  opsemTrace twop s s [] 

and
opsemStep: forall twop x y z tail head.
  opsemTrace twop x y tail && 
  opsemStep twop y z head
==>
  opsemTrace twop x z (head::tail)

and
opsemInternalStep: forall twop x y z tail.
  opsemTrace twop x y tail && 
  twop.step y.twopState z.twopState Nothing &&
  z = <|y with twopState = z.twopState |>
==>
  opsemTrace twop x z tail

val opsemConsistent: twop -> program -> observable_execution -> bool
let ~{ocaml} opsemConsistent twop p ex =
  exists trace s. 
  opsemTrace twop (initialState twop p) s trace &&
  s.preEx = fst ex &&
  s.exWitness = snd ex &&
  allSpecsAreResolved s.preEx s.exWitness

val opsemUndefined: twop -> program -> observable_execution -> bool
let ~{ocaml} opsemUndefined twop p ex =
  exists trace s. 
  opsemTrace twop (initialState twop p) s trace &&
  s.preEx = fst ex &&
  s.exWitness = snd ex &&
  allSpecsAreResolved s.preEx s.exWitness &&
  not s.stateIsDefined

val opsemBehaviour: twop -> program -> Cmm_master.program_behaviours
let ~{ocaml} opsemBehaviour twop c = 
  if (exists ex. opsemUndefined twop c ex)
  then Undefined
  else Defined {ex | opsemConsistent twop c ex}
