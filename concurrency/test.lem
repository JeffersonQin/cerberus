open import Pervasives Show Relation Set
open import Cmm_master
open import MinimalOpsem 
open import RelationalOpsem
open import ExecutableOpsem

val print: string -> unit
declare ocaml target_rep function print = `print_string`
let ~{ocaml} print _ = ()

val step: exeState -> nat -> list exeState
let step s n =
  let steps = Set_extra.toList (exeOpsemStep s standardEqualityCvalue) in
  let indent = String.makeString n #' ' in
  let _ = print (indent ^ show (List.length steps) ^ " steps at " ^ show s ^ "\n") in
  List.map (fun step -> let _ = print (show step) in stateOf step)
           steps

val chooseStep: exeState -> action -> exeState
let chooseStep s a =
  let steps = Set_extra.toList (exeOpsemStep s standardEqualityCvalue) in
  let filtered_steps  = List.filter (fun step -> actionOf step = a) steps in
  match filtered_steps with
  | []               -> let _ = print "Transition not possible\n" in s
  | [chosenStep]     -> let _ = print (show chosenStep ^ "\n") in stateOf chosenStep
  | _                -> let _ = print ("Multiple transitions possible " ^ 
                                       show filtered_steps) in s
  end  

val trace_aux: exeState -> list action -> exeState
let rec trace_aux s l = 
  match l with
  | []   -> s
  | h::t -> trace_aux (chooseStep s h) t
  end

val trace: pre_execution -> list action -> exeState
let trace pre l =
  trace_aux (initialExeState pre) l

val exhaustive_aux: exeState -> nat -> unit
let rec exhaustive_aux s n =
  let _ = List.map (fun s' -> exhaustive_aux s' (n + 1)) (step s n) in ()

(* Exhaustive is a reserved key word in Lem. *)
val exhaustive2: pre_execution -> unit
let exhaustive2 p =
  exhaustive_aux (initialExeState p) 0

let a0 = Store 0 0 Release 0 0
let a1 = Store 1 0 Release 1 1
let a2 = Load  2 0 Acquire 1 0
let a3 = Store 3 1 Release 1 0
let a4 = Store 4 1 Release 0 1
let a5 = Load  5 1 Acquire 0 0

val examplePreEx: pre_execution
let examplePreEx =
  <|actions = {a0; a1; a2; a3; a4; a5};
    threads = {0; 1};
    lk      = (fun _ -> Atomic);
    sb      = {(a0,a1); (a0,a2); (a1,a2); (a3,a4); (a3,a5); (a4,a5)};
    asw     = {};
    dd      = {};
|>

val isCons: exeState -> bool
let isCons state = 
  let rel = getRelations state.preEx state.exWitness in
  let ex = (state.preEx, state.exWitness, rel) in
  let committed = state.committed in
  let eq = standardEqualityCvalue in
  let _ = print (if not (assumptions ex) then "assumptions\n" else "") in
  let _ = print (if not (det_read_op committed ex) then "det_read_op\n" else "") in
  let _ = print (if not (coherent_memory_use ex) then "coherent_memory_use\n" else "") in
  let _ = print (if not (consistent_atomic_rf ex) then "consistent_atomic_rf\n" else "") in
  let _ = print (if not (consistent_hb ex) then "consistent_hb\n" else "") in
  let _ = print (if not (consistent_mo_op committed ex) then "consistent_mo_op\n" else "") in
  let _ = print (if not (consistent_non_atomic_rf ex) then "consistent_non_atomic_rf\n" else "") in
  let _ = print (if not (locks_only_consistent_lo_op committed ex) 
                 then "locks_only_consistent_lo_op\n" else "") in
  let _ = print (if not (locks_only_consistent_locks_op committed ex) 
                 then "locks_only_consistent_locks_op\n" else "") in
  let _ = print (if not (rmw_atomicity_op committed ex) then "rmw_atomicity_op\n" else "") in
  let _ = print (if not (sc_accesses_consistent_sc_op committed ex) 
                 then "sc_accesses_consistent_sc_op\n" else "") in
  let _ = print (if not (sc_accesses_sc_reads_restricted ex) 
                 then "sc_accesses_sc_reads_restricted\n" else "") in
  let _ = print (if not (sc_fenced_sc_fences_heeded ex) then "sc_fenced_sc_fences_heeded\n" else "") in
  let _ = print (if not (tot_empty ex) then "tot_empty\n" else "") in
  let _ = print (if not (well_formed_rf_op_sym eq committed ex) then "well_formed_rf_op_sym\n" else "") in
  let _ = print (if not (well_formed_threads ex) then "well_formed_threads\n" else "") in
  let Xo = state.preEx in
  let _ = print (if not ((forall (a IN Xo.actions). well_formed_action a)) 
                 then "well_formed_action\n" else "") in
  let _ = print (if not (actions_respect_location_kinds Xo.actions Xo.lk) 
                 then "actions_respect_location_kinds\n" else "") in
  let _ = print (if not (blocking_observed Xo.actions Xo.sb) then "blocking_observed\n" else "") in
  let _ = print (if not (inj_on aid_of Xo.actions) then "inj_on aid\n" else "") in
  let _ = print (if not (relation_over Xo.actions Xo.sb) then "relation_over sb\n" else "") in
  let _ = print (if not (relation_over Xo.actions Xo.asw) then "relation_over asw\n" else "") in
  let _ = print (if not (threadwise Xo.actions Xo.sb) then "threadwise sb\n" else "") in
  let _ = print (if not (interthread Xo.actions Xo.asw) then "interthread asw\n" else "") in
  let _ = print (if not (isStrictPartialOrder Xo.sb) then "isStrictPartialOrder sb\n" else "") in
  let _ = print (if not (isStrictPartialOrder Xo.dd) then "isStrictPartialOrder dd\n" else "") in
  let _ = print (if not (Xo.dd subset Xo.sb) then "dd subset sb\n" else "") in
  let _ = print (if not (indeterminate_sequencing Xo) then "indeterminate_sequencing\n" else "") in
  let _ = print (if not (isIrreflexive (sbasw Xo)) then "isIrreflexive sb asw\n" else "") in
  let _ = print (if not (finite_prefixes (sbasw Xo) Xo.actions) 
                 then "finite_prefixes sb asw\n" else "") in
  let _ = print (if not (disjoint_allocs Xo.actions) then "disjoint_allocs\n" else "") in
  exIsConsistent_op_sym eq committed ex

val main: unit
let main = 
  let _ = print ("is_cons: " ^ show (isCons (initialExeState examplePreEx)) ^ "\n") in
  let _ = trace examplePreEx [a1; a3; a4; a0; a2; a5] in 
  let _ = print "finished\n" in ()
