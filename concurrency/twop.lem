open import Pervasives_extra
open import Cmm_aux
open import Cmm_master
open import Opsem_aux
open import Opsem
open import Language

(* See Opsem_aux for the definition of twopState *)

val initialState: command -> twopState
let initialState c = 
  (c, 
   T_Single <| tid = Concrete 0; prevActions = {}; |>,
   <| bindings = Map.empty;
      maxAid = 0;
      maxTid = 0;
   |>
  )

(* Auxiliary functions *)

(* Let ott generate the Cmm memory_orders *)
val cmmMem: Language.memoryOrder -> Cmm_master.memory_order
let cmmMem mem = 
  match mem with
  | Mo_Na -> NA
  | Mo_Relaxed -> Relaxed
  | Mo_Acquire -> Acquire
  | Mo_Release -> Release
  | Mo_Seq_cst -> Seq_cst
  end

(* TODO: Let program be Undefined when variable not bound, instead of
   giving it the value 0  *)
val evalE: globalState -> expression -> number
let rec evalE s e = 
  match e with
  | E_Var v       -> Map.findWithDefault v 0 s.bindings
  | E_Int n       -> n
  | E_Plus e1 e2  -> (evalE s e1) + (evalE s e2)
  | E_Minus e1 e2 -> (evalE s e1) - (evalE s e2)
  end

val evalBe: globalState -> booleanExpression -> bool
let rec evalBe s be = 
  match be with
  | Be_True        -> true
  | Be_False       -> false
  | Be_Eq e1 e2    -> (evalE s e1) = (evalE s e2)
  | Be_Geq e1 e2   -> (evalE s e1) >= (evalE s e2)
  | Be_Not be1     -> not (evalBe s be1)
  | Be_And be1 be2 -> (evalBe s be1) && (evalBe s be2)
  | Be_Or be1 be2  -> (evalBe s be1) || (evalBe s be2)
  end

(* The operational semantics *)

indreln
[step: twopState -> twopState -> maybe preExStep -> bool]

sStore: forall var expr mem loc glob store.
  store = Store (Concrete (glob.maxAid + 1)) loc.tid (cmmMem mem) var (evalE glob expr) 
==>
  step (C_Store var expr mem, T_Single loc, glob)
       (C_Skip, T_Single <| loc with prevActions = {store} |>, glob)
       (Just <| action = store;
                locKind = Non_Atomic;
                prevSb = Set.filter (fun a -> tid_of a = loc.tid) loc.prevActions;
                prevAsw = Set.filter (fun a -> tid_of a <> loc.tid) loc.prevActions;
                prevDd = {}; |>)

and
sLoad: forall binderVar loadVar mem c value loc glob load.   
  load = Load (Concrete (glob.maxAid + 1)) loc.tid (cmmMem mem) loadVar value
==>
  step (C_Load binderVar loadVar mem c, T_Single loc, glob)
       (c, T_Single <| loc with prevActions = {load} |>, glob)
       (Just <| action = load;
                locKind = Non_Atomic;
                prevSb = Set.filter (fun a -> tid_of a = loc.tid) loc.prevActions;
                prevAsw = Set.filter (fun a -> tid_of a <> loc.tid) loc.prevActions;
                prevDd = {}; |>)

and
sIfTrue: forall be c1 c2 loc glob.
  evalBe glob be
==>
  step (C_If be c1 c2, loc, glob) (c1, loc, glob) Nothing

and
sIfFalse: forall be c1 c2 loc glob.
  not (evalBe glob be)
==>
  step (C_If be c1 c2, loc, glob) (c2, loc, glob) Nothing

and
sSeqSkip: forall c glob loc.
  true
==>
  step (C_Seq C_Skip c, loc, glob) (c, loc, glob) Nothing

and
sSeq: forall c1 c1' c2 glob glob' loc loc' preExStep.
  step (c1, loc, glob) (c1', loc', glob') preExStep
==>
  step (C_Seq c1 c2, loc, glob) (C_Seq c1' c2, loc', glob') preExStep

and
sParFork: forall glob glob' c1 c2 loc1 loc2 loc3.
  loc2.tid = Concrete (glob.maxTid + 1) &&
  loc2.prevActions = loc1.prevActions &&
  loc3.tid = Concrete (glob.maxTid + 2) &&
  loc3.prevActions = loc1.prevActions &&
  glob'.bindings = glob.bindings &&
  glob'.maxAid = glob.maxAid &&
  glob'.maxTid = glob.maxTid + 2
==>
  step (C_Par c1 c2, T_Single loc1, glob) 
       (C_Par c1 c2, T_Par (T_Single loc2) (T_Single loc3) loc1.tid, glob') 
       Nothing

and
sParJoin: forall glob loc1 loc2 loc3 tid3.
  loc3.tid = tid3 &&
  loc3.prevActions = loc1.prevActions union loc2.prevActions
==>
  step (C_Par C_Skip C_Skip, T_Par (T_Single loc1) (T_Single loc2) tid3, glob) 
       (C_Skip, T_Single loc3, glob) 
       Nothing

and
sParLeft: forall c1 c1' c2 glob glob' loc1 loc1' loc2 preExStep tid. 
  step (c1, loc1, glob) (c1', loc1', glob') preExStep
==>
  step (C_Par c1 c2, T_Par loc1 loc2 tid, glob) (C_Par c1' c2, T_Par loc1' loc2 tid, glob') preExStep

and
sParRight: forall c1 c2 c2' glob glob' loc1 loc2 loc2' preExStep tid.
  step (c2, loc2, glob) (c2', loc2', glob') preExStep
==>
  step (C_Par c1 c2, T_Par loc1 loc2 tid, glob) (C_Par c1 c2', T_Par loc1 loc2' tid, glob') preExStep



(* The parameter to the concurrent semantics *)
val twop: twop
let twop = 
  <| init = initialState;
     step = step;
  |>

lemma ~{ocaml} twopCorrect: (twopIsReorderingClosed twop)