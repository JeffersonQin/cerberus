(* --------------------------------------------------------------------- *)
(* -- An operational semantics of C11 concurrency                        *)
(* -- (c) Kyndylan Nienhuis, University of Cambridge                     *)
(* --------------------------------------------------------------------- *)

open import Pervasives Show Show_extra
open import Cmm_aux Cmm_master



(* The axiomatic model ------------------------------------------------- *)

(* The following parameters denote which model and sublanguage we use
   in the opserational semantics. If the model satisfies certain
   properties (see the Isabelle proofs), the operational semantics
   will be equivalent to the axiomatic model. These properties hold
   for some models (probably rel-acq-rlx-sc, rel-acq-rlx-sc-fences,
   with_consume and the standard model), but not all models. *)

val sublanguage: condition_t
let inline sublanguage = true_condition

val memory_model: memory_model
let inline memory_model = standard_memory_model

val axBehaviour: opsem_t -> program -> program_behaviours
let inline ~{ocaml} axBehaviour = standard_behaviour

val axUndefined: list fault_setgen
let inline axUndefined = locks_only_undefined_behaviour

val getRelations: pre_execution -> execution_witness -> relation_list
let inline getRelations = standard_relations

val axConsistent: candidate_execution -> bool
let inline axConsistent ex = 
  apply_tree standard_consistent_execution ex



(* The simplified axiomatic model -------------------------------------- *)

(* We use the simplified version of det_read and consistent_atomic_rf,
and we add some requirements on pre-executions. *)

val well_formed_threads_opsem: candidate_execution -> bool
let well_formed_threads_opsem (pre, wit, rel) =
  well_formed_threads (pre, wit, rel) &&
  finite (pre.actions)

val axsimpConsistentExecution: named_predicate_tree
let axsimpConsistentExecution =
  Node [ 
    ("assumptions",                     Leaf assumptions);
    ("tot_empty",                       Leaf tot_empty);
    ("well_formed_threads_opsem",       Leaf well_formed_threads_opsem);
    ("well_formed_rf",                  Leaf well_formed_rf);
    ("locks_only_consistent_locks",     Leaf locks_only_consistent_locks);
    ("locks_only_consistent_lo",        Leaf locks_only_consistent_lo);
    ("consistent_mo",                   Leaf consistent_mo);
    ("sc_accesses_consistent_sc",       Leaf sc_accesses_consistent_sc);
    ("sc_fenced_sc_fences_heeded",      Leaf sc_fenced_sc_fences_heeded);
    ("consistent_hb",                   Leaf consistent_hb);
    ("det_read_alt",                    Leaf det_read_alt);
    ("consistent_non_atomic_rf",        Leaf consistent_non_atomic_rf);
    ("consistent_atomic_rf",            Leaf consistent_atomic_rf);
    ("coherent_memory_use",             Leaf coherent_memory_use);
    ("rmw_atomicity",                   Leaf rmw_atomicity);
    ("sc_accesses_sc_reads_restricted", Leaf sc_accesses_sc_reads_restricted)  
  ]

val axsimpConsistent: candidate_execution -> bool
let inline axsimpConsistent ex =
  apply_tree axsimpConsistentExecution ex

val axsimpMemoryModel: memory_model
let axsimpMemoryModel = 
  <| consistent = axsimpConsistentExecution;
     relation_calculation = getRelations;
     undefined = axUndefined;
     relation_flags =
       <|  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = true;
           tot_flag = false |>
  |>

val axsimpBehaviour: opsem_t -> program -> program_behaviours
let ~{ocaml} axsimpBehaviour opsem_t p =
  behaviour axsimpMemoryModel sublanguage opsem_t p



(* The incremental model ----------------------------------------------- *)

val preRestrict: pre_execution -> set action -> pre_execution
let preRestrict pre actions = 
<| actions = pre.actions inter actions;
   threads = pre.threads;
   lk = pre.lk; 
   sb = Relation.relRestrict pre.sb actions;
   asw = Relation.relRestrict pre.asw actions;
   dd = Relation.relRestrict pre.dd actions;
|>

(* incWitRestrict restricts the witness to the set of committed
   actions. *)
val incWitRestrict: execution_witness -> set action -> execution_witness
let incWitRestrict wit actions = 
<| rf = Relation.relRestrict wit.rf actions;
   mo = Relation.relRestrict wit.mo actions;
   sc = Relation.relRestrict wit.sc actions;
   lo = Relation.relRestrict wit.lo actions;
   tot = Relation.relRestrict wit.tot actions;
|>

(* To show completeness, we will commit the actions of a pre_execution
   in a certain order, which we define here. *)

val pre_hb: pre_execution -> set (action * action)
let ~{ocaml} pre_hb pre = 
  pre.sb union (sw_asw pre)

val wit_hb: pre_execution -> execution_witness -> set (action * action)
let ~{ocaml} wit_hb pre wit = 
        (sw_lock pre wit)
  union (sw_rel_acq_rs pre wit) 
  union (sw_fence_sb_hrs_rf_sb pre wit)
  union (sw_fence_sb_hrs_rf pre wit)
  union (sw_fence_rs_rf_sb pre wit)

val sb_r_f: pre_execution -> execution_witness -> set (action * action)
let sb_r_f pre wit = 
  {(a, b) | forall ((a, b) IN pre.sb) 
  |    is_at_atomic_location pre.lk a 
    && is_read a
    && is_fence b
    && is_acquire b}

val sb_f_w: pre_execution -> execution_witness -> set (action * action)
let sb_f_w pre wit = 
  {(a, b) | forall ((a, b) IN pre.sb) 
  |    is_fence a
    && is_release a
    && is_at_atomic_location pre.lk b 
    && is_write b}

val incCom2_step: candidate_execution -> set (action * action)
let incCom2_step (pre, wit, rel) =
        wit.mo
  union wit.rf
  union (sb_r_f pre wit)
  union (sb_f_w pre wit)

val incCom2: candidate_execution -> set (action * action)
let incCom2 ex =
  Relation.transitiveClosure (incCom2_step ex)

(* The old order *)

val is_na_or_non_write: pre_execution -> action -> bool
let is_na_or_non_write pre a = 
  not (is_write a) || is_at_non_atomic_location pre.lk a

(* TODO: find a better name *)
val hbMinus: candidate_execution -> set (action * action)
let hbMinus (pre, _, ("hb",hb)::_) = 
  {(a, b) | forall ((a, b) IN hb) | is_na_or_non_write pre b} 

(* The commitment order *)
val incCom: candidate_execution -> set (action * action)
let incCom (pre, wit, rel) =
  Relation.transitiveClosure 
    (Set.(union) (hbMinus (pre, wit, rel)) 
                 (Set.(union) wit.rf wit.mo))

val respectsCom: set action -> set action -> set (action * action) -> action -> bool
let respectsCom actions committed comOrder a = 
  (forall (b IN actions).
    (b IN committed --> (a, b) NIN comOrder) &&
    ((b, a) IN comOrder --> b IN committed))
  

(* The state of the incremental model *)

type incState = 
<| incWit:       execution_witness;
   incCommitted: set action;
|>

val incInitialState: pre_execution -> incState
let incInitialState _ = 
<| incWit       = empty_witness;
   incCommitted = {};
|>

val incToEx: pre_execution -> incState -> candidate_execution
let incToEx pre s = 
  let pre_res = preRestrict pre s.incCommitted in
  let wit     = s.incWit in
  let rel     = getRelations pre_res wit in
  (pre_res, wit, rel)

(* The semantics of the incremental model *)

val incStep: pre_execution -> incState -> incState -> action -> bool
let incStep pre s1 s2 a =

  let s2_pre = preRestrict pre s2.incCommitted in
  let rel   = getRelations s2_pre s2.incWit in
  let s2_ex = (s2_pre, s2.incWit, rel) in
  let com   = incCom s2_ex in

  (* The action that is committed in this step hasn't already been committed *)
  a IN pre.actions &&
  a NIN s1.incCommitted &&
  s2.incCommitted = Set.insert a s1.incCommitted &&  

  (* Actions are committed in the right order. *)
  respectsCom pre.actions s1.incCommitted com a &&

  (* The new execution_witness extends the previous (only new
  relations are added, and new relations are from or to the committed
  action). *)
  incWitRestrict s2.incWit s1.incCommitted = s1.incWit &&

  (* The new execution satisfies the consistency predicates. *)
  axsimpConsistent s2_ex


(* incTrace is the transitive closure of incStep, except that in the
   reflexive case we require that the consistency predicate hold. This
   is needed for soundness. *)

indreln
[incTrace: pre_execution -> incState -> incState -> bool]

incReflexive: forall pre s. 
  well_formed_threads_opsem (pre, empty_witness, [])
==>
  incTrace pre s s

and
incStep: forall pre x y z a.
  incTrace pre x y && 
  incStep pre y z a
==>
  incTrace pre x z


val incConsistent: candidate_execution -> bool
let ~{ocaml} incConsistent (pre, wit, rel) =
  rel = getRelations pre wit &&
  exists s. 
  incTrace pre (incInitialState pre) s &&
  s.incWit = wit &&
  s.incCommitted = pre.actions



(* The monadic model --------------------------------------------------- *)

import Nondeterminism
(* The following doesn't generate valid Isabelle code. *)
(* module ND = Nondeterminism *)

(* Note that until we have implemented back tracking, we need the
   concurrency model to compute the set of next steps exhaustively
   (regardless of the execution mode) to prevent getting stuck in
   killed executions. *) 
let inline (>>=) = Nondeterminism.bindExhaustive 
let inline (>>) m1 m2 = Nondeterminism.bindExhaustive m1 (fun _ -> m2)

(* Auxiliaries *)

val sameLocWrites: set action -> action -> set action
let sameLocWrites actions a =
  {b | forall (b IN actions) | is_write b && loc_of b = loc_of a}

val sameLocLocksUnlocks: set action -> action -> set action
let sameLocLocksUnlocks actions a =
  {b | forall (b IN actions) | (is_lock b || is_unlock b) && loc_of b = loc_of a}

val scActions: set action -> set action
let scActions actions =
  {b | forall (b IN actions) | is_seq_cst b}

(* Methods for updating the execution witness *)

val addToTransitiveOrder: set action -> action -> set (action * action) -> Nondeterminism.t (set (action * action))
let addToTransitiveOrder domain a r =
  Nondeterminism.mplus
  (* We insert the action before all other actions *)
  (Nondeterminism.return (Set.(union) r {(a, b) | forall (b IN domain) | true}))
  (* We choose an action, and insert 'a' directly after it *)
  (Nondeterminism.pick (Set_extra.toList domain) >>= fun b ->
    let prev = {(c, a) | forall (c IN domain) | (c, b) IN r} in
    let succ = {(a, c) | forall (c IN domain) | (b, c) IN r} in
    Nondeterminism.return (Set.(union) r (Set.insert (b, a) (Set.(union) prev succ))))

val monAddToMo: pre_execution -> action -> incState -> Nondeterminism.t (set (action * action))
let monAddToMo pre a s =
  let prev = {(b, a) | forall (b IN sameLocWrites s.incCommitted a) | true} in
  Nondeterminism.return (Set.(union) s.incWit.mo prev)

val auxAddPairToRf: set (action * action) -> action -> action -> 
                    (cvalue -> cvalue -> bool) ->
                    Nondeterminism.t (set (action * action) * maybe (cvalue * cvalue))
let auxAddPairToRf old_rf w r eq =
  match (value_written_by w, value_read_by r) with
  | (Just value_w, Just value_r) -> 
      Nondeterminism.guard (eq value_w value_r) 
               (Nondeterminism.Other ("The value written (" ^ show value_w ^ 
                          ") and the value read ( " ^ show value_r ^ 
                          ") cannot be matched")) >> 
      Nondeterminism.return ((Set.insert (w, r) old_rf), Just (value_w, value_r))
  | _ -> 
      Nondeterminism.kill (Nondeterminism.Error "A write-read pair doesn't contain the values written and read")
  end  

(* NOTE: this function is only sound when the resulting execution is
   checked for det_read. Because the resulting state is not visible at 
   this point, we can't check that here. The top-level semantics is sound, 
   because in all calling fuctions we do check det_read *)
(* The parameter eq is used to compare cvalues. *)
(* The return type is the new rf-relation, and Nothing if no new edge
   has been added, and otherwise Just a b with a b the values of the
   read and write of the new rf-edge. *)
val auxAddToRfLoad: pre_execution -> action -> incState -> 
                    (cvalue -> cvalue -> bool) ->
                    Nondeterminism.t (set (action * action) * maybe (cvalue * cvalue))
let auxAddToRfLoad pre a s eq =
  Nondeterminism.mplus
  (* We do not add an rf-edge. This should happen when there is no vse-edge in the resulting state. *)
  (Nondeterminism.return (s.incWit.rf, Nothing))
  (* We add an rf-edge. *)
  (Nondeterminism.pick 
    (Set_extra.toList (sameLocWrites s.incCommitted a)) 
    >>= fun w ->
    auxAddPairToRf s.incWit.rf w a eq)

val monAddToRfLoad: pre_execution -> action -> incState -> 
                    Nondeterminism.t (set (action * action))
let monAddToRfLoad pre a s =
  auxAddToRfLoad pre a s (fun a b -> a = b) >>= fun (new_rf, _) ->
  Nondeterminism.return new_rf

(* The parameter eq is used to compare cvalues. *)
(* The return type is the new rf-relation, and Nothing if no new edge
   has been added, and otherwise Just a b with a b the values of the
   read and write of the new rf-edge. *)
val auxAddToRfRmw: pre_execution -> action -> incState -> 
                   (cvalue -> cvalue -> bool) ->
                   Nondeterminism.t (set (action * action) * maybe (cvalue * cvalue))
let auxAddToRfRmw pre a s eq =
  let mo_actions = sameLocWrites s.incCommitted a in
  if mo_actions = {} then
    Nondeterminism.return (s.incWit.rf, Nothing)
  else
    Nondeterminism.pick 
      (Set_extra.toList 
        {w | forall (w IN mo_actions) 
           | forall (c IN mo_actions). (w, c) NIN s.incWit.mo})
    >>= fun w ->
    auxAddPairToRf s.incWit.rf w a eq    

val monAddToRfRmw: pre_execution -> action -> incState -> 
                   Nondeterminism.t (set (action * action))
let monAddToRfRmw pre a s =
  auxAddToRfRmw pre a s (fun a b -> a = b) >>= fun (new_rf, _) ->
  Nondeterminism.return new_rf

val monAddToLo: pre_execution -> action -> incState -> Nondeterminism.t (set (action * action))
let monAddToLo pre a s = 
  addToTransitiveOrder (sameLocLocksUnlocks s.incCommitted a) a s.incWit.lo

val monAddToSc: pre_execution -> action -> incState -> Nondeterminism.t (set (action * action))
let monAddToSc pre a s = 
  addToTransitiveOrder (scActions s.incCommitted) a s.incWit.sc

(* Checking consistency in monadic style *)

val monCheckConsistency: candidate_execution -> Nondeterminism.t unit
let monCheckConsistency ex =
  Nondeterminism.guard (axsimpConsistent ex) (Nondeterminism.Other "Inconsistent")

val monCheckWitRestrict: execution_witness -> set action -> execution_witness -> Nondeterminism.t unit
let monCheckWitRestrict new_wit committed old_wit =
  Nondeterminism.guard (incWitRestrict new_wit committed = old_wit) 
           (Nondeterminism.Error "\"witnessRestrict new committed = old\" should hold by construction.")

val monCheckCommitmentOrder: set action -> candidate_execution -> set action
                             -> action -> Nondeterminism.t unit
let monCheckCommitmentOrder actions (pre, wit, rel) committed a = 
  let order = incCom (pre, wit, rel) in
  Nondeterminism.guard 
    (respectsCom actions committed order a)
    (Nondeterminism.Other ("Committing action " ^ show (aid_of a) ^ 
                           " does not respect the commitment order."))

(* The semantics of performing an action *)

val monPerformLoad: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformLoad pre s a =
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     Nondeterminism.return s.incWit.sc)    >>= fun new_sc ->
  monAddToRfLoad pre a s       >>= fun new_rf ->
  let new_wit = <| s.incWit with sc = new_sc; rf = new_rf; |> in
  Nondeterminism.return new_wit

val monPerformStore: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformStore pre s a =
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     Nondeterminism.return s.incWit.sc)    >>= fun new_sc ->
  (if is_at_atomic_location pre.lk a then
     monAddToMo pre a s
   else
     Nondeterminism.return s.incWit.mo)    >>= fun new_mo ->
  let new_wit = <| s.incWit with sc = new_sc; mo = new_mo; |> in
  Nondeterminism.return new_wit

val monPerformRmw: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformRmw pre s a =
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     Nondeterminism.return s.incWit.sc)    >>= fun new_sc ->
  monAddToRfRmw pre a s        >>= fun new_rf ->
  monAddToMo pre a s           >>= fun new_mo ->
  let new_wit = <| s.incWit with sc = new_sc; rf = new_rf; mo = new_mo; |> in
  Nondeterminism.return new_wit

val monPerformBlocked_rmw: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformBlocked_rmw pre s a =
  let new_wit = s.incWit in
  Nondeterminism.return new_wit

val monPerformLock: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformLock pre s a =
  monAddToLo pre a s          >>= fun new_lo ->
  let new_wit = <| s.incWit with lo = new_lo; |> in
  Nondeterminism.return new_wit

val monPerformUnlock: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformUnlock pre s a =
  monAddToLo pre a s          >>= fun new_lo ->
  let new_wit = <| s.incWit with lo = new_lo; |> in
  Nondeterminism.return new_wit

val monPerformFence: pre_execution -> incState -> action -> Nondeterminism.t execution_witness
let monPerformFence pre s a =
  (if is_seq_cst a then
     monAddToSc pre a s
   else
     Nondeterminism.return s.incWit.sc)    >>= fun new_sc ->
  let new_wit = <| s.incWit with sc = new_sc; |> in
  Nondeterminism.return new_wit

val monStep: pre_execution -> incState -> Nondeterminism.t (action * incState)
let monStep pre s =

  let uncommitted_actions = 
    Set_extra.toList (Set.difference pre.actions s.incCommitted) in
  Nondeterminism.pick uncommitted_actions >>= fun a ->

  match a with
  | Lock _ _ _ _      -> monPerformLock pre s a
  | Unlock _ _ _      -> monPerformUnlock pre s a
  | Load _ _ _ _ _    -> monPerformLoad pre s a
  | Store _ _ _ _ _   -> monPerformStore pre s a
  | RMW _ _ _ _ _ _   -> monPerformRmw pre s a
  | Fence _ _ _       -> monPerformFence pre s a
  | Blocked_rmw _ _ _ -> monPerformBlocked_rmw pre s a
  | Alloc _ _ _       -> Nondeterminism.kill (Nondeterminism.Error "Allocs not supported")
  | Dealloc _ _ _     -> Nondeterminism.kill (Nondeterminism.Error "Deallocs not supported")
  end                         >>= fun new_wit ->

  let new_committed = Set.insert a s.incCommitted in
  let new_pre = preRestrict pre new_committed in
  let new_ex = (new_pre, new_wit, getRelations new_pre new_wit) in

  (* TODO: break down the consistency predicates in stepwise predicates *)
  (* monCheckConsistency new_ex                          >> *)
  (* TODO: prove instead of assert that the following always holds *)  
  monCheckWitRestrict new_wit s.incCommitted s.incWit >>

  monCheckCommitmentOrder pre.actions new_ex s.incCommitted a     >>

  let new_state = <| incWit       = new_wit; 
                     incCommitted = new_committed; |> in
  Nondeterminism.return (a, new_state)



(* The symbolic model -------------------------------------------------- *)

(* The symbolic model uses a custom equality over cvalues *)

type threeStateBoolean = 
  | TTrue
  | TUnknown
  | TFalse

instance (Eq threeStateBoolean)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

type equalityCvalue =
  cvalue -> cvalue -> threeStateBoolean

val initialEqualityCvalue: equalityCvalue
let initialEqualityCvalue left right =
  if left = right then TTrue else TUnknown

val standardEqualityCvalue: equalityCvalue
let standardEqualityCvalue left right =
  if left = right then TTrue else TFalse

(* We have a different type of state, because pre-executions and the
   equality over cvalues can be updated. *)

type symState =
<| symPre:            pre_execution; 
   symWit:            execution_witness;
   symCommitted:      set action;
   symEqualityCvalue: equalityCvalue;
   symUndefinedness:  list undefinedness;
|>

instance (Show symState)
  let show state =
    "(pre_ex: " ^ show (Set.map aid_of state.symPre.actions) ^  
    ", wit: " ^ show state.symWit ^
    ", committed: " ^ show (Set.map aid_of state.symCommitted) ^ 
    ", eq: " ^ "TODO" ^ ")"
end

val defaultLk: location_kind
let defaultLk = Non_Atomic

val symInitialPre: pre_execution
let symInitialPre = 
  <| actions = {}; 
     threads = {};
     lk = (fun _ -> defaultLk);
     sb = {};
     asw = {};
     dd = {}; 
  |>

val symInitialState: pre_execution -> symState
let symInitialState pre = 
  <| symPre = pre;
     symWit = empty_witness;
     symCommitted = {};
     symEqualityCvalue = initialEqualityCvalue;
     (* TODO: not true! *)
     symUndefinedness = [];
  |>

(* The symbolic model allows the threadwise local semantics to build
   the pre-execution step by step, as opposed to generate full
   pre-executions. *)

type preExStep = 
  <| newAction    : action;
     sbBefore     : set aid;
     ddBefore     : set aid;
     aswBefore    : set aid;
     locationKind : maybe location_kind;
  |>

instance (Show preExStep)
  let show step = 
    "(Action: "     ^ show step.newAction ^
    ", sbBefore: "  ^ show step.sbBefore ^
    ", ddBefore: "  ^ show step.ddBefore ^
    ", aswBefore: " ^ show step.aswBefore ^
    ", locKind: "   ^ show step.locationKind ^ ")"
end

val symUpdatePreEx: symState -> preExStep -> symState
let symUpdatePreEx s step = 
  let pre = s.symPre in
  let new_lk = match (step.locationKind, loc_of step.newAction) with
               | (Just loc_kind, Just loc) -> (fun x -> if x = loc then loc_kind else pre.lk x)
               | _                         -> pre.lk
               end in
  let extra_sb  = Set.cross {a | forall (a IN pre.actions) | aid_of a IN step.sbBefore}  {step.newAction} in
  let extra_dd  = Set.cross {a | forall (a IN pre.actions) | aid_of a IN step.ddBefore}  {step.newAction} in
  let extra_asw = Set.cross {a | forall (a IN pre.actions) | aid_of a IN step.aswBefore} {step.newAction} in
  let new_pre = <| actions = Set.insert step.newAction pre.actions;
                   threads = Set.insert (tid_of step.newAction) pre.threads;
                   lk      = new_lk;
                   sb      = pre.sb union extra_sb;
                   asw     = pre.asw union extra_asw;
                   dd      = pre.dd union extra_dd;
                |> in
  (*
  let extra_mo = if is_write step.newAction && is_at_atomic_location new_lk step.newAction then
                    {(a, step.action) | forall (a IN s.preEx.actions)
                     | a IN s.committed && a <> step.action && is_write a && loc_of a = loc_of step.action} 
                 else {} in
  let new_mo = Set.(union) s.exWitness.mo extra_mo in
  let new_wit = <| s.exWitness with mo = new_mo |> in
  <|s with preEx = new_pre; exWitness = new_wit; |> *)
  <| s with symPre = new_pre; |>



(* The return type of the step function. The threadwise model wants to
   know which values are being considered equal when a new rf-edge is
   formed. *)

type symStep = 
  | ConcurrencyTau of action * symState

  (* The first cvalue is the value written, the second the value read. *)
  | ReadsFrom      of cvalue * cvalue * action * symState 

instance (Show symStep)
  let show step = 
    match step with
    | ConcurrencyTau a state  -> 
        "Tau (" ^ show (aid_of a) ^ ", " ^ show state ^ ")"
    | ReadsFrom v1 v2 a state -> 
        "ReadsFrom (" ^ show (aid_of a) ^ ", " ^ show v2 ^ " <- " ^ show v1 ^ ", " ^ show state ^ ")"
    end
end

val stateOf: symStep -> symState
let stateOf step = 
  match step with
  | ConcurrencyTau _ s -> s
  | ReadsFrom _ _ _ s  -> s
  end

val actionOf: symStep -> action
let actionOf step = 
  match step with
  | ConcurrencyTau a _ -> a
  | ReadsFrom _ _ a _  -> a
  end

val symPerformLoad: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symPerformStore: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symPerformRmw: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symPerformBlocked_rmw: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symPerformLock: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symPerformUnlock: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symPerformFence: symState -> action -> equalityCvalue -> Nondeterminism.t symStep

val symStep: symState -> equalityCvalue -> Nondeterminism.t symStep
let symStep s eq =
  (* TODO: this is not correct! *)
  let incState = <| incWit = s.symWit; 
                    incCommitted = s.symCommitted; |> in
  monStep s.symPre incState >>= fun (a, newIncState) ->
  let newSymState = <| s with symWit = newIncState.incWit;
                              symCommitted = newIncState.incCommitted; |> in
  Nondeterminism.return (ConcurrencyTau a newSymState)
