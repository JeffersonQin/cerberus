[Update of the reduction of indeterminately sequenced expressions]

A prototype of the idead described in Knote02 is now implemented in Haskell
for miniCore (Core - pure expressions / binders). And it is being ported to
lem and the full Core.

The rewriting system has changed a lot. It now has four stages. Here is first
a description of workings for miniCore and assuming a unique indet expression:

The rewriting system starts from a miniCore expression:

  e ::= a                  atom
     |  f                  the unique indet expression
     |  e1; e2             seq operator
     |  e1 || ... || ek    unseq operator

and works internally with a extension of the language:

  e ::= ...
     | ^{ e }    annotation meaning that the inner expression is either implied
                 by the syntax of the original expression to be before the indet
                 expression, or this choice has been made in the current
                 derivation.
     | v{ e }    Similar, but placing the inner expression after the indet
                 expression.

The output is a set of miniCore (without annotations)

The four stages:

  * "zero"  in this stage, we check wether a given expression contains the indet
            expression and return a set of expressions which are nearly the
            original one:
              - assuming the graph based view of the ordering (where the two new
                constructors are transparent to the calculation of sb), the
                input and output expressions have the same ordering.
                
              - the atoms which are ordered according to SB are annotated as
                such in the output expressions (NOTE: sometime an annotation
                pack several atoms and not just one).
                
              - for the atoms which aren't ordered according to SB, there is an
	        output expression with the annotation corresponding to either
		ordering choice.
            
	    Something to note is that, if we ignore what happens with the
	    unsequencing operator, this stage is a deterministic partial
	    application. If the given expression does not contain the indet
	    expression, then nothing is associated. Otherwise, the only
	    non-deterministic part comes from the annotations of the 3rd point
	    which are produced at the level of the unsequencing operators by
	    calling the second stage "one" one expression which are unsequenced
	    with the one containing the indet expression.
    
    ----------    -----------------------    -----------------------
    f  -0->  f    (f; e2)  -0->  f; v{e2}    (e1; f)  -0->  ^{e1}; f
    
    
    e1  -/0->    e2 -0-> e2'         e1  -0->  e1'
    ------------------------    -----------------------
    e1; e2  -0->  ^{e1}; e2'    e1; e2  -0-> e1'; v{e2}
    
    exists i IN {1..k}, ei  -0->  ei'
    forall j <> i, ej -d-> ej'              (-d-> is a transition from "one"
                                                  with direction d, see later)
    --------------------------------------
    e1 || .. || ek  -0->  e1' || .. || ek'


  * "one"  this stage as described earlier, make all the possible ordering
           choices for the atoms for sb ordered with the indet expression.
	   It is total application (that terminates on a unique step), which in
	   addition to an expression returns a "direction" (before or after)
	   which it uses on recursive calls. Morally it returns "before" if
	   it only has choosen to order atoms before the indet expression,
	   otherwise it returns "after".
    
    -------------    -------------
    a  -^->  ^{a}    a  -v->  v{a}
    
    ---------------------    ---------------------
    f; e2  -v->  f; v{e2}    e1; f  -^->  ^{e1}; f
    
    e1  --d1--> e1'  ..  ek  --dk--> ek'
    d = if (forall i IN {1..k}, dk = ^) then ^ else v
    -------------------------------------------------
        e1 || .. || ek  -- d --> e1' || .. || ek'


    * "two"  this stages fusion the annotations and bring them to the root of
             the abstract syntax. By doing so, brakes the apparent SB order
	     implied by the syntax (eg. by replacing some seq expression by
	     an unseq expression). However this is done without loss of
	     information thanks to the annotations. Also these "breaking" are
	     bottom-up, hence when we extend the scheme to the full Core with
	     in particular binders, we can properly keep symbolic names and the
	     expressions they bind together which we don't know how to do with
	     the direct "graph based" approach to reducing indet expressions.