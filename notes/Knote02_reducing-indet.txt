[Indeterminately-sequenced expressions (a.k.a. C function calls)]

Here we deal with the ordering of indeterminately-sequenced (indet)
expressions. These expressions correspond to the elaboration of the body of C
functions when they are called. An indet expression must be sequenced in one
way are the other with any actions with which it is originally said to be
unsequenced.
Let us have in Core a constructor for indet expression: [e]_k, where e is an
expression and k a unique index. Then in the expression:
  A >> B || [C]_k

C must be ordered with A and B, and there are 3 possible resulting sb-orders:
  * C --sb-> A (and by transitivity C --sb--> B)
  * A --sb--> C --sb--> B
  * B --sb--> C (and by transitivity A --sb--> C)

Additionally, if the weak sequencing operator (>>) is replaced by an atomic
sequencing operator (|>), then the second ordering is no longer allowed. This
models the semantics of C postfix increment/decrement.

To compute the set of possible orderings of a Core expression with indet
sub-expressions, we defined a preliminary reduction stage such that for any
expression the set of normal forms are Core expressions without indet
sub-expressions, each corresponding to a sb-order.
For example for the expression considered before, the set of normal forms is:
  C; A; B
  A ; C; B
  A; B; C

The LTS semantics for Core (without indet expressions) can then be run without
modification on the normal forms.

In Core's syntax, we need to add a second constructor (in addition to [e]_k) to
delimitated the context with which an indet expression has to be ordered.
Indeed, in C this indeterminated sequencing of function call body is localised
to C expressions because of the presence of sequence point everywhere in C
statements. (NOTE: we could do without these delimitation constructs in Core,
but this be inefficient). We write: ?>_k e <?_k, for






To produce all the possible ordering of a Core expression containing some indet
sub-expression, we use a ND reduction system over Core expression such that for
any given Core expression, the set of normal forms correspond to the set of
possible ordering.
This reduction system works over an extension of the Core syntax: we add two new
constructors: ^{e}_k (resp. v{e}_k) (where e is an expression), with meaning
"the expression e will be sequence-before (resp. sequence-after) the indet
expression with index k".
The reduction system progressively encapsulate the actions of a Core expression
with a ^{} v{} until they are all partitionned between these to tags, giving an
expression of the following shape:

  ^{e1}_k || [e]_k || v{e2}_k

which is then reduced to:
  
  e1; e; e2






--------------------------------------------------------------------------------
                         -------------    -------------
                         a --^--> ^{a}    a --v--> v{a}

                     e1 --^--> e1'            e2 --v--> e2'
                 ---------------------    ---------------------
                 e1; e2 --^--> e1'; e2    e1; e2 --v--> e1; e2'

                    e1 --v--> e1'               e2 --^--> e2'
              ------------------------    ------------------------
              e1; e2 --v--> e1'; v{e2}    e1; e2 --v--> ^{e1}; e2'

                                ej --^/v--> ej'
              ---------------------------------------------------
              e1 || .. ej .. || ek --^/v--> e1 || .. ej' .. || ek

================================================================================

          ----------------------------    ----------------------------
          ^{e1}; ^{e2} ----> ^{e1; e2}    v{e1}; v{e2} ----> v{e1; e2}

      --------------------------------    --------------------------------
      ^{e1} || ^{e2} ----> ^{e1 || e2}    v{e1} || v{e2} ----> v{e1 || e2}

                        ---------------------------------
                        ^{e1}; v{e2} ----> ^{e1} || v{e2}

================================================================================

                  -------------------------------------------
                  |> ^{e1} || [e} || v{e2} <| ----> e1; e; e2

