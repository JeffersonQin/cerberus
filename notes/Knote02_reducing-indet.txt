[Indeterminately-sequenced expressions (a.k.a. C function calls)]

Here we deal with the ordering of indeterminately-sequenced (indet)
expressions. These expressions correspond to the elaboration of the body of C
functions when they are called. An indet expression must be sequenced in one
way or the other with any actions with which it is originally said to be
unsequenced.
Let us have in Core a constructor for indet expression: [e]_k, where e is an
expression and k a unique index. Then in the expression:
  A >> B || [C]_k

C must be ordered with A and B, and there are 3 possible resulting sb-orders:
  * C --sb-> A (and by transitivity C --sb--> B)
  * A --sb--> C --sb--> B
  * B --sb--> C (and by transitivity A --sb--> C)

Additionally, if the weak sequencing operator (>>) is replaced by an atomic
sequencing operator (|>), then the second ordering is no longer allowed. This
models the semantics of C postfix increment/decrement.

To compute the set of possible orderings of a Core expression with indet
sub-expressions, we defined a preliminary reduction stage such that for any
expression the set of normal forms are Core expressions without indet
sub-expressions, each corresponding to a sb-order.
For example for the expression considered before, the set of normal forms is:
  C; A; B
  A ; C; B
  A; B; C

The LTS semantics for Core (without indet expressions) can then be run without
modification on the normal forms (note the reduction also gets rid of the atomic
sequencing operator, since in the absence of any indet expression it behaves
like the weak sequencing operator).

In Core's syntax, we need to add a second constructor (in addition to [e]_k) to
delimit the context within which an indet expression has to be ordered.
Indeed, in C this indeterminate sequencing of function call bodies is localised
to C expressions because of the presence of sequence points everywhere in C
statements. (NOTE: we could do without these delimiting constructs in Core,
but this would be inefficient). We write: ?>_k e <?_k, for an expression e which is
the scope of an indet expression indexed k.   

--------------------------------------------------------------------------------

The reduction system works over an extension of the Core syntax: we add two new
constructors: ^{e}_k (resp. v{e}_k) (where e is an expression), with meaning
"the expression e will be sequenced-before (resp. sequenced-after) the indet
expression with index k".
The reduction system progressively encapsulates the actions of a Core expression
with a ^{} v{} until they are all partitioned between these two tags, giving an
expression of the following shape:

  ^{e1}_k || [e]_k || v{e2}_k

which is then reduced to:
  
  e1; e; e2

The reduction occurs in three stages, first actions are progressively tagged one
way or the other:
                         -------------    -------------
                         a --^--> ^{a}    a --v--> v{a}

                     e1 --^--> e1'            e2 --v--> e2'
                 ---------------------    ---------------------
                 e1; e2 --^--> e1'; e2    e1; e2 --v--> e1; e2'

                    e1 --v--> e1'               e2 --^--> e2'
              ------------------------    ------------------------
              e1; e2 --v--> e1'; v{e2}    e1; e2 --v--> ^{e1}; e2'

                                ej --^/v--> ej'
              ---------------------------------------------------
              e1 || .. ej .. || ek --^/v--> e1 || .. ej' .. || ek


Then the taggings are brought up in the AST (merging when possible):
          ----------------------------    ----------------------------
          ^{e1}; ^{e2} ----> ^{e1; e2}    v{e1}; v{e2} ----> v{e1; e2}

      --------------------------------    --------------------------------
      ^{e1} || ^{e2} ----> ^{e1 || e2}    v{e1} || v{e2} ----> v{e1 || e2}

                        ---------------------------------
                        ^{e1}; v{e2} ----> ^{e1} || v{e2}

Until there is a partitioning at the level of the boundary:
                  -------------------------------------------
                  ?> ^{e1} || [e} || v{e2} <? ----> e1; e; e2


Here the rule shows only one indet expressions, when several are present the
same reductions are done but by strictely ordering the ordering of each indet
expressions (no mixing).
