[{"questions":[{"tests":["provenance_basic_global_yx.c","provenance_basic_global_xy.c","provenance_basic_auto_yx.c","provenance_basic_auto_xy.c"],"question":"Q1. Must the pointer used for a memory access have the right provenance, i.e. be derived from the pointer to the original allocation (with undefined behaviour otherwise)? (This lets compilers do provenance-based alias analysis)\n"},{"tests":["provenance_equality_global_yx.c","provenance_equality_global_xy.c","provenance_equality_global_fn_yx.c","provenance_equality_global_fn_xy.c"],"question":"Q2. Can equality testing on pointers be affected by pointer provenance information?\n"},{"tests":["provenance_roundtrip_via_intptr_t.c"],"question":"Q3. Can one make a usable pointer via casts to intptr t and back?\n"}],"section":"Pointer provenance"},{"questions":[{"tests":["provenance_roundtrip_via_unsigned_long.c"],"question":"Q4. Can one make a usable pointer via casts to unsigned long and back?\n"},{"tests":["provenance_basic_using_intptr_t_global_yx.c","provenance_basic_using_intptr_t_global_xy.c"],"question":"Q5. Must provenance information be tracked via casts to integer types and integer arithmetic?\n"}],"section":"Pointer provenance via integer types"},{"questions":[{"tests":["provenance_tag_bits_via_uintptr_t_1.c"],"question":"Q6. Can one use bit manipulation and integer casts to store information in unused bits of pointers?\n"},{"tests":["provenance_equality_uintptr_t_global_yx.c","provenance_equality_uintptr_t_global_xy.c"],"question":"Q7. Can equality testing on integers that are derived from pointer values be affected by their provenance?\n"},{"tests":["provenance_multiple_1_global.c","provenance_multiple_2_global.c","provenance_multiple_3_global_yx.c","provenance_multiple_4_global_yx.c"],"question":"Q8. Should intra-object pointer subtraction give provenance-free integer results?\n"},{"tests":["pointer_offset_from_subtraction_1_global.c","pointer_offset_from_subtraction_1_auto.c","pointer_offset_from_subtraction_1_malloc.c","pointer_offset_constant_8_malloc.c"],"question":"Q9. Can one make a usable offset between two separately allocated objects by inter-object subtraction (using either pointer or integer arithmetic), to make a usable pointer to the second by adding the offset to the first?\n"},{"tests":["pointer_offset_from_subtraction_2_global.c","pointer_offset_from_subtraction_2_auto.c"],"question":"Q10. Presuming that one can have valid pointers with multiple provenances, does an inter-object pointer subtraction give a value with explicitly-unknown provenance or something more specific?\n"},{"tests":["pointer_offset_xor_global.c","pointer_offset_xor_auto.c"],"question":"Q11. Is the XOR linked list idiom supported?\n"},{"tests":["pointer_arith_algebraic_properties_2_global.c","pointer_arith_algebraic_properties_3_global.c","pointer_arith_algebraic_properties_2_auto.c","pointer_arith_algebraic_properties_3_auto.c."],"question":"Q12. For arithmetic over prove- nanced integer values, is the provenance of the result invariant under plus/minus associativity?\n"}],"section":"Pointers involving multiple provenance"},{"questions":[{"tests":["pointer_copy_memcpy.c"],"question":"Q13. Can one make a usable copy of a pointer by copying its representation bytes using the library memcpy?\n"},{"tests":["pointer_copy_user_dataflow_direct_bytewise.c"],"question":"Q14. Can one make a usable copy of a pointer by copying its representation bytes (unchanged) in user code?\n"},{"tests":["pointer_copy_user_dataflow_indirect_bytewise.c"],"question":"Q15. Can one make a usable copy of a pointer by copying its representation bytes by user code that indirectly computes the identity function on those bytes?\n"},{"tests":["pointer_copy_user_ctrlflow_bytewise.c","pointer_copy_user_ctrlflow_bitwise.c","pointer_copy_user_dataflow_direct_bitwise.c","provenance_basic_mixed_global_offset+4.c","provenance_basic_mixed_global_offset-4.c","provenance_basic_mixed_global_offset-64.c","provenance_basic_mixed_auto_offset+4.c","provenance_basic_mixed_auto_offset-4.c","provenance_basic_mixed_auto_offset-64.c"],"question":"Q16. Can one carry provenance through dataflow alone or also through control flow? \n"}],"section":"Pointer provenance via pointer represenatation copying"},{"questions":[{"tests":["provenance_union_punning_1_global.c"],"question":"Q17. Is type punning between integer and pointer values allowed?\n"},{"tests":["provenance_union_punning_2_global_yx.c","provenance_union_punning_2_global_xy.c","provenance_union_punning_2_auto_xy.c"],"question":"Q18. Does type punning between integer and pointer values preserve provenance?\n"}],"section":"Pointer provenance and union type punning"},{"questions":[{"tests":["provenance_via_io_percentp_global.c","provenance_via_io_bytewise_global.c","provenance_via_io_uintptr_t_global.c"],"question":"Q19. Can one make a usable pointer via IO?\n"},{"tests":["pointer_from_concrete_address_1.c","pointer_from_concrete_address_2.c"],"question":"Q20. Can one make a usable pointer from a concrete address (of device memory)?\n"}],"section":"Pointer provenance via IO"},{"questions":[{"tests":["pointer_stability_1.c","pointer_stability_2.c","pointer_stability_3.c"],"question":"Q21. Are pointer values stable?\n"}],"section":"Stability of pointer values"},{"questions":[{"tests":["pointer_comparison_eq_1_global.c","pointer_comparison_eq_1_auto.c","pointer_comparison_eq_2_global.c","pointer_comparison_eq_2_auto.c"],"question":"Q22. Can one do == comparison between pointers to objects of non-compatible types?\n"},{"tests":["klw-itp14-2.c"],"question":"Q23. Can one do == comparison between pointers (to objects of compatible types) with different provenances that are not strictly within their original allocations?\n"},{"tests":["besson_blazy_wilke_6.2.c"],"question":"Q24. Can one do == comparison of a pointer and (void*)-1?\n"}],"section":"Pointer equality comparison"},{"questions":[{"tests":["pointer_comparison_rel_1_global.c","pointer_comparison_rel_1_auto.c"],"question":"Q25. Can one do relational comparison (with <, >, <=, or >=) of two pointers to separately allocated objects (of compatible object types)?\n"},{"tests":["pointer_comparison_rel_substruct.c"],"question":"Q26. Can one do relational comparison (with <, >, <=, or >=) of a pointer to a structure member and one to a sub-member of another member, of compatible object types?\n"},{"tests":["pointer_comparison_rel_different_type_members.c"],"question":"Q27. Can one do relational comparison (with <, >, <=, or >=) of pointers to two members of a structure that have incompatible types?\n"}],"section":"Pointer relational comparison"},{"questions":[{"tests":["null_pointer_1.c"],"question":"Q28. Can one make a null pointer by casting from a non-constant integer expression?\n"},{"tests":["null_pointer_2.c"],"question":"Q29. Can one assume that all null pointers have the same representation?\n"},{"tests":["null_pointer_3.c"],"question":"Q30. Can null pointers be assumed to have all-zero representation bytes?\n"}],"section":"Null pointers"},{"questions":[{"tests":["cheri_03_ii.c","cheri_03_ii_char.c"],"question":"Q31. Can one construct out-of-bounds (by more than one) pointer values by pointer arithmetic (without undefined behaviour)?\n"},{"tests":["pointer_add_wrap_1.c"],"question":"Q32. Can one form pointer values by pointer addition that overflows (without undefined behaviour)?\n"},{"tests":["pointer_add_wrap_2.c"],"question":"Q33. Can one assume pointer addition wraps on overflow?\n"},{"tests":["cast_struct_inter_member_1.c"],"question":"Q34. Can one move among the members of a struct using representation-pointer arithmetic and casts?\n"},{"tests":["struct_inter_submember_1.c"],"question":"Q35. Can one move between subobjects of the members of a struct using pointer arithmetic?\n"},{"tests":["ubc_addr_null_1.c"],"question":"Q36. Can one implement offsetof using the addresses of members of a NULL struct pointer?\n"}],"section":"Pointer arithmetic"},{"questions":[{"tests":["cast_struct_and_first_member_1.c"],"question":"Q37. Are usable pointers to a struct and to its first member interconvertable?\n"},{"tests":["cast_union_and_member_1.c","struct_initialise_members.c"],"question":"Q38. Are usable pointers to a union and to its current member interconvertable?\n"}],"section":"Casts between pointer types"},{"questions":[{"tests":["cast_struct_isomorphic.c","cast_struct_same_prefix.c"],"question":"Q39. Given two different structure types sharing a prefix of members that have compatible types, can one cast a usable pointer to an object of the first to a pointer to the second, that can be used to read and write members of that prefix (with strict-aliasing disabled and without packing variation)?\n"},{"tests":["read_union_same_prefix_visible.c"],"question":"Q40. Can one read from the initial part of a union of structures sharing a common initial sequence via any union member (if the union type is visible)?\n"},{"tests":["write_union_same_prefix_visible.c"],"question":"Q41. Is writing to the initial part of a union of structures sharing a common initial sequence allowed via any union member (if the union type is visible)?\n"},{"tests":["union_punning_gcc_1.c","union_punning_gcc_2.c"],"question":"Q42. Is type punning by writing and reading different union members allowed (if the lvalue is syntactically obvious)?\n"}],"section":"Accesses to related structure and union types"},{"questions":[{"tests":["pointer_comparison_eq_zombie_1.c","pointer_comparison_eq_zombie_2.c"],"question":"Q43. Can one inspect the value, (e.g. by testing equality with ==) of a pointer to an object whose lifetime has ended (either at a free() or block exit)?\n"},{"tests":["compcertTSO-2.c"],"question":"Q44. Is the dynamic reuse of allocation addresses permitted?\n"}],"section":"Pointer lifetime"},{"questions":[{"tests":["null_pointer_4.c"],"question":"Q45. Can accesses via a null pointer be assumed to give runtime errors, rather than give rise to undefined behaviour?\n"},{"tests":["read_via_invalid_1.c"],"question":"Q46. Can reads via invalid pointers be assumed to give runtime errors or unspecified values, rather than undefined behaviour?\n"}],"section":"Invalid accesses"},{"questions":[{"tests":["trap_representation_1.c"],"question":"Q47. Can one reasonably assume that no types have trap representations? \n"},{"tests":["trap_representation_1.c","trap_representation_2.c","trap_representation_3.c","frama-c-2013-03-13-2.c","frama-c-2013-03-13-3.c","frama-c-2013-03-13-3-uc.c"],"question":"Q48. Does reading an uninitialised object give rise to undefined behaviour?\n"}],"section":"Trap representation"},{"questions":[{"tests":["unspecified_value_library_call_argument.c"],"question":"Q49. Can library calls with unspecified-value arguments be assumed to execute with an arbitrary choice of a concrete value (not necessarily giving rise to undefined behaviour)?\n"},{"tests":["unspecified_value_control_flow_choice.c"],"question":"Q50. Can control-flow choices based on unspecified values be assumed to make an arbitrary choice (not giving rise to undefined behaviour)?\n"},{"tests":null,"question":"Q51. In the absence of any writes, is an unspecified value potentially unstable, i.e., can multiple usages of it give different values?\n"},{"tests":["unspecified_value_strictness_int.c","unspecified_value_strictness_unsigned_char.c","unspecified_value_strictness_mod_1.c","unspecified_value_strictness_mod_2.c"],"question":"Q52. Do operations on unspecified values result in unspecified values?\n"},{"tests":["unspecified_value_strictness_and_1.c"],"question":"Q53. Do bitwise operations on unspecified values result in unspecified values?\n"},{"tests":["unspecified_value_daemonic_1.c"],"question":"Q54. Must unspecified values be considered daemonically for identification of other possible undefined behaviours?\n"},{"tests":["unspecified_value_struct_copy.c","unspecified_value_union_1.c"],"question":"Q55. Can a structure containing an unspecified-value member can be copied as a whole?\n"},{"tests":["besson_blazy_wilke_bitfields_1u.c"],"question":"Q56. Given multiple bitfields that may be in the same word, can one be a well-defined value while another is an unspecified value?\n"},{"tests":["unspecified_value_representation_bytes_1.c"],"question":"Q57. Are the representation bytes of an unspecified value themselves also unspecified values? (not an arbitrary choice of concrete byte values)\n"},{"tests":["unspecified_value_representation_bytes_4.c"],"question":"Q58. If one writes some but not all of the representation bytes of an uninitialized value, do the other representation bytes still hold unspecified values?\n"},{"tests":["unspecified_value_representation_bytes_2.c","unspecified_value_representation_bytes_3.c"],"question":"Q59. If one writes some but not all of the representation bytes of an uninitialized value, does a read of the whole value still give an unspecified value?\n"}],"section":"Unspecified values"},{"questions":[{"tests":["padding_struct_copy_1.c","padding_struct_copy_2.c","padding_struct_members_copy.c","padding_struct_copy_3.c"],"question":"Q60. Can structure-copy copy padding?\n"},{"tests":["padding_unspecified_value_1.c"],"question":"Q61. After an explicit write of a padding byte, does that byte hold a well-defined value? (not an unspecified value)\n"},{"tests":["padding_unspecified_value_2.c","padding_unspecified_value_3.c","padding_unspecified_value_4.c"],"question":"Q62. After an explicit write of a padding byte followed by a write to the whole structure, does the padding byte hold a well-defined value? (not an unspecified value)\n"},{"tests":null,"question":"Q63. After an explicit write of a padding byte followed by a write to adjacent members of the structure, does the padding byte hold a well-defined value? (not an unspecified value)\n"},{"tests":["padding_unspecified_value_7.c","padding_unspecified_value_8.c"],"question":"Q64. After an explicit write of zero to a padding byte followed by a write to adjacent members of the structure, does the padding byte hold a well-defined zero value? (not an unspecified value)\n"},{"tests":["padding_unspecified_value_5.c"],"question":"Q65. After an explicit write of a padding byte followed by a write to a non-adjacent member of the whole structure, does the padding byte hold a well-defined value? (not an unspecified value)\n"},{"tests":["padding_unspecified_value_6.c"],"question":"Q66. After an explicit write of a padding byte followed by a writes to adjacent members of the whole structure, but accessed via pointers to the members rather than via the structure, does the padding byte hold a well-defined value? (not an unspecified value)\n"},{"tests":["padding_subunion_1.c","padding_subunion_2.c"],"question":"Q67. Can one use a malloc’d region for a union that is just big enough to hold the subset of members that will be used?\n"},{"tests":["padding_struct_copy_of_representation_bytes.c"],"question":"Q68. Can the user make a copy of a structure or union by copying just the representation bytes of its members and writing junk into the padding bytes?\n"},{"tests":["cheri_08_last_word.c"],"question":"Q69. Can one read an object as aligned words without regard for the fact that the object’s extent may not include all of the last word?\n"},{"tests":null,"question":"Q70. Does concurrent access to two (non-bitfield) distinct members of a structure constitute a data race?\n"},{"tests":null,"question":"Q71. Does concurrent access to a structure member and a padding byte of that structure constitute a data race?\n"},{"tests":null,"question":"Q72. Does concurrent (read or write) access to an unspecified value constitute a data race?\n"}],"section":"Structure and union padding"},{"questions":[{"tests":["effective_type_1.c","effective_type_10.c"],"question":"Q73. Can one do type punning between arbitrary types?\n"},{"tests":["effective_type_2.c"],"question":"Q74. Can one do type punning between distinct but isomorphic structure types?\n"},{"tests":["effective_type_3.c","effective_type_4.c"],"question":"Q75. Can an unsigned character array with static or automatic storage duration be used (in the same way as a malloc’d region) to hold values of other types?\n"},{"tests":["effective_type_5.c"],"question":"Q76. After writing a structure to a malloc’d region, can its members can be accessed via pointers of the individual member types?\n"},{"tests":["effective_type_6.c"],"question":"Q77. Can a non-character value be read from an uninitialised malloc’d region?\n"},{"tests":["effective_type_7.c"],"question":"Q78. After writing one member of a structure to a malloc’d region, can its other members be read?\n"},{"tests":["effective_type_8.c"],"question":"Q79. After writing one member of a structure to a malloc’d region, can a member of another structure, with footprint overlapping that of the first structure, be written?\n"},{"tests":["effective_type_9.c"],"question":"Q80. After writing a structure to a malloc’d region, can its members be accessed via a pointer to a different structure type that has the same leaf member type at the same offset?\n"},{"tests":["krebbers_biener_1.c"],"question":"Q81. Can one access two objects, within a malloc’d region, that have overlapping but non-identical footprint?\n"}],"section":"Effective types"},{"questions":[{"tests":null,"question":"Q82. Given a const-qualified pointer to an object defined with a non-const-qualified type, can the pointer be cast to a non-const-qualified pointer and used to mutate the object?\n"},{"tests":null,"question":"Q83. Can char and unsigned char be assumed to be 8-bit bytes?\n"},{"tests":null,"question":"Q84. Can one assume two’s-complement arithmetic?\n"},{"tests":null,"question":"Q85. In the absence of floating point, can one assume that no base types have multiple representations of the same value?\n"}],"section":"Others"}]