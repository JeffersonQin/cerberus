[{"tests":["provenance_basic_global_xy.c","provenance_basic_global_yx.c","provenance_basic_auto_xy.c","provenance_basic_auto_yx.c"],"section":"Basic provenance semantics for pointer values"},{"tests":["cheri_03_ii.c"],"section":"Can one construct out-of-bounds (by more than one) pointer values by pointer arithmetic?"},{"tests":["pointer_offset_from_ptr_subtraction_global_xy.c","pointer_offset_from_ptr_subtraction_global_yx.c","pointer_offset_from_ptr_subtraction_auto_xy.c","pointer_offset_from_ptr_subtraction_auto_yx.c"],"section":"Inter-object pointer arithmetic"},{"tests":["provenance_equality_global_xy.c","provenance_equality_global_yx.c","provenance_equality_auto_xy.c","provenance_equality_auto_yx.c","provenance_equality_global_fn_xy.c","provenance_equality_global_fn_yx.c"],"section":"Pointer equality comparison and provenance"},{"tests":["provenance_roundtrip_via_intptr_t.c"],"section":"Pointer/integer casts"},{"tests":["provenance_basic_using_uintptr_t_global_xy.c","provenance_basic_using_uintptr_t_global_yx.c","provenance_basic_using_uintptr_t_auto_xy.c","provenance_basic_using_uintptr_t_auto_yx.c","pointer_offset_from_int_subtraction_global_xy.c","pointer_offset_from_int_subtraction_global_yx.c","pointer_offset_from_int_subtraction_auto_xy.c","pointer_offset_from_int_subtraction_auto_yx.c","pointer_offset_xor_global.c","pointer_offset_xor_auto.c"],"section":"Inter-object integer arithmetic"},{"tests":["provenance_tag_bits_via_uintptr_t_1.c"],"section":"Pointer provenance for pointer bit manipulations"},{"tests":["pointer_arith_algebraic_properties_2_global.c","pointer_arith_algebraic_properties_3_global.c"],"section":"Algebraic properties of integer operations"},{"tests":["pointer_copy_memcpy.c"],"section":"Copying pointer values with memcpy()"},{"tests":["pointer_copy_user_dataflow_direct_bytewise.c"],"section":"Copying pointer values bytewise, with user-memcpy"},{"tests":["pointer_copy_user_ctrlflow_bytewise.c","pointer_copy_user_ctrlflow_bitwise.c"],"section":"Copying pointer values via control flow"},{"tests":["provenance_equality_uintptr_t_global_xy.c","provenance_equality_uintptr_t_global_yx.c","provenance_equality_uintptr_t_auto_xy.c","provenance_equality_uintptr_t_auto_yx.c"],"section":"Integer comparison and provenance"},{"tests":["provenance_union_punning_2_global_xy.c","provenance_union_punning_2_global_yx.c","provenance_union_punning_2_auto_xy.c","provenance_union_punning_2_auto_yx.c"],"section":"Pointer provenance and union type punning"},{"tests":["provenance_via_io_percentp_global.c","provenance_via_io_bytewise_global.c","provenance_via_io_uintptr_t_global.c"],"section":"Pointer provenance via IO"},{"tests":["pointer_from_integer_1i.c"],"section":"Can a function argument alias local variables of the function?"},{"tests":["pointer_from_integer_1ig.c","pointer_from_integer_1p.c","pointer_from_integer_1pg.c"],"section":"Allocation-address nondeterminism"},{"tests":["pointer_from_integer_2.c","pointer_from_integer_2g.c"],"section":"Can a function access local variables of its parent?"},{"tests":["provenance_lost_escape_1.c"],"section":"The problem with lost address-takens and escapes"}]