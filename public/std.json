{"1":{"title":"Scope","P1":"This International Standard specifies the form and establishes the interpretation of programs written in the C programming language. <foot>This International Standard is designed to promote the portability of C programs among a variety of data-processing systems. It is intended for use by implementors and programmers.</foot> It specifies <ul> <li>the representation of C programs;</li> <li>the syntax and constraints of the C language;</li> <li>the semantic rules for interpreting C programs;</li> <li>the representation of input data to be processed by C programs;</li> <li>the representation of output data produced by C programs;</li> <li>the restrictions and limits imposed by a conforming implementation of C.</li> </ul>\n","P2":"This International Standard does not specify <ul> <li>the mechanism by which C programs are transformed for use by a data-processing system;</li> <li>the mechanism by which C programs are invoked for use by a data-processing system;</li> <li>the mechanism by which input data are transformed for use by a C program;</li> <li>the mechanism by which output data are transformed after being produced by a C program;</li> <li>the size or complexity of a program and its data that will exceed the capacity of any specific data-processing system or the capacity of a particular processor;</li> <li>all minimal requirements of a data-processing system that is capable of supporting a conforming implementation.</li> </ul>\n"},"2":{"title":"Normative references","P1":"The following referenced documents are indispensable for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.\n","P2":"ISO/IEC 2382−1:1993, Information technology — Vocabulary — Part 1: Fundamental terms.\n","P3":"ISO 4217, Codes for the representation of currencies and funds.","P4":"ISO 8601, Data elements and interchange formats — Information interchange — Representation of dates and times.\n","P5":"ISO/IEC 10646, Information technology — Universal Coded Character Set (UCS).","P6":"IEC 60559:1989, Binary floating-point arithmetic for microprocessor systems (previously designated IEC 559:1989).\n","P7":"ISO 80000−2, Quantities and units — Part 2: Mathematical signs and symbols to be used in the natural sciences and technology.\n"},"3":{"1":{"P1":"<b>access</b>\n〈execution-time action〉to read or modify the value of an object\n","P2":"NOTE 1 Where only one of these two actions is meant, ‘‘read’’ or ‘‘modify’’ is used.\n","P3":"NOTE 2 ‘‘Modify’’ includes the case where the new value being stored is the same as the previous value.\n","P4":"NOTE 3 Expressions that are not evaluated do not access objects."},"2":{"P1":"<b>alignment</b>\nrequirement that objects of a particular type be located on storage\nboundaries with addresses that are particular multiples of a byte address\n"},"3":{"P1":"<b>argument</b>\nactual argument\nactual parameter (deprecated)\nexpression in the comma-separated list bounded by the parentheses in a\nfunction call expression, or a sequence of preprocessing tokens in the\ncomma-separated list bounded by the parentheses in a function-like macro\ninvocation\n"},"4":{"1":{"P1":"<b>implementation-defined behavior</b>\nunspecified behavior where each implementation documents\nhow the choice is made\n","P2":"EXAMPLE An example of implementation-defined behavior is the propagation of the high-order bit when a signed integer is shifted right.\n"},"2":{"P1":"<b>locale-specific behavior</b>\nbehavior that depends on local conventions of nationality, culture, and\nlanguage that each implementation documents\n","P2":"EXAMPLE An example of locale-specific behavior is whether the islower function returns true for characters other than the 26 lowercase Latin letters.\n"},"3":{"P1":"<b>undefined behavior</b>\nbehavior, upon use of a nonportable or erroneous program construct or\nof erroneous data, for which this International Standard imposes no\nrequirements\n","P2":"NOTE Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).\n","P3":"EXAMPLE An example of undefined behavior is the behavior on integer overflow.\n"},"4":{"P1":"<b>unspecified behavior</b>\nuse of an unspecified value, or other behavior where this International\nStandard provides two or more possibilities and imposes no further\nrequirements on which is chosen in any instance\n","P2":"EXAMPLE An example of unspecified behavior is the order in which the arguments to a function are evaluated.\n"},"P1":"<b>behavior</b>\nexternal appearance or action\n"},"5":{"P1":"<b>bit</b>\nunit of data storage in the execution environment large enough to hold an\nobject that may have one of two values\n","P2":"NOTE It need not be possible to express the address of each individual bit of an object.\n"},"6":{"P1":"<b>byte</byte>\naddressable unit of data storage large enough to hold any member of the\nbasic character set of the execution environment\n","P2":"NOTE 1 It is possible to express the address of each individual byte of an object uniquely.\n","P3":"NOTE 2 A byte is composed of a contiguous sequence of bits, the number of which is implementationdefined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit.\n"},"7":{"1":{"P1":"<b>character</b>\nsingle-byte character\n〈C〉 bit representation that fits in a byte\n"},"2":{"P1":"<b>multibyte character</b>\nsequence of one or more bytes representing a member of the extended\ncharacter set of either the source or the execution environment\n","P2":"NOTE The extended character set is a superset of the basic character set."},"3":{"P1":"<b>wide character</b>\nvalue representable by an object of type wchar_t, capable of\nrepresenting any character in the current locale\n"},"P1":"<b>character</b>\n〈abstract〉 member of a set of elements used for the organization,\ncontrol, orrepresentation of data\n"},"8":{"P1":"<b>constraint</b>\nrestriction, either syntactic or semantic, by which the exposition of\nlanguage elements is to be interpreted\n"},"9":{"P1":"<b>correctly rounded result</b>\nrepresentation in the result format that is nearest in value, subject to\nthe current rounding mode, to what the result would be given unlimited\nrange and precision\n"},"10":{"P1":"<b>diagnostic message</b>\nmessage belonging to an implementation-defined subset of the\nimplementation’s message output\n"},"11":{"P1":"<b>forward reference</b>\nreference to a later subclause of this International Standard that\ncontains additional information relevant to this subclause\n"},"12":{"P1":"<b>implementation</b>\nparticular set of software, running in a particular translation\nenvironment under particular control options, that performs translation\nof programs for, and supports execution of functions in, a particular\nexecution environment\n"},"13":{"P1":"<b>implementation limit</b>\nrestriction imposed upon programs by the implementation\n"},"14":{"P1":"<b>memory location</b>\neither an object of scalar type, or a maximal sequence of adjacent\nbit-fields all having nonzero width\n","P2":"NOTE 1 Two threads of execution can update and access separate memory locations without interfering with each other.\n","P3":"NOTE 2 A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (non-zero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be.\n","P4":"EXAMPLE A structure declared as\n<code>struct {\n    char a;\n    int b:5, c:11, :0, d:8;\n    struct { int ee:8; } e;\n  }</code>\ncontains four separate memory locations: The member a, and bit-fields d\nand e.ee are each separate memory locations, and can be modified\nconcurrently without interfering with each other. The bit-fields b and c\ntogether constitute the fourth memory location. The bit-fields b and c\ncannot be concurrently modified, but b and a, for example, can be.\n"},"15":{"P1":"<b>object</b>\nregion of data storage in the execution environment, the contents of which can represent values\n","P2":"NOTE When referenced, an object may be interpreted as having a particular type; see 6.3.2.1.\n"},"16":{"P1":"<b>parameter</b>\nformal parameter\nformal argument (deprecated)\nobject declared as part of a function declaration or definition that\nacquires a value on entry to the function, or an identifier from the\ncomma-separated list bounded by the parentheses immediately following the\nmacro name in a function-like macro definition\n"},"17":{"P1":"<b>recommended practice</b>\nspecification that is strongly recommended as being in keeping with\nthe intent of the standard, but that may be impractical for some\nimplementations\n"},"18":{"P1":"<b>runtime-constraint</b>\nrequirement on a program when calling a library function\n","P2":"NOTE 1 Despite the similar terms, a runtime-constraint is not a kind of constraint as defined by 3.8, and need not be diagnosed at translation time.\n","P3":"NOTE 2 Implementations that support the extensions in annex K are required to verify that the runtimeconstraints for a library function are not violated by the program; see K.3.1.4.\n"},"19":{"1":{"P1":"<b>implementation-defined value</b>\nunspecified value where each implementation documents how the choice\nis made\n"},"2":{"P1":"<b>indeterminate value</b>\neither an unspecified value or a trap representation\n"},"3":{"P1":"<b>unspecified value</b>\nvalid value of the relevant type where this International Standard\nimposes no requirements on which value is chosen in any instance\n","P2":"NOTE An unspecified value cannot be a trap representation."},"4":{"P1":"<b>trap representation</b>\nan object representation that need not represent a value of the object type\n"},"5":{"P1":"<b>perform a trap</b>\ninterrupt execution of the program such that no further operations\nare performed\n","P2":"NOTE In this International Standard, when the word ‘‘trap’’ is not immediately followed by ‘‘representation’’, this is the intended usage.2)\n"},"P1":"<b>value</b>\nprecise meaning of the contents of an object when interpreted as having\na specific type\n"},"20":{"P1":"⎡x⎤\nceiling of x: the least integer greater than or equal to x\n","P2":"EXAMPLE ⎡2. 4⎤ is 3, ⎡−2. 4⎤ is −2."},"21":{"P1":"⎣x⎦\nfloor of x: the greatest integer less than or equal to x\n","P2":"EXAMPLE <foot>For example, ‘‘Trapping or stopping (if supported) is disabled...’’ (F.8.2). Note that fetching a trap representation might perform a trap but is not required to (see 6.2.6.1).</foot>⎣2. 4⎦ is 2, ⎣−2. 4⎦ is −3.\n"},"title":"Terms, definitions, and symbols","P1":"For the purposes of this document, the following terms and definitions apply. Other terms are defined where they appear in italic type or on the left side of a syntax rule. Terms explicitly defined in this International Standard are not to be presumed to refer implicitly to similar terms defined elsewhere. Terms not defined in this International Standard are to be interpreted according to ISO/IEC 2382−1. Mathematical symbols not defined in this International Standard are to be interpreted according to ISO 80000−2.\n"},"4":{"title":"Conformance","P1":"In this International Standard, ‘‘shall’’ is to be interpreted as a requirement on an implementation or on a program; conversely, ‘‘shall not’’ is to be interpreted as a prohibition.\n","P2":"If a ‘‘shall’’ or ‘‘shall not’’ requirement that appears outside of a constraint or runtimeconstraint is violated, the behavior is undefined. Undefined behavior is otherwise indicated in this International Standard by the words ‘‘undefined behavior’’ or by the omission of any explicit definition of behavior. There is no difference in emphasis among these three; they all describe ‘‘behavior that is undefined’’.\n","P3":"A program that is correct in all other aspects, operating on correct data, containing unspecified behavior shall be a correct program and act in accordance with 5.1.2.3.\n","P4":"The implementation shall not successfully translate a preprocessing translation unit containing a \\#error preprocessing directive unless it is part of a group skipped by conditional inclusion.\n","P5":"A strictly conforming program shall use only those features of the language\nand library specified in this International Standard.<foot>A strictly\nconforming program can use conditional features (see 6.10.8.3) provided the\nuse is guarded by an appropriate conditional inclusion preprocessing\ndirective using the related macro.\nFor example:<code>\n\\#ifdef _ _STDC_IEC_559_ _ /* FE_UPWARD defined */\n/* ... */\nfesetround(FE_UPWARD);\n/* ... */\n\\#endif</code></foot> It shall not produce output dependent on any\nunspecified, undefined, or implementation-defined behavior, and shall not\nexceed any minimum implementation limit.\n","P6":"The two forms of conforming implementation are hosted and freestanding. A conforming hosted implementation shall accept any strictly conforming program. A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (clause 7) is confined to the contents of the standard headers <float.h>, <iso646.h>, <limits.h>, <stdalign.h>, <b><stdarg.h></b>, <b><stdbool.h></b>, <b><stddef.h></b>, <b><stdint.h></b>, and <b><stdnoreturn.h></b>. A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any strictly conforming program.<foot>This implies that a conforming implementation reserves no identifiers other than those explicitly reserved in this International Standard.</foot>\n","P7":"A conforming program is one that is acceptable to a conforming implementation.  <foot>Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon nonportable features of a conforming implementation.</foot>\n","P8":"An implementation shall be accompanied by a document that defines all implementationdefined and locale-specific characteristics and all extensions.\n"},"6":{"1":{"title":"Notation","P1":"In the syntax notation used in this clause, syntactic categories (nonterminals) are indicated by italic type, and literal words and character set members (terminals) by bold type. A colon (:) following a nonterminal introduces its definition. Alternative definitions are listed on separate lines, except when prefaced by the words ‘‘one of’’. An optional symbol is indicated by the subscript ‘‘opt’’, so that {  expressionopt } indicates an optional expression enclosed in braces.\n","P2":"For each different entity that an identifier designates, the identifier is visible (i.e., can be used) only within a region of program text called its scope. Different entities designated by the same identifier either have different scopes, or are in different name spaces. There are four kinds of scopes: function, file, block, and function prototype. (A function prototype is a declaration of a function that declares the types of its parameters.)\n","P3":"A summary of the language syntax is given in annex A."},"2":{"1":{"title":"Scopes of identifiers\nP1: >\n  An identifier can denote an object; a function; a tag or a member of\n  a structure, union, or enumeration; a typedef name; a label name; a\n  macro name; or a macro parameter. The same identifier can denote\n  different entities at different points in the program. A member of an\n  enumeration is called an enumeration constant. Macro names and macro\n  parameters are not considered further here, because prior to the\n  semantic phase of program translation any occurrences of macro names\n  in the source file are replaced by the preprocessing token sequences\n  that constitute their macro definitions.\nP2: >\n  For each different entity that an identifier designates, the\n  identifier is visible (i.e., can be used) only within a region of\n  program text called its scope. Different entities designated by the\n  same identifier either have different scopes, or are in different\n  name spaces. There are four kinds of scopes: function, file, block,\n  and function prototype. (A function prototype is a declaration of a\n  function that declares the types of its parameters.)\nP3: >\n  A label name is the only kind of identifier that has function scope.\n  It can be used (in a goto statement) anywhere in the function in which\n  it appears, and is declared implicitly by its syntactic appearance\n  (followed by a : and a statement).\nP4: >\n  Every other identifier has scope determined by the placement of its\n  declaration (in a declarator or type specifier). If the declarator or\n  type specifier that declares the identifier appears outside of any\n  block or list of parameters, the identifier has file scope, which\n  terminates at the end of the translation unit. If the declarator or\n  type specifier that declares the identifier appears inside a block or\n  within the list of parameter declarations in a function definition,\n  the identifier has block scope, which terminates at the end of the\n  associated block. If the declarator or type specifier that declares\n  the identifier appears within the list of parameter declarations in a\n  function prototype (not part of a function definition), the\n  identifier has function prototype scope, which terminates at the end\n  of the function declarator. If an identifier designates two different\n  entities in the same name space, the scopes might overlap. If so, the\n  scope of one entity (the inner scope) will end strictly before the\n  scope of the other entity (the outer scope). Within the inner scope,\n  the identifier designates the entity declared in the inner scope; the\n  entity declared in the outer scope is hidden (and not visible) within\n  the inner scope.\nP5: >\n  Unless explicitly stated otherwise, where this International Standard\n  uses the term ‘‘identifier’’ to refer to some entity (as opposed to\n  the syntactic construct), it refers to the entity in the relevant\n  name space whose declaration is visible at the point the identifier\n  occurs.\nP6: >\n  Two identifiers have the same scope if and only if their scopes\n  terminate at the same point.\nP7: >\n  Structure, union, and enumeration tags have scope that begins just\n  after the appearance of the tag in a type specifier that declares the\n  tag. Each enumeration constant has scope that begins just after the\n  appearance of its defining enumerator in an enumerator list. Any\n  other identifier has scope that begins just after the completion of\n  its declarator.\nP8: >\n  As a special case, a type name (which is not a declaration of an\n  identifier) is considered to have a scope that begins just after the\n  place within the type name where the omitted identifier would appear\n  were it not omitted."},"2":{"title":"Linkages of identifiers","P1":"An identifier declared in different scopes or in the same scope more than once can be made to refer to the same object or function by a process called linkage.  <foot>There is no linkage between different identifiers.</foot>There are three kinds of linkage: external, internal, and none.\n","P2":"In the set of translation units and libraries that constitutes an entire program, each declaration of a particular identifier with external linkage denotes the same object or function. Within one translation unit, each declaration of an identifier with internal linkage denotes the same object or function. Each declaration of an identifier with no linkage denotes a unique entity.\n","P3":"If the declaration of a file scope identifier for an object or a function contains the storageclass specifier static, the identifier has internal linkage.  <foot>A function declaration can contain the storage-class specifier static only if it is at file scope; see 6.7.1.</foot>\n","P4":"For an identifier declared with the storage-class specifier extern in a scope in which a prior declaration of that identifier is visible, <foot>As specified in 6.2.1, the later declaration might hide the prior declaration.</foot> if the prior declaration specifies internal or external linkage, the linkage of the identifier at the later declaration is the same as the linkage specified at the prior declaration. If no prior declaration is visible, or if the prior declaration specifies no linkage, then the identifier has external linkage.\n","P5":"If the declaration of an identifier for a function has no storage-class specifier, its linkage is determined exactly as if it were declared with the storage-class specifier extern. If the declaration of an identifier for an object has file scope and no storage-class specifier, its linkage is external.\n","P6":"The following identifiers have no linkage: an identifier declared to be anything other than an object or a function; an identifier declared to be a function parameter; a block scope identifier for an object declared without the storage-class specifier extern.\n","P7":"If, within a translation unit, the same identifier appears with both internal and external linkage, the behavior is undefined.\n"},"3":{"title":"Name spaces of identifiers","P1":"If more than one declaration of a particular identifier is visible at any point in a translation unit, the syntactic context disambiguates uses that refer to different entities. Thus, there are separate name spaces for various categories of identifiers, as follows: — label names (disambiguated by the syntax of the label declaration and use); — the tags of structures, unions, and enumerations (disambiguated by following any<foot>There is only one name space for tags even though three are possible.</foot>) of the keywords struct, union, or enum); — the members of structures or unions; each structure or union has a separate name space for its members (disambiguated by the type of the expression used to access the member via the . or -> operator); — all other identifiers, called ordinary identifiers (declared in ordinary declarators or as enumeration constants).\n"},"4":{"title":"Storage durations of objects","P1":"An object has a storage duration that determines its lifetime. There are four storage durations: static, thread, automatic, and allocated. Allocated storage is described in 7.22.3.\n","P2":"The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, <foot>The term ‘‘constant address’’ means that two pointers to the object constructed at possibly different times will compare equal. The address may be different during two different executions of the same program.</foot>and retains its last-stored value throughout its lifetime.<foot>In the case of a volatile object, the last store need not be explicit in the program.</foot>) If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime.\n","P3":"An object whose identifier is declared without the storage-class specifier _Thread_local, and either with external or internal linkage or with the storage-class specifier static, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.\n","P4":"An object whose identifier is declared with the storage-class specifier _Thread_local has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.\n","P5":"An object whose identifier is declared with no linkage and without the storage-class specifier static has automatic storage duration, as do some compound literals. The result of attempting to indirectly access an object with automatic storage duration from a thread other than the one with which the object is associated is implementation-defined.\n","P6":"For such an object that does not have a variable length array type, its lifetime extends from entry into the block with which it is associated until execution of that block ends in any way. (Entering an enclosed block or calling a function suspends, but does not end, execution of the current block.) If the block is entered recursively, a new instance of the object is created each time. The initial value of the object is indeterminate. If an initialization is specified for the object, it is performed each time the declaration or compound literal is reached in the execution of the block; otherwise, the value becomes indeterminate each time the declaration is reached.\n","P7":"For such an object that does have a variable length array type, its lifetime extends from the declaration of the object until execution of the program leaves the scope of the declaration.<foot>Leaving the innermost block containing the declaration, or jumping to a point in that block or an embedded block prior to the declaration, leaves the scope of the declaration. If the scope is entered recursively, a new instance of the object is created</foot> each time. The initial value of the object is indeterminate.\n","P8":"A non-lvalue expression with structure or union type, where the structure or union contains a member with array type (including, recursively, members of all contained structures and unions) refers to an object with automatic storage duration and temporary lifetime.<foot>The address of such an object is taken implicitly when an array member is accessed.</foot> Its lifetime begins when the expression is evaluated and its initial value is the value of the expression. Its lifetime ends when the evaluation of the containing full expression or full declarator ends. Any attempt to modify an object with temporary lifetime results in undefined behavior.\n"},"5":{"title":"Types","P1":"The meaning of a value stored in an object or returned by a function is determined by the type of the expression used to access it. (An identifier declared to be an object is the simplest such expression; the type is specified in the declaration of the identifier.) Types are partitioned into object types (types that describe objects) and function types (types that describe functions). At various points within a translation unit an object type may be incomplete (lacking sufficient information to determine the size of objects of that type) or complete (having sufficient information).<foot>A type may be incomplete or complete throughout an entire translation unit, or it may change states at different points within a translation unit.</foot>\n","P2":"An object declared as type _Bool is large enough to store the values 0 and 1.\n","P3":"An object declared as type char is large enough to store any member of the basic execution character set. If a member of the basic execution character set is stored in a char object, its value is guaranteed to be nonnegative. If any other character is stored in a char object, the resulting value is implementation-defined but shall be within the range of values that can be represented in that type.\n","P4":"There are five standard signed integer types, designated as signed char, short int, int, long int, and long long int. (These and other types may be designated in several additional ways, as described in 6.7.2.) There may also be implementation-defined extended signed integer types.<foot>Implementation-defined keywords shall have the form of an identifier reserved for any use as described in 7.1.3.</foot> The standard and extended signed integer types are collectively called signed integer types.  <foot>Therefore, any statement in this Standard about signed integer types also applies to the extended signed integer types.</foot>\n","P5":"An object declared as type signed char occupies the same amount of storage as a ‘‘plain’’ char object. A ‘‘plain’’ int object has the natural size suggested by the architecture of the execution environment (large enough to contain any value in the range INT_MIN to INT_MAX as defined in the header <limits.h>).\n","P6":"For each of the signed integer types, there is a corresponding (but different) unsigned integer type (designated with the keyword unsigned) that uses the same amount of storage (including sign information) and has the same alignment requirements. The type _Bool and the unsigned integer types that correspond to the standard signed integer types are the standard unsigned integer types. The unsigned integer types that correspond to the extended signed integer types are the extended unsigned integer types.  The standard and extended unsigned integer types are collectively called unsigned integer types.<foot>Therefore, any statement in this Standard about unsigned integer types also applies to the extended unsigned integer types.</foot>\n","P7":"The standard signed integer types and standard unsigned integer types are collectively called the standard integer types; the extended signed integer types and extended unsigned integer types are collectively called the extended integer types.\n","P8":"For any two integer types with the same signedness and different integer conversion rank (see 6.3.1.1), the range of values of the type with smaller integer conversion rank is a subrange of the values of the other type.\n","P9":"The range of nonnegative values of a signed integer type is a subrange of the corresponding unsigned integer type, and the representation of the same value in each type is the same.<foot>The same representation and alignment requirements are meant to imply interchangeability as arguments to functions, return values from functions, and members of unions.</foot> A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.\n","P10":"There are three real floating types, designated as float, double, and long double.<foot>See ‘‘future language directions’’ (6.11.1).</foot> The set of values of the type float is a subset of the set of values of the type double; the set of values of the type double is a subset of the set of values of the type long double.\n","P11":"There are three complex types, designated as float _Complex, double _Complex, and long double _Complex.<foot>A specification for imaginary types is in annex G.</foot> (Complex types are a conditional feature that implementations need not support; see 6.10.8.3.) The real floating and complex types are collectively called the floating types.\n","P12":"For each floating type there is a corresponding real type, which is always a real floating type. For real floating types, it is the same type. For complex types, it is the type given by deleting the keyword _Complex from the type name.\n","P13":"Each complex type has the same representation and alignment requirements as an array type containing exactly two elements of the corresponding real type; the first element is equal to the real part, and the second element to the imaginary part, of the complex number.\n","P14":"The type char, the signed and unsigned integer types, and the floating types are collectively called the basic types. The basic types are complete object types. Even if the implementation defines two or more basic types to have the same representation, they are nevertheless different types.<foot>An implementation may define new keywords that provide alternative ways to designate a basic (or any other) type; this does not violate the requirement that all basic types be different. Implementation-defined keywords shall have the form of an identifier reserved for any use as described in 7.1.3.</foot>\n","P15":"The three types char, signed char, and unsigned char are collectively called the character types. The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char.<foot>CHAR_MIN, defined in <limits.h>, will have one of the values 0 or SCHAR_MIN, and this can be used to distinguish the two options. Irrespective of the choice made, char is a separate type from the other two and is not compatible with either.</foot>\n","P16":"An enumeration comprises a set of named integer constant values. Each distinct enumeration constitutes a different enumerated type.\n","P17":"The type char, the signed and unsigned integer types, and the enumerated types are collectively called integer types. The integer and real floating types are collectively called real types.\n","P18":"Integer and floating types are collectively called arithmetic types. Each arithmetic type belongs to one type domain: the real type domain comprises the real types, the complex type domain comprises the complex types.\n","P19":"The void type comprises an empty set of values; it is an incomplete object type that cannot be completed.\n","P20":"Any number of derived types can be constructed from the object and\nfunction types, as follows:\n— An array type describes a contiguously allocated nonempty set of\nobjects with a particular member object type, called the element type.\nThe element type shall be complete whenever the array type is\nspecified. Array types are characterized by their element type and by\nthe number of elements in the array. An array type is said to be\nderived from its element type, and if its element type is T , the array\ntype is sometimes called ‘‘array of T ’’. The construction of an array\ntype from an element type is called ‘‘array type derivation’’.\n— A structure type describes a sequentially allocated nonempty set of\nmember objects (and, in certain circumstances, an incomplete array),\neach of which has an optionally specified name and possibly distinct\ntype.\n— A union type describes an overlapping nonempty set of member objects,\neach of which has an optionally specified name and possibly distinct\ntype.\n— A function type describes a function with specified return type. A\nfunction type is characterized by its return type and the number and\ntypes of its parameters. A function type is said to be derived from its\nreturn type, and if its return type is T , the function type is\nsometimes called ‘‘function returning T ’’. The construction of a\nfunction type from a return type is called ‘‘function type\nderivation’’.\n— A pointer type may be derived from a function type or an object type,\ncalled the referenced type. A pointer type describes an object whose\nvalue provides a reference to an entity of the referenced type. A\npointer type derived from the referenced type T is sometimes called\n‘‘pointer to T ’’. The construction of a pointer type from a referenced\ntype is called ‘‘pointer type derivation’’. A pointer type is a\ncomplete object type.\n— An atomic type describes the type designated by the construct _Atomic\n( typename ). (Atomic types are a conditional feature that\nimplementations need not support; see 6.10.8.3.)\nThese methods of constructing derived types can be applied recursively.\n","P21":"Arithmetic types and pointer types are collectively called scalar types. Array and structure types are collectively called aggregate types.<foot>Note that aggregate type does not include union type because an object with union type can only contain one member at a time.</foot>\n","P22":"An array type of unknown size is an incomplete type. It is completed, for an identifier of that type, by specifying the size in a later declaration (with internal or external linkage).  A structure or union type of unknown content (as described in 6.7.2.3) is an incomplete type. It is completed, for all declarations of that type, by declaring the same structure or union tag with its defining content later in the same scope.\n","P23":"A type has known constant size if the type is not incomplete and is not a variable length array type.\n","P24":"Array, function, and pointer types are collectively called derived declarator types. A declarator type derivation from a type T is the construction of a derived declarator type from T by the application of an array-type, a function-type, or a pointer-type derivation to T.\n","P25":"A type is characterized by its type category, which is either the outermost derivation of a derived type (as noted above in the construction of derived types), or the type itself if the type consists of no derived types.\n","P26":"Any type so far mentioned is an unqualified type. Each unqualified type has several qualified versions of its type,<foot>See 6.7.3 regarding qualified array and function types.</foot> corresponding to the combinations of one, two, or all three of the const, volatile, and restrict qualifiers. The qualified or unqualified versions of a type are distinct types that belong to the same type category and have the same representation and alignment requirements.48) A derived type is not qualified by the qualifiers (if any) of the type from which it is derived.\n","P27":"Further, there is the _Atomic qualifier. The presence of the _Atomic qualifier designates an atomic type. The size, representation, and alignment of an atomic type need not be the same as those of the corresponding unqualified type. Therefore, this Standard explicitly uses the phrase ‘‘atomic, qualified or unqualified type’’ whenever the atomic version of a type is permitted along with the other qualified versions of a type.  The phrase ‘‘qualified or unqualified type’’, without specific mention of atomic, does not include the atomic types.\n","P28":"A pointer to void shall have the same representation and alignment requirements as a pointer to a character type.<foot>The same representation and alignment requirements are meant to imply interchangeability as arguments to functions, return values from functions, and members of unions.</foot> Similarly, pointers to qualified or unqualified versions of compatible types shall have the same representation and alignment requirements. All pointers to structure types shall have the same representation and alignment requirements as each other. All pointers to union types shall have the same representation and alignment requirements as each other. Pointers to other types need not have the same representation or alignment requirements.\n","P29":"EXAMPLE 1 The type designated as ‘‘float *’’ has type ‘‘pointer to float’’. Its type category is pointer, not a floating type. The const-qualified version of this type is designated as ‘‘float * const’’ whereas the type designated as ‘‘const float *’’ is not a qualified type — its type is ‘‘pointer to const- qualified float’’ and is a pointer to a qualified type.\n","P30":"EXAMPLE 2 The type designated as ‘‘struct tag (*[5])(float)’’ has type ‘‘array of pointer to function returning struct tag’’. The array has length five and the function has a single parameter of type float. Its type category is array.\n"},"6":{"1":{"title":"General","P1":"The representations of all types are unspecified except as stated in this subclause.\n","P2":"Except for bit-fields, objects are composed of contiguous sequences of one or more bytes, the number, order, and encoding of which are either explicitly specified or implementation-defined.\n","P3":"Values stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation.<foot>A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral powers of 2, except perhaps the bit with the highest position. (Adapted from the American National Dictionary for Information Processing Systems.) A byte contains CHAR_BIT bits, and the values of CHAR_BIT type unsigned char range from 0 to 2 − 1.</foot>\n","P4":"Values stored in non-bit-field objects of any other object type consist of n × CHAR_BIT bits, where n is the size of an object of that type, in bytes. The value may be copied into an object of type unsigned char [n] (e.g., by memcpy); the resulting set of bytes is called the object representation of the value. Values stored in bit-fields consist of m bits, where m is the size specified for the bit-field. The object representation is the set of m bits the bit-field comprises in the addressable storage unit holding it. Two values (other than NaNs) with the same object representation compare equal, but values that compare equal may have different object representations.\n","P5":"Certain object representations need not represent a value of the object type. If the stored value of an object has such a representation and is read by an lvalue expression that does not have character type, the behavior is undefined. If such a representation is produced by a side effect that modifies all or any part of the object by an lvalue expression that does not have character type, the behavior is undefined.<foot>Thus, an automatic variable can be initialized to a trap representation without causing undefined behavior, but the value of the variable cannot be used until a proper value is stored in it.</foot> Such a representation is called a trap representation.\n","P6":"When a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values.<foot>Thus, for example, structure assignment need not copy any padding bits.</foot> The value of a structure or union object is never a trap representation, even though the value of a member of the structure or union object may be a trap representation.\n","P7":"When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values.\n","P8":"Where an operator is applied to a value that has more than one object representation, which object representation is used shall not affect the value of the result.<foot>It is possible for objects x and y with the same effective type T to have the same value when they are accessed as objects of type T, but to have different values in other contexts. In particular, if == is defined for type T, then x == y does not imply that memcmp(&x, &y, sizeof (T)) == 0. Furthermore, x == y does not necessarily imply that x and y have the same value; other operations on values of type T may distinguish between them.</foot> Where a value is stored in an object using a type that has more than one object representation for that value, it is unspecified which representation is used, but a trap representation shall not be generated.\n","P9":"Loads and stores of objects with atomic types are done with memory_order_seq_cst semantics.\n"},"2":{"title":"Integer types","P1":"For unsigned integer types other than unsigned char, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter). If there are N value bits, each bit shall represent a different power of 2 between 1 and 2 N −1 , so that objects of that type shall be capable of representing values from 0 to 2 N − 1 using a pure binary representation; this shall be known as the value representation. The values of any padding bits are unspecified.<foot>Some combinations of padding bits might generate trap representations, for example, if one padding bit is a parity bit. Regardless, no arithmetic operation on valid values can generate a trap representation other than as part of an exceptional condition such as an overflow, and this cannot occur with unsigned types. All other combinations of padding bits are alternative object representations of the value specified by the value bits.</foot>\n","P2":"For signed integer types, the bits of the object representation shall be divided into three groups: value bits, padding bits, and the sign bit. There need not be any padding bits; signed char shall not have any padding bits. There shall be exactly one sign bit.  Each bit that is a value bit shall have the same value as the same bit in the object representation of the corresponding unsigned type (if there are M value bits in the signed type and N in the unsigned type, then M ≤ N ). If the sign bit is zero, it shall not affect the resulting value. If the sign bit is one, the value shall be modified in one of the following ways: — the corresponding value with sign bit 0 is negated (sign and magnitude); — the sign bit has the value −(2 M ) (two’s complement); — the sign bit has the value −(2 M − 1) (ones’ complement). Which of these applies is implementation-defined, as is whether the value with sign bit 1 and all value bits zero (for the first two), or with sign bit and all value bits 1 (for ones’ complement), is a trap representation or a normal value. In the case of sign and magnitude and ones’ complement, if this representation is a normal value it is called a negative zero.\n","P3":"If the implementation supports negative zeros, they shall be generated only by: — the &, |, ^, ~, <<, and >> operators with operands that produce such a value; — the +, -, *, /, and % operators where one operand is a negative zero and the result is zero; — compound assignment operators based on the above cases.  It is unspecified whether these cases actually generate a negative zero or a normal zero, and whether a negative zero becomes a normal zero when stored in an object\n","P4":"If the implementation does not support negative zeros, the behavior of the &, |, ^, ~, <<, and >> operators with operands that would produce such a value is undefined.\n","P5":"The values of any padding bits are unspecified.<foot>Some combinations of padding bits might generate trap representations, for example, if one padding bit is a parity bit. Regardless, no arithmetic operation on valid values can generate a trap representation other than as part of an exceptional condition such as an overflow. All other combinations of padding bits are alternative object representations of the value specified by the value bits.</foot> A valid (non-trap) object representation of a signed integer type where the sign bit is zero is a valid object representation of the corresponding unsigned type, and shall represent the same value. For any integer type, the object representation where all the bits are zero shall be a representation of the value zero in that type.\n","P6":"The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. The width of an integer type is the same but including any sign bit; thus for unsigned integer types the two values are the same, while for signed integer types the width is one greater than the precision.\n"},"title":"Representations of types"},"7":{"title":"Compatible type and composite type","P1":"Two types have compatible type if their types are the same. Additional rules for determining whether two types are compatible are described in 6.7.2 for type specifiers, in 6.7.3 for type qualifiers, and in 6.7.6 for declarators.<foot>Two types need not be identical to be compatible.</foot> Moreover, two structure, union, or enumerated types declared in separate translation units are compatible if their tags and members satisfy the following requirements: If one is declared with a tag, the other shall be declared with the same tag. If both are completed anywhere within their respective translation units, then the following additional requirements apply: there shall be a one-to-one correspondence between their members such that each pair of corresponding members are declared with compatible types; if one member of the pair is declared with an alignment specifier, the other is declared with an equivalent alignment specifier; and if one member of the pair is declared with a name, the other is declared with the same name. For two structures, corresponding members shall be declared in the same order. For two structures or unions, corresponding bit-fields shall have the same widths. For two enumerations, corresponding members shall have the same values.\n","P2":"All declarations that refer to the same object or function shall have compatible type; otherwise, the behavior is undefined.\n","P3":"A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions: — If both types are array types, the following rules are applied: * If one type is an array of known constant size, the composite type is an array of that size. * Otherwise, if one type is a variable length array whose size is specified by an expression that is not evaluated, the behavior is undefined. * Otherwise, if one type is a variable length array whose size is specified, the composite type is a variable length array of that size. * Otherwise, if one type is a variable length array of unspecified size, the composite type is a variable length array of unspecified size. * Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size.  The element type of the composite type is the composite type of the two element types. — If only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list. — If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters. These rules apply recursively to the types from which the two types are derived.\n","P4":"For an identifier with internal or external linkage declared in a scope in which a prior declaration of that identifier is visible,<foot>As specified in 6.2.1, the later declaration might hide the prior declaration.</foot> if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.\n","P5":"EXAMPLE\nGiven the following two file scope declarations:\n<code>\nint f(int (*)(), double (*)[3]);\nint f(int (*)(char *), double (*)[]);\n</code>\nThe resulting composite type for the function is:\n<code>\nint f(int (*)(char *), double (*)[3]);\n</code>\n"},"8":{"title":"Alignment of objects","P1":"Complete object types have alignment requirements which place restrictions on the addresses at which objects of that type may be allocated. An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. An object type imposes an alignment requirement on every object of that type: stricter alignment can be requested using the _Alignas keyword.\n","P2":"A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to _Alignof (max_align_t).\n","P3":"An extended alignment is represented by an alignment greater than _Alignof (max_align_t). It is implementation-defined whether any extended alignments are supported and the contexts in which they are supported. A type having an extended alignment requirement is an over-aligned type.<foot>Every over-aligned type is, or contains, a structure or union type with a member to which an extended alignment has been applied.</foot>\n","P4":"Alignments are represented as values of the type size_t. Valid alignments include only those values returned by an _Alignof expression for fundamental types, plus an additional implementation-defined set of values, which may be empty. Every valid alignment value shall be a nonnegative integral power of two.\n","P5":"Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.\n","P6":"The alignment requirement of a complete type can be queried using an _Alignof expression. The types char, signed char, and unsigned char shall have the weakest alignment requirement.\n","P7":"Comparing alignments is meaningful and provides the obvious results: — Two alignments are equal when their numeric values are equal. — Two alignments are different when their numeric values are not equal. — When an alignment is larger than another it represents a stricter alignment.\n"},"title":"Concepts"},"3":{"1":{"1":{"title":"Boolean, characters, and integers","P1":"Every integer type has an integer conversion rank defined as follows:\n— No two signed integer types shall have the same rank, even if they\nhave the same representation.\n— The rank of a signed integer type shall be greater than the rank of\nany signed integer type with less precision.\n— The rank of long long int shall be greater than the rank of long\nint, which shall be greater than the rank of int, which shall be\ngreater than the rank of short int, which shall be greater than the\nrank of signed char.\n— The rank of any unsigned integer type shall equal the rank of the\ncorresponding signed integer type, if any.\n— The rank of any standard integer type shall be greater than the\nrank of any extended integer type with the same width.\n— The rank of char shall equal the rank of signed char and unsigned char.\n— The rank of _Bool shall be less than the rank of all other standard\ninteger types.\n— The rank of any enumerated type shall equal the rank of the\ncompatible integer type (see 6.7.2.2).\n— The rank of any extended signed integer type relative to another\nextended signed integer type with the same precision is\nimplementation-defined, but still subject to the other rules for\ndetermining the integer conversion rank.\n— For all integer types T1, T2, and T3, if T1 has greater rank than\nT2 and T2 has greater rank than T3, then T1 has greater rank than T3.\n","P2":"The following may be used in an expression wherever an int or\nunsigned int may be used:\n— An object or expression with an integer type (other than int or\nunsigned int) whose integer conversion rank is less than or equal to\nthe rank of int and unsigned int.\n— A bit-field of type _Bool, int, signed int, or unsigned int.  If an\nint can represent all values of the original type (as restricted by\nthe width, for a bit-field), the value is converted to an int;\notherwise, it is converted to an unsigned int. These are called the\ninteger promotions. <foot>The integer promotions are applied only: as\npart of the usual arithmetic conversions, to certain argument\nexpressions, to the operands of the unary +, -, and ~ operators, and\nto both operands of the shift operators, as specified by their\nrespective subclauses.</foot> All other types are unchanged by the\ninteger promotions.\n","P3":"The integer promotions preserve value including sign. As discussed earlier, whether a ‘‘plain’’ char is treated as signed is implementation-defined.\n"},"2":{"title":"Boolean type","P1":"When any scalar value is converted to _Bool, the result is 0 if the value compares equal to 0; otherwise, the result is 1. <foot>NaNs do not compare equal to 0 and thus convert to 1.</foot>\n"},"3":{"title":"Signed and unsigned integers","P1":"When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.\n","P2":"Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.  <foot>The rules describe arithmetic on the mathematical value, not the value of a given type of expression.</foot>\n","P3":"Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.\n"},"4":{"title":"Real floating and integer","P1":"When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined. <foot>The remaindering operation performed when a value of integer type is converted to unsigned type need not be performed when a value of real floating type is converted to unsigned type. Thus, the range of portable real floating values is (−1, Utype_MAX+1).</foot>\n","P2":"When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined. Results of some implicit conversions may be represented in greater range and precision than that required by the new type (see 6.3.1.8 and 6.8.6.4).\n"},"5":{"title":"Real floating types","P1":"When a value of real floating type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined. Results of some implicit conversions may be represented in greater range and precision than that required by the new type (see 6.3.1.8 and 6.8.6.4).\n"},"6":{"title":"Complex types","P1":"When a value of complex type is converted to another complex type, both the real and imaginary parts follow the conversion rules for the corresponding real types.\n"},"7":{"title":"Real and complex","P1":"When a value of real type is converted to a complex type, the real part of the complex result value is determined by the rules of conversion to the corresponding real type and the imaginary part of the complex result value is a positive zero or an unsigned zero.\n","P2":"When a value of complex type is converted to a real type, the imaginary part of the complex value is discarded and the value of the real part is converted according to the conversion rules for the corresponding real type.\n"},"8":{"title":"Usual arithmetic conversions","P1":"Many operators that expect operands of arithmetic type cause\nconversions and yield result types in a similar way. The purpose is\nto determine a common real type for the operands and result. For the\nspecified operands, each operand is converted, without change of type\ndomain, to a type whose corresponding real type is the common real\ntype. Unless explicitly stated otherwise, the common real type is\nalso the corresponding real type of the result, whose type domain is\nthe type domain of the operands if they are the same, and complex\notherwise. This pattern is called the usual arithmetic conversions:\nFirst, if the corresponding real type of either operand is long\ndouble, the other operand is converted, without change of type\ndomain, to a type whose corresponding real type is long double.\nOtherwise, if the corresponding real type of either operand is\ndouble, the other operand is converted, without change of type\ndomain, to a type whose corresponding real type is double.\nOtherwise, if the corresponding real type of either operand is float,\nthe other operand is converted, without change of type domain, to a\ntype whose corresponding real type is float. <foot>For example,\naddition of a double _Complex and a float entails just the conversion\nof the float operand to double (and yields a double _Complex\nresult).</foot>\nOtherwise, the integer promotions are performed on both operands.\nThen the following rules are applied to the promoted operands:\n  If both operands have the same type, then no further conversion is\n  needed.\n  Otherwise, if both operands have signed integer types or both have\n  unsigned integer types, the operand with the type of lesser integer\n  conversion rank is converted to the type of the operand with\n  greater rank.\n  Otherwise, if the operand that has unsigned integer type has rank\n  greater or equal to the rank of the type of the other operand, then\n  the operand with signed integer type is converted to the type of\n  the operand with unsigned integer type.\n  Otherwise, if the type of the operand with signed integer type can\n  represent all of the values of the type of the operand with\n  unsigned integer type, then the operand with unsigned integer type\n  is converted to the type of the operand with signed integer type.\n  Otherwise, both operands are converted to the unsigned integer type\n  corresponding to the type of the operand with signed integer type.\n","P2":"The values of floating operands and of the results of floating expressions may be represented in greater range and precision than that required by the type; the types are not changed thereby. <foot>The cast and assignment operators are still required to remove extra range and precision.</foot>\n"},"title":"Arithmetic operands"},"2":{"1":{"title":"Lvalues, arrays, and function designators","P1":"An lvalue is an expression (with an object type other than void) that potentially designates an object; <foot>The name ‘‘lvalue’’ comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object ‘‘locator value’’. What is sometimes called ‘‘rvalue’’ is in this International Standard described as the ‘‘value of an expression’’.  An obvious example of an lvalue is an identifier of an object. As a further example, if E is a unary expression that is a pointer to an object, *E is an lvalue that designates the object to which E points.</foot>) if an lvalue does not designate an object when it is evaluated, the behavior is undefined. When an object is said to have a particular type, the type is specified by the lvalue used to designate the object. A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a constqualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a constqualified type.\n","P2":"Except when it is the operand of the sizeof operator, the unary & operator, the ++ operator, the -- operator, or the left operand of the . operator or an assignment operator, an lvalue that does not have array type is converted to the value stored in the designated object (and is no longer an lvalue); this is called lvalue conversion. If the lvalue has qualified type, the value has the unqualified version of the type of the lvalue; additionally, if the lvalue has atomic type, the value has the non-atomic version of the type of the lvalue; otherwise, the value has the type of the lvalue. If the lvalue has an incomplete type and does not have array type, the behavior is undefined. If the lvalue designates an object of automatic storage duration that could have been declared with the register storage class (never had its address taken), and that object is uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.\n","P3":"Except when it is the operand of the sizeof operator, or the unary & operator, or is a string literal used to initialize an array, an expression that has type ‘‘array of type’’ is converted to an expression with type ‘‘pointer to type’’ that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.\n","P4":"A function designator is an expression that has function type. Except when it is the operand of the sizeof operator,<foot>Because this conversion does not occur, the operand of the sizeof operator remains a function designator and violates the constraints in 6.5.3.4.</foot> or the unary & operator, a function designator with type ‘‘function returning type’’ is converted to an expression that has type ‘‘pointer to function returning type’’.\n"},"2":{"title":"void","P1":"The (nonexistent) value of a void expression (an expression that has type void) shall not be used in any way, and implicit or explicit conversions (except to void) shall not be applied to such an expression. If an expression of any other type is evaluated as a void expression, its value or designator is discarded. (A void expression is evaluated for its side effects.)\n"},"3":{"title":"Pointers","P1":"A pointer to void may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer.\n","P2":"For any qualifier q, a pointer to a non-q-qualified type may be converted to a pointer to the q-qualified version of the type; the values stored in the original and converted pointers shall compare equal.\n","P3":"An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. <foot>The macro NULL is defined in <stddef.h> (and other headers) as a null pointer constant; see 7.19.</foot> If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.\n","P4":"Conversion of a null pointer to another pointer type yields a null pointer of that type.  Any two null pointers shall compare equal.\n","P5":"An integer may be converted to any pointer type. Except as previously specified, the result is implementation-defined, might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation.<foot>The mapping functions for converting a pointer to an integer or an integer to a pointer are intended to be consistent with the addressing structure of the execution environment.</foot>\n","P6":"Any pointer type may be converted to an integer type. Except as previously specified, the result is implementation-defined. If the result cannot be represented in the integer type, the behavior is undefined. The result need not be in the range of values of any integer type.\n","P7":"A pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned<foot>In general, the concept ‘‘correctly aligned’’ is transitive: if a pointer to type A is correctly aligned for a pointer to type B, which in turn is correctly aligned for a pointer to type C, then a pointer to type A is correctly aligned for a pointer to type C.</foot> for the referenced type, the behavior is undefined. Otherwise, when converted back again, the result shall compare equal to the original pointer. When a pointer to an object is converted to a pointer to a character type, the result points to the lowest addressed byte of the object. Successive increments of the result, up to the size of the object, yield pointers to the remaining bytes of the object.\n","P8":"A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined.\n"},"title":"Other operands"},"title":"Conversion","P1":"Several operators convert operand values from one type to another automatically. This subclause specifies the result required from such an implicit conversion, as well as those that result from a cast operation (an explicit conversion). The list in 6.3.1.8 summarizes the conversions performed by most ordinary operators; it is supplemented as required by the discussion of each operator in 6.5.\n","P2":"Unless explicitly stated otherwise, conversion of an operand value to a compatible type causes no change to the value or the representation.\n"},"4":{"1":{"title":"Keywords","P1":"Syntax\nkeyword: one of\nauto\nbreak\ncase\nchar\nconst\ncontinue\ndefault\ndo\ndouble\nelse\nenum\nextern\nfloat\nfor\ngoto\nif\ninline\nint\nlong\nregister\nrestrict\nreturn\nshort\nsigned\nsizeof\nstatic\nstruct\nswitch\ntypedef\nunion\nunsigned\nvoid\nvolatile\nwhile\n_Alignas\n_Alignof\n_Atomic\n_Bool\n_Complex\n_Generic\n_Imaginary\n_Noreturn\n_Static_assert\n_Thread_local\n","P2":"Semantics\nThe above tokens (case sensitive) are reserved (in translation phases 7\nand 8) for use as keywords, and shall not be used otherwise. The\nkeyword _Imaginary is reserved for specifying imaginary types.\n<foot>One possible specification for imaginary types appears in annex\nG.</foot>\n"},"2":{"1":{"title":"General","P1":"Syntax\nidentifier:\n  identifier-nondigit\n  identifier identifier-nondigit\n  identifier digit\nidentifier-nondigit:\n  nondigit\n  universal-character-name\n  other implementation-defined characters\nnondigit: one of\n  _ a b c d e f g h i j k l m\n    n o p q r s t u v w x y z\n    A B C D E F G H I J K L M\n    N O P Q R S T U V W X Y Z\ndigit: one of\n  0 1 2 3 4 5 6 7 8 9\n","P2":"Semantics\nAn identifier is a sequence of nondigit characters (including the\nunderscore _, the lowercase and uppercase Latin letters, and other\ncharacters) and digits, which designates one or more entities as\ndescribed in 6.2.1. Lowercase and uppercase letters are distinct.\nThere is no specific limit on the maximum length of an identifier.\n","P3":"Each universal character name in an identifier shall designate a character whose encoding in ISO/IEC 10646 falls into one of the ranges specified in D.1.<foot>On systems in which linkers cannot accept extended characters, an encoding of the universal character name may be used in forming valid external identifiers. For example, some otherwise unused character or sequence of characters may be used to encode the \\u in a universal character name.  Extended characters may produce a long external identifier.</foot> The initial character shall not be a universal character name designating a character whose encoding falls into one of the ranges specified in D.2. An implementation may allow multibyte characters that are not part of the basic source character set to appear in identifiers; which characters and their correspondence to universal character names is implementation-defined.\n","P4":"When preprocessing tokens are converted to tokens during translation phase 7, if a preprocessing token could be converted to either a keyword or an identifier, it is converted to a keyword.\n","P5":"Implementation limits\nAs discussed in 5.2.4.1, an implementation may limit the number of\nsignificant initial characters in an identifier; the limit for an\nexternal name (an identifier that has external linkage) may be more\nrestrictive than that for an internal name (a macro name or an\nidentifier that does not have external linkage). The number of\nsignificant characters in an identifier is implementation-defined.\n","P6":"Any identifiers that differ in a significant character are different identifiers. If two identifiers differ only in nonsignificant characters, the behavior is undefined.\n"},"2":{"title":"Predefined identifiers","P1":"Semantics\nThe identifier _ _func_ _ shall be implicitly declared by the\ntranslator as if, immediately following the opening brace of each\nfunction definition, the declaration\n<code>\nstatic const char _ _func_ _[] = \"function-name\";\n</code>\nappeared, where function-name is the name of the lexically-enclosing\nfunction. <foot>Since the name _ _func_ _ is reserved for any use by\nthe implementation (7.1.3), if any other identifier is explicitly\ndeclared using the name _ _func_ _, the behavior is undefined.</foot>\n","P2":"This name is encoded as if the implicit declaration had been written in the source character set and then translated into the execution character set as indicated in translation phase 5.\n","P3":"EXAMPLE\nConsider the code fragment:\n<code>\n\\#include <stdio.h>\nvoid myfunc(void)\n{\n  printf(\"%s\\n\", _ _func_ _);\n  /* ... */\n}\n</code>\nEach time the function is called, it will print to the standard\noutput stream: myfunc\n"},"title":"Identifiers"},"3":{"title":"Universal character names","P1":"Syntax\nuniversal-character-name:\n  \\u hex-quad\n  \\U hex-quad hex-quad\nhex-quad:\n  hexadecimal-digit hexadecimal-digit\n  hexadecimal-digit hexadecimal-digit\n","P2":"Constraints\nA universal character name shall not specify a character whose short\nidentifier is less than 00A0 other than 0024 ($), 0040 (@), or 0060\n(‘), nor one in the range D800 through DFFF inclusive.<foot>The\ndisallowed characters are the characters in the basic character set and\nthe code positions reserved by ISO/IEC 10646 for control characters,\nthe character DELETE, and the S-zone (reserved for use by\nUTF−16).</foot>\n","P3":"Description\nUniversal character names may be used in identifiers, character\nconstants, and string literals to designate characters that are not in\nthe basic character set.\n","P4":"Semantics\nThe universal character name \\Unnnnnnnn designates the character whose\neight-digit short identifier (as specified by ISO/IEC 10646) is\nnnnnnnnn.<foot>Short identifiers for characters were first specified in\nISO/IEC 10646−1:1993/Amd.9:1997.</foot> Similarly, the universal\ncharacter name \\unnnn designates the character whose four-digit short\nidentifier is nnnn (and whose eight-digit short identifier is\n0000nnnn).\n"},"4":{"1":{"title":"Integer constants","P1":"Syntax\ninteger-constant:\n  decimal-constant integer-suffixopt\n  octal-constant integer-suffixopt\n  hexadecimal-constant integer-suffixopt\ndecimal-constant:\n  nonzero-digit\n  decimal-constant digit\noctal-constant:\n  0\n  octal-constant octal-digit\nhexadecimal-constant:\n  hexadecimal-prefix hexadecimal-digit\n  hexadecimal-constant hexadecimal-digit\nhexadecimal-prefix: one of\n  0x 0X\nnonzero-digit: one of\n  1 2 3 4 5 6 7 8 9\noctal-digit: one of\n  0 1 2 3 4 5 6 7\nhexadecimal-digit: one of\n  0 1 2 3 4 5 6 7 8 9\n  a b c d e f\n  A B C D E F\ninteger-suffix:\n  unsigned-suffix long-suffixopt\n  unsigned-suffix long-long-suffix\n  long-suffix unsigned-suffixopt\n  long-long-suffix unsigned-suffixopt\nunsigned-suffix: one of\n  u U\nlong-suffix: one of\n  l L\nlong-long-suffix: one of\n  ll LL\n","P2":"Description\nAn integer constant begins with a digit, but has no period or\nexponent part. It may have a prefix that specifies its base and a\nsuffix that specifies its type.\n","P3":"A decimal constant begins with a nonzero digit and consists of a\nsequence of decimal digits. An octal constant consists of the prefix\n0 optionally followed by a sequence of the digits 0 through 7 only. A\nhexadecimal constant consists of the prefix 0x or 0X followed by a\nsequence of the decimal digits and the letters a (or A) through f (or\nF) with values 10 through 15 respectively.\n","P4":"Semantics\nThe value of a decimal constant is computed base 10; that of an octal\nconstant, base 8; that of a hexadecimal constant, base 16. The\nlexically first digit is the most significant.\n","P5":"The type of an integer constant is the first of the corresponding\nlist in which its value can be represented.\n<table>\n<tr>\n  <th>Decimal Constant</th>\n  <th>Octal or Hexadecimal</th>\n  <th>Constant</th>\n</tr>\n<tr>\n  <th>none</th>\n  <th>\n    int\n    long int\n    long long int\n  <th>\n    int\n    unsigned int\n    long int\n    unsigned long int\n    long long int\n    unsigned long long int\n  </th>\n</tr>\n<tr>\n  <th>u or U</th>\n    unsigned int\n    unsigned long int\n    unsigned long long int\n  </th>\n  <th>\n    unsigned int\n    unsigned long int\n    unsigned long long int\n  </th>\n</tr>\n<tr>\n  <th>l or L</th>\n  <th>\n    long int\n    long long int\n  </th>\n  <th>\n    long int\n    unsigned long int\n    long long int\n    unsigned long long int\n  </th>\n</tr>\n<tr>\n  <th>\n    Both u or U\n    and l or L\n  </th>\n  <th>\n    unsigned long int\n    unsigned long long int\n  </th>\n  <th>\n    unsigned long int\n    unsigned long long int\n  </th>\n</tr>\n<tr>\n  <th>ll or LL</th>\n  <th>\n    long long int\n  </th>\n  <th>\n    long long int\n    unsigned long long int\n  </th>\n</tr>\n<tr>\n  <th>\n    Both u or U\n    and ll or LL\n  </th>\n  <th>\n    unsigned long long int\n  </th>\n  <th>\n    unsigned long long int\n  </th>\n</tr>\n</table>\n","P6":"If an integer constant cannot be represented by any type in its list, it may have an extended integer type, if the extended integer type can represent its value. If all of the types in the list for the constant are signed, the extended integer type shall be signed. If all of the types in the list for the constant are unsigned, the extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended integer type may be signed or unsigned. If an integer constant cannot be represented by any type in its list and has no extended integer type, then the integer constant has no type.\n"},"2":{"title":"Floating constants","P1":"Syntax\nfloating-constant:\n  decimal-floating-constant\n  hexadecimal-floating-constant\ndecimal-floating-constant:\n  fractional-constant exponent-partopt floating-suffixopt\n  digit-sequence exponent-part floating-suffixopt\nhexadecimal-floating-constant:\n  hexadecimal-prefix hexadecimal-fractional-constant\n    binary-exponent-part floating-suffixopt\n  hexadecimal-prefix hexadecimal-digit-sequence\n    binary-exponent-part floating-suffixopt\nfractional-constant:\n  digit-sequenceopt . digit-sequence\n  digit-sequence .\nexponent-part:\n  e signopt digit-sequence\n  E signopt digit-sequence\nsign: one of\n  + -\ndigit-sequence:\n  digit\n  digit-sequence digit\nhexadecimal-fractional-constant:\n  hexadecimal-digit-sequenceopt .\n    hexadecimal-digit-sequence\n  hexadecimal-digit-sequence .\nbinary-exponent-part:\n  p signopt digit-sequence\n  P signopt digit-sequence\nhexadecimal-digit-sequence:\n  hexadecimal-digit\n  hexadecimal-digit-sequence hexadecimal-digit\nfloating-suffix: one of\n  f l F L\n","P2":"Description\nA floating constant has a significand part that may be followed by an\nexponent part and a suffix that specifies its type. The components of\nthe significand part may include a digit sequence representing the\nwhole-number part, followed by a period (.), followed by a digit\nsequence representing the fraction part. The components of the\nexponent part are an e, E, p, or P followed by an exponent consisting\nof an optionally signed digit sequence.  Either the whole-number part\nor the fraction part has to be present; for decimal floating\nconstants, either the period or the exponent part has to be present.\n","P3":"Semantics\nThe significand part is interpreted as a (decimal or hexadecimal)\nrational number; the digit sequence in the exponent part is\ninterpreted as a decimal integer. For decimal floating constants, the\nexponent indicates the power of 10 by which the significand part is\nto be scaled. For hexadecimal floating constants, the exponent\nindicates the power of 2 by which the significand part is to be\nscaled. For decimal floating constants, and also for hexadecimal\nfloating constants when FLT_RADIX is not a power of 2, the result is\neither the nearest representable value, or the larger or smaller\nrepresentable value immediately adjacent to the nearest representable\nvalue, chosen in an implementation-defined manner.  For hexadecimal\nfloating constants when FLT_RADIX is a power of 2, the result is\ncorrectly rounded.\n","P4":"An unsuffixed floating constant has type double. If suffixed by the letter f or F, it has type float. If suffixed by the letter l or L, it has type long double.\n","P5":"Floating constants are converted to internal format as if at translation-time. The conversion of a floating constant shall not raise an exceptional condition or a floatingpoint exception at execution time. All floating constants of the same source form<foot>1.23, 1.230, 123e-2, 123e-02, and 1.23L are all different source forms and thus need not convert to the same internal format and value.  </foot> shall convert to the same internal format with the same value.\n","P6":"Recommended practice\nThe implementation should produce a diagnostic message if a\nhexadecimal constant cannot be represented exactly in its evaluation\nformat; the implementation should then proceed with the translation\nof the program.\n","P7":"The translation-time conversion of floating constants should match the execution-time conversion of character strings by library functions, such as strtod, given matching inputs suitable for both conversions, the same result format, and default execution-time rounding.<foot>The specification for the library functions recommends more accurate conversion than required for floating constants (see 7.22.1.3).  </foot>\n"},"3":{"title":"Enumeration constants","P1":"Syntax\nenumeration-constant:\n  identifier\n","P2":"Semantics\nAn identifier declared as an enumeration constant has type int.\n"},"4":{"title":"Character constants","P1":"Syntax\ncharacter-constant:\n  ' c-char-sequence '\n  L' c-char-sequence '\n  u' c-char-sequence '\n  U' c-char-sequence '\nc-char-sequence:\n  c-char\n  c-char-sequence c-char\nc-char:\n  any member of the source character set except\n    the single-quote ', backslash \\, or new-line character\n  escape-sequence\nescape-sequence:\n  simple-escape-sequence\n  octal-escape-sequence\n  hexadecimal-escape-sequence\n  universal-character-name\nsimple-escape-sequence: one of\n  \\' \\\" \\? \\\\\n  \\a \\b \\f \\n \\r \\t \\v\noctal-escape-sequence:\n  \\ octal-digit\n  \\ octal-digit octal-digit\n  \\ octal-digit octal-digit octal-digit\nhexadecimal-escape-sequence:\n  \\x hexadecimal-digit\n  hexadecimal-escape-sequence hexadecimal-digit\n","P2":"Description\nAn integer character constant is a sequence of one or more multibyte\ncharacters enclosed in single-quotes, as in 'x'. A wide character\nconstant is the same, except prefixed by the letter L, u, or U. With\na few exceptions detailed later, the elements of the sequence are any\nmembers of the source character set; they are mapped in an\nimplementation-defined manner to members of the execution character\nset.\n","P3":"The single-quote \\', the double-quote \", the question-mark ?, the\nbackslash \\, and arbitrary integer values are representable according\nto the following table of escape sequences:\nsingle quote '            \\'\ndouble quote \"            \\\"\nquestion mark ?           \\?\nbackslash \\               \\\\\noctal character           \\octal digits\nhexadecimal character     \\x hexadecimal digits\n","P4":"The double-quote \\\" and question-mark ? are representable either by themselves or by the escape sequences \\\" and \\?, respectively, but the single-quote ' and the backslash \\ shall be represented, respectively, by the escape sequences \\' and \\\\.\n","P5":"The octal digits that follow the backslash in an octal escape sequence are taken to be part of the construction of a single character for an integer character constant or of a single wide character for a wide character constant. The numerical value of the octal integer so formed specifies the value of the desired character or wide character.\n","P6":"The hexadecimal digits that follow the backslash and the letter x in a hexadecimal escape sequence are taken to be part of the construction of a single character for an integer character constant or of a single wide character for a wide character constant. The numerical value of the hexadecimal integer so formed specifies the value of the desired character or wide character.\n","P7":"Each octal or hexadecimal escape sequence is the longest sequence of characters that can constitute the escape sequence.\n","P8":"In addition, characters not in the basic character set are representable by universal character names and certain nongraphic characters are representable by escape sequences consisting of the backslash \\ followed by a lowercase letter: \\a, \\b, \\f, \\n, \\r, \\t, and \\v.<foot>The semantics of these characters were discussed in 5.2.2. If any other character follows a backslash, the result is not a token and a diagnostic is required. See ‘‘future language directions’’ (6.11.4).</foot>\n","P9":"Constraints\nThe value of an octal or hexadecimal escape sequence shall be in the\nrange of representable values for the corresponding type:\n<table>\n<tr>\n  <th>Prefix</th>\n  <th>Corresponding Type</th>\n</tr>\n  <th>none</th>\n  <th>unsigned char</th>\n<tr>\n  <th>L</th>\n  <th>the unsigned type corresponding to wchar_t</th>\n</tr>\n<tr>\n  <th>u</th>\n  <th>char16_t</th>\n</tr>\n<tr>\n  <th>U</th>\n  <th>char32_t</th>\n</tr>\n</table>\n","P10":"Semantics\nAn integer character constant has type int. The value of an integer\ncharacter constant containing a single character that maps to a\nsingle-byte execution character is the numerical value of the\nrepresentation of the mapped character interpreted as an integer.\nThe value of an integer character constant containing more than one\ncharacter (e.g., 'ab'), or containing a character or escape sequence\nthat does not map to a single-byte execution character, is\nimplementation-defined. If an integer character constant contains a\nsingle character or escape sequence, its value is the one that\nresults when an object with type char whose value is that of the\nsingle character or escape sequence is converted to type int.\n","P11":"A wide character constant prefixed by the letter L has type wchar_t, an integer type defined in the <stddef.h> header; a wide character constant prefixed by the letter u or U has type char16_t or char32_t, respectively, unsigned integer types defined in the <uchar.h> header. The value of a wide character constant containing a single multibyte character that maps to a single member of the extended execution character set is the wide character corresponding to that multibyte character, as defined by the mbtowc, mbrtoc16, or mbrtoc32 function as appropriate for its type, with an implementation-defined current locale. The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set, is implementation-defined.\n","P12":"EXAMPLE 1 The construction '\\0' is commonly used to represent the null character.\n","P13":"EXAMPLE 2 Consider implementations that use two’s complement representation for integers and eight bits for objects that have type char. In an implementation in which type char has the same range of values as signed char, the integer character constant '\\xFF' has the value −1; if type char has the same range of values as unsigned char, the character constant '\\xFF' has the value +255.\n","P14":"EXAMPLE 3 Even if eight bits are used for objects that have type char, the construction '\\x123' specifies an integer character constant containing only one character, since a hexadecimal escape sequence is terminated only by a non-hexadecimal character. To specify an integer character constant containing the two characters whose values are '\\x12' and '3', the construction '\\0223' may be used, since an octal escape sequence is terminated after three octal digits. (The value of this two-character integer character constant is implementation-defined.)\n","P15":"EXAMPLE 4 Even if 12 or more bits are used for objects that have type wchar_t, the construction L'\\1234' specifies the implementation-defined value that results from the combination of the values 0123 and '4'.\n"},"title":"Constants","P1":"Syntax\nconstant:\n  integer-constant\n  floating-constant\n  enumeration-constant\n  character-constant\n","P2":"Constraints\nEach constant shall have a type and the value of a constant shall be in\nthe range of representable values for its type.\n","P3":"Semantics\nEach constant has a type, determined by its form and value, as detailed\nlater.\n"},"5":{"title":"String literals","P1":"Syntax\nstring-literal:\n  encoding-prefixopt \" s-char-sequenceopt \"\nencoding-prefix:\n  u8\n  u\n  U\n  L\ns-char-sequence:\n  s-char\n  s-char-sequence s-char\ns-char:\n  any member of the source character set except\n    the double-quote \\\", backslash \\, or new-line character\n  escape-sequence\n","P2":"Constraints\nA sequence of adjacent string literal tokens shall not include both a\nwide string literal and a UTF−8 string literal.\n","P3":"Description\nA character string literal is a sequence of zero or more multibyte\ncharacters enclosed in double-quotes, as in \"xyz\". A UTF−8 string\nliteral is the same, except prefixed by u8.  A wide string literal is\nthe same, except prefixed by the letter L, u, or U.\n","P4":"The same considerations apply to each element of the sequence in a\nstring literal as if it were in an integer character constant (for a\ncharacter or UTF−8 string literal) or a wide character constant (for a\nwide string literal), except that the single-quote \\' is representable\neither by itself or by the escape sequence \\', but the double-quote \\\"\nshall be represented by the escape sequence \\\".\n","P5":"Semantics\nIn translation phase 6, the multibyte character sequences specified by\nany sequence of adjacent character and identically-prefixed string\nliteral tokens are concatenated into a single multibyte character\nsequence. If any of the tokens has an encoding prefix, the resulting\nmultibyte character sequence is treated as having the same prefix;\notherwise, it is treated as a character string literal. Whether\ndifferently-prefixed wide string literal tokens can be concatenated\nand, if so, the treatment of the resulting multibyte character sequence\nare implementation-defined.\n","P6":"In translation phase 7, a byte or code of value zero is appended to\neach multibyte character sequence that results from a string literal or\nliterals.<foot>A string literal need not be a string (see 7.1.1),\nbecause a null character may be embedded in it by a \\0 escape\nsequence.</foot> The multibyte character sequence is then used to\ninitialize an array of static storage duration and length just\nsufficient to contain the sequence. For character string literals, the\narray elements have type char, and are initialized with the individual\nbytes of the multibyte character sequence. For UTF−8 string literals,\nthe array elements have type char, and are initialized with the\ncharacters of the multibyte character sequence, as encoded in UTF−8.\nFor wide string literals prefixed by the letter L, the array elements\nhave type wchar_t and are initialized with the sequence of wide\ncharacters corresponding to the multibyte character sequence, as\ndefined by the mbstowcs function with an implementationdefined current\nlocale. For wide string literals prefixed by the letter u or U, the\narray elements have type char16_t or char32_t, respectively, and are\ninitialized with the sequence of wide characters corresponding to the\nmultibyte character sequence, as defined by successive calls to the\nmbrtoc16, or mbrtoc32 function as appropriate for its type, with an\nimplementation-defined current locale. The value of a string literal\ncontaining a multibyte character or escape sequence not represented in\nthe execution character set is implementation-defined.\n","P7":"It is unspecified whether these arrays are distinct provided their\nelements have the appropriate values. If the program attempts to modify\nsuch an array, the behavior is undefined.\n","P8":"EXAMPLE 1\nThis pair of adjacent character string literals\n\"\\x12\" \"3\" produces a single character string literal containing the\ntwo characters whose values are '\\x12' and '3', because escape\nsequences are converted into single members of the execution character\nset just prior to adjacent string literal concatenation.\n","P9":"EXAMPLE 2\nEach of the sequences of adjacent string literal tokens\n  \"a\" \"b\" L\"c\"\n  \"a\" L\"b\" \"c\"\n  L\"a\" \"b\" L\"c\"\n  L\"a\" L\"b\" L\"c\"\nis equivalent to the string literal\n  L\"abc\"\nLikewise, each of the sequences\n  \"a\" \"b\" u\"c\"\n  \"a\" u\"b\" \"c\"\n  u\"a\" \"b\" u\"c\"\n  u\"a\" u\"b\" u\"c\"\nis equivalent to\n  u\"abc\"\n"},"6":{"title":"Punctuators","P1":"Syntax\npunctuator: one of\n  [ ] ( ) { } . ->\n  ++ -- & * + - ~ !\n  / % << >> < > <= >= == != ^ | && ||\n  ? : ; ...\n  = *= /= %= += -= <<= >>= &= ^= |=\n  , \\# \\#\\#\n  <: :> <% %> %: %:%:\n","P2":"Semantics\nA punctuator is a symbol that has independent syntactic and semantic\nsignificance.  Depending on context, it may specify an operation to be\nperformed (which in turn may yield a value or a function designator,\nproduce a side effect, or some combination thereof) in which case it is\nknown as an operator (other forms of operator also exist in some\ncontexts). An operand is an entity on which an operator acts.\n","P3":"In all aspects of the language, the six tokens\n<foot>These tokens are sometimes called ‘‘digraphs’’.</foot>\n  <: :>  <% %> %: %:%:\nbehave, respectively, the same as the six tokens\n[ ] { } \\# \\#\\#\nexcept for their spelling.<foot>Thus [ and <: behave differently when\n‘‘stringized’’ (see 6.10.3.2), but can otherwise be freely\ninterchanged.</foot>\n"},"7":{"title":"Header names","P1":"Syntax\nheader-name:\n  < h-char-sequence >\n  \" q-char-sequence \"\nh-char-sequence:\n  h-char\n  h-char-sequence h-char\nh-char:\n  any member of the source character set except\n  the new-line character and >\nq-char-sequence:\n  q-char\n  q-char-sequence q-char\nq-char:\n  any member of the source character set except\n  the new-line character and \\\"\n","P2":"Semantics\nThe sequences in both forms of header names are mapped in an\nimplementation-defined manner to headers or external source file names\nas specified in 6.10.2.\n","P3":"If the characters \\', \\, \\\", //, or /* occur in the sequence between the < and > delimiters, the behavior is undefined. Similarly, if the characters \\', \\, //, or /* occur in the sequence between the \\\" delimiters, the behavior is undefined.<foot>Thus, sequences of characters that resemble escape sequences cause undefined behavior.</foot> Header name preprocessing tokens are recognized only within \\#include preprocessing directives and in implementation-defined locations within \\#pragma directives.<foot>For an example of a header name preprocessing token used in a \\#pragma directive, see 6.10.9.</foot>\n","P4":"EXAMPLE\nThe following sequence of characters:\n<code>\n  0x3<1/a.h>1e2\n  \\#include <1/a.h>\n  \\#define const.member@$\n</code>\nforms the following sequence of preprocessing tokens (with each\nindividual preprocessing token delimited by a { on the left and a } on\nthe right).\n<code>\n  {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}\n  {#}{include} {<1/a.h>}\n  {#}{define} {const}{.}{member}{@}{$}\n</code>\n"},"8":{"title":"Preprocessing numbers","P1":"Syntax\npp-number:\n  digit\n  . digit\n  pp-number digit\n  pp-number identifier-nondigit\n  pp-number e sign\n  pp-number E sign\n  pp-number p sign\n  pp-number P sign\n  pp-number .\n","P2":"Description\nA preprocessing number begins with a digit optionally preceded by a\nperiod (.) and may be followed by valid identifier characters and the\ncharacter sequences e+, e-, E+, E-, p+, p-, P+, or P-.\n","P3":"Preprocessing number tokens lexically include all floating and integer\nconstant tokens.\n","P4":"Semantics\nA preprocessing number does not have type or a value; it acquires both\nafter a successful conversion (as part of translation phase 7) to a\nfloating constant token or an integer constant token.\n"},"9":{"title":"Comments","P1":"Except within a character constant, a string literal, or a comment, the characters /* introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters */ that terminate it. <foot>Thus, /* ... */ comments do not nest.</foot>\n","P2":"Except within a character constant, a string literal, or a comment, the characters // introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identify multibyte characters and to find the terminating new-line character.\n","P3":"EXAMPLE\n<code>\n\"a//b\"                      // four-character string literal\n\\#include \"//e\"             // undefined behavior\n// */                       // comment, not syntax error\nf = g/**//h;                // equivalent to f = g / h;\n//\\\ni();                        // part of a two-line comment\n/\\\n/ j();                      // part of a two-line comment\n\\#define glue(x,y) x##y\nglue(/,/) k();              // syntax error, not comment\n/*//*/ l();                 // equivalent to l();\nm = n//**/o\n+ p;                        // equivalent to m = n + p;\n</code>\n"},"title":"Lexical elements","P1":"Syntax\ntoken:\n  keyword\n  identifier\n  constant\n  string-literal\n  punctuator\npreprocessing-token:\n  header-name\n  identifier\n  pp-number\n  character-constant\n  string-literal\n  punctuator\n  each non-white-space character that cannot be one of the above\n","P2":"Constraints\nEach preprocessing token that is converted to a token shall have the\nlexical form of a keyword, an identifier, a constant, a string literal,\nor a punctuator.\n","P3":"Semantics\nA token is the minimal lexical element of the language in translation\nphases 7 and 8. The categories of tokens are: keywords, identifiers,\nconstants, string literals, and punctuators.  A preprocessing token is the\nminimal lexical element of the language in translation phases 3 through 6.\nThe categories of preprocessing tokens are: header names, identifiers,\npreprocessing numbers, character constants, string literals, punctuators,\nand single non-white-space characters that do not lexically match the other\npreprocessing token categories.<foot>An additional category, placemarkers,\nis used internally in translation phase 4 (see 6.10.3.3); it cannot occur\nin source files.</foot> If a \\' or a \\\" character matches the last category,\nthe behavior is undefined. Preprocessing tokens can be separated by white\nspace; this consists of comments (described later), or white-space\ncharacters (space, horizontal tab, new-line, vertical tab, and form-feed),\nor both. As described in 6.10, in certain circumstances during translation\nphase 4, white space (or the absence thereof) serves as more than\npreprocessing token separation. White space may appear within a\npreprocessing token only as part of a header name or between the quotation\ncharacters in a character constant or string literal.\n","P4":"If the input stream has been parsed into preprocessing tokens up to a given character, the next preprocessing token is the longest sequence of characters that could constitute a preprocessing token. There is one exception to this rule: header name preprocessing tokens are recognized only within #include preprocessing directives and in implementation-defined locations within #pragma directives. In such contexts, a sequence of characters that could be either a header name or a string literal is recognized as the former.\n","P5":"EXAMPLE 1 The program fragment 1Ex is parsed as a preprocessing number token (one that is not a valid floating or integer constant token), even though a parse as the pair of preprocessing tokens 1 and Ex might produce a valid expression (for example, if Ex were a macro defined as +1). Similarly, the program fragment 1E1 is parsed as a preprocessing number (one that is a valid floating constant token), whether or not E is a macro name.\n","P6":"EXAMPLE 2 The program fragment x+++++y is parsed as x ++ ++ + y, which violates a constraint on increment operators, even though the parse x ++ + ++ y might yield a correct expression.\n"},"5":{"1":{"1":{"title":"Generic selection","P1":"Syntax\ngeneric-selection:\n  _Generic ( assignment-expression , generic-assoc-list )\ngeneric-assoc-list:\n  generic-association\n  generic-assoc-list , generic-association\ngeneric-association:\n  type-name : assignment-expression\n  default : assignment-expression\n","P2":"Constraints\nA generic selection shall have no more than one default generic\nassociation. The type name in a generic association shall specify a\ncomplete object type other than a variably modified type. No two\ngeneric associations in the same generic selection shall specify\ncompatible types. The controlling expression of a generic selection\nshall have type compatible with at most one of the types named in its\ngeneric association list. If a generic selection has no default\ngeneric association, its controlling expression shall have type\ncompatible with exactly one of the types named in its generic\nassociation list.\n","P3":"Semantics\nThe controlling expression of a generic selection is not evaluated.\nIf a generic selection has a generic association with a type name\nthat is compatible with the type of the controlling expression, then\nthe result expression of the generic selection is the expression in\nthat generic association. Otherwise, the result expression of the\ngeneric selection is the expression in the default generic\nassociation. None of the expressions from any other generic\nassociation of the generic selection is evaluated.\n","P4":"The type and value of a generic selection are identical to those of its result expression. It is an lvalue, a function designator, or a void expression if its result expression is, respectively, an lvalue, a function designator, or a void expression.\n","P5":"EXAMPLE\nThe cbrt type-generic macro could be implemented as follows:\n<code>\n\\#define cbrt(X) _Generic((X), \\\n            long double: cbrtl, \\\n            default: cbrt, \\\n            float: cbrtf \\\n            )(X)\n</code>\n"},"title":"Primary expressions","P1":"Syntax\nprimary-expression:\n  identifier\n  constant\n  string-literal\n  ( expression )\n  generic-selection\n  Semantics\n","P2":"An identifier is a primary expression, provided it has been declared as designating an object (in which case it is an lvalue) or a function (in which case it is a function designator).<foot>Thus, an undeclared identifier is a violation of the syntax.</foot>\n","P3":"A constant is a primary expression. Its type depends on its form and value, as detailed in 6.4.4.\n","P4":"A string literal is a primary expression. It is an lvalue with type as detailed in 6.4.5.\n","P5":"A parenthesized expression is a primary expression. Its type and value are identical to those of the unparenthesized expression. It is an lvalue, a function designator, or a void expression if the unparenthesized expression is, respectively, an lvalue, a function designator, or a void expression.\n","P6":"A generic selection is a primary expression. Its type and value depend on the selected generic association, as detailed in the following subclause.\n"},"2":{"1":{"title":"Array subscripting","P1":"Constraints\nOne of the expressions shall have type ‘‘pointer to complete object\ntype’’, the other expression shall have integer type, and the result\nhas type ‘‘type’’.\n","P2":"Semantics\nA postfix expression followed by an expression in square brackets []\nis a subscripted designation of an element of an array object. The\ndefinition of the subscript operator [] is that E1[E2] is identical\nto (*((E1)+(E2))). Because of the conversion rules that apply to the\nbinary + operator, if E1 is an array object (equivalently, a pointer\nto the initial element of an array object) and E2 is an integer,\nE1[E2] designates the E2-th element of E1 (counting from zero).\n","P3":"Successive subscript operators designate an element of a multidimensional array object.  If E is an n-dimensional array (n ≥ 2) with dimensions i × j × . . . × k, then E (used as other than an lvalue) is converted to a pointer to an (n − 1)-dimensional array with dimensions j × . . . × k. If the unary * operator is applied to this pointer explicitly, or implicitly as a result of subscripting, the result is the referenced (n − 1)-dimensional array, which itself is converted into a pointer if used as other than an lvalue. It follows from this that arrays are stored in row-major order (last subscript varies fastest).\n","P4":"EXAMPLE\nConsider the array object defined by the declaration\n<code>\n  int x[3][5];\n</code>\nHere x is a 3 × 5 array of ints; more precisely, x is an array of\nthree element objects, each of which is an array of five ints. In the\nexpression x[i], which is equivalent to (*((x)+(i))), x is first\nconverted to a pointer to the initial array of five ints. Then i is\nadjusted according to the type of x, which conceptually entails\nmultiplying i by the size of the object to which the pointer points,\nnamely an array of five int objects. The results are added and\nindirection is applied to yield an array of five ints. When used in\nthe expression x[i][j], that array is in turn converted to a pointer\nto the first of the ints, so x[i][j] yields an int.\n"},"2":{"title":"Function calls","P1":"Constraints\nThe expression that denotes the called function<foot>Most often, this\nis the result of converting an identifier that is a function\ndesignator.</foot> shall have type pointer to function returning void\nor returning a complete object type other than an array type.\n","P2":"If the expression that denotes the called function has a type that includes a prototype, the number of arguments shall agree with the number of parameters. Each argument shall have a type such that its value may be assigned to an object with the unqualified version of the type of its corresponding parameter.\n","P3":"Semantics\nA postfix expression followed by parentheses () containing a possibly\nempty, commaseparated list of expressions is a function call. The\npostfix expression denotes the called function. The list of\nexpressions specifies the arguments to the function.\n","P4":"An argument may be an expression of any complete object type. In preparing for the call to a function, the arguments are evaluated, and each parameter is assigned the value of the corresponding argument.<foot>A function may change the values of its parameters, but these changes cannot affect the values of the arguments. On the other hand, it is possible to pass a pointer to an object, and the function may change the value of the object pointed to. A parameter declared to have array or function type is adjusted to have a pointer type as described in 6.9.1.</foot>\n","P5":"If the expression that denotes the called function has type pointer to function returning an object type, the function call expression has the same type as that object type, and has the value determined as specified in 6.8.6.4. Otherwise, the function call has type void.\n","P6":"If the expression that denotes the called function has a type that\ndoes not include a prototype, the integer promotions are performed on\neach argument, and arguments that have type float are promoted to\ndouble. These are called the default argument promotions. If the\nnumber of arguments does not equal the number of parameters, the\nbehavior is undefined. If the function is defined with a type that\nincludes a prototype, and either the prototype ends with an ellipsis\n(, ...) or the types of the arguments after promotion are not\ncompatible with the types of the parameters, the behavior is\nundefined.  If the function is defined with a type that does not\ninclude a prototype, and the types of the arguments after promotion\nare not compatible with those of the parameters after promotion, the\nbehavior is undefined, except for the following cases:\n— one promoted type is a signed integer type, the other promoted type\nis the corresponding unsigned integer type, and the value is\nrepresentable in both types;\n— both types are pointers to qualified or unqualified versions of a\ncharacter type or void.\n","P7":"If the expression that denotes the called function has a type that does include a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters, taking the type of each parameter to be the unqualified version of its declared type. The ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default argument promotions are performed on trailing arguments.\n","P8":"No other conversions are performed implicitly; in particular, the number and types of arguments are not compared with those of the parameters in a function definition that does not include a function prototype declarator.\n","P9":"If the function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function, the behavior is undefined.\n","P10":"There is a sequence point after the evaluations of the function designator and the actual arguments but before the actual call. Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function. <foot>In other words, function executions do not ‘‘interleave’’ with each other.</foot>\n","P11":"Recursive function calls shall be permitted, both directly and indirectly through any chain of other functions.\n","P12":"EXAMPLE\nIn the function call\n<code>\n  (*pf[f1()]) (f2(), f3() + f4())\n</code>\nthe functions f1, f2, f3, and f4 may be called in any order. All side\neffects have to be completed before the function pointed to by\npf[f1()] is called.\n"},"3":{"title":"Structure and union members","P1":"Constraints\nThe first operand of the . operator shall have an atomic, qualified,\nor unqualified structure or union type, and the second operand shall\nname a member of that type.\n","P2":"The first operand of the -> operator shall have type ‘‘pointer to atomic, qualified, or unqualified structure’’ or ‘‘pointer to atomic, qualified, or unqualified union’’, and the second operand shall name a member of the type pointed to.\n","P3":"Semantics\nA postfix expression followed by the . operator and an identifier\ndesignates a member of a structure or union object. The value is that\nof the named member,<foot>If the member used to read the contents of\na union object is not the same as the member last used to store a\nvalue in the object, the appropriate part of the object\nrepresentation of the value is reinterpreted as an object\nrepresentation in the new type as described in 6.2.6 (a process\nsometimes called ‘‘type punning’’). This might be a trap\nrepresentation.</foot> and is an lvalue if the first expression is an\nlvalue. If the first expression has qualified type, the result has\nthe so-qualified version of the type of the designated member.\n","P4":"A postfix expression followed by the -> operator and an identifier designates a member of a structure or union object. The value is that of the named member of the object to which the first expression points, and is an lvalue.<foot>If &E is a valid pointer expression (where & is the ‘‘address-of ’’ operator, which generates a pointer to its operand), the expression (&E)->MOS is the same as E.MOS.</foot> If the first expression is a pointer to a qualified type, the result has the so-qualified version of the type of the designated member.\n","P5":"Accessing a member of an atomic structure or union object results in undefined behavior.<foot>For example, a data race would occur if access to the entire structure or union in one thread conflicts with access to a member from another thread, where at least one access is a modification. Members can be safely accessed using a non-atomic object which is assigned to or from the atomic object.</foot>\n","P6":"One special guarantee is made in order to simplify the use of unions: if a union contains several structures that share a common initial sequence (see below), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere that a declaration of the completed type of the union is visible. Two structures share a common initial sequence if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members.\n","P7":"EXAMPLE 1 If f is a function returning a structure or union, and x is a member of that structure or union, f().x is a valid postfix expression but is not an lvalue.\n","P8":"EXAMPLE 2\nIn:\n<code>\n  struct s { int i; const int ci; };\n  struct s s;\n  const struct s cs;\n  volatile struct s vs;\n</code>\nthe various members have the types:\n<code>\n  s.i    int\n  s.ci   const int\n  cs.i   const int\n  cs.ci  const int\n  vs.i   volatile int\n  vs.ci  volatile const int\n</code>\n","P9":"EXAMPLE 3\nThe following is a valid fragment:\n<code>\n  union {\n    struct {\n      int\n      alltypes;\n    } n;\n    struct {\n      int\n      type;\n      int\n      intnode;\n    } ni;\n    struct {\n      int\n      type;\n      double doublenode;\n    } nf;\n  } u;\n  u.nf.type = 1;\n  u.nf.doublenode = 3.14;\n  /* ... */\n  if (u.n.alltypes == 1)\n    if (sin(u.nf.doublenode) == 0.0)\n      /* ... */\n</code>\nThe following is not a valid fragment (because the union type is not\nvisible within function f):\n<code>\nstruct t1 { int m; };\nstruct t2 { int m; };\nint f(struct t1 *p1, struct t2 *p2)\n{\n  if (p1->m < 0)\n    p2->m = -p2->m;\n  return p1->m;\n}\nint g()\n{\n  union {\n    struct t1 s1;\n    struct t2 s2;\n  } u;\n  /* ... */\n  return f(&u.s1, &u.s2);\n}\n</code>\n"},"4":{"title":"Postfix increment and decrement operators","P1":"Constraints\nThe operand of the postfix increment or decrement operator shall have\natomic, qualified, or unqualified real or pointer type, and shall be\na modifiable lvalue.\n","P2":"Semantics\nThe result of the postfix ++ operator is the value of the operand. As\na side effect, the value of the operand object is incremented (that\nis, the value 1 of the appropriate type is added to it). See the\ndiscussions of additive operators and compound assignment for\ninformation on constraints, types, and conversions and the effects of\noperations on pointers. The value computation of the result is\nsequenced before the side effect of updating the stored value of the\noperand. With respect to an indeterminately-sequenced function call,\nthe operation of postfix ++ is a single evaluation. Postfix ++ on an\nobject with atomic type is a read-modify-write operation with\nmemory_order_seq_cst memory order semantics.\n<foot> Where a pointer to an atomic object can be formed and E has\ninteger type, E++ is equivalent to the following code sequence where T\nis the type of E:\n  <code>\n  T *addr = &E;\n  T old = *addr;\n  T new;\n  do {\n    new = old + 1;\n  } while (!atomic_compare_exchange_strong(addr, &old, new));\n</code>\nwith old being the result of the operation.  Special care must be\ntaken if E has floating type; see 6.5.16.2.</foot>\n","P3":"The postfix -- operator is analogous to the postfix ++ operator, except that the value of the operand is decremented (that is, the value 1 of the appropriate type is subtracted from it).\n"},"5":{"title":"Compound literals","P1":"Constraints\nThe type name shall specify a complete object type or an array of\nunknown size, but not a variable length array type.\n","P2":"All the constraints for initializer lists in 6.7.9 also apply to compound literals.\n","P3":"Semantics\nA postfix expression that consists of a parenthesized type name\nfollowed by a braceenclosed list of initializers is a compound\nliteral. It provides an unnamed object whose value is given by the\ninitializer list.\n<foot>Note that this differs from a cast expression. For example, a\ncast specifies a conversion to scalar types or void only, and the\nresult of a cast expression is not an lvalue.</foot>\n","P4":"If the type name specifies an array of unknown size, the size is determined by the initializer list as specified in 6.7.9, and the type of the compound literal is that of the completed array type. Otherwise (when the type name specifies an object type), the type of the compound literal is that specified by the type name. In either case, the result is an lvalue.\n","P5":"The value of the compound literal is that of an unnamed object initialized by the initializer list. If the compound literal occurs outside the body of a function, the object has static storage duration; otherwise, it has automatic storage duration associated with the enclosing block.\n","P6":"All the semantic rules for initializer lists in 6.7.9 also apply to compound literals. <foot>For example, subobjects without explicit initializers are initialized to zero.</foot>\n","P7":"String literals, and compound literals with const-qualified types, need not designate distinct objects.<foot>This allows implementations to share storage for string literals and constant compound literals with the same or overlapping representations.</foot>\n","P8":"EXAMPLE 1\nThe file scope definition\n<code>\n  int *p = (int []){2, 4};\n</code>\ninitializes p to point to the first element of an array of two ints,\nthe first having the value two and the second, four. The expressions\nin this compound literal are required to be constant. The unnamed\nobject has static storage duration.\n","P9":"EXAMPLE 2\nIn contrast, in\n<code>\nvoid f(void)\n{\n  int *p;\n  /*...*/\n  p = (int [2]){*p};\n  /*...*/\n}\n</code>\np is assigned the address of the first element of an array of two\nints, the first having the value previously pointed to by p and the\nsecond, zero. The expressions in this compound literal need not be\nconstant. The unnamed object has automatic storage duration.\n","P10":"EXAMPLE 3 Initializers with designations can be combined with\ncompound literals. Structure objects created using compound literals\ncan be passed to functions without depending on member order:\n<code>\n  drawline((struct point){.x=1, .y=1},\n  (struct point){.x=3, .y=4});\n</code>\nOr, if drawline instead expected pointers to struct point:\n<code>\n  drawline(&(struct point){.x=1, .y=1},\n  &(struct point){.x=3, .y=4});\n</code>\n","P11":"EXAMPLE 4\nA read-only compound literal can be specified through constructions like:\n<code>\n  (const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6}\n</code>\n","P12":"EXAMPLE 5\nThe following three expressions have different meanings:\n<code>\n  \"/tmp/fileXXXXXX\"\n  (char []){\"/tmp/fileXXXXXX\"}\n  (const char []){\"/tmp/fileXXXXXX\"}\n</code>\nThe first always has static storage duration and has type array of\nchar, but need not be modifiable; the last two have automatic storage\nduration when they occur within the body of a function, and the first\nof these two is modifiable.\n","P13":"EXAMPLE 6 Like string literals, const-qualified compound literals can\nbe placed into read-only memory and can even be shared. For example,\n<code>\n  (const char []){\"abc\"} == \"abc\"\n</code>\nmight yield 1 if the literals’ storage is shared.\n","P14":"EXAMPLE 7 Since compound literals are unnamed, a single compound\nliteral cannot specify a circularly linked object. For example, there\nis no way to write a self-referential compound literal that could be\nused as the function argument in place of the named object\nendless_zeros below:\n<code>\n  struct int_list { int car; struct int_list *cdr; };\n  struct int_list endless_zeros = {0, &endless_zeros};\n  eval(endless_zeros);\n</code>\n","P15":"EXAMPLE 8\nEach compound literal creates only a single object in a given scope:\n<code>\n  struct s { int i; };\n  int f (void)\n  {\n    struct s *p = 0, *q;\n    int j = 0;\n  again:\n    q = p, p = &((struct s){ j++ });\n    if (j < 2) goto again;\n    return p == q && q->i == 1;\n  }\n</code>\nThe function f() always returns the value 1.\n","P16":"Note that if an iteration statement were used instead of an explicit goto and a labeled statement, the lifetime of the unnamed object would be the body of the loop only, and on entry next time around p would have an indeterminate value, which would result in undefined behavior.\n"},"title":"Postfix operators","P1":"Syntax\npostfix-expression:\n  primary-expression\n  postfix-expression [ expression ]\n  postfix-expression ( argument-expression-listopt )\n  postfix-expression . identifier\n  postfix-expression -> identifier\n  postfix-expression ++\n  postfix-expression -( type-name ) { initializer-list }\n  ( type-name ) { initializer-list , }\nargument-expression-list:\n  assignment-expression\n  argument-expression-list , assignment-expression\n"},"3":{"1":{"title":"Prefix increment and decrement operators","P1":"Constraints\nThe operand of the prefix increment or decrement operator shall have\natomic, qualified, or unqualified real or pointer type, and shall be\na modifiable lvalue.\n","P2":"Semantics\nThe value of the operand of the prefix ++ operator is incremented.\nThe result is the new value of the operand after incrementation. The\nexpression ++E is equivalent to (E+=1).  See the discussions of\nadditive operators and compound assignment for information on\nconstraints, types, side effects, and conversions and the effects of\noperations on pointers.\n","P3":"The prefix -- operator is analogous to the prefix ++ operator, except that the value of the operand is decremented.\n"},"2":{"title":"Address and indirection operators","P1":"Constraints The operand of the unary & operator shall be either a\nfunction designator, the result of a [] or unary * operator, or an\nlvalue that designates an object that is not a bit-field and is not\ndeclared with the register storage-class specifier.\n","P2":"The operand of the unary * operator shall have pointer type.","P3":"Semantics\nThe unary & operator yields the address of its operand. If the\noperand has type ‘‘type’’, the result has type ‘‘pointer to type’’.\nIf the operand is the result of a unary * operator, neither that\noperator nor the & operator is evaluated and the result is as if both\nwere omitted, except that the constraints on the operators still\napply and the result is not an 88 lvalue. Similarly, if the operand\nis the result of a [] operator, neither the & operator nor the unary\n* that is implied by the [] is evaluated and the result is as if the\n& operator were removed and the [] operator were changed to a +\noperator. Otherwise, the result is a pointer to the object or\nfunction designated by its operand.\n","P4":"The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.<foot>Thus, &*E is equivalent to E (even if E is a null pointer), and &(E1[E2]) to ((E1)+(E2)). It is always true that if E is a function designator or an lvalue that is a valid operand of the unary & operator, *&E is a function designator or an lvalue equal to E. If *P is an lvalue and T is the name of an object pointer type, *(T)P is an lvalue that has a type compatible with that to which T points.  Among the invalid values for dereferencing a pointer by the unary * operator are a null pointer, an address inappropriately aligned for the type of object pointed to, and the address of an object after the end of its lifetime.</foot>\n"},"3":{"title":"Unary arithmetic operators","P1":"Constraints\nThe operand of the unary + or - operator shall have arithmetic type;\nof the ~ operator, integer type; of the ! operator, scalar type.\n","P2":"Semantics\nThe result of the unary + operator is the value of its (promoted)\noperand. The integer promotions are performed on the operand, and the\nresult has the promoted type.\n","P3":"The result of the unary - operator is the negative of its (promoted) operand. The integer promotions are performed on the operand, and the result has the promoted type.\n","P4":"The result of the ~ operator is the bitwise complement of its (promoted) operand (that is, each bit in the result is set if and only if the corresponding bit in the converted operand is not set). The integer promotions are performed on the operand, and the result has the promoted type. If the promoted type is an unsigned type, the expression ~E is equivalent to the maximum value representable in that type minus E.\n","P5":"The result of the logical negation operator ! is 0 if the value of its operand compares unequal to 0, 1 if the value of its operand compares equal to 0. The result has type int.  The expression !E is equivalent to (0==E).\n"},"4":{"title":"The sizeof and _Alignof operators","P1":"Constraints\nThe sizeof operator shall not be applied to an expression that has\nfunction type or an incomplete type, to the parenthesized name of\nsuch a type, or to an expression that designates a bit-field member.\nThe _Alignof operator shall not be applied to a function type or an\nincomplete type.\n","P2":"Semantics\nThe sizeof operator yields the size (in bytes) of its operand, which\nmay be an expression or the parenthesized name of a type. The size is\ndetermined from the type of the operand. The result is an integer. If\nthe type of the operand is a variable length array type, the operand\nis evaluated; otherwise, the operand is not evaluated and the result\nis an integer constant.\n","P3":"The _Alignof operator yields the alignment requirement of its operand type. The operand is not evaluated and the result is an integer constant. When applied to an array type, the result is the alignment requirement of the element type.\n","P4":"When sizeof is applied to an operand that has type char, unsigned char, or signed char, (or a qualified version thereof) the result is 1. When applied to an operand that has array type, the result is the total number of bytes in the array.<foot>When applied to a parameter declared to have array or function type, the sizeof operator yields the size of the adjusted (pointer) type (see 6.9.1).</foot> When applied to an operand that has structure or union type, the result is the total number of bytes in such an object, including internal and trailing padding.\n","P5":"The value of the result of both operators is implementation-defined, and its type (an unsigned integer type) is size_t, defined in <stddef.h> (and other headers).\n","P6":"EXAMPLE 1 A principal use of the sizeof operator is in communication\nwith routines such as storage allocators and I/O systems. A\nstorage-allocation function might accept a size (in bytes) of an object\nto allocate and return a pointer to void. For example:\n<code>\n  extern void *alloc(size_t);\n  double *dp = alloc(sizeof *dp);\n</code>\nThe implementation of the alloc function should ensure that its\nreturn value is aligned suitably for conversion to a pointer to\ndouble.\n","P7":"EXAMPLE 2\nAnother use of the sizeof operator is to compute the number of\nelements in an array:\n<code>\n  sizeof array / sizeof array[0]\n</code>\n","P8":"EXAMPLE 3\nIn this example, the size of a variable length array is computed and\nreturned from a function:\n<code>\n  \\#include <stddef.h>\n  size_t fsize3(int n)\n  {\n    char b[n+3]; // variable length array\n    return sizeof b; // execution time sizeof\n  }\n  int main()\n  {\n    size_t size;\n    size = fsize3(10); // fsize3 returns 13\n    return 0;\n  }\n</code>\n"},"title":"Unary operators","P1":"Syntax\nunary-expression:\n  postfix-expression\n  ++ unary-expression\n  -- unary-expression\n  unary-operator cast-expression\n  sizeof unary-expression\n  sizeof ( type-name )\n  _Alignof ( type-name )\nunary-operator: one of\n  & * + - ~ !\n"},"4":{"title":"Cast operators","P1":"Syntax\ncast-expression:\n  unary-expression\n  ( type-name ) cast-expression\n","P2":"Constraints\nUnless the type name specifies a void type, the type name shall specify\natomic, qualified, or unqualified scalar type, and the operand shall\nhave scalar type.\n","P3":"Conversions that involve pointers, other than where permitted by the constraints of 6.5.16.1, shall be specified by means of an explicit cast.\n","P4":"A pointer type shall not be converted to any floating type. A floating type shall not be converted to any pointer type.\n","P5":"Semantics\nPreceding an expression by a parenthesized type name converts the value\nof the expression to the named type. This construction is called a\ncast.<foot> A cast does not yield an lvalue. Thus, a cast to a\nqualified type has the same effect as a cast to the unqualified version\nof the type.</foot> A cast that specifies no conversion has no effect\non the type or value of an expression.\n","P6":"If the value of the expression is represented with greater range or precision than required by the type named by the cast (6.3.1.8), then the cast specifies a conversion even if the type of the expression is the same as the named type and removes any extra range and precision.\n"},"5":{"title":"Multiplicative operators","P1":"Syntax\nmultiplicative-expression:\n  cast-expression\n  multiplicative-expression * cast-expression\n  multiplicative-expression / cast-expression\n  multiplicative-expression % cast-expression\n","P2":"Constraints\nEach of the operands shall have arithmetic type. The operands of the %\noperator shall have integer type.\n","P3":"Semantics\nThe usual arithmetic conversions are performed on the operands.\n","P4":"The result of the binary * operator is the product of the operands.\n","P5":"The result of the / operator is the quotient from the division of the first operand by the second; the result of the % operator is the remainder. In both operations, if the value of the second operand is zero, the behavior is undefined.\n","P6":"When integers are divided, the result of the / operator is the algebraic quotient with any fractional part discarded.<foot>This is often called ‘‘truncation toward zero’’.</foot> If the quotient a/b is representable, the expression (a/b)*b + a%b shall equal a; otherwise, the behavior of both a/b and a%b is undefined.\n"},"6":{"titlle":"Additive operators","P1":"Syntax\nadditive-expression:\n  multiplicative-expression\n  additive-expression + multiplicative-expression\n  additive-expression - multiplicative-expression\n","P2":"Constraints\nFor addition, either both operands shall have arithmetic type, or one\noperand shall be a pointer to a complete object type and the other\nshall have integer type. (Incrementing is equivalent to adding 1.)\n","P3":"For subtraction, one of the following shall hold:\n— both operands have arithmetic type;\n— both operands are pointers to qualified or unqualified versions of\ncompatible complete object types; or\n— the left operand is a pointer to a complete object type and the right\noperand has integer type.\n(Decrementing is equivalent to subtracting 1.)\n","P4":"Semantics\nIf both operands have arithmetic type, the usual arithmetic conversions\nare performed on them.\n","P5":"The result of the binary + operator is the sum of the operands.\n","P6":"The result of the binary - operator is the difference resulting from the subtraction of the second operand from the first.\n","P7":"For the purposes of these operators, a pointer to an object that is not an element of an array behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.\n","P8":"When an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression. In other words, if the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N (where N has the value n) point to, respectively, the i+n-th and i−n-th elements of the array object, provided they exist. Moreover, if the expression P points to the last element of an array object, the expression (P)+1 points one past the last element of the array object, and if the expression Q points one past the last element of an array object, the expression (Q)-1 points to the last element of the array object. If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined. If the result points one past the last element of the array object, it shall not be used as the operand of a unary * operator that is evaluated.\n","P9":"When two pointers are subtracted, both shall point to elements of the same array object, or one past the last element of the array object; the result is the difference of the subscripts of the two array elements. The size of the result is implementation-defined, and its type (a signed integer type) is ptrdiff_t defined in the <stddef.h> header.  If the result is not representable in an object of that type, the behavior is undefined. In other words, if the expressions P and Q point to, respectively, the i-th and j-th elements of an array object, the expression (P)-(Q) has the value i−j provided the value fits in an object of type ptrdiff_t. Moreover, if the expression P points either to an element of an array object or one past the last element of an array object, and the expression Q points to the last element of the same array object, the expression ((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the expression P points one past the last element of the array object, even though the expression (Q)+1 does not point to an element of the array object.<foot>Another way to approach pointer arithmetic is first to convert the pointer(s) to character pointer(s): In this scheme the integer expression added to or subtracted from the converted pointer is first multiplied by the size of the object originally pointed to, and the resulting pointer is converted back to the original type. For pointer subtraction, the result of the difference between the character pointers is similarly divided by the size of the object originally pointed to. When viewed in this way, an implementation need only provide one extra byte (which may overlap another object in the program) just after the end of the object in order to satisfy the ‘‘one past the last element’’ requirements.</foot>\n","P10":"EXAMPLE\nPointer arithmetic is well defined with pointers to variable length\narray types.\n<code>\n{\n  int n = 4, m = 3;\n  int a[n][m];\n  int (*p)[m] = a; // p == &a[0]\n  p += 1;          // p == &a[1]\n  (*p)[2] = 99;    // a[1][2] == 99\n  n = p - a;       // n == 1\n}\n</code>\n","P11":"If array a in the above example were declared to be an array of known constant size, and pointer p were declared to be a pointer to an array of the same known constant size (pointing to a), the results would be the same.\n"},"7":{"title":"Bitwise shift operators","P1":"Syntax\nshift-expression:\n  additive-expression\n  shift-expression << additive-expression\n  shift-expression >> additive-expression\n","P2":"Constraints\nEach of the operands shall have integer type.\n","P3":"Semantics\nThe integer promotions are performed on each of the operands. The type\nof the result is that of the promoted left operand. If the value of the\nright operand is negative or is greater than or equal to the width of\nthe promoted left operand, the behavior is undefined.\n","P4":"The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has an unsigned type, the value of the result is E1 × 2E2 , reduced modulo one more than the maximum value representable in the result type. If E1 has a signed type and nonnegative value, and E1 × 2E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.\n","P5":"The result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2 . If E1 has a signed type and a negative value, the resulting value is implementation-defined.\n"},"8":{"title":"Relational operators","P1":"Syntax\nrelational-expression:\n  shift-expression\n  relational-expression < shift-expression\n  relational-expression > shift-expression\n  relational-expression <= shift-expression\n  relational-expression >= shift-expression\n","P2":"Constraints\nOne of the following shall hold:\n— both operands have real type; or\n— both operands are pointers to qualified or unqualified versions of\ncompatible object types.\n","P3":"Semantics\nIf both of the operands have arithmetic type, the usual arithmetic\nconversions are performed.\n","P4":"For the purposes of these operators, a pointer to an object that is not an element of an array behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.\n","P5":"When two pointers are compared, the result depends on the relative locations in the address space of the objects pointed to. If two pointers to object types both point to the same object, or both point one past the last element of the same array object, they compare equal. If the objects pointed to are members of the same aggregate object, pointers to structure members declared later compare greater than pointers to members declared earlier in the structure, and pointers to array elements with larger subscript values compare greater than pointers to elements of the same array with lower subscript values. All pointers to members of the same union object compare equal. If the expression P points to an element of an array object and the expression Q points to the last element of the same array object, the pointer expression Q+1 compares greater than P. In all other cases, the behavior is undefined.\n","P6":"Each of the operators < (less than), > (greater than), <= (less than or equal to), and >= (greater than or equal to) shall yield 1 if the specified relation is true and 0 if it is false.<foot>The expression a<b<c is not interpreted as in ordinary mathematics. As the syntax indicates, it means (a<b)<c; in other words, ‘‘if a is less than b, compare 1 to c; otherwise, compare 0 to c’’.</foot>) The result has type int.\n"},"9":{"title":"Equality operators","P1":"Syntax\nequality-expression:\n  relational-expression\n  equality-expression == relational-expression\n  equality-expression != relational-expression\n","P2":"Constraints\nOne of the following shall hold:\n— both operands have arithmetic type;\n— both operands are pointers to qualified or unqualified versions of\ncompatible types;\n— one operand is a pointer to an object type and the other is a pointer\nto a qualified or unqualified version of void; or\n— one operand is a pointer and the other is a null pointer constant.\n","P3":"Semantics\nThe == (equal to) and != (not equal to) operators are analogous to the\nrelational operators except for their lower precedence.<foot>Because of\nthe precedences, a<b == c<d is 1 whenever a<b and c<d have the same\ntruth-value.</foot> Each of the operators yields 1 if the specified\nrelation is true and 0 if it is false. The result has type int. For any\npair of operands, exactly one of the relations is true.\n","P4":"If both of the operands have arithmetic type, the usual arithmetic conversions are performed. Values of complex types are equal if and only if both their real parts are equal and also their imaginary parts are equal. Any two values of arithmetic types from different type domains are equal if and only if the results of their conversions to the (complex) result type determined by the usual arithmetic conversions are equal.\n","P5":"Otherwise, at least one operand is a pointer. If one operand is a pointer and the other is a null pointer constant, the null pointer constant is converted to the type of the pointer. If one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified version of void, the former is converted to the type of the latter.\n","P6":"Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function, both are pointers to one past the last element of the same array object, or one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array object that happens to immediately follow the first array object in the address space. <foot>Two objects may be adjacent in memory because they are adjacent elements of a larger array or adjacent members of a structure with no padding between them, or because the implementation chose to place them so, even though they are unrelated. If prior invalid pointer operations (such as accesses outside array bounds) produced undefined behavior, subsequent comparisons also produce undefined behavior.</foot>\n","P7":"For the purposes of these operators, a pointer to an object that is not an element of an array behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.\n"},"10":{"title":"Bitwise AND operator","P1":"Syntax\nAND-expression:\n  equality-expression\n  AND-expression & equality-expression\n","P2":"Constraints\nEach of the operands shall have integer type.\n","P3":"Semantics\nThe usual arithmetic conversions are performed on the operands.\n","P4":"The result of the binary & operator is the bitwise AND of the operands (that is, each bit in the result is set if and only if each of the corresponding bits in the converted operands is set).\n"},"11":{"title":"exclusive OR operator","P1":"Syntax\nexclusive-OR-expression:\n  AND-expression\n  exclusive-OR-expression ^ AND-expression\n","P2":"Constraints\nEach of the operands shall have integer type.\n","P3":"Semantics\nThe usual arithmetic conversions are performed on the operands.\n","P4":"The result of the ^ operator is the bitwise exclusive OR of the operands (that is, each bit in the result is set if and only if exactly one of the corresponding bits in the converted operands is set).\n"},"12":{"title":"Bitwise inclusive OR operator","P1":"Syntax\ninclusive-OR-expression:\n  exclusive-OR-expression\n  inclusive-OR-expression | exclusive-OR-expression\n","P2":"Constraints\nEach of the operands shall have integer type.\n","P3":"Semantics\nThe usual arithmetic conversions are performed on the operands.\n","P4":"The result of the | operator is the bitwise inclusive OR of the operands (that is, each bit in the result is set if and only if at least one of the corresponding bits in the converted operands is set).\n"},"13":{"title":"Logical AND operator","P1":"Syntax\nlogical-AND-expression:\n  inclusive-OR-expression\n  logical-AND-expression && inclusive-OR-expression\n","P2":"Constraints\nEach of the operands shall have scalar type.\n","P3":"Semantics\nThe && operator shall yield 1 if both of its operands compare unequal\nto 0; otherwise, it yields 0. The result has type int.\n","P4":"Unlike the bitwise binary & operator, the && operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares equal to 0, the second operand is not evaluated.\n"},"14":{"title":"Logical OR operator","P1":"Syntax\nlogical-OR-expression:\n  logical-AND-expression\n  logical-OR-expression || logical-AND-expression\n","P2":"Constraints\nEach of the operands shall have scalar type.\n","P3":"Semantics\nThe || operator shall yield 1 if either of its operands compare unequal\nto 0; otherwise, it yields 0. The result has type int.\n","P4":"Unlike the bitwise | operator, the || operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares unequal to 0, the second operand is not evaluated.\n"},"15":{"title":"Conditional operator","P1":"Syntax\nconditional-expression:\n  logical-OR-expression\n  logical-OR-expression ? expression : conditional-expression\n","P2":"Constraints\nThe first operand shall have scalar type.\n","P3":"One of the following shall hold for the second and third operands:\n— both operands have arithmetic type;\n— both operands have the same structure or union type;\n— both operands have void type;\n— both operands are pointers to qualified or unqualified versions of\ncompatible types;\n— one operand is a pointer and the other is a null pointer constant; or\n— one operand is a pointer to an object type and the other is a pointer\nto a qualified or unqualified version of void.\n","P4":"Semantics\nThe first operand is evaluated; there is a sequence point between its\nevaluation and the evaluation of the second or third operand (whichever\nis evaluated). The second operand is evaluated only if the first\ncompares unequal to 0; the third operand is evaluated only if the first\ncompares equal to 0; the result is the value of the second or third\noperand (whichever is evaluated), converted to the type described\nbelow.<foot>A conditional expression does not yield an lvalue.</foot>\n","P5":"If both the second and third operands have arithmetic type, the result type that would be determined by the usual arithmetic conversions, were they applied to those two operands, is the type of the result. If both the operands have structure or union type, the result has that type. If both operands have void type, the result has void type.\n","P6":"If both the second and third operands are pointers or one is a null pointer constant and the other is a pointer, the result type is a pointer to a type qualified with all the type qualifiers of the types referenced by both operands. Furthermore, if both operands are pointers to compatible types or to differently qualified versions of compatible types, the result type is a pointer to an appropriately qualified version of the composite type; if one operand is a null pointer constant, the result has the type of the other operand; otherwise, one operand is a pointer to void or a qualified version of void, in which case the result type is a pointer to an appropriately qualified version of void.\n","P7":"EXAMPLE The common type that results when the second and third operands are pointers is determined in two independent stages. The appropriate qualifiers, for example, do not depend on whether the two pointers have compatible types.\n","P8":"Given the declarations\n<code>\n  const void *c_vp;\n  void *vp;\n  const int *c_ip;\n  volatile int *v_ip;\n  int *ip;\n  const char *c_cp;\n</code>\nthe third column in the following table is the common type that is the\nresult of a conditional expression in which the first two columns are the\nsecond and third operands (in either order):\n<code>\n  c_vp  c_ip  const void *\n  v_ip  0     volatile int *\n  c_ip v_ip   const volatile int *\n  vp   c_cp   const void *\n  ip   c_ip   const int *\n  vp   ip     void *\n</code>\n"},"16":{"1":{"title":"Simple assignment","P1":"Constraints\nOne of the following shall hold:<foot>The asymmetric appearance of\nthese constraints with respect to type qualifiers is due to the\nconversion (specified in 6.3.2.1) that changes lvalues to ‘‘the value\nof the expression’’ and thus removes any type qualifiers that were\napplied to the type category of the expression (for example, it\nremoves const but not volatile from the type int volatile *\nconst).</foot>\n— the left operand has atomic, qualified, or unqualified arithmetic\ntype, and the right has arithmetic type;\n— the left operand has an atomic, qualified, or unqualified version\nof a structure or union type compatible with the type of the right;\n— the left operand has atomic, qualified, or unqualified pointer\ntype, and (considering the type the left operand would have after\nlvalue conversion) both operands are pointers to qualified or\nunqualified versions of compatible types, and the type pointed to by\nthe left has all the qualifiers of the type pointed to by the right;\n— the left operand has atomic, qualified, or unqualified pointer\ntype, and (considering the type the left operand would have after\nlvalue conversion) one operand is a pointer to an object type, and\nthe other is a pointer to a qualified or unqualified version of void,\nand the type pointed to by the left has all the qualifiers of the\ntype pointed to by the right;\n— the left operand is an atomic, qualified, or unqualified pointer,\nand the right is a null pointer constant; or\n— the left operand has type atomic, qualified, or unqualified _Bool,\nand the right is a pointer.\n","P2":"Semantics\nIn simple assignment (=), the value of the right operand is converted\nto the type of the assignment expression and replaces the value\nstored in the object designated by the left operand.\n","P3":"If the value being stored in an object is read from another object that overlaps in any way the storage of the first object, then the overlap shall be exact and the two objects shall have qualified or unqualified versions of a compatible type; otherwise, the behavior is undefined.\n","P4":"EXAMPLE 1\nIn the program fragment\n<code>\n  int f(void);\n  char c;\n  /* ... */\n  if ((c = f()) == -1)\n  /* ... */\n</code>\nthe int value returned by the function may be truncated when stored\nin the char, and then converted back to int width prior to the\ncomparison. In an implementation in which ‘‘plain’’ char has the same\nrange of values as unsigned char (and char is narrower than int), the\nresult of the conversion cannot be negative, so the operands of the\ncomparison can never compare equal. Therefore, for full portability,\nthe variable c should be declared as int.\n","P5":"EXAMPLE 2\nIn the fragment:\n<code>\n  char c;\n  int i;\n  long l;\n  l = (c = i);\n</code>\nthe value of i is converted to the type of the assignment expression\nc = i, that is, char type. The value of the expression enclosed in\nparentheses is then converted to the type of the outer assignment\nexpression, that is, long int type.\n","P6":"EXAMPLE 3\nConsider the fragment:\n<code>\n  const char **cpp;\n  char *p;\n  const char c = 'A';\n  cpp = &p; // constraint violation\n  *cpp = &c; // valid\n  *p = 0; // valid\n</code>\nThe first assignment is unsafe because it would allow the following\nvalid code to attempt to change the value of the const object c.\n"},"2":{"title":"Compound assignment","P1":"Constraints\nFor the operators += and -= only, either the left operand shall be an\natomic, qualified, or unqualified pointer to a complete object type,\nand the right shall have integer type; or the left operand shall have\natomic, qualified, or unqualified arithmetic type, and the right\nshall have arithmetic type.\n","P2":"For the other operators, the left operand shall have atomic,\nqualified, or unqualified arithmetic type, and (considering the type\nthe left operand would have after lvalue conversion) each operand\nshall have arithmetic type consistent with those allowed by the\ncorresponding binary operator.\n","P3":"Semantics\nA compound assignment of the form E1 op = E2 is equivalent to the\nsimple assignment expression E1 = E1 op (E2), except that the lvalue\nE1 is evaluated only once, and with respect to an\nindeterminately-sequenced function call, the operation of a compound\nassignment is a single evaluation. If E1 has an atomic type, compound\nassignment is a read-modify-write operation with memory_order_seq_cst\nmemory order semantics.<foot>Where a pointer to an atomic object can\nbe formed and E1 and E2 have integer type, this is equivalent to the\nfollowing code sequence where T1 is the type of E1 and T2 is the type\nof E2:\n<code>\n  T1 *addr = &E1;\n  T2 val = (E2);\n  T1 old = *addr;\n  T1 new;\n  do {\n    new = old op val;\n  } while (!atomic_compare_exchange_strong(addr, &old, new));\n</code>\nwith new being the result of the operation.\nIf E1 or E2 has floating type, then exceptional conditions or\nfloating-point exceptions encountered during discarded evaluations of\nnew should also be discarded in order to satisfy the equivalence of\nE1 op = E2 and E1 = E1 op (E2). For example, if annex F is in effect,\nthe floating types involved have IEC 60559 formats, and\nFLT_EVAL_METHOD is 0, the equivalent code would be:\n<code>\n  \\#include <fenv.h>\n  \\#pragma STDC FENV_ACCESS ON\n  /* ... */\n    fenv_t fenv;\n    T1 *addr = &E1;\n    T2 val = E2;\n    T1 old = *addr;\n    T1 new;\n    feholdexcept(&fenv);\n    for (;;) {\n      new = old op val;\n      if (atomic_compare_exchange_strong(addr, &old, new))\n        break;\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    feupdateenv(&fenv);\n</code>\nIf FLT_EVAL_METHOD is not 0, then T2 must be a type with the range\nand precision to which E2 is evaluated in order to satisfy the\nequivalence.</foot>\n"},"title":"Assignment operators","P1":"Syntax\nassignment-expression:\n  conditional-expression\n  unary-expression assignment-operator assignment-expression\nassignment-operator: one of\n  = *= /= %= += -= <<= >>= &= ^= |=\n","P2":"Constraints\nAn assignment operator shall have a modifiable lvalue as its left operand.\n","P3":"Semantics\nAn assignment operator stores a value in the object designated by the\nleft operand. An assignment expression has the value of the left\noperand after the assignment,<foot>The implementation is permitted to\nread the object to determine the value but is not required to, even\nwhen the object has volatile-qualified type.</foot> but is not an\nlvalue. The type of an assignment expression is the type the left\noperand would have after lvalue conversion. The side effect of updating\nthe stored value of the left operand is sequenced after the value\ncomputations of the left and right operands. The evaluations of the\noperands are unsequenced.\n"},"17":{"title":"Comma operator","P1":"Syntax\nexpression:\n  assignment-expression\n  expression , assignment-expression\n","P2":"Semantics\nThe left operand of a comma operator is evaluated as a void expression;\nthere is a sequence point between its evaluation and that of the right\noperand. Then the right operand is evaluated; the result has its type\nand value.<foot>A comma operator does not yield an lvalue.</foot>\n","P3":"EXAMPLE As indicated by the syntax, the comma operator (as described in this subclause) cannot appear in contexts where a comma is used to separate items in a list (such as arguments to functions or lists of initializers). On the other hand, it can be used within a parenthesized expression or within the second expression of a conditional operator in such contexts. In the function call f(a, (t=3, t+2), c) the function has three arguments, the second of which has the value 5.\n"},"title":"Expressions","P1":"An expression is a sequence of operators and operands that specifies computation of a value, or that designates an object or a function, or that generates side effects, or that performs a combination thereof. The value computations of the operands of an operator are sequenced before the value computation of the result of the operator.\n","P2":"If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings. <foot>This paragraph renders undefined statement expressions such as <code>  i = ++i + 1;\n  a[i++] = i;\n</code> while allowing <code>  i = i + 1;\n  a[i] = i;\n</code> </foot>\n","P3":"The grouping of operators and operands is indicated by the syntax. <foot>The syntax specifies the precedence of operators in the evaluation of an expression, which is the same as the order of the major subclauses of this subclause, highest precedence first. Thus, for example, the expressions allowed as the operands of the binary + operator (6.5.6) are those expressions defined in 6.5.1 through 6.5.6. The exceptions are cast expressions (6.5.4) as operands of unary operators (6.5.3), and an operand contained between any of the following pairs of operators: grouping parentheses () (6.5.1), subscripting brackets [] (6.5.2.1), function-call parentheses () (6.5.2.2), and the conditional operator ? : (6.5.15). Within each major subclause, the operators have the same precedence. Left- or right-associativity is indicated in each subclause by the syntax for the expressions discussed therein.</foot> Except as specified later, side effects and value computations of subexpressions are unsequenced.<foot>In an expression that is evaluated more than once during the execution of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations.</foot>\n","P4":"Some operators (the unary operator ~, and the binary operators <<, >>, &, ^, and |, collectively described as bitwise operators) are required to have operands that have integer type. These operators yield values that depend on the internal representations of integers, and have implementation-defined and undefined aspects for signed types.\n","P5":"If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined.\n","P6":"The effective type of an object for an access to its stored value is the declared type of the object, if any.<foot>Allocated objects have no declared type.</foot> If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value. If a value is copied into an object having no declared type using memcpy or memmove, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one. For all other accesses to an object having no declared type, the effective type of the object is simply the type of the lvalue used for the access.\n","P7":"An object shall have its stored value accessed only by an lvalue\nexpression that has one of the following types:<foot>The intent of this\nlist is to specify those circumstances in which an object may or may not\nbe aliased.</foot>\n— a type compatible with the effective type of the object,\n— a qualified version of a type compatible with the effective type of the\nobject,\n— a type that is the signed or unsigned type corresponding to the\neffective type of the object,\n— a type that is the signed or unsigned type corresponding to a qualified\nversion of the effective type of the object,\n— an aggregate or union type that includes one of the aforementioned\ntypes among its members (including, recursively, a member of a\nsubaggregate or contained union), or\n— a character type.\n","P8":"A floating expression may be contracted, that is, evaluated as though it were a single operation, thereby omitting rounding errors implied by the source code and the expression evaluation method.<foot>The intermediate operations in the contracted expression are evaluated as if to infinite range and precision, while the final operation is rounded to the format determined by the expression evaluation method. A contracted expression might also omit the raising of floating-point exceptions.</foot> The FP_CONTRACT pragma in <math.h> provides a way to disallow contracted expressions. Otherwise, whether and how expressions are contracted is implementation-defined.<foot>This license is specifically intended to allow implementations to exploit fast machine instructions that combine multiple C operators. As contractions potentially undermine predictability, and can even decrease accuracy for containing expressions, their use needs to be well-defined and clearly documented.</foot>\n"},"6":{"title":"Constant expressions","P1":"Syntax\nconstant-expression:\n  conditional-expression\n","P2":"Description\nA constant expression can be evaluated during translation rather than\nruntime, and accordingly may be used in any place that a constant may be.\n","P3":"Constraints\nConstant expressions shall not contain assignment, increment, decrement,\nfunction-call, or comma operators, except when they are contained within\na subexpression that is not evaluated. <foot>The operand of a sizeof or\n_Alignof operator is usually not evaluated (6.5.3.4).</foot>\n","P4":"Each constant expression shall evaluate to a constant that is in the range of representable values for its type.\n","P5":"Semantics\nAn expression that evaluates to a constant is required in several\ncontexts. If a floating expression is evaluated in the translation\nenvironment, the arithmetic range and precision shall be at least as\ngreat as if the expression were being evaluated in the execution\nenvironment.<foot>The use of evaluation formats as characterized by\nFLT_EVAL_METHOD also applies to evaluation in the translation\nenvironment.</foot>\n","P6":"An integer constant expression<foot>An integer constant expression is required in a number of contexts such as the size of a bit-field member of a structure, the value of an enumeration constant, and the size of a non-variable length array. Further constraints that apply to the integer constant expressions used in conditional-inclusion preprocessing directives are discussed in 6.10.1.</foot> shall have integer type and shall only have operands that are integer constants, enumeration constants, character constants, sizeof expressions whose results are integer constants, _Alignof expressions, and floating constants that are the immediate operands of casts. Cast operators in an integer constant expression shall only convert arithmetic types to integer types, except as part of an operand to the sizeof or _Alignof operator.\n","P7":"More latitude is permitted for constant expressions in initializers. Such\na constant expression shall be, or evaluate to, one of the following:\n— an arithmetic constant expression,\n— a null pointer constant,\n— an address constant, or\n— an address constant for a complete object type plus or minus an integer\nconstant expression.\n","P8":"An arithmetic constant expression shall have arithmetic type and shall only have operands that are integer constants, floating constants, enumeration constants, character constants, sizeof expressions whose results are integer constants, and _Alignof expressions. Cast operators in an arithmetic constant expression shall only convert arithmetic types to arithmetic types, except as part of an operand to a sizeof or _Alignof operator.\n","P9":"An address constant is a null pointer, a pointer to an lvalue designating an object of static storage duration, or a pointer to a function designator; it shall be created explicitly using the unary & operator or an integer constant cast to pointer type, or implicitly by the use of an expression of array or function type. The array-subscript [] and member-access .  and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators.\n","P10":"An implementation may accept other forms of constant expressions.","P11":"The semantic rules for the evaluation of a constant expression are the same as for nonconstant expressions.<foot>Thus, in the following initialization, static int i = 2 || 1 / 0; the expression is a valid integer constant expression with value one.</foot>\n"},"7":{"1":{"title":"Storage-class specifiers","P1":"Syntax\nstorage-class-specifier:\n  typedef\n  extern\n  static\n  _Thread_local\n  auto\n  register\n","P2":"Constraints\nAt most, one storage-class specifier may be given in the declaration\nspecifiers in a declaration, except that _Thread_local may appear with\nstatic or extern.<foot>See ‘‘future language directions’’ (6.11.5).</foot>\n","P3":"In the declaration of an object with block scope, if the declaration specifiers include _Thread_local, they shall also include either static or extern. If _Thread_local appears in any declaration of an object, it shall be present in every declaration of that object.\n","P4":"_Thread_local shall not appear in the declaration specifiers of a function declaration.\n","P5":"Semantics\nThe typedef specifier is called a ‘‘storage-class specifier’’ for\nsyntactic convenience only; it is discussed in 6.7.8. The meanings of\nthe various linkages and storage durations were discussed in 6.2.2 and\n6.2.4.\n","P6":"A declaration of an identifier for an object with storage-class specifier register suggests that access to the object be as fast as possible. The extent to which such suggestions are effective is implementation-defined.<foot>The implementation may treat any register declaration simply as an auto declaration. However, whether or not addressable storage is actually used, the address of any part of an object declared with storage-class specifier register cannot be computed, either explicitly (by use of the unary & operator as discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as discussed in 6.3.2.1). Thus, the only operator that can be applied to an array declared with storage-class specifier register is sizeof.</foot>\n","P7":"The declaration of an identifier for a function that has block scope shall have no explicit storage-class specifier other than extern.\n","P8":"If an aggregate or union object is declared with a storage-class specifier other than typedef, the properties resulting from the storage-class specifier, except with respect to linkage, also apply to the members of the object, and so on recursively for any aggregate or union member objects.\n"},"2":{"1":{"title":"Structure and union specifiers","P1":"Syntax\nstruct-or-union-specifier:\n  struct-or-union identifieropt { struct-declaration-list }\n  struct-or-union identifier\nstruct-or-union:\n  struct\n  union\nstruct-declaration-list:\n  struct-declaration\n  struct-declaration-list struct-declaration\nstruct-declaration:\n  specifier-qualifier-list struct-declarator-listopt ;\n  static_assert-declaration\nspecifier-qualifier-list:\n  type-specifier specifier-qualifier-listopt\n  type-qualifier specifier-qualifier-listopt\nstruct-declarator-list:\n  struct-declarator\n  struct-declarator-list , struct-declarator\nstruct-declarator:\n  declarator\ndeclaratoropt : constant-expression\n","P2":"Constraints\nA struct-declaration that does not declare an anonymous structure or\nanonymous union shall contain a struct-declarator-list.\n","P3":"A structure or union shall not contain a member with incomplete or function type (hence, a structure shall not contain an instance of itself, but may contain a pointer to an instance of itself), except that the last member of a structure with more than one named member may have incomplete array type; such a structure (and any union containing, possibly recursively, a member that is such a structure) shall not be a member of a structure or an element of an array.\n","P4":"The expression that specifies the width of a bit-field shall be an integer constant expression with a nonnegative value that does not exceed the width of an object of the type that would be specified were the colon and expression omitted.122) If the value is zero, the declaration shall have no declarator.\n","P5":"A bit-field shall have a type that is a qualified or unqualified version of _Bool, signed int, unsigned int, or some other implementation-defined type. It is implementation-defined whether atomic types are permitted.  122) While the number of bits in a _Bool object is at least CHAR_BIT, the width (number of sign and value bits) of a _Bool may be just 1 bit.\n","P6":"Semantics\nAs discussed in 6.2.5, a structure is a type consisting of a sequence\nof members, whose storage is allocated in an ordered sequence, and a\nunion is a type consisting of a sequence of members whose storage\noverlap.\n","P7":"Structure and union specifiers have the same form. The keywords struct and union indicate that the type being specified is, respectively, a structure type or a union type.\n","P8":"The presence of a struct-declaration-list in a struct-or-union-specifier declares a new type, within a translation unit. The struct-declaration-list is a sequence of declarations for the members of the structure or union. If the struct-declaration-list does not contain any named members, either directly or via an anonymous structure or anonymous union, the behavior is undefined. The type is incomplete until immediately after the } that terminates the list, and complete thereafter.\n","P9":"A member of a structure or union may have any complete object type other than a variably modified type.<foot>A structure or union cannot contain a member with a variably modified type because member names are not ordinary identifiers as defined in 6.2.3.</foot> In addition, a member may be declared to consist of a specified number of bits (including a sign bit, if any). Such a member is called a bit-field;<foot>The unary & (address-of) operator cannot be applied to a bit-field object; thus, there are no pointers to or arrays of bit-field objects.</foot> its width is preceded by a colon.\n","P10":"A bit-field is interpreted as having a signed or unsigned integer type consisting of the specified number of bits.<foot>As specified in 6.7.2 above, if the actual type specifier used is int or a typedef-name defined as int, then it is implementation-defined whether the bit-field is signed or unsigned.</foot> If the value 0 or 1 is stored into a nonzero-width bit-field of type _Bool, the value of the bit-field shall compare equal to the value stored; a _Bool bit-field has the semantics of a _Bool.\n","P11":"An implementation may allocate any addressable storage unit large enough to hold a bitfield. If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit. If insufficient space remains, whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is implementation-defined. The order of allocation of bit-fields within a unit (high-order to low-order or low-order to high-order) is implementation-defined. The alignment of the addressable storage unit is unspecified.\n","P12":"A bit-field declaration with no declarator, but only a colon and a width, indicates an unnamed bit-field.<foot>An unnamed bit-field structure member is useful for padding to conform to externally imposed layouts.</foot> As a special case, a bit-field structure member with a width of 0 indicates that no further bit-field is to be packed into the unit in which the previous bitfield, if any, was placed.\n","P13":"An unnamed member whose type specifier is a structure specifier with no tag is called an anonymous structure; an unnamed member whose type specifier is a union specifier with no tag is called an anonymous union. The members of an anonymous structure or union are considered to be members of the containing structure or union. This applies recursively if the containing structure or union is also anonymous.\n","P14":"Each non-bit-field member of a structure or union object is aligned in an implementation defined manner appropriate to its type.\n","P15":"Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.\n","P16":"The size of a union is sufficient to contain the largest of its members. The value of at most one of the members can be stored in a union object at any time. A pointer to a union object, suitably converted, points to each of its members (or if a member is a bitfield, then to the unit in which it resides), and vice versa.\n","P17":"There may be unnamed padding at the end of a structure or union.\n","P18":"As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply. However, when a . (or ->) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it.\n","P19":"EXAMPLE 1\nThe following illustrates anonymous structures and unions:\n<code>\n  struct v {\n    union {\n      // anonymous union\n      struct { int i, j; };\n      // anonymous structure\n      struct { long k, l; } w;\n    };\n    int m;\n  } v1;\n  v1.i = 2; // valid\n  v1.k = 3; // invalid: inner structure is not anonymous\n  v1.w.k = 5; // valid\n</code>\n","P20":"EXAMPLE 2\nAfter the declaration:\n<code>\n  struct s { int n; double d[]; };\n</code>\nthe structure struct s has a flexible array member d. A typical way\nto use this is:\n<code>\n  int m = /* some value */;\n  struct s *p = malloc(sizeof (struct s) + sizeof (double [m]));\n</code>\nand assuming that the call to malloc succeeds, the object pointed to\nby p behaves, for most purposes, as if p had been declared as:\n<code>\n  struct { int n; double d[m]; } *p;\n</code>\n(there are circumstances in which this equivalence is broken; in\nparticular, the offsets of member d might not be the same).\n","P21":"Following the above declaration:\n<code>\n  struct s t1 = { 0 }; // valid\n  struct s t2 = { 1, { 4.2 }}; // invalid\n  t1.n = 4; // valid\n  t1.d[0] = 4.2; // might be undefined behavior\n</code>\nThe initialization of t2 is invalid (and violates a constraint)\nbecause struct s is treated as if it did not contain member d. The\nassignment to t1.d[0] is probably undefined behavior, but it is\npossible that\n<code>\n  sizeof (struct s) >= offsetof(struct s, d) + sizeof (double)\n</code>\nin which case the assignment would be legitimate. Nevertheless, it\ncannot appear in strictly conforming code.\n","P22":"After the further declaration:\n<code>\n  struct ss { int n; };\n</code>\nthe expressions:\n<code>\n  sizeof (struct s) >= sizeof (struct ss)\n  sizeof (struct s) >= offsetof(struct s, d)\n</code>\nare always equal to 1.\n","P23":"If sizeof (double) is 8, then after the following code is executed:\n<code>\n  struct s *s1;\n  struct s *s2;\n  s1 = malloc(sizeof (struct s) + 64);\n  s2 = malloc(sizeof (struct s) + 46);\n</code>\nand assuming that the calls to malloc succeed, the objects pointed to\nby s1 and s2 behave, for most purposes, as if the identifiers had\nbeen declared as:\n<code>\n  struct { int n; double d[8]; } *s1;\n  struct { int n; double d[5]; } *s2;\n</code>\n","P24":"Following the further successful assignments:\n<code>\n  s1 = malloc(sizeof (struct s) + 10);\n  s2 = malloc(sizeof (struct s) + 6);\n</code>\nthey then behave as if the declarations were:\n<code>\n  struct { int n; double d[1]; } *s1, *s2;\n</code>\nand:\n<code>\n  double *dp;\n  dp = &(s1->d[0]); // valid\n  *dp = 42; // valid\n  dp = &(s2->d[0]); //valid\n  *dp = 42; // undefined behavior\n</code>\n","P25":"The assignment:\n<code>\n  *s1 = *s2;\n</code>\nonly copies the member n; if any of the array elements are within the\nfirst sizeof (struct s) bytes of the structure, they might be copied\nor simply overwritten with indeterminate values.\n","P26":"EXAMPLE 3 Because members of anonymous structures and unions are\nconsidered to be members of the containing structure or union, struct s\nin the following example has more than one named member and thus the\nuse of a flexible array member is valid:\n<code>\n  struct s {\n    struct { int i; };\n    int a[];\n  };\n</code>\n"},"2":{"title":"Enumeration specifiers","P1":"Syntax\nenum-specifier:\n  enum identifieropt { enumerator-list }\n  enum identifieropt { enumerator-list , }\n  enum identifier\nenumerator-list:\n  enumerator\n  enumerator-list , enumerator\nenumerator:\n  enumeration-constant\n  enumeration-constant = constant-expression\n","P2":"Constraints\nThe expression that defines the value of an enumeration constant\nshall be an integer constant expression that has a value\nrepresentable as an int.\n","P3":"Semantics\nThe identifiers in an enumerator list are declared as constants that\nhave type int and may appear wherever such are permitted.<foot>Thus,\nthe identifiers of enumeration constants declared in the same scope\nshall all be distinct from</foot> An enumerator with = defines its\nenumeration constant as the value of the constant expression. If the\nfirst enumerator has no =, the value of its enumeration constant is\n0. Each subsequent enumerator with no = defines its enumeration\nconstant as the value of the constant expression obtained by adding 1\nto the value of the previous enumeration constant. (The use of\nenumerators with = may produce enumeration constants with values that\nduplicate other values in the same enumeration.) The enumerators of\nan enumeration are also known as its members.\n","P4":"Each enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined,<foot>An implementation may delay the choice of which integer type until all enumeration constants have been seen.</foot> but shall be capable of representing the values of all the members of the enumeration. The enumerated type is incomplete until immediately after the } that terminates the list of enumerator declarations, and complete thereafter.\n","P5":"EXAMPLE\nThe following fragment:\n<code>\n  enum hue { chartreuse, burgundy, claret=20, winedark };\n  enum hue col, *cp;\n  col = claret;\n  cp = &col;\n  if (*cp != burgundy)\n  /* ... */\n</code>\nmakes hue the tag of an enumeration, and then declares col as an\nobject that has that type and cp as a pointer to an object that has\nthat type. The enumerated values are in the set { 0, 1, 20, 21 }.\n"},"3":{"title":"Tags","P1":"Constraints\nA specific type shall have its content defined at most once.\n","P2":"Where two declarations that use the same tag declare the same type, they shall both use the same choice of struct, union, or enum.\n","P3":"A type specifier of the form enum identifier without an enumerator list shall only appear after the type it specifies is complete.\n","P4":"Semantics\nAll declarations of structure, union, or enumerated types that have\nthe same scope and use the same tag declare the same type.\nIrrespective of whether there is a tag or what other declarations of\nthe type are in the same translation unit, the type is\nincomplete<foot>An incomplete type may only by used when the size of\nan object of that type is not needed. It is not needed, for example,\nwhen a typedef name is declared to be a specifier for a structure or\nunion, or when a pointer to or a function returning a structure or\nunion is being declared. (See incomplete types in 6.2.5.) The\nspecification has to be complete before such a function is called or\ndefined.</foot> until immediately after the closing brace of the list\ndefining the content, and complete thereafter.\n","P5":"Two declarations of structure, union, or enumerated types which are in different scopes or use different tags declare distinct types. Each declaration of a structure, union, or enumerated type which does not include a tag declares a distinct type.\n","P6":"A type specifier of the form\n  struct-or-union identifieropt { struct-declaration-list }\nor\n  enum identifieropt { enumerator-list }\nor\n  enum identifieropt { enumerator-list , }\ndeclares a structure, union, or enumerated type. The list defines the\nstructure content, union content, or enumeration content. If an\nidentifier is provided,<foot>If there is no identifier, the type can,\nwithin the translation unit, only be referred to by the declaration\nof which it is a part. Of course, when the declaration is of a\ntypedef name, subsequent declarations can make use of that typedef\nname to declare objects having the specified structure, union, or\nenumerated type.</foot> the type specifier also declares the\nidentifier to be the tag of that type.\n","P7":"A declaration of the form\n  struct-or-union identifier ;\nspecifies a structure or union type and declares the identifier as a\ntag of that type.<foot>A similar construction with enum does not\nexist.</foot>\n","P8":"If a type specifier of the form\n  struct-or-union identifier\noccurs other than as part of one of the above forms, and no other\ndeclaration of the identifier as a tag is visible, then it declares\nan incomplete structure or union type, and declares the identifier as\nthe tag of that type.<foot>A similar construction with enum does not\nexist.</foot>\n","P9":"If a type specifier of the form\n  struct-or-union identifier\nor\n  enum identifier\noccurs other than as part of one of the above forms, and a\ndeclaration of the identifier as a tag is visible, then it specifies\nthe same type as that other declaration, and does not redeclare the\ntag.\n","P10":"EXAMPLE 1\nThis mechanism allows declaration of a self-referential structure.\n<code>\n  struct tnode {\n    int count;\n    struct tnode *left, *right;\n  };\n</code>\nspecifies a structure that contains an integer and two pointers to\nobjects of the same type. Once this declaration has been given, the\ndeclaration\n<code>\n  struct tnode s, *sp;\n</code>\ndeclares s to be an object of the given type and sp to be a pointer\nto an object of the given type. With these declarations, the\nexpression sp->left refers to the left struct tnode pointer of the\nobject to which sp points; the expression s.right->count designates\nthe count member of the right struct tnode pointed to from s.\n","P11":"The following alternative formulation uses the typedef mechanism:\n<code>\n  typedef struct tnode TNODE;\n  struct tnode {\n    int count;\n    TNODE *left, *right;\n  };\n  TNODE s, *sp;\n</code>\n","P12":"EXAMPLE 2 To illustrate the use of prior declaration of a tag to\nspecify a pair of mutually referential structures, the declarations\n<code>\n  struct s1 { struct s2 *s2p; /* ... */ }; // D1\n  struct s2 { struct s1 *s1p; /* ... */ }; // D2\n</code>\nspecify a pair of structures that contain pointers to each other.\nNote, however, that if s2 were already declared as a tag in an\nenclosing scope, the declaration D1 would refer to it, not to the tag\ns2 declared in D2. To eliminate this context sensitivity, the\ndeclaration struct s2; may be inserted ahead of D1. This declares a\nnew tag s2 in the inner scope; the declaration D2 then completes the\nspecification of the new type.\n"},"4":{"title":"Atomic type specifiers","P1":"Syntax\natomic-type-specifier:\n  _Atomic ( type-name )\n","P2":"Constraints\nAtomic type specifiers shall not be used if the implementation does\nnot support atomic types (see 6.10.8.3).\n","P3":"The type name in an atomic type specifier shall not refer to an array type, a function type, an atomic type, or a qualified type.\n","P4":"Semantics\nThe properties associated with atomic types are meaningful only for\nexpressions that are lvalues. If the _Atomic keyword is immediately\nfollowed by a left parenthesis, it is interpreted as a type specifier\n(with a type name), not as a type qualifier.\n"},"title":"Type specifiers","P1":"Syntax\ntype-specifier:\n  void\n  char\n  short\n  int\n  long\n  float\n  double\n  signed\n  unsigned\n  _Bool\n  _Complex\n  atomic-type-specifier\n  struct-or-union-specifier\n  enum-specifier\n  typedef-name\n","P2":"Constraints\nAt least one type specifier shall be given in the declaration\nspecifiers in each declaration, and in the specifier-qualifier list in\neach struct declaration and type name. Each list of type specifiers\nshall be one of the following multisets (delimited by commas, when\nthere is more than one multiset per item); the type specifiers may\noccur in any order, possibly intermixed with the other declaration\nspecifiers.\n— void\n— char\n— signed char\n— unsigned char\n— short, signed short, short int, or signed short int\n— unsigned short, or unsigned short int\n— int, signed, or signed int\n— unsigned, or unsigned int\n— long, signed long, long int, or signed long int\n— unsigned long, or unsigned long int\n— long long, signed long long, long long int, or\nsigned long long int\n— unsigned long long, or unsigned long long int\n— float\n— double\n— long double\n— _Bool\n— float _Complex\n— double _Complex\n— long double _Complex\n— atomic type specifier\n— struct or union specifier\n— enum specifier\n— typedef name\nThe type specifier _Complex shall not be used if the implementation\ndoes not support complex types (see 6.10.8.3).\n","P4":"Semantics\nSpecifiers for structures, unions, enumerations, and atomic types are\ndiscussed in 6.7.2.1 through 6.7.2.4. Declarations of typedef names are\ndiscussed in 6.7.8. The characteristics of the other types are\ndiscussed in 6.2.5.\n","P5":"Each of the comma-separated multisets designates the same type, except that for bitfields, it is implementation-defined whether the specifier int designates the same type as signed int or the same type as unsigned int.\n"},"3":{"1":{"title":"Formal definition of restrict","P1":"Let D be a declaration of an ordinary identifier that provides a means of designating an object P as a restrict-qualified pointer to type T.\n","P2":"If D appears inside a block and does not have storage class extern, let B denote the block. If D appears in the list of parameter declarations of a function definition, let B denote the associated block. Otherwise, let B denote the block of main (or the block of whatever function is called at program startup in a freestanding environment).\n","P3":"In what follows, a pointer expression E is said to be based on object P if (at some sequence point in the execution of B prior to the evaluation of E) modifying P to point to a copy of the array object into which it formerly pointed would change the value of E.<foot>In other words, E depends on the value of P itself rather than on the value of an object referenced indirectly through P. For example, if identifier p has type (int **restrict), then the pointer expressions p and p+1 are based on the restricted pointer object designated by p, but the pointer expressions *p and p[1] are not.</foot> Note that ‘‘based’’ is defined only for expressions with pointer types.\n","P4":"During each execution of B, let L be any lvalue that has &L based on P. If L is used to access the value of the object X that it designates, and X is also modified (by any means), then the following requirements apply: T shall not be const-qualified. Every other lvalue used to access the value of X shall also have its address based on P. Every access that modifies X shall be considered also to modify P, for the purposes of this subclause. If P is assigned the value of a pointer expression E that is based on another restricted pointer object P2, associated with block B2, then either the execution of B2 shall begin before the execution of B, or the execution of B2 shall end prior to the assignment. If these requirements are not met, then the behavior is undefined.\n","P5":"Here an execution of B means that portion of the execution of the program that would correspond to the lifetime of an object with scalar type and automatic storage duration associated with B.\n","P6":"A translator is free to ignore any or all aliasing implications of uses of restrict.\n","P7":"EXAMPLE 1\nThe file scope declarations\n<code>\n  int * restrict a;\n  int * restrict b;\n  extern int c[];\n</code>\nassert that if an object is accessed using one of a, b, or c, and\nthat object is modified anywhere in the program, then it is never\naccessed using either of the other two.\n","P8":"EXAMPLE 2\nThe function parameter declarations in the following example\n<code>\n  void f(int n, int * restrict p, int * restrict q)\n  {\n    while (n-- > 0)\n    *p++ = *q++;\n  }\n</code>\nassert that, during each execution of the function, if an object is\naccessed through one of the pointer parameters, then it is not also\naccessed through the other.\n","P9":"The benefit of the restrict qualifiers is that they enable a\ntranslator to make an effective dependence analysis of function f\nwithout examining any of the calls of f in the program. The cost is\nthat the programmer has to examine all of those calls to ensure that\nnone give undefined behavior. For example, the second call of f in g\nhas undefined behavior because each of d[1] through d[49] is accessed\nthrough both p and q.\n<code>\n  void g(void)\n  {\n    extern int d[100];\n    f(50, d + 50, d); // valid\n    f(50, d + 1, d); // undefined behavior\n  }\n<code>\n","P10":"EXAMPLE 3\nThe function parameter declarations\n<code>\n  void h(int n, int * restrict p, int * restrict q, int * restrict r)\n  {\n    int i;\n    for (i = 0; i < n; i++)\n    p[i] = q[i] + r[i];\n  }\n</code>\nillustrate how an unmodified object can be aliased through two\nrestricted pointers. In particular, if a and b are disjoint arrays, a\ncall of the form h(100, a, b, b) has defined behavior, because array\nb is not modified within function h.\n","P11":"EXAMPLE 4 The rule limiting assignments between restricted pointers\ndoes not distinguish between a function call and an equivalent nested\nblock. With one exception, only ‘‘outer-to-inner’’ assignments\nbetween restricted pointers declared in nested blocks have defined\nbehavior.\n<code>\n{\n  int * restrict p1;\n  int * restrict q1;\n  p1 = q1; // undefined behavior\n  {\n    int * restrict p2 = p1; // valid\n    int * restrict q2 = q1; // valid\n    p1 = q2; // undefined behavior\n    p2 = q2; // undefined behavior\n  }\n}\n</code>\n","P12":"The one exception allows the value of a restricted pointer to be\ncarried out of the block in which it (or, more precisely, the\nordinary identifier used to designate it) is declared when that block\nfinishes execution. For example, this permits new_vector to return a\nvector.\n<code>\n  typedef struct { int n; float * restrict v; } vector;\n  vector new_vector(int n)\n  {\n    vector t;\n    t.n = n;\n    t.v = malloc(n * sizeof (float));\n    return t;\n  }\n</code>\n"},"title":"Type qualifiers","P1":"Syntax\ntype-qualifier:\n  const\n  restrict\n  volatile\n  _Atomic\n","P2":"Constraints\nTypes other than pointer types whose referenced type is an object type\nshall not be restrict-qualified.\n","P3":"The type modified by the _Atomic qualifier shall not be an array type or a function type.\n","P4":"Semantics\nThe properties associated with qualified types are meaningful only for\nexpressions that are lvalues.<foot>The implementation may place a const\nobject that is not volatile in a read-only region of storage. Moreover,\nthe implementation need not allocate storage for such an object if its\naddress is never used.</foot>\n","P5":"If the same qualifier appears more than once in the same specifier-qualifier-list, either directly or via one or more typedefs, the behavior is the same as if it appeared only once. If other qualifiers appear along with the _Atomic qualifier in a specifier-qualifier list, the resulting type is the so-qualified atomic type.\n","P6":"If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined. If an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined. <foot>This applies to those objects that behave as if they were defined with qualified types, even if they are never actually defined as objects in the program (such as an object at a memory-mapped input/output address).</foot>\n","P7":"An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Therefore any expression referring to such an object shall be evaluated strictly according to the rules of the abstract machine, as described in 5.1.2.3. Furthermore, at every sequence point the value last stored in the object shall agree with that prescribed by the abstract machine, except as modified by the unknown factors mentioned previously.<foot>For example, a statement that assigns a value returned by malloc to a single pointer establishes this association between the allocated object and the pointer.</foot> What constitutes an access to an object that has volatile-qualified type is implementation-defined.\n","P8":"An object that is accessed through a restrict-qualified pointer has a special association with that pointer. This association, defined in 6.7.3.1 below, requires that all accesses to that object use, directly or indirectly, the value of that particular pointer.<foot>For example, a statement that assigns a value returned by malloc to a single pointer establishes this association between the allocated object and the pointer.</foot> The intended use of the restrict qualifier (like the register storage class) is to promote optimization, and deleting all instances of the qualifier from all preprocessing translation units composing a conforming program does not change its meaning (i.e., observable behavior).\n","P9":"If the specification of an array type includes any type qualifiers, the element type is soqualified, not the array type. If the specification of a function type includes any type qualifiers, the behavior is undefined.<foot>Both of these can occur through the use of typedefs.</foot>\n","P10":"For two qualified types to be compatible, both shall have the\nidentically qualified version of a compatible type; the order of type\nqualifiers within a list of specifiers or qualifiers does not affect\nthe specified type.\n","P11":"EXAMPLE 1\nAn object declared\nextern const volatile int real_time_clock;\nmay be modifiable by hardware, but cannot be assigned to, incremented,\nor decremented.\n","P12":"EXAMPLE 2 The following declarations and expressions illustrate the\nbehavior when type qualifiers modify an aggregate type:\n<code>\n  const struct s { int mem; } cs = { 1 };\n  struct s ncs; // the object ncs is modifiable\n  typedef int A[2][3];\n  const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int\n  int *pi;\n  const int *pci;\n  ncs = cs;       // valid\n  cs = ncs;       // violates modifiable lvalue constraint for =\n  pi = &ncs.mem;  // valid\n  pi = &cs.mem;   // violates type constraints for =\n  pci = &cs.mem;  // valid\n  pi = a[0];      // invalid: a[0] has type ‘‘const int *’’\n</code>\n","P13":"EXAMPLE 3\nThe declaration\n<code>\n  _Atomic volatile int *p;\n</code>\nspecifies that p has the type ‘‘pointer to volatile atomic int’’, a\npointer to a volatile-qualified atomic type.\n"},"4":{"title":"Function specifiers","P1":"Syntax\nfunction-specifier:\n  inline\n  _Noreturn\n","P2":"Constraints\nFunction specifiers shall be used only in the declaration of an\nidentifier for a function.\n","P3":"An inline definition of a function with external linkage shall not contain a definition of a modifiable object with static or thread storage duration, and shall not contain a reference to an identifier with internal linkage.\n","P4":"In a hosted environment, no function specifier(s) shall appear in a declaration of main.\n","P5":"Semantics\nA function specifier may appear more than once; the behavior is the\nsame as if it appeared only once.\n","P6":"A function declared with an inline function specifier is an inline function. Making a function an inline function suggests that calls to the function be as fast as possible.<foot>By using, for example, an alternative to the usual function call mechanism, such as ‘‘inline substitution’’. Inline substitution is not textual substitution, nor does it create a new function.  Therefore, for example, the expansion of a macro used within the body of the function uses the definition it had at the point the function body appears, and not where the function is called; and identifiers refer to the declarations in scope where the body occurs. Likewise, the function has a single address, regardless of the number of inline definitions that occur in addition to the external definition.</foot> The extent to which such suggestions are effective is implementation-defined.<foot>For example, an implementation might never perform inline substitution, or might only perform inline substitutions to calls in the scope of an inline declaration.</foot>\n","P7":"Any function with internal linkage can be an inline function. For a function with external linkage, the following restrictions apply: If a function is declared with an inline function specifier, then it shall also be defined in the same translation unit. If all of the file scope declarations for a function in a translation unit include the inline function specifier without extern, then the definition in that translation unit is an inline definition. An inline definition does not provide an external definition for the function, and does not forbid an external definition in another translation unit. An inline definition provides an alternative to an external definition, which a translator may use to implement any call to the function in the same translation unit. It is unspecified whether a call to the function uses the inline definition or the external definition.<foot>Since an inline definition is distinct from the corresponding external definition and from any other corresponding inline definitions in other translation units, all corresponding objects with static storage duration are also distinct in each of the definitions.</foot>\n","P8":"A function declared with a _Noreturn function specifier shall not return to its caller.\n","P9":"Recommended practice\nThe implementation should produce a diagnostic message for a function\ndeclared with a _Noreturn function specifier that appears to be capable\nof returning to its caller.\n","P10":"EXAMPLE 1 The declaration of an inline function with external linkage\ncan result in either an external definition, or a definition available\nfor use only within the translation unit. A file scope declaration with\nextern creates an external definition. The following example shows an\nentire translation unit.\n<code>\n  inline double fahr(double t)\n  {\n    return (9.0 * t) / 5.0 + 32.0;\n  }\n    inline double cels(double t)\n  {\n    return (5.0 * (t - 32.0)) / 9.0;\n  }\n  extern double fahr(double); // creates an external definition\n  double convert(int is_fahr, double temp)\n  {\n  /* A translator may perform inline substitutions */\n  return is_fahr ? cels(temp) : fahr(temp);\n  }\n</code>\n","P11":"Note that the definition of fahr is an external definition because fahr is also declared with extern, but the definition of cels is an inline definition. Because cels has external linkage and is referenced, an external definition has to appear in another translation unit (see 6.9); the inline definition and the external definition are distinct and either may be used for the call.\n","P12":"EXAMPLE 2\n<code>\n  _Noreturn void f () {\n    abort(); // ok\n  }\n  _Noreturn void g (int i) { // causes undefined behavior if i <= 0\n    if (i > 0) abort();\n  }\n</code>\n"},"5":{"title":"Alignment specifier","P1":"Syntax\nalignment-specifier:\n  _Alignas ( type-name )\n  _Alignas ( constant-expression )\n","P2":"Constraints\nAn alignment attribute shall not be specified in a declaration of a\ntypedef, or a bit-field, or a function, or a parameter, or an object\ndeclared with the register storage-class specifier.\n","P3":"The constant expression shall be an integer constant expression. It shall evaluate to a valid fundamental alignment, or to a valid extended alignment supported by the implementation in the context in which it appears, or to zero.\n","P4":"The combined effect of all alignment attributes in a declaration shall not specify an alignment that is less strict than the alignment that would otherwise be required for the type of the object or member being declared.\n","P5":"Semantics\nThe first form is equivalent to _Alignas (_Alignof (type-name)).\n","P6":"The alignment requirement of the declared object or member is taken to be the specified alignment. An alignment specification of zero has no effect.<foot>An alignment specification of zero also does not affect other alignment specifications in the same declaration.</foot> When multiple alignment specifiers occur in a declaration, the effective alignment requirement is the strictest specified alignment.\n","P7":"If the definition of an object has an alignment specifier, any other declaration of that object shall either specify equivalent alignment or have no alignment specifier. If the definition of an object does not have an alignment specifier, any other declaration of that object shall also have no alignment specifier. If declarations of an object in different translation units have different alignment specifiers, the behavior is undefined.\n"},"6":{"1":{"title":"Pointer declarators","P1":"Semantics\nIf, in the declaration ‘‘T D1’’, D1 has the form\n  * type-qualifier-listopt D\nand the type specified for ident in the declaration ‘‘T D’’ is\n‘‘derived-declarator-type-list T ’’, then the type specified for\nident is ‘‘derived-declarator-type-list type-qualifier-list pointer\nto T ’’. For each type qualifier in the list, ident is a so-qualified\npointer.\n","P2":"For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.\n","P3":"EXAMPLE The following pair of declarations demonstrates the\ndifference between a ‘‘variable pointer to a constant value’’ and a\n‘‘constant pointer to a variable value’’.\n<code>\n  const int *ptr_to_constant;\n  int *const constant_ptr;\n</code>\nThe contents of any object pointed to by ptr_to_constant shall not be\nmodified through that pointer, but ptr_to_constant itself may be\nchanged to point to another object. Similarly, the contents of the\nint pointed to by constant_ptr may be modified, but constant_ptr\nitself shall always point to the same location.\n","P4":"The declaration of the constant pointer constant_ptr may be clarified\nby including a definition for the type ‘‘pointer to int’’.\n<code>\n  typedef int *int_ptr;\n  const int_ptr constant_ptr;\n</code>\ndeclares constant_ptr as an object that has type ‘‘const-qualified\npointer to int’’.\n"},"2":{"title":"Array declarators","P1":"Constraints\nIn addition to optional type qualifiers and the keyword static, the [\nand ] may delimit an expression or *. If they delimit an expression\n(which specifies the size of an array), the expression shall have\nan integer type. If the expression is a constant expression, it\nshall have a value greater than zero. The element type shall not be\nan incomplete or function type. The optional type qualifiers and\nthe keyword static shall appear only in a declaration of a function\nparameter with an array type, and then only in the outermost array\ntype derivation.\n","P2":"If an identifier is declared as having a variably modified type, it shall be an ordinary identifier (as defined in 6.2.3), have no linkage, and have either block scope or function prototype scope. If an identifier is declared to be an object with static or thread storage duration, it shall not have a variable length array type.\n","P3":"Semantics\nIf, in the declaration ‘‘T D1’’, D1 has one of the forms:\n  D[ type-qualifier-listopt assignment-expressionopt ]\n  D[ static type-qualifier-listopt assignment-expression ]\n  D[ type-qualifier-list static assignment-expression ]\n  D[ type-qualifier-listopt * ]\nand the type specified for ident in the declaration ‘‘T D’’ is\n‘‘derived-declarator-type-list T ’’, then the type specified for\nident is ‘‘derived-declarator-type-list array of T ’’.<foot>When\nseveral ‘‘array of’’ specifications are adjacent, a multidimensional\narray is declared.</foot> (See 6.7.6.3 for the meaning of the\noptional type qualifiers and the keyword static.)\n","P4":"If the size is not present, the array type is an incomplete type. If the size is * instead of being an expression, the array type is a variable length array type of unspecified size, which can only be used in declarations or type names with function prototype scope;<foot>Thus, * can be used only in function declarations that are not definitions (see 6.7.6.3).</foot> such arrays are nonetheless complete types. If the size is an integer constant expression and the element type has a known constant size, the array type is not a variable length array type; otherwise, the array type is a variable length array type. (Variable length arrays are a conditional feature that implementations need not support; see 6.10.8.3.)\n","P5":"If the size is an expression that is not an integer constant expression: if it occurs in a declaration at function prototype scope, it is treated as if it were replaced by *; otherwise, each time it is evaluated it shall have a value greater than zero. The size of each instance of a variable length array type does not change during its lifetime. Where a size expression is part of the operand of a sizeof operator and changing the value of the size expression would not affect the result of the operator, it is unspecified whether or not the size expression is evaluated.\n","P6":"For two array types to be compatible, both shall have compatible element types, and if both size specifiers are present, and are integer constant expressions, then both size specifiers shall have the same constant value. If the two array types are used in a context which requires them to be compatible, it is undefined behavior if the two size specifiers evaluate to unequal values.\n","P7":"EXAMPLE 1\n<code>\n  float fa[11], *afp[17];\n</code>\ndeclares an array of float numbers and an array of pointers to float\nnumbers.\n","P8":"EXAMPLE 2\nNote the distinction between the declarations\n<code>\n  extern int *x;\n  extern int y[];\n</code>\nThe first declares x to be a pointer to int; the second declares y to\nbe an array of int of unspecified size (an incomplete type), the\nstorage for which is defined elsewhere.\n","P9":"EXAMPLE 3\nThe following declarations demonstrate the compatibility rules for\nvariably modified types.\n<code>\n  extern int n;\n  extern int m;\n  void fcompat(void)\n  {\n    int a[n][6][m];\n    int (*p)[4][n+1];\n    int c[n][n][6][m];\n    int (*r)[n][n][n+1];\n    p = a; // invalid: not compatible because 4 != 6\n    r = c; // compatible, but defined behavior only if\n           // n == 6 and m == n+1\n  }\n</code>\n","P10":"EXAMPLE 4 All declarations of variably modified (VM) types have to be\nat either block scope or function prototype scope. Array objects\ndeclared with the _Thread_local, static, or extern storage-class\nspecifier cannot have a variable length array (VLA) type. However, an\nobject declared with the static storage-class specifier can have a VM\ntype (that is, a pointer to a VLA type). Finally, all identifiers\ndeclared with a VM type have to be ordinary identifiers and cannot,\ntherefore, be members of structures or unions.\n<code>\nextern int n;\nint A[n];            // invalid: file scope VLA\nextern int (*p2)[n]; // invalid: file scope VM\nint B[100];          // valid: file scope but not VM\n\nvoid fvla(int m, int C[m][m]); // valid: VLA with prototype scope\n\nvoid fvla(int m, int C[m][m]) // valid: adjusted to auto pointer to VLA \n{\n  typedef int VLA[m][m];      // valid: block scope typedef VLA\n\n  struct tag {\n    int (*y)[n];             // invalid: y not ordinary identifier\n    int z[n];                // invalid: z not ordinary identifier\n  };\n  int D[m];                  // valid: auto VLA\n  static int E[m];           // invalid: static block scope VLA\n  extern int F[m];           // invalid: F has linkage and is VLA\n  int (*s)[m];               // valid: auto pointer to VLA\n  extern int (*r)[m];        // invalid: r has linkage and points to VLA\n  static int (*q)[m] = &B;   // valid: q is a static block pointer to VLA\n}\n</code>\n"},"3":{"title":"Function declarators (including prototypes)","P1":"Constraints\nA function declarator shall not specify a return type that is a\nfunction type or an array type.\n","P2":"The only storage-class specifier that shall occur in a parameter declaration is register.\n","P3":"An identifier list in a function declarator that is not part of a definition of that function shall be empty.\n","P4":"After adjustment, the parameters in a parameter type list in a function declarator that is part of a definition of that function shall not have incomplete type.\n","P5":"Semantics\nIf, in the declaration ‘‘T D1’’, D1 has the form\n  D( parameter-type-list )\nor\n  D( identifier-listopt )\nand the type specified for ident in the declaration ‘‘T D’’ is\n‘‘derived-declarator-type-list T ’’, then the type specified for\nident is ‘‘derived-declarator-type-list function returning T ’’.\n","P6":"A parameter type list specifies the types of, and may declare identifiers for, the parameters of the function.\n","P7":"A declaration of a parameter as ‘‘array of type’’ shall be adjusted to ‘‘qualified pointer to type’’, where the type qualifiers (if any) are those specified within the [ and ] of the array type derivation. If the keyword static also appears within the [ and ] of the array type derivation, then for each call to the function, the value of the corresponding actual argument shall provide access to the first element of an array with at least as many elements as specified by the size expression.\n","P8":"A declaration of a parameter as ‘‘function returning type’’ shall be adjusted to ‘‘pointer to function returning type’’, as in 6.3.2.1.\n","P9":"If the list terminates with an ellipsis (, ...), no information about the number or types of the parameters after the comma is supplied.<foot>The macros defined in the <stdarg.h> header (7.16) may be used to access arguments that correspond to the ellipsis.</foot>\n","P10":"The special case of an unnamed parameter of type void as the only item in the list specifies that the function has no parameters.\n","P11":"If, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name.\n","P12":"If the function declarator is not part of a definition of that function, parameters may have incomplete type and may use the [*] notation in their sequences of declarator specifiers to specify variable length array types.\n","P13":"The storage-class specifier in the declaration specifiers for a parameter declaration, if present, is ignored unless the declared parameter is one of the members of the parameter type list for a function definition.\n","P14":"An identifier list declares only the identifiers of the parameters of the function. An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. The empty list in a function declarator that is not part of a definition of that function specifies that no information about the number or types of the parameters is supplied. <foot>See ‘‘future language directions’’ (6.11.6).</foot>\n","P15":"For two function types to be compatible, both shall specify compatible return types.<foot>If both function types are ‘‘old style’’, parameter types are not compared.</foot> Moreover, the parameter type lists, if both are present, shall agree in the number of parameters and in use of the ellipsis terminator; corresponding parameters shall have compatible types. If one type has a parameter type list and the other type is specified by a function declarator that is not part of a function definition and that contains an empty identifier list, the parameter list shall not have an ellipsis terminator and the type of each parameter shall be compatible with the type that results from the application of the default argument promotions. If one type has a parameter type list and the other type is specified by a function definition that contains a (possibly empty) identifier list, both shall agree in the number of parameters, and the type of each prototype parameter shall be compatible with the type that results from the application of the default argument promotions to the type of the corresponding identifier. (In the determination of type compatibility and of a composite type, each parameter declared with function or array type is taken as having the adjusted type and each parameter declared with qualified type is taken as having the unqualified version of its declared type.)\n","P16":"EXAMPLE 1\nThe declaration\n<code>\n  int f(void), *fip(), (*pfi)();\n</code>\ndeclares a function f with no parameters returning an int, a function\nfip with no parameter specification returning a pointer to an int,\nand a pointer pfi to a function with no parameter specification\nreturning an int. It is especially useful to compare the last two.\nThe binding of *fip() is *(fip()), so that the declaration suggests,\nand the same construction in an expression requires, the calling of a\nfunction fip, and then using indirection through the pointer result\nto yield an int. In the declarator (*pfi)(), the extra parentheses\nare necessary to indicate that indirection through a pointer to a\nfunction yields a function designator, which is then used to call the\nfunction; it returns an int.\n","P17":"If the declaration occurs outside of any function, the identifiers have file scope and external linkage. If the declaration occurs inside a function, the identifiers of the functions f and fip have block scope and either internal or external linkage (depending on what file scope declarations for these identifiers are visible), and the identifier of the pointer pfi has block scope and no linkage.\n","P18":"EXAMPLE 2\nThe declaration\n<code>\n  int (*apfi[3])(int *x, int *y);\n</code>\ndeclares an array apfi of three pointers to functions returning int.\nEach of these functions has two parameters that are pointers to int.\nThe identifiers x and y are declared for descriptive purposes only\nand go out of scope at the end of the declaration of apfi.\n","P19":"EXAMPLE 3\nThe declaration\n<code>\n  int (*fpfi(int (*)(long), int))(int, ...);\n</code>\ndeclares a function fpfi that returns a pointer to a function\nreturning an int. The function fpfi has two parameters: a pointer to a\nfunction returning an int (with one parameter of type long int), and an\nint.  The pointer returned by fpfi points to a function that has one\nint parameter and accepts zero or more additional arguments of any\ntype.\n","P20":"EXAMPLE 4\nThe following prototype has a variably modified parameter.\n<code>\n  void addscalar(int n, int m,\n    double a[n][n*m+300], double x);\n  int main()\n  {\n    double b[4][308];\n    addscalar(4, 2, b, 2.17);\n    return 0;\n  }\n  void addscalar(int n, int m,\n    double a[n][n*m+300], double x)\n  {\n  for (int i = 0; i < n; i++)\n    for (int j = 0, k = n*m+300; j < k; j++)\n      // a is a pointer to a VLA with n*m+300 elements\n      a[i][j] += x;\n  }\n</code>\n","P21":"EXAMPLE 5\nThe following are all compatible function prototype declarators.\n<code>\n  double maximum(int n, int m, double a[n][m]);\n  double maximum(int n, int m, double a[*][*]);\n  double maximum(int n, int m, double a[ ][*]);\n  double maximum(int n, int m, double a[ ][m]);\n</code>\nas are:\n<code>\n  void f(double (* restrict a)[5]);\n  void f(double a[restrict][5]);\n  void f(double a[restrict 3][5]);\n  void f(double a[restrict statuc 3][5]);\n</code>\n(Note that the last declaration also specifies that the argument\ncorresponding to a in any call to f must be a non-null pointer to the\nfirst of at least three arrays of 5 doubles, which the others do\nnot.)\n"},"title":"Declarators","P1":"Syntax\ndeclarator:\n  pointeropt direct-declarator\ndirect-declarator:\n  identifier\n  ( declarator )\n  direct-declarator [ type-qualifier-listopt assignment-expressionopt ]\n  direct-declarator [ static type-qualifier-listopt assignment-expression ]\n  direct-declarator [ type-qualifier-list static assignment-expression ]\n  direct-declarator [ type-qualifier-listopt * ]\n  direct-declarator ( parameter-type-list )\n  direct-declarator ( identifier-listopt )\npointer:\n  * type-qualifier-listopt\n  * type-qualifier-listopt pointer\ntype-qualifier-list:\n  type-qualifier\n  type-qualifier-list type-qualifier\nparameter-type-list:\n  parameter-list\n  parameter-list , ...\nparameter-list:\n  parameter-declaration\n  parameter-list , parameter-declaration\nparameter-declaration:\n  declaration-specifiers declarator\n  declaration-specifiers abstract-declaratoropt\nidentifier-list:\n  identifier\n  identifier-list , identifier\n","P2":"Semantics\nEach declarator declares one identifier, and asserts that when an\noperand of the same form as the declarator appears in an expression, it\ndesignates a function or object with the scope, storage duration, and\ntype indicated by the declaration specifiers.\n","P3":"A full declarator is a declarator that is not part of another declarator. The end of a full declarator is a sequence point. If, in the nested sequence of declarators in a full declarator, there is a declarator specifying a variable length array type, the type specified by the full declarator is said to be variably modified. Furthermore, any type derived by declarator type derivation from a variably modified type is itself variably modified.\n","P4":"In the following subclauses, consider a declaration\n<code>\n  T D1\n</code>\nwhere T contains the declaration specifiers that specify a type T (such\nas int) and D1 is a declarator that contains an identifier ident. The\ntype specified for the identifier ident in the various forms of\ndeclarator is described inductively using this notation.\n","P5":"If, in the declaration ‘‘T D1’’, D1 has the form identifier then the type specified for ident is T .\n","P6":"If, in the declaration ‘‘T D1’’, D1 has the form\n<code>\n( D )\n</code>\nthen ident has the type specified by the declaration ‘‘T D’’. Thus, a\ndeclarator in parentheses is identical to the unparenthesized\ndeclarator, but the binding of complicated declarators may be altered\nby parentheses.\n","P7":"Implementation limits\nAs discussed in 5.2.4.1, an implementation may limit the number of\npointer, array, and function declarators that modify an arithmetic,\nstructure, union, or void type, either directly or via one or more\ntypedefs.\n"},"7":{"title":"Type names","P1":"Syntax\ntype-name:\n  specifier-qualifier-list abstract-declaratoropt\nabstract-declarator:\n  pointer\n  pointeropt direct-abstract-declarator\ndirect-abstract-declarator:\n  ( abstract-declarator )\n  direct-abstract-declaratoropt [ type-qualifier-listopt\n  assignment-expressionopt ]\n  direct-abstract-declaratoropt [ static type-qualifier-listopt\n  assignment-expression ]\n  direct-abstract-declaratoropt [ type-qualifier-list static\n  assignment-expression ]\n  direct-abstract-declaratoropt [ * ]\n  direct-abstract-declaratoropt ( parameter-type-listopt )\n","P2":"Semantics\nIn several contexts, it is necessary to specify a type. This is\naccomplished using a type name, which is syntactically a declaration\nfor a function or an object of that type that omits the identifier.\n<foot>As indicated by the syntax, empty parentheses in a type name are\ninterpreted as ‘‘function with no parameter specification’’, rather\nthan redundant parentheses around the omitted identifier.</foot>\n","P3":"EXAMPLE\nThe constructions\n(a) int\n(b) int *\n(c) int *[3]\n(d) int (*)[3]\n(e) int (*)[*]\n(f) int *()\n(g) int (*) (void)\n(h) int (*const []) (unsigned int, ...)\nname respectively the types (a) int, (b) pointer to int, (c) array of\nthree pointers to int, (d) pointer to an array of three ints, (e)\npointer to a variable length array of an unspecified number of ints,\n(f) function with no parameter specification returning a pointer to\nint, (g) pointer to function with no parameters returning an int, and\n(h) array of an unspecified number of constant pointers to functions,\neach with one parameter that has type unsigned int and an unspecified\nnumber of other parameters, returning an int.\n"},"8":{"title":"Type definitions","P1":"Syntax\ntypedef-name:\n  identifier\n","P2":"Constraints\nIf a typedef name specifies a variably modified type then it shall have\nblock scope.\n","P3":"Semantics\nIn a declaration whose storage-class specifier is typedef, each\ndeclarator defines an identifier to be a typedef name that denotes the\ntype specified for the identifier in the way described in 6.7.6. Any\narray size expressions associated with variable length array\ndeclarators are evaluated each time the declaration of the typedef name\nis reached in the order of execution. A typedef declaration does not\nintroduce a new type, only a synonym for the type so specified. That\nis, in the following declarations:\n<code>\n  typedef T type_ident;\n  type_ident D;\n</code>\ntype_ident is defined as a typedef name with the type specified by the\ndeclaration specifiers in T (known as T ), and the identifier in D has\nthe type ‘‘derived-declaratortype-list T ’’ where the\nderived-declarator-type-list is specified by the declarators of D. A\ntypedef name shares the same name space as other identifiers declared\nin ordinary declarators.\n","P4":"EXAMPLE 1\nAfter\n<code>\n  typedef int MILES, KLICKSP();\n  typedef struct { double hi, lo; } range;\n</code>\nthe constructions\n<code>\n  MILES distance;\n  extern KLICKSP *metricp;\n  range x;\n  range z, *zp;\n</code>\nare all valid declarations. The type of distance is int, that of\nmetricp is ‘‘pointer to function with no parameter specification\nreturning int’’, and that of x and z is the specified structure; zp is\na pointer to such a structure. The object distance has a type\ncompatible with any other int object.\n","P5":"EXAMPLE 2\nAfter the declarations\n<code>\n  typedef struct s1 { int x; } t1, *tp1;\n  typedef struct s2 { int x; } t2, *tp2;\n</code>\ntype t1 and the type pointed to by tp1 are compatible. Type t1 is also\ncompatible with type struct s1, but not compatible with the types\nstruct s2, t2, the type pointed to by tp2, or int.\n","P6":"EXAMPLE 3\nThe following obscure constructions\n<code>\n  typedef signed int t;\n  typedef int plain;\n  struct tag {\n    unsigned t:4;\n    const t:5;\n    plain r:5;\n  };\n</code>\ndeclare a typedef name t with type signed int, a typedef name plain\nwith type int, and a structure with three bit-field members, one named\nt that contains values in the range [0, 15], an unnamed constqualified\nbit-field which (if it could be accessed) would contain values in\neither the range [−15, +15] or [−16, +15], and one named r that\ncontains values in one of the ranges [0, 31], [−15, +15], or [−16,\n+15].  (The choice of range is implementation-defined.) The first two\nbit-field declarations differ in that unsigned is a type specifier\n(which forces t to be the name of a structure member), while const is a\ntype qualifier (which modifies t which is still visible as a typedef\nname). If these declarations are followed in an inner scope by\n<code>\n  t f(t (t));\n  long t;\n</code>\nthen a function f is declared with type ‘‘function returning signed int\nwith one unnamed parameter with type pointer to function returning\nsigned int with one unnamed parameter with type signed int’’, and an\nidentifier t with type long int.\n","P7":"EXAMPLE 4 On the other hand, typedef names can be used to improve code\nreadability. All three of the following declarations of the signal\nfunction specify exactly the same type, the first without making use of\nany typedef names.\n<code>\n  typedef void fv(int), (*pfv)(int);\n  void (*signal(int, void (*)(int)))(int);\n  fv *signal(int, fv *);\n  pfv signal(int, pfv);\n</code>\n","P8":"EXAMPLE 5 If a typedef name denotes a variable length array type, the\nlength of the array is fixed at the time the typedef name is defined, not\neach time it is used:\n<code>\n  void copyt(int n)\n  {\n    typedef int B[n]; // B is n ints, n evaluated now\n    n += 1;\n    B a;              // a is n ints, n without += 1\n    int b[n];         // a and b are different sizes\n    for (int i = 1; i < n; i++)\n      a[i-1] = b[i];\n  }\n</code>\n"},"9":{"title":"Initialization","P1":"Syntax\ninitializer:\n  assignment-expression\n  { initializer-list }\n  { initializer-list , }\ninitializer-list:\n  designationopt initializer\n  initializer-list , designationopt initializer\ndesignation:\n  designator-list =\ndesignator-list:\n  designator\n  designator-list designator\ndesignator:\n  [ constant-expression ]\n  . identifier\n","P2":"Constraints\nNo initializer shall attempt to provide a value for an object not\ncontained within the entity being initialized.\n","P3":"The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.\n","P4":"All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.\n","P5":"If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier.\n","P6":"If a designator has the form\n  [ constant-expression ]\nthen the current object (defined below) shall have array type and the\nexpression shall be an integer constant expression. If the array is of\nunknown size, any nonnegative value is valid.\n","P7":"If a designator has the form\n  . identifier\nthen the current object (defined below) shall have structure or union\ntype and the identifier shall be the name of a member of that type.\n","P8":"Semantics\nAn initializer specifies the initial value stored in an object.\n","P9":"Except where explicitly stated otherwise, for the purposes of this subclause unnamed members of objects of structure and union type do not participate in initialization.  Unnamed members of structure objects have indeterminate value even after initialization.\n","P10":"If an object that has automatic storage duration is not initialized\nexplicitly, its value is indeterminate. If an object that has static or\nthread storage duration is not initialized explicitly, then:\n— if it has pointer type, it is initialized to a null pointer;\n— if it has arithmetic type, it is initialized to (positive or\nunsigned) zero;\n— if it is an aggregate, every member is initialized (recursively)\naccording to these rules, and any padding is initialized to zero bits;\n— if it is a union, the first named member is initialized (recursively)\naccording to these rules, and any padding is initialized to zero bits;\n","P11":"The initializer for a scalar shall be a single expression, optionally enclosed in braces. The initial value of the object is that of the expression (after conversion); the same type constraints and conversions as for simple assignment apply, taking the type of the scalar to be the unqualified version of its declared type.\n","P12":"The rest of this subclause deals with initializers for objects that have aggregate or union type.\n","P13":"The initializer for a structure or union object that has automatic storage duration shall be either an initializer list as described below, or a single expression that has compatible structure or union type. In the latter case, the initial value of the object, including unnamed members, is that of the expression.\n","P14":"An array of character type may be initialized by a character string literal or UTF−8 string literal, optionally enclosed in braces. Successive bytes of the string literal (including the terminating null character if there is room or if the array is of unknown size) initialize the elements of the array.\n","P15":"An array with element type compatible with a qualified or unqualified version of wchar_t, char16_t, or char32_t may be initialized by a wide string literal with the corresponding encoding prefix (L, u, or U, respectively), optionally enclosed in braces. Successive wide characters of the wide string literal (including the terminating null wide character if there is room or if the array is of unknown size) initialize the elements of the array.\n","P16":"Otherwise, the initializer for an object that has aggregate or union type shall be a braceenclosed list of initializers for the elements or named members.\n","P17":"Each brace-enclosed initializer list has an associated current object. When no designations are present, subobjects of the current object are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union.<foot>If the initializer list for a subaggregate or contained union does not begin with a left brace, its subobjects are initialized as usual, but the subaggregate or contained union does not become the current object: current objects are associated only with brace-enclosed initializer lists.</foot> In contrast, a designation causes the following initializer to begin initialization of the subobject described by the designator. Initialization then continues forward in order, beginning with the next subobject after that described by the designator.<foot>After a union member is initialized, the next object is not the next member of the union; instead, it is the next subobject of an object containing the union.</foot>\n","P18":"Each designator list begins its description with the current object associated with the closest surrounding brace pair. Each item in the designator list (in order) specifies a particular member of its current object and changes the current object for the next designator (if any) to be that member.<foot>Thus, a designator can only specify a strict subobject of the aggregate or union that is associated with the surrounding brace pair. Note, too, that each separate designator list is independent.</foot> The current object that results at the end of the designator list is the subobject to be initialized by the following initializer.\n","P19":"The initialization shall occur in initializer list order, each initializer provided for a particular subobject overriding any previously listed initializer for the same subobject;<foot>Any initializer for the subobject which is overridden and so not used to initialize that subobject might not be evaluated at all.</foot> all subobjects that are not initialized explicitly shall be initialized implicitly the same as objects that have static storage duration.\n","P20":"If the aggregate or union contains elements or members that are aggregates or unions, these rules apply recursively to the subaggregates or contained unions. If the initializer of a subaggregate or contained union begins with a left brace, the initializers enclosed by that brace and its matching right brace initialize the elements or members of the subaggregate or the contained union. Otherwise, only enough initializers from the list are taken to account for the elements or members of the subaggregate or the first member of the contained union; any remaining initializers are left to initialize the next element or member of the aggregate of which the current subaggregate or contained union is a part.\n","P21":"If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.\n","P22":"If an array of unknown size is initialized, its size is determined by the largest indexed element with an explicit initializer. The array type is completed at the end of its initializer list.\n","P23":"The evaluations of the initialization list expressions are indeterminately sequenced with respect to one another and thus the order in which any side effects occur is unspecified.<foot>In particular, the evaluation order need not be the same as the order of subobject initialization.</foot>\n","P24":"EXAMPLE 1\nProvided that <complex.h> has been \\#included, the declarations\n<code>\n  int i = 3.5;\n  double complex c = 5 + 3 * I;\n</code>\ndefine and initialize i with the value 3 and c with the value 5. 0 + i3. 0.\n","P25":"EXAMPLE 2\nThe declaration\n<code>\n  int x[] = { 1, 3, 5 };\n</code>\ndefines and initializes x as a one-dimensional array object that has\nthree elements, as no size was specified and there are three\ninitializers.\n","P26":"EXAMPLE 3\nThe declaration\n<code>\n  int y[4][3] =\n    { 1, 3, 5 },\n    { 2, 4, 6 },\n    { 3, 5, 7 },\n  };\n<code>\nis a definition with a fully bracketed initialization: 1, 3, and 5\ninitialize the first row of y (the array object y[0]), namely y[0][0],\ny[0][1], and y[0][2]. Likewise the next two lines initialize y[1] and\ny[2]. The initializer ends early, so y[3] is initialized with zeros.\nPrecisely the same effect could have been achieved by\n<code>\n  int y[4][3] = {\n    1, 3, 5, 2, 4, 6, 3, 5, 7\n  };\n</code>\nThe initializer for y[0] does not begin with a left brace, so three\nitems from the list are used. Likewise the next three are taken\nsuccessively for y[1] and y[2].\n","P27":"EXAMPLE 4\nThe declaration\n<code>\n  int z[4][3] = {\n    { 1 }, { 2 }, { 3 }, { 4 }\n  };\n</code>\ninitializes the first column of z as specified and initializes the rest\nwith zeros.\n","P28":"EXAMPLE 5\nThe declaration\n<code>\n  struct { int a[3], b; } w[] = { { 1 }, 2 };\n</code>\nis a definition with an inconsistently bracketed initialization. It\ndefines an array with two element structures: w[0].a[0] is 1 and\nw[1].a[0] is 2; all the other elements are zero.\n","P29":"EXAMPLE 6\nThe declaration\n<code>\n  short q[4][3][2] = {\n    { 1 },\n    { 2, 3 },\n    { 4, 5, 6 }\n  };\n</code>\ncontains an incompletely but consistently bracketed initialization. It\ndefines a three-dimensional array object: q[0][0][0] is 1, q[1][0][0] is\n2, q[1][0][1] is 3, and 4, 5, and 6 initialize q[2][0][0], q[2][0][1],\nand q[2][1][0], respectively; all the rest are zero. The initializer for\nq[0][0] does not begin with a left brace, so up to six items from the\ncurrent list may be used. There is only one, so the values for the\nremaining five elements are initialized with zero. Likewise, the\ninitializers for q[1][0] and q[2][0] do not begin with a left brace, so\neach uses up to six items, initializing their respective two-dimensional\nsubaggregates. If there had been more than six items in any of the lists,\na diagnostic message would have been issued. The same initialization\nresult could have been achieved by:\n<code>\n  short q[4][3][2] = {\n    1, 0, 0, 0, 0, 0,\n    2, 3, 0, 0, 0, 0,\n    4, 5, 6\n  };\n</code>\nor by:\n<code>\n  short q[4][3][2] = {\n  {\n      { 1 },\n    },\n    {\n      { 2, 3 },\n    },\n    {\n      { 4, 5 },\n      { 6 },\n  }\n};\n</code>\nin a fully bracketed form.\n","P30":"Note that the fully bracketed and minimally bracketed forms of\ninitialization are, in general, less likely to cause confusion.\n","P31":"EXAMPLE 7\nOne form of initialization that completes array types involves typedef\nnames. Given the declaration\n<code>\n  typedef int A[]; // OK - declared with block scope\n</code>\nthe declaration\n<code>\n  A a = { 1, 2 }, b = { 3, 4, 5 };\n</code>\nis identical to\n<code>\n  int a[] = { 1, 2 }, b[] = { 3, 4, 5 };\n</code>\ndue to the rules for incomplete types.\n","P32":"EXAMPLE 8\nThe declaration\n<code>\n  char s[] = \"abc\", t[3] = \"abc\";\n</code>\ndefines ‘‘plain’’ char array objects s and t whose elements are\ninitialized with character string literals.  This declaration is\nidentical to\n<code>\n  char s[] = { 'a', 'b', 'c', '\\0' },\n  t[] = { 'a', 'b', 'c' };\n</code>\nThe contents of the arrays are modifiable. On the other hand, the\ndeclaration\n<code>\n  char *p = \"abc\";\n</code>\ndefines p with type ‘‘pointer to char’’ and initializes it to point to\nan object with type ‘‘array of char’’ with length 4 whose elements are\ninitialized with a character string literal. If an attempt is made to\nuse p to modify the contents of the array, the behavior is undefined.\n","P33":"EXAMPLE 9\nArrays can be initialized to correspond to the elements of an\nenumeration by using designators:\n<code>\n  enum { member_one,\n    const char *nm[] = {\n    [member_two] = \"member two\",\n    [member_one] = \"member one\",\n  };\n<code>\n","P34":"EXAMPLE 10\nStructure members can be initialized to nonzero values without\ndepending on their order:\n<code>\n  div_t answer = { .quot = 2, .rem = -1 };\n</code>\n","P35":"EXAMPLE 11 Designators can be used to provide explicit initialization\nwhen unadorned initializer lists might be misunderstood:\n<code>\n  struct { int a[3], b; } w[] =\n    { [0].a = {1}, [1].a[0] = 2 };\n</code>\n","P36":"EXAMPLE 12\nSpace can be ‘‘allocated’’ from both ends of an array by using a single\ndesignator:\n<code>\n  int a[MAX] = {\n    1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0\n  };\n</code>\n","P37":"In the above, if MAX is greater than ten, there will be some\nzero-valued elements in the middle; if it is less than ten, some of the\nvalues provided by the first five initializers will be overridden by\nthe second five.\n","P38":"EXAMPLE 13\nAny member of a union can be initialized:\n<code>\n  union { /* ... */ } u = { .any_member = 42 };\n</code>\n"},"10":{"title":"Static assertions","P1":"Syntax\nstatic_assert-declaration:\n  _Static_assert ( constant-expression , string-literal ) ;\n","P2":"Constraints\nThe constant expression shall compare unequal to 0.\n","P3":"Semantics\nThe constant expression shall be an integer constant expression. If the\nvalue of the constant expression compares unequal to 0, the declaration\nhas no effect. Otherwise, the constraint is violated and the\nimplementation shall produce a diagnostic message that includes the\ntext of the string literal, except that characters not in the basic\nsource character set are not required to appear in the message.\n"},"title":"Declarations","P1":"Syntax\ndeclaration:\n  declaration-specifiers init-declarator-listopt ;\n  static_assert-declaration\ndeclaration-specifiers:\n  storage-class-specifier declaration-specifiersopt\n  type-specifier declaration-specifiersopt\n  type-qualifier declaration-specifiersopt\n  function-specifier declaration-specifiersopt\n  alignment-specifier declaration-specifiersopt\ninit-declarator-list:\n  init-declarator\n  init-declarator-list , init-declarator\ninit-declarator:\n  declarator\n  declarator = initializer\n","P2":"Constraints\nA declaration other than a static_assert declaration shall declare at\nleast a declarator (other than the parameters of a function or the\nmembers of a structure or union), a tag, or the members of an\nenumeration.\n","P3":"If an identifier has no linkage, there shall be no more than one\ndeclaration of the identifier (in a declarator or type specifier) with the\nsame scope and in the same name space, except that:\n— a typedef name may be redefined to denote the same type as it currently\ndoes, provided that type is not a variably modified type;\n— tags may be redeclared as specified in 6.7.2.3.\n","P4":"All declarations in the same scope that refer to the same object or function shall specify compatible types.\n","P5":"Semantics\nA declaration specifies the interpretation and attributes of a set of\nidentifiers. A definition of an identifier is a declaration for that\nidentifier that:\n— for an object, causes storage to be reserved for that object;\n— for a function, includes the function body;<foot>Function definitions\nhave a different syntax, described in 6.9.1.</foot>\n— for an enumeration constant, is the (only) declaration of the identifier;\n— for a typedef name, is the first (or only) declaration of the identifier.\n","P6":"The declaration specifiers consist of a sequence of specifiers that indicate the linkage, storage duration, and part of the type of the entities that the declarators denote. The initdeclarator-list is a comma-separated sequence of declarators, each of which may have additional type information, or an initializer, or both. The declarators contain the identifiers (if any) being declared.\n","P7":"If an identifier for an object is declared with no linkage, the type for the object shall be complete by the end of its declarator, or by the end of its init-declarator if it has an initializer; in the case of function parameters (including in prototypes), it is the adjusted type (see 6.7.6.3) that is required to be complete.\n"},"8":{"1":{"title":"Labeled statements","P1":"Syntax\nlabeled-statement:\n  identifier : statement\n  case constant-expression : statement\n  default : statement\n","P2":"Constraints\nA case or default label shall appear only in a switch statement.\nFurther constraints on such labels are discussed under the switch\nstatement.\n","P3":"Label names shall be unique within a function.\n","P4":"Semantics\nAny statement may be preceded by a prefix that declares an identifier\nas a label name.  Labels in themselves do not alter the flow of\ncontrol, which continues unimpeded across them.\n"},"2":{"title":"Compound statement","P1":"Syntax\ncompound-statement:\n  { block-item-listopt }\nblock-item-list:\n  block-item\n  block-item-list block-item\nblock-item:\n  declaration\n  statement\n","P2":"Semantics\nA compound statement is a block.\n"},"3":{"title":"Expression and null statements","P1":"Syntax\nexpression-statement:\n  expressionopt ;\n","P2":"Semantics\nThe expression in an expression statement is evaluated as a void\nexpression for its side effects.<foot>Such as assignments, and function\ncalls which have side effects.</foot>\n","P3":"A null statement (consisting of just a semicolon) performs no operations.\n","P4":"EXAMPLE 1 If a function call is evaluated as an expression statement\nfor its side effects only, the discarding of its value may be made\nexplicit by converting the expression to a void expression by means of a\ncast:\n<code>\n  int p(int);\n  /* ... */\n  (void)p(0);\n</code>\n","P5":"EXAMPLE 2\nIn the program fragment\n<code>\n  char *s;\n  /* ... */\n  while (*s++ != '\\0')\n    ;\n</code>\na null statement is used to supply an empty loop body to the iteration\nstatement.\n","P6":"EXAMPLE 3\nA null statement may also be used to carry a label just before the\nclosing } of a compound statement.\n<code>\n  while (loop1) {\n    /* ... */\n    while (loop2) {\n      /* ... */\n      if (want_out)\n        goto end_loop1;\n      /* ... */\n    }\n    /* ... */\n  end_loop1: ;\n  }\n</code>\n"},"4":{"1":{"title":"The if statement","P1":"Constraints\nThe controlling expression of an if statement shall have scalar type.\n","P2":"Semantics\nIn both forms, the first substatement is executed if the expression\ncompares unequal to 0.  In the else form, the second substatement is\nexecuted if the expression compares equal to 0. If the first\nsubstatement is reached via a label, the second substatement is not\nexecuted.\n","P3":"An else is associated with the lexically nearest preceding if that is allowed by the syntax.\n"},"2":{"title":"The switch statement","P1":"Constraints\nThe controlling expression of a switch statement shall have integer type.\n","P2":"If a switch statement has an associated case or default label within the scope of an identifier with a variably modified type, the entire switch statement shall be within the scope of that identifier. <foot>That is, the declaration either precedes the switch statement, or it follows the last case or default label associated with the switch that is in the block containing the declaration.</foot>\n","P3":"The expression of each case label shall be an integer constant expression and no two of the case constant expressions in the same switch statement shall have the same value after conversion. There may be at most one default label in a switch statement.  (Any enclosed switch statement may have a default label or case constant expressions with values that duplicate case constant expressions in the enclosing switch statement.)\n","P4":"Semantics\nA switch statement causes control to jump to, into, or past the\nstatement that is the switch body, depending on the value of a\ncontrolling expression, and on the presence of a default label and\nthe values of any case labels on or in the switch body. A case or\ndefault label is accessible only within the closest enclosing switch\nstatement.\n","P5":"The integer promotions are performed on the controlling expression. The constant expression in each case label is converted to the promoted type of the controlling expression. If a converted value matches that of the promoted controlling expression, control jumps to the statement following the matched case label. Otherwise, if there is a default label, control jumps to the labeled statement. If no converted case constant expression matches and there is no default label, no part of the switch body is executed.\n","P6":"Implementation limits\nAs discussed in 5.2.4.1, the implementation may limit the number of\ncase values in a switch statement.\n","P7":"EXAMPLE\nIn the artificial program fragment\n<code>\n  switch (expr)\n  {\n    int i = 4;\n    f(i);\n  case 0:\n    i = 17;\n    /* falls through into default code */\n  default:\n    printf(\"%d\\n\", i);\n  }\n</code>\nthe object whose identifier is i exists with automatic storage\nduration (within the block) but is never initialized, and thus if the\ncontrolling expression has a nonzero value, the call to the printf\nfunction will access an indeterminate value. Similarly, the call to\nthe function f cannot be reached.\n"},"title":"Selection statements","P1":"Syntax\nselection-statement:\n  if ( expression ) statement\n  if ( expression ) statement else statement\n  switch ( expression ) statement\n","P2":"Semantics\nA selection statement selects among a set of statements depending on\nthe value of a controlling expression.\n","P3":"A selection statement is a block whose scope is a strict subset of the scope of its enclosing block. Each associated substatement is also a block whose scope is a strict subset of the scope of the selection statement.\n"},"5":{"1":{"title":"The while statement","P1":"The evaluation of the controlling expression takes place before each\nexecution of the loop body.\n"},"2":{"title":"The do statement","P1":"The evaluation of the controlling expression takes place after each\nexecution of the loop body.\n"},"3":{"title":"The for statement","P1":"The statement\n  for ( clause-1 ; expression-2 ; expression-3 ) statement\nbehaves as follows: The expression expression-2 is the controlling\nexpression that is evaluated before each execution of the loop body.\nThe expression expression-3 is evaluated as a void expression after\neach execution of the loop body. If clause-1 is a declaration, the\nscope of any identifiers it declares is the remainder of the\ndeclaration and the entire loop, including the other two expressions;\nit is reached in the order of execution before the first evaluation\nof the controlling expression. If clause-1 is an expression, it is\nevaluated as a void expression before the first evaluation of the\ncontrolling expression.<foot>Thus, clause-1 specifies initialization\nfor the loop, possibly declaring one or more variables for use in the\nloop; the controlling expression, expression-2, specifies an\nevaluation made before each iteration, such that execution of the\nloop continues until the expression compares equal to 0; and\nexpression-3 specifies an operation (such as incrementing) that is\nperformed after each iteration.</foot>\n","P2":"Both clause-1 and expression-3 can be omitted. An omitted expression-2 is replaced by a nonzero constant.\n"},"title":"Iteration statements","P1":"Syntax\niteration-statement:\n  while ( expression ) statement\n  do statement while ( expression ) ;\n  for ( expressionopt ; expressionopt ; expressionopt ) statement\n  for ( declaration expressionopt ; expressionopt ) statement\n","P2":"Constraints\nThe controlling expression of an iteration statement shall have scalar type.\n","P3":"The declaration part of a for statement shall only declare identifiers for objects having storage class auto or register.\n","P4":"Semantics\nAn iteration statement causes a statement called the loop body to be\nexecuted repeatedly until the controlling expression compares equal to\n0. The repetition occurs regardless of whether the loop body is entered\nfrom the iteration statement or by a jump.<foot>Code jumped over is not\nexecuted. In particular, the controlling expression of a for or while\nstatement is not evaluated before entering the loop body, nor is\nclause-1 of a for statement.  </foot>\n","P5":"An iteration statement is a block whose scope is a strict subset of the scope of its enclosing block. The loop body is also a block whose scope is a strict subset of the scope of the iteration statement.\n","P6":"An iteration statement whose controlling expression is not a constant expression,<foot>An omitted controlling expression is replaced by a nonzero constant, which is a constant expression.  </foot> that performs no input/output operations, does not access volatile objects, and performs no synchronization or atomic operations in its body, controlling expression, or (in the case of a for statement) its expression-3, may be assumed by the implementation to terminate. <foot>This is intended to allow compiler transformations such as removal of empty loops even when termination cannot be proven.</foot>\n"},"6":{"1":{"title":"The goto statement","P1":"Constraints\nThe identifier in a goto statement shall name a label located somewhere\nin the enclosing function. A goto statement shall not jump from outside\nthe scope of an identifier having a variably modified type to inside\nthe scope of that identifier.\n","P2":"Semantics\nA goto statement causes an unconditional jump to the statement\nprefixed by the named label in the enclosing function.\n","P3":"EXAMPLE 1 It is sometimes convenient to jump into the middle of a\ncomplicated set of statements. The following outline presents one\npossible approach to a problem based on these three assumptions:\n  1. The general initialization code accesses objects only visible\n  to the current function.\n  2. The general initialization code is too large to warrant\n  duplication.\n  3. The code to determine the next operation is at the head of the\n  loop. (To allow it to be reached by continue statements, for\n  example.)\n  <code>\n    /* ... */\n    goto first_time;\n    for (;;) {\n      // determine next operation\n      /* ... */\n      if (need to reinitialize) {\n        // reinitialize-only code\n        /* ... */\n      first_time:\n        // general initialization code\n        /* ... */\n        continue;\n      }\n      // handle other operations\n      /* ... */\n    }\n  </code>\n","P4":"EXAMPLE 2 A goto statement is not allowed to jump past any\ndeclarations of objects with variably modified types. A jump within\nthe scope, however, is permitted.\n<code>\n  goto lab3;       // invalid: going INTO scope of VLA.\n  {\n    double a[n];\n    a[j] = 4.4;\n  lab3:\n    a[j] = 3.3;\n    goto lab4;    // valid: going WITHIN scope of VLA.\n    a[j] = 5.5;\n  lab4:\n    a[j] = 6.6;\n  }\n  goto lab4;     // invalid: going INTO scope of VLA.\n</code>\n"},"2":{"title":"The continue statement","P1":"Constraints\nA continue statement shall appear only in or as a loop body.\n","P2":"Semantics\nA continue statement causes a jump to the loop-continuation portion\nof the smallest enclosing iteration statement; that is, to the end of\nthe loop body. More precisely, in each of the statements\n<code>\n  while (/* ... */) {\n    /* ... */\n    continue;\n    /* ... */\n  contin: ;\n  }\n</code>\n\n<code>\n  do {\n    /* ... */\n    continue;\n    /* ... */\n  contin: ;\n  } while (/* ... */);\n</code>\n\n<code>\n  for (/* ... */) {\n    /* ... */\n    continue;\n    /* ... */\n  contin: ;\n  }\n</code>\nunless the continue statement shown is in an enclosed iteration\nstatement (in which case it is interpreted within that statement), it\nis equivalent to goto contin;.<foot>Following the contin: label is a\nnull statement.</foot>\n"},"3":{"title":"The break statement","P1":"Constraints\nA break statement shall appear only in or as a switch body or loop body.\n","P2":"Semantics\nA break statement terminates execution of the smallest enclosing\nswitch or iteration statement.\n"},"4":{"title":"The return statement","P1":"Constraints\nA return statement with an expression shall not appear in a function\nwhose return type is void. A return statement without an expression\nshall only appear in a function whose return type is void.\n","P2":"Semantics\nA return statement terminates execution of the current function and\nreturns control to its caller. A function may have any number of\nreturn statements.\n","P3":"If a return statement with an expression is executed, the value of the expression is returned to the caller as the value of the function call expression. If the expression has a type different from the return type of the function in which it appears, the value is converted as if by assignment to an object having the return type of the function.<foot>The return statement is not an assignment. The overlap restriction of subclause 6.5.16.1 does not apply to the case of function return. The representation of floating-point values may have wider range or precision than implied by the type; a cast may be used to remove this extra range and precision.</foot>\n","P4":"EXAMPLE In:\n<code>\n  struct s { double i; } f(void);\n  union {\n    struct {\n      int f1;\n      struct s f2;\n    } u1;\n    struct {\n      struct s f3;\n      int f4;\n    } u2;\n  } g;\n  struct s f(void)\n  {\n    return g.u1.f2;\n  }\n  /* ... */\n  g.u2.f3 = f();\n</code>\nthere is no undefined behavior, although there would be if the\nassignment were done directly (without using a function call to fetch\nthe value).\n"},"title":"Jump statements","P1":"Syntax\njump-statement:\n  goto identifier ;\n  continue ;\n  break ;\n  return expressionopt ;\n","P2":"Semantics\nA jump statement causes an unconditional jump to another place.\n"},"title":"Statements and blocks","P1":"Syntax\nstatement:\n  labeled-statement\n  compound-statement\n  expression-statement\n  selection-statement\n  iteration-statement\n  jump-statement\n","P2":"Semantics\nA statement specifies an action to be performed. Except as indicated,\nstatements are executed in sequence.\n","P3":"A block allows a set of declarations and statements to be grouped into one syntactic unit.  The initializers of objects that have automatic storage duration, and the variable length array declarators of ordinary identifiers with block scope, are evaluated and the values are stored in the objects (including storing an indeterminate value in objects without an initializer) each time the declaration is reached in the order of execution, as if it were a statement, and within each declaration in the order that declarators appear.\n","P4":"A full expression is an expression that is not part of another expression or of a declarator.  Each of the following is a full expression: an initializer that is not part of a compound literal; the expression in an expression statement; the controlling expression of a selection statement (if or switch); the controlling expression of a while or do statement; each of the (optional) expressions of a for statement; the (optional) expression in a return statement. There is a sequence point between the evaluation of a full expression and the evaluation of the next full expression to be evaluated.\n"},"9":{"1":{"title":"Function definitions","P1":"Syntax\nfunction-definition:\n  declaration-specifiers declarator declaration-listopt compound-statement\ndeclaration-list:\n  declaration\n  declaration-list declaration\n","P2":"Constraints\nThe identifier declared in a function definition (which is the name of\nthe function) shall have a function type, as specified by the\ndeclarator portion of the function definition.\n<foot>\nThe intent is that the type category in a function definition cannot be\ninherited from a typedef:\n<code>\n  typedef int F(void);          // type F is ‘‘function with no parameters\n                                // returning int’’\n  F f, g;                       // f and g both have type compatible with F\n  F f { /* ... */ }             // WRONG: syntax/constraint error\n  F g() { /* ... */ }           // WRONG:declares that g returns a function\n  int f(void) { /* ... */ }     // RIGHT: f has type compatible with F\n  int g() { /* ... */ }         // RIGHT: g has type compatible with F\n  F *e(void) { /* ... */ }      // e returns a pointer to a function\n  F *((e))(void) { /* ... */ }  // same: parentheses irrelevant\n  int (*fp)(void);              // fp points to a function that has type F\n  F *Fp;                        // Fp points to a function that has type F \n</code>\n</foot>\n","P3":"The return type of a function shall be void or a complete object type other than array type.\n","P4":"The storage-class specifier, if any, in the declaration specifiers shall be either extern or static.\n","P5":"If the declarator includes a parameter type list, the declaration of each parameter shall include an identifier, except for the special case of a parameter list consisting of a single parameter of type void, in which case there shall not be an identifier. No declaration list shall follow.\n","P6":"If the declarator includes an identifier list, each declaration in the declaration list shall have at least one declarator, those declarators shall declare only identifiers from the identifier list, and every identifier in the identifier list shall be declared. An identifier declared as a typedef name shall not be redeclared as a parameter. The declarations in the declaration list shall contain no storage-class specifier other than register and no initializations.\n","P7":"Semantics\nThe declarator in a function definition specifies the name of the\nfunction being defined and the identifiers of its parameters. If the\ndeclarator includes a parameter type list, the list also specifies the\ntypes of all the parameters; such a declarator also serves as a\nfunction prototype for later calls to the same function in the same\ntranslation unit. If the declarator includes an identifier list,<foot>\nSee ‘‘future language directions’’ (6.11.7).</foot>\nthe types of the parameters shall be declared in a following\ndeclaration list. In either case, the type of each parameter is\nadjusted as described in 6.7.6.3 for a parameter type list; the\nresulting type shall be a complete object type.\n","P8":"If a function that accepts a variable number of arguments is defined without a parameter type list that ends with the ellipsis notation, the behavior is undefined.\n","P9":"Each parameter has automatic storage duration; its identifier is an lvalue.<foot>A parameter identifier cannot be redeclared in the function body except in an enclosed block.</foot> The layout of the storage for parameters is unspecified.\n","P10":"On entry to the function, the size expressions of each variably modified parameter are evaluated and the value of each argument expression is converted to the type of the corresponding parameter as if by assignment. (Array expressions and function designators as arguments were converted to pointers before the call.)\n","P11":"After all parameters have been assigned, the compound statement that constitutes the body of the function definition is executed.\n","P12":"If the } that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.\n","P13":"EXAMPLE 1\nIn the following:\n<code>\n  extern int max(int a, int b)\n  {\n    return a > b ? a : b;\n  }\n</code>\nextern is the storage-class specifier and int is the type specifier;\nmax(int a, int b) is the function declarator; and\n<code>\n  { return a > b ? a : b; }\n</code>\nis the function body. The following similar definition uses the\nidentifier-list form for the parameter declarations:\n<code>\n  extern int max(a, b)\n  int a, b;\n  {\n    return a > b ? a : b;\n  }\n</code>\nHere int a, b; is the declaration list for the parameters. The\ndifference between these two definitions is that the first form acts as\na prototype declaration that forces conversion of the arguments of\nsubsequent calls to the function, whereas the second form does not.\n","P14":"EXAMPLE 2\nTo pass one function to another, one might say\n<code>\n  int f(void);\n  /* ... */\n  g(f);\n</code>\nThen the definition of g might read\n<code>\n  void g(int (*funcp)(void))\n  {\n    /* ... */\n    (*funcp)(); /* or funcp(); ... */\n  }\n</code>\nor, equivalently,\n<code>\n  void g(int func(void))\n  {\n    /* ... */\n    func(); /* or (*func)(); ... */\n  }\n</code>\n"},"2":{"title":"External object definitions","P1":"Semantics\nIf the declaration of an identifier for an object has file scope and an\ninitializer, the declaration is an external definition for the\nidentifier.\n","P2":"A declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with the storage-class specifier static, constitutes a tentative definition. If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definition for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.\n","P3":"If the declaration of an identifier for an object is a tentative definition and has internal linkage, the declared type shall not be an incomplete type.\n","P4":"EXAMPLE 1\nint i1 = 1;         // definition, external linkage\nstatic int i2 = 2;  // definition, internal linkage\nextern int i3 = 3;  // definition, external linkage\nint i4;             // tentative definition, external linkage\nstatic int i5;      // tentative definition, internal linkage\n\nint i1; // valid tentative definition, refers to previous\nint i2; // 6.2.2 renders undefined, linkage disagreement\nint i3; // valid tentative definition, refers to previous\nint i4; // valid tentative definition, refers to previous\nint i5; // 6.2.2 renders undefined, linkage disagreement\n\nextern int i1; // refers to previous, whose linkage is external\nextern int i2; // refers to previous, whose linkage is internal\nextern int i3; // refers to previous, whose linkage is external\nextern int i4; // refers to previous, whose linkage is external\nextern int i5; // refers to previous, whose linkage is internal\n","P5":"EXAMPLE 2\nIf at the end of the translation unit containing\n<code>\n  int i[];\n</code>\nthe array i still has incomplete type, the implicit initializer causes\nit to have one element, which is set to zero on program startup.\n"},"title":"External definitions","P1":"Syntax\ntranslation-unit:\n  external-declaration\n  translation-unit external-declaration\nexternal-declaration:\n  function-definition\n  declaration\n","P2":"Constraints\nThe storage-class specifiers auto and register shall not appear in the\ndeclaration specifiers in an external declaration.\n","P3":"There shall be no more than one external definition for each identifier declared with internal linkage in a translation unit. Moreover, if an identifier declared with internal linkage is used in an expression (other than as a part of the operand of a sizeof or _Alignof operator whose result is an integer constant), there shall be exactly one external definition for the identifier in the translation unit.\n","P4":"Semantics\nAs discussed in 5.1.1.1, the unit of program text after preprocessing is\na translation unit, which consists of a sequence of external\ndeclarations. These are described as ‘‘external’’ because they appear\noutside any function (and hence have file scope). As discussed in 6.7, a\ndeclaration that also causes storage to be reserved for an object or a\nfunction named by the identifier is a definition.\n","P5":"An external definition is an external declaration that is also a definition of a function (other than an inline definition) or an object. If an identifier declared with external linkage is used in an expression (other than as part of the operand of a sizeof or _Alignof operator whose result is an integer constant), somewhere in the entire program there shall be exactly one external definition for the identifier; otherwise, there shall be no more than one.<foot>Thus, if an identifier declared with external linkage is not used in an expression, there need be no external definition for it.</foot>\n"},"10":{"title":"Preprocessing directives"},"11":{"1":{"title":"Floating types","P1":"Future standardization may include additional floating-point types, including those with greater range, precision, or both than long double.\n"},"2":{"title":"Linkages of identifiers","P1":"Declaring an identifier with internal linkage at file scope without the static storageclass specifier is an obsolescent feature.\n"},"3":{"title":"External names","P1":"Restriction of the significance of an external name to fewer than 255 characters (considering each universal character name or extended source character as a single character) is an obsolescent feature that is a concession to existing implementations.\n"},"4":{"title":"Character escape sequences","P1":"Lowercase letters as escape sequences are reserved for future standardization. Other characters may be used in extensions.\n"},"5":{"title":"Storage-class specifiers","P1":"The placement of a storage-class specifier other than at the beginning of the declaration specifiers in a declaration is an obsolescent feature.\n"},"6":{"title":"Function declarators","P1":"The use of function declarators with empty parentheses (not prototype-format parameter type declarators) is an obsolescent feature.\n"},"7":{"title":"Function definitions","P1":"The use of function definitions with separate parameter identifier and declaration lists (not prototype-format parameter type and identifier declarators) is an obsolescent feature.\n"},"8":{"title":"Pragma directives","P1":"Pragmas whose first preprocessing token is STDC are reserved for future standardization.\n"},"9":{"title":"Predefined macro names","P1":"Macro names beginning with _ _STDC_ are reserved for future standardization.\n"},"title":"Future language directions"},"title":"Language"}}
