# Section 1
1:
  title: Scope
  P1: >
    This International Standard specifies the form and establishes the
    interpretation of programs written in the C programming language.
    <foot>This International Standard is designed to promote the portability of C
    programs among a variety of data-processing systems. It is intended for use
    by implementors and programmers.</foot>
    It specifies
    <ul>
    <li>the representation of C programs;</li>
    <li>the syntax and constraints of the C language;</li>
    <li>the semantic rules for interpreting C programs;</li>
    <li>the representation of input data to be processed by C programs;</li>
    <li>the representation of output data produced by C programs;</li>
    <li>the restrictions and limits imposed by a conforming implementation of C.</li>
    </ul>
  P2: >
    This International Standard does not specify
    <ul>
    <li>the mechanism by which C programs are transformed for use by a
    data-processing system;</li>
    <li>the mechanism by which C programs are invoked for use by a
    data-processing system;</li>
    <li>the mechanism by which input data are transformed for use by a
    C program;</li>
    <li>the mechanism by which output data are transformed after being
    produced by a C program;</li>
    <li>the size or complexity of a program and its data that will exceed
    the capacity of any specific data-processing system or the capacity of
    a particular processor;</li>
    <li>all minimal requirements of a data-processing system that is capable
    of supporting a conforming implementation.</li>
    </ul>

# Section 2
2:
  title: Normative references
  P1: >
    The following referenced documents are indispensable for the application of
    this document. For dated references, only the edition cited applies. For
    undated references, the latest edition of the referenced document
    (including any amendments) applies.
  P2: >
    ISO/IEC 2382−1:1993, Information technology — Vocabulary — Part 1:
    Fundamental terms.
  P3: ISO 4217, Codes for the representation of currencies and funds.
  P4: >
    ISO 8601, Data elements and interchange formats — Information interchange —
    Representation of dates and times.
  P5: ISO/IEC 10646, Information technology — Universal Coded Character Set (UCS).
  P6: >
    IEC 60559:1989, Binary floating-point arithmetic for microprocessor systems
    (previously designated IEC 559:1989).
  P7: >
    ISO 80000−2, Quantities and units — Part 2: Mathematical signs and symbols
    to be used in the natural sciences and technology.

# Section 3:
3:
  title: Terms, definitions, and symbols
  P1: >
    For the purposes of this document, the following terms and definitions apply.
    Other terms are defined where they appear in italic type or on the left side
    of a syntax rule.
    Terms explicitly defined in this International Standard are not to be presumed
    to refer implicitly to similar terms defined elsewhere. Terms not defined in
    this International Standard are to be interpreted according to ISO/IEC 2382−1.
    Mathematical symbols not defined in this International Standard are to be
    interpreted according to ISO 80000−2.
  1:
    P1: |
      <b>access</b>
      〈execution-time action〉to read or modify the value of an object
    P2: >
      NOTE 1 Where only one of these two actions is meant, ‘‘read’’ or
      ‘‘modify’’ is used.
    P3: >
      NOTE 2 ‘‘Modify’’ includes the case where the new value being stored is
      the same as the previous value.
    P4: NOTE 3 Expressions that are not evaluated do not access objects.
  2:
    P1: |
      <b>alignment</b>
      requirement that objects of a particular type be located on storage
      boundaries with addresses that are particular multiples of a byte address
  3:
    P1: |
      <b>argument</b>
      actual argument
      actual parameter (deprecated)
      expression in the comma-separated list bounded by the parentheses in a
      function call expression, or a sequence of preprocessing tokens in the
      comma-separated list bounded by the parentheses in a function-like macro
      invocation
  4:
    P1: |
      <b>behavior</b>
      external appearance or action
    1:
      P1: |
        <b>implementation-defined behavior</b>
        unspecified behavior where each implementation documents
        how the choice is made
      P2: >
        EXAMPLE An example of implementation-defined behavior is the
        propagation of the high-order bit when a signed integer is shifted
        right.
    2:
      P1: |
        <b>locale-specific behavior</b>
        behavior that depends on local conventions of nationality, culture, and
        language that each implementation documents
      P2: >
        EXAMPLE An example of locale-specific behavior is whether the islower
        function returns true for characters other than the 26 lowercase Latin
        letters.
    3:
      P1: |
        <b>undefined behavior</b>
        behavior, upon use of a nonportable or erroneous program construct or
        of erroneous data, for which this International Standard imposes no
        requirements
      P2: >
        NOTE Possible undefined behavior ranges from ignoring the situation
        completely with unpredictable results, to behaving during translation
        or program execution in a documented manner characteristic of the
        environment (with or without the issuance of a diagnostic message), to
        terminating a translation or execution (with the issuance of a
        diagnostic message).
      P3: >
        EXAMPLE An example of undefined behavior is the behavior on integer
        overflow.
    4:
      P1: |
        <b>unspecified behavior</b>
        use of an unspecified value, or other behavior where this International
        Standard provides two or more possibilities and imposes no further
        requirements on which is chosen in any instance
      P2: >
        EXAMPLE An example of unspecified behavior is the order in which the
        arguments to a function are evaluated.
  5:
    P1: |
      <b>bit</b>
      unit of data storage in the execution environment large enough to hold an
      object that may have one of two values
    P2: >
      NOTE It need not be possible to express the address of each individual
      bit of an object.
  6:
    P1: |
      <b>byte</byte>
      addressable unit of data storage large enough to hold any member of the
      basic character set of the execution environment
    P2: >
      NOTE 1 It is possible to express the address of each individual byte of
      an object uniquely.
    P3: >
      NOTE 2 A byte is composed of a contiguous sequence of bits, the number of
      which is implementationdefined. The least significant bit is called the
      low-order bit; the most significant bit is called the high-order bit.
  7:
    P1: |
      <b>character</b>
      〈abstract〉 member of a set of elements used for the organization,
      control, orrepresentation of data
    1:
      P1: |
        <b>character</b>
        single-byte character
        〈C〉 bit representation that fits in a byte
    2:
      P1: |
        <b>multibyte character</b>
        sequence of one or more bytes representing a member of the extended
        character set of either the source or the execution environment
      P2: NOTE The extended character set is a superset of the basic character set.
    3:
      P1: |
        <b>wide character</b>
        value representable by an object of type wchar_t, capable of
        representing any character in the current locale
  8:
    P1: |
      <b>constraint</b>
      restriction, either syntactic or semantic, by which the exposition of
      language elements is to be interpreted
  9:
    P1: |
      <b>correctly rounded result</b>
      representation in the result format that is nearest in value, subject to
      the current rounding mode, to what the result would be given unlimited
      range and precision
  10:
    P1: |
      <b>diagnostic message</b>
      message belonging to an implementation-defined subset of the
      implementation’s message output
  11:
    P1: |
      <b>forward reference</b>
      reference to a later subclause of this International Standard that
      contains additional information relevant to this subclause
  12:
    P1: |
      <b>implementation</b>
      particular set of software, running in a particular translation
      environment under particular control options, that performs translation
      of programs for, and supports execution of functions in, a particular
      execution environment
  13:
    P1: |
      <b>implementation limit</b>
      restriction imposed upon programs by the implementation
  14:
    P1: |
      <b>memory location</b>
      either an object of scalar type, or a maximal sequence of adjacent
      bit-fields all having nonzero width
    P2: >
      NOTE 1 Two threads of execution can update and access separate memory
      locations without interfering with each other.
    P3: >
      NOTE 2 A bit-field and an adjacent non-bit-field member are in separate
      memory locations. The same applies to two bit-fields, if one is declared
      inside a nested structure declaration and the other is not, or if the two
      are separated by a zero-length bit-field declaration, or if they are
      separated by a non-bit-field member declaration. It is not safe to
      concurrently update two non-atomic bit-fields in the same structure if
      all members declared between them are also (non-zero-length) bit-fields,
      no matter what the sizes of those intervening bit-fields happen to be.
    P4: |
      EXAMPLE A structure declared as
      <code>struct {
          char a;
          int b:5, c:11, :0, d:8;
          struct { int ee:8; } e;
        }</code>
      contains four separate memory locations: The member a, and bit-fields d
      and e.ee are each separate memory locations, and can be modified
      concurrently without interfering with each other. The bit-fields b and c
      together constitute the fourth memory location. The bit-fields b and c
      cannot be concurrently modified, but b and a, for example, can be.
  15:
    P1: |
      <b>object</b>
      region of data storage in the execution environment, the contents of which can represent values
    P2: >
      NOTE When referenced, an object may be interpreted as having a particular
      type; see 6.3.2.1.
  16:
    P1: |
      <b>parameter</b>
      formal parameter
      formal argument (deprecated)
      object declared as part of a function declaration or definition that
      acquires a value on entry to the function, or an identifier from the
      comma-separated list bounded by the parentheses immediately following the
      macro name in a function-like macro definition
  17:
    P1: |
      <b>recommended practice</b>
      specification that is strongly recommended as being in keeping with
      the intent of the standard, but that may be impractical for some
      implementations
  18:
    P1: |
      <b>runtime-constraint</b>
      requirement on a program when calling a library function
    P2: >
      NOTE 1 Despite the similar terms, a runtime-constraint is not a kind of
      constraint as defined by 3.8, and need not be diagnosed at translation
      time.
    P3: >
      NOTE 2 Implementations that support the extensions in annex K are
      required to verify that the runtimeconstraints for a library function are
      not violated by the program; see K.3.1.4.
  19:
    P1: |
      <b>value</b>
      precise meaning of the contents of an object when interpreted as having
      a specific type
    1:
      P1: |
        <b>implementation-defined value</b>
        unspecified value where each implementation documents how the choice
        is made
    2:
      P1: |
        <b>indeterminate value</b>
        either an unspecified value or a trap representation
    3:
      P1: |
        <b>unspecified value</b>
        valid value of the relevant type where this International Standard
        imposes no requirements on which value is chosen in any instance
      P2: NOTE An unspecified value cannot be a trap representation.
    4:
      P1: |
        <b>trap representation</b>
        an object representation that need not represent a value of the object type
    5:
      P1: |
        <b>perform a trap</b>
        interrupt execution of the program such that no further operations
        are performed
      P2: >
        NOTE In this International Standard, when the word ‘‘trap’’ is not
        immediately followed by ‘‘representation’’, this is the intended
        usage.2)
  20:
    P1: |
      ⎡x⎤
      ceiling of x: the least integer greater than or equal to x
    P2: EXAMPLE ⎡2. 4⎤ is 3, ⎡−2. 4⎤ is −2.
  21:
    P1: |
      ⎣x⎦
      floor of x: the greatest integer less than or equal to x
    P2: >
      EXAMPLE <foot>For example, ‘‘Trapping or stopping (if supported) is
      disabled...’’ (F.8.2). Note that fetching a trap representation might
      perform a trap but is not required to (see 6.2.6.1).</foot>⎣2. 4⎦ is 2,
      ⎣−2. 4⎦ is −3.
4:
  title: Conformance
  P1: >
    In this International Standard, ‘‘shall’’ is to be interpreted as a
    requirement on an implementation or on a program; conversely, ‘‘shall not’’
    is to be interpreted as a prohibition.
  P2: >
    If a ‘‘shall’’ or ‘‘shall not’’ requirement that appears outside of a
    constraint or runtimeconstraint is violated, the behavior is undefined.
    Undefined behavior is otherwise indicated in this International Standard by
    the words ‘‘undefined behavior’’ or by the omission of any explicit
    definition of behavior. There is no difference in emphasis among these
    three; they all describe ‘‘behavior that is undefined’’.
  P3: >
    A program that is correct in all other aspects, operating on correct data,
    containing unspecified behavior shall be a correct program and act in
    accordance with 5.1.2.3.
  P4: >
    The implementation shall not successfully translate a preprocessing
    translation unit containing a \#error preprocessing directive unless it is
    part of a group skipped by conditional inclusion.
  P5: |
    A strictly conforming program shall use only those features of the language
    and library specified in this International Standard.<foot>A strictly
    conforming program can use conditional features (see 6.10.8.3) provided the
    use is guarded by an appropriate conditional inclusion preprocessing
    directive using the related macro.
    For example:<code>
    \#ifdef _ _STDC_IEC_559_ _ /* FE_UPWARD defined */
    /* ... */
    fesetround(FE_UPWARD);
    /* ... */
    \#endif</code></foot> It shall not produce output dependent on any
    unspecified, undefined, or implementation-defined behavior, and shall not
    exceed any minimum implementation limit.
  P6: >
    The two forms of conforming implementation are hosted and freestanding. A
    conforming hosted implementation shall accept any strictly conforming
    program. A conforming freestanding implementation shall accept any strictly
    conforming program in which the use of the features specified in the
    library clause (clause 7) is confined to the contents of the standard
    headers <float.h>, <iso646.h>, <limits.h>, <stdalign.h>, <b><stdarg.h></b>,
    <b><stdbool.h></b>, <b><stddef.h></b>, <b><stdint.h></b>, and
    <b><stdnoreturn.h></b>. A conforming implementation may have extensions
    (including additional library functions), provided they do not alter the
    behavior of any strictly conforming program.<foot>This implies that a
    conforming implementation reserves no identifiers other than those
    explicitly reserved in this International Standard.</foot>
  P7: >
    A conforming program is one that is acceptable to a conforming
    implementation.  <foot>Strictly conforming programs are intended to be
    maximally portable among conforming implementations. Conforming programs
    may depend upon nonportable features of a conforming implementation.</foot>
  P8: >
    An implementation shall be accompanied by a document that defines all
    implementationdefined and locale-specific characteristics and all
    extensions.

## TODO: Section 5

# Section 6
6:
  title: Language
  1:
    title: Notation
    P1: >
      In the syntax notation used in this clause, syntactic categories
      (nonterminals) are indicated by italic type, and literal words and
      character set members (terminals) by bold type. A colon (:) following a
      nonterminal introduces its definition. Alternative definitions are listed
      on separate lines, except when prefaced by the words ‘‘one of’’. An
      optional symbol is indicated by the subscript ‘‘opt’’, so that {
        expressionopt } indicates an optional expression enclosed in braces.
    P2: >
      For each different entity that an identifier designates, the identifier
      is visible (i.e., can be used) only within a region of program text
      called its scope. Different entities designated by the same identifier
      either have different scopes, or are in different name spaces. There are
      four kinds of scopes: function, file, block, and function prototype. (A
      function prototype is a declaration of a function that declares the types
      of its parameters.)
    P3: A summary of the language syntax is given in annex A.
  2:
    title: Concepts
    1:
      title: Scopes of identifiers
        P1: >
          An identifier can denote an object; a function; a tag or a member of
          a structure, union, or enumeration; a typedef name; a label name; a
          macro name; or a macro parameter. The same identifier can denote
          different entities at different points in the program. A member of an
          enumeration is called an enumeration constant. Macro names and macro
          parameters are not considered further here, because prior to the
          semantic phase of program translation any occurrences of macro names
          in the source file are replaced by the preprocessing token sequences
          that constitute their macro definitions.
        P2: >
          For each different entity that an identifier designates, the
          identifier is visible (i.e., can be used) only within a region of
          program text called its scope. Different entities designated by the
          same identifier either have different scopes, or are in different
          name spaces. There are four kinds of scopes: function, file, block,
          and function prototype. (A function prototype is a declaration of a
          function that declares the types of its parameters.)
        P3: >
          A label name is the only kind of identifier that has function scope.
          It can be used (in a goto statement) anywhere in the function in which
          it appears, and is declared implicitly by its syntactic appearance
          (followed by a : and a statement).
        P4: >
          Every other identifier has scope determined by the placement of its
          declaration (in a declarator or type specifier). If the declarator or
          type specifier that declares the identifier appears outside of any
          block or list of parameters, the identifier has file scope, which
          terminates at the end of the translation unit. If the declarator or
          type specifier that declares the identifier appears inside a block or
          within the list of parameter declarations in a function definition,
          the identifier has block scope, which terminates at the end of the
          associated block. If the declarator or type specifier that declares
          the identifier appears within the list of parameter declarations in a
          function prototype (not part of a function definition), the
          identifier has function prototype scope, which terminates at the end
          of the function declarator. If an identifier designates two different
          entities in the same name space, the scopes might overlap. If so, the
          scope of one entity (the inner scope) will end strictly before the
          scope of the other entity (the outer scope). Within the inner scope,
          the identifier designates the entity declared in the inner scope; the
          entity declared in the outer scope is hidden (and not visible) within
          the inner scope.
        P5: >
          Unless explicitly stated otherwise, where this International Standard
          uses the term ‘‘identifier’’ to refer to some entity (as opposed to
          the syntactic construct), it refers to the entity in the relevant
          name space whose declaration is visible at the point the identifier
          occurs.
        P6: >
          Two identifiers have the same scope if and only if their scopes
          terminate at the same point.
        P7: >
          Structure, union, and enumeration tags have scope that begins just
          after the appearance of the tag in a type specifier that declares the
          tag. Each enumeration constant has scope that begins just after the
          appearance of its defining enumerator in an enumerator list. Any
          other identifier has scope that begins just after the completion of
          its declarator.
        P8: >
          As a special case, a type name (which is not a declaration of an
          identifier) is considered to have a scope that begins just after the
          place within the type name where the omitted identifier would appear
          were it not omitted.
    2:
      title: Linkages of identifiers
      P1: >
        An identifier declared in different scopes or in the same scope more
        than once can be made to refer to the same object or function by a
        process called linkage.  <foot>There is no linkage between different
        identifiers.</foot>There are three kinds of linkage: external,
        internal, and none.
      P2: >
        In the set of translation units and libraries that constitutes an
        entire program, each declaration of a particular identifier with
        external linkage denotes the same object or function. Within one
        translation unit, each declaration of an identifier with internal
        linkage denotes the same object or function. Each declaration of an
        identifier with no linkage denotes a unique entity.
      P3: >
        If the declaration of a file scope identifier for an object or a
        function contains the storageclass specifier static, the identifier has
        internal linkage.  <foot>A function declaration can contain the
        storage-class specifier static only if it is at file scope; see
        6.7.1.</foot>
      P4: >
        For an identifier declared with the storage-class specifier extern in a
        scope in which a prior declaration of that identifier is visible,
        <foot>As specified in 6.2.1, the later declaration might hide the prior
        declaration.</foot> if the prior declaration specifies internal or
        external linkage, the linkage of the identifier at the later
        declaration is the same as the linkage specified at the prior
        declaration. If no prior declaration is visible, or if the prior
        declaration specifies no linkage, then the identifier has external
        linkage.
      P5: >
        If the declaration of an identifier for a function has no storage-class
        specifier, its linkage is determined exactly as if it were declared
        with the storage-class specifier extern. If the declaration of an
        identifier for an object has file scope and no storage-class specifier,
        its linkage is external.
      P6: >
        The following identifiers have no linkage: an identifier declared to be
        anything other than an object or a function; an identifier declared to
        be a function parameter; a block scope identifier for an object
        declared without the storage-class specifier extern.
      P7: >
        If, within a translation unit, the same identifier appears with both
        internal and external linkage, the behavior is undefined.
    3:
      title: Name spaces of identifiers
      P1: >
        If more than one declaration of a particular identifier is visible at
        any point in a translation unit, the syntactic context disambiguates
        uses that refer to different entities.
        Thus, there are separate name spaces for various categories of
        identifiers, as follows:
        — label names (disambiguated by the syntax of the label declaration and
        use);
        — the tags of structures, unions, and enumerations (disambiguated by
        following any<foot>There is only one name space for tags even though
        three are possible.</foot>) of the keywords struct, union, or enum);
        — the members of structures or unions; each structure or union has a
        separate name space for its members (disambiguated by the type of the
        expression used to access the member via the . or -> operator);
        — all other identifiers, called ordinary identifiers (declared in
        ordinary declarators or as enumeration constants).
    4:
      title: Storage durations of objects
      P1: >
        An object has a storage duration that determines its lifetime. There
        are four storage durations: static, thread, automatic, and allocated.
        Allocated storage is described in
        7.22.3.
      P2: >
        The lifetime of an object is the portion of program execution during
        which storage is guaranteed to be reserved for it. An object exists,
        has a constant address, <foot>The term ‘‘constant address’’ means that
        two pointers to the object constructed at possibly different times will
        compare equal. The address may be different during two different
        executions of the same program.</foot>and retains its last-stored value
        throughout its lifetime.<foot>In the case of a volatile object, the
        last store need not be explicit in the program.</foot>) If an object is
        referred to outside of its lifetime, the behavior is undefined. The
        value of a pointer becomes indeterminate when the object it points to
        (or just past) reaches the end of its lifetime.
      P3: >
        An object whose identifier is declared without the storage-class
        specifier _Thread_local, and either with external or internal linkage
        or with the storage-class specifier static, has static storage
        duration. Its lifetime is the entire execution of the program and its
        stored value is initialized only once, prior to program startup.
      P4: >
        An object whose identifier is declared with the storage-class specifier
        _Thread_local has thread storage duration. Its lifetime is the entire
        execution of the thread for which it is created, and its stored value
        is initialized when the thread is started. There is a distinct object
        per thread, and use of the declared name in an expression refers to the
        object associated with the thread evaluating the expression. The result
        of attempting to indirectly access an object with thread storage
        duration from a thread other than the one with which the object is
        associated is implementation-defined.
      P5: >
        An object whose identifier is declared with no linkage and without the
        storage-class specifier static has automatic storage duration, as do
        some compound literals. The result of attempting to indirectly access
        an object with automatic storage duration from a thread other than the
        one with which the object is associated is implementation-defined.
      P6: >
        For such an object that does not have a variable length array type, its
        lifetime extends from entry into the block with which it is associated
        until execution of that block ends in any way. (Entering an enclosed
        block or calling a function suspends, but does not end, execution of
        the current block.) If the block is entered recursively, a new instance
        of the object is created each time. The initial value of the object is
        indeterminate. If an initialization is specified for the object, it is
        performed each time the declaration or compound literal is reached in
        the execution of the block; otherwise, the value becomes indeterminate
        each time the declaration is reached.
      P7: >
        For such an object that does have a variable length array type, its
        lifetime extends from the declaration of the object until execution of
        the program leaves the scope of the declaration.<foot>Leaving the
        innermost block containing the declaration, or jumping to a point in
        that block or an embedded block prior to the declaration, leaves the
        scope of the declaration. If the scope is entered recursively, a new
        instance of the object is created</foot> each time. The initial value
        of the object is indeterminate.
      P8: >
        A non-lvalue expression with structure or union type, where the
        structure or union contains a member with array type (including,
        recursively, members of all contained structures and unions) refers to
        an object with automatic storage duration and temporary
        lifetime.<foot>The address of such an object is taken implicitly when
        an array member is accessed.</foot> Its lifetime begins when the
        expression is evaluated and its initial value is the value of the
        expression. Its lifetime ends when the evaluation of the containing
        full expression or full declarator ends. Any attempt to modify an
        object with temporary lifetime results in undefined behavior.
    5:
      title: Types
      P1: >
        The meaning of a value stored in an object or returned by a function is
        determined by the type of the expression used to access it. (An
        identifier declared to be an object is the simplest such expression;
        the type is specified in the declaration of the identifier.) Types are
        partitioned into object types (types that describe objects) and
        function types (types that describe functions). At various points
        within a translation unit an object type may be incomplete (lacking
        sufficient information to determine the size of objects of that type)
        or complete (having sufficient information).<foot>A type may be
        incomplete or complete throughout an entire translation unit, or it may
        change states at different points within a translation unit.</foot>
      P2: >
        An object declared as type _Bool is large enough to store the values
        0 and 1.
      P3: >
        An object declared as type char is large enough to store any member of
        the basic execution character set. If a member of the basic execution
        character set is stored in a char object, its value is guaranteed to be
        nonnegative. If any other character is stored in a char object, the
        resulting value is implementation-defined but shall be within the range
        of values that can be represented in that type.
      P4: >
        There are five standard signed integer types, designated as signed
        char, short int, int, long int, and long long int. (These and other
        types may be designated in several additional ways, as described in
        6.7.2.) There may also be implementation-defined extended signed
        integer types.<foot>Implementation-defined keywords shall have the form
        of an identifier reserved for any use as described in 7.1.3.</foot> The
        standard and extended signed integer types are collectively called
        signed integer types.  <foot>Therefore, any statement in this Standard
        about signed integer types also applies to the extended signed integer
        types.</foot>
      P5: >
        An object declared as type signed char occupies the same amount of
        storage as a ‘‘plain’’ char object. A ‘‘plain’’ int object has the
        natural size suggested by the architecture of the execution environment
        (large enough to contain any value in the range INT_MIN to INT_MAX as
        defined in the header <limits.h>).
      P6: >
        For each of the signed integer types, there is a corresponding (but
        different) unsigned integer type (designated with the keyword unsigned)
        that uses the same amount of storage (including sign information) and
        has the same alignment requirements. The type _Bool and the unsigned
        integer types that correspond to the standard signed integer types are
        the standard unsigned integer types. The unsigned integer types that
        correspond to the extended signed integer types are the extended
        unsigned integer types.  The standard and extended unsigned integer
        types are collectively called unsigned integer types.<foot>Therefore,
        any statement in this Standard about unsigned integer types also
        applies to the extended unsigned integer types.</foot>
      P7: >
        The standard signed integer types and standard unsigned integer types
        are collectively called the standard integer types; the extended signed
        integer types and extended unsigned integer types are collectively
        called the extended integer types.
      P8: >
        For any two integer types with the same signedness and different
        integer conversion rank (see 6.3.1.1), the range of values of the type
        with smaller integer conversion rank is a subrange of the values of the
        other type.
      P9: >
        The range of nonnegative values of a signed integer type is a subrange
        of the corresponding unsigned integer type, and the representation of
        the same value in each type is the same.<foot>The same representation
        and alignment requirements are meant to imply interchangeability as
        arguments to functions, return values from functions, and members of
        unions.</foot> A computation involving unsigned operands can never
        overflow, because a result that cannot be represented by the resulting
        unsigned integer type is reduced modulo the number that is one greater
        than the largest value that can be represented by the resulting type.
      P10: >
        There are three real floating types, designated as float, double, and
        long double.<foot>See ‘‘future language directions’’ (6.11.1).</foot>
        The set of values of the type float is a subset of the set of values of
        the type double; the set of values of the type double is a subset of
        the set of values of the type long double.
      P11: >
        There are three complex types, designated as float _Complex, double
        _Complex, and long double _Complex.<foot>A specification for imaginary
        types is in annex G.</foot> (Complex types are a conditional feature
        that implementations need not support; see 6.10.8.3.) The real floating
        and complex types are collectively called the floating types.
      P12: >
        For each floating type there is a corresponding real type, which is
        always a real floating type. For real floating types, it is the same
        type. For complex types, it is the type given by deleting the keyword
        _Complex from the type name.
      P13: >
        Each complex type has the same representation and alignment
        requirements as an array type containing exactly two elements of the
        corresponding real type; the first element is equal to the real part,
        and the second element to the imaginary part, of the complex
        number.
      P14: >
        The type char, the signed and unsigned integer types, and the floating
        types are collectively called the basic types. The basic types are
        complete object types. Even if the implementation defines two or more
        basic types to have the same representation, they are nevertheless
        different types.<foot>An implementation may define new keywords that
        provide alternative ways to designate a basic (or any other) type; this
        does not violate the requirement that all basic types be different.
        Implementation-defined keywords shall have the form of an identifier
        reserved for any use as described in 7.1.3.</foot>
      P15: >
        The three types char, signed char, and unsigned char are collectively
        called the character types. The implementation shall define char to
        have the same range, representation, and behavior as either signed char
        or unsigned char.<foot>CHAR_MIN, defined in <limits.h>, will have one
        of the values 0 or SCHAR_MIN, and this can be used to distinguish the
        two options. Irrespective of the choice made, char is a separate type
        from the other two and is not compatible with either.</foot>
      P16: >
        An enumeration comprises a set of named integer constant values. Each
        distinct enumeration constitutes a different enumerated type.
      P17: >
        The type char, the signed and unsigned integer types, and the
        enumerated types are collectively called integer types. The integer and
        real floating types are collectively called real types.
      P18: >
        Integer and floating types are collectively called arithmetic types.
        Each arithmetic type belongs to one type domain: the real type domain
        comprises the real types, the complex type domain comprises the complex
        types.
      P19: >
        The void type comprises an empty set of values; it is an incomplete
        object type that cannot be completed.
      P20: |
        Any number of derived types can be constructed from the object and
        function types, as follows:
        — An array type describes a contiguously allocated nonempty set of
        objects with a particular member object type, called the element type.
        The element type shall be complete whenever the array type is
        specified. Array types are characterized by their element type and by
        the number of elements in the array. An array type is said to be
        derived from its element type, and if its element type is T , the array
        type is sometimes called ‘‘array of T ’’. The construction of an array
        type from an element type is called ‘‘array type derivation’’.
        — A structure type describes a sequentially allocated nonempty set of
        member objects (and, in certain circumstances, an incomplete array),
        each of which has an optionally specified name and possibly distinct
        type.
        — A union type describes an overlapping nonempty set of member objects,
        each of which has an optionally specified name and possibly distinct
        type.
        — A function type describes a function with specified return type. A
        function type is characterized by its return type and the number and
        types of its parameters. A function type is said to be derived from its
        return type, and if its return type is T , the function type is
        sometimes called ‘‘function returning T ’’. The construction of a
        function type from a return type is called ‘‘function type
        derivation’’.
        — A pointer type may be derived from a function type or an object type,
        called the referenced type. A pointer type describes an object whose
        value provides a reference to an entity of the referenced type. A
        pointer type derived from the referenced type T is sometimes called
        ‘‘pointer to T ’’. The construction of a pointer type from a referenced
        type is called ‘‘pointer type derivation’’. A pointer type is a
        complete object type.
        — An atomic type describes the type designated by the construct _Atomic
        ( typename ). (Atomic types are a conditional feature that
        implementations need not support; see 6.10.8.3.)
        These methods of constructing derived types can be applied recursively.
      P21: >
        Arithmetic types and pointer types are collectively called scalar
        types. Array and structure types are collectively called aggregate
        types.<foot>Note that aggregate type does not include union type
        because an object with union type can only contain one member at a
        time.</foot>
      P22: >
        An array type of unknown size is an incomplete type. It is completed,
        for an identifier of that type, by specifying the size in a later
        declaration (with internal or external linkage).  A structure or union
        type of unknown content (as described in 6.7.2.3) is an incomplete
        type. It is completed, for all declarations of that type, by declaring
        the same structure or union tag with its defining content later in the
        same scope.
      P23: >
        A type has known constant size if the type is not incomplete and is not
        a variable length array type.
      P24: >
        Array, function, and pointer types are collectively called derived
        declarator types. A declarator type derivation from a type T is the
        construction of a derived declarator type from T by the application of
        an array-type, a function-type, or a pointer-type derivation to T.
      P25: >
        A type is characterized by its type category, which is either the
        outermost derivation of a derived type (as noted above in the
        construction of derived types), or the type itself if the type consists
        of no derived types.
      P26: >
        Any type so far mentioned is an unqualified type. Each unqualified type
        has several qualified versions of its type,<foot>See 6.7.3 regarding
        qualified array and function types.</foot> corresponding to the
        combinations of one, two, or all three of the const, volatile, and
        restrict qualifiers. The qualified or unqualified versions of a type
        are distinct types that belong to the same type category and have the
        same representation and alignment requirements.48) A derived type is
        not qualified by the qualifiers (if any) of the type from which it is
        derived.
      P27: >
        Further, there is the _Atomic qualifier. The presence of the _Atomic
        qualifier designates an atomic type. The size, representation, and
        alignment of an atomic type need not be the same as those of the
        corresponding unqualified type. Therefore, this Standard explicitly
        uses the phrase ‘‘atomic, qualified or unqualified type’’ whenever the
        atomic version of a type is permitted along with the other qualified
        versions of a type.  The phrase ‘‘qualified or unqualified type’’,
        without specific mention of atomic, does not include the atomic types.
      P28: >
        A pointer to void shall have the same representation and alignment
        requirements as a pointer to a character type.<foot>The same
        representation and alignment requirements are meant to imply
        interchangeability as arguments to functions, return values from
        functions, and members of unions.</foot> Similarly, pointers to
        qualified or unqualified versions of compatible types shall have the
        same representation and alignment requirements. All pointers to
        structure types shall have the same representation and alignment
        requirements as each other. All pointers to union types shall have the
        same representation and alignment requirements as each other. Pointers
        to other types need not have the same representation or alignment
        requirements.
      P29: >
        EXAMPLE 1 The type designated as ‘‘float *’’ has type ‘‘pointer to
        float’’. Its type category is pointer, not a floating type. The
        const-qualified version of this type is designated as ‘‘float * const’’
        whereas the type designated as ‘‘const float *’’ is not a qualified
        type — its type is ‘‘pointer to const- qualified float’’ and is a
        pointer to a qualified type.
      P30: >
        EXAMPLE 2 The type designated as ‘‘struct tag (*[5])(float)’’ has type
        ‘‘array of pointer to function returning struct tag’’. The array has
        length five and the function has a single parameter of type float. Its
        type category is array.
    6:
      title: Representations of types
      1:
        title: General
        P1: >
          The representations of all types are unspecified except as stated
          in this subclause.
        P2: >
          Except for bit-fields, objects are composed of contiguous sequences
          of one or more bytes, the number, order, and encoding of which are
          either explicitly specified or implementation-defined.
        P3: >
          Values stored in unsigned bit-fields and objects of type unsigned
          char shall be represented using a pure binary notation.<foot>A
          positional representation for integers that uses the binary digits 0
          and 1, in which the values represented by successive bits are
          additive, begin with 1, and are multiplied by successive integral
          powers of 2, except perhaps the bit with the highest position.
          (Adapted from the American National Dictionary for Information
          Processing Systems.) A byte contains CHAR_BIT bits, and the values of
          CHAR_BIT type unsigned char range from 0 to 2 − 1.</foot>
        P4: >
          Values stored in non-bit-field objects of any other object type
          consist of n × CHAR_BIT bits, where n is the size of an object of
          that type, in bytes. The value may be copied into an object of type
          unsigned char [n] (e.g., by memcpy); the resulting set of bytes is
          called the object representation of the value. Values stored in
          bit-fields consist of m bits, where m is the size specified for the
          bit-field. The object representation is the set of m bits the
          bit-field comprises in the addressable storage unit holding it. Two
          values (other than NaNs) with the same object representation compare
          equal, but values that compare equal may have different object
          representations.
        P5: >
          Certain object representations need not represent a value of the
          object type. If the stored value of an object has such a
          representation and is read by an lvalue expression that does not have
          character type, the behavior is undefined. If such a representation
          is produced by a side effect that modifies all or any part of the
          object by an lvalue expression that does not have character type, the
          behavior is undefined.<foot>Thus, an automatic variable can be
          initialized to a trap representation without causing undefined
          behavior, but the value of the variable cannot be used until a proper
          value is stored in it.</foot> Such a representation is called a trap
          representation.
        P6: >
          When a value is stored in an object of structure or union type,
          including in a member object, the bytes of the object representation
          that correspond to any padding bytes take unspecified
          values.<foot>Thus, for example, structure assignment need not copy
          any padding bits.</foot> The value of a structure or union object is
          never a trap representation, even though the value of a member of the
          structure or union object may be a trap representation.
        P7: >
          When a value is stored in a member of an object of union type, the
          bytes of the object representation that do not correspond to that
          member but do correspond to other members take unspecified values.
        P8: >
          Where an operator is applied to a value that has more than one object
          representation, which object representation is used shall not affect
          the value of the result.<foot>It is possible for objects x and y with
          the same effective type T to have the same value when they are
          accessed as objects of type T, but to have different values in other
          contexts. In particular, if == is defined for type T, then x == y
          does not imply that memcmp(&x, &y, sizeof (T)) == 0. Furthermore, x
          == y does not necessarily imply that x and y have the same value;
          other operations on values of type T may distinguish between
          them.</foot> Where a value is stored in an object using a type that
          has more than one object representation for that value, it is
          unspecified which representation is used, but a trap representation
          shall not be generated.
        P9: >
          Loads and stores of objects with atomic types are done with
          memory_order_seq_cst semantics.
      2:
        title: Integer types
        P1: >
          For unsigned integer types other than unsigned char, the bits of the
          object representation shall be divided into two groups: value bits and
          padding bits (there need not be any of the latter). If there are N
          value bits, each bit shall represent a different power of 2 between 1
          and 2 N −1 , so that objects of that type shall be capable of
          representing values from 0 to 2 N − 1 using a pure binary
          representation; this shall be known as the value representation. The
          values of any padding bits are unspecified.<foot>Some combinations of
          padding bits might generate trap representations, for example, if one
          padding bit is a parity bit. Regardless, no arithmetic operation on
          valid values can generate a trap representation other than as part of
          an exceptional condition such as an overflow, and this cannot occur
          with unsigned types. All other combinations of padding bits are
          alternative object representations of the value specified by the value
          bits.</foot>
        P2: >
          For signed integer types, the bits of the object representation shall
          be divided into three groups: value bits, padding bits, and the sign
          bit. There need not be any padding bits; signed char shall not have any
          padding bits. There shall be exactly one sign bit.  Each bit that is a
          value bit shall have the same value as the same bit in the object
          representation of the corresponding unsigned type (if there are M value
          bits in the signed type and N in the unsigned type, then M ≤ N ). If
          the sign bit is zero, it shall not affect the resulting value. If the
          sign bit is one, the value shall be modified in one of the
          following ways:
          — the corresponding value with sign bit 0 is negated (sign and magnitude);
          — the sign bit has the value −(2 M ) (two’s complement);
          — the sign bit has the value −(2 M − 1) (ones’ complement).
          Which of these applies is implementation-defined, as is whether the
          value with sign bit 1 and all value bits zero (for the first two), or
          with sign bit and all value bits 1 (for ones’ complement), is a trap
          representation or a normal value. In the case of sign and magnitude
          and ones’ complement, if this representation is a normal value it is
          called a negative zero.
        P3: >
          If the implementation supports negative zeros, they shall be
          generated only by:
          — the &, |, ^, ~, <<, and >> operators with operands that produce
          such a value;
          — the +, -, *, /, and % operators where one operand is a negative
          zero and the result is zero;
          — compound assignment operators based on the above cases.  It is
          unspecified whether these cases actually generate a negative zero or
          a normal zero, and whether a negative zero becomes a normal zero when
          stored in an object
        P4: >
          If the implementation does not support negative zeros, the behavior
          of the &, |, ^, ~, <<, and >> operators with operands that would
          produce such a value is undefined.
        P5: >
          The values of any padding bits are unspecified.<foot>Some
          combinations of padding bits might generate trap representations, for
          example, if one padding bit is a parity bit. Regardless, no
          arithmetic operation on valid values can generate a trap
          representation other than as part of an exceptional condition such as
          an overflow. All other combinations of padding bits are alternative
          object representations of the value specified by the value
          bits.</foot> A valid (non-trap) object representation of a signed
          integer type where the sign bit is zero is a valid object
          representation of the corresponding unsigned type, and shall
          represent the same value. For any integer type, the object
          representation where all the bits are zero shall be a representation
          of the value zero in that type.
        P6: >
          The precision of an integer type is the number of bits it uses to
          represent values, excluding any sign and padding bits. The width of
          an integer type is the same but including any sign bit; thus for
          unsigned integer types the two values are the same, while for signed
          integer types the width is one greater than the precision.
    7:
      title: Compatible type and composite type
      P1: >
        Two types have compatible type if their types are the same. Additional
        rules for determining whether two types are compatible are described in
        6.7.2 for type specifiers, in 6.7.3 for type qualifiers, and in 6.7.6
        for declarators.<foot>Two types need not be identical to be
        compatible.</foot> Moreover, two structure, union, or enumerated types
        declared in separate translation units are compatible if their tags and
        members satisfy the following requirements: If one is declared with a
        tag, the other shall be declared with the same tag. If both are completed
        anywhere within their respective translation units, then the following
        additional requirements apply: there shall be a one-to-one correspondence
        between their members such that each pair of corresponding members are
        declared with compatible types; if one member of the pair is declared
        with an alignment specifier, the other is declared with an equivalent
        alignment specifier; and if one member of the pair is declared with a
        name, the other is declared with the same name. For two structures,
        corresponding members shall be declared in the same order. For two
        structures or unions, corresponding bit-fields shall have the same
        widths. For two enumerations, corresponding members shall have the same
        values.
      P2: >
        All declarations that refer to the same object or function shall have
        compatible type; otherwise, the behavior is undefined.
      P3: >
        A composite type can be constructed from two types that are compatible;
        it is a type that is compatible with both of the two types and satisfies
        the following conditions:
        — If both types are array types, the following rules are applied:
        * If one type is an array of known constant size, the composite type is
        an array of that size.
        * Otherwise, if one type is a variable length array whose size is
        specified by an expression that is not evaluated, the behavior is
        undefined.
        * Otherwise, if one type is a variable length array whose size is
        specified, the composite type is a variable length array of that size.
        * Otherwise, if one type is a variable length array of unspecified
        size, the composite
        type is a variable length array of unspecified size.
        * Otherwise, both types are arrays of unknown size and the composite
        type is an array of unknown size.  The element type of the composite
        type is the composite type of the two element
        types.
        — If only one type is a function type with a parameter type list
        (a function prototype),
        the composite type is a function prototype with the parameter type list.
        — If both types are function types with parameter type lists, the type
        of each parameter in the composite parameter type list is the composite
        type of the corresponding parameters.
        These rules apply recursively to the types from which the two types are
        derived.
      P4: >
        For an identifier with internal or external linkage declared in a scope
        in which a prior declaration of that identifier is visible,<foot>As
        specified in 6.2.1, the later declaration might hide the prior
        declaration.</foot> if the prior declaration specifies internal or
        external linkage, the type of the identifier at the later declaration
        becomes the composite type.
      P5: |
        EXAMPLE
        Given the following two file scope declarations:
        <code>
        int f(int (*)(), double (*)[3]);
        int f(int (*)(char *), double (*)[]);
        </code>
        The resulting composite type for the function is:
        <code>
        int f(int (*)(char *), double (*)[3]);
        </code>
    8:
      title: Alignment of objects 
      P1: >
        Complete object types have alignment requirements which place
        restrictions on the addresses at which objects of that type may be
        allocated. An alignment is an implementation-defined integer value
        representing the number of bytes between successive addresses at which
        a given object can be allocated. An object type imposes an alignment
        requirement on every object of that type: stricter alignment can be
        requested using the _Alignas keyword.
      P2: >
        A fundamental alignment is represented by an alignment less than or
        equal to the greatest alignment supported by the implementation in all
        contexts, which is equal to _Alignof (max_align_t).
      P3: >
        An extended alignment is represented by an alignment greater than
        _Alignof (max_align_t). It is implementation-defined whether any
        extended alignments are supported and the contexts in which they are
        supported. A type having an extended alignment requirement is an
        over-aligned type.<foot>Every over-aligned type is, or contains, a
        structure or union type with a member to which an extended alignment
        has been applied.</foot>
      P4: >
        Alignments are represented as values of the type size_t. Valid
        alignments include only those values returned by an _Alignof expression
        for fundamental types, plus an additional implementation-defined set of
        values, which may be empty. Every valid alignment value shall be a
        nonnegative integral power of two.
      P5: >
        Alignments have an order from weaker to stronger or stricter
        alignments. Stricter alignments have larger alignment values. An
        address that satisfies an alignment requirement also satisfies any
        weaker valid alignment requirement.
      P6: >
        The alignment requirement of a complete type can be queried using an
        _Alignof expression. The types char, signed char, and unsigned char
        shall have the weakest alignment requirement.
      P7: >
        Comparing alignments is meaningful and provides the obvious results:
        — Two alignments are equal when their numeric values are equal.
        — Two alignments are different when their numeric values are not equal.
        — When an alignment is larger than another it represents a stricter alignment.
  3:
    title: Conversion
    P1: >
      Several operators convert operand values from one type to another
      automatically. This subclause specifies the result required from such an
      implicit conversion, as well as those that result from a cast operation
      (an explicit conversion). The list in 6.3.1.8 summarizes the conversions
      performed by most ordinary operators; it is supplemented as required by
      the discussion of each operator in 6.5.
    P2: >
      Unless explicitly stated otherwise, conversion of an operand value to a
      compatible type causes no change to the value or the representation.
    1:
      title: Arithmetic operands
      1:
        title: Boolean, characters, and integers
        P1: |
          Every integer type has an integer conversion rank defined as follows:
          — No two signed integer types shall have the same rank, even if they
          have the same representation.
          — The rank of a signed integer type shall be greater than the rank of
          any signed integer type with less precision.
          — The rank of long long int shall be greater than the rank of long
          int, which shall be greater than the rank of int, which shall be
          greater than the rank of short int, which shall be greater than the
          rank of signed char.
          — The rank of any unsigned integer type shall equal the rank of the
          corresponding signed integer type, if any.
          — The rank of any standard integer type shall be greater than the
          rank of any extended integer type with the same width.
          — The rank of char shall equal the rank of signed char and unsigned char.
          — The rank of _Bool shall be less than the rank of all other standard
          integer types.
          — The rank of any enumerated type shall equal the rank of the
          compatible integer type (see 6.7.2.2).
          — The rank of any extended signed integer type relative to another
          extended signed integer type with the same precision is
          implementation-defined, but still subject to the other rules for
          determining the integer conversion rank.
          — For all integer types T1, T2, and T3, if T1 has greater rank than
          T2 and T2 has greater rank than T3, then T1 has greater rank than T3.
        P2: |
          The following may be used in an expression wherever an int or
          unsigned int may be used:
          — An object or expression with an integer type (other than int or
          unsigned int) whose integer conversion rank is less than or equal to
          the rank of int and unsigned int.
          — A bit-field of type _Bool, int, signed int, or unsigned int.  If an
          int can represent all values of the original type (as restricted by
          the width, for a bit-field), the value is converted to an int;
          otherwise, it is converted to an unsigned int. These are called the
          integer promotions. <foot>The integer promotions are applied only: as
          part of the usual arithmetic conversions, to certain argument
          expressions, to the operands of the unary +, -, and ~ operators, and
          to both operands of the shift operators, as specified by their
          respective subclauses.</foot> All other types are unchanged by the
          integer promotions.
        P3: >
          The integer promotions preserve value including sign. As discussed
          earlier, whether a ‘‘plain’’ char is treated as signed is
          implementation-defined.
      2:
        title: Boolean type
        P1: >
          When any scalar value is converted to _Bool, the result is 0 if the
          value compares equal to 0; otherwise, the result is 1.
          <foot>NaNs do not compare equal to 0 and thus convert to 1.</foot>
      3:
        title: Signed and unsigned integers
        P1: >
          When a value with integer type is converted to another integer type
          other than _Bool, if the value can be represented by the new type, it
          is unchanged.
        P2: >
          Otherwise, if the new type is unsigned, the value is converted by
          repeatedly adding or subtracting one more than the maximum value that
          can be represented in the new type until the value is in the range of
          the new type.  <foot>The rules describe arithmetic on the
          mathematical value, not the value of a given type of
          expression.</foot>
        P3: >
          Otherwise, the new type is signed and the value cannot be represented
          in it; either the result is implementation-defined or an
          implementation-defined signal is raised.
      4:
        title: Real floating and integer
        P1: >
          When a finite value of real floating type is converted to an integer
          type other than _Bool, the fractional part is discarded (i.e., the
          value is truncated toward zero). If the value of the integral part
          cannot be represented by the integer type, the behavior is undefined.
          <foot>The remaindering operation performed when a value of integer
          type is converted to unsigned type need not be performed when a value
          of real floating type is converted to unsigned type. Thus, the range
          of portable real floating values is (−1, Utype_MAX+1).</foot>
        P2: >
          When a value of integer type is converted to a real floating type, if
          the value being converted can be represented exactly in the new type,
          it is unchanged. If the value being converted is in the range of
          values that can be represented but cannot be represented exactly, the
          result is either the nearest higher or nearest lower representable
          value, chosen in an implementation-defined manner. If the value being
          converted is outside the range of values that can be represented, the
          behavior is undefined. Results of some implicit conversions may be
          represented in greater range and precision than that required by the
          new type (see 6.3.1.8 and 6.8.6.4).
      5:
        title: Real floating types
        P1: >
          When a value of real floating type is converted to a real floating
          type, if the value being converted can be represented exactly in the
          new type, it is unchanged. If the value being converted is in the
          range of values that can be represented but cannot be represented
          exactly, the result is either the nearest higher or nearest lower
          representable value, chosen in an implementation-defined manner. If
          the value being converted is outside the range of values that can be
          represented, the behavior is undefined. Results of some implicit
          conversions may be represented in greater range and precision than
          that required by the new type (see 6.3.1.8 and 6.8.6.4).
      6:
        title: Complex types
        P1: >
          When a value of complex type is converted to another complex type,
          both the real and imaginary parts follow the conversion rules for the
          corresponding real types.
      7:
        title: Real and complex
        P1: >
          When a value of real type is converted to a complex type, the real
          part of the complex result value is determined by the rules of
          conversion to the corresponding real type and the imaginary part of
          the complex result value is a positive zero or an unsigned zero.
        P2: >
          When a value of complex type is converted to a real type, the
          imaginary part of the complex value is discarded and the value of the
          real part is converted according to the conversion rules for the
          corresponding real type.
      8:
        title: Usual arithmetic conversions
        P1: |
          Many operators that expect operands of arithmetic type cause
          conversions and yield result types in a similar way. The purpose is
          to determine a common real type for the operands and result. For the
          specified operands, each operand is converted, without change of type
          domain, to a type whose corresponding real type is the common real
          type. Unless explicitly stated otherwise, the common real type is
          also the corresponding real type of the result, whose type domain is
          the type domain of the operands if they are the same, and complex
          otherwise. This pattern is called the usual arithmetic conversions:
          First, if the corresponding real type of either operand is long
          double, the other operand is converted, without change of type
          domain, to a type whose corresponding real type is long double.
          Otherwise, if the corresponding real type of either operand is
          double, the other operand is converted, without change of type
          domain, to a type whose corresponding real type is double.
          Otherwise, if the corresponding real type of either operand is float,
          the other operand is converted, without change of type domain, to a
          type whose corresponding real type is float. <foot>For example,
          addition of a double _Complex and a float entails just the conversion
          of the float operand to double (and yields a double _Complex
          result).</foot>
          Otherwise, the integer promotions are performed on both operands.
          Then the following rules are applied to the promoted operands:
            If both operands have the same type, then no further conversion is
            needed.
            Otherwise, if both operands have signed integer types or both have
            unsigned integer types, the operand with the type of lesser integer
            conversion rank is converted to the type of the operand with
            greater rank.
            Otherwise, if the operand that has unsigned integer type has rank
            greater or equal to the rank of the type of the other operand, then
            the operand with signed integer type is converted to the type of
            the operand with unsigned integer type.
            Otherwise, if the type of the operand with signed integer type can
            represent all of the values of the type of the operand with
            unsigned integer type, then the operand with unsigned integer type
            is converted to the type of the operand with signed integer type.
            Otherwise, both operands are converted to the unsigned integer type
            corresponding to the type of the operand with signed integer type.
        P2: >
          The values of floating operands and of the results of floating
          expressions may be represented in greater range and precision than
          that required by the type; the types are not changed thereby.
          <foot>The cast and assignment operators are still required to remove
          extra range and precision.</foot>
    2:
      title: Other operands
      1:
        title: Lvalues, arrays, and function designators
        P1: >
          An lvalue is an expression (with an object type other than void) that
          potentially designates an object; <foot>The name ‘‘lvalue’’ comes
          originally from the assignment expression E1 = E2, in which the left
          operand E1 is required to be a (modifiable) lvalue. It is perhaps
          better considered as representing an object ‘‘locator value’’. What
          is sometimes called ‘‘rvalue’’ is in this International Standard
          described as the ‘‘value of an expression’’.  An obvious example of
          an lvalue is an identifier of an object. As a further example, if E
          is a unary expression that is a pointer to an object, *E is an lvalue
          that designates the object to which E points.</foot>) if an lvalue
          does not designate an object when it is evaluated, the behavior is
          undefined. When an object is said to have a particular type, the type
          is specified by the lvalue used to designate the object. A modifiable
          lvalue is an lvalue that does not have array type, does not have an
          incomplete type, does not have a constqualified type, and if it is a
          structure or union, does not have any member (including, recursively,
          any member or element of all contained aggregates or unions) with a
          constqualified type.
        P2: >
          Except when it is the operand of the sizeof operator, the unary &
          operator, the ++ operator, the -- operator, or the left operand of
          the . operator or an assignment operator, an lvalue that does not
          have array type is converted to the value stored in the designated
          object (and is no longer an lvalue); this is called lvalue
          conversion. If the lvalue has qualified type, the value has the
          unqualified version of the type of the lvalue; additionally, if the
          lvalue has atomic type, the value has the non-atomic version of the
          type of the lvalue; otherwise, the value has the type of the lvalue.
          If the lvalue has an incomplete type and does not have array type,
          the behavior is undefined. If the lvalue designates an object of
          automatic storage duration that could have been declared with the
          register storage class (never had its address taken), and that object
          is uninitialized (not declared with an initializer and no assignment
          to it has been performed prior to use), the behavior is undefined.
        P3: >
          Except when it is the operand of the sizeof operator, or the unary &
          operator, or is a string literal used to initialize an array, an
          expression that has type ‘‘array of type’’ is converted to an
          expression with type ‘‘pointer to type’’ that points to the initial
          element of the array object and is not an lvalue. If the array object
          has register storage class, the behavior is undefined.
        P4: >
          A function designator is an expression that has function type. Except
          when it is the operand of the sizeof operator,<foot>Because this
          conversion does not occur, the operand of the sizeof operator remains
          a function designator and violates the constraints in 6.5.3.4.</foot>
          or the unary & operator, a function designator with type ‘‘function
          returning type’’ is converted to an expression that has type
          ‘‘pointer to function returning type’’.
      2:
        title: void
        P1: >
          The (nonexistent) value of a void expression (an expression that has
          type void) shall not be used in any way, and implicit or explicit
          conversions (except to void) shall not be applied to such an
          expression. If an expression of any other type is evaluated as a void
          expression, its value or designator is discarded. (A void expression
          is evaluated for its side effects.)
      3:
        title: Pointers
        P1: >
          A pointer to void may be converted to or from a pointer to any object
          type. A pointer to any object type may be converted to a pointer to
          void and back again; the result shall compare equal to the original
          pointer.
        P2: >
          For any qualifier q, a pointer to a non-q-qualified type may be
          converted to a pointer to the q-qualified version of the type; the
          values stored in the original and converted pointers shall compare
          equal.
        P3: >
          An integer constant expression with the value 0, or such an
          expression cast to type void *, is called a null pointer constant.
          <foot>The macro NULL is defined in <stddef.h> (and other headers) as
          a null pointer constant; see 7.19.</foot> If a null pointer constant
          is converted to a pointer type, the resulting pointer, called a null
          pointer, is guaranteed to compare unequal to a pointer to any object
          or function.
        P4: >
          Conversion of a null pointer to another pointer type yields a null
          pointer of that type.  Any two null pointers shall compare equal.
        P5: >
          An integer may be converted to any pointer type. Except as previously
          specified, the result is implementation-defined, might not be
          correctly aligned, might not point to an entity of the referenced
          type, and might be a trap representation.<foot>The mapping functions
          for converting a pointer to an integer or an integer to a pointer are
          intended to be consistent with the addressing structure of the
          execution environment.</foot>
        P6: >
          Any pointer type may be converted to an integer type. Except as
          previously specified, the result is implementation-defined. If the
          result cannot be represented in the integer type, the behavior is
          undefined. The result need not be in the range of values of any
          integer type.
        P7: >
          A pointer to an object type may be converted to a pointer to a
          different object type. If the resulting pointer is not correctly
          aligned<foot>In general, the concept ‘‘correctly aligned’’ is
          transitive: if a pointer to type A is correctly aligned for a pointer
          to type B, which in turn is correctly aligned for a pointer to type C,
          then a pointer to type A is correctly aligned for a pointer to type
          C.</foot> for the referenced type, the behavior is undefined.
          Otherwise, when converted back again, the result shall compare equal to
          the original pointer. When a pointer to an object is converted to a
          pointer to a character type, the result points to the lowest addressed
          byte of the object. Successive increments of the result, up to the size
          of the object, yield pointers to the remaining bytes of the object.
        P8: >
          A pointer to a function of one type may be converted to a pointer to
          a function of another type and back again; the result shall compare
          equal to the original pointer. If a converted pointer is used to call
          a function whose type is not compatible with the referenced type, the
          behavior is undefined.
  4:
    title: Lexical elements
    P1: |
      Syntax
      token:
        keyword
        identifier
        constant
        string-literal
        punctuator
      preprocessing-token:
        header-name
        identifier
        pp-number
        character-constant
        string-literal
        punctuator
        each non-white-space character that cannot be one of the above
    P2: |
      Constraints
      Each preprocessing token that is converted to a token shall have the
      lexical form of a keyword, an identifier, a constant, a string literal,
      or a punctuator.
    P3: |
      Semantics
      A token is the minimal lexical element of the language in translation
      phases 7 and 8. The categories of tokens are: keywords, identifiers,
      constants, string literals, and punctuators.  A preprocessing token is the
      minimal lexical element of the language in translation phases 3 through 6.
      The categories of preprocessing tokens are: header names, identifiers,
      preprocessing numbers, character constants, string literals, punctuators,
      and single non-white-space characters that do not lexically match the other
      preprocessing token categories.<foot>An additional category, placemarkers,
      is used internally in translation phase 4 (see 6.10.3.3); it cannot occur
      in source files.</foot> If a \' or a \" character matches the last category,
      the behavior is undefined. Preprocessing tokens can be separated by white
      space; this consists of comments (described later), or white-space
      characters (space, horizontal tab, new-line, vertical tab, and form-feed),
      or both. As described in 6.10, in certain circumstances during translation
      phase 4, white space (or the absence thereof) serves as more than
      preprocessing token separation. White space may appear within a
      preprocessing token only as part of a header name or between the quotation
      characters in a character constant or string literal.
    P4: >
      If the input stream has been parsed into preprocessing tokens up to a
      given character, the next preprocessing token is the longest sequence of
      characters that could constitute a preprocessing token. There is one
      exception to this rule: header name preprocessing tokens are recognized
      only within #include preprocessing directives and in implementation-defined
      locations within #pragma directives. In such contexts, a sequence of
      characters that could be either a header name or a string literal is
      recognized as the former.
    P5: >
      EXAMPLE 1 The program fragment 1Ex is parsed as a preprocessing number
      token (one that is not a valid floating or integer constant token), even
      though a parse as the pair of preprocessing tokens 1 and Ex might produce
      a valid expression (for example, if Ex were a macro defined as +1).
      Similarly, the program fragment 1E1 is parsed as a preprocessing number
      (one that is a valid floating constant token), whether or not E is a
      macro name.
    P6: >
      EXAMPLE 2 The program fragment x+++++y is parsed as x ++ ++ + y, which
      violates a constraint on increment operators, even though the parse x ++
      + ++ y might yield a correct expression.
    1:
      title: Keywords
      P1: |
        Syntax
        keyword: one of
        auto
        break
        case
        char
        const
        continue
        default
        do
        double
        else
        enum
        extern
        float
        for
        goto
        if
        inline
        int
        long
        register
        restrict
        return
        short
        signed
        sizeof
        static
        struct
        switch
        typedef
        union
        unsigned
        void
        volatile
        while
        _Alignas
        _Alignof
        _Atomic
        _Bool
        _Complex
        _Generic
        _Imaginary
        _Noreturn
        _Static_assert
        _Thread_local
      P2: |
        Semantics
        The above tokens (case sensitive) are reserved (in translation phases 7
        and 8) for use as keywords, and shall not be used otherwise. The
        keyword _Imaginary is reserved for specifying imaginary types.
        <foot>One possible specification for imaginary types appears in annex
        G.</foot>
    2:
      title: Identifiers
      1:
        title: General
        P1: |
          Syntax
          identifier:
            identifier-nondigit
            identifier identifier-nondigit
            identifier digit
          identifier-nondigit:
            nondigit
            universal-character-name
            other implementation-defined characters
          nondigit: one of
            _ a b c d e f g h i j k l m
              n o p q r s t u v w x y z
              A B C D E F G H I J K L M
              N O P Q R S T U V W X Y Z
          digit: one of
            0 1 2 3 4 5 6 7 8 9
        P2: |
          Semantics
          An identifier is a sequence of nondigit characters (including the
          underscore _, the lowercase and uppercase Latin letters, and other
          characters) and digits, which designates one or more entities as
          described in 6.2.1. Lowercase and uppercase letters are distinct.
          There is no specific limit on the maximum length of an identifier.
        P3: >
          Each universal character name in an identifier shall designate a
          character whose encoding in ISO/IEC 10646 falls into one of the
          ranges specified in D.1.<foot>On systems in which linkers cannot
          accept extended characters, an encoding of the universal character
          name may be used in forming valid external identifiers. For example,
          some otherwise unused character or sequence of characters may be used
          to encode the \u in a universal character name.  Extended characters
          may produce a long external identifier.</foot> The initial character
          shall not be a universal character name designating a character whose
          encoding falls into one of the ranges specified in D.2. An
          implementation may allow multibyte characters that are not part of
          the basic source character set to appear in identifiers; which
          characters and their correspondence to universal character names is
          implementation-defined.
        P4: >
          When preprocessing tokens are converted to tokens during translation
          phase 7, if a preprocessing token could be converted to either a
          keyword or an identifier, it is converted to a keyword.
        P5: |
          Implementation limits
          As discussed in 5.2.4.1, an implementation may limit the number of
          significant initial characters in an identifier; the limit for an
          external name (an identifier that has external linkage) may be more
          restrictive than that for an internal name (a macro name or an
          identifier that does not have external linkage). The number of
          significant characters in an identifier is implementation-defined.
        P6: >
          Any identifiers that differ in a significant character are different
          identifiers. If two identifiers differ only in nonsignificant
          characters, the behavior is undefined.
      2:
        title: Predefined identifiers
        P1: |
          Semantics
          The identifier _ _func_ _ shall be implicitly declared by the
          translator as if, immediately following the opening brace of each
          function definition, the declaration
          <code>
          static const char _ _func_ _[] = "function-name";
          </code>
          appeared, where function-name is the name of the lexically-enclosing
          function. <foot>Since the name _ _func_ _ is reserved for any use by
          the implementation (7.1.3), if any other identifier is explicitly
          declared using the name _ _func_ _, the behavior is undefined.</foot>
        P2: >
          This name is encoded as if the implicit declaration had been written
          in the source character set and then translated into the execution
          character set as indicated in translation phase 5.
        P3: |
          EXAMPLE
          Consider the code fragment:
          <code>
          \#include <stdio.h>
          void myfunc(void)
          {
            printf("%s\n", _ _func_ _);
            /* ... */
          }
          </code>
          Each time the function is called, it will print to the standard
          output stream: myfunc
    3:
      title: Universal character names
      P1: |
        Syntax
        universal-character-name:
          \u hex-quad
          \U hex-quad hex-quad
        hex-quad:
          hexadecimal-digit hexadecimal-digit
          hexadecimal-digit hexadecimal-digit
      P2: |
        Constraints
        A universal character name shall not specify a character whose short
        identifier is less than 00A0 other than 0024 ($), 0040 (@), or 0060
        (‘), nor one in the range D800 through DFFF inclusive.<foot>The
        disallowed characters are the characters in the basic character set and
        the code positions reserved by ISO/IEC 10646 for control characters,
        the character DELETE, and the S-zone (reserved for use by
        UTF−16).</foot>
      P3: |
        Description
        Universal character names may be used in identifiers, character
        constants, and string literals to designate characters that are not in
        the basic character set.
      P4: |
        Semantics
        The universal character name \Unnnnnnnn designates the character whose
        eight-digit short identifier (as specified by ISO/IEC 10646) is
        nnnnnnnn.<foot>Short identifiers for characters were first specified in
        ISO/IEC 10646−1:1993/Amd.9:1997.</foot> Similarly, the universal
        character name \unnnn designates the character whose four-digit short
        identifier is nnnn (and whose eight-digit short identifier is
        0000nnnn).
    4:
      title: Constants
      P1: |
        Syntax
        constant:
          integer-constant
          floating-constant
          enumeration-constant
          character-constant
      P2: |
        Constraints
        Each constant shall have a type and the value of a constant shall be in
        the range of representable values for its type.
      P3: |
        Semantics
        Each constant has a type, determined by its form and value, as detailed
        later.
      1:
        title: Integer constants
        P1: |
          Syntax
          integer-constant:
            decimal-constant integer-suffixopt
            octal-constant integer-suffixopt
            hexadecimal-constant integer-suffixopt
          decimal-constant:
            nonzero-digit
            decimal-constant digit
          octal-constant:
            0
            octal-constant octal-digit
          hexadecimal-constant:
            hexadecimal-prefix hexadecimal-digit
            hexadecimal-constant hexadecimal-digit
          hexadecimal-prefix: one of
            0x 0X
          nonzero-digit: one of
            1 2 3 4 5 6 7 8 9
          octal-digit: one of
            0 1 2 3 4 5 6 7
          hexadecimal-digit: one of
            0 1 2 3 4 5 6 7 8 9
            a b c d e f
            A B C D E F
          integer-suffix:
            unsigned-suffix long-suffixopt
            unsigned-suffix long-long-suffix
            long-suffix unsigned-suffixopt
            long-long-suffix unsigned-suffixopt
          unsigned-suffix: one of
            u U
          long-suffix: one of
            l L
          long-long-suffix: one of
            ll LL
        P2: |
          Description
          An integer constant begins with a digit, but has no period or
          exponent part. It may have a prefix that specifies its base and a
          suffix that specifies its type.
        P3: |
          A decimal constant begins with a nonzero digit and consists of a
          sequence of decimal digits. An octal constant consists of the prefix
          0 optionally followed by a sequence of the digits 0 through 7 only. A
          hexadecimal constant consists of the prefix 0x or 0X followed by a
          sequence of the decimal digits and the letters a (or A) through f (or
          F) with values 10 through 15 respectively.
        P4: |
          Semantics
          The value of a decimal constant is computed base 10; that of an octal
          constant, base 8; that of a hexadecimal constant, base 16. The
          lexically first digit is the most significant.
        P5: |
          The type of an integer constant is the first of the corresponding
          list in which its value can be represented.
          <table>
          <tr>
            <th>Decimal Constant</th>
            <th>Octal or Hexadecimal</th>
            <th>Constant</th>
          </tr>
          <tr>
            <th>none</th>
            <th>
              int
              long int
              long long int
            <th>
              int
              unsigned int
              long int
              unsigned long int
              long long int
              unsigned long long int
            </th>
          </tr>
          <tr>
            <th>u or U</th>
              unsigned int
              unsigned long int
              unsigned long long int
            </th>
            <th>
              unsigned int
              unsigned long int
              unsigned long long int
            </th>
          </tr>
          <tr>
            <th>l or L</th>
            <th>
              long int
              long long int
            </th>
            <th>
              long int
              unsigned long int
              long long int
              unsigned long long int
            </th>
          </tr>
          <tr>
            <th>
              Both u or U
              and l or L
            </th>
            <th>
              unsigned long int
              unsigned long long int
            </th>
            <th>
              unsigned long int
              unsigned long long int
            </th>
          </tr>
          <tr>
            <th>ll or LL</th>
            <th>
              long long int
            </th>
            <th>
              long long int
              unsigned long long int
            </th>
          </tr>
          <tr>
            <th>
              Both u or U
              and ll or LL
            </th>
            <th>
              unsigned long long int
            </th>
            <th>
              unsigned long long int
            </th>
          </tr>
          </table>
        P6: >
          If an integer constant cannot be represented by any type in its list,
          it may have an extended integer type, if the extended integer type
          can represent its value. If all of the types in the list for the
          constant are signed, the extended integer type shall be signed. If
          all of the types in the list for the constant are unsigned, the
          extended integer type shall be unsigned. If the list contains both
          signed and unsigned types, the extended integer type may be signed or
          unsigned. If an integer constant cannot be represented by any type in
          its list and has no extended integer type, then the integer constant
          has no type.
      2:
        title: Floating constants
        P1: |
          Syntax
          floating-constant:
            decimal-floating-constant
            hexadecimal-floating-constant
          decimal-floating-constant:
            fractional-constant exponent-partopt floating-suffixopt
            digit-sequence exponent-part floating-suffixopt
          hexadecimal-floating-constant:
            hexadecimal-prefix hexadecimal-fractional-constant
              binary-exponent-part floating-suffixopt
            hexadecimal-prefix hexadecimal-digit-sequence
              binary-exponent-part floating-suffixopt
          fractional-constant:
            digit-sequenceopt . digit-sequence
            digit-sequence .
          exponent-part:
            e signopt digit-sequence
            E signopt digit-sequence
          sign: one of
            + -
          digit-sequence:
            digit
            digit-sequence digit
          hexadecimal-fractional-constant:
            hexadecimal-digit-sequenceopt .
              hexadecimal-digit-sequence
            hexadecimal-digit-sequence .
          binary-exponent-part:
            p signopt digit-sequence
            P signopt digit-sequence
          hexadecimal-digit-sequence:
            hexadecimal-digit
            hexadecimal-digit-sequence hexadecimal-digit
          floating-suffix: one of
            f l F L
        P2: |
          Description
          A floating constant has a significand part that may be followed by an
          exponent part and a suffix that specifies its type. The components of
          the significand part may include a digit sequence representing the
          whole-number part, followed by a period (.), followed by a digit
          sequence representing the fraction part. The components of the
          exponent part are an e, E, p, or P followed by an exponent consisting
          of an optionally signed digit sequence.  Either the whole-number part
          or the fraction part has to be present; for decimal floating
          constants, either the period or the exponent part has to be present.
        P3: |
          Semantics
          The significand part is interpreted as a (decimal or hexadecimal)
          rational number; the digit sequence in the exponent part is
          interpreted as a decimal integer. For decimal floating constants, the
          exponent indicates the power of 10 by which the significand part is
          to be scaled. For hexadecimal floating constants, the exponent
          indicates the power of 2 by which the significand part is to be
          scaled. For decimal floating constants, and also for hexadecimal
          floating constants when FLT_RADIX is not a power of 2, the result is
          either the nearest representable value, or the larger or smaller
          representable value immediately adjacent to the nearest representable
          value, chosen in an implementation-defined manner.  For hexadecimal
          floating constants when FLT_RADIX is a power of 2, the result is
          correctly rounded.
        P4: >
          An unsuffixed floating constant has type double. If suffixed by the
          letter f or F, it has type float. If suffixed by the letter l or L,
          it has type long double.
        P5: >
          Floating constants are converted to internal format as if at
          translation-time. The conversion of a floating constant shall not
          raise an exceptional condition or a floatingpoint exception at
          execution time. All floating constants of the same source
          form<foot>1.23, 1.230, 123e-2, 123e-02, and 1.23L are all different
          source forms and thus need not convert to the same internal format
          and value.  </foot> shall convert to the same internal format with
          the same value.
        P6: |
          Recommended practice
          The implementation should produce a diagnostic message if a
          hexadecimal constant cannot be represented exactly in its evaluation
          format; the implementation should then proceed with the translation
          of the program.
        P7: >
          The translation-time conversion of floating constants should match
          the execution-time conversion of character strings by library
          functions, such as strtod, given matching inputs suitable for both
          conversions, the same result format, and default execution-time
          rounding.<foot>The specification for the library functions recommends
          more accurate conversion than required for floating constants (see
          7.22.1.3).  </foot>
      3:
        title: Enumeration constants
        P1: |
          Syntax
          enumeration-constant:
            identifier
        P2: |
          Semantics
          An identifier declared as an enumeration constant has type int.
      4:
        title: Character constants
        P1: |
          Syntax
          character-constant:
            ' c-char-sequence '
            L' c-char-sequence '
            u' c-char-sequence '
            U' c-char-sequence '
          c-char-sequence:
            c-char
            c-char-sequence c-char
          c-char:
            any member of the source character set except
              the single-quote ', backslash \, or new-line character
            escape-sequence
          escape-sequence:
            simple-escape-sequence
            octal-escape-sequence
            hexadecimal-escape-sequence
            universal-character-name
          simple-escape-sequence: one of
            \' \" \? \\
            \a \b \f \n \r \t \v
          octal-escape-sequence:
            \ octal-digit
            \ octal-digit octal-digit
            \ octal-digit octal-digit octal-digit
          hexadecimal-escape-sequence:
            \x hexadecimal-digit
            hexadecimal-escape-sequence hexadecimal-digit
        P2: |
          Description
          An integer character constant is a sequence of one or more multibyte
          characters enclosed in single-quotes, as in 'x'. A wide character
          constant is the same, except prefixed by the letter L, u, or U. With
          a few exceptions detailed later, the elements of the sequence are any
          members of the source character set; they are mapped in an
          implementation-defined manner to members of the execution character
          set.
        P3: |
          The single-quote \', the double-quote ", the question-mark ?, the
          backslash \, and arbitrary integer values are representable according
          to the following table of escape sequences:
          single quote '            \'
          double quote "            \"
          question mark ?           \?
          backslash \               \\
          octal character           \octal digits
          hexadecimal character     \x hexadecimal digits
        P4: >
          The double-quote \" and question-mark ? are representable either by
          themselves or by the escape sequences \" and \?, respectively, but
          the single-quote ' and the backslash \ shall be represented,
          respectively, by the escape sequences \' and \\.
        P5: >
          The octal digits that follow the backslash in an octal escape
          sequence are taken to be part of the construction of a single
          character for an integer character constant or of a single wide
          character for a wide character constant. The numerical value of the
          octal integer so formed specifies the value of the desired character
          or wide character.
        P6: >
          The hexadecimal digits that follow the backslash and the letter x in
          a hexadecimal escape sequence are taken to be part of the
          construction of a single character for an integer character constant
          or of a single wide character for a wide character constant. The
          numerical value of the hexadecimal integer so formed specifies the
          value of the desired character or wide character.
        P7: >
          Each octal or hexadecimal escape sequence is the longest sequence of
          characters that can constitute the escape sequence.
        P8: >
          In addition, characters not in the basic character set are
          representable by universal character names and certain nongraphic
          characters are representable by escape sequences consisting of the
          backslash \ followed by a lowercase letter: \a, \b, \f, \n, \r, \t, and
          \v.<foot>The semantics of these characters were discussed in 5.2.2.
          If any other character follows a backslash, the result is not a token
          and a diagnostic is required. See ‘‘future language directions’’
          (6.11.4).</foot>
        P9: |
          Constraints
          The value of an octal or hexadecimal escape sequence shall be in the
          range of representable values for the corresponding type:
          <table>
          <tr>
            <th>Prefix</th>
            <th>Corresponding Type</th>
          </tr>
            <th>none</th>
            <th>unsigned char</th>
          <tr>
            <th>L</th>
            <th>the unsigned type corresponding to wchar_t</th>
          </tr>
          <tr>
            <th>u</th>
            <th>char16_t</th>
          </tr>
          <tr>
            <th>U</th>
            <th>char32_t</th>
          </tr>
          </table>
        P10: |
          Semantics
          An integer character constant has type int. The value of an integer
          character constant containing a single character that maps to a
          single-byte execution character is the numerical value of the
          representation of the mapped character interpreted as an integer.
          The value of an integer character constant containing more than one
          character (e.g., 'ab'), or containing a character or escape sequence
          that does not map to a single-byte execution character, is
          implementation-defined. If an integer character constant contains a
          single character or escape sequence, its value is the one that
          results when an object with type char whose value is that of the
          single character or escape sequence is converted to type int.
        P11: >
          A wide character constant prefixed by the letter L has type wchar_t,
          an integer type defined in the <stddef.h> header; a wide character
          constant prefixed by the letter u or U has type char16_t or char32_t,
          respectively, unsigned integer types defined in the <uchar.h> header.
          The value of a wide character constant containing a single multibyte
          character that maps to a single member of the extended execution
          character set is the wide character corresponding to that multibyte
          character, as defined by the mbtowc, mbrtoc16, or mbrtoc32 function
          as appropriate for its type, with an implementation-defined current
          locale. The value of a wide character constant containing more than
          one multibyte character or a single multibyte character that maps to
          multiple members of the extended execution character set, or
          containing a multibyte character or escape sequence not represented
          in the extended execution character set, is implementation-defined.
        P12: >
          EXAMPLE 1
          The construction '\0' is commonly used to represent the null
          character.
        P13: >
          EXAMPLE 2 Consider implementations that use two’s complement
          representation for integers and eight bits for objects that have type
          char. In an implementation in which type char has the same range of
          values as signed char, the integer character constant '\xFF' has the
          value −1; if type char has the same range of values as unsigned char,
          the character constant '\xFF' has the value +255.
        P14: >
          EXAMPLE 3 Even if eight bits are used for objects that have type
          char, the construction '\x123' specifies an integer character
          constant containing only one character, since a hexadecimal escape
          sequence is terminated only by a non-hexadecimal character. To
          specify an integer character constant containing the two characters
          whose values are '\x12' and '3', the construction '\0223' may be
          used, since an octal escape sequence is terminated after three octal
          digits. (The value of this two-character integer character constant
          is implementation-defined.)
        P15: >
          EXAMPLE 4 Even if 12 or more bits are used for objects that have type
          wchar_t, the construction L'\1234' specifies the
          implementation-defined value that results from the combination of the
          values 0123 and '4'.
    5:
      title: String literals
      P1: |
        Syntax
        string-literal:
          encoding-prefixopt " s-char-sequenceopt "
        encoding-prefix:
          u8
          u
          U
          L
        s-char-sequence:
          s-char
          s-char-sequence s-char
        s-char:
          any member of the source character set except
            the double-quote \", backslash \, or new-line character
          escape-sequence
      P2: |
        Constraints
        A sequence of adjacent string literal tokens shall not include both a
        wide string literal and a UTF−8 string literal.
      P3: |
        Description
        A character string literal is a sequence of zero or more multibyte
        characters enclosed in double-quotes, as in "xyz". A UTF−8 string
        literal is the same, except prefixed by u8.  A wide string literal is
        the same, except prefixed by the letter L, u, or U.
      P4: |
        The same considerations apply to each element of the sequence in a
        string literal as if it were in an integer character constant (for a
        character or UTF−8 string literal) or a wide character constant (for a
        wide string literal), except that the single-quote \' is representable
        either by itself or by the escape sequence \', but the double-quote \"
        shall be represented by the escape sequence \".
      P5: |
        Semantics
        In translation phase 6, the multibyte character sequences specified by
        any sequence of adjacent character and identically-prefixed string
        literal tokens are concatenated into a single multibyte character
        sequence. If any of the tokens has an encoding prefix, the resulting
        multibyte character sequence is treated as having the same prefix;
        otherwise, it is treated as a character string literal. Whether
        differently-prefixed wide string literal tokens can be concatenated
        and, if so, the treatment of the resulting multibyte character sequence
        are implementation-defined.
      P6: |
        In translation phase 7, a byte or code of value zero is appended to
        each multibyte character sequence that results from a string literal or
        literals.<foot>A string literal need not be a string (see 7.1.1),
        because a null character may be embedded in it by a \0 escape
        sequence.</foot> The multibyte character sequence is then used to
        initialize an array of static storage duration and length just
        sufficient to contain the sequence. For character string literals, the
        array elements have type char, and are initialized with the individual
        bytes of the multibyte character sequence. For UTF−8 string literals,
        the array elements have type char, and are initialized with the
        characters of the multibyte character sequence, as encoded in UTF−8.
        For wide string literals prefixed by the letter L, the array elements
        have type wchar_t and are initialized with the sequence of wide
        characters corresponding to the multibyte character sequence, as
        defined by the mbstowcs function with an implementationdefined current
        locale. For wide string literals prefixed by the letter u or U, the
        array elements have type char16_t or char32_t, respectively, and are
        initialized with the sequence of wide characters corresponding to the
        multibyte character sequence, as defined by successive calls to the
        mbrtoc16, or mbrtoc32 function as appropriate for its type, with an
        implementation-defined current locale. The value of a string literal
        containing a multibyte character or escape sequence not represented in
        the execution character set is implementation-defined.
      P7: |
        It is unspecified whether these arrays are distinct provided their
        elements have the appropriate values. If the program attempts to modify
        such an array, the behavior is undefined.
      P8: |
        EXAMPLE 1
        This pair of adjacent character string literals
        "\x12" "3" produces a single character string literal containing the
        two characters whose values are '\x12' and '3', because escape
        sequences are converted into single members of the execution character
        set just prior to adjacent string literal concatenation.
      P9: |
        EXAMPLE 2
        Each of the sequences of adjacent string literal tokens
          "a" "b" L"c"
          "a" L"b" "c"
          L"a" "b" L"c"
          L"a" L"b" L"c"
        is equivalent to the string literal
          L"abc"
        Likewise, each of the sequences
          "a" "b" u"c"
          "a" u"b" "c"
          u"a" "b" u"c"
          u"a" u"b" u"c"
        is equivalent to
          u"abc"
    6:
      title: Punctuators
      P1: |
        Syntax
        punctuator: one of
          [ ] ( ) { } . ->
          ++ -- & * + - ~ !
          / % << >> < > <= >= == != ^ | && ||
          ? : ; ...
          = *= /= %= += -= <<= >>= &= ^= |=
          , \# \#\#
          <: :> <% %> %: %:%:
      P2: |
        Semantics
        A punctuator is a symbol that has independent syntactic and semantic
        significance.  Depending on context, it may specify an operation to be
        performed (which in turn may yield a value or a function designator,
        produce a side effect, or some combination thereof) in which case it is
        known as an operator (other forms of operator also exist in some
        contexts). An operand is an entity on which an operator acts.
      P3: |
        In all aspects of the language, the six tokens
        <foot>These tokens are sometimes called ‘‘digraphs’’.</foot>
          <: :>  <% %> %: %:%:
        behave, respectively, the same as the six tokens
        [ ] { } \# \#\#
        except for their spelling.<foot>Thus [ and <: behave differently when
        ‘‘stringized’’ (see 6.10.3.2), but can otherwise be freely
        interchanged.</foot>
    7:
      title: Header names
      P1: |
        Syntax
        header-name:
          < h-char-sequence >
          " q-char-sequence "
        h-char-sequence:
          h-char
          h-char-sequence h-char
        h-char:
          any member of the source character set except
          the new-line character and >
        q-char-sequence:
          q-char
          q-char-sequence q-char
        q-char:
          any member of the source character set except
          the new-line character and \"
      P2: |
        Semantics
        The sequences in both forms of header names are mapped in an
        implementation-defined manner to headers or external source file names
        as specified in 6.10.2.
      P3: >
        If the characters \', \, \", //, or /* occur in the sequence between the
        < and > delimiters, the behavior is undefined. Similarly, if the
        characters \', \, //, or /* occur in the sequence between the \"
        delimiters, the behavior is undefined.<foot>Thus, sequences of
        characters that resemble escape sequences cause undefined
        behavior.</foot> Header name preprocessing tokens are recognized only
        within \#include preprocessing directives and in implementation-defined
        locations within \#pragma directives.<foot>For an example of a header
        name preprocessing token used in a \#pragma directive, see
        6.10.9.</foot>
      P4: |
        EXAMPLE
        The following sequence of characters:
        <code>
          0x3<1/a.h>1e2
          \#include <1/a.h>
          \#define const.member@$
        </code>
        forms the following sequence of preprocessing tokens (with each
        individual preprocessing token delimited by a { on the left and a } on
        the right).
        <code>
          {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}
          {#}{include} {<1/a.h>}
          {#}{define} {const}{.}{member}{@}{$}
        </code>
    8:
      title: Preprocessing numbers
      P1: |
        Syntax
        pp-number:
          digit
          . digit
          pp-number digit
          pp-number identifier-nondigit
          pp-number e sign
          pp-number E sign
          pp-number p sign
          pp-number P sign
          pp-number .
      P2: |
        Description
        A preprocessing number begins with a digit optionally preceded by a
        period (.) and may be followed by valid identifier characters and the
        character sequences e+, e-, E+, E-, p+, p-, P+, or P-.
      P3: |
        Preprocessing number tokens lexically include all floating and integer
        constant tokens.
      P4: |
        Semantics
        A preprocessing number does not have type or a value; it acquires both
        after a successful conversion (as part of translation phase 7) to a
        floating constant token or an integer constant token.
    9:
      title: Comments
      P1: >
        Except within a character constant, a string literal, or a comment, the
        characters /* introduce a comment. The contents of such a comment are
        examined only to identify multibyte characters and to find the
        characters */ that terminate it.
        <foot>Thus, /* ... */ comments do not nest.</foot>
      P2: >
        Except within a character constant, a string literal, or a comment, the
        characters // introduce a comment that includes all multibyte
        characters up to, but not including, the next new-line character. The
        contents of such a comment are examined only to identify multibyte
        characters and to find the terminating new-line character.
      P3: |
        EXAMPLE
        <code>
        "a//b"                      // four-character string literal
        \#include "//e"             // undefined behavior
        // */                       // comment, not syntax error
        f = g/**//h;                // equivalent to f = g / h;
        //\
        i();                        // part of a two-line comment
        /\
        / j();                      // part of a two-line comment
        \#define glue(x,y) x##y
        glue(/,/) k();              // syntax error, not comment
        /*//*/ l();                 // equivalent to l();
        m = n//**/o
        + p;                        // equivalent to m = n + p;
        </code>
  5:
    title: Expressions
    P1: >
      An expression is a sequence of operators and operands that specifies
      computation of a value, or that designates an object or a function, or
      that generates side effects, or that performs a combination thereof. The
      value computations of the operands of an operator are sequenced before
      the value computation of the result of the operator.
    P2: >
      If a side effect on a scalar object is unsequenced relative to either a
      different side effect on the same scalar object or a value computation
      using the value of the same scalar object, the behavior is undefined. If
      there are multiple allowable orderings of the subexpressions of an
      expression, the behavior is undefined if such an unsequenced side effect
      occurs in any of the orderings.
      <foot>This paragraph renders undefined statement expressions such as
      <code>
        i = ++i + 1;
        a[i++] = i;
      </code>
      while allowing
      <code>
        i = i + 1;
        a[i] = i;
      </code>
      </foot>
    P3: >
      The grouping of operators and operands is indicated by the syntax.
      <foot>The syntax specifies the precedence of operators in the evaluation
      of an expression, which is the same as the order of the major subclauses
      of this subclause, highest precedence first. Thus, for example, the
      expressions allowed as the operands of the binary + operator (6.5.6) are
      those expressions defined in 6.5.1 through 6.5.6. The exceptions are cast
      expressions (6.5.4) as operands of unary operators (6.5.3), and an
      operand contained between any of the following pairs of operators: grouping
      parentheses () (6.5.1), subscripting brackets [] (6.5.2.1), function-call
      parentheses () (6.5.2.2), and the conditional operator ? : (6.5.15).
      Within each major subclause, the operators have the same precedence. Left-
      or right-associativity is indicated in each subclause by the syntax for the
      expressions discussed therein.</foot> Except as specified later, side
      effects and value computations of subexpressions are unsequenced.<foot>In
      an expression that is evaluated more than once during the execution of a
      program, unsequenced and indeterminately sequenced evaluations of its
      subexpressions need not be performed consistently in different
      evaluations.</foot>
    P4: >
      Some operators (the unary operator ~, and the binary operators <<, >>, &,
      ^, and |, collectively described as bitwise operators) are required to
      have operands that have integer type. These operators yield values that
      depend on the internal representations of integers, and have
      implementation-defined and undefined aspects for signed types.
    P5: >
      If an exceptional condition occurs during the evaluation of an expression
      (that is, if the result is not mathematically defined or not in the range
      of representable values for its type), the behavior is undefined.
    P6: >
      The effective type of an object for an access to its stored value is the
      declared type of the object, if any.<foot>Allocated objects have no
      declared type.</foot> If a value is stored into an object having no
      declared type through an lvalue having a type that is not a character
      type, then the type of the lvalue becomes the effective type of the
      object for that access and for subsequent accesses that do not modify the
      stored value. If a value is copied into an object having no declared type
      using memcpy or memmove, or is copied as an array of character type, then
      the effective type of the modified object for that access and for
      subsequent accesses that do not modify the value is the effective type of
      the object from which the value is copied, if it has one. For all other
      accesses to an object having no declared type, the effective type of the
      object is simply the type of the lvalue used for the access.
    P7: |
      An object shall have its stored value accessed only by an lvalue
      expression that has one of the following types:<foot>The intent of this
      list is to specify those circumstances in which an object may or may not
      be aliased.</foot>
      — a type compatible with the effective type of the object,
      — a qualified version of a type compatible with the effective type of the
      object,
      — a type that is the signed or unsigned type corresponding to the
      effective type of the object,
      — a type that is the signed or unsigned type corresponding to a qualified
      version of the effective type of the object,
      — an aggregate or union type that includes one of the aforementioned
      types among its members (including, recursively, a member of a
      subaggregate or contained union), or
      — a character type.
    P8: >
      A floating expression may be contracted, that is, evaluated as though it
      were a single operation, thereby omitting rounding errors implied by the
      source code and the expression evaluation method.<foot>The intermediate
      operations in the contracted expression are evaluated as if to infinite
      range and precision, while the final operation is rounded to the format
      determined by the expression evaluation method. A contracted expression
      might also omit the raising of floating-point exceptions.</foot> The
      FP_CONTRACT pragma in <math.h> provides a way to disallow contracted
      expressions. Otherwise, whether and how expressions are contracted is
      implementation-defined.<foot>This license is specifically intended to
      allow implementations to exploit fast machine instructions that combine
      multiple C operators. As contractions potentially undermine
      predictability, and can even decrease accuracy for containing
      expressions, their use needs to be well-defined and clearly
      documented.</foot>
    1:
      title: Primary expressions
      P1: |
        Syntax
        primary-expression:
          identifier
          constant
          string-literal
          ( expression )
          generic-selection
          Semantics
      P2: >
        An identifier is a primary expression, provided it has been declared as
        designating an object (in which case it is an lvalue) or a function (in
        which case it is a function designator).<foot>Thus, an undeclared
        identifier is a violation of the syntax.</foot>
      P3: >
        A constant is a primary expression. Its type depends on its form and
        value, as detailed in 6.4.4.
      P4: >
        A string literal is a primary expression. It is an lvalue with type as
        detailed in 6.4.5.
      P5: >
        A parenthesized expression is a primary expression. Its type and value
        are identical to those of the unparenthesized expression. It is an
        lvalue, a function designator, or a void expression if the
        unparenthesized expression is, respectively, an lvalue, a function
        designator, or a void expression.
      P6: >
        A generic selection is a primary expression. Its type and value depend
        on the selected generic association, as detailed in the following
        subclause.
      1:
        title: Generic selection
        P1: |
          Syntax
          generic-selection:
            _Generic ( assignment-expression , generic-assoc-list )
          generic-assoc-list:
            generic-association
            generic-assoc-list , generic-association
          generic-association:
            type-name : assignment-expression
            default : assignment-expression
        P2: |
          Constraints
          A generic selection shall have no more than one default generic
          association. The type name in a generic association shall specify a
          complete object type other than a variably modified type. No two
          generic associations in the same generic selection shall specify
          compatible types. The controlling expression of a generic selection
          shall have type compatible with at most one of the types named in its
          generic association list. If a generic selection has no default
          generic association, its controlling expression shall have type
          compatible with exactly one of the types named in its generic
          association list.
        P3: |
          Semantics
          The controlling expression of a generic selection is not evaluated.
          If a generic selection has a generic association with a type name
          that is compatible with the type of the controlling expression, then
          the result expression of the generic selection is the expression in
          that generic association. Otherwise, the result expression of the
          generic selection is the expression in the default generic
          association. None of the expressions from any other generic
          association of the generic selection is evaluated.
        P4: >
          The type and value of a generic selection are identical to those of
          its result expression. It is an lvalue, a function designator, or a
          void expression if its result expression is, respectively, an lvalue,
          a function designator, or a void expression.
        P5: |
          EXAMPLE
          The cbrt type-generic macro could be implemented as follows:
          <code>
          \#define cbrt(X) _Generic((X), \
                      long double: cbrtl, \
                      default: cbrt, \
                      float: cbrtf \
                      )(X)
          </code>
    2:
      title: Postfix operators
      P1: |
        Syntax
        postfix-expression:
          primary-expression
          postfix-expression [ expression ]
          postfix-expression ( argument-expression-listopt )
          postfix-expression . identifier
          postfix-expression -> identifier
          postfix-expression ++
          postfix-expression -( type-name ) { initializer-list }
          ( type-name ) { initializer-list , }
        argument-expression-list:
          assignment-expression
          argument-expression-list , assignment-expression
      1:
        title: Array subscripting
        P1: |
          Constraints
          One of the expressions shall have type ‘‘pointer to complete object
          type’’, the other expression shall have integer type, and the result
          has type ‘‘type’’.
        P2: |
          Semantics
          A postfix expression followed by an expression in square brackets []
          is a subscripted designation of an element of an array object. The
          definition of the subscript operator [] is that E1[E2] is identical
          to (*((E1)+(E2))). Because of the conversion rules that apply to the
          binary + operator, if E1 is an array object (equivalently, a pointer
          to the initial element of an array object) and E2 is an integer,
          E1[E2] designates the E2-th element of E1 (counting from zero).
        P3: >
          Successive subscript operators designate an element of a
          multidimensional array object.  If E is an n-dimensional array (n ≥
          2) with dimensions i × j × . . . × k, then E (used as other than an
          lvalue) is converted to a pointer to an (n − 1)-dimensional array
          with dimensions j × . . . × k. If the unary * operator is applied to
          this pointer explicitly, or implicitly as a result of subscripting,
          the result is the referenced (n − 1)-dimensional array, which itself
          is converted into a pointer if used as other than an lvalue. It
          follows from this that arrays are stored in row-major order (last
          subscript varies fastest).
        P4: |
          EXAMPLE
          Consider the array object defined by the declaration
          <code>
            int x[3][5];
          </code>
          Here x is a 3 × 5 array of ints; more precisely, x is an array of
          three element objects, each of which is an array of five ints. In the
          expression x[i], which is equivalent to (*((x)+(i))), x is first
          converted to a pointer to the initial array of five ints. Then i is
          adjusted according to the type of x, which conceptually entails
          multiplying i by the size of the object to which the pointer points,
          namely an array of five int objects. The results are added and
          indirection is applied to yield an array of five ints. When used in
          the expression x[i][j], that array is in turn converted to a pointer
          to the first of the ints, so x[i][j] yields an int.
      2:
        title: Function calls
        P1: |
          Constraints
          The expression that denotes the called function<foot>Most often, this
          is the result of converting an identifier that is a function
          designator.</foot> shall have type pointer to function returning void
          or returning a complete object type other than an array type.
        P2: >
          If the expression that denotes the called function has a type that
          includes a prototype, the number of arguments shall agree with the
          number of parameters. Each argument shall have a type such that its
          value may be assigned to an object with the unqualified version of
          the type of its corresponding parameter.
        P3: |
          Semantics
          A postfix expression followed by parentheses () containing a possibly
          empty, commaseparated list of expressions is a function call. The
          postfix expression denotes the called function. The list of
          expressions specifies the arguments to the function.
        P4: >
          An argument may be an expression of any complete object type. In
          preparing for the call to a function, the arguments are evaluated,
          and each parameter is assigned the value of the corresponding
          argument.<foot>A function may change the values of its parameters,
          but these changes cannot affect the values of the arguments. On the
          other hand, it is possible to pass a pointer to an object, and the
          function may change the value of the object pointed to. A parameter
          declared to have array or function type is adjusted to have a pointer
          type as described in 6.9.1.</foot>
        P5: >
          If the expression that denotes the called function has type pointer
          to function returning an object type, the function call expression
          has the same type as that object type, and has the value determined
          as specified in 6.8.6.4. Otherwise, the function call has type void.
        P6: |
          If the expression that denotes the called function has a type that
          does not include a prototype, the integer promotions are performed on
          each argument, and arguments that have type float are promoted to
          double. These are called the default argument promotions. If the
          number of arguments does not equal the number of parameters, the
          behavior is undefined. If the function is defined with a type that
          includes a prototype, and either the prototype ends with an ellipsis
          (, ...) or the types of the arguments after promotion are not
          compatible with the types of the parameters, the behavior is
          undefined.  If the function is defined with a type that does not
          include a prototype, and the types of the arguments after promotion
          are not compatible with those of the parameters after promotion, the
          behavior is undefined, except for the following cases:
          — one promoted type is a signed integer type, the other promoted type
          is the corresponding unsigned integer type, and the value is
          representable in both types;
          — both types are pointers to qualified or unqualified versions of a
          character type or void.
        P7: >
          If the expression that denotes the called function has a type that
          does include a prototype, the arguments are implicitly converted, as
          if by assignment, to the types of the corresponding parameters,
          taking the type of each parameter to be the unqualified version of
          its declared type. The ellipsis notation in a function prototype
          declarator causes argument type conversion to stop after the last
          declared parameter. The default argument promotions are performed on
          trailing arguments.
        P8: >
          No other conversions are performed implicitly; in particular, the
          number and types of arguments are not compared with those of the
          parameters in a function definition that does not include a function
          prototype declarator.
        P9: >
          If the function is defined with a type that is not compatible with
          the type (of the expression) pointed to by the expression that
          denotes the called function, the behavior is undefined.
        P10: >
          There is a sequence point after the evaluations of the function
          designator and the actual arguments but before the actual call. Every
          evaluation in the calling function (including other function calls)
          that is not otherwise specifically sequenced before or after the
          execution of the body of the called function is indeterminately
          sequenced with respect to the execution of the called function.
          <foot>In other words, function executions do not ‘‘interleave’’ with
          each other.</foot>
        P11: >
          Recursive function calls shall be permitted, both directly and
          indirectly through any chain of other functions.
        P12: |
          EXAMPLE
          In the function call
          <code>
            (*pf[f1()]) (f2(), f3() + f4())
          </code>
          the functions f1, f2, f3, and f4 may be called in any order. All side
          effects have to be completed before the function pointed to by
          pf[f1()] is called.
      3:
        title: Structure and union members
        P1: |
          Constraints
          The first operand of the . operator shall have an atomic, qualified,
          or unqualified structure or union type, and the second operand shall
          name a member of that type.
        P2: >
          The first operand of the -> operator shall have type ‘‘pointer to
          atomic, qualified, or unqualified structure’’ or ‘‘pointer to atomic,
          qualified, or unqualified union’’, and the second operand shall name
          a member of the type pointed to.
        P3: |
          Semantics
          A postfix expression followed by the . operator and an identifier
          designates a member of a structure or union object. The value is that
          of the named member,<foot>If the member used to read the contents of
          a union object is not the same as the member last used to store a
          value in the object, the appropriate part of the object
          representation of the value is reinterpreted as an object
          representation in the new type as described in 6.2.6 (a process
          sometimes called ‘‘type punning’’). This might be a trap
          representation.</foot> and is an lvalue if the first expression is an
          lvalue. If the first expression has qualified type, the result has
          the so-qualified version of the type of the designated member.
        P4: >
          A postfix expression followed by the -> operator and an identifier
          designates a member of a structure or union object. The value is that
          of the named member of the object to which the first expression
          points, and is an lvalue.<foot>If &E is a valid pointer expression
          (where & is the ‘‘address-of ’’ operator, which generates a pointer
          to its operand), the expression (&E)->MOS is the same as
          E.MOS.</foot> If the first expression is a pointer to a qualified
          type, the result has the so-qualified version of the type of the
          designated member.
        P5: >
          Accessing a member of an atomic structure or union object results in
          undefined behavior.<foot>For example, a data race would occur if
          access to the entire structure or union in one thread conflicts with
          access to a member from another thread, where at least one access is
          a modification. Members can be safely accessed using a non-atomic
          object which is assigned to or from the atomic object.</foot>
        P6: >
          One special guarantee is made in order to simplify the use of unions:
          if a union contains several structures that share a common initial
          sequence (see below), and if the union object currently contains
          one of these structures, it is permitted to inspect the common
          initial part of any of them anywhere that a declaration of the
          completed type of the union is visible. Two structures share a
          common initial sequence if corresponding members have compatible
          types (and, for bit-fields, the same widths) for a sequence of one
          or more initial members.
        P7: >
          EXAMPLE 1 If f is a function returning a structure or union, and x is
          a member of that structure or union, f().x is a valid postfix
          expression but is not an lvalue.
        P8: |
          EXAMPLE 2
          In:
          <code>
            struct s { int i; const int ci; };
            struct s s;
            const struct s cs;
            volatile struct s vs;
          </code>
          the various members have the types:
          <code>
            s.i    int
            s.ci   const int
            cs.i   const int
            cs.ci  const int
            vs.i   volatile int
            vs.ci  volatile const int
          </code>
        P9: |
          EXAMPLE 3
          The following is a valid fragment:
          <code>
            union {
              struct {
                int
                alltypes;
              } n;
              struct {
                int
                type;
                int
                intnode;
              } ni;
              struct {
                int
                type;
                double doublenode;
              } nf;
            } u;
            u.nf.type = 1;
            u.nf.doublenode = 3.14;
            /* ... */
            if (u.n.alltypes == 1)
              if (sin(u.nf.doublenode) == 0.0)
                /* ... */
          </code>
          The following is not a valid fragment (because the union type is not
          visible within function f):
          <code>
          struct t1 { int m; };
          struct t2 { int m; };
          int f(struct t1 *p1, struct t2 *p2)
          {
            if (p1->m < 0)
              p2->m = -p2->m;
            return p1->m;
          }
          int g()
          {
            union {
              struct t1 s1;
              struct t2 s2;
            } u;
            /* ... */
            return f(&u.s1, &u.s2);
          }
          </code>
      4:
        title: Postfix increment and decrement operators
        P1: |
          Constraints
          The operand of the postfix increment or decrement operator shall have
          atomic, qualified, or unqualified real or pointer type, and shall be
          a modifiable lvalue.
        P2: |
          Semantics
          The result of the postfix ++ operator is the value of the operand. As
          a side effect, the value of the operand object is incremented (that
          is, the value 1 of the appropriate type is added to it). See the
          discussions of additive operators and compound assignment for
          information on constraints, types, and conversions and the effects of
          operations on pointers. The value computation of the result is
          sequenced before the side effect of updating the stored value of the
          operand. With respect to an indeterminately-sequenced function call,
          the operation of postfix ++ is a single evaluation. Postfix ++ on an
          object with atomic type is a read-modify-write operation with
          memory_order_seq_cst memory order semantics.
          <foot> Where a pointer to an atomic object can be formed and E has
          integer type, E++ is equivalent to the following code sequence where T
          is the type of E:
            <code>
            T *addr = &E;
            T old = *addr;
            T new;
            do {
              new = old + 1;
            } while (!atomic_compare_exchange_strong(addr, &old, new));
          </code>
          with old being the result of the operation.  Special care must be
          taken if E has floating type; see 6.5.16.2.</foot>
        P3: >
          The postfix -- operator is analogous to the postfix ++ operator,
          except that the value of the operand is decremented (that is, the
          value 1 of the appropriate type is subtracted from it).
      5:
        title: Compound literals
        P1: |
          Constraints
          The type name shall specify a complete object type or an array of
          unknown size, but not a variable length array type.
        P2: >
          All the constraints for initializer lists in 6.7.9 also apply to
          compound literals.
        P3: |
          Semantics
          A postfix expression that consists of a parenthesized type name
          followed by a braceenclosed list of initializers is a compound
          literal. It provides an unnamed object whose value is given by the
          initializer list.
          <foot>Note that this differs from a cast expression. For example, a
          cast specifies a conversion to scalar types or void only, and the
          result of a cast expression is not an lvalue.</foot>
        P4: >
          If the type name specifies an array of unknown size, the size is
          determined by the initializer list as specified in 6.7.9, and the
          type of the compound literal is that of the completed array type.
          Otherwise (when the type name specifies an object type), the type of
          the compound literal is that specified by the type name. In either
          case, the result is an lvalue.
        P5: >
          The value of the compound literal is that of an unnamed object
          initialized by the initializer list. If the compound literal occurs
          outside the body of a function, the object has static storage
          duration; otherwise, it has automatic storage duration associated
          with the enclosing block.
        P6: >
          All the semantic rules for initializer lists in 6.7.9 also apply to
          compound literals.
          <foot>For example, subobjects without explicit initializers are
          initialized to zero.</foot>
        P7: >
          String literals, and compound literals with const-qualified types,
          need not designate distinct objects.<foot>This allows implementations
          to share storage for string literals and constant compound literals
          with the same or overlapping representations.</foot>
        P8: |
          EXAMPLE 1
          The file scope definition
          <code>
            int *p = (int []){2, 4};
          </code>
          initializes p to point to the first element of an array of two ints,
          the first having the value two and the second, four. The expressions
          in this compound literal are required to be constant. The unnamed
          object has static storage duration.
        P9: |
          EXAMPLE 2
          In contrast, in
          <code>
          void f(void)
          {
            int *p;
            /*...*/
            p = (int [2]){*p};
            /*...*/
          }
          </code>
          p is assigned the address of the first element of an array of two
          ints, the first having the value previously pointed to by p and the
          second, zero. The expressions in this compound literal need not be
          constant. The unnamed object has automatic storage duration.
        P10: |
          EXAMPLE 3 Initializers with designations can be combined with
          compound literals. Structure objects created using compound literals
          can be passed to functions without depending on member order:
          <code>
            drawline((struct point){.x=1, .y=1},
            (struct point){.x=3, .y=4});
          </code>
          Or, if drawline instead expected pointers to struct point:
          <code>
            drawline(&(struct point){.x=1, .y=1},
            &(struct point){.x=3, .y=4});
          </code>
        P11: |
          EXAMPLE 4
          A read-only compound literal can be specified through constructions like:
          <code>
            (const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6}
          </code>
        P12: |
          EXAMPLE 5
          The following three expressions have different meanings:
          <code>
            "/tmp/fileXXXXXX"
            (char []){"/tmp/fileXXXXXX"}
            (const char []){"/tmp/fileXXXXXX"}
          </code>
          The first always has static storage duration and has type array of
          char, but need not be modifiable; the last two have automatic storage
          duration when they occur within the body of a function, and the first
          of these two is modifiable.
        P13: |
          EXAMPLE 6 Like string literals, const-qualified compound literals can
          be placed into read-only memory and can even be shared. For example,
          <code>
            (const char []){"abc"} == "abc"
          </code>
          might yield 1 if the literals’ storage is shared.
        P14: |
          EXAMPLE 7 Since compound literals are unnamed, a single compound
          literal cannot specify a circularly linked object. For example, there
          is no way to write a self-referential compound literal that could be
          used as the function argument in place of the named object
          endless_zeros below:
          <code>
            struct int_list { int car; struct int_list *cdr; };
            struct int_list endless_zeros = {0, &endless_zeros};
            eval(endless_zeros);
          </code>
        P15: |
          EXAMPLE 8
          Each compound literal creates only a single object in a given scope:
          <code>
            struct s { int i; };
            int f (void)
            {
              struct s *p = 0, *q;
              int j = 0;
            again:
              q = p, p = &((struct s){ j++ });
              if (j < 2) goto again;
              return p == q && q->i == 1;
            }
          </code>
          The function f() always returns the value 1.
        P16: >
          Note that if an iteration statement were used instead of an explicit
          goto and a labeled statement, the lifetime of the unnamed object
          would be the body of the loop only, and on entry next time around p
          would have an indeterminate value, which would result in undefined
          behavior.
    3:
      title: Unary operators
      P1: |
        Syntax
        unary-expression:
          postfix-expression
          ++ unary-expression
          -- unary-expression
          unary-operator cast-expression
          sizeof unary-expression
          sizeof ( type-name )
          _Alignof ( type-name )
        unary-operator: one of
          & * + - ~ !
      1:
        title: Prefix increment and decrement operators
        P1: |
          Constraints
          The operand of the prefix increment or decrement operator shall have
          atomic, qualified, or unqualified real or pointer type, and shall be
          a modifiable lvalue.
        P2: |
          Semantics
          The value of the operand of the prefix ++ operator is incremented.
          The result is the new value of the operand after incrementation. The
          expression ++E is equivalent to (E+=1).  See the discussions of
          additive operators and compound assignment for information on
          constraints, types, side effects, and conversions and the effects of
          operations on pointers.
        P3: >
          The prefix -- operator is analogous to the prefix ++ operator, except
          that the value of the operand is decremented.
      2:
        title: Address and indirection operators
        P1: |
          Constraints The operand of the unary & operator shall be either a
          function designator, the result of a [] or unary * operator, or an
          lvalue that designates an object that is not a bit-field and is not
          declared with the register storage-class specifier.
        P2: The operand of the unary * operator shall have pointer type.
        P3: |
          Semantics
          The unary & operator yields the address of its operand. If the
          operand has type ‘‘type’’, the result has type ‘‘pointer to type’’.
          If the operand is the result of a unary * operator, neither that
          operator nor the & operator is evaluated and the result is as if both
          were omitted, except that the constraints on the operators still
          apply and the result is not an 88 lvalue. Similarly, if the operand
          is the result of a [] operator, neither the & operator nor the unary
          * that is implied by the [] is evaluated and the result is as if the
          & operator were removed and the [] operator were changed to a +
          operator. Otherwise, the result is a pointer to the object or
          function designated by its operand.
        P4: >
          The unary * operator denotes indirection. If the operand points to a
          function, the result is a function designator; if it points to an
          object, the result is an lvalue designating the object. If the
          operand has type ‘‘pointer to type’’, the result has type ‘‘type’’.
          If an invalid value has been assigned to the pointer, the behavior of
          the unary * operator is undefined.<foot>Thus, &*E is equivalent to E
          (even if E is a null pointer), and &(E1[E2]) to ((E1)+(E2)). It is
          always true that if E is a function designator or an lvalue that is a
          valid operand of the unary & operator, *&E is a function designator
          or an lvalue equal to E. If *P is an lvalue and T is the name of an
          object pointer type, *(T)P is an lvalue that has a type compatible
          with that to which T points.  Among the invalid values for
          dereferencing a pointer by the unary * operator are a null pointer,
          an address inappropriately aligned for the type of object pointed to,
          and the address of an object after the end of its lifetime.</foot>
      3:
        title: Unary arithmetic operators
        P1: |
          Constraints
          The operand of the unary + or - operator shall have arithmetic type;
          of the ~ operator, integer type; of the ! operator, scalar type.
        P2: |
          Semantics
          The result of the unary + operator is the value of its (promoted)
          operand. The integer promotions are performed on the operand, and the
          result has the promoted type.
        P3: >
          The result of the unary - operator is the negative of its (promoted)
          operand. The integer promotions are performed on the operand, and the
          result has the promoted type.
        P4: >
          The result of the ~ operator is the bitwise complement of its
          (promoted) operand (that is, each bit in the result is set if and
          only if the corresponding bit in the converted operand is not set).
          The integer promotions are performed on the operand, and the result
          has the promoted type. If the promoted type is an unsigned type, the
          expression ~E is equivalent to the maximum value representable in
          that type minus E.
        P5: >
          The result of the logical negation operator ! is 0 if the value of
          its operand compares unequal to 0, 1 if the value of its operand
          compares equal to 0. The result has type int.  The expression !E is
          equivalent to (0==E).
      4:
        title: The sizeof and _Alignof operators
        P1: |
          Constraints
          The sizeof operator shall not be applied to an expression that has
          function type or an incomplete type, to the parenthesized name of
          such a type, or to an expression that designates a bit-field member.
          The _Alignof operator shall not be applied to a function type or an
          incomplete type.
        P2: |
          Semantics
          The sizeof operator yields the size (in bytes) of its operand, which
          may be an expression or the parenthesized name of a type. The size is
          determined from the type of the operand. The result is an integer. If
          the type of the operand is a variable length array type, the operand
          is evaluated; otherwise, the operand is not evaluated and the result
          is an integer constant.
        P3: >
          The _Alignof operator yields the alignment requirement of its operand
          type. The operand is not evaluated and the result is an integer
          constant. When applied to an array type, the result is the alignment
          requirement of the element type.
        P4: >
          When sizeof is applied to an operand that has type char, unsigned
          char, or signed char, (or a qualified version thereof) the result is
          1. When applied to an operand that has array type, the result is the
          total number of bytes in the array.<foot>When applied to a parameter
          declared to have array or function type, the sizeof operator yields
          the size of the adjusted (pointer) type (see 6.9.1).</foot> When
          applied to an operand that has structure or union type, the result is
          the total number of bytes in such an object, including internal and
          trailing padding.
        P5: >
          The value of the result of both operators is implementation-defined,
          and its type (an unsigned integer type) is size_t, defined in
          <stddef.h> (and other headers).
        P6: |
          EXAMPLE 1 A principal use of the sizeof operator is in communication
          with routines such as storage allocators and I/O systems. A
          storage-allocation function might accept a size (in bytes) of an object
          to allocate and return a pointer to void. For example:
          <code>
            extern void *alloc(size_t);
            double *dp = alloc(sizeof *dp);
          </code>
          The implementation of the alloc function should ensure that its
          return value is aligned suitably for conversion to a pointer to
          double.
        P7: |
          EXAMPLE 2
          Another use of the sizeof operator is to compute the number of
          elements in an array:
          <code>
            sizeof array / sizeof array[0]
          </code>
        P8: |
          EXAMPLE 3
          In this example, the size of a variable length array is computed and
          returned from a function:
          <code>
            \#include <stddef.h>
            size_t fsize3(int n)
            {
              char b[n+3]; // variable length array
              return sizeof b; // execution time sizeof
            }
            int main()
            {
              size_t size;
              size = fsize3(10); // fsize3 returns 13
              return 0;
            }
          </code>
    4:
      title: Cast operators
      P1: |
        Syntax
        cast-expression:
          unary-expression
          ( type-name ) cast-expression
      P2: |
        Constraints
        Unless the type name specifies a void type, the type name shall specify
        atomic, qualified, or unqualified scalar type, and the operand shall
        have scalar type.
      P3: >
        Conversions that involve pointers, other than where permitted by the
        constraints of 6.5.16.1, shall be specified by means of an explicit
        cast.
      P4: >
        A pointer type shall not be converted to any floating type. A floating
        type shall not be converted to any pointer type.
      P5: |
        Semantics
        Preceding an expression by a parenthesized type name converts the value
        of the expression to the named type. This construction is called a
        cast.<foot> A cast does not yield an lvalue. Thus, a cast to a
        qualified type has the same effect as a cast to the unqualified version
        of the type.</foot> A cast that specifies no conversion has no effect
        on the type or value of an expression.
      P6: >
        If the value of the expression is represented with greater range or
        precision than required by the type named by the cast (6.3.1.8), then
        the cast specifies a conversion even if the type of the expression is
        the same as the named type and removes any extra range and precision.
    5:
      title: Multiplicative operators
      P1: |
        Syntax
        multiplicative-expression:
          cast-expression
          multiplicative-expression * cast-expression
          multiplicative-expression / cast-expression
          multiplicative-expression % cast-expression
      P2: |
        Constraints
        Each of the operands shall have arithmetic type. The operands of the %
        operator shall have integer type.
      P3: |
        Semantics
        The usual arithmetic conversions are performed on the operands.
      P4: >
        The result of the binary * operator is the product of the operands.
      P5: >
        The result of the / operator is the quotient from the division of the
        first operand by the second; the result of the % operator is the
        remainder. In both operations, if the value of the second operand is
        zero, the behavior is undefined.
      P6: >
        When integers are divided, the result of the / operator is the
        algebraic quotient with any fractional part discarded.<foot>This is
        often called ‘‘truncation toward zero’’.</foot> If the quotient a/b is
        representable, the expression (a/b)*b + a%b shall equal a; otherwise,
        the behavior of both a/b and a%b is undefined.
    6:
      titlle: Additive operators
      P1: |
        Syntax
        additive-expression:
          multiplicative-expression
          additive-expression + multiplicative-expression
          additive-expression - multiplicative-expression
      P2: |
        Constraints
        For addition, either both operands shall have arithmetic type, or one
        operand shall be a pointer to a complete object type and the other
        shall have integer type. (Incrementing is equivalent to adding 1.)
      P3: |
        For subtraction, one of the following shall hold:
        — both operands have arithmetic type;
        — both operands are pointers to qualified or unqualified versions of
        compatible complete object types; or
        — the left operand is a pointer to a complete object type and the right
        operand has integer type.
        (Decrementing is equivalent to subtracting 1.)
      P4: |
        Semantics
        If both operands have arithmetic type, the usual arithmetic conversions
        are performed on them.
      P5: >
        The result of the binary + operator is the sum of the operands.
      P6: >
        The result of the binary - operator is the difference resulting from
        the subtraction of the second operand from the first.
      P7: >
        For the purposes of these operators, a pointer to an object that is not
        an element of an array behaves the same as a pointer to the first
        element of an array of length one with the type of the object as its
        element type.
      P8: >
        When an expression that has integer type is added to or subtracted from
        a pointer, the result has the type of the pointer operand. If the
        pointer operand points to an element of an array object, and the array
        is large enough, the result points to an element offset from the
        original element such that the difference of the subscripts of the
        resulting and original array elements equals the integer expression. In
        other words, if the expression P points to the i-th element of an array
        object, the expressions (P)+N (equivalently, N+(P)) and (P)-N (where N
        has the value n) point to, respectively, the i+n-th and i−n-th elements
        of the array object, provided they exist. Moreover, if the expression P
        points to the last element of an array object, the expression (P)+1
        points one past the last element of the array object, and if the
        expression Q points one past the last element of an array object, the
        expression (Q)-1 points to the last element of the array object. If
        both the pointer operand and the result point to elements of the same
        array object, or one past the last element of the array object, the
        evaluation shall not produce an overflow; otherwise, the behavior is
        undefined. If the result points one past the last element of the array
        object, it shall not be used as the operand of a unary * operator that
        is evaluated.
      P9: >
        When two pointers are subtracted, both shall point to elements of the
        same array object, or one past the last element of the array object;
        the result is the difference of the subscripts of the two array
        elements. The size of the result is implementation-defined, and its
        type (a signed integer type) is ptrdiff_t defined in the <stddef.h>
        header.  If the result is not representable in an object of that type,
        the behavior is undefined. In other words, if the expressions P and Q
        point to, respectively, the i-th and j-th elements of an array object,
        the expression (P)-(Q) has the value i−j provided the value fits in an
        object of type ptrdiff_t. Moreover, if the expression P points either
        to an element of an array object or one past the last element of an
        array object, and the expression Q points to the last element of the
        same array object, the expression ((Q)+1)-(P) has the same value as
        ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the
        expression P points one past the last element of the array object, even
        though the expression (Q)+1 does not point to an element of the array
        object.<foot>Another way to approach pointer arithmetic is first to
        convert the pointer(s) to character pointer(s): In this scheme the
        integer expression added to or subtracted from the converted pointer is
        first multiplied by the size of the object originally pointed to, and the
        resulting pointer is converted back to the original type. For pointer
        subtraction, the result of the difference between the character pointers
        is similarly divided by the size of the object originally pointed to.
        When viewed in this way, an implementation need only provide one extra
        byte (which may overlap another object in the program) just after the end
        of the object in order to satisfy the ‘‘one past the last element’’
        requirements.</foot>
      P10: |
        EXAMPLE
        Pointer arithmetic is well defined with pointers to variable length
        array types.
        <code>
        {
          int n = 4, m = 3;
          int a[n][m];
          int (*p)[m] = a; // p == &a[0]
          p += 1;          // p == &a[1]
          (*p)[2] = 99;    // a[1][2] == 99
          n = p - a;       // n == 1
        }
        </code>
      P11: >
        If array a in the above example were declared to be an array of known
        constant size, and pointer p were declared to be a pointer to an array
        of the same known constant size (pointing to a), the results would be
        the same.
    7:
      title: Bitwise shift operators
      P1: |
        Syntax
        shift-expression:
          additive-expression
          shift-expression << additive-expression
          shift-expression >> additive-expression
      P2: |
        Constraints
        Each of the operands shall have integer type.
      P3: |
        Semantics
        The integer promotions are performed on each of the operands. The type
        of the result is that of the promoted left operand. If the value of the
        right operand is negative or is greater than or equal to the width of
        the promoted left operand, the behavior is undefined.
      P4: >
        The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated
        bits are filled with zeros. If E1 has an unsigned type, the value of
        the result is E1 × 2E2 , reduced modulo one more than the maximum value
        representable in the result type. If E1 has a signed type and
        nonnegative value, and E1 × 2E2 is representable in the result type,
        then that is the resulting value; otherwise, the behavior is undefined.
      P5: >
        The result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has
        an unsigned type or if E1 has a signed type and a nonnegative value,
        the value of the result is the integral part of the quotient of E1 /
        2E2 . If E1 has a signed type and a negative value, the resulting value
        is implementation-defined.
    8:
      title: Relational operators
      P1: |
        Syntax
        relational-expression:
          shift-expression
          relational-expression < shift-expression
          relational-expression > shift-expression
          relational-expression <= shift-expression
          relational-expression >= shift-expression
      P2: |
        Constraints
        One of the following shall hold:
        — both operands have real type; or
        — both operands are pointers to qualified or unqualified versions of
        compatible object types.
      P3: |
        Semantics
        If both of the operands have arithmetic type, the usual arithmetic
        conversions are performed.
      P4: >
        For the purposes of these operators, a pointer to an object that is not
        an element of an array behaves the same as a pointer to the first
        element of an array of length one with the type of the object as its
        element type.
      P5: >
        When two pointers are compared, the result depends on the relative
        locations in the address space of the objects pointed to. If two
        pointers to object types both point to the same object, or both point
        one past the last element of the same array object, they compare equal.
        If the objects pointed to are members of the same aggregate object,
        pointers to structure members declared later compare greater than
        pointers to members declared earlier in the structure, and pointers to
        array elements with larger subscript values compare greater than
        pointers to elements of the same array with lower subscript
        values. All pointers to members of the same union object compare equal.
        If the expression P points to an element of an array object and the
        expression Q points to the last element of the same array object, the
        pointer expression Q+1 compares greater than P. In all other cases, the
        behavior is undefined.
      P6: >
        Each of the operators < (less than), > (greater than), <= (less than or
        equal to), and >= (greater than or equal to) shall yield 1 if the
        specified relation is true and 0 if it is false.<foot>The expression
        a<b<c is not interpreted as in ordinary mathematics. As the syntax
        indicates, it means (a<b)<c; in other words, ‘‘if a is less than b,
        compare 1 to c; otherwise, compare 0 to c’’.</foot>) The result has
        type int.
    9:
      title: Equality operators
      P1: |
        Syntax
        equality-expression:
          relational-expression
          equality-expression == relational-expression
          equality-expression != relational-expression
      P2: |
        Constraints
        One of the following shall hold:
        — both operands have arithmetic type;
        — both operands are pointers to qualified or unqualified versions of
        compatible types;
        — one operand is a pointer to an object type and the other is a pointer
        to a qualified or unqualified version of void; or
        — one operand is a pointer and the other is a null pointer constant.
      P3: |
        Semantics
        The == (equal to) and != (not equal to) operators are analogous to the
        relational operators except for their lower precedence.<foot>Because of
        the precedences, a<b == c<d is 1 whenever a<b and c<d have the same
        truth-value.</foot> Each of the operators yields 1 if the specified
        relation is true and 0 if it is false. The result has type int. For any
        pair of operands, exactly one of the relations is true.
      P4: >
        If both of the operands have arithmetic type, the usual arithmetic
        conversions are performed. Values of complex types are equal if and
        only if both their real parts are equal and also their imaginary parts
        are equal. Any two values of arithmetic types from different type
        domains are equal if and only if the results of their conversions to
        the (complex) result type determined by the usual arithmetic
        conversions are equal.
      P5: >
        Otherwise, at least one operand is a pointer. If one operand is a
        pointer and the other is a null pointer constant, the null pointer
        constant is converted to the type of the pointer. If one operand is a
        pointer to an object type and the other is a pointer to a qualified or
        unqualified version of void, the former is converted to the type of the
        latter.
      P6: >
        Two pointers compare equal if and only if both are null pointers, both
        are pointers to the same object (including a pointer to an object and a
        subobject at its beginning) or function, both are pointers to one past
        the last element of the same array object, or one is a pointer to one
        past the end of one array object and the other is a pointer to the
        start of a different array object that happens to immediately follow
        the first array object in the address space.
        <foot>Two objects may be adjacent in memory because they are adjacent
        elements of a larger array or adjacent members of a structure with no
        padding between them, or because the implementation chose to place them
        so, even though they are unrelated. If prior invalid pointer operations
        (such as accesses outside array bounds) produced undefined behavior,
        subsequent comparisons also produce undefined behavior.</foot>
      P7: >
        For the purposes of these operators, a pointer to an object that is not
        an element of an array behaves the same as a pointer to the first
        element of an array of length one with the type of the object as its
        element type.
    10:
      title: Bitwise AND operator
      P1: |
        Syntax
        AND-expression:
          equality-expression
          AND-expression & equality-expression
      P2: |
        Constraints
        Each of the operands shall have integer type.
      P3: |
        Semantics
        The usual arithmetic conversions are performed on the operands.
      P4: >
        The result of the binary & operator is the bitwise AND of the operands
        (that is, each bit in the result is set if and only if each of the
        corresponding bits in the converted operands is set).
    11:
      title: exclusive OR operator
      P1: |
        Syntax
        exclusive-OR-expression:
          AND-expression
          exclusive-OR-expression ^ AND-expression
      P2: |
        Constraints
        Each of the operands shall have integer type.
      P3: |
        Semantics
        The usual arithmetic conversions are performed on the operands.
      P4: >
        The result of the ^ operator is the bitwise exclusive OR of the
        operands (that is, each bit in the result is set if and only if exactly
        one of the corresponding bits in the converted operands is set).
    12:
      title: Bitwise inclusive OR operator
      P1: |
        Syntax
        inclusive-OR-expression:
          exclusive-OR-expression
          inclusive-OR-expression | exclusive-OR-expression
      P2: |
        Constraints
        Each of the operands shall have integer type.
      P3: |
        Semantics
        The usual arithmetic conversions are performed on the operands.
      P4: >
        The result of the | operator is the bitwise inclusive OR of the
        operands (that is, each bit in the result is set if and only if at
        least one of the corresponding bits in the converted operands is set).
    13:
      title: Logical AND operator
      P1: |
        Syntax
        logical-AND-expression:
          inclusive-OR-expression
          logical-AND-expression && inclusive-OR-expression
      P2: |
        Constraints
        Each of the operands shall have scalar type.
      P3: |
        Semantics
        The && operator shall yield 1 if both of its operands compare unequal
        to 0; otherwise, it yields 0. The result has type int.
      P4: >
        Unlike the bitwise binary & operator, the && operator guarantees
        left-to-right evaluation; if the second operand is evaluated, there is
        a sequence point between the evaluations of the first and second
        operands. If the first operand compares equal to 0, the second operand
        is not evaluated.
    14:
      title: Logical OR operator
      P1: |
        Syntax
        logical-OR-expression:
          logical-AND-expression
          logical-OR-expression || logical-AND-expression
      P2: |
        Constraints
        Each of the operands shall have scalar type.
      P3: |
        Semantics
        The || operator shall yield 1 if either of its operands compare unequal
        to 0; otherwise, it yields 0. The result has type int.
      P4: >
        Unlike the bitwise | operator, the || operator guarantees left-to-right
        evaluation; if the second operand is evaluated, there is a sequence
        point between the evaluations of the first and second operands. If the
        first operand compares unequal to 0, the second operand is not
        evaluated.
    15:
      title: Conditional operator
      P1: |
        Syntax
        conditional-expression:
          logical-OR-expression
          logical-OR-expression ? expression : conditional-expression
      P2: |
        Constraints
        The first operand shall have scalar type.
      P3: |
        One of the following shall hold for the second and third operands:
        — both operands have arithmetic type;
        — both operands have the same structure or union type;
        — both operands have void type;
        — both operands are pointers to qualified or unqualified versions of
        compatible types;
        — one operand is a pointer and the other is a null pointer constant; or
        — one operand is a pointer to an object type and the other is a pointer
        to a qualified or unqualified version of void.
      P4: |
        Semantics
        The first operand is evaluated; there is a sequence point between its
        evaluation and the evaluation of the second or third operand (whichever
        is evaluated). The second operand is evaluated only if the first
        compares unequal to 0; the third operand is evaluated only if the first
        compares equal to 0; the result is the value of the second or third
        operand (whichever is evaluated), converted to the type described
        below.<foot>A conditional expression does not yield an lvalue.</foot>
      P5: >
        If both the second and third operands have arithmetic type, the result
        type that would be determined by the usual arithmetic conversions, were
        they applied to those two operands, is the type of the result. If both
        the operands have structure or union type, the result has that type. If
        both operands have void type, the result has void type.
      P6: >
        If both the second and third operands are pointers or one is a null
        pointer constant and the other is a pointer, the result type is a
        pointer to a type qualified with all the type qualifiers of the types
        referenced by both operands. Furthermore, if both operands are pointers
        to compatible types or to differently qualified versions of compatible
        types, the result type is a pointer to an appropriately qualified
        version of the composite type; if one operand is a null pointer
        constant, the result has the type of the other operand; otherwise, one
        operand is a pointer to void or a qualified version of void, in which
        case the result type is a pointer to an appropriately qualified version
        of void.
      P7: >
        EXAMPLE The common type that results when the second and third operands
        are pointers is determined in two independent stages. The appropriate
        qualifiers, for example, do not depend on whether the two pointers have
        compatible types.
      P8: |
        Given the declarations
        <code>
          const void *c_vp;
          void *vp;
          const int *c_ip;
          volatile int *v_ip;
          int *ip;
          const char *c_cp;
        </code>
        the third column in the following table is the common type that is the
        result of a conditional expression in which the first two columns are the
        second and third operands (in either order):
        <code>
          c_vp  c_ip  const void *
          v_ip  0     volatile int *
          c_ip v_ip   const volatile int *
          vp   c_cp   const void *
          ip   c_ip   const int *
          vp   ip     void *
        </code>
    16:
      title: Assignment operators
      P1: |
        Syntax
        assignment-expression:
          conditional-expression
          unary-expression assignment-operator assignment-expression
        assignment-operator: one of
          = *= /= %= += -= <<= >>= &= ^= |=
      P2: |
        Constraints
        An assignment operator shall have a modifiable lvalue as its left operand.
      P3: |
        Semantics
        An assignment operator stores a value in the object designated by the
        left operand. An assignment expression has the value of the left
        operand after the assignment,<foot>The implementation is permitted to
        read the object to determine the value but is not required to, even
        when the object has volatile-qualified type.</foot> but is not an
        lvalue. The type of an assignment expression is the type the left
        operand would have after lvalue conversion. The side effect of updating
        the stored value of the left operand is sequenced after the value
        computations of the left and right operands. The evaluations of the
        operands are unsequenced.
      1:
        title: Simple assignment
        P1: |
          Constraints
          One of the following shall hold:<foot>The asymmetric appearance of
          these constraints with respect to type qualifiers is due to the
          conversion (specified in 6.3.2.1) that changes lvalues to ‘‘the value
          of the expression’’ and thus removes any type qualifiers that were
          applied to the type category of the expression (for example, it
          removes const but not volatile from the type int volatile *
          const).</foot>
          — the left operand has atomic, qualified, or unqualified arithmetic
          type, and the right has arithmetic type;
          — the left operand has an atomic, qualified, or unqualified version
          of a structure or union type compatible with the type of the right;
          — the left operand has atomic, qualified, or unqualified pointer
          type, and (considering the type the left operand would have after
          lvalue conversion) both operands are pointers to qualified or
          unqualified versions of compatible types, and the type pointed to by
          the left has all the qualifiers of the type pointed to by the right;
          — the left operand has atomic, qualified, or unqualified pointer
          type, and (considering the type the left operand would have after
          lvalue conversion) one operand is a pointer to an object type, and
          the other is a pointer to a qualified or unqualified version of void,
          and the type pointed to by the left has all the qualifiers of the
          type pointed to by the right;
          — the left operand is an atomic, qualified, or unqualified pointer,
          and the right is a null pointer constant; or
          — the left operand has type atomic, qualified, or unqualified _Bool,
          and the right is a pointer.
        P2: |
          Semantics
          In simple assignment (=), the value of the right operand is converted
          to the type of the assignment expression and replaces the value
          stored in the object designated by the left operand.
        P3: >
          If the value being stored in an object is read from another object
          that overlaps in any way the storage of the first object, then the
          overlap shall be exact and the two objects shall have qualified or
          unqualified versions of a compatible type; otherwise, the behavior is
          undefined.
        P4: |
          EXAMPLE 1
          In the program fragment
          <code>
            int f(void);
            char c;
            /* ... */
            if ((c = f()) == -1)
            /* ... */
          </code>
          the int value returned by the function may be truncated when stored
          in the char, and then converted back to int width prior to the
          comparison. In an implementation in which ‘‘plain’’ char has the same
          range of values as unsigned char (and char is narrower than int), the
          result of the conversion cannot be negative, so the operands of the
          comparison can never compare equal. Therefore, for full portability,
          the variable c should be declared as int.
        P5: |
          EXAMPLE 2
          In the fragment:
          <code>
            char c;
            int i;
            long l;
            l = (c = i);
          </code>
          the value of i is converted to the type of the assignment expression
          c = i, that is, char type. The value of the expression enclosed in
          parentheses is then converted to the type of the outer assignment
          expression, that is, long int type.
        P6: |
          EXAMPLE 3
          Consider the fragment:
          <code>
            const char **cpp;
            char *p;
            const char c = 'A';
            cpp = &p; // constraint violation
            *cpp = &c; // valid
            *p = 0; // valid
          </code>
          The first assignment is unsafe because it would allow the following
          valid code to attempt to change the value of the const object c.
      2:
        title: Compound assignment
        P1: |
          Constraints
          For the operators += and -= only, either the left operand shall be an
          atomic, qualified, or unqualified pointer to a complete object type,
          and the right shall have integer type; or the left operand shall have
          atomic, qualified, or unqualified arithmetic type, and the right
          shall have arithmetic type.
        P2: |
          For the other operators, the left operand shall have atomic,
          qualified, or unqualified arithmetic type, and (considering the type
          the left operand would have after lvalue conversion) each operand
          shall have arithmetic type consistent with those allowed by the
          corresponding binary operator.
        P3: |
          Semantics
          A compound assignment of the form E1 op = E2 is equivalent to the
          simple assignment expression E1 = E1 op (E2), except that the lvalue
          E1 is evaluated only once, and with respect to an
          indeterminately-sequenced function call, the operation of a compound
          assignment is a single evaluation. If E1 has an atomic type, compound
          assignment is a read-modify-write operation with memory_order_seq_cst
          memory order semantics.<foot>Where a pointer to an atomic object can
          be formed and E1 and E2 have integer type, this is equivalent to the
          following code sequence where T1 is the type of E1 and T2 is the type
          of E2:
          <code>
            T1 *addr = &E1;
            T2 val = (E2);
            T1 old = *addr;
            T1 new;
            do {
              new = old op val;
            } while (!atomic_compare_exchange_strong(addr, &old, new));
          </code>
          with new being the result of the operation.
          If E1 or E2 has floating type, then exceptional conditions or
          floating-point exceptions encountered during discarded evaluations of
          new should also be discarded in order to satisfy the equivalence of
          E1 op = E2 and E1 = E1 op (E2). For example, if annex F is in effect,
          the floating types involved have IEC 60559 formats, and
          FLT_EVAL_METHOD is 0, the equivalent code would be:
          <code>
            \#include <fenv.h>
            \#pragma STDC FENV_ACCESS ON
            /* ... */
              fenv_t fenv;
              T1 *addr = &E1;
              T2 val = E2;
              T1 old = *addr;
              T1 new;
              feholdexcept(&fenv);
              for (;;) {
                new = old op val;
                if (atomic_compare_exchange_strong(addr, &old, new))
                  break;
                feclearexcept(FE_ALL_EXCEPT);
              }
              feupdateenv(&fenv);
          </code>
          If FLT_EVAL_METHOD is not 0, then T2 must be a type with the range
          and precision to which E2 is evaluated in order to satisfy the
          equivalence.</foot>
    17:
      title: Comma operator
      P1: |
        Syntax
        expression:
          assignment-expression
          expression , assignment-expression
      P2: |
        Semantics
        The left operand of a comma operator is evaluated as a void expression;
        there is a sequence point between its evaluation and that of the right
        operand. Then the right operand is evaluated; the result has its type
        and value.<foot>A comma operator does not yield an lvalue.</foot>
      P3: >
        EXAMPLE As indicated by the syntax, the comma operator (as described in
        this subclause) cannot appear in contexts where a comma is used to
        separate items in a list (such as arguments to functions or lists of
        initializers). On the other hand, it can be used within a parenthesized
        expression or within the second expression of a conditional operator in
        such contexts. In the function call f(a, (t=3, t+2), c) the function
        has three arguments, the second of which has the value 5.

  6:
    title: Constant expressions
    P1: |
      Syntax
      constant-expression:
        conditional-expression
    P2: |
      Description
      A constant expression can be evaluated during translation rather than
      runtime, and accordingly may be used in any place that a constant may be.
    P3: |
      Constraints
      Constant expressions shall not contain assignment, increment, decrement,
      function-call, or comma operators, except when they are contained within
      a subexpression that is not evaluated. <foot>The operand of a sizeof or
      _Alignof operator is usually not evaluated (6.5.3.4).</foot>
    P4: >
      Each constant expression shall evaluate to a constant that is in the
      range of representable values for its type.
    P5: |
      Semantics
      An expression that evaluates to a constant is required in several
      contexts. If a floating expression is evaluated in the translation
      environment, the arithmetic range and precision shall be at least as
      great as if the expression were being evaluated in the execution
      environment.<foot>The use of evaluation formats as characterized by
      FLT_EVAL_METHOD also applies to evaluation in the translation
      environment.</foot>
    P6: >
      An integer constant expression<foot>An integer constant expression is
      required in a number of contexts such as the size of a bit-field member
      of a structure, the value of an enumeration constant, and the size of a
      non-variable length array. Further constraints that apply to the integer
      constant expressions used in conditional-inclusion preprocessing
      directives are discussed in 6.10.1.</foot> shall have integer type and
      shall only have operands that are integer constants, enumeration
      constants, character constants, sizeof expressions whose results are
      integer constants, _Alignof expressions, and floating constants that are
      the immediate operands of casts. Cast operators in an integer constant
      expression shall only convert arithmetic types to integer types, except
      as part of an operand to the sizeof or _Alignof operator.
    P7: |
      More latitude is permitted for constant expressions in initializers. Such
      a constant expression shall be, or evaluate to, one of the following:
      — an arithmetic constant expression,
      — a null pointer constant,
      — an address constant, or
      — an address constant for a complete object type plus or minus an integer
      constant expression.
    P8: >
      An arithmetic constant expression shall have arithmetic type and shall
      only have operands that are integer constants, floating constants,
      enumeration constants, character constants, sizeof expressions whose
      results are integer constants, and _Alignof expressions. Cast operators
      in an arithmetic constant expression shall only convert arithmetic types
      to arithmetic types, except as part of an operand to a sizeof or _Alignof
      operator.
    P9: >
      An address constant is a null pointer, a pointer to an lvalue designating
      an object of static storage duration, or a pointer to a function
      designator; it shall be created explicitly using the unary & operator or
      an integer constant cast to pointer type, or implicitly by the use of an
      expression of array or function type. The array-subscript [] and
      member-access .  and -> operators, the address & and indirection * unary
      operators, and pointer casts may be used in the creation of an address
      constant, but the value of an object shall not be accessed by use of
      these operators.
    P10: An implementation may accept other forms of constant expressions.
    P11: >
      The semantic rules for the evaluation of a constant expression are the
      same as for nonconstant expressions.<foot>Thus, in the following
      initialization, static int i = 2 || 1 / 0; the expression is a valid
      integer constant expression with value one.</foot>
  7:
    title: Declarations
    P1: |
      Syntax
      declaration:
        declaration-specifiers init-declarator-listopt ;
        static_assert-declaration
      declaration-specifiers:
        storage-class-specifier declaration-specifiersopt
        type-specifier declaration-specifiersopt
        type-qualifier declaration-specifiersopt
        function-specifier declaration-specifiersopt
        alignment-specifier declaration-specifiersopt
      init-declarator-list:
        init-declarator
        init-declarator-list , init-declarator
      init-declarator:
        declarator
        declarator = initializer
    P2: |
      Constraints
      A declaration other than a static_assert declaration shall declare at
      least a declarator (other than the parameters of a function or the
      members of a structure or union), a tag, or the members of an
      enumeration.
    P3: |
      If an identifier has no linkage, there shall be no more than one
      declaration of the identifier (in a declarator or type specifier) with the
      same scope and in the same name space, except that:
      — a typedef name may be redefined to denote the same type as it currently
      does, provided that type is not a variably modified type;
      — tags may be redeclared as specified in 6.7.2.3.
    P4: >
      All declarations in the same scope that refer to the same object or
      function shall specify compatible types.
    P5: |
      Semantics
      A declaration specifies the interpretation and attributes of a set of
      identifiers. A definition of an identifier is a declaration for that
      identifier that:
      — for an object, causes storage to be reserved for that object;
      — for a function, includes the function body;<foot>Function definitions
      have a different syntax, described in 6.9.1.</foot>
      — for an enumeration constant, is the (only) declaration of the identifier;
      — for a typedef name, is the first (or only) declaration of the identifier.
    P6: >
      The declaration specifiers consist of a sequence of specifiers that
      indicate the linkage, storage duration, and part of the type of the
      entities that the declarators denote. The initdeclarator-list is a
      comma-separated sequence of declarators, each of which may have
      additional type information, or an initializer, or both. The declarators
      contain the identifiers (if any) being declared.
    P7: >
      If an identifier for an object is declared with no linkage, the type for
      the object shall be complete by the end of its declarator, or by the end
      of its init-declarator if it has an initializer; in the case of function
      parameters (including in prototypes), it is the adjusted type (see
      6.7.6.3) that is required to be complete.
    1:
      title: Storage-class specifiers
      P1: |
        Syntax
        storage-class-specifier:
          typedef
          extern
          static
          _Thread_local
          auto
          register
      P2: |
        Constraints
        At most, one storage-class specifier may be given in the declaration
        specifiers in a declaration, except that _Thread_local may appear with
        static or extern.<foot>See ‘‘future language directions’’ (6.11.5).</foot>
      P3: >
        In the declaration of an object with block scope, if the declaration
        specifiers include _Thread_local, they shall also include either static
        or extern. If _Thread_local appears in any declaration of an object, it
        shall be present in every declaration of that object.
      P4: >
        _Thread_local shall not appear in the declaration specifiers of a
        function declaration.
      P5: |
        Semantics
        The typedef specifier is called a ‘‘storage-class specifier’’ for
        syntactic convenience only; it is discussed in 6.7.8. The meanings of
        the various linkages and storage durations were discussed in 6.2.2 and
        6.2.4.
      P6: >
        A declaration of an identifier for an object with storage-class
        specifier register suggests that access to the object be as fast as
        possible. The extent to which such suggestions are effective is
        implementation-defined.<foot>The implementation may treat any register
        declaration simply as an auto declaration. However, whether or not
        addressable storage is actually used, the address of any part of an
        object declared with storage-class specifier register cannot be
        computed, either explicitly (by use of the unary & operator as
        discussed in 6.5.3.2) or implicitly (by converting an array name to a
        pointer as discussed in 6.3.2.1). Thus, the only operator that can be
        applied to an array declared with storage-class specifier register is
        sizeof.</foot>
      P7: >
        The declaration of an identifier for a function that has block scope
        shall have no explicit storage-class specifier other than extern.
      P8: >
        If an aggregate or union object is declared with a storage-class
        specifier other than typedef, the properties resulting from the
        storage-class specifier, except with respect to linkage, also apply to
        the members of the object, and so on recursively for any aggregate or
        union member objects.
    2:
      title: Type specifiers
      P1: |
        Syntax
        type-specifier:
          void
          char
          short
          int
          long
          float
          double
          signed
          unsigned
          _Bool
          _Complex
          atomic-type-specifier
          struct-or-union-specifier
          enum-specifier
          typedef-name
      P2: |
        Constraints
        At least one type specifier shall be given in the declaration
        specifiers in each declaration, and in the specifier-qualifier list in
        each struct declaration and type name. Each list of type specifiers
        shall be one of the following multisets (delimited by commas, when
        there is more than one multiset per item); the type specifiers may
        occur in any order, possibly intermixed with the other declaration
        specifiers.
        — void
        — char
        — signed char
        — unsigned char
        — short, signed short, short int, or signed short int
        — unsigned short, or unsigned short int
        — int, signed, or signed int
        — unsigned, or unsigned int
        — long, signed long, long int, or signed long int
        — unsigned long, or unsigned long int
        — long long, signed long long, long long int, or
        signed long long int
        — unsigned long long, or unsigned long long int
        — float
        — double
        — long double
        — _Bool
        — float _Complex
        — double _Complex
        — long double _Complex
        — atomic type specifier
        — struct or union specifier
        — enum specifier
        — typedef name
        The type specifier _Complex shall not be used if the implementation
        does not support complex types (see 6.10.8.3).
      P4: |
        Semantics
        Specifiers for structures, unions, enumerations, and atomic types are
        discussed in 6.7.2.1 through 6.7.2.4. Declarations of typedef names are
        discussed in 6.7.8. The characteristics of the other types are
        discussed in 6.2.5.
      P5: >
        Each of the comma-separated multisets designates the same type, except
        that for bitfields, it is implementation-defined whether the specifier
        int designates the same type as signed int or the same type as unsigned
        int.

      1:
        title: Structure and union specifiers
        P1: |
          Syntax
          struct-or-union-specifier:
            struct-or-union identifieropt { struct-declaration-list }
            struct-or-union identifier
          struct-or-union:
            struct
            union
          struct-declaration-list:
            struct-declaration
            struct-declaration-list struct-declaration
          struct-declaration:
            specifier-qualifier-list struct-declarator-listopt ;
            static_assert-declaration
          specifier-qualifier-list:
            type-specifier specifier-qualifier-listopt
            type-qualifier specifier-qualifier-listopt
          struct-declarator-list:
            struct-declarator
            struct-declarator-list , struct-declarator
          struct-declarator:
            declarator
          declaratoropt : constant-expression
        P2: |
          Constraints
          A struct-declaration that does not declare an anonymous structure or
          anonymous union shall contain a struct-declarator-list.
        P3: >
          A structure or union shall not contain a member with incomplete or
          function type (hence, a structure shall not contain an instance of
          itself, but may contain a pointer to an instance of itself), except
          that the last member of a structure with more than one named member
          may have incomplete array type; such a structure (and any union
          containing, possibly recursively, a member that is such a structure)
          shall not be a member of a structure or an element of an array.
        P4: >
          The expression that specifies the width of a bit-field shall be an
          integer constant expression with a nonnegative value that does not
          exceed the width of an object of the type that would be specified
          were the colon and expression omitted.122) If the value is zero, the
          declaration shall have no declarator.
        P5: >
          A bit-field shall have a type that is a qualified or unqualified
          version of _Bool, signed int, unsigned int, or some other
          implementation-defined type. It is implementation-defined whether
          atomic types are permitted.  122) While the number of bits in a _Bool
          object is at least CHAR_BIT, the width (number of sign and value
          bits) of a _Bool may be just 1 bit.
        P6: |
          Semantics
          As discussed in 6.2.5, a structure is a type consisting of a sequence
          of members, whose storage is allocated in an ordered sequence, and a
          union is a type consisting of a sequence of members whose storage
          overlap.
        P7: >
          Structure and union specifiers have the same form. The keywords
          struct and union indicate that the type being specified is,
          respectively, a structure type or a union type.
        P8: >
          The presence of a struct-declaration-list in a
          struct-or-union-specifier declares a new type, within a translation
          unit. The struct-declaration-list is a sequence of declarations for
          the members of the structure or union. If the struct-declaration-list
          does not contain any named members, either directly or via an
          anonymous structure or anonymous union, the behavior is undefined.
          The type is incomplete until immediately after the } that terminates
          the list, and complete thereafter.
        P9: >
          A member of a structure or union may have any complete object type
          other than a variably modified type.<foot>A structure or union cannot
          contain a member with a variably modified type because member names
          are not ordinary identifiers as defined in 6.2.3.</foot> In addition,
          a member may be declared to consist of a specified number of bits
          (including a sign bit, if any). Such a member is called a
          bit-field;<foot>The unary & (address-of) operator cannot be applied
          to a bit-field object; thus, there are no pointers to or arrays of
          bit-field objects.</foot> its width is preceded by a colon.
        P10: >
          A bit-field is interpreted as having a signed or unsigned integer
          type consisting of the specified number of bits.<foot>As specified in
          6.7.2 above, if the actual type specifier used is int or a
          typedef-name defined as int, then it is implementation-defined
          whether the bit-field is signed or unsigned.</foot> If the value 0 or
          1 is stored into a nonzero-width bit-field of type _Bool, the value
          of the bit-field shall compare equal to the value stored; a _Bool
          bit-field has the semantics of a _Bool.
        P11: >
          An implementation may allocate any addressable storage unit large
          enough to hold a bitfield. If enough space remains, a bit-field that
          immediately follows another bit-field in a structure shall be packed
          into adjacent bits of the same unit. If insufficient space remains,
          whether a bit-field that does not fit is put into the next unit or
          overlaps adjacent units is implementation-defined. The order of
          allocation of bit-fields within a unit (high-order to low-order or
          low-order to high-order) is implementation-defined. The alignment of
          the addressable storage unit is unspecified.
        P12: >
          A bit-field declaration with no declarator, but only a colon and a
          width, indicates an unnamed bit-field.<foot>An unnamed bit-field
          structure member is useful for padding to conform to externally
          imposed layouts.</foot> As a special case, a bit-field structure
          member with a width of 0 indicates that no further bit-field is to be
          packed into the unit in which the previous bitfield, if any, was
          placed.
        P13: >
          An unnamed member whose type specifier is a structure specifier with
          no tag is called an anonymous structure; an unnamed member whose type
          specifier is a union specifier with no tag is called an anonymous
          union. The members of an anonymous structure or union are considered
          to be members of the containing structure or union. This applies
          recursively if the containing structure or union is also anonymous.
        P14: >
          Each non-bit-field member of a structure or union object is aligned
          in an implementation defined manner appropriate to its type.
        P15: >
          Within a structure object, the non-bit-field members and the units in
          which bit-fields reside have addresses that increase in the order in
          which they are declared. A pointer to a structure object, suitably
          converted, points to its initial member (or if that member is a
          bit-field, then to the unit in which it resides), and vice versa.
          There may be unnamed padding within a structure object, but not at
          its beginning.
        P16: >
          The size of a union is sufficient to contain the largest of its
          members. The value of at most one of the members can be stored in a
          union object at any time. A pointer to a union object, suitably
          converted, points to each of its members (or if a member is a
          bitfield, then to the unit in which it resides), and vice versa.
        P17: >
          There may be unnamed padding at the end of a structure or union.
        P18: >
          As a special case, the last element of a structure with more than one
          named member may have an incomplete array type; this is called a
          flexible array member. In most situations, the flexible array member
          is ignored. In particular, the size of the structure is as if the
          flexible array member were omitted except that it may have more
          trailing padding than the omission would imply. However, when a . (or
          ->) operator has a left operand that is (a pointer to) a structure
          with a flexible array member and the right operand names that member,
          it behaves as if that member were replaced with the longest array
          (with the same element type) that would not make the structure larger
          than the object being accessed; the offset of the array shall remain
          that of the flexible array member, even if this would differ from
          that of the replacement array. If this array would have no elements,
          it behaves as if it had one element but the behavior is undefined if
          any attempt is made to access that element or to generate a pointer
          one past it.
        P19: |
          EXAMPLE 1
          The following illustrates anonymous structures and unions:
          <code>
            struct v {
              union {
                // anonymous union
                struct { int i, j; };
                // anonymous structure
                struct { long k, l; } w;
              };
              int m;
            } v1;
            v1.i = 2; // valid
            v1.k = 3; // invalid: inner structure is not anonymous
            v1.w.k = 5; // valid
          </code>
        P20: |
          EXAMPLE 2
          After the declaration:
          <code>
            struct s { int n; double d[]; };
          </code>
          the structure struct s has a flexible array member d. A typical way
          to use this is:
          <code>
            int m = /* some value */;
            struct s *p = malloc(sizeof (struct s) + sizeof (double [m]));
          </code>
          and assuming that the call to malloc succeeds, the object pointed to
          by p behaves, for most purposes, as if p had been declared as:
          <code>
            struct { int n; double d[m]; } *p;
          </code>
          (there are circumstances in which this equivalence is broken; in
          particular, the offsets of member d might not be the same).
        P21: |
          Following the above declaration:
          <code>
            struct s t1 = { 0 }; // valid
            struct s t2 = { 1, { 4.2 }}; // invalid
            t1.n = 4; // valid
            t1.d[0] = 4.2; // might be undefined behavior
          </code>
          The initialization of t2 is invalid (and violates a constraint)
          because struct s is treated as if it did not contain member d. The
          assignment to t1.d[0] is probably undefined behavior, but it is
          possible that
          <code>
            sizeof (struct s) >= offsetof(struct s, d) + sizeof (double)
          </code>
          in which case the assignment would be legitimate. Nevertheless, it
          cannot appear in strictly conforming code.
        P22: |
          After the further declaration:
          <code>
            struct ss { int n; };
          </code>
          the expressions:
          <code>
            sizeof (struct s) >= sizeof (struct ss)
            sizeof (struct s) >= offsetof(struct s, d)
          </code>
          are always equal to 1.
        P23: |
          If sizeof (double) is 8, then after the following code is executed:
          <code>
            struct s *s1;
            struct s *s2;
            s1 = malloc(sizeof (struct s) + 64);
            s2 = malloc(sizeof (struct s) + 46);
          </code>
          and assuming that the calls to malloc succeed, the objects pointed to
          by s1 and s2 behave, for most purposes, as if the identifiers had
          been declared as:
          <code>
            struct { int n; double d[8]; } *s1;
            struct { int n; double d[5]; } *s2;
          </code>
        P24: |
          Following the further successful assignments:
          <code>
            s1 = malloc(sizeof (struct s) + 10);
            s2 = malloc(sizeof (struct s) + 6);
          </code>
          they then behave as if the declarations were:
          <code>
            struct { int n; double d[1]; } *s1, *s2;
          </code>
          and:
          <code>
            double *dp;
            dp = &(s1->d[0]); // valid
            *dp = 42; // valid
            dp = &(s2->d[0]); //valid
            *dp = 42; // undefined behavior
          </code>
        P25: |
          The assignment:
          <code>
            *s1 = *s2;
          </code>
          only copies the member n; if any of the array elements are within the
          first sizeof (struct s) bytes of the structure, they might be copied
          or simply overwritten with indeterminate values.
        P26: |
          EXAMPLE 3 Because members of anonymous structures and unions are
          considered to be members of the containing structure or union, struct s
          in the following example has more than one named member and thus the
          use of a flexible array member is valid:
          <code>
            struct s {
              struct { int i; };
              int a[];
            };
          </code>

      2:
        title: Enumeration specifiers
        P1: |
          Syntax
          enum-specifier:
            enum identifieropt { enumerator-list }
            enum identifieropt { enumerator-list , }
            enum identifier
          enumerator-list:
            enumerator
            enumerator-list , enumerator
          enumerator:
            enumeration-constant
            enumeration-constant = constant-expression
        P2: |
          Constraints
          The expression that defines the value of an enumeration constant
          shall be an integer constant expression that has a value
          representable as an int.
        P3: |
          Semantics
          The identifiers in an enumerator list are declared as constants that
          have type int and may appear wherever such are permitted.<foot>Thus,
          the identifiers of enumeration constants declared in the same scope
          shall all be distinct from</foot> An enumerator with = defines its
          enumeration constant as the value of the constant expression. If the
          first enumerator has no =, the value of its enumeration constant is
          0. Each subsequent enumerator with no = defines its enumeration
          constant as the value of the constant expression obtained by adding 1
          to the value of the previous enumeration constant. (The use of
          enumerators with = may produce enumeration constants with values that
          duplicate other values in the same enumeration.) The enumerators of
          an enumeration are also known as its members.
        P4: >
          Each enumerated type shall be compatible with char, a signed integer
          type, or an unsigned integer type. The choice of type is
          implementation-defined,<foot>An implementation may delay the choice
          of which integer type until all enumeration constants have been
          seen.</foot> but shall be capable of representing the values of all
          the members of the enumeration. The enumerated type is incomplete
          until immediately after the } that terminates the list of enumerator
          declarations, and complete thereafter.
        P5: |
          EXAMPLE
          The following fragment:
          <code>
            enum hue { chartreuse, burgundy, claret=20, winedark };
            enum hue col, *cp;
            col = claret;
            cp = &col;
            if (*cp != burgundy)
            /* ... */
          </code>
          makes hue the tag of an enumeration, and then declares col as an
          object that has that type and cp as a pointer to an object that has
          that type. The enumerated values are in the set { 0, 1, 20, 21 }.

      3:
        title: Tags
        P1: |
          Constraints
          A specific type shall have its content defined at most once.
        P2: >
          Where two declarations that use the same tag declare the same type,
          they shall both use the same choice of struct, union, or enum.
        P3: >
          A type specifier of the form enum identifier without an enumerator
          list shall only appear after the type it specifies is complete.
        P4: |
          Semantics
          All declarations of structure, union, or enumerated types that have
          the same scope and use the same tag declare the same type.
          Irrespective of whether there is a tag or what other declarations of
          the type are in the same translation unit, the type is
          incomplete<foot>An incomplete type may only by used when the size of
          an object of that type is not needed. It is not needed, for example,
          when a typedef name is declared to be a specifier for a structure or
          union, or when a pointer to or a function returning a structure or
          union is being declared. (See incomplete types in 6.2.5.) The
          specification has to be complete before such a function is called or
          defined.</foot> until immediately after the closing brace of the list
          defining the content, and complete thereafter.
        P5: >
          Two declarations of structure, union, or enumerated types which are
          in different scopes or use different tags declare distinct types.
          Each declaration of a structure, union, or enumerated type which does
          not include a tag declares a distinct type.
        P6: |
          A type specifier of the form
            struct-or-union identifieropt { struct-declaration-list }
          or
            enum identifieropt { enumerator-list }
          or
            enum identifieropt { enumerator-list , }
          declares a structure, union, or enumerated type. The list defines the
          structure content, union content, or enumeration content. If an
          identifier is provided,<foot>If there is no identifier, the type can,
          within the translation unit, only be referred to by the declaration
          of which it is a part. Of course, when the declaration is of a
          typedef name, subsequent declarations can make use of that typedef
          name to declare objects having the specified structure, union, or
          enumerated type.</foot> the type specifier also declares the
          identifier to be the tag of that type.
        P7: |
          A declaration of the form
            struct-or-union identifier ;
          specifies a structure or union type and declares the identifier as a
          tag of that type.<foot>A similar construction with enum does not
          exist.</foot>
        P8: |
          If a type specifier of the form
            struct-or-union identifier
          occurs other than as part of one of the above forms, and no other
          declaration of the identifier as a tag is visible, then it declares
          an incomplete structure or union type, and declares the identifier as
          the tag of that type.<foot>A similar construction with enum does not
          exist.</foot>
        P9: |
          If a type specifier of the form
            struct-or-union identifier
          or
            enum identifier
          occurs other than as part of one of the above forms, and a
          declaration of the identifier as a tag is visible, then it specifies
          the same type as that other declaration, and does not redeclare the
          tag.
        P10: |
          EXAMPLE 1
          This mechanism allows declaration of a self-referential structure.
          <code>
            struct tnode {
              int count;
              struct tnode *left, *right;
            };
          </code>
          specifies a structure that contains an integer and two pointers to
          objects of the same type. Once this declaration has been given, the
          declaration
          <code>
            struct tnode s, *sp;
          </code>
          declares s to be an object of the given type and sp to be a pointer
          to an object of the given type. With these declarations, the
          expression sp->left refers to the left struct tnode pointer of the
          object to which sp points; the expression s.right->count designates
          the count member of the right struct tnode pointed to from s.
        P11: |
          The following alternative formulation uses the typedef mechanism:
          <code>
            typedef struct tnode TNODE;
            struct tnode {
              int count;
              TNODE *left, *right;
            };
            TNODE s, *sp;
          </code>
        P12: |
          EXAMPLE 2 To illustrate the use of prior declaration of a tag to
          specify a pair of mutually referential structures, the declarations
          <code>
            struct s1 { struct s2 *s2p; /* ... */ }; // D1
            struct s2 { struct s1 *s1p; /* ... */ }; // D2
          </code>
          specify a pair of structures that contain pointers to each other.
          Note, however, that if s2 were already declared as a tag in an
          enclosing scope, the declaration D1 would refer to it, not to the tag
          s2 declared in D2. To eliminate this context sensitivity, the
          declaration struct s2; may be inserted ahead of D1. This declares a
          new tag s2 in the inner scope; the declaration D2 then completes the
          specification of the new type.
      4:
        title: Atomic type specifiers
        P1: |
          Syntax
          atomic-type-specifier:
            _Atomic ( type-name )
        P2: |
          Constraints
          Atomic type specifiers shall not be used if the implementation does
          not support atomic types (see 6.10.8.3).
        P3: >
          The type name in an atomic type specifier shall not refer to an array
          type, a function type, an atomic type, or a qualified type.
        P4: |
          Semantics
          The properties associated with atomic types are meaningful only for
          expressions that are lvalues. If the _Atomic keyword is immediately
          followed by a left parenthesis, it is interpreted as a type specifier
          (with a type name), not as a type qualifier.
    3:
      title: Type qualifiers
      P1: |
        Syntax
        type-qualifier:
          const
          restrict
          volatile
          _Atomic
      P2: |
        Constraints
        Types other than pointer types whose referenced type is an object type
        shall not be restrict-qualified.
      P3: >
        The type modified by the _Atomic qualifier shall not be an array type
        or a function type.
      P4: |
        Semantics
        The properties associated with qualified types are meaningful only for
        expressions that are lvalues.<foot>The implementation may place a const
        object that is not volatile in a read-only region of storage. Moreover,
        the implementation need not allocate storage for such an object if its
        address is never used.</foot>
      P5: >
        If the same qualifier appears more than once in the same
        specifier-qualifier-list, either directly or via one or more typedefs,
        the behavior is the same as if it appeared only once. If other
        qualifiers appear along with the _Atomic qualifier in a
        specifier-qualifier list, the resulting type is the so-qualified atomic
        type.
      P6: >
        If an attempt is made to modify an object defined with a
        const-qualified type through use of an lvalue with non-const-qualified
        type, the behavior is undefined. If an attempt is made to refer to an
        object defined with a volatile-qualified type through use of an lvalue
        with non-volatile-qualified type, the behavior is undefined.
        <foot>This applies to those objects that behave as if they were defined
        with qualified types, even if they are never actually defined as
        objects in the program (such as an object at a memory-mapped
        input/output address).</foot>
      P7: >
        An object that has volatile-qualified type may be modified in ways
        unknown to the implementation or have other unknown side effects.
        Therefore any expression referring to such an object shall be evaluated
        strictly according to the rules of the abstract machine, as described
        in 5.1.2.3. Furthermore, at every sequence point the value last stored
        in the object shall agree with that prescribed by the abstract machine,
        except as modified by the unknown factors mentioned
        previously.<foot>For example, a statement that assigns a value returned
        by malloc to a single pointer establishes this association between the
        allocated object and the pointer.</foot> What constitutes an access to
        an object that has volatile-qualified type is implementation-defined.
      P8: >
        An object that is accessed through a restrict-qualified pointer has a
        special association with that pointer. This association, defined in
        6.7.3.1 below, requires that all accesses to that object use, directly
        or indirectly, the value of that particular pointer.<foot>For example,
        a statement that assigns a value returned by malloc to a single pointer
        establishes this association between the allocated object and the
        pointer.</foot> The intended use of the restrict qualifier (like the
        register storage class) is to promote optimization, and deleting all
        instances of the qualifier from all preprocessing translation units
        composing a conforming program does not change its meaning (i.e.,
        observable behavior).
      P9: >
        If the specification of an array type includes any type qualifiers, the
        element type is soqualified, not the array type. If the specification
        of a function type includes any type qualifiers, the behavior is
        undefined.<foot>Both of these can occur through the use of typedefs.</foot>
      P10: |
        For two qualified types to be compatible, both shall have the
        identically qualified version of a compatible type; the order of type
        qualifiers within a list of specifiers or qualifiers does not affect
        the specified type.
      P11: |
        EXAMPLE 1
        An object declared
        extern const volatile int real_time_clock;
        may be modifiable by hardware, but cannot be assigned to, incremented,
        or decremented.
      P12: |
        EXAMPLE 2 The following declarations and expressions illustrate the
        behavior when type qualifiers modify an aggregate type:
        <code>
          const struct s { int mem; } cs = { 1 };
          struct s ncs; // the object ncs is modifiable
          typedef int A[2][3];
          const A a = {{4, 5, 6}, {7, 8, 9}}; // array of array of const int
          int *pi;
          const int *pci;
          ncs = cs;       // valid
          cs = ncs;       // violates modifiable lvalue constraint for =
          pi = &ncs.mem;  // valid
          pi = &cs.mem;   // violates type constraints for =
          pci = &cs.mem;  // valid
          pi = a[0];      // invalid: a[0] has type ‘‘const int *’’
        </code>
      P13: |
        EXAMPLE 3
        The declaration
        <code>
          _Atomic volatile int *p;
        </code>
        specifies that p has the type ‘‘pointer to volatile atomic int’’, a
        pointer to a volatile-qualified atomic type.
      1:
        title: Formal definition of restrict
        P1: >
          Let D be a declaration of an ordinary identifier that provides a means
          of designating an object P as a restrict-qualified pointer to type T.
        P2: >
          If D appears inside a block and does not have storage class extern,
          let B denote the block. If D appears in the list of parameter
          declarations of a function definition, let B denote the associated
          block. Otherwise, let B denote the block of main (or the block of
          whatever function is called at program startup in a freestanding
          environment).
        P3: >
          In what follows, a pointer expression E is said to be based on object
          P if (at some sequence point in the execution of B prior to the
          evaluation of E) modifying P to point to a copy of the array object
          into which it formerly pointed would change the value of E.<foot>In
          other words, E depends on the value of P itself rather than on the
          value of an object referenced indirectly through P. For example, if
          identifier p has type (int **restrict), then the pointer expressions
          p and p+1 are based on the restricted pointer object designated by p,
          but the pointer expressions *p and p[1] are not.</foot> Note that
          ‘‘based’’ is defined only for expressions with pointer types.
        P4: >
          During each execution of B, let L be any lvalue that has &L based on
          P. If L is used to access the value of the object X that it designates,
          and X is also modified (by any means), then the following requirements
          apply: T shall not be const-qualified. Every other lvalue used to
          access the value of X shall also have its address based on P. Every
          access that modifies X shall be considered also to modify P, for the
          purposes of this subclause. If P is assigned the value of a pointer
          expression E that is based on another restricted pointer object P2,
          associated with block B2, then either the execution of B2 shall begin
          before the execution of B, or the execution of B2 shall end prior to
          the assignment. If these requirements are not met, then the behavior
          is undefined.
        P5: >
          Here an execution of B means that portion of the execution of the
          program that would correspond to the lifetime of an object with
          scalar type and automatic storage duration associated with B.
        P6: >
          A translator is free to ignore any or all aliasing implications of
          uses of restrict.
        P7: |
          EXAMPLE 1
          The file scope declarations
          <code>
            int * restrict a;
            int * restrict b;
            extern int c[];
          </code>
          assert that if an object is accessed using one of a, b, or c, and
          that object is modified anywhere in the program, then it is never
          accessed using either of the other two.
        P8: |
          EXAMPLE 2
          The function parameter declarations in the following example
          <code>
            void f(int n, int * restrict p, int * restrict q)
            {
              while (n-- > 0)
              *p++ = *q++;
            }
          </code>
          assert that, during each execution of the function, if an object is
          accessed through one of the pointer parameters, then it is not also
          accessed through the other.
        P9: |
          The benefit of the restrict qualifiers is that they enable a
          translator to make an effective dependence analysis of function f
          without examining any of the calls of f in the program. The cost is
          that the programmer has to examine all of those calls to ensure that
          none give undefined behavior. For example, the second call of f in g
          has undefined behavior because each of d[1] through d[49] is accessed
          through both p and q.
          <code>
            void g(void)
            {
              extern int d[100];
              f(50, d + 50, d); // valid
              f(50, d + 1, d); // undefined behavior
            }
          <code>
        P10: |
          EXAMPLE 3
          The function parameter declarations
          <code>
            void h(int n, int * restrict p, int * restrict q, int * restrict r)
            {
              int i;
              for (i = 0; i < n; i++)
              p[i] = q[i] + r[i];
            }
          </code>
          illustrate how an unmodified object can be aliased through two
          restricted pointers. In particular, if a and b are disjoint arrays, a
          call of the form h(100, a, b, b) has defined behavior, because array
          b is not modified within function h.
        P11: |
          EXAMPLE 4 The rule limiting assignments between restricted pointers
          does not distinguish between a function call and an equivalent nested
          block. With one exception, only ‘‘outer-to-inner’’ assignments
          between restricted pointers declared in nested blocks have defined
          behavior.
          <code>
          {
            int * restrict p1;
            int * restrict q1;
            p1 = q1; // undefined behavior
            {
              int * restrict p2 = p1; // valid
              int * restrict q2 = q1; // valid
              p1 = q2; // undefined behavior
              p2 = q2; // undefined behavior
            }
          }
          </code>
        P12: |
          The one exception allows the value of a restricted pointer to be
          carried out of the block in which it (or, more precisely, the
          ordinary identifier used to designate it) is declared when that block
          finishes execution. For example, this permits new_vector to return a
          vector.
          <code>
            typedef struct { int n; float * restrict v; } vector;
            vector new_vector(int n)
            {
              vector t;
              t.n = n;
              t.v = malloc(n * sizeof (float));
              return t;
            }
          </code>
    4:
      title: Function specifiers
      P1: |
        Syntax
        function-specifier:
          inline
          _Noreturn
      P2: |
        Constraints
        Function specifiers shall be used only in the declaration of an
        identifier for a function.
      P3: >
        An inline definition of a function with external linkage shall not
        contain a definition of a modifiable object with static or thread
        storage duration, and shall not contain a reference to an identifier
        with internal linkage.
      P4: >
        In a hosted environment, no function specifier(s) shall appear in a
        declaration of main.
      P5: |
        Semantics
        A function specifier may appear more than once; the behavior is the
        same as if it appeared only once.
      P6: >
        A function declared with an inline function specifier is an inline
        function. Making a function an inline function suggests that calls to
        the function be as fast as possible.<foot>By using, for example, an
        alternative to the usual function call mechanism, such as ‘‘inline
        substitution’’. Inline substitution is not textual substitution, nor
        does it create a new function.  Therefore, for example, the expansion
        of a macro used within the body of the function uses the definition it
        had at the point the function body appears, and not where the function
        is called; and identifiers refer to the declarations in scope where the
        body occurs. Likewise, the function has a single address, regardless of
        the number of inline definitions that occur in addition to the external
        definition.</foot> The extent to which such suggestions are effective
        is implementation-defined.<foot>For example, an implementation might
        never perform inline substitution, or might only perform inline
        substitutions to calls in the scope of an inline declaration.</foot>
      P7: >
        Any function with internal linkage can be an inline function. For a
        function with external linkage, the following restrictions apply: If a
        function is declared with an inline function specifier, then it shall
        also be defined in the same translation unit. If all of the file scope
        declarations for a function in a translation unit include the inline
        function specifier without extern, then the definition in that
        translation unit is an inline definition. An inline definition does not
        provide an external definition for the function, and does not forbid an
        external definition in another translation unit. An inline definition
        provides an alternative to an external definition, which a translator may
        use to implement any call to the function in the same translation unit.
        It is unspecified whether a call to the function uses the inline
        definition or the external definition.<foot>Since an inline definition
        is distinct from the corresponding external definition and from any
        other corresponding inline definitions in other translation units, all
        corresponding objects with static storage duration are also distinct in
        each of the definitions.</foot>
      P8: >
        A function declared with a _Noreturn function specifier shall not
        return to its caller.
      P9: |
        Recommended practice
        The implementation should produce a diagnostic message for a function
        declared with a _Noreturn function specifier that appears to be capable
        of returning to its caller.
      P10: |
        EXAMPLE 1 The declaration of an inline function with external linkage
        can result in either an external definition, or a definition available
        for use only within the translation unit. A file scope declaration with
        extern creates an external definition. The following example shows an
        entire translation unit.
        <code>
          inline double fahr(double t)
          {
            return (9.0 * t) / 5.0 + 32.0;
          }
            inline double cels(double t)
          {
            return (5.0 * (t - 32.0)) / 9.0;
          }
          extern double fahr(double); // creates an external definition
          double convert(int is_fahr, double temp)
          {
          /* A translator may perform inline substitutions */
          return is_fahr ? cels(temp) : fahr(temp);
          }
        </code>
      P11: >
        Note that the definition of fahr is an external definition because fahr
        is also declared with extern, but the definition of cels is an inline
        definition. Because cels has external linkage and is referenced, an
        external definition has to appear in another translation unit (see
        6.9); the inline definition and the external definition are distinct
        and either may be used for the call.
      P12: |
        EXAMPLE 2
        <code>
          _Noreturn void f () {
            abort(); // ok
          }
          _Noreturn void g (int i) { // causes undefined behavior if i <= 0
            if (i > 0) abort();
          }
        </code>
    5:
      title: Alignment specifier
      P1: |
        Syntax
        alignment-specifier:
          _Alignas ( type-name )
          _Alignas ( constant-expression )
      P2: |
        Constraints
        An alignment attribute shall not be specified in a declaration of a
        typedef, or a bit-field, or a function, or a parameter, or an object
        declared with the register storage-class specifier.
      P3: >
        The constant expression shall be an integer constant expression. It
        shall evaluate to a valid fundamental alignment, or to a valid extended
        alignment supported by the implementation in the context in which it
        appears, or to zero.
      P4: >
        The combined effect of all alignment attributes in a declaration shall
        not specify an alignment that is less strict than the alignment that
        would otherwise be required for the type of the object or member being
        declared.
      P5: |
        Semantics
        The first form is equivalent to _Alignas (_Alignof (type-name)).
      P6: >
        The alignment requirement of the declared object or member is taken to
        be the specified alignment. An alignment specification of zero has no
        effect.<foot>An alignment specification of zero also does not affect
        other alignment specifications in the same declaration.</foot> When
        multiple alignment specifiers occur in a declaration, the effective
        alignment requirement is the strictest specified alignment.
      P7: >
        If the definition of an object has an alignment specifier, any other
        declaration of that object shall either specify equivalent alignment or
        have no alignment specifier. If the definition of an object does not
        have an alignment specifier, any other declaration of that object shall
        also have no alignment specifier. If declarations of an object in
        different translation units have different alignment specifiers, the
        behavior is undefined.
    6:
      title: Declarators
      P1: |
        Syntax
        declarator:
          pointeropt direct-declarator
        direct-declarator:
          identifier
          ( declarator )
          direct-declarator [ type-qualifier-listopt assignment-expressionopt ]
          direct-declarator [ static type-qualifier-listopt assignment-expression ]
          direct-declarator [ type-qualifier-list static assignment-expression ]
          direct-declarator [ type-qualifier-listopt * ]
          direct-declarator ( parameter-type-list )
          direct-declarator ( identifier-listopt )
        pointer:
          * type-qualifier-listopt
          * type-qualifier-listopt pointer
        type-qualifier-list:
          type-qualifier
          type-qualifier-list type-qualifier
        parameter-type-list:
          parameter-list
          parameter-list , ...
        parameter-list:
          parameter-declaration
          parameter-list , parameter-declaration
        parameter-declaration:
          declaration-specifiers declarator
          declaration-specifiers abstract-declaratoropt
        identifier-list:
          identifier
          identifier-list , identifier
      P2: |
        Semantics
        Each declarator declares one identifier, and asserts that when an
        operand of the same form as the declarator appears in an expression, it
        designates a function or object with the scope, storage duration, and
        type indicated by the declaration specifiers.
      P3: >
        A full declarator is a declarator that is not part of another
        declarator. The end of a full declarator is a sequence point. If, in
        the nested sequence of declarators in a full declarator, there is a
        declarator specifying a variable length array type, the type specified
        by the full declarator is said to be variably modified. Furthermore,
        any type derived by declarator type derivation from a variably modified
        type is itself variably modified.
      P4: |
        In the following subclauses, consider a declaration
        <code>
          T D1
        </code>
        where T contains the declaration specifiers that specify a type T (such
        as int) and D1 is a declarator that contains an identifier ident. The
        type specified for the identifier ident in the various forms of
        declarator is described inductively using this notation.
      P5: >
        If, in the declaration ‘‘T D1’’, D1 has the form identifier then the
        type specified for ident is T .
      P6: |
        If, in the declaration ‘‘T D1’’, D1 has the form
        <code>
        ( D )
        </code>
        then ident has the type specified by the declaration ‘‘T D’’. Thus, a
        declarator in parentheses is identical to the unparenthesized
        declarator, but the binding of complicated declarators may be altered
        by parentheses.
      P7: |
        Implementation limits
        As discussed in 5.2.4.1, an implementation may limit the number of
        pointer, array, and function declarators that modify an arithmetic,
        structure, union, or void type, either directly or via one or more
        typedefs.
      1:
        title: Pointer declarators
        P1: |
          Semantics
          If, in the declaration ‘‘T D1’’, D1 has the form
            * type-qualifier-listopt D
          and the type specified for ident in the declaration ‘‘T D’’ is
          ‘‘derived-declarator-type-list T ’’, then the type specified for
          ident is ‘‘derived-declarator-type-list type-qualifier-list pointer
          to T ’’. For each type qualifier in the list, ident is a so-qualified
          pointer.
        P2: >
          For two pointer types to be compatible, both shall be identically
          qualified and both shall be pointers to compatible types.
        P3: |
          EXAMPLE The following pair of declarations demonstrates the
          difference between a ‘‘variable pointer to a constant value’’ and a
          ‘‘constant pointer to a variable value’’.
          <code>
            const int *ptr_to_constant;
            int *const constant_ptr;
          </code>
          The contents of any object pointed to by ptr_to_constant shall not be
          modified through that pointer, but ptr_to_constant itself may be
          changed to point to another object. Similarly, the contents of the
          int pointed to by constant_ptr may be modified, but constant_ptr
          itself shall always point to the same location.
        P4: |
          The declaration of the constant pointer constant_ptr may be clarified
          by including a definition for the type ‘‘pointer to int’’.
          <code>
            typedef int *int_ptr;
            const int_ptr constant_ptr;
          </code>
          declares constant_ptr as an object that has type ‘‘const-qualified
          pointer to int’’.
      2:
        title: Array declarators
        P1: |
          Constraints
          In addition to optional type qualifiers and the keyword static, the [
          and ] may delimit an expression or *. If they delimit an expression
          (which specifies the size of an array), the expression shall have
          an integer type. If the expression is a constant expression, it
          shall have a value greater than zero. The element type shall not be
          an incomplete or function type. The optional type qualifiers and
          the keyword static shall appear only in a declaration of a function
          parameter with an array type, and then only in the outermost array
          type derivation.
        P2: >
          If an identifier is declared as having a variably modified type, it
          shall be an ordinary identifier (as defined in 6.2.3), have no
          linkage, and have either block scope or function prototype scope. If
          an identifier is declared to be an object with static or thread
          storage duration, it shall not have a variable length array type.
        P3: |
          Semantics
          If, in the declaration ‘‘T D1’’, D1 has one of the forms:
            D[ type-qualifier-listopt assignment-expressionopt ]
            D[ static type-qualifier-listopt assignment-expression ]
            D[ type-qualifier-list static assignment-expression ]
            D[ type-qualifier-listopt * ]
          and the type specified for ident in the declaration ‘‘T D’’ is
          ‘‘derived-declarator-type-list T ’’, then the type specified for
          ident is ‘‘derived-declarator-type-list array of T ’’.<foot>When
          several ‘‘array of’’ specifications are adjacent, a multidimensional
          array is declared.</foot> (See 6.7.6.3 for the meaning of the
          optional type qualifiers and the keyword static.)
        P4: >
          If the size is not present, the array type is an incomplete type. If
          the size is * instead of being an expression, the array type is a
          variable length array type of unspecified size, which can only be
          used in declarations or type names with function prototype
          scope;<foot>Thus, * can be used only in function declarations that
          are not definitions (see 6.7.6.3).</foot> such arrays are nonetheless
          complete types. If the size is an integer constant expression and the
          element type has a known constant size, the array type is not a
          variable length array type; otherwise, the array type is a variable
          length array type. (Variable length arrays are a conditional feature
          that implementations need not support; see 6.10.8.3.)
        P5: >
          If the size is an expression that is not an integer constant
          expression: if it occurs in a declaration at function prototype scope,
          it is treated as if it were replaced by *; otherwise, each time it is
          evaluated it shall have a value greater than zero. The size of each
          instance of a variable length array type does not change during its
          lifetime. Where a size expression is part of the operand of a sizeof
          operator and changing the value of the size expression would not affect
          the result of the operator, it is unspecified whether or not the size
          expression is evaluated.
        P6: >
          For two array types to be compatible, both shall have compatible
          element types, and if both size specifiers are present, and are
          integer constant expressions, then both size specifiers shall have
          the same constant value. If the two array types are used in a context
          which requires them to be compatible, it is undefined behavior if the
          two size specifiers evaluate to unequal values.
        P7: |
          EXAMPLE 1
          <code>
            float fa[11], *afp[17];
          </code>
          declares an array of float numbers and an array of pointers to float
          numbers.
        P8: |
          EXAMPLE 2
          Note the distinction between the declarations
          <code>
            extern int *x;
            extern int y[];
          </code>
          The first declares x to be a pointer to int; the second declares y to
          be an array of int of unspecified size (an incomplete type), the
          storage for which is defined elsewhere.
        P9: |
          EXAMPLE 3
          The following declarations demonstrate the compatibility rules for
          variably modified types.
          <code>
            extern int n;
            extern int m;
            void fcompat(void)
            {
              int a[n][6][m];
              int (*p)[4][n+1];
              int c[n][n][6][m];
              int (*r)[n][n][n+1];
              p = a; // invalid: not compatible because 4 != 6
              r = c; // compatible, but defined behavior only if
                     // n == 6 and m == n+1
            }
          </code>
        P10: |
          EXAMPLE 4 All declarations of variably modified (VM) types have to be
          at either block scope or function prototype scope. Array objects
          declared with the _Thread_local, static, or extern storage-class
          specifier cannot have a variable length array (VLA) type. However, an
          object declared with the static storage-class specifier can have a VM
          type (that is, a pointer to a VLA type). Finally, all identifiers
          declared with a VM type have to be ordinary identifiers and cannot,
          therefore, be members of structures or unions.
          <code>
          extern int n;
          int A[n];            // invalid: file scope VLA
          extern int (*p2)[n]; // invalid: file scope VM
          int B[100];          // valid: file scope but not VM

          void fvla(int m, int C[m][m]); // valid: VLA with prototype scope

          void fvla(int m, int C[m][m]) // valid: adjusted to auto pointer to VLA 
          {
            typedef int VLA[m][m];      // valid: block scope typedef VLA

            struct tag {
              int (*y)[n];             // invalid: y not ordinary identifier
              int z[n];                // invalid: z not ordinary identifier
            };
            int D[m];                  // valid: auto VLA
            static int E[m];           // invalid: static block scope VLA
            extern int F[m];           // invalid: F has linkage and is VLA
            int (*s)[m];               // valid: auto pointer to VLA
            extern int (*r)[m];        // invalid: r has linkage and points to VLA
            static int (*q)[m] = &B;   // valid: q is a static block pointer to VLA
          }
          </code>
      3:
        title: Function declarators (including prototypes)
        P1: |
          Constraints
          A function declarator shall not specify a return type that is a
          function type or an array type.
        P2: >
          The only storage-class specifier that shall occur in a parameter
          declaration is register.
        P3: >
          An identifier list in a function declarator that is not part of a
          definition of that function shall be empty.
        P4: >
          After adjustment, the parameters in a parameter type list in a
          function declarator that is part of a definition of that function
          shall not have incomplete type.
        P5: |
          Semantics
          If, in the declaration ‘‘T D1’’, D1 has the form
            D( parameter-type-list )
          or
            D( identifier-listopt )
          and the type specified for ident in the declaration ‘‘T D’’ is
          ‘‘derived-declarator-type-list T ’’, then the type specified for
          ident is ‘‘derived-declarator-type-list function returning T ’’.
        P6: >
          A parameter type list specifies the types of, and may declare
          identifiers for, the parameters of the function.
        P7: >
          A declaration of a parameter as ‘‘array of type’’ shall be adjusted
          to ‘‘qualified pointer to type’’, where the type qualifiers (if any)
          are those specified within the [ and ] of the array type derivation.
          If the keyword static also appears within the [ and ] of the array
          type derivation, then for each call to the function, the value of the
          corresponding actual argument shall provide access to the first
          element of an array with at least as many elements as specified by
          the size expression.
        P8: >
          A declaration of a parameter as ‘‘function returning type’’ shall be
          adjusted to ‘‘pointer to function returning type’’, as in 6.3.2.1.
        P9: >
          If the list terminates with an ellipsis (, ...), no information about
          the number or types of the parameters after the comma is
          supplied.<foot>The macros defined in the <stdarg.h> header (7.16) may
          be used to access arguments that correspond to the ellipsis.</foot>
        P10: >
          The special case of an unnamed parameter of type void as the only
          item in the list specifies that the function has no parameters.
        P11: >
          If, in a parameter declaration, an identifier can be treated either
          as a typedef name or as a parameter name, it shall be taken as a
          typedef name.
        P12: >
          If the function declarator is not part of a definition of that
          function, parameters may have incomplete type and may use the [*]
          notation in their sequences of declarator specifiers to specify
          variable length array types.
        P13: >
          The storage-class specifier in the declaration specifiers for a
          parameter declaration, if present, is ignored unless the declared
          parameter is one of the members of the parameter type list for a
          function definition.
        P14: >
          An identifier list declares only the identifiers of the parameters of
          the function. An empty list in a function declarator that is part of
          a definition of that function specifies that the function has no
          parameters. The empty list in a function declarator that is not part
          of a definition of that function specifies that no information about
          the number or types of the parameters is supplied.
          <foot>See ‘‘future language directions’’ (6.11.6).</foot>
        P15: >
          For two function types to be compatible, both shall specify
          compatible return types.<foot>If both function types are ‘‘old
          style’’, parameter types are not compared.</foot> Moreover, the
          parameter type lists, if both are present, shall agree in the number
          of parameters and in use of the ellipsis terminator; corresponding
          parameters shall have compatible types. If one type has a parameter
          type list and the other type is specified by a function declarator
          that is not part of a function definition and that contains an empty
          identifier list, the parameter list shall not have an ellipsis
          terminator and the type of each parameter shall be compatible with
          the type that results from the application of the default argument
          promotions. If one type has a parameter type list and the other type
          is specified by a function definition that contains a (possibly
          empty) identifier list, both shall agree in the number of parameters,
          and the type of each prototype parameter shall be compatible with the
          type that results from the application of the default argument
          promotions to the type of the corresponding identifier. (In the
          determination of type compatibility and of a composite type, each
          parameter declared with function or array type is taken as having the
          adjusted type and each parameter declared with qualified type is
          taken as having the unqualified version of its declared type.)
        P16: |
          EXAMPLE 1
          The declaration
          <code>
            int f(void), *fip(), (*pfi)();
          </code>
          declares a function f with no parameters returning an int, a function
          fip with no parameter specification returning a pointer to an int,
          and a pointer pfi to a function with no parameter specification
          returning an int. It is especially useful to compare the last two.
          The binding of *fip() is *(fip()), so that the declaration suggests,
          and the same construction in an expression requires, the calling of a
          function fip, and then using indirection through the pointer result
          to yield an int. In the declarator (*pfi)(), the extra parentheses
          are necessary to indicate that indirection through a pointer to a
          function yields a function designator, which is then used to call the
          function; it returns an int.
        P17: >
          If the declaration occurs outside of any function, the identifiers
          have file scope and external linkage. If the declaration occurs
          inside a function, the identifiers of the functions f and fip have
          block scope and either internal or external linkage (depending on
          what file scope declarations for these identifiers are visible), and
          the identifier of the pointer pfi has block scope and no linkage.
        P18: |
          EXAMPLE 2
          The declaration
          <code>
            int (*apfi[3])(int *x, int *y);
          </code>
          declares an array apfi of three pointers to functions returning int.
          Each of these functions has two parameters that are pointers to int.
          The identifiers x and y are declared for descriptive purposes only
          and go out of scope at the end of the declaration of apfi.
        P19: |
          EXAMPLE 3
          The declaration
          <code>
            int (*fpfi(int (*)(long), int))(int, ...);
          </code>
          declares a function fpfi that returns a pointer to a function
          returning an int. The function fpfi has two parameters: a pointer to a
          function returning an int (with one parameter of type long int), and an
          int.  The pointer returned by fpfi points to a function that has one
          int parameter and accepts zero or more additional arguments of any
          type.
        P20: |
          EXAMPLE 4
          The following prototype has a variably modified parameter.
          <code>
            void addscalar(int n, int m,
              double a[n][n*m+300], double x);
            int main()
            {
              double b[4][308];
              addscalar(4, 2, b, 2.17);
              return 0;
            }
            void addscalar(int n, int m,
              double a[n][n*m+300], double x)
            {
            for (int i = 0; i < n; i++)
              for (int j = 0, k = n*m+300; j < k; j++)
                // a is a pointer to a VLA with n*m+300 elements
                a[i][j] += x;
            }
          </code>
        P21: |
          EXAMPLE 5
          The following are all compatible function prototype declarators.
          <code>
            double maximum(int n, int m, double a[n][m]);
            double maximum(int n, int m, double a[*][*]);
            double maximum(int n, int m, double a[ ][*]);
            double maximum(int n, int m, double a[ ][m]);
          </code>
          as are:
          <code>
            void f(double (* restrict a)[5]);
            void f(double a[restrict][5]);
            void f(double a[restrict 3][5]);
            void f(double a[restrict statuc 3][5]);
          </code>
          (Note that the last declaration also specifies that the argument
          corresponding to a in any call to f must be a non-null pointer to the
          first of at least three arrays of 5 doubles, which the others do
          not.)
    7:
      title: Type names
      P1: |
        Syntax
        type-name:
          specifier-qualifier-list abstract-declaratoropt
        abstract-declarator:
          pointer
          pointeropt direct-abstract-declarator
        direct-abstract-declarator:
          ( abstract-declarator )
          direct-abstract-declaratoropt [ type-qualifier-listopt
          assignment-expressionopt ]
          direct-abstract-declaratoropt [ static type-qualifier-listopt
          assignment-expression ]
          direct-abstract-declaratoropt [ type-qualifier-list static
          assignment-expression ]
          direct-abstract-declaratoropt [ * ]
          direct-abstract-declaratoropt ( parameter-type-listopt )
      P2: |
        Semantics
        In several contexts, it is necessary to specify a type. This is
        accomplished using a type name, which is syntactically a declaration
        for a function or an object of that type that omits the identifier.
        <foot>As indicated by the syntax, empty parentheses in a type name are
        interpreted as ‘‘function with no parameter specification’’, rather
        than redundant parentheses around the omitted identifier.</foot>
      P3: |
        EXAMPLE
        The constructions
        (a) int
        (b) int *
        (c) int *[3]
        (d) int (*)[3]
        (e) int (*)[*]
        (f) int *()
        (g) int (*) (void)
        (h) int (*const []) (unsigned int, ...)
        name respectively the types (a) int, (b) pointer to int, (c) array of
        three pointers to int, (d) pointer to an array of three ints, (e)
        pointer to a variable length array of an unspecified number of ints,
        (f) function with no parameter specification returning a pointer to
        int, (g) pointer to function with no parameters returning an int, and
        (h) array of an unspecified number of constant pointers to functions,
        each with one parameter that has type unsigned int and an unspecified
        number of other parameters, returning an int.
    8:
      title: Type definitions
      P1: |
        Syntax
        typedef-name:
          identifier
      P2: |
        Constraints
        If a typedef name specifies a variably modified type then it shall have
        block scope.
      P3: |
        Semantics
        In a declaration whose storage-class specifier is typedef, each
        declarator defines an identifier to be a typedef name that denotes the
        type specified for the identifier in the way described in 6.7.6. Any
        array size expressions associated with variable length array
        declarators are evaluated each time the declaration of the typedef name
        is reached in the order of execution. A typedef declaration does not
        introduce a new type, only a synonym for the type so specified. That
        is, in the following declarations:
        <code>
          typedef T type_ident;
          type_ident D;
        </code>
        type_ident is defined as a typedef name with the type specified by the
        declaration specifiers in T (known as T ), and the identifier in D has
        the type ‘‘derived-declaratortype-list T ’’ where the
        derived-declarator-type-list is specified by the declarators of D. A
        typedef name shares the same name space as other identifiers declared
        in ordinary declarators.
      P4: |
        EXAMPLE 1
        After
        <code>
          typedef int MILES, KLICKSP();
          typedef struct { double hi, lo; } range;
        </code>
        the constructions
        <code>
          MILES distance;
          extern KLICKSP *metricp;
          range x;
          range z, *zp;
        </code>
        are all valid declarations. The type of distance is int, that of
        metricp is ‘‘pointer to function with no parameter specification
        returning int’’, and that of x and z is the specified structure; zp is
        a pointer to such a structure. The object distance has a type
        compatible with any other int object.
      P5: |
        EXAMPLE 2
        After the declarations
        <code>
          typedef struct s1 { int x; } t1, *tp1;
          typedef struct s2 { int x; } t2, *tp2;
        </code>
        type t1 and the type pointed to by tp1 are compatible. Type t1 is also
        compatible with type struct s1, but not compatible with the types
        struct s2, t2, the type pointed to by tp2, or int.
      P6: |
        EXAMPLE 3
        The following obscure constructions
        <code>
          typedef signed int t;
          typedef int plain;
          struct tag {
            unsigned t:4;
            const t:5;
            plain r:5;
          };
        </code>
        declare a typedef name t with type signed int, a typedef name plain
        with type int, and a structure with three bit-field members, one named
        t that contains values in the range [0, 15], an unnamed constqualified
        bit-field which (if it could be accessed) would contain values in
        either the range [−15, +15] or [−16, +15], and one named r that
        contains values in one of the ranges [0, 31], [−15, +15], or [−16,
        +15].  (The choice of range is implementation-defined.) The first two
        bit-field declarations differ in that unsigned is a type specifier
        (which forces t to be the name of a structure member), while const is a
        type qualifier (which modifies t which is still visible as a typedef
        name). If these declarations are followed in an inner scope by
        <code>
          t f(t (t));
          long t;
        </code>
        then a function f is declared with type ‘‘function returning signed int
        with one unnamed parameter with type pointer to function returning
        signed int with one unnamed parameter with type signed int’’, and an
        identifier t with type long int.
      P7: |
        EXAMPLE 4 On the other hand, typedef names can be used to improve code
        readability. All three of the following declarations of the signal
        function specify exactly the same type, the first without making use of
        any typedef names.
        <code>
          typedef void fv(int), (*pfv)(int);
          void (*signal(int, void (*)(int)))(int);
          fv *signal(int, fv *);
          pfv signal(int, pfv);
        </code>
      P8: |
        EXAMPLE 5 If a typedef name denotes a variable length array type, the
        length of the array is fixed at the time the typedef name is defined, not
        each time it is used:
        <code>
          void copyt(int n)
          {
            typedef int B[n]; // B is n ints, n evaluated now
            n += 1;
            B a;              // a is n ints, n without += 1
            int b[n];         // a and b are different sizes
            for (int i = 1; i < n; i++)
              a[i-1] = b[i];
          }
        </code>
    9:
      title: Initialization
      P1: |
        Syntax
        initializer:
          assignment-expression
          { initializer-list }
          { initializer-list , }
        initializer-list:
          designationopt initializer
          initializer-list , designationopt initializer
        designation:
          designator-list =
        designator-list:
          designator
          designator-list designator
        designator:
          [ constant-expression ]
          . identifier
      P2: |
        Constraints
        No initializer shall attempt to provide a value for an object not
        contained within the entity being initialized.
      P3: >
        The type of the entity to be initialized shall be an array of unknown
        size or a complete object type that is not a variable length array
        type.
      P4: >
        All the expressions in an initializer for an object that has static or
        thread storage duration shall be constant expressions or string
        literals.
      P5: >
        If the declaration of an identifier has block scope, and the identifier
        has external or internal linkage, the declaration shall have no
        initializer for the identifier.
      P6: |
        If a designator has the form
          [ constant-expression ]
        then the current object (defined below) shall have array type and the
        expression shall be an integer constant expression. If the array is of
        unknown size, any nonnegative value is valid.
      P7: |
        If a designator has the form
          . identifier
        then the current object (defined below) shall have structure or union
        type and the identifier shall be the name of a member of that type.
      P8: |
        Semantics
        An initializer specifies the initial value stored in an object.
      P9: >
        Except where explicitly stated otherwise, for the purposes of this
        subclause unnamed members of objects of structure and union type do not
        participate in initialization.  Unnamed members of structure objects
        have indeterminate value even after initialization.
      P10: |
        If an object that has automatic storage duration is not initialized
        explicitly, its value is indeterminate. If an object that has static or
        thread storage duration is not initialized explicitly, then:
        — if it has pointer type, it is initialized to a null pointer;
        — if it has arithmetic type, it is initialized to (positive or
        unsigned) zero;
        — if it is an aggregate, every member is initialized (recursively)
        according to these rules, and any padding is initialized to zero bits;
        — if it is a union, the first named member is initialized (recursively)
        according to these rules, and any padding is initialized to zero bits;
      P11: >
        The initializer for a scalar shall be a single expression, optionally
        enclosed in braces. The initial value of the object is that of the
        expression (after conversion); the same type constraints and
        conversions as for simple assignment apply, taking the type of the
        scalar to be the unqualified version of its declared type.
      P12: >
        The rest of this subclause deals with initializers for objects that
        have aggregate or union type.
      P13: >
        The initializer for a structure or union object that has automatic
        storage duration shall be either an initializer list as described
        below, or a single expression that has compatible structure or union
        type. In the latter case, the initial value of the object, including
        unnamed members, is that of the expression.
      P14: >
        An array of character type may be initialized by a character string
        literal or UTF−8 string literal, optionally enclosed in braces.
        Successive bytes of the string literal (including the terminating null
        character if there is room or if the array is of unknown size)
        initialize the elements of the array.
      P15: >
        An array with element type compatible with a qualified or unqualified
        version of wchar_t, char16_t, or char32_t may be initialized by a wide
        string literal with the corresponding encoding prefix (L, u, or U,
        respectively), optionally enclosed in braces. Successive wide
        characters of the wide string literal (including the terminating null
        wide character if there is room or if the array is of unknown size)
        initialize the elements of the array.
      P16: >
        Otherwise, the initializer for an object that has aggregate or union
        type shall be a braceenclosed list of initializers for the elements or
        named members.
      P17: >
        Each brace-enclosed initializer list has an associated current object.
        When no designations are present, subobjects of the current object are
        initialized in order according to the type of the current object: array
        elements in increasing subscript order, structure members in declaration
        order, and the first named member of a union.<foot>If the initializer
        list for a subaggregate or contained union does not begin with a left
        brace, its subobjects are initialized as usual, but the subaggregate or
        contained union does not become the current object: current objects are
        associated only with brace-enclosed initializer lists.</foot> In
        contrast, a designation causes the following initializer to begin
        initialization of the subobject described by the designator.
        Initialization then continues forward in order, beginning with the next
        subobject after that described by the designator.<foot>After a union
        member is initialized, the next object is not the next member of the
        union; instead, it is the next subobject of an object containing the
        union.</foot>
      P18: >
        Each designator list begins its description with the current object
        associated with the closest surrounding brace pair. Each item in the
        designator list (in order) specifies a particular member of its current
        object and changes the current object for the next designator (if any)
        to be that member.<foot>Thus, a designator can only specify a strict
        subobject of the aggregate or union that is associated with the
        surrounding brace pair. Note, too, that each separate designator list
        is independent.</foot> The current object that results at the end of
        the designator list is the subobject to be initialized by the following
        initializer.
      P19: >
        The initialization shall occur in initializer list order, each
        initializer provided for a particular subobject overriding any
        previously listed initializer for the same subobject;<foot>Any
        initializer for the subobject which is overridden and so not used to
        initialize that subobject might not be evaluated at all.</foot> all
        subobjects that are not initialized explicitly shall be initialized
        implicitly the same as objects that have static storage duration.
      P20: >
        If the aggregate or union contains elements or members that are
        aggregates or unions, these rules apply recursively to the
        subaggregates or contained unions. If the initializer of a subaggregate
        or contained union begins with a left brace, the initializers enclosed
        by that brace and its matching right brace initialize the elements or
        members of the subaggregate or the contained union. Otherwise, only
        enough initializers from the list are taken to account for the elements
        or members of the subaggregate or the first member of the contained
        union; any remaining initializers are left to initialize the next
        element or member of the aggregate of which the current subaggregate or
        contained union is a part.
      P21: >
        If there are fewer initializers in a brace-enclosed list than there are
        elements or members of an aggregate, or fewer characters in a string
        literal used to initialize an array of known size than there are
        elements in the array, the remainder of the aggregate shall be
        initialized implicitly the same as objects that have static storage
        duration.
      P22: >
        If an array of unknown size is initialized, its size is determined by
        the largest indexed element with an explicit initializer. The array
        type is completed at the end of its initializer list.
      P23: >
        The evaluations of the initialization list expressions are
        indeterminately sequenced with respect to one another and thus the
        order in which any side effects occur is unspecified.<foot>In
        particular, the evaluation order need not be the same as the order of
        subobject initialization.</foot>
      P24: |
        EXAMPLE 1
        Provided that <complex.h> has been \#included, the declarations
        <code>
          int i = 3.5;
          double complex c = 5 + 3 * I;
        </code>
        define and initialize i with the value 3 and c with the value 5. 0 + i3. 0.
      P25: |
        EXAMPLE 2
        The declaration
        <code>
          int x[] = { 1, 3, 5 };
        </code>
        defines and initializes x as a one-dimensional array object that has
        three elements, as no size was specified and there are three
        initializers.
      P26: |
        EXAMPLE 3
        The declaration
        <code>
          int y[4][3] =
            { 1, 3, 5 },
            { 2, 4, 6 },
            { 3, 5, 7 },
          };
        <code>
        is a definition with a fully bracketed initialization: 1, 3, and 5
        initialize the first row of y (the array object y[0]), namely y[0][0],
        y[0][1], and y[0][2]. Likewise the next two lines initialize y[1] and
        y[2]. The initializer ends early, so y[3] is initialized with zeros.
        Precisely the same effect could have been achieved by
        <code>
          int y[4][3] = {
            1, 3, 5, 2, 4, 6, 3, 5, 7
          };
        </code>
        The initializer for y[0] does not begin with a left brace, so three
        items from the list are used. Likewise the next three are taken
        successively for y[1] and y[2].
      P27: |
        EXAMPLE 4
        The declaration
        <code>
          int z[4][3] = {
            { 1 }, { 2 }, { 3 }, { 4 }
          };
        </code>
        initializes the first column of z as specified and initializes the rest
        with zeros.
      P28: |
        EXAMPLE 5
        The declaration
        <code>
          struct { int a[3], b; } w[] = { { 1 }, 2 };
        </code>
        is a definition with an inconsistently bracketed initialization. It
        defines an array with two element structures: w[0].a[0] is 1 and
        w[1].a[0] is 2; all the other elements are zero.
      P29: |
        EXAMPLE 6
        The declaration
        <code>
          short q[4][3][2] = {
            { 1 },
            { 2, 3 },
            { 4, 5, 6 }
          };
        </code>
        contains an incompletely but consistently bracketed initialization. It
        defines a three-dimensional array object: q[0][0][0] is 1, q[1][0][0] is
        2, q[1][0][1] is 3, and 4, 5, and 6 initialize q[2][0][0], q[2][0][1],
        and q[2][1][0], respectively; all the rest are zero. The initializer for
        q[0][0] does not begin with a left brace, so up to six items from the
        current list may be used. There is only one, so the values for the
        remaining five elements are initialized with zero. Likewise, the
        initializers for q[1][0] and q[2][0] do not begin with a left brace, so
        each uses up to six items, initializing their respective two-dimensional
        subaggregates. If there had been more than six items in any of the lists,
        a diagnostic message would have been issued. The same initialization
        result could have been achieved by:
        <code>
          short q[4][3][2] = {
            1, 0, 0, 0, 0, 0,
            2, 3, 0, 0, 0, 0,
            4, 5, 6
          };
        </code>
        or by:
        <code>
          short q[4][3][2] = {
          {
              { 1 },
            },
            {
              { 2, 3 },
            },
            {
              { 4, 5 },
              { 6 },
          }
        };
        </code>
        in a fully bracketed form.
      P30: |
        Note that the fully bracketed and minimally bracketed forms of
        initialization are, in general, less likely to cause confusion.
      P31: |
        EXAMPLE 7
        One form of initialization that completes array types involves typedef
        names. Given the declaration
        <code>
          typedef int A[]; // OK - declared with block scope
        </code>
        the declaration
        <code>
          A a = { 1, 2 }, b = { 3, 4, 5 };
        </code>
        is identical to
        <code>
          int a[] = { 1, 2 }, b[] = { 3, 4, 5 };
        </code>
        due to the rules for incomplete types.
      P32: |
        EXAMPLE 8
        The declaration
        <code>
          char s[] = "abc", t[3] = "abc";
        </code>
        defines ‘‘plain’’ char array objects s and t whose elements are
        initialized with character string literals.  This declaration is
        identical to
        <code>
          char s[] = { 'a', 'b', 'c', '\0' },
          t[] = { 'a', 'b', 'c' };
        </code>
        The contents of the arrays are modifiable. On the other hand, the
        declaration
        <code>
          char *p = "abc";
        </code>
        defines p with type ‘‘pointer to char’’ and initializes it to point to
        an object with type ‘‘array of char’’ with length 4 whose elements are
        initialized with a character string literal. If an attempt is made to
        use p to modify the contents of the array, the behavior is undefined.
      P33: |
        EXAMPLE 9
        Arrays can be initialized to correspond to the elements of an
        enumeration by using designators:
        <code>
          enum { member_one,
            const char *nm[] = {
            [member_two] = "member two",
            [member_one] = "member one",
          };
        <code>
      P34: |
        EXAMPLE 10
        Structure members can be initialized to nonzero values without
        depending on their order:
        <code>
          div_t answer = { .quot = 2, .rem = -1 };
        </code>
      P35: |
        EXAMPLE 11 Designators can be used to provide explicit initialization
        when unadorned initializer lists might be misunderstood:
        <code>
          struct { int a[3], b; } w[] =
            { [0].a = {1}, [1].a[0] = 2 };
        </code>
      P36: |
        EXAMPLE 12
        Space can be ‘‘allocated’’ from both ends of an array by using a single
        designator:
        <code>
          int a[MAX] = {
            1, 3, 5, 7, 9, [MAX-5] = 8, 6, 4, 2, 0
          };
        </code>
      P37: |
        In the above, if MAX is greater than ten, there will be some
        zero-valued elements in the middle; if it is less than ten, some of the
        values provided by the first five initializers will be overridden by
        the second five.
      P38: |
        EXAMPLE 13
        Any member of a union can be initialized:
        <code>
          union { /* ... */ } u = { .any_member = 42 };
        </code>
    10:
      title: Static assertions
      P1: |
        Syntax
        static_assert-declaration:
          _Static_assert ( constant-expression , string-literal ) ;
      P2: |
        Constraints
        The constant expression shall compare unequal to 0.
      P3: |
        Semantics
        The constant expression shall be an integer constant expression. If the
        value of the constant expression compares unequal to 0, the declaration
        has no effect. Otherwise, the constraint is violated and the
        implementation shall produce a diagnostic message that includes the
        text of the string literal, except that characters not in the basic
        source character set are not required to appear in the message.
  8:
    title: Statements and blocks
    P1: |
      Syntax
      statement:
        labeled-statement
        compound-statement
        expression-statement
        selection-statement
        iteration-statement
        jump-statement
    P2: |
      Semantics
      A statement specifies an action to be performed. Except as indicated,
      statements are executed in sequence.
    P3: >
      A block allows a set of declarations and statements to be grouped into
      one syntactic unit.  The initializers of objects that have automatic
      storage duration, and the variable length array declarators of ordinary
      identifiers with block scope, are evaluated and the values are stored in
      the objects (including storing an indeterminate value in objects without
      an initializer) each time the declaration is reached in the order of
      execution, as if it were a statement, and within each declaration in the
      order that declarators appear.
    P4: >
      A full expression is an expression that is not part of another expression
      or of a declarator.  Each of the following is a full expression: an
      initializer that is not part of a compound literal; the expression in an
      expression statement; the controlling expression of a selection statement
      (if or switch); the controlling expression of a while or do statement; each
      of the (optional) expressions of a for statement; the (optional) expression
      in a return statement. There is a sequence point between the evaluation of
      a full expression and the evaluation of the next full expression to be
      evaluated.
    1:
      title: Labeled statements
      P1: |
        Syntax
        labeled-statement:
          identifier : statement
          case constant-expression : statement
          default : statement
      P2: |
        Constraints
        A case or default label shall appear only in a switch statement.
        Further constraints on such labels are discussed under the switch
        statement.
      P3: >
        Label names shall be unique within a function.
      P4: |
        Semantics
        Any statement may be preceded by a prefix that declares an identifier
        as a label name.  Labels in themselves do not alter the flow of
        control, which continues unimpeded across them.
    2:
      title: Compound statement
      P1: |
        Syntax
        compound-statement:
          { block-item-listopt }
        block-item-list:
          block-item
          block-item-list block-item
        block-item:
          declaration
          statement
      P2: |
        Semantics
        A compound statement is a block.
    3:
      title: Expression and null statements
      P1: |
        Syntax
        expression-statement:
          expressionopt ;
      P2: |
        Semantics
        The expression in an expression statement is evaluated as a void
        expression for its side effects.<foot>Such as assignments, and function
        calls which have side effects.</foot>
      P3: >
        A null statement (consisting of just a semicolon) performs no operations.
      P4: |
        EXAMPLE 1 If a function call is evaluated as an expression statement
        for its side effects only, the discarding of its value may be made
        explicit by converting the expression to a void expression by means of a
        cast:
        <code>
          int p(int);
          /* ... */
          (void)p(0);
        </code>
      P5: |
        EXAMPLE 2
        In the program fragment
        <code>
          char *s;
          /* ... */
          while (*s++ != '\0')
            ;
        </code>
        a null statement is used to supply an empty loop body to the iteration
        statement.
      P6: |
        EXAMPLE 3
        A null statement may also be used to carry a label just before the
        closing } of a compound statement.
        <code>
          while (loop1) {
            /* ... */
            while (loop2) {
              /* ... */
              if (want_out)
                goto end_loop1;
              /* ... */
            }
            /* ... */
          end_loop1: ;
          }
        </code>

    4:
      title: Selection statements
      P1: |
        Syntax
        selection-statement:
          if ( expression ) statement
          if ( expression ) statement else statement
          switch ( expression ) statement
      P2: |
        Semantics
        A selection statement selects among a set of statements depending on
        the value of a controlling expression.
      P3: >
        A selection statement is a block whose scope is a strict subset of the
        scope of its enclosing block. Each associated substatement is also a
        block whose scope is a strict subset of the scope of the selection
        statement.
      1:
        title: The if statement
        P1: |
          Constraints
          The controlling expression of an if statement shall have scalar type.
        P2: |
          Semantics
          In both forms, the first substatement is executed if the expression
          compares unequal to 0.  In the else form, the second substatement is
          executed if the expression compares equal to 0. If the first
          substatement is reached via a label, the second substatement is not
          executed.
        P3: >
          An else is associated with the lexically nearest preceding if that is
          allowed by the syntax.
      2:
        title: The switch statement
        P1: |
          Constraints
          The controlling expression of a switch statement shall have integer type.
        P2: >
          If a switch statement has an associated case or default label within
          the scope of an identifier with a variably modified type, the entire
          switch statement shall be within the scope of that identifier.
          <foot>That is, the declaration either precedes the switch statement,
          or it follows the last case or default label associated with the
          switch that is in the block containing the declaration.</foot>
        P3: >
          The expression of each case label shall be an integer constant
          expression and no two of the case constant expressions in the same
          switch statement shall have the same value after conversion. There
          may be at most one default label in a switch statement.  (Any
          enclosed switch statement may have a default label or case constant
          expressions with values that duplicate case constant expressions in
          the enclosing switch statement.)
        P4: |
          Semantics
          A switch statement causes control to jump to, into, or past the
          statement that is the switch body, depending on the value of a
          controlling expression, and on the presence of a default label and
          the values of any case labels on or in the switch body. A case or
          default label is accessible only within the closest enclosing switch
          statement.
        P5: >
          The integer promotions are performed on the controlling expression.
          The constant expression in each case label is converted to the
          promoted type of the controlling expression. If a converted value
          matches that of the promoted controlling expression, control jumps to
          the statement following the matched case label. Otherwise, if there
          is a default label, control jumps to the labeled statement. If no
          converted case constant expression matches and there is no default
          label, no part of the switch body is executed.
        P6: |
          Implementation limits
          As discussed in 5.2.4.1, the implementation may limit the number of
          case values in a switch statement.
        P7: |
          EXAMPLE
          In the artificial program fragment
          <code>
            switch (expr)
            {
              int i = 4;
              f(i);
            case 0:
              i = 17;
              /* falls through into default code */
            default:
              printf("%d\n", i);
            }
          </code>
          the object whose identifier is i exists with automatic storage
          duration (within the block) but is never initialized, and thus if the
          controlling expression has a nonzero value, the call to the printf
          function will access an indeterminate value. Similarly, the call to
          the function f cannot be reached.
    5:
      title: Iteration statements
      P1: |
        Syntax
        iteration-statement:
          while ( expression ) statement
          do statement while ( expression ) ;
          for ( expressionopt ; expressionopt ; expressionopt ) statement
          for ( declaration expressionopt ; expressionopt ) statement
      P2: |
        Constraints
        The controlling expression of an iteration statement shall have scalar type.
      P3: >
        The declaration part of a for statement shall only declare identifiers
        for objects having storage class auto or register.
      P4: |
        Semantics
        An iteration statement causes a statement called the loop body to be
        executed repeatedly until the controlling expression compares equal to
        0. The repetition occurs regardless of whether the loop body is entered
        from the iteration statement or by a jump.<foot>Code jumped over is not
        executed. In particular, the controlling expression of a for or while
        statement is not evaluated before entering the loop body, nor is
        clause-1 of a for statement.  </foot>
      P5: >
        An iteration statement is a block whose scope is a strict subset of the
        scope of its enclosing block. The loop body is also a block whose scope
        is a strict subset of the scope of the iteration statement.
      P6: >
        An iteration statement whose controlling expression is not a constant
        expression,<foot>An omitted controlling expression is replaced by a
        nonzero constant, which is a constant expression.  </foot> that
        performs no input/output operations, does not access volatile objects,
        and performs no synchronization or atomic operations in its body,
        controlling expression, or (in the case of a for statement) its
        expression-3, may be assumed by the implementation to terminate.
        <foot>This is intended to allow compiler transformations such as
        removal of empty loops even when termination cannot be proven.</foot>
      1:
        title: The while statement
        P1: |
          The evaluation of the controlling expression takes place before each
          execution of the loop body.
      2:
        title: The do statement
        P1: |
          The evaluation of the controlling expression takes place after each
          execution of the loop body.
      3:
        title: The for statement
        P1: |
          The statement
            for ( clause-1 ; expression-2 ; expression-3 ) statement
          behaves as follows: The expression expression-2 is the controlling
          expression that is evaluated before each execution of the loop body.
          The expression expression-3 is evaluated as a void expression after
          each execution of the loop body. If clause-1 is a declaration, the
          scope of any identifiers it declares is the remainder of the
          declaration and the entire loop, including the other two expressions;
          it is reached in the order of execution before the first evaluation
          of the controlling expression. If clause-1 is an expression, it is
          evaluated as a void expression before the first evaluation of the
          controlling expression.<foot>Thus, clause-1 specifies initialization
          for the loop, possibly declaring one or more variables for use in the
          loop; the controlling expression, expression-2, specifies an
          evaluation made before each iteration, such that execution of the
          loop continues until the expression compares equal to 0; and
          expression-3 specifies an operation (such as incrementing) that is
          performed after each iteration.</foot>
        P2: >
          Both clause-1 and expression-3 can be omitted. An omitted
          expression-2 is replaced by a nonzero constant.
    6:
      title: Jump statements
      P1: |
        Syntax
        jump-statement:
          goto identifier ;
          continue ;
          break ;
          return expressionopt ;
      P2: |
        Semantics
        A jump statement causes an unconditional jump to another place.
      1:
        title: The goto statement
        P1: |
          Constraints
          The identifier in a goto statement shall name a label located somewhere
          in the enclosing function. A goto statement shall not jump from outside
          the scope of an identifier having a variably modified type to inside
          the scope of that identifier.
        P2: |
          Semantics
          A goto statement causes an unconditional jump to the statement
          prefixed by the named label in the enclosing function.
        P3: |
          EXAMPLE 1 It is sometimes convenient to jump into the middle of a
          complicated set of statements. The following outline presents one
          possible approach to a problem based on these three assumptions:
            1. The general initialization code accesses objects only visible
            to the current function.
            2. The general initialization code is too large to warrant
            duplication.
            3. The code to determine the next operation is at the head of the
            loop. (To allow it to be reached by continue statements, for
            example.)
            <code>
              /* ... */
              goto first_time;
              for (;;) {
                // determine next operation
                /* ... */
                if (need to reinitialize) {
                  // reinitialize-only code
                  /* ... */
                first_time:
                  // general initialization code
                  /* ... */
                  continue;
                }
                // handle other operations
                /* ... */
              }
            </code>
        P4: |
          EXAMPLE 2 A goto statement is not allowed to jump past any
          declarations of objects with variably modified types. A jump within
          the scope, however, is permitted.
          <code>
            goto lab3;       // invalid: going INTO scope of VLA.
            {
              double a[n];
              a[j] = 4.4;
            lab3:
              a[j] = 3.3;
              goto lab4;    // valid: going WITHIN scope of VLA.
              a[j] = 5.5;
            lab4:
              a[j] = 6.6;
            }
            goto lab4;     // invalid: going INTO scope of VLA.
          </code>
      2:
        title: The continue statement
        P1: |
          Constraints
          A continue statement shall appear only in or as a loop body.
        P2: |
          Semantics
          A continue statement causes a jump to the loop-continuation portion
          of the smallest enclosing iteration statement; that is, to the end of
          the loop body. More precisely, in each of the statements
          <code>
            while (/* ... */) {
              /* ... */
              continue;
              /* ... */
            contin: ;
            }
          </code>

          <code>
            do {
              /* ... */
              continue;
              /* ... */
            contin: ;
            } while (/* ... */);
          </code>

          <code>
            for (/* ... */) {
              /* ... */
              continue;
              /* ... */
            contin: ;
            }
          </code>
          unless the continue statement shown is in an enclosed iteration
          statement (in which case it is interpreted within that statement), it
          is equivalent to goto contin;.<foot>Following the contin: label is a
          null statement.</foot>
      3:
        title: The break statement
        P1: |
          Constraints
          A break statement shall appear only in or as a switch body or loop body.
        P2: |
          Semantics
          A break statement terminates execution of the smallest enclosing
          switch or iteration statement.
      4:
        title: The return statement
        P1: |
          Constraints
          A return statement with an expression shall not appear in a function
          whose return type is void. A return statement without an expression
          shall only appear in a function whose return type is void.
        P2: |
          Semantics
          A return statement terminates execution of the current function and
          returns control to its caller. A function may have any number of
          return statements.
        P3: >
          If a return statement with an expression is executed, the value of
          the expression is returned to the caller as the value of the function
          call expression. If the expression has a type different from the
          return type of the function in which it appears, the value is
          converted as if by assignment to an object having the return type of
          the function.<foot>The return statement is not an assignment. The
          overlap restriction of subclause 6.5.16.1 does not apply to the case
          of function return. The representation of floating-point values may
          have wider range or precision than implied by the type; a cast may be
          used to remove this extra range and precision.</foot>
        P4: |
          EXAMPLE In:
          <code>
            struct s { double i; } f(void);
            union {
              struct {
                int f1;
                struct s f2;
              } u1;
              struct {
                struct s f3;
                int f4;
              } u2;
            } g;
            struct s f(void)
            {
              return g.u1.f2;
            }
            /* ... */
            g.u2.f3 = f();
          </code>
          there is no undefined behavior, although there would be if the
          assignment were done directly (without using a function call to fetch
          the value).
  9:
    title: External definitions
    P1: |
      Syntax
      translation-unit:
        external-declaration
        translation-unit external-declaration
      external-declaration:
        function-definition
        declaration
    P2: |
      Constraints
      The storage-class specifiers auto and register shall not appear in the
      declaration specifiers in an external declaration.
    P3: >
      There shall be no more than one external definition for each identifier
      declared with internal linkage in a translation unit. Moreover, if an
      identifier declared with internal linkage is used in an expression (other
      than as a part of the operand of a sizeof or _Alignof operator whose
      result is an integer constant), there shall be exactly one external
      definition for the identifier in the translation unit.
    P4: |
      Semantics
      As discussed in 5.1.1.1, the unit of program text after preprocessing is
      a translation unit, which consists of a sequence of external
      declarations. These are described as ‘‘external’’ because they appear
      outside any function (and hence have file scope). As discussed in 6.7, a
      declaration that also causes storage to be reserved for an object or a
      function named by the identifier is a definition.
    P5: >
      An external definition is an external declaration that is also a
      definition of a function (other than an inline definition) or an object.
      If an identifier declared with external linkage is used in an expression
      (other than as part of the operand of a sizeof or _Alignof operator whose
      result is an integer constant), somewhere in the entire program there
      shall be exactly one external definition for the identifier; otherwise,
      there shall be no more than one.<foot>Thus, if an identifier declared
      with external linkage is not used in an expression, there need be no
      external definition for it.</foot>
    1:
      title: Function definitions
      P1: |
        Syntax
        function-definition:
          declaration-specifiers declarator declaration-listopt compound-statement
        declaration-list:
          declaration
          declaration-list declaration
      P2: |
        Constraints
        The identifier declared in a function definition (which is the name of
        the function) shall have a function type, as specified by the
        declarator portion of the function definition.
        <foot>
        The intent is that the type category in a function definition cannot be
        inherited from a typedef:
        <code>
          typedef int F(void);          // type F is ‘‘function with no parameters
                                        // returning int’’
          F f, g;                       // f and g both have type compatible with F
          F f { /* ... */ }             // WRONG: syntax/constraint error
          F g() { /* ... */ }           // WRONG:declares that g returns a function
          int f(void) { /* ... */ }     // RIGHT: f has type compatible with F
          int g() { /* ... */ }         // RIGHT: g has type compatible with F
          F *e(void) { /* ... */ }      // e returns a pointer to a function
          F *((e))(void) { /* ... */ }  // same: parentheses irrelevant
          int (*fp)(void);              // fp points to a function that has type F
          F *Fp;                        // Fp points to a function that has type F 
        </code>
        </foot>
      P3: >
        The return type of a function shall be void or a complete object type
        other than array type.
      P4: >
        The storage-class specifier, if any, in the declaration specifiers
        shall be either extern or static.
      P5: >
        If the declarator includes a parameter type list, the declaration of
        each parameter shall include an identifier, except for the special case
        of a parameter list consisting of a single parameter of type void, in
        which case there shall not be an identifier. No declaration list shall
        follow.
      P6: >
        If the declarator includes an identifier list, each declaration in the
        declaration list shall have at least one declarator, those declarators
        shall declare only identifiers from the identifier list, and every
        identifier in the identifier list shall be declared. An identifier
        declared as a typedef name shall not be redeclared as a parameter. The
        declarations in the declaration list shall contain no storage-class
        specifier other than register and no initializations.
      P7: |
        Semantics
        The declarator in a function definition specifies the name of the
        function being defined and the identifiers of its parameters. If the
        declarator includes a parameter type list, the list also specifies the
        types of all the parameters; such a declarator also serves as a
        function prototype for later calls to the same function in the same
        translation unit. If the declarator includes an identifier list,<foot>
        See ‘‘future language directions’’ (6.11.7).</foot>
        the types of the parameters shall be declared in a following
        declaration list. In either case, the type of each parameter is
        adjusted as described in 6.7.6.3 for a parameter type list; the
        resulting type shall be a complete object type.
      P8: >
        If a function that accepts a variable number of arguments is defined
        without a parameter type list that ends with the ellipsis notation, the
        behavior is undefined.
      P9: >
        Each parameter has automatic storage duration; its identifier is an
        lvalue.<foot>A parameter identifier cannot be redeclared in the
        function body except in an enclosed block.</foot> The layout of the
        storage for parameters is unspecified.
      P10: >
        On entry to the function, the size expressions of each variably
        modified parameter are evaluated and the value of each argument
        expression is converted to the type of the corresponding parameter as
        if by assignment. (Array expressions and function designators as
        arguments were converted to pointers before the call.)
      P11: >
        After all parameters have been assigned, the compound statement that
        constitutes the body of the function definition is executed.
      P12: >
        If the } that terminates a function is reached, and the value of the
        function call is used by the caller, the behavior is undefined.
      P13: |
        EXAMPLE 1
        In the following:
        <code>
          extern int max(int a, int b)
          {
            return a > b ? a : b;
          }
        </code>
        extern is the storage-class specifier and int is the type specifier;
        max(int a, int b) is the function declarator; and
        <code>
          { return a > b ? a : b; }
        </code>
        is the function body. The following similar definition uses the
        identifier-list form for the parameter declarations:
        <code>
          extern int max(a, b)
          int a, b;
          {
            return a > b ? a : b;
          }
        </code>
        Here int a, b; is the declaration list for the parameters. The
        difference between these two definitions is that the first form acts as
        a prototype declaration that forces conversion of the arguments of
        subsequent calls to the function, whereas the second form does not.
      P14: |
        EXAMPLE 2
        To pass one function to another, one might say
        <code>
          int f(void);
          /* ... */
          g(f);
        </code>
        Then the definition of g might read
        <code>
          void g(int (*funcp)(void))
          {
            /* ... */
            (*funcp)(); /* or funcp(); ... */
          }
        </code>
        or, equivalently,
        <code>
          void g(int func(void))
          {
            /* ... */
            func(); /* or (*func)(); ... */
          }
        </code>
    2:
      title: External object definitions
      P1: |
        Semantics
        If the declaration of an identifier for an object has file scope and an
        initializer, the declaration is an external definition for the
        identifier.
      P2: >
        A declaration of an identifier for an object that has file scope
        without an initializer, and without a storage-class specifier or with
        the storage-class specifier static, constitutes a tentative definition.
        If a translation unit contains one or more tentative definitions for an
        identifier, and the translation unit contains no external definition
        for that identifier, then the behavior is exactly as if the translation
        unit contains a file scope declaration of that identifier, with the
        composite type as of the end of the translation unit, with an
        initializer equal to 0.
      P3: >
        If the declaration of an identifier for an object is a tentative
        definition and has internal linkage, the declared type shall not be an
        incomplete type.
      P4: |
        EXAMPLE 1
        int i1 = 1;         // definition, external linkage
        static int i2 = 2;  // definition, internal linkage
        extern int i3 = 3;  // definition, external linkage
        int i4;             // tentative definition, external linkage
        static int i5;      // tentative definition, internal linkage

        int i1; // valid tentative definition, refers to previous
        int i2; // 6.2.2 renders undefined, linkage disagreement
        int i3; // valid tentative definition, refers to previous
        int i4; // valid tentative definition, refers to previous
        int i5; // 6.2.2 renders undefined, linkage disagreement

        extern int i1; // refers to previous, whose linkage is external
        extern int i2; // refers to previous, whose linkage is internal
        extern int i3; // refers to previous, whose linkage is external
        extern int i4; // refers to previous, whose linkage is external
        extern int i5; // refers to previous, whose linkage is internal
      P5: |
        EXAMPLE 2
        If at the end of the translation unit containing
        <code>
          int i[];
        </code>
        the array i still has incomplete type, the implicit initializer causes
        it to have one element, which is set to zero on program startup.
## TODO: Section 6.10
  10:
    title: Preprocessing directives

  11:
    title: Future language directions
    1:
      title: Floating types
      P1: >
        Future standardization may include additional floating-point types,
        including those with greater range, precision, or both than long
        double.
    2:
      title: Linkages of identifiers
      P1: >
        Declaring an identifier with internal linkage at file scope without the
        static storageclass specifier is an obsolescent feature.
    3:
      title: External names
      P1: >
        Restriction of the significance of an external name to fewer than 255
        characters (considering each universal character name or extended
        source character as a single character) is an obsolescent feature that
        is a concession to existing implementations.
    4:
      title: Character escape sequences
      P1: >
        Lowercase letters as escape sequences are reserved for future
        standardization. Other characters may be used in extensions.
    5:
      title: Storage-class specifiers
      P1: >
        The placement of a storage-class specifier other than at the beginning
        of the declaration specifiers in a declaration is an obsolescent
        feature.
    6:
      title: Function declarators
      P1: >
        The use of function declarators with empty parentheses (not
        prototype-format parameter type declarators) is an obsolescent feature.
    7:
      title: Function definitions
      P1: >
        The use of function definitions with separate parameter identifier and
        declaration lists (not prototype-format parameter type and identifier
        declarators) is an obsolescent feature.
    8:
      title: Pragma directives
      P1: >
        Pragmas whose first preprocessing token is STDC are reserved for future
        standardization.
    9:
      title: Predefined macro names
      P1: >
        Macro names beginning with _ _STDC_ are reserved for future
        standardization.