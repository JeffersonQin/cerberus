module C      = Cabs
module ATypes = AilTypes



(* STD §6.7.2#2, sentence 2 (non `void' case) *)
val desugar_basic_type_specifiers: Multiset.t C.type_specifier -> E.t (ATypes.basicType)
let desugar_basic_type_specifiers specs =
  if      specs = Multiset.from_list [C.TSpec_char]                   then E.return $ ATypes.Integer ATypes.Char
  else if specs = Multiset.from_list [C.TSpec_signed; C.TSpec_char]   then E.return $ ATypes.Integer (ATypes.Signed ATypes.Ichar)
  else if specs = Multiset.from_list [C.TSpec_unsigned; C.TSpec_char] then E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Ichar)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_short];
            Multiset.from_list [C.TSpec_signed; C.TSpec_short];
            Multiset.from_list [C.TSpec_short; C.TSpec_int];
            Multiset.from_list [C.TSpec_signed; C.TSpec_short; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Signed ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_short];
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_short; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_int];
            Multiset.from_list [C.TSpec_signed];
            Multiset.from_list [C.TSpec_signed; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Signed ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_unsigned];
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_long];
            Multiset.from_list [C.TSpec_signed; C.TSpec_long];
            Multiset.from_list [C.TSpec_long; C.TSpec_int];
            Multiset.from_list [C.TSpec_signed; C.TSpec_long; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Signed ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_long];
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_long; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_long; C.TSpec_long];
            Multiset.from_list [C.TSpec_signed; C.TSpec_long; C.TSpec_long];
            Multiset.from_list [C.TSpec_long; C.TSpec_long; C.TSpec_int];
            Multiset.from_list [C.TSpec_signed; C.TSpec_long; C.TSpec_long; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Signed ATypes.LongLong)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_long; C.TSpec_long];
            Multiset.from_list [C.TSpec_unsigned; C.TSpec_long; C.TSpec_long; C.TSpec_int] ] then E.return $ ATypes.Integer (ATypes.Unsigned ATypes.LongLong)
  else if specs = Multiset.from_list [C.TSpec_Bool] then E.return $ ATypes.Integer (ATypes.Bool)
  (* NOTE: real floating not supported *)
  else if    specs = Multiset.from_list [C.TSpec_float]
          || specs = Multiset.from_list [C.TSpec_double]
          || specs = Multiset.from_list [C.TSpec_long; C.TSpec_double]
          || specs = Multiset.from_list [C.TSpec_float; C.TSpec_Complex]
          || specs = Multiset.from_list [C.TSpec_double; C.TSpec_Complex]
          || specs = Multiset.from_list [C.TSpec_long; C.TSpec_double; C.TSpec_Complex] then E.fail $ Errors.CSEM_NOT_SUPPORTED "real floating types"
  else
    E.fail Errors.Cabs_to_ail__invalid_type_specifier_list


val desugar_type_specifiers : list C.type_specifier -> E.t (ATypes.ctype)
let desugar_type_specifiers = function
  | [] ->
      (* STD §6.7.2#2, sentence 1 *)
      E.fail Errors.Cabs_to_ail__empty_type_specifier_list
  
  | [C.TSpec_void] ->
      (* STD §6.7.2#2, sentence 2 (`void' case) *)
      E.return ATypes.Void
  
  | [C.TSpec_Atomic tyname] -> do E
      ty <- desugar_type_name tyname; in
      E.return (ATypes.Atomic ty)
  
  | [C.TSpec_struct id_opt sdecls_opt] ->
      Boot.assert_false "TODO"
  
  | [C.TSpec_union id_opt sdecls_opt] ->
      Boot.assert_false "TODO"
  
  | [C.TSpec_enum id_opt enums_opt] ->
      Boot.assert_false "TODO"
  
    (* TODO: this break impl-def independance *)
  | [C.TSpec_name str] ->
      match Builtins.translate_builtin_typenames str with
        | Just ty ->
            E.return ty
        | Nothing ->
            (* TODO [tmp hack] removing the qualifiers *)
            E.get_typedef str >>= fun (qs, ty) ->
            E.return ty
      end
  
  | ss ->
      ATypes.Basic <$> desugar_basic_type_specifiers (Multiset.from_list ss)
end


















(* STD §6.7.3#5, sentence 1 *)
val translate_type_qualifiers: list C.type_qualifier -> ATypes.qualifiers
let translate_type_qualifiers qs =
  ATypes.make_qualifiers
    (List.elem C.Q_const qs) (List.elem C.Q_restrict qs)
    (List.elem C.Q_volatile qs) (List.elem C.Q_Atomic qs)
|>




(* §6.7.6.1 Pointer declarators *)
(* STD §6.7.1#1 *)
val     desugar_pointer_declarator: C.pointer_declarator -> E.t (ATypes.ctype -> ATypes.ctype)
let rec desugar_pointer_declarator (PDecl qs ptr_decltor_opt) = do E
  mk_ptr <- option (E.return id) desugar_pointer_declarator  ptr_decltor_opt; in
  let a_qs = translate_type_qualifiers qs
  E.return $
    fun ty -> ATypes.Pointer a_qs (mk_ptr ty)






val     desugar_direct_abstract_declarator: C.direct_abstract_declarator -> E.t (ATypes.ctype -> ATypes.ctype)
let rec desugar_direct_abstract_declarator dabs_decltor =
  match dabs_decltor with
    | DAbs_decl_abs abs_decltor -> (* abstract_declarator *)
        desugar_abstract_declarator abs_decltor
    | DAbs_A dabs_decltor_opt qs expr -> (* maybe direct_abstract_declarator * list type_qualifier * maybe expression *)
        
    | DAbs_B dabs_decltor_opt qs expr -> (* maybe direct_abstract_declarator * list type_qualifier * expression *)
        
    | DAbs_C dabs_decltor_opt qs expr -> (* maybe direct_abstract_declarator * list type_qualifier * expression *)
        
    | DAbs_D dabs_decltor_opt -> (* maybe direct_abstract_declarator *)
        
    | DAbs_E dabs_decltor_opt params -> (* maybe direct_abstract_declarator * parameter_type_list *)
        





val desugar_abstract_declarator: C.abstract_declarator -> E.t (ATypes.ctype -> ATypes.ctype)
let desugar_abstract_declarator = function
  | AbsDecl_pointer ptr_decltor ->
      desugar_pointer_declarator ptr_decltor
  | AbsDecl_direct ptr_decltor_opt dabs_decltor -> do E
      mk_ptr <- option (E.return id) desugar_pointer_declarator ptr_decltor_opt;
      mk_ty  <- desugar_direct_abstract_declarator dabs_decltor; in
      E.return $
        fun ty -> mk_ty (mk_ptr ty)
end



val desugar_type_name: C.type_name -> ATypes.qualifiers * ATypes.ctype
let desugar_type_name (C.Type_name specs qs absdecltor_opt) =
  let a_specs = translate_type_specifiers specs in
  let a_qs    = translate_type_qualifiers qs    in
  
