% Global index variables
indexvar n ::= {{ com index }}

metavar id ::= {{ com identifier }}
metavar l , l' , l'' ::= {{ com label}}

grammar
% Overriding some terminals with their LaTeX representation
terminals :: terminals_  ::=
  | X :: :: prod {{ tex \times }}
  | -> :: :: arrow {{ tex \rightarrow }}
  | --> :: :: longArrow {{ tex \longrightarrow }}
  | |- :: :: turnstile {{ tex \vdash }}
  | <rank :: :: rank_lt {{ tex <_{rank} }}
  | =rank :: :: rank_eq {{ tex =_{rank} }}
  | <=rank :: :: rank_leq {{ tex \leqslant_{rank} }}
  | <= :: :: leq {{ tex \leqslant }}
  | neq :: :: neq {{ tex \not = }}
  | =compat :: :: type_compat {{ tex =_{\tau-compatible} }}

% Syntax for C

% Statements
s :: 'stmt_' ::= {{ com statement}}
  | e :: :: exp {{com expression}}
  | s1 ; s2 :: :: seq {{com sequence of expressions}}

% Expressions
e :: exp_ ::= {{ com expression }}
  | Var id :: :: var {{ com variable }}
  | Fun id :: :: fun_ref {{ com function reference }}
  | c :: :: const {{ com constant }}
  | unop e :: :: unop {{ com unary operation }}
  | ( t_C ) e :: :: cast {{ com type cast }}
  | e1 binop e2 :: :: binop {{ com binary operation }}
  | e1 relop e2 :: :: relop {{ com relational operator }}
  | e1 seqop e2 :: :: seqop {{ com binary operator with sequencing constraints }}
  | e1 = e2 :: :: assign {{ tex [[e1]]\ \texttt{=}\ [[e2]] }} {{ com simple assignement }}
  | e1 binop = e2 :: :: comp_assign {{ tex [[e1]] [[binop]]\texttt{=}\ [[e2]] }}{{ com compound assignment }}
  | e ( e1 , ... , en ) :: :: fun_call {{ com function call }}

% Labelled Expressions
%e_l {{ tex e }} :: exp_labelled_ ::= {{ com labelled expression }}
%  | Var id l :: :: var {{ tex {\left( [[Var]]\ [[id]] \right)}^l }}
%  | Fun id l :: :: fun_ref {{ tex {\left( [[Fun]]\ [[id]] \right)}^l }}
%  | c l :: :: const {{ tex {[[c]]}^l }}
%  | unop e_l l :: :: unop {{ tex {\left( [[unop]]\ [[e_l]] \right)}^l }}
%  | ( t ) e_l l :: :: cast
%  | e_l1 binop e_l2 l :: :: binop {{ tex {\left( [[e_l1]] [[binop]] [[e_l2]] \right)}^l }}
%  | e_l ( e_l1 , ... , e_ln ) l :: :: fun_call
%  | ( e_l ) :: S :: paren

unop :: unop_ ::= {{ com unary operator}}
  | + :: :: pos {{ tex \texttt{+} }}
  | - :: :: neg {{ tex \texttt{-} }}
  | ~ :: :: bcompl {{ tex \texttt{~} }} {{ com bitwise complement }}
  | addr :: :: addr {{ tex \texttt{\&} }} {{ com address operator }}
  | * :: :: indr {{ tex \texttt{*} }} {{ com indirection operator }}

binop {{tex \odot }} :: binop_ ::= {{ com binary operator}}
  | + :: :: add {{ tex \texttt{+} }} {{ com addition }}
  | - :: :: sub {{ tex \texttt{-} }} {{ com subtraction }}
  | * :: :: mul {{ tex \texttt{*} }} {{ com multiplication }}
  | / :: :: div {{ tex \texttt{/} }} {{ com division}}
  | mod :: :: mod {{ tex \texttt{\%} }} {{ com modulo }}
  | << :: :: lshift {{ tex \texttt{<<} }} {{ com left shift }}
  | >> :: :: rshift {{ tex \texttt{>>} }} {{ com right shift }}
  | | :: :: bor {{ tex \texttt{|} }} {{ com bitwise or }}
  | & :: :: band {{ tex \texttt{\&} }} {{ com bitwise and }}
  | ^ :: :: bxor {{ tex \texttt{\textasciicircum} }} {{ com bitwise exclusive or }} % TODO Stop Ott from turning ^ into a LaTeX arrow!

relop {{ tex ? }} :: relop_ ::= {{ com relational operators}}
  | == :: :: eq {{ tex \texttt{==} }} {{ com equal-to }}
  | != :: :: neq {{ tex \texttt{!=} }} {{com not-equal-to }}
  | < :: :: lt {{ tex \texttt{<} }} {{ com less-than }}
  | > :: ::  gt {{ tex \texttt{>} }} {{ com greater-than }}
  | <= :: :: le {{ tex \texttt{<=} }} {{ com less-than-or-equal-to }}
  | >= :: :: ge {{ tex \texttt{>=} }} {{ com greater-than-or-equal-to }}

seqop :: seqop ::=
  | && :: :: land {{ tex \texttt{\&\&} }} {{ com logical and }}
  | || :: :: lor {{ tex \texttt{||} }} {{ com logical or }}
  | , :: :: comma {{ tex \texttt{,} }} {{ com comma operator }}

c :: 'const_' ::= {{ com constant }}
  | n :: :: int {{ com signed integer constant }}
  | NULL :: :: null {{ com null pointer constant}}

% C Types
t_base {{ tex \tau^{base} }} :: type_base_ ::= {{ com integer base type }}
  | char :: :: char
  | short :: :: short
  | int :: :: int
  | long :: :: long
  | longlong :: :: longlong

t_C {{ tex t }} :: ctype_ ::= {{ com C type }}
  | void :: :: void {{ com unit type }}
  | bool :: :: bool {{ com boolean type }}
  | unsigned t_base :: :: unsigned_int {{ com unsigned integer type (excluding $[[bool]]$) }}
  | signed t_base :: :: signed_int {{ com signed signed integer type }}
  | t_C * :: :: pt {{ com pointer type}}
  | t_C [ n ] :: :: array {{ com array type }}

% Abstract Types
t {{ tex \tau }} :: type_ ::= {{ com abstract type }}
  | void :: :: void {{ com unit type }}
  | bool :: :: bool {{ com boolean type }}
  | unsigned t_base :: :: unsigned_int {{ com unsigned integer type (excluding $[[bool]]$) }}
  | signed t_base :: :: signed_int {{ com signed signed integer type }}
  | t * :: :: pt {{ com pointer type}}
  | t [ n ] :: :: array {{ com array type }}
  | t lvalue :: :: lvalue {{ com lvalue type }}
  | t1 X ... X tn -> t :: :: function {{ com function type}}

% Subrules for Types
t_signed {{ tex \tau^{signed} }} :: t_class_signed_ ::= {{ com signed integer type }}
  | signed t_base :: :: int

t_unsigned {{ tex \tau^{unsigned} }} :: t_class_unsigned_ ::= {{ com unsigned integer type }}
  | bool :: :: bool
  | unsigned t_base :: :: int

t_int {{ tex \tau^{int} }} :: t_class_int_ ::= {{ com integer type }}
%  | t_signed :: :: signed
%  | t_unsigned :: :: unsigned
  | bool :: :: bool
  | unsigned t_base :: :: signed
  | signed t_base :: :: unsigned

t_arith {{ tex \tau^{arith} }} :: t_class_arith_ ::= {{ com arithmetic type }}
%  | t_signed :: :: int
  | bool :: :: int_bool
  | unsigned t_base :: :: int_signed
  | signed t_base :: :: int_unsigned

t_real {{ tex \tau^{real} }} :: t_class_real_ ::= {{ com real type }}
%  | t_signed :: :: int
  | bool :: :: int_bool
  | unsigned t_base :: :: int_signed
  | signed t_base :: :: int_unsigned

t_scalar {{ tex \tau^{scalar} }} :: t_class_scalar_ ::= {{ com scalar type }}
%  | t_arith :: :: arith
%  | t * :: :: pt
  | bool :: :: int_bool
  | unsigned t_base :: :: int_signed
  | signed t_base :: :: int_unsigned
  | t * :: :: pt

t_C_scalar {{ tex t^{scalar} }} :: t_C_class_scalar_ ::= {{ com scalar C type }}
%  | t_C_arith :: :: arith
%  | t_C * :: :: pt
  | bool :: :: int_bool
  | unsigned t_base :: :: int_signed
  | signed t_base :: :: int_unsigned
  | t_C * :: :: pt

% Subrules
subrules
t_signed <:: t
t_signed <:: t_C

t_unsigned <:: t
t_unsigned <:: t_C

t_signed <:: t_int
t_unsigned <:: t_int
t_int <:: t
t_int <:: t_C

t_int <:: t_real
t_real <:: t
t_real <:: t_C

t_real <:: t_arith
t_arith <:: t
t_arith <:: t_C

t_arith <:: t_scalar
t_scalar <:: t

t_C_scalar <:: t_C
t_C_scalar <:: t_scalar
t_C <:: t