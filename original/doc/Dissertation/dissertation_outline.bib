@inproceedings{developmentOfC,
 author = {Ritchie, Dennis M.},
 title = {{The development of the C language}},
 booktitle = {HOPL-II: The second ACM SIGPLAN conference on History of programming languages},
 year = 1993,
 isbn = {0-89791-570-4},
 pages = {201--208},
 location = {Cambridge, MA, USA},
 doi = {http://doi.acm.org/10.1145/154766.155580},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@String{pub-ANSI = "American National Standards Institute"}
@String{pub-ANSI:adr = "1430 Broadway, New York, NY 10018, USA"}

@book{ansiC,
 author = {American National Standards Institute},
 title = {{American National Standard for Information Systems ---  Programming Languages -- C: ANSI X3.159-1989}},
 publisher = pub-ANSI,
 address = pub-ANSI:adr,
 pages = "219 + vi + 119",
 year = "1989",
}

@TechReport{norrishPhd,
 author = {Norrish, Michael},
 title = {{C formalised in HOL}},
 year = 1998,
 month = dec,
 url = {http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-453.pdf},
 institution = {University of Cambridge, Computer Laboratory},
 number = {UCAM-CL-TR-453}
}

@inproceedings{codeGeneration,
  author = {Florian Haftmann and Tobias Nipkow},
  title = {Code Generation via Higher-Order Rewrite Systems},
  booktitle = {Functional and Logic Programming: 10th International Symposium: FLOPS 2010},
  year = 2010,
  publisher = {Springer},
  series = {Lecture Notes in Computer Science},
  editor = {Matthias Blume and Naoki Kobayashi and Germ{\'a}n Vidal},
  volume = {6009}
}

@inproceedings{cil,
 author = {Necula, George C. and McPeak, Scott and Rahul, Shree Prakash and Weimer, Westley},
 title = {{CIL: Intermediate Language and Tools for Analysis and Transformation of C Programs}},
 booktitle = {Proceedings of the 11th International Conference on Compiler Construction},
 year = {2002},
 isbn = {3-540-43369-4},
 pages = {213--228},
 publisher = {Springer-Verlag},
 address = {London, UK},
 }

@Techreport{cpp,
 author = {Batty, Mark and Owens, Scott and Sewell, Peter and Sarkar, Susmit and Weber, Tjark},
 title = {{Mathematizing C++ Concurrency: The Post-Rapperswil Model}},
 year = 2010,
 month = sep,
 url = {http://www.cl.cam.ac.uk/~pes20/cpp/tech.pdf},
 institution = {University of Cambridge, Computer Laboratory},
 number = {N3132=10-0122, Revision 5190},
}

@Book{isabelle,
  author  = {Tobias Nipkow and Lawrence C. Paulson and Markus Wenzel},
  title   = {Isabelle/HOL --- A Proof Assistant for Higher-Order Logic},
  publisher = {Springer},
  series  = {LNCS},
  volume  = 2283,
  year    = 2002,
}

@techreport{Ellison2010, 
author = "Chucky Ellison and Grigore Ro{\c s}u", 
institution={University of Illinois}, 
number={http://hdl.handle.net/2142/17414}, 
title = "A Formal Semantics of {C} with Applications", 
month = nov, 
year = "2010", 
}

@techreport{minutes,
  author = {Hedquist, Barry},
  title = {{Minutes for April 2008}},
  institution = {ISO/IEC JTC1/SC22/WG14},
  number = {N1343},
  month = oct,
  year = 2008
}

@techreport{c1xCharter,
  author = {Benito, John},
  title = {{C -- The C1X Charter}},
  institution = {ISO/IEC JTC1/SC22/WG14},
  number = {N1250},
  month = jun,
  year = 2007
}

@manual{pdp11,
  organization= {Digital Equipment Corporation},
  title={{PDP-11/40 Processor Handbook}},
  address = {Maynard, MA, USA},
  year = 1972
}

@manual{codeGenerationManual,
  author = {Haftmann, Florian and Bulwahn, Lukas},
  title = {{Code generation from Isabelle/HOL theories}},
  url = {http://isabelle.in.tum.de/dist/Isabelle2011/doc/codegen.pdf},
  howpublished = "\url{http://isabelle.in.tum.de/dist/Isabelle2011/doc/codegen.pdf}",
  month = jan,
  year = 2011
}


@incollection{gccImplementation,
  author = {Stallmann, Richard M. and {the \texttt{GCC} Developer Community}},
  booktitle = {{Using the GNU Compiler Collection}},
  title = {{Implementation-defined behavior}},
  chapter = 4,
  year=2010,
  publisher = {{GNU Press}},
  address = {Boston, MA, USA}
}

@techreport{c1x,
  author = {Jones, Larry},
  title = {{Working Draft (SC 22 N4578)}},
  institution = {ISO/IEC JTC1/SC22/WG14},
  year = 2010,
  month = nov
}

@inproceedings{felleisenSecd,
    author = {Felleisen, Matthias and Friedman, Daniel P.},
    booktitle = {Proceedings of the IFIP TC 2/WG2. 2 Working Conf. on Formal Description of Programming Concepts Part III},
    location = {Ebberup, Denmark},
    pages = {193--219},
    title = {{Control Operators, the SECD-Machine, and the Lambda-Calculus}},
    year = 1986,
    month = aug
}

@techreport{martinLoef,
  author = {Martin-Löf, Per},
  title = {{On the meanings of the logical constants and the justifications of the logical laws}},
  number = 2,
  year = 1985,
  institution = {Universita di Siena, Dipartimento di Matematica, Scuola di Specializzazione in Logica Matematica}
}

@article{discoveryContinuation,
   author = {Reynolds, John C.},
   affiliation = {School of Computer Science Carnegie Mellon University 15213-3890 Pittsburgh PA},
   title = {The discoveries of continuations},
   journal = {LISP and Symbolic Computation},
   publisher = {Springer Netherlands},
   issn = {0892-4635},
   keyword = {Computer Science},
   pages = {233-247},
   volume = 6,
   issue = 3,
   url = {http://dx.doi.org/10.1007/BF01019459},
   abstract = {We give a brief account of the discoveries of continuations and related concepts by A. van Wijngaarden, A. W. Mazurkiewicz, F. L. Morris, C. P. Wadsworth, J. H. Morris, M. J. Fischer, and S. K. Abdali.},
   year = 1993
}

@article{memoryModels,
  author = {Adve, Sarita V. and Boehm, Hans-J.},
  title = {Memory models: a case for rethinking parallel languages and hardware},
  journal = {Commun. ACM},
  issue_date = {August 2010},
  volume = 53,
  issue = 8,
  month = {August},
  year = 2010,
  issn = {0001-0782},
  pages = {90--101},
  numpages = 12,
  url = {http://doi.acm.org/10.1145/1787234.1787255},
  doi = {http://doi.acm.org/10.1145/1787234.1787255},
  acmid = 1787255,
  publisher = {ACM},
  address = {New York, NY, USA},
} 

@inproceedings{weakOrdering,
  author = {Adve, Sarita V. and Hill, Mark D.},
  title = {Weak ordering -- a new definition},
  booktitle = {Proceedings of the 17th annual international symposium on Computer Architecture},
  series = {ISCA '90},
  year = 1990,
  isbn = {0-89791-366-3},
  location = {Seattle, Washington, United States},
  pages = {2--14},
  numpages = 13,
  url = {http://doi.acm.org/10.1145/325164.325100},
  doi = {http://doi.acm.org/10.1145/325164.325100},
  acmid = 325100,
  publisher = {ACM},
  address = {New York, NY, USA},
  keywords = {sequential consistency, shared-memory multiprocessor, weak ordering},
}

@article{ott,
author = {Sewell, Peter and Nardelli, Francesco Zappa and Owens, Scott and Peskine, Gilles and Ridge,Thomas and Sarkar, Susmit and Strniša, Rok},
title = {Ott: Effective tool support for the working semanticist},
journal = {Journal of Functional Programming},
volume = {20},
number = {01},
pages = {71-122},
year = {2010},
doi = {10.1017/S0956796809990293},
URL = {http://dx.doi.org/10.1017/S0956796809990293},
eprint = {http://journals.cambridge.org/article_S0956796809990293},
abstract = {Semantic definitions of full-scale programming languages
                  are rarely given, despite the many potential benefits. Partly
                  this is because the available metalanguages for expressing
                  semantics make it much harder than necessary to work with
                  large definitions. We present a metalanguage specifically
                  designed for this problem, and a tool, Ott, that sanity-checks
                  such definitions and compiles them into proof assistant code
                  for Coq, HOL, and Isabelle/HOL, together with code for
                  production-quality typesetting, and OCaml boilerplate. The
                  main innovations are (1) metalanguage design to make
                  definitions concise, and easy to read and edit; (2) an
                  expressive but intuitive metalanguage for specifying binding
                  structures; and (3) compilation to proof assistant code. This
                  has been tested in substantial case studies, including modular
                  specifications of calculi from the TAPL text, a Lightweight
                  Java with Java JSR 277/294 module system proposals, and a
                  large fragment of OCaml (OCamllight, 310 rules), with
                  mechanised proofs of various soundness results. Our aim with
                  this work is to enable a phase change: making it feasible to
                  work routinely, without heroic effort, with rigorous semantic
                  definitions of realistic languages. }
}

@book{modernCompiler,
 author = {Appel, Andrew W.},
 title = {Modern compiler implementation in ML: basic techniques},
 year = {1997},
 isbn = {0-521-58775-1},
 publisher = {Cambridge University Press},
 address = {New York, NY, USA},
}

@article{zipperCFG,
title = "An Applicative Control-Flow Graph Based on Huet's Zipper",
journal = "Electronic Notes in Theoretical Computer Science",
volume = "148",
number = "2",
pages = "105 - 126",
year = "2006",
note = "Proceedings of the ACM-SIGPLAN Workshop on ML (ML 2005)",
issn = "1571-0661",
doi = "DOI: 10.1016/j.entcs.2005.11.042",
url = "http://www.sciencedirect.com/science/article/B75H1-4JFR8JY-6/2/d7bcb95263bbe08c29267a12911c2c86",
author = "Norman Ramsey and João Dias",
keywords = "compilers",
keywords = "control-flow graphs",
keywords = "applicative data structures",
keywords = "dataflow analysis",
keywords = "optimization",
abstract = " We are using ML to build a compiler that does low-level
                  optimization. To support optimizations in classic imperative
                  style, we built a control-flow graph using mutable pointers
                  and other mutable state in the nodes. This decision proved
                  unfortunate: the mutable flow graph was big and complex, and
                  it led to many bugs. We have replaced it by a smaller,
                  simpler, applicative flow graph based on Huet's [Huet, Gérard,
                  1997. The Zipper. Journal of Functional Programming,
                  7(5):549-554. Functional Pearl] zipper. The new flow graph is
                  a success; this paper presents its design and shows how it
                  leads to a gratifyingly simple implementation of the dataflow
                  framework developed by [Lerner, Sorin, David Grove, and Craig
                  Chambers. 2002. Composing dataflow analyses and
                  transformations. Conference Record of the 29th Annual ACM
                  Symposium on Principles of Programming Languages, in SIGPLAN
                  Notices, 31(1):270-282]."
}

@misc{expressionProblem,
    abstract = {The Expression Problem is a new name for an old problem.  The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).  For the concrete example, we take expressions as the data type, begin with one case (constants) and one function (evaluators), then add one more construct (plus) and one more function (conversion to a string).

Whether a language can solve the Expression Problem is a salient indicator of its capacity for expression.  One can think of cases as rows and functions as columns in a table.  In a functional language, the rows are fixed (cases in a datatype declaration) but it is easy to add new columns (functions).  In an object-oriented language, the columns are fixed (methods in a class declaration) but it is easy to add new rows (subclasses).  We want to make it easy to add either rows or columns.},
    author = {Wadler, Philip},
    day = {12},
    howpublished = {\url{http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt}},
    journal = {java-genericity Mailing List},
    keywords = {expression-problem, extensibility},
    month = nov,
    posted-at = {2005-04-10 15:58:38},
    priority = {2},
    title = {The Expression Problem},
    url = {http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt},
    year = {1998}
}

@inproceedings{polymorphicVariants,
  author = {Jacques Garrigue},
  title = {Code reuse through polymorphic variants},
  booktitle = {Foundations of Software Engineering},
  year = {2000},
  masid = {224650}
}

@unpublished{openVariant,
  title = {{The AST Typing Problem}},
  author = {Krishnaswami, Neelakantan  R.},
  note = {\url{http://lambda-the-ultimate.org/node/4170\#comment-63836}},
  url = {http://lambda-the-ultimate.org/node/4170#comment-63836},
  month = dec,
  year = 2010
}

@article{spiralModel86,
  author = {Boehm, Barry W.},
  title = {A spiral model of software development and enhancement},
  journal = {SIGSOFT Softw. Eng. Notes},
  volume = {11},
  issue = {4},
  month = {August},
  year = {1986},
  issn = {0163-5948},
  pages = {14--24},
  numpages = {11},
  url = {http://doi.acm.org/10.1145/12944.12948},
  doi = {http://doi.acm.org/10.1145/12944.12948},
  acmid = {12948},
  publisher = {ACM},
  address = {New York, NY, USA},
}

@article{spiralModel,
  author = {Boehm, Barry W.},
  journal = {Computer},
  title = {A spiral model of software development and enhancement},
  year = {1988},
  month = {may},
  volume = {21},
  number = {5},
  pages = {61 -72},
  abstract = {A short description is given of software process models and the
                  issues they address. An outline is given of the process steps
                  involved in the spiral model, an evolving risk-driven approach
                  that provides a framework for guiding the software process,
                  and its application to a software project is shown. A summary
                  is given of the primary advantages and implications involved
                  in using the spiral model and the primary difficulties in
                  using it at its current incomplete level of elaboration },
  keywords = {enhancement;risk-driven approach;software development;software process models;spiral model;software engineering;},
  doi = {10.1109/2.59},
  ISSN = {0018-9162},
}

@book{expertC,
  author = {van der Linden, Peter},
  title = {{Expert C Programming: Deep C Secrets}},
  publisher = {Prentice Hall},
  year = 1994
}

@incollection {expertFS,
   author = {Syme, Don and Granicz, Adam and Cisternino, Antonio and Syme, Don and Granicz, Adam and Cisternino, Antonio},
   title = {Introducing Functional Programming},
   booktitle = {Expert F\#},
   publisher = {Apress},
   isbn = {978-1-4302-0285-1},
   keyword = {Computer Science},
   pages = {27-68},
   year = 2007
}

@article{fastCC,
title = "Fast congruence closure and extensions",
journal = "Information and Computation",
volume = "205",
number = "4",
pages = "557 - 580",
year = "2007",
note = "Special Issue: 16th International Conference on Rewriting Techniques and Applications",
issn = "0890-5401",
doi = "DOI: 10.1016/j.ic.2006.08.009",
url = "http://www.sciencedirect.com/science/article/B6WGK-4MWXT8D-1/2/5fd7a9f8ab446a803098a16c04bf476e",
author = "Robert Nieuwenhuis and Albert Oliveras",
keywords = "Decision procedures",
keywords = "Congruence closure",
keywords = "Equational reasoning",
keywords = "Verification"
}

@inproceedings{unionFind,
 author = {Conchon, Sylvain and Filli\^{a}tre, Jean-Christophe},
 title = {{A Persistent Union-Find Data Structure}},
 booktitle = {{Proceedings of the 2007 Workshop on ML}},
 series = {ML '07},
 year = {2007},
 isbn = {978-1-59593-676-9},
 location = {Freiburg, Germany},
 pages = {37--46},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1292535.1292541},
 doi = {http://doi.acm.org/10.1145/1292535.1292541},
 acmid = {1292541},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {formal verification, persistence, union-find},
} 

@inproceedings{regehr,
  author = {Yang, Xuejun and Chen, Yang and Eide, Eric and Regehr, John},
  title = {{Finding and Understanding Bugs in C Compilers}},
  booktitle = {{Proceedings of the 2011 ACM SIGPLAN Conference on Programming Language Design and Implementation}},
  publisher = {ACM},
  address = {New York, NY, USA},
  location = {San Jose, California},
  month = jun,
  year = 2011
}