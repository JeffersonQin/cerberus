\documentclass[12pt,a4paper,reqno]{article}

\usepackage{amssymb}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{graphicx}
%\usepackage{asymptote}
\usepackage{setspace}
\usepackage{version}
\usepackage[british]{babel}
\usepackage{hyperref}
\usepackage{url}

\theoremstyle{plain}
\newtheorem{theorem}[subsection]{Theorem}
\newtheorem{proposition}[subsection]{Proposition}
\newtheorem{lemma}[subsection]{Lemma}
\newtheorem{corollary}[subsection]{Corollary}
\newtheorem{conjecture}[subsection]{Conjecture}
\newtheorem{claim}{Claim}

\theoremstyle{definition}
\newtheorem{definition}[subsection]{Definition}
\newtheorem{note}[subsection]{Note}

\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}

\renewcommand{\labelenumi}{(\roman{enumi})}
%\onehalfspace
\parindent 5mm
\parskip   0mm

\usepackage[utf8x]{inputenc}

%opening
\title{Notes on the C Programming Language}
\author{Justus Matthiesen}

\begin{document}

\maketitle

\begin{abstract}
The purpose of this article is to document my questions and thoughts on the draft \textit {N1494} for the next C standard.
\end{abstract}

\tableofcontents

\section{Basic Definitions}

\begin{definition}[\textit{object}]\label{object}
An object is a region of \textit{data storage} in the \textit{execution environment} [\ref{execution environment}]. The contents of the region typically represent a \textit{value} [\ref{value}].

\hfill\textsf{Paragraph 3.15}
\end{definition}

\begin{definition}[\textit{value}]\label{value}
A value is the meaning of the contents of an object [\ref{object}] when interpreted as having a specific \textit{type} [\ref{type}].
\end{definition}

\begin{definition}[\textit{unspecified value}]\label{unspecified value}
An unspecified value is a valid value of the given type where the standard does not specify which value is chosen.
\end{definition}

\begin{definition}[\textit{trap representation}]\label{trap representation}
A (data storage) representation of an object that does not necessarily represent a value of the object type.
\end{definition}


\begin{definition}[\textit{indeterminate value}]

\end{definition}


\begin{definition}[\textit{access}ing an object \ref{object}]\label{access}
\textit{Reading} or \textit{modifying} an object at run-time. The term \textit{modify} includes the case when the new value assigned to an object coincides with the previous value.
\end{definition}

\begin{definition}[\textit{behaviour}]
Behaviour is the \textit{external appearance}\footnote{Note that \textit{external appearance} is not the same as \textit{observable behaviour} [\ref{observable behaviour}].} of program execution. It can also be an \textit{action}. A definition of what constitutes an action is not given.
\end{definition}

\begin{definition}[\textit{undefined behaviour}]\label{undefined behaviour}
Behaviour for which the standard the standard imposes no requirements.
\end{definition}

\begin{definition}[\textit{unspecified behaviour}]\label{unspecified behaviour}
Behaviour is unspecified if it involves an \textit{unspecified value} [\ref{}] or if the standard presents several options without imposing any further requirements on which is chosen in any circumstance.
\end{definition}

\begin{definition}[\textit{implementation-defined behaviour}]
For our purposes implementation-defined behaviour is equivalent to unspecified behaviour [\ref{unspecified behaviour}].
\end{definition}

\begin{definition}[\textit{locale-specific behaviour}]
For our purposes locale-specific behaviour is equivalent to unspecified behaviour [\ref{unspecified behaviour}].
\end{definition}

\section{Questions and Criticisms}

\subsection{Inconsistent use of convention}
The standard gives a concise definition of what constitutes \textit{undefined behaviour}. It states (amongst other things) that ``[u]ndefined behavior is otherwise indicated [...] by the omission of any explicit definition of behavior'' (\textit{Conformance}, Chapter 4 §1).

Let us look at a particular instance of \textit{undefined behaviour} by omission of defined behaviour. The following paragraph defines the semantics of an identifier expression.
\begin{quote}
``An identifier is a primary expression, provided it has been declared as designating an object (in which case it is an lvalue) or a function (in which case it is a function designator)''. (\textit{Primary expressions, Semantics}, Chapter 6.5.1 §1)
\end{quote}
What is the behaviour if the identifier has not (yet) been declared? The above description clearly does not consider this case, i.e. the definition of behaviour is omitted and the behaviour is thus undefined. However, in a footnote to the semantic description the standard explains: ``Thus, an undeclared identifier is a violation of the syntax''. Since footnotes are ``for information only'' (\textit{Foreword}, §8), the quoted footnote should only clarify the definition and should certainly not introduce further constraints. To implement the intend of the standard, it would be necessary to make the syntactic violation explicit by adding a constraint section with an appropriate \textit{shall} requirement.

\subsection{Use of implicit definitions}
The standard introduces a number of technical terms without giving a clear definition. A good example of such a term is the notion of an \textit{object type} which is defined as follows.
\begin{quote}
``Types are partioned into \textit{object types} (types that describe objects) and \textit{function types} (types that describe functions)''. (\textit{Types}, Chapter 6.2.5 §1)
\end{quote}
To understand the definition, we need, of course, to know what an object is: The standard defines it as ``a region of storage in the execution environment, the contents of which can represent values'' (\textit{object}, Chapter 3.15 §1).

To see whether these two definitions are sufficient to define what an object type is, we shall look at two examples.

First, let us try to answer the question of whether a pointer type belongs to the set of object types. The answer is ``yes''. Why? Because the standard says so:
\begin{quote}
``A pointer is a complete object type'' (\textit{Types}, Chapter 6.2.5 §20).
\end{quote}
How about array types? Here, the standard remains silent so we have to go back and examine the definition of object types. Unfortunately, the definition of object is too vague to be useful. One could argue that, since the set of types is partitioned into object and function types, any particular type must be part of either of the two categories. Our intuitive understanding of C tells us that an array type should not be a function type and therefore it must be an object type. While the above reasoning probably coincides with the intent of the standard (committee), we should be able to read and understand the standard without having to rely on any a priori knowledge about C  for it is the purpose of the standard to ``establish the interpretation of programs expressed in the programming language C'' (\textit{Abstract}, p. i).

\subsection{Underspecification}
Suppose we want to determine whether a C program is correctly typed. The standard's description of the constraints involved in type checking mostly follow the syntactic structure of a program.
\begin{quote}
``The result is an integer.'' (\textit{The \texttt{sizeof} and \texttt{alignof} operators, Semantics}, Chapter 6.5.3.4 §2)
\end{quote}
\begin{quote}
``The result is an integer constant.'' (\textit{The \texttt{sizeof} and \texttt{alignof} operators, Semantics}, Chapter 6.5.3.4 §3)
\end{quote}


\end{document}
