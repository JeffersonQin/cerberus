fun is_representable_integer (n: integer, ty: ctype): boolean :=
--  <ctype_min>(ty) <= n /\ n <= <ctype_max>(ty)
  Ivmin(ty) <= n /\ n <= Ivmax(ty)

fun is_representable_floating (f: floating, ty: ctype): boolean :=
  -- HACK!
  True 
  -- error(<<<is_representable_floating>>>, Unit)


fun all_values_representable_in (ty1: ctype, ty2: ctype): boolean :=
  Ivmin(ty2) <= Ivmin(ty1) /\ Ivmax(ty1) <= Ivmax(ty2)


-- STD §6.5#5
fun catch_exceptional_condition (ty: ctype, n: integer) : integer :=
  if is_representable_integer(n, ty) then
    n
  else
    undef(<<UB036_exceptional_condition>>)


-- [conv_int ty n] returns the value [n] converted to the integer type [ty]
fun conv_int (ty: ctype, n: integer): integer :=
{-
  if is_unspec(n) then
    unspecified(ty)
  else
-}
  -- (STD §6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if ty = !(_Bool) then
    if n = 0 then 0 else 1
  
  -- (STD §6.3.1.3#1) When a value with integer type is converted to another integer
  -- type other than _Bool, if the value can be represented by the new type, it
  -- is unchanged.
  else
    if is_representable_integer(n, ty) then
      n
  
  -- (STD §6.3.1.3#2) Otherwise, if the new type is unsigned, the value is converted
  -- by repeatedly adding or subtracting one more than the maximum value that
  -- can be represented in the new type until the value is in the range of the
  -- new type.
    else
      if is_unsigned(ty) then
        wrapI(ty, n)
  
  -- (STD §6.3.1.3#3) Otherwise, the new type is signed and the value cannot be
  -- represented in it; either the result is implementation-defined or an
  -- implementation-defined signal is raised.
      else
        <Integer.conv_nonrepresentable_signed_integer>(ty, n)

-- auxiliary function for the [conv] (see §6.3.1.3#1)
fun conv_aux (ty: ctype, n: integer) : integer :=
  n rem_f (Ivmax(ty) - Ivmin(ty) + 1)

fun conv_loaded_int (ty: ctype, _n: loaded integer): loaded integer :=
  case _n of
    | Specified(n:integer) =>
        Specified(conv_int(ty, n))
    | Unspecified(_: ctype) =>
        Unspecified(ty)
  end

fun loaded_fvfromint (ty: ctype, _n: loaded integer) : loaded floating :=
  case _n of
    | Specified(n:integer) =>
        Specified(Fvfromint(n))
    | Unspecified(_: ctype) =>
        Unspecified(ty)
  end

fun loaded_ivfromfloat (ty: ctype, _f: loaded floating) : loaded integer :=
  case _f of
    | Specified(f:floating) =>
        Specified(Ivfromfloat(ty, f))
    | Unspecified(_: ctype) =>
        Unspecified(ty)
  end

proc loaded_pointer_to_Bool (_ptr: loaded pointer) : eff loaded integer :=
  case _ptr of
    | Specified(ptr: pointer) =>
        let weak is_null: boolean = memop(PtrEq, ptr, NULL(void*)) in
        pure(Specified(if is_null then 0 else 1))
    | Unspecified(_: ctype) =>
        -- TODO: check
        pure(Unspecified(!(_Bool)))
  end



fun ctype_width (ty: ctype): integer :=
  Ivsizeof(ty) * <bits_in_byte>



{-

-- encode an element of Z into an element of N following the
-- two's complement encoding
fun encodeTwos (ty : ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width: integer = ctype_width(ty) in
  if n < Ivmin(ty) \/ Ivmax(ty) < n then
    error(<<<encodeTwos>>>, (width, ty, n))
  else if 0 <= n then
    n
  else
    2^width + n



-- the inverse of the previous function
fun decodeTwos (ty: ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width: integer = ctype_width(ty) in
  if (n < 0) \/ (2^width <= n) then
    error(<<<decodeTwos>>>, (ty, n))
  else if n <= 2^(width - 1) - 1 then
    n
  else
    n - 2^width

-- bitwise complement of a two's complement encoded integer
fun complementTwos_aux (n: integer, w: integer) : integer :=
  if w = 0 then
    n
  else
    let n_: integer = n / 2 in
    (1 - (n rem_f 2)) + 2 * complementTwos_aux(n_, w - 1)

fun complementTwos (ty:ctype, n: integer) : integer :=
  complementTwos_aux(n, ctype_width(ty))


-- bitwise AND
fun bitwise_AND_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_: integer = n1 / 2 in
    let n2_: integer = n2 / 2 in
    (if n1 rem_f 2 = 1 /\ n2 rem_f 2 = 1 then 1 else 0) + 2 * bitwise_AND_aux(n1_, n2_, w-1)

fun bitwise_AND (ty: ctype, n1: integer, n2: integer) : integer :=
--  if ty = "unsigned long" then
--    error(<<<WIP_bAND>>>, (ty, n1, n2))
--  else
    let n1_: integer = <Integer.encode>(ty, n1) in
    let n2_: integer = <Integer.encode>(ty, n2) in
    <Integer.decode>(ty, bitwise_AND_aux(n1_, n2_, ctype_width(ty)))


-- bitwise XOR
fun bitwise_XOR_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_: integer = n1 / 2 in
    let n2_: integer = n2 / 2 in
    (if (n1 rem_f 2) * (n2 rem_f 2) = 0 /\ not((n1 rem_f 2) + (n2 rem_f 2) = 0) then 1 else 0) + 2 * bitwise_XOR_aux(n1_, n2_, w-1)

fun bitwise_XOR (ty: ctype, n1: integer, n2: integer) : integer :=
--  if ty = "unsigned long" then
--    error(<<<WIP_bXOR>>>, Unit)
--  else
  let n1_: integer = <Integer.encode>(ty, n1) in
  let n2_: integer = <Integer.encode>(ty, n2) in
  <Integer.decode>(ty, bitwise_XOR_aux(n1_, n2_, ctype_width(ty)))


-- bitwise OR
fun bitwise_OR_aux(n1: integer, n2: integer, w: integer) : integer :=
  if w = 0 then
    0
  else
    let n1_: integer = n1 / 2 in
    let n2_: integer = n2 / 2 in
    (if n1 rem_f 2 = 1 \/ n2 rem_f 2 = 1 then 1 else 0) + 2 * bitwise_OR_aux(n1_, n2_, w-1)

fun bitwise_OR (ty: ctype, n1: integer, n2: integer) : integer :=
--  if ty = "unsigned long" then
--    error(<<<WIP_bOR>>>, Unit)
--  else
    let n1_: integer = <Integer.encode>(ty, n1) in
    let n2_: integer = <Integer.encode>(ty, n2) in
    <Integer.decode>(ty, bitwise_OR_aux(n1_, n2_, ctype_width(ty)))

-- ones_prefix(0, k, width) returns an positive integer whose binary
-- representation is 1    ...   1 0      ...       0
--                     k times     width - k times
fun ones_prefix (i: integer, k: integer, width: integer) : integer :=
  if (0 <= i) /\ (i < k) then
    2^(width - 1 - i) + ones_prefix(i+1, k, width)
  else
    0
-- gccSHR_Twos n m =
--  quot n (2^m) + (sum $ map (\i -> 2^(width - 1 - i)) [0..m-1])


-}




proc rev_listFromStr_aux(str: pointer, acc: [integer]) : eff [integer] :=
  let strong c_: loaded integer = load(!(char), array_shift(str, !(char), 0)) in
  case c_ of
    | Specified(c: integer) =>
        if c = 0 then
          pure(acc)
        else
          let strong ret: [integer] = pcall(rev_listFromStr_aux, array_shift(str, !(char), 1), c :: acc) in
          pure(ret)
    | Unspecified(_: ctype) =>
        pure (undef(<<DUMMY(rev_listFromStr_aux)>>)) -- TODO think about that
  end



-- TODO: this is the reverse
proc rev_listFromStr(str: pointer) : eff [integer] :=
--  pcall(Cfunction(rev_listFromStr_aux), str, [])

  let strong ret: [integer] = pcall(rev_listFromStr_aux, str, []) in
  pure(ret)





proc [ailname = "printf"] printf_proxy(tmp_ptr: {-loaded-} pointer, args: [(ctype, pointer)]) : eff loaded integer :=
  let strong frmt_ptr_: loaded pointer = load(!(char*), tmp_ptr) in
  case frmt_ptr_ of
    | Specified(frmt_ptr: pointer) =>
        let strong xs: [integer] = pcall(rev_listFromStr, frmt_ptr) in
        let strong ret: loaded integer = pcall(<std_function_printf>, xs, args) in
        pure(ret)
    | Unspecified(_: ctype) =>
        pure (undef(<<DUMMY(printf_proxy)>>)) -- TODO think about that
  end




proc [ailname = "malloc"] malloc_proxy (size_ptr: pointer) : eff loaded pointer :=
  let strong size_: loaded integer = load(!(size_t), size_ptr) in
  case size_ of
    | Specified(size: integer) =>
        let strong ptr: pointer = alloc(8 {- TODO -}, size) in
        pure(Specified(ptr))
    | Unspecified(_: ctype) =>
        pure(error(<<<malloc_proxy>>>, False))
  end

-- TODO: this is a hack for GCC torture while signal are not implemented
proc [ailname = "abort"] abort_proxy() : eff unit :=
  pure(error(<<<ABORT>>>, Unit))
proc [ailname = "exit"] exit_proxy(n: integer) : eff unit :=
  pure(error(<<<EXIT>>>, Unit))


-- see §5.1.2 from ISO/IEC 10967-1:1994(E)
fun wrapI(ty: ctype, n: integer) : integer :=
{-
  -- TODO: this is a temporary hack to prune executions with overflow on unsigned types
  if Ivmin(ty) <= n /\ n <= Ivmax(ty) then
    n
  else
    error(<<<wrapI>>>, Unit)
-}
    let dlt: integer = Ivmax(ty) - Ivmin(ty) + 1 in
    let r: integer = n rem_f dlt in
    if r <= Ivmax(ty) then
      r
    else
      r - dlt


proc [ailname= "memcpy"] memcpy_proxy (s1_ptr: pointer, s2_ptr: pointer, n_ptr: pointer) : eff loaded pointer :=
  let strong _s1: loaded pointer = load(!(void *), s1_ptr) in
  let strong _s2: loaded pointer = load(!(void *), s2_ptr) in
  let strong _n:  loaded integer = load(!(size_t), n_ptr)  in
  case (_s1, _s2, _n) of
    | (Specified(s1: pointer), Specified(s2: pointer), Specified(n: integer)) =>
        let strong res: pointer = memop(Memcpy, s1, s2, n) in
        pure(Specified(res))
    | _: (loaded pointer, loaded pointer, loaded integer) =>
        pure(undef(<<DUMMY(memcpy_proxy)>>)) -- TODO check that
  end


{-
void *memcpy(void * restrict s1, const void * restrict s2, size_t n);
-}

proc [ailname = "memcmp"] memcmp_proxy (p_ptr: pointer, q_ptr: pointer, size_ptr: pointer) : eff loaded integer :=
  let strong _p: loaded pointer = load(!(void *), p_ptr) in
  let strong _q: loaded pointer = load(!(void *), q_ptr) in
  let strong _size: loaded integer = load(!(size_t), size_ptr) in
  case (_p, _q, _size) of
    | (Specified(p: pointer), Specified(q: pointer), Specified(size: integer)) =>
        let strong res: integer = memop(Memcmp, p, q, size) in
        pure(Specified(res))
    | _: (loaded pointer, loaded pointer, loaded integer) =>
        pure(undef(<<DUMMY(memcmp_proxy)>>)) -- TODO check that
  end


proc [ailname = "free"] free_proxy (p_ptr: pointer) : eff unit :=
  let strong _p: loaded pointer = load(!(void *), p_ptr) in
  case _p of
    | Specified(p: pointer) =>
        let weak is_null: boolean = memop(PtrEq, p, NULL(void*)) in
        if is_null then
          skip
        else
          -- TODO: this is wrong, p was not allocated with alloc(), this should be UB
          kill(p)
    | _: loaded pointer =>
        pure(undef(<<DUMMY(kill_proxy_1)>>)) -- TODO check that
  end