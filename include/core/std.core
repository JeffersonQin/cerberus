------------------------------------------------------------------------------
-- CORE STDLIB
------------------------------------------------------------------------------

fun is_representable_integer (n: integer, ty: ctype): boolean :=
  Ivmin(ty) <= n /\ n <= Ivmax(ty)

fun is_representable_floating (f: floating, ty: ctype): boolean :=
  True
  -- FIXME: error(<<<is_representable_floating>>>, Unit)


fun all_values_representable_in (ty1: ctype, ty2: ctype): boolean :=
  Ivmin(ty2) <= Ivmin(ty1) /\ Ivmax(ty1) <= Ivmax(ty2)


-- STD §6.5#5
fun catch_exceptional_condition (ty: ctype, n: integer) : integer :=
  if is_representable_integer(n, ty) then
    n
  else
    undef(<<UB036_exceptional_condition>>)

-- [conv_int ty n] returns the value [n] converted to the integer type [ty]
fun conv_int (ty: ctype, n: integer): integer :=
{-
  if is_unspec(n) then
    unspecified(ty)
  else
-}
  -- (STD §6.3.1.2#1) When any scalar value is converted to _Bool, the result is 0 if the value compares
  -- equal to 0; otherwise, the result is 1.
  if ty = '_Bool' then
    if n = 0 then 0 else 1
  
  -- (STD §6.3.1.3#1) When a value with integer type is converted to another integer
  -- type other than _Bool, if the value can be represented by the new type, it
  -- is unchanged.
  else
    if is_representable_integer(n, ty) then
      n
  
  -- (STD §6.3.1.3#2) Otherwise, if the new type is unsigned, the value is converted
  -- by repeatedly adding or subtracting one more than the maximum value that
  -- can be represented in the new type until the value is in the range of the
  -- new type.
    else
      if is_unsigned(ty) then
        wrapI(ty, n)
  
  -- (STD §6.3.1.3#3) Otherwise, the new type is signed and the value cannot be
  -- represented in it; either the result is implementation-defined or an
  -- implementation-defined signal is raised.
      else
        <Integer.conv_nonrepresentable_signed_integer>(ty, n)

-- auxiliary function for the [conv] (see §6.3.1.3#1)
fun conv_aux (ty: ctype, n: integer) : integer :=
  n rem_f (Ivmax(ty) - Ivmin(ty) + 1)

fun conv_loaded_int (ty: ctype, _n: loaded integer): loaded integer :=
  case _n of
    | Specified(n:integer) =>
        Specified(conv_int(ty, n))
    | Unspecified(_: ctype) =>
        Unspecified(ty)
  end

fun loaded_fvfromint (ty: ctype, _n: loaded integer) : loaded floating :=
  case _n of
    | Specified(n:integer) =>
        Specified(Fvfromint(n))
    | Unspecified(_: ctype) =>
        Unspecified(ty)
  end

fun loaded_ivfromfloat (ty: ctype, _f: loaded floating) : loaded integer :=
  case _f of
    | Specified(f:floating) =>
        Specified(Ivfromfloat(ty, f))
    | Unspecified(_: ctype) =>
        Unspecified(ty)
  end

proc loaded_pointer_to_Bool (_ptr: loaded pointer) : eff loaded integer :=
  case _ptr of
    | Specified(ptr: pointer) =>
        let weak is_null: boolean = memop(PtrEq, ptr, NULL(void*)) in
        pure(Specified(if is_null then 0 else 1))
    | Unspecified(_: ctype) =>
        -- TODO: check
        pure(Unspecified('_Bool'))
  end

fun is_floating(ty: ctype): boolean :=
  ty = 'float' \/ ty = 'double' \/ ty = 'long_double'

fun params_length_aux (acc: integer, cs: [ctype]): integer :=
  case cs of
    | [] => acc
    | _:ctype :: xs:[ctype] => params_length_aux (acc+1, xs)
  end

fun params_length (cs: [ctype]): integer :=
  params_length_aux(0, cs)

fun params_nth (cs: [ctype], n: integer): ctype :=
  case cs of
    | [] =>
      error(<<<params_nth>>>, (cs, n))
    | x:ctype :: xs:[ctype] =>
      if n = 0 then
        x
      else if n > 0 then
        params_nth(xs, n-1)
      else
        error(<<<params_nth>>>, (cs, n))
  end

fun ctype_width (ty: ctype): integer :=
  Ivsizeof(ty) * <bits_in_byte>


-- encode an element of Z into an element of N following the
-- two's complement encoding
fun encodeTwos (ty : ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width: integer = ctype_width(ty) in
  if n < Ivmin(ty) \/ Ivmax(ty) < n then
    error(<<<encodeTwos>>>, (width, ty, n))
  else if 0 <= n then
    n
  else
    2^width + n


-- the inverse of the previous function
fun decodeTwos (ty: ctype, n: integer) : integer :=
  -- TODO: this assumes no padding bits
  let width: integer = ctype_width(ty) in
  if (n < 0) \/ (2^width <= n) then
    error(<<<decodeTwos>>>, (ty, n))
  else if n <= 2^(width - 1) - 1 then
    n
  else
    n - 2^width

-- bitwise complement of a two's complement encoded integer
fun complementTwos_aux (n: integer, w: integer) : integer :=
  if w = 0 then
    n
  else
    let n_: integer = n / 2 in
    (1 - (n rem_f 2)) + 2 * complementTwos_aux(n_, w - 1)

fun complementTwos (ty:ctype, n: integer) : integer :=
  complementTwos_aux(n, ctype_width(ty))

-- ones_prefix(0, k, width) returns an positive integer whose binary
-- representation is 1    ...   1 0      ...       0
--                     k times     width - k times
fun ones_prefix (i: integer, k: integer, width: integer) : integer :=
  if (0 <= i) /\ (i < k) then
    2^(width - 1 - i) + ones_prefix(i+1, k, width)
  else
    0

proc rev_listFromStr_aux(str: pointer, acc: [integer]) : eff [integer] :=
  let strong c_: loaded integer = load('char', array_shift(str, 'char', 0)) in
  case c_ of
    | Specified(c: integer) =>
        if c = 0 then
          pure(acc)
        else
          let strong ret: [integer] = pcall(rev_listFromStr_aux, array_shift(str, 'char', 1), c :: acc) in
          pure(ret)
    | Unspecified(_: ctype) =>
        pure (undef(<<DUMMY(rev_listFromStr_aux)>>)) -- TODO think about that
  end

-- TODO: this is the reverse
proc rev_listFromStr(str: pointer) : eff [integer] :=
--  pcall(Cfunction(rev_listFromStr_aux), str, [])

  let strong ret: [integer] = pcall(rev_listFromStr_aux, str, []) in
  pure(ret)

-- see §5.1.2 from ISO/IEC 10967-1:1994(E)
fun wrapI(ty: ctype, n: integer) : integer :=
{-
  -- TODO: this is a temporary hack to prune executions with overflow on unsigned types
  if Ivmin(ty) <= n /\ n <= Ivmax(ty) then
    n
  else
    error(<<<wrapI>>>, Unit)
-}
    let dlt: integer = Ivmax(ty) - Ivmin(ty) + 1 in
    let r: integer = n rem_f dlt in
    if r <= Ivmax(ty) then
      r
    else
      r - dlt

proc create_and_store (ty: ctype, x: storable) : eff pointer :=
  let weak p: pointer = create(Ivalignof(ty), ty) in
  let weak _: unit = store(ty, p, x) in
  pure(p)

------------------------------------------------------------------------------
-- <signal.h>
------------------------------------------------------------------------------

proc [ailname = "signal"] signal_proxy(sig_ptr: pointer, fn_ptr: pointer): eff loaded pointer :=
  let strong sig : loaded integer = load('signed int', sig_ptr) in
  -- let strong fn_  : loaded pointer = load('void (signed int)*', fn_ptr) in
  case sig of
    | Specified (n: integer) =>
        pcall(<std_function_signal>, n, fn_ptr)
    | Unspecified (_: ctype) =>
        pure(undef(<<DUMMY(signal_proxy)>>))
  end

------------------------------------------------------------------------------
-- <stdio.h>
------------------------------------------------------------------------------

proc [ailname = "printf"] printf_proxy(tmp_ptr: {-loaded-} pointer, args: [(ctype, pointer)]) : eff loaded integer :=
  let strong frmt_ptr_: loaded pointer = load('char*', tmp_ptr) in
  case frmt_ptr_ of
    | Specified(frmt_ptr: pointer) =>
        let strong xs: [integer] = pcall(rev_listFromStr, frmt_ptr) in
        let strong ret: loaded integer = pcall(<std_function_printf>, xs, args) in
        pure(ret)
    | Unspecified(_: ctype) =>
        pure (undef(<<DUMMY(printf_proxy)>>)) -- TODO think about that
  end

proc [ailname = "snprintf"] snprintf_proxy(s_ptr: pointer, n_ptr: pointer, tmp_ptr: {-loaded-} pointer, args: [(ctype, pointer)]) : eff loaded integer :=
  let strong s_: loaded pointer = load('char*', s_ptr) in
  let strong n_: loaded integer = load('size_t', n_ptr) in
  let strong frmt_ptr_: loaded pointer = load('char*', tmp_ptr) in
  case (s_, n_, frmt_ptr_) of
    | (Specified(s: pointer), Specified(n: integer), Specified(frmt_ptr: pointer)) =>
        let strong xs: [integer] = pcall(rev_listFromStr, frmt_ptr) in
        let strong ret: loaded integer = pcall(<std_function_snprintf>, s, n, xs, args) in
        pure(ret)
    | _ : (loaded pointer, loaded integer, loaded pointer) =>
        pure (undef(<<DUMMY(snprintf_proxy)>>)) -- TODO think about that
  end

proc [ailname = "sprintf"] sprintf_proxy(s_ptr: pointer, tmp_ptr: {-loaded-} pointer, args: [(ctype, pointer)]) : eff loaded integer :=
  let strong s_: loaded pointer = load('char*', s_ptr) in
  let strong frmt_ptr_: loaded pointer = load('char*', tmp_ptr) in
  case (s_, frmt_ptr_) of
    | (Specified(s: pointer), Specified(frmt_ptr: pointer)) =>
        let strong xs: [integer] = pcall(rev_listFromStr, frmt_ptr) in
        let strong ret: loaded integer = pcall(<std_function_sprintf>, s, xs, args) in
        pure(ret)
    | _ : (loaded pointer, loaded pointer) =>
        pure (undef(<<DUMMY(sprintf_proxy)>>)) -- TODO think about that
  end


------------------------------------------------------------------------------
-- <stdlib.h>
------------------------------------------------------------------------------

proc [ailname = "abort"] abort_proxy () : eff unit :=
  pure (error(<<<ABORT>>>, False))

proc [ailname = "exit"] exit_proxy (x_ptr: pointer) : eff unit :=
  let strong x: loaded integer = load('signed int', x_ptr) in
  pcall(<std_function_exit>, x)

proc [ailname = "_Exit"] _Exit_proxy (x_ptr: pointer) : eff unit :=
  let strong x: loaded integer = load('signed int', x_ptr) in
  pcall(<std_function__Exit>, x)

proc [ailname = "malloc"] malloc_proxy (size_ptr: pointer) : eff loaded pointer :=
  let strong size_: loaded integer = load('size_t', size_ptr) in
  case size_ of
    | Specified(size: integer) =>
        let strong ptr: pointer = alloc(8 {- TODO -}, size) in
        pure(Specified(ptr))
    | Unspecified(_: ctype) =>
        pure(error(<<<malloc_proxy>>>, False))
  end

proc [ailname = "realloc"] realloc_proxy (old_ptrptr: pointer, size_ptr: pointer) : eff loaded pointer :=
  let strong size_: loaded integer = load('size_t', size_ptr) in
  let strong old_ptrptr_: loaded pointer = load('void *', old_ptrptr) in
  case (size_, old_ptrptr_) of
    | (Specified(size: integer), Specified(old_ptr: pointer)) =>
        let strong ptr: pointer = memop(Realloc, 8, old_ptr, size) in
        pure(Specified(ptr))
    | (_: loaded integer, _: loaded pointer) =>
        pure(error(<<<malloc_proxy>>>, False))
  end

proc [ailname = "free"] free_proxy (p_ptr: pointer) : eff unit :=
  let strong _p: loaded pointer = load('void *', p_ptr) in
  case _p of
    | Specified(p: pointer) =>
        free(p)
    | _: loaded pointer =>
        pure(undef(<<DUMMY(kill_proxy_1)>>)) -- TODO check that
  end

proc [ailname = "aligned_alloc"] aligned_alloc_proxy (align_ptr: pointer, size_ptr: pointer) : eff loaded pointer :=
  let strong align_: loaded integer = load('size_t', align_ptr) in
  let strong size_: loaded integer = load('size_t', size_ptr) in
  case (align_, size_) of
    | (Specified(align: integer), Specified(size: integer)) =>
        if size rem_t align = 0 then
          let strong ptr: pointer = alloc(align, size) in
          pure(Specified(ptr))
        else
          pure(undef(<<DUMMY(align_alloc)>>))
    | (_: loaded integer, _: loaded integer) =>
        pure(error(<<<align_alloc_proxy>>>, False))
  end

------------------------------------------------------------------------------
-- <string.h>
------------------------------------------------------------------------------

proc [ailname= "memcpy"] memcpy_proxy (s1_ptr: pointer, s2_ptr: pointer, n_ptr: pointer) : eff loaded pointer :=
  let strong _s1: loaded pointer = load('void *', s1_ptr) in
  let strong _s2: loaded pointer = load('void *', s2_ptr) in
  let strong _n:  loaded integer = load('size_t', n_ptr)  in
  case (_s1, _s2, _n) of
    | (Specified(s1: pointer), Specified(s2: pointer), Specified(n: integer)) =>
        let strong res: pointer = memop(Memcpy, s1, s2, n) in
        pure(Specified(res))
    | _: (loaded pointer, loaded pointer, loaded integer) =>
        pure(undef(<<DUMMY(memcpy_proxy)>>)) -- TODO check that
  end

proc [ailname = "memcmp"] memcmp_proxy (p_ptr: pointer, q_ptr: pointer, size_ptr: pointer) : eff loaded integer :=
  let strong _p: loaded pointer = load('void *', p_ptr) in
  let strong _q: loaded pointer = load('void *', q_ptr) in
  let strong _size: loaded integer = load('size_t', size_ptr) in
  case (_p, _q, _size) of
    | (Specified(p: pointer), Specified(q: pointer), Specified(size: integer)) =>
        let strong res: integer = memop(Memcmp, p, q, size) in
        pure(Specified(res))
    | _: (loaded pointer, loaded pointer, loaded integer) =>
        pure(undef(<<DUMMY(memcmp_proxy)>>)) -- TODO check that
  end


