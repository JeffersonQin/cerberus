% NB the comments here relate to the Core source syntax; the Lem
% datatypes have additional values used at Core runtime


embed {{ lem 
open import Pervasives String_extra Global
import Symbol AilTypes Implementation_ Undefined Loc Cmm_csem
import Mem

open import Thread Core_ctype

module Cmm = Cmm_csem
}}

% (*
% (TODO C signals)
% type handler_event =
%   string (* TODO: fixed ctors? *)
% *)


metavar Symbol_t {{ lem Symbol.t }}  ::=  {{ phantom }} 
metavar tag {{ lem Symbol.t }}  ::=  {{ phantom }}  {{ com struct/union tag }}

indexvar n ::= {{ phantom }}

grammar

core_object_type {{ tex \textit{oTy} }} :: 'OTy_' ::= {{ com Core object types }}
%(those that may be memory read/stored, hence matching C object types) }}
  | integer                    :: ::  integer
  | floating                   :: ::  floating
  | pointer                    :: ::  pointer
  | cfunction                  :: ::  cfunction
  | array ( core_object_type ) :: ::  array
  | struct tag            :: ::  struct
  | union tag             :: ::  union

core_base_type {{ tex \textit{bTy} }} :: 'BTy_' ::= {{ com Core base types}}
   | unit                                       :: ::   unit    {{ com unit }}
   | boolean                                    :: ::   boolean {{ com boolean }}
   | Ctype                                      :: ::   ctype   {{ com C type }} {{ tex \ottkw{ctype} }}
   | [ core_base_type ]                         :: ::   list    {{ com list }}
   | ( core_base_type1 , .. , core_base_typen ) :: ::   tuple   {{ com tuple }}
   | core_object_type                           :: ::   object  {{ com C object value }}
   | loaded core_object_type                    :: ::   loaded  {{ com C object value or unspecified value }} {{ tex [[loaded]]\ [[core_object_type]] }}

% NOTE: loaded is the same as object, but has just been loaded from
% memory so the value may be unspecified
 


% Types discriminate between pure (TyBase) and effectful
% expressions (TyEffect)

core_type {{ tex \textit{coreTy} }} :: 'Ty' ::= {{ com Core types }}
   | core_base_type     :: :: Base        {{ com pure base type }}
   | eff core_base_type :: :: Effect      {{ com effectful base type }}
 
 
%TODO: maybe split apart this sym into different nonterminals? 
metavar sym {{ lem Symbol.t }} ::= {{ phantom }}  {{ com Symbolic names }}

metavar ksym {{ lem Symbol.t }} ::= {{ phantom }}  {{ com Continuation names }}


% (* Binary operators *)

grammar
 binop :: 'Op' ::= 
%   (* arithmetic operators *)
   | +     :: :: Add    
   | -     :: :: Sub    
   | *     :: :: Mul    
   | /     :: :: Div    
   | rem_t :: :: Rem_t  
%(* this the % of C ===> rem_t(x,y) = x - ((truncate(x/y) * y) *)
   | rem_f :: :: Rem_f 
%(* rem_t(x,y) = x - ((foor(x/y) * y) *)
   | ^     :: :: Exp
%   (* relational operators *)
   | =     :: :: Eq
   | >     :: :: Gt
   | <     :: :: Lt
   | >=    :: :: Ge
   | <=    :: :: Le
%   (* logical connectives *)
   | /\    :: :: And 
   | \/    :: :: Or




embed {{ lem
 
 instance (Eq binop)
   let (=)  = unsafe_structural_equality
   let (<>) = unsafe_structural_inequality
 end
 
 instance (Show binop)
   let show op = 
     match op with
     | OpAdd -> "OpAdd"
     | OpSub -> "OpSub"
     | OpMul -> "OpMul"
     | OpDiv -> "OpDiv"
     | OpRem_t -> "OpRem_t"
     | OpRem_f -> "OpRem_f"
     | OpExp -> "OpExp"
     | OpEq  -> "OpEq"
     | OpGt  -> "OpGt"
     | OpLt  -> "OpLt"
     | OpGe  -> "OpGe"
     | OpLe  -> "OpLe"
     | OpAnd -> "OpAnd"
     | OpOr  -> "OpOr"
     end
 end
}}



grammar
 polarity :: '' ::= {{ com  Polarity for actions }}
   | Pos   :: ::  Pos
   | Neg   :: ::  Neg


metavar 
Implementation__implementation_constant {{ lem Implementation_.implementation_constant }} {{ tex impl\_const }}::= {{ phantom }}

metavar tyvarsym {{ lem 'sym }} {{tex \mathit{sym} }}::= {{ phantom }}

grammar 
generic_name {{ tex name }} :: '' ::= {{ auxparam 'sym }}
   | tyvarsym                                    :: :: Sym   {{ com core identifier }} 
   | < Implementation__implementation_constant > :: :: Impl  {{ com implementation-defined constant }}


 
% (*
% declare {coq} rename type name = name_ (* workaround for Lem issue #87 *)
% 
% let nameEquality n1 n2 =
%   match (n1, n2) with
%   | (Sym s1, Sym s2)   -> s1 = s2
%   | (Sym _, _)         -> false
%   | (Impl i1, Impl i2) -> i1 = i2
%   | (Impl _, _)        -> false
%   end
% 
% instance (Eq name)
%   let (=)  = nameEquality
%   let (<>) = fun n1 n2 -> not (nameEquality n1 n2)
% end
% 
% instance (Show name)
%   let show n =
%     match n with
%     | Sym sym -> "Sym (" ^ show sym ^ ")"
%     | Impl i  -> "Impl (?)" (* TODO *)
%     end
% end
% *)
 
 
metavar Mem_integer_value {{ tex integer\_const }} {{ lem Mem.integer_value }} ::= {{ phantom }}  {{ com integer constant }}
metavar Mem_floating_value {{ tex float\_const }} {{ lem Mem.floating_value }} ::= {{ phantom }}  {{ com float constant }}
%metavar Mem_pointer_value {{ lem Mem.pointer_value }} ::= {{ phantom }}  
metavar Mem_mem_value {{ lem Mem.mem_value }} {{ tex memval }} ::= {{ phantom }}  
metavar Cabs_cabs_identifier {{ tex member }} {{ lem Cabs.cabs_identifier }} ::= {{ phantom }} {{ com C struct/union member name }}
 
grammar 
Mem_pointer_value :: '' ::= {{ phantom }} {{ lem Mem.pointer_value }}
   | nullptr ( ctype ) :: :: nullptr

% (* Object values (inhabitants of object types, hence values that can be read/stored) *)
grammar
generic_object_value {{ tex object\_value }}:: 'OV' ::=  {{ auxparam 'sym }}
   | Mem_integer_value :: :: integer  {{ com integer constant }}
   | Mem_floating_value :: :: floating {{ com floating-point constant }}
   | Mem_pointer_value :: :: pointer {{ com TODO: CHECK  null pointer constant }}
   | generic_name  :: :: cfunction {{ com C function pointer }}
   | array ( generic_object_value1 , .. , generic_object_valuen ) :: :: array {{ com C array value }}
   | ( struct sym ) { . Cabs_cabs_identifier1 = Mem_mem_value1 , .. , . Cabs_cabs_identifiern = Mem_mem_valuen } :: :: struct {{ com C struct value }}
   | ( union sym ) { . Cabs_cabs_identifier = Mem_mem_value } :: :: union {{ com C union value }}
 

metavar Mem_mem_constraint {{ lem Mem.mem_constraint }} ::= {{ phantom }}   
metavar ctype {{ lem ctype }} ::= {{ phantom }}   

grammar
list_Mem_mem_constraint :: '' ::=  {{ phantom }} {{ lem list Mem.mem_constraint }}
   | Mem_mem_constraint1 .. Mem_mem_constraintn :: :: list_mem_constraint

generic_value {{ tex value }} :: 'V' ::=  {{ auxparam 'sym }}
   | Constrained ( list_Mem_mem_constraint1 , generic_value1 ) .. ( list_Mem_mem_constraintn , generic_valuen ) :: :: constrained
   | generic_object_value :: :: object
   | Loaded ( generic_object_value ) :: :: loaded
   | Unspecified ( ctype ) :: :: unspecified
   | Unit :: :: unit
   | True :: :: true
   | False :: :: false
   | ctype :: :: ctype
   | core_base_type [ generic_value1 , .. , generic_valuen ] :: :: list
   | ( generic_value1 , .. , generic_valuen ) :: :: tuple
 

metavar ty {{ lem 'ty }} ::= {{ phantom }}
 

% TODO: maybe suppress ty in latex 
grammar
generic_ctor {{ tex ctor }} :: 'C' ::= {{ auxparam 'ty }}
   | Nil ty      :: :: nil         {{ com empty list  }} %  : [bTy] 
   | Cons        :: :: cons        {{ com cons  }} %  : bTy -> [bTy] -> [bTy] 
   | Tuple       :: :: tuple       {{ com tuple  }} %  : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN) 
   | Array       :: :: array       {{ com C array  }} %  : bTy -> ... -> bTy -> array bTy 
   | Ivmax       :: :: ivmax       {{ com max integer value }} %  : ctype -> integer 
   | Ivmin       :: :: ivmin       {{ com min integer value  }} %  : ctype -> integer 
   | Ivsizeof    :: :: ivsizeof    {{ com sizeof value  }} %  : ctype -> integer 
   | Ivalignof   :: :: ivalignof   {{ com alignof value  }} %  : ctype -> integer 
   | Loaded      :: :: loaded      {{ com non-unspecified loaded value  }} %  : objTy -> loaded objTy 
   | Unspecified :: :: unspecified {{ com unspecified value }} %  : ctype -> loaded (integer|floating|pointer|array|struct|union) 


% (*
% type pattern =
%     list (maybe (sym * core_base_type))
% *)

maybesym :: '' ::= {{ auxparam 'sym }} {{ lem maybe 'sym }} {{ phantom }}
   | _   :: :: Nothing 
   | sym :: :: Just


generic_pattern {{ tex pattern }} :: 'Case' ::= {{ auxparam 'ty 'sym }}
   | maybesym                                                  :: :: Base
   | generic_ctor ( generic_pattern1 , .. , generic_patternn ) :: :: Ctor
 

metavar Undefined_undefined_behaviour {{ lem Undefined.undefined_behaviour }}  ::=  {{ phantom }} 
metavar string {{ lem string }}  ::=  {{ phantom }} 

metavar Mem_pure_memop {{ lem Mem.pure_memop }} {{ tex memop }} ::= {{ phantom }}  
% TODO: introduce a phantom grammar for memop 

embed {{ lem
type sym = Symbol.t
type ksym = Symbol.t
}}

grammar
% (* pure Core expressions *)
pexpr_ :: 'PE' ::=  {{ auxparam 'ty 'sym }}
%   (* undefined behaviour and late static error / failed assert *)
   | undef ( Undefined_undefined_behaviour ) :: :: undef {{ com undefined behaviour }} 
   | error ( string , generic_pexpr )        :: :: error {{ com static error dependent on implementation-defined constant }}
 
%(* the expression is for debug purpose *)
 
%   (* values *)
   | generic_value                     :: :: val {{ com value }}
   | constrained ( list_Mem_mem_constraint1 , generic_pexpr1 ) .. ( list_Mem_mem_constraintn , generic_pexprn )  :: :: constrained {{ com constrained value }}
   
%   (* names *)
   | tyvarsym                          :: :: sym {{ com core identifier }}
   | < Implementation__implementation_constant > :: :: impl {{ com implementation-defined constant }} 
   
%   (* data (de|con)structors *)
   | generic_ctor ( generic_pexpr1 , ..  , generic_pexprn )  :: :: ctor  {{ com constructor application }}
   | case generic_pexpr with | generic_pattern1 => generic_pexpr1 .. | generic_patternn => generic_pexprn end :: :: case {{ com pattern matching }}
   
%   (* operators on pointer values *)
   | array_shift ( generic_pexpr1 , ctype , generic_pexpr2 )   :: :: array_shift {{ com pointer array shift }}
   | member_shift ( generic_pexpr , tag . Cabs_cabs_identifier ) :: :: member_shift {{ com pointer struct/union member shift }}
   
%   (* operators on integers *)
   | not ( generic_pexpr )          :: :: not {{ com not }} 
   |  generic_pexpr1 binop generic_pexpr2  :: :: op {{ order [[binop]] [[generic_pexpr1]] [[generic_pexpr2]] }} {{ com binop }}
   
%   (* pure operations provide by the memory layout model *)
   | memop ( Mem_pure_memop , generic_pexpr1 , .. , generic_pexprn ) :: :: memop {{ com memory operation }}
%   (* these two are annoying *) 
   | ( struct tag ) { . Cabs_cabs_identifier1 = generic_pexpr1 , .. , . Cabs_cabs_identifiern = generic_pexprn } :: :: struct {{ com C struct expression }}
 
% TODO what about unions???!

%   (* call to a pure function *)
   | generic_name ( generic_pexpr1 , .. , generic_pexprn ) :: :: call {{ com pure Core function call }}
   
   | let generic_pattern = generic_pexpr1 in generic_pexpr2  :: :: let {{ com Core let }}
   | if generic_pexpr then generic_pexpr1 else generic_pexpr2  :: :: if {{ com Core if }}
   
 %(*  | vla ctype * pexpr *)
 
 
 %  (* TODO: this is a temporary, because I don't want to add pattern matching in Core, and those functions need it *)
   | is_scalar ( generic_pexpr   ) :: :: is_scalar
   | is_integer ( generic_pexpr  ) :: :: is_integer
   | is_signed ( generic_pexpr   ) :: :: is_signed
   | is_unsigned ( generic_pexpr ) :: :: is_unsigned
 
generic_pexpr {{ tex pe }} :: 'P' ::= {{ auxparam 'ty 'sym }}
   | Pexpr ty pexpr_ :: :: expr
 
metavar a {{ lem 'a }} ::= {{ phantom }}
metavar nat {{ lem nat }} ::= {{ phantom }}
metavar Thread_thread_id {{ lem Thread.thread_id }} ::= {{ phantom }}
metavar Loc_t {{ lem Loc.t }} ::= {{ phantom }}
metavar Cmm_memory_order {{ lem Cmm.memory_order }} ::= {{ phantom }}
metavar Symbol_prefix {{ lem Symbol.prefix }}  ::=  {{ phantom }} 

grammar

maybe_Symbol_t_core_base_type :: '' ::=  {{ lem maybe (Symbol.t * core_base_type) }} {{ phantom }}

generic_expr :: 'E' ::= {{ auxparam 'a 'ty 'sym }}
%   (* pure expression *)
   | generic_pexpr :: :: pure
%   (* operations (that either require sequencing or are ND) provide by the memory layout model *)
   | memop Mem_pure_memop generic_pexpr1 .. generic_pexprn :: :: memop
% (*
% (TODO C signals)
%   (* these two are to deal with C signals *)
%   | Eraise handler_event
%   | Eregister handler_event * name
% *)
%   (* potentially effectful *)
   | skip :: :: skip
   | let generic_pattern = generic_pexpr in generic_expr :: :: let
   | Eif generic_pexpr generic_expr1 generic_expr2 :: :: if
   | Ecase generic_pexpr ( generic_pattern1 , generic_expr1 ) .. ( generic_patternn , generic_exprn ) :: :: case
   | Eproc a generic_pexpr generic_pexpr1 .. generic_pexprn :: :: proc
   | Eaction generic_paction  :: :: action
%   (* sequencing operators *)
   | Eunseq generic_expr1 .. generic_exprn :: :: unseq
   | letw generic_pattern = generic_expr1 in generic_expr2 :: :: wseq
   | lets generic_pattern = generic_expr1 in generic_expr2 :: :: sseq
   | Easeq maybe_Symbol_t_core_base_type generic_action1 generic_paction2 :: :: aseq % (* this ctor doesn't exist at runtine *)
%   (* indeterminately-sequenced expressions and boundary *) 
   | Eindet generic_expr :: :: indet %(* TODO: add unique indices *) (* this ctor doesn't exist at runtine *)
   | Ebound nat generic_expr :: :: bound %(* this ctor doesn't exist at runtine *)
%   (* Continuation operators *)
%   (* TODO: may have to add the possibility storing a number instead a ctype (for dynamically allocated objects) *)
   | Esave ksym ( Symbol_t1 ctype1 ) .. ( Symbol_tn ctypen ) generic_expr :: :: save
   | Erun a ksym ( Symbol_t1 , generic_pexpr1 ) .. ( Symbol_tn , generic_pexprn ) :: :: run
   | return ( generic_pexpr ) :: :: return
%   (* Non deterministic choice (resulting from indet expressions) *)
%   (* TODO: this only exists for the second stage dynamics (after core_indet) *)
   | nd ( generic_expr1 , .. , generic_exprn ) :: ::  nd
%   (* Thread operators *)
%   (* TODO: this ctor is kind redundant once we add Espawn, since we have Eunseq ... *)
   | par ( generic_expr1 , .. , generic_exprn ) :: :: par %(* Parallel composition: for cppmem-style composition *)
   | Ewait Thread_thread_id :: :: wait %(* TODO: this will need to have a Core type annotation to allow typecheck ... *)
   | Eloc Loc_t generic_expr :: :: loc
 
 %(* the qualification prefixes are for pprint *)
% WAS generic_action_ in source
 generic_actionB {{ lem generic_action_ }} :: '' ::= {{ auxparam 'ty 'sym }}
   | Create generic_pexpr1 generic_pexpr2 Symbol_prefix :: :: Create %(* the expr arguments are: alignment requirement, effective type *)
   | Alloc generic_pexpr1 generic_pexpr2 Symbol_prefix :: :: Alloc  %(* the expr arguments are: alignment requirement, space size *)
   | Kill generic_pexpr :: :: Kill
   | Store generic_pexpr1 generic_pexpr2 generic_pexpr Cmm_memory_order :: :: Store
   | Load generic_pexpr1 generic_pexpr2 Cmm_memory_order :: :: Load
   | RMW generic_pexpr1  generic_pexpr2 generic_pexpr3 generic_pexpr4 Cmm_memory_order1 Cmm_memory_order2 :: :: RMW
%   | RMW generic_pexpr(* ctype *) generic_pexpr(* object_ptr *) generic_pexpr(* expected_val *) generic_pexpr(* desired_val *) Cmm.memory_order Cmm.memory_order
 
% (*
%   | CompareExchangeStrong pexpr pexpr pexpr pexpr Cmm.memory_order Cmm.memory_order
%   | CompareExchangeWeak pexpr pexpr pexpr pexpr Cmm.memory_order Cmm.memory_order
% *)
   
%   (* TODO: it annoying (maybe wrong) that these are actions *)
% (*  | Ptr pointer_action list pexpr *)
 


 generic_action :: '' ::= {{ auxparam 'a 'ty 'sym }}
    |  Action Loc_t a generic_actionB  :: :: Action 
 generic_paction :: '' ::= {{ auxparam 'a 'ty 'sym }}
    |  Paction polarity generic_action :: :: Paction



terminals :: 'terminal' ::=
   | /\    :: :: And  {{ tex \wedge }}
   | \/    :: :: Or   {{ tex \vee }}

   | array_shift :: :: array_shift {{ tex \ottkw{array\_shift} }}
   | member_shift :: :: member_shift {{ tex \ottkw{member\_shift} }}
   | is_scalar   :: :: is_scalar   {{ tex \ottkw{is\_scalar  } }}
   | is_integer  :: :: is_integer  {{ tex \ottkw{is\_integer } }}
   | is_signed   :: :: is_signed   {{ tex \ottkw{is\_signed  } }}
   | is_unsigned :: :: is_unsigned {{ tex \ottkw{is\_unsigned} }}
embed {{ lem 
 
 type name         = generic_name Symbol.t
 type object_value = generic_object_value Symbol.t
 type value        = generic_value Symbol.t
 type ctor         = generic_ctor Symbol.t
 type pattern      = generic_pattern core_base_type Symbol.t
 type pexpr        = generic_pexpr core_base_type Symbol.t
 type expr 'a      = generic_expr 'a core_base_type Symbol.t
 type paction 'a   = generic_paction 'a core_base_type Symbol.t
 
 
 
 
 
 
 
 (* TODO: don't we need any impl proc? *)
 type impl_decl =
   | Def of core_base_type * pexpr
   | IFun of core_base_type * list (Symbol.t * core_base_type) * pexpr
 type impl = map Implementation_.implementation_constant impl_decl
 (*
 type impl_decl =
   | IConst  core_base_type * value
   | IFun core_base_type * list (sym * core_base_type) * pexpr
 type impl = map Impl_types.impl_name impl_decl
 *)
 
 
 type fun_map_decl 'a =
   | Fun of core_base_type * list (Symbol.t * core_base_type) * pexpr
   | Proc of core_base_type * list (Symbol.t * core_base_type) * expr 'a
 
 type fun_map 'a = map Symbol.t (fun_map_decl 'a)
 
 
 (* a Core file is just a set named functions *)
 type file 'a = <|
   main   : Symbol.t;
   stdlib : fun_map 'a;
   impl   : impl;
   globs  : list (Symbol.t * core_type * expr 'a);
   funs   : fun_map 'a;
 |>
 declare {coq} rename type impl = impl_ (* workaround for Lem issue #74 *)
 
 
 
 
 
 
 
 
 
 (* runtime stuff *)
 
 type continuation_element 'a =
   | Kunseq of list (expr 'a) * list (expr 'a)
   | Kwseq  of pattern * expr 'a
   | Ksseq  of pattern * expr 'a
 (*  | Ktry   list (string * expr 'a) *)
 
 
 type continuation 'a = list (continuation_element 'a)
 
 
 type labeled_continuation 'a = list (Symbol.t * ctype) * expr 'a
 
 
 type stack 'a =
   | Stack_empty
   | Stack_cons of continuation 'a * stack 'a
 
 
 
 
 
 
 (* basic class instanciations *)
 instance (SetType polarity)
   let setElemCompare = defaultCompare
 end
}}