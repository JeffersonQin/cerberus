% NB the comments here relate to the Core source syntax; the Lem
% datatypes have additional values used at Core runtime

embed {{ tex-preamble
%\usepackage[scaled=0.82]{beramono}
\renewcommand{\ottkw}[1]{\texttt{#1}%
}
}}


embed {{ lem 
open import Pervasives String_extra Global
import Symbol AilTypes Implementation_ Undefined Loc Cmm_csem
import Mem

open import Thread Core_ctype

module Cmm = Cmm_csem
}}

% (*
% (TODO C signals)
% type handler_event =
%   string (* TODO: fixed ctors? *)
% *)


metavar Symbol_t {{ tex sym }} {{ lem Symbol.t }}  ::=  {{ phantom }} 
metavar tag {{ lem Symbol.t }}  ::=  {{ phantom }}  {{ com struct/union tag }}

indexvar n, i ::= {{ phantom }}

grammar

core_object_type {{ tex \textit{oTy} }} :: 'OTy_' ::= {{ com types for C objects}}
%(those that may be memory read/stored, hence matching C object types) }}
  | integer                    :: ::  integer
  | floating                   :: ::  floating
  | pointer                    :: ::  pointer
  | cfunction                  :: ::  cfunction
  | array ( core_object_type ) :: ::  array
  | struct tag            :: ::  struct
  | union tag             :: ::  union

core_base_type {{ tex \textit{bTy} }} :: 'BTy_' ::= {{ com Core base types}}
   | unit                                       :: ::   unit    {{ com unit }}
   | boolean                                    :: ::   boolean {{ com boolean }}
   | Ctype                                      :: ::   ctype   {{ com Core type of C type exprs}} {{ tex \ottkw{ctype} }}
   | [ core_base_type ]                         :: ::   list    {{ com list }}
%   | ( core_base_type1 , .. , core_base_typen ) :: ::   tuple   {{ com tuple }}
   | ( </ core_base_typei // , // i /> ) :: ::   tuple   {{ com tuple }}
   | core_object_type                           :: ::   object  {{ com C object value }}
   | loaded core_object_type                    :: ::   loaded  {{ com [[core_object_type]] or unspecified value }} {{ tex [[loaded]]\ [[core_object_type]] }}

% NOTE: loaded is the same as object, but has just been loaded from
% memory so the value may be unspecified
 


% Types discriminate between pure (TyBase) and effectful
% expressions (TyEffect)

core_type {{ tex \textit{coreTy} }} :: 'Ty' ::= {{ com Core types }}
   | core_base_type     :: :: Base        {{ com pure base type }}
   | eff core_base_type :: :: Effect      {{ com effectful base type }}
 
 
%TODO: maybe split apart this sym into different nonterminals? 
metavar sym {{ lem Symbol.t }} ::= {{ phantom }}  {{ com Symbolic names }}

metavar label {{ lem Symbol.t }} ::= {{ phantom }}  {{ com Continuation names }}


% (* Binary operators *)

grammar
 binop :: 'Op' ::= 
%   (* arithmetic operators *)
   | +     :: :: Add    
   | -     :: :: Sub    
   | *     :: :: Mul    
   | /     :: :: Div    
   | rem_t :: :: Rem_t  
%(* this the % of C ===> rem_t(x,y) = x - ((truncate(x/y) * y) *)
   | rem_f :: :: Rem_f 
%(* rem_t(x,y) = x - ((foor(x/y) * y) *)
   | ^     :: :: Exp
%   (* relational operators *)
   | =     :: :: Eq
   | >     :: :: Gt
   | <     :: :: Lt
   | >=    :: :: Ge
   | <=    :: :: Le
%   (* logical connectives *)
   | /\    :: :: And 
   | \/    :: :: Or




embed {{ lem
 
 instance (Eq binop)
   let (=)  = unsafe_structural_equality
   let (<>) = unsafe_structural_inequality
 end
 
 instance (Show binop)
   let show op = 
     match op with
     | OpAdd -> "OpAdd"
     | OpSub -> "OpSub"
     | OpMul -> "OpMul"
     | OpDiv -> "OpDiv"
     | OpRem_t -> "OpRem_t"
     | OpRem_f -> "OpRem_f"
     | OpExp -> "OpExp"
     | OpEq  -> "OpEq"
     | OpGt  -> "OpGt"
     | OpLt  -> "OpLt"
     | OpGe  -> "OpGe"
     | OpLe  -> "OpLe"
     | OpAnd -> "OpAnd"
     | OpOr  -> "OpOr"
     end
 end
}}



grammar
 polarity :: '' ::= {{ com  Polarity for actions }}
   | Pos   :: ::  Pos
   | Neg   :: ::  Neg


metavar 
Implementation__implementation_constant {{ lem Implementation_.implementation_constant }} {{ tex \ottnt{\texttt{<}impl\textit{-}const\texttt{>} } }}::= {{ phantom }}

metavar tyvarsym {{ lem 'sym }} {{tex \mathit{sym} }}::= {{ phantom }}

grammar 
generic_name {{ tex name }} :: '' ::= {{ auxparam 'sym }}
   | tyvarsym                                :: :: Sym   {{ com Core identifier }} 
   | Implementation__implementation_constant :: :: Impl  {{ com implementation-defined constant }}


 
% (*
% declare {coq} rename type name = name_ (* workaround for Lem issue #87 *)
% 
% let nameEquality n1 n2 =
%   match (n1, n2) with
%   | (Sym s1, Sym s2)   -> s1 = s2
%   | (Sym _, _)         -> false
%   | (Impl i1, Impl i2) -> i1 = i2
%   | (Impl _, _)        -> false
%   end
% 
% instance (Eq name)
%   let (=)  = nameEquality
%   let (<>) = fun n1 n2 -> not (nameEquality n1 n2)
% end
% 
% instance (Show name)
%   let show n =
%     match n with
%     | Sym sym -> "Sym (" ^ show sym ^ ")"
%     | Impl i  -> "Impl (?)" (* TODO *)
%     end
% end
% *)
 
 
metavar Mem_integer_value {{ tex integer\_const }} {{ lem Mem.integer_value }} ::= {{ phantom }}  {{ com integer constant }}
metavar Mem_floating_value {{ tex float\_const }} {{ lem Mem.floating_value }} ::= {{ phantom }}  {{ com float constant }}
%metavar Mem_pointer_value {{ lem Mem.pointer_value }} ::= {{ phantom }}  
metavar Mem_mem_value {{ lem Mem.mem_value }} {{ tex memval }} ::= {{ phantom }}  
metavar Cabs_cabs_identifier {{ tex member }} {{ lem Cabs.cabs_identifier }} ::= {{ phantom }} {{ com C struct/union member name }}
 
grammar 
Mem_pointer_value {{ tex pointerval }} :: '' ::= {{ phantom }} {{ lem Mem.pointer_value }}
   | nullptr ( ctype ) :: :: nullptr

% (* Object values (inhabitants of object types, hence values that can be read/stored) *)
grammar
generic_object_value {{ tex object\_value }}:: 'OV' ::=  {{ auxparam 'sym }} {{ com C object value }} 
   | Mem_integer_value :: :: integer  {{ com integer constant }}
   | Mem_floating_value :: :: floating {{ com floating-point constant }}
   | Mem_pointer_value :: :: pointer {{ com TODO null pointer constant? }}
   | generic_name  :: :: cfunction {{ com C function pointer }}
%   | array ( generic_object_value1 , .. , generic_object_valuen ) :: :: array {{ com C array value }}
   | array ( </ generic_object_valuei // , // i /> ) :: :: array {{ com C array value }}
%   | ( struct tag ) { . Cabs_cabs_identifier1 = Mem_mem_value1 , .. , . Cabs_cabs_identifiern = Mem_mem_valuen } :: :: struct {{ com C struct value }}
   | ( struct tag ) { </ . Cabs_cabs_identifieri = Mem_mem_valuei // , // i /> } :: :: struct {{ com C struct value }}
   | ( union tag ) { . Cabs_cabs_identifier = Mem_mem_value } :: :: union {{ com C union value }}
 

metavar Mem_mem_constraint {{ tex Mem.mem\_constraint }} {{ lem Mem.mem_constraint }} ::= {{ phantom }}   
metavar ctype {{ lem ctype }} ::= {{ phantom }}   

grammar
list_Mem_mem_constraint {{ tex mcs }} :: '' ::=  {{ phantom }} {{ lem list Mem.mem_constraint }}
% {{ tex list Mem.mem\_constraint }}
   | </ Mem_mem_constrainti // , // i /> :: :: list_mem_constraint

generic_value {{ tex value }} :: 'V' ::=  {{ auxparam 'sym }} {{ com Core value }}
   | Constrained ( list_Mem_mem_constraint1 , generic_value1 ) .. ( list_Mem_mem_constraintn , generic_valuen ) :: X :: constrained
   | generic_object_value :: :: object {{ com C object value }} 
   | Loaded ( generic_object_value ) :: :: loaded {{ com non-unspecified loaded value }}
   | Unspecified ( ctype ) :: :: unspecified      {{ com unspecified loaded value }} 
   | Unit :: :: unit                              {{ com unit }}
   | True :: :: true                              {{ com true }}
   | False :: :: false                            {{ com false }}
   | ctype :: :: ctype                            {{ com C type expr }}
   | core_base_type [ generic_value1 , .. , generic_valuen ] :: :: list {{ com list }}
   | ( generic_value1 , .. , generic_valuen ) :: :: tuple {{ com tuple }}
 

metavar ty {{ tex ty }} {{ lem 'ty }} ::= {{ phantom }}
 

% TODO: maybe suppress ty in latex 
grammar
generic_ctor {{ tex ctor }} :: 'C' ::= {{ auxparam 'ty }}
   | Nil ty      :: :: nil         {{ com empty list  }} %  : [bTy] 
   | Cons        :: :: cons        {{ com cons  }} %  : bTy -> [bTy] -> [bTy] 
   | Tuple       :: :: tuple       {{ com tuple  }} %  : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN) 
   | Array       :: :: array       {{ com C array  }} %  : bTy -> ... -> bTy -> array bTy 
   | Ivmax       :: :: ivmax       {{ com max integer value }} %  : ctype -> integer 
   | Ivmin       :: :: ivmin       {{ com min integer value  }} %  : ctype -> integer 
   | Ivsizeof    :: :: ivsizeof    {{ com sizeof value  }} %  : ctype -> integer 
   | Ivalignof   :: :: ivalignof   {{ com alignof value  }} %  : ctype -> integer 
   | Loaded      :: :: loaded      {{ com non-unspecified loaded value  }} %  : objTy -> loaded objTy 
   | Unspecified :: :: unspecified {{ com unspecified value }} %  : ctype -> loaded (integer|floating|pointer|array|struct|union) 


% (*
% type pattern =
%     list (maybe (sym * core_base_type))
% *)

maybesym :: '' ::= {{ auxparam 'sym }} {{ lem maybe 'sym }} {{ phantom }}
   | _   :: :: Nothing 
   | sym :: :: Just


generic_pattern {{ tex pat }} :: 'Case' ::= {{ auxparam 'ty 'sym }}
   | maybesym                                                  :: :: Base
   | generic_ctor ( generic_pattern1 , .. , generic_patternn ) :: :: Ctor
 

metavar Undefined_undefined_behaviour {{ tex \ottnt{ub\textit{-}name} }} {{ lem Undefined.undefined_behaviour }}  ::=  {{ phantom }} 
metavar string {{ lem string }}  ::=  {{ phantom }} 

metavar Mem_pure_memop {{ lem Mem.pure_memop }} {{ tex memop }} ::= {{ phantom }}  
% TODO: introduce a phantom grammar for memop 
% TODO: P wonders whether there is a distinction between pure memop and impure memop?  The idea of a "pure memop" may confuse, so we'd better be clear...

embed {{ lem
type sym = Symbol.t
type ksym = Symbol.t
}}

grammar
pexpr_ {{ tex pe }} :: 'PE' ::=  {{ auxparam 'ty 'sym }} {{ com Core pure expressions }} 
%   (* undefined behaviour and late static error / failed assert *)
   | undef ( Undefined_undefined_behaviour ) :: :: undef {{ com undefined behaviour }} 
   | error ( string , generic_pexpr )        :: :: error {{ com impl-def static error }}
 
%(* the expression is for debug purpose *)
 
%   (* values *)
   | generic_value                     :: :: val {{ com value }}
   | constrained ( list_Mem_mem_constraint1 , generic_pexpr1 ) .. ( list_Mem_mem_constraintn , generic_pexprn )  :: X :: constrained {{ com constrained value }}
   
%   (* names *)
   | tyvarsym                          :: :: sym {{ com core identifier }}
   | Implementation__implementation_constant :: :: impl {{ com implementation-defined constant }} 
   
%   (* data (de|con)structors *)
   | generic_ctor ( generic_pexpr1 , ..  , generic_pexprn )  :: :: ctor  {{ com constructor application }}
%   | case generic_pexpr with | generic_pattern1 => generic_pexpr1 .. | generic_patternn => generic_pexprn end :: :: case {{ com pattern matching }}
   | case generic_pexpr with </ | generic_patterni => generic_pexpri // i /> end :: :: case {{ com pattern matching }}
   
%   (* operators on pointer values *)
   | array_shift ( generic_pexpr1 , ctype , generic_pexpr2 )   :: :: array_shift {{ com pointer array shift }}
   | member_shift ( generic_pexpr , tag . Cabs_cabs_identifier ) :: :: member_shift {{ com pointer struct/union member shift }}
   
%   (* operators on integers *)
   | not ( generic_pexpr )          :: :: not {{ com integer not }} 
   |  generic_pexpr1 binop generic_pexpr2  :: :: op {{ order [[binop]] [[generic_pexpr1]] [[generic_pexpr2]] }} {{ com integer binop }}
   
%   (* pure operations provided by the memory layout model *)
   | memop ( Mem_pure_memop , generic_pexpr1 , .. , generic_pexprn ) :: :: memop {{ com pure memory operation }}
%   (* these two are annoying *) 
%   | ( struct tag ) { . Cabs_cabs_identifier1 = generic_pexpr1 , .. , . Cabs_cabs_identifiern = generic_pexprn } :: :: struct {{ com C struct expression }}
   | ( struct tag ) { </ . Cabs_cabs_identifieri = generic_pexpri // , // i /> } :: :: struct {{ com C struct expression }}
   | ( union tag ) { . Cabs_cabs_identifier = generic_pexpr } :: :: union {{ com C union expression }}
 

%   (* call to a pure function *)
   | generic_name ( generic_pexpr1 , .. , generic_pexprn ) :: :: call {{ com pure Core function call }}
   
   | let generic_pattern = generic_pexpr1 in generic_pexpr2  :: :: let {{ com pure Core let }}
   | if generic_pexpr then generic_pexpr1 else generic_pexpr2  :: :: if {{ com pure Core if }}
   
 %(*  | vla ctype * pexpr *)
 
 
 %  (* TODO: this is a temporary, because I don't want to add pattern matching in Core, and those functions need it *)
   | is_scalar ( generic_pexpr   ) :: :: is_scalar
   | is_integer ( generic_pexpr  ) :: :: is_integer
   | is_signed ( generic_pexpr   ) :: :: is_signed
   | is_unsigned ( generic_pexpr ) :: :: is_unsigned
 
generic_pexpr {{ tex pe }} :: 'P' ::= {{ auxparam 'ty 'sym }}
   | Pexpr ty pexpr_ :: :: expr
% in the generated paper LaTeX we suppress the distinction between pexpr_ and generic_pexpr by rendering both with {{ tex pe }} 

metavar a {{ tex }} {{ lem 'a }} ::= {{ phantom }}
metavar nat {{ tex n }} {{ lem nat }} ::= {{ phantom }}
metavar Thread_thread_id {{ tex \ottnt{thread\textit{-}id} }} {{ lem Thread.thread_id }} ::= {{ phantom }}
metavar Loc_t {{ lem Loc.t }} ::= {{ phantom }}
metavar Cmm_memory_order {{ tex \ottnt{memory\textit{-}order} }} {{ lem Cmm.memory_order }} ::= {{ phantom }}
metavar Symbol_prefix {{ tex }} {{ lem Symbol.prefix }}  ::=  {{ phantom }} 

grammar

maybe_Symbol_t_core_base_type {{ tex  (sym: oTy) }} :: '' ::=  {{ lem maybe (Symbol.t * core_base_type) }} {{ phantom }}

generic_expr {{ tex e }} :: 'E' ::= {{ auxparam 'a 'ty 'sym }}  {{ com Core expressions }} 
%   (* pure expression *)
   | pure ( generic_pexpr ) :: :: pure  {{ com  pure expression }}
%   (* operations (that either require sequencing or are ND) provide by the memory layout model *)
   | memop ( Mem_pure_memop , generic_pexpr1 , .. , generic_pexprn ) :: :: memop {{ com memory operation }}
% (*
% (TODO C signals)
%   (* these two are to deal with C signals *)
%   | Eraise handler_event
%   | Eregister handler_event * name
% *)
%   (* potentially effectful *)
   | skip :: :: skip {{ com  skip }}
   | let generic_pattern = generic_pexpr in generic_expr :: :: let {{ com Core let  }}
   | if generic_pexpr then generic_expr1 else generic_expr2 :: :: if {{ com Core if  }}
%   | case generic_pexpr with | generic_pattern1 => generic_expr1 .. | generic_patternn => generic_exprn end :: :: case {{ com pattern matching }}
   | case generic_pexpr with </ | generic_patterni => generic_expri // i /> end :: :: case {{ com pattern matching }}
   | pcall ( a  generic_pexpr , generic_pexpr1 , .. , generic_pexprn ) :: :: proc {{ com procedure call }}
   | generic_paction  :: :: action {{ com memory action }}
%   (* sequencing operators *)
   | unseq ( generic_expr1 , .. , generic_exprn ) :: :: unseq {{ com unsequenced expressions }}
   | let weak generic_pattern = generic_expr1 in generic_expr2 :: :: wseq {{ com weak sequencing }}
   | let strong generic_pattern = generic_expr1 in generic_expr2 :: :: sseq {{ com strong sequencing }}
   | let atomic maybe_Symbol_t_core_base_type = generic_action1 in generic_paction2 :: :: aseq  {{ com atomic sequencing }}% (* this ctor doesn't exist at runtine *)
%   (* indeterminately-sequenced expressions and boundary *) 
   | indet [ nat ] ( generic_expr ) :: :: indet  {{ com indeterminately sequenced expression }} %(* TODO: add unique indices *) (* this ctor doesn't exist at runtine *)
   | bound [ nat ] ( generic_expr ) :: :: bound  {{ com indeterminate sequencing boundary }} %(* this ctor doesn't exist at runtine *)
%   (* Continuation operators *)
%   (* TODO: may have to add the possibility storing a number instead a ctype (for dynamically allocated objects) *)
%   | save label ( Symbol_t1 : ctype1 ,  .. , Symbol_tn : ctypen ) in generic_expr :: :: save
   | save label ( </ Symbol_ti : ctypei // , // i /> ) in generic_expr :: :: save  {{ com save label }}
%   | run a label ( Symbol_t1 := generic_pexpr1 , .. , Symbol_tn := generic_pexprn ) :: :: run
   | run a label ( </ Symbol_ti := generic_pexpri // , // i /> ) :: :: run  {{ com run from label }}
%   | return ( generic_pexpr ) :: :: return
%   (* Non deterministic choice (resulting from indet expressions) *)
%   (* TODO: this only exists for the second stage dynamics (after core_indet) *)
   | nd ( generic_expr1 , .. , generic_exprn ) :: ::  nd {{ com nondetermnistic sequencing }}
% TODO shouldn't this come with the other sequencing operations?
%   (* Thread operators *)
%   (* TODO: this ctor is kind redundant once we add Espawn, since we have Eunseq ... *)
   | par ( generic_expr1 , .. , generic_exprn ) :: :: par  {{ com cppmem thread creation }}%(* Parallel composition: for cppmem-style composition *)
   | wait ( Thread_thread_id ) :: :: wait  {{ com TODO: need to be removed from the TeX }}%(* TODO: this will need to have a Core type annotation to allow typecheck ... *)
   | Eloc Loc_t generic_expr :: X :: loc {{ com TODO: need to be removed from the TeX  }}
% TODO: P suppressed Eloc in latex - is that right? 

 %(* the qualification prefixes are for pprint *)
% WAS generic_action_ in source
 generic_actionB {{ tex a }} {{ lem generic_action_ }} :: '' ::= {{ auxparam 'ty 'sym }}
   | create ( generic_pexpr1 , generic_pexpr2 Symbol_prefix ) :: :: Create %(* the expr arguments are: alignment requirement, effective type *)
   | alloc ( generic_pexpr1 , generic_pexpr2 Symbol_prefix ) :: :: Alloc  %(* the expr arguments are: alignment requirement, space size *)
   | kill ( generic_pexpr ) :: :: Kill
   | store ( generic_pexpr1 , generic_pexpr2 , generic_pexpr , Cmm_memory_order ) :: :: Store
   | load ( generic_pexpr1 , generic_pexpr2 , Cmm_memory_order ) :: :: Load
   | rmw ( generic_pexpr1 ,  generic_pexpr2 , generic_pexpr3 , generic_pexpr4 , Cmm_memory_order1 , Cmm_memory_order2 ) :: :: RMW
%   | RMW generic_pexpr(* ctype *) generic_pexpr(* object_ptr *) generic_pexpr(* expected_val *) generic_pexpr(* desired_val *) Cmm.memory_order Cmm.memory_order
 
% (*
%   | CompareExchangeStrong pexpr pexpr pexpr pexpr Cmm.memory_order Cmm.memory_order
%   | CompareExchangeWeak pexpr pexpr pexpr pexpr Cmm.memory_order Cmm.memory_order
% *)
   
%   (* TODO: it annoying (maybe wrong) that these are actions *)
% (*  | Ptr pointer_action list pexpr *)
 

% NB in the generated latex we suppress the distinction between generic_actionB and generic_action by typesetting both as 'a'
 generic_action {{ tex a}} :: '' ::= {{ auxparam 'a 'ty 'sym }} {{ com action }}
    |  Action Loc_t a generic_actionB  :: :: Action 
 generic_paction {{ tex pa }} :: '' ::= {{ auxparam 'a 'ty 'sym }} {{ com action with polarity }}
    |  Paction polarity generic_action :: :: Paction


 declaration :: '' ::= {{ phantom }} {{ com Core declarations }}
%    | fun generic_name ( generic_pexpr1 : core_base_type1 , .. , generic_pexprn : core_base_typen ) : core_base_type := generic_pexpr :: :: Fun    
%    | proc generic_name ( generic_pexpr1 : core_base_type1 , .. , generic_pexprn : core_base_typen ) : eff core_base_type := generic_expr :: :: Proc
    | fun generic_name ( </ Symbol_ti : core_base_typei // , // i /> ) : core_base_type := generic_pexpr :: :: Fun
    | proc generic_name ( </ Symbol_ti : core_base_typei // , // i /> ) : eff core_base_type := generic_expr :: :: Proc



terminals :: 'terminal' ::=
   | /\    :: :: And  {{ tex \wedge }}
   | \/    :: :: Or   {{ tex \vee }}
   | ^     :: :: Expr {{ tex \hat{} }}
   | =>    :: :: Pat  {{ tex \texttt{=>} }}
   | <     :: :: langle {{ tex \texttt{<} }}
   | >     :: :: rangle {{ tex \texttt{>} }}
   | [     :: :: lbrac {{ tex \texttt{[} }}
   | ]     :: :: rbrac {{ tex \texttt{]} }}
   | (     :: :: lparen {{ tex \texttt{(} }}
   | )     :: :: rparen {{ tex \texttt{)} }}
   | {     :: :: lbrace {{ tex \mbox{\tt\char'173} }}
   | }     :: :: rbrace {{ tex \mbox{\tt\char'175} }}
   | |     :: :: mid {{ tex \texttt{|} }}
   | =     :: :: eq {{ tex \,\texttt{=}\, }}
   | ,     :: :: comma {{ tex \texttt{,} }}
   | .     :: :: dot {{ tex \texttt{.} }}
   | :     :: :: colon {{ tex \texttt{:} }}
   | :=     :: :: coloneq {{ tex \texttt{:=}\, }}

   | array_shift :: :: array_shift {{ tex \ottkw{array\_shift} }}
   | member_shift :: :: member_shift {{ tex \ottkw{member\_shift} }}
   | is_scalar   :: :: is_scalar   {{ tex \ottkw{is\_scalar  } }}
   | is_integer  :: :: is_integer  {{ tex \ottkw{is\_integer } }}
   | is_signed   :: :: is_signed   {{ tex \ottkw{is\_signed  } }}
   | is_unsigned :: :: is_unsigned {{ tex \ottkw{is\_unsigned} }}
embed {{ lem 
 
 type name         = generic_name Symbol.t
 type object_value = generic_object_value Symbol.t
 type value        = generic_value Symbol.t
 type ctor         = generic_ctor Symbol.t
 type pattern      = generic_pattern core_base_type Symbol.t
 type pexpr        = generic_pexpr core_base_type Symbol.t
 type expr 'a      = generic_expr 'a core_base_type Symbol.t
 type paction 'a   = generic_paction 'a core_base_type Symbol.t
 
 
 
 
 
 
 
 (* TODO: don't we need any impl proc? *)
 type impl_decl =
   | Def of core_base_type * pexpr
   | IFun of core_base_type * list (Symbol.t * core_base_type) * pexpr
 type impl = map Implementation_.implementation_constant impl_decl
 (*
 type impl_decl =
   | IConst  core_base_type * value
   | IFun core_base_type * list (sym * core_base_type) * pexpr
 type impl = map Impl_types.impl_name impl_decl
 *)
 
 
 type fun_map_decl 'a =
   | Fun of core_base_type * list (Symbol.t * core_base_type) * pexpr
   | Proc of core_base_type * list (Symbol.t * core_base_type) * expr 'a
 
 type fun_map 'a = map Symbol.t (fun_map_decl 'a)
 
 
 (* a Core file is just a set named functions *)
 type file 'a = <|
   main   : Symbol.t;
   stdlib : fun_map 'a;
   impl   : impl;
   globs  : list (Symbol.t * core_type * expr 'a);
   funs   : fun_map 'a;
 |>
 declare {coq} rename type impl = impl_ (* workaround for Lem issue #74 *)
 
 
 
 
 
 
 
 
 
 (* runtime stuff *)
 
 type continuation_element 'a =
   | Kunseq of list (expr 'a) * list (expr 'a)
   | Kwseq  of pattern * expr 'a
   | Ksseq  of pattern * expr 'a
 (*  | Ktry   list (string * expr 'a) *)
 
 
 type continuation 'a = list (continuation_element 'a)
 
 
 type labeled_continuation 'a = list (Symbol.t * ctype) * expr 'a
 
 
 type stack 'a =
   | Stack_empty
   | Stack_cons of continuation 'a * stack 'a
 
 
 
 
 
 
 (* basic class instanciations *)
 instance (SetType polarity)
   let setElemCompare = defaultCompare
 end
}}