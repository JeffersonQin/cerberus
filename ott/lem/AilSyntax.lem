open import Pervasives Common AilTypes Context
import Symbol Loc ErrorMonad Cmm_master

(* module Cmm = Cmm_master *)


(* == Ail syntax datatypes ================================================== *)
type identifier = Symbol.t

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

type basis =
  | Octal
  | Decimal
  | Hexadecimal

type integerConstant (*[name = "ic*"]*) =
  | IConstant of integer * basis * maybe integerSuffix
  | IConstantMax of integerType
  | IConstantMin of integerType

type characterPrefix =
  | Pref_L
  | Pref_u
  | Pref_U

type characterConstant =
    maybe characterPrefix * string

type encodingPrefix =
  | Enc_u8
  | Enc_u
  | Enc_U
  | Enc_L

type stringLiteral =
  maybe encodingPrefix * list string

type arithmeticOperator [name = "aop.*"] =  (*r 6.5.5 Multiplicative operators *)
 | Mul
 | Div
 | Mod (*r 6.5.6 Additive operators *)
 | Add
 | Sub (*r 6.5.7 Bitwise shift operators *)
 | Shl
 | Shr (*r 6.5.10 Bitwise AND operator *)
 | Band (*r 6.5.11 Bitwise exclusive OR operator *)
 | Bor (*r 6.5.12 Bitwise inclusive OR operator *)
 | Bxor (*r Binary operators from 6.5.5-14, 6.5.17 *)

type constant [name = "c*"] = 
 | ConstantIndeterminate of ctype
 | ConstantNull (* TODO: maybe temporary *)
 | ConstantInteger       of integerConstant
 | ConstantCharacter     of characterConstant
 | ConstantArray         of list constant

(* 
 (* TODO: this is a kind of integer constant, may need to update some predicates *)
 | ConstantMemoryOrder of Cmm.memory_order
*)

type unaryOperator = 
 | Plus
 | Minus
 | Bnot
 | Address
 | Indirection
 | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
 | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assigments *)
 | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
 | Comma (*r 6.5.13 Logical AND operator *)
 | And (*r 6.5.14 Logical OR operator *)
 | Or (*r 6.5.8 Relational operators *)
 | Lt
 | Gt
 | Le
 | Ge (*r 6.5.9 Equality operators *)
 | Eq
 | Ne

type expression' 'A [name = "e*"] = 
  | AilEunary of unaryOperator * expression 'A
  | AilEbinary of expression 'A * binaryOperator * expression 'A
  | AilEassign of expression 'A * expression 'A
  | AilEcompoundAssign of expression 'A * arithmeticOperator * expression 'A
  | AilEcond of expression 'A * expression 'A * expression 'A
  | AilEcast of qualifiers * ctype * expression 'A
  | AilEcall of expression 'A * list (expression 'A)
  | AilEassert of expression 'A
  | AilEgeneric of expression 'A * list (generic_association 'A)
  
  (* TODO: hackish? *)
  (* TODO: these two don't exist in C (apart from in decl) *)
  | AilEarray of ctype * list (maybe (expression 'A))
  | AilEstruct of identifier * list (Cabs.cabs_identifier * maybe (expression 'A)) (* tag, pairs of member id, expression *)
  
  (* NOTE: the expression obviously need to match the type, and will typically be
           a AilEarray or AilEstruct *)
  | AilEcompound of ctype * expression 'A
  
  
  | AilEmemberof of expression 'A * Cabs.cabs_identifier
  | AilEmemberofptr of expression 'A * Cabs.cabs_identifier
  
  | AilEbuiltin of string (* TODO: see if that can be moved to [constant] *)
  
  | AilEstr of stringLiteral
  | AilEconst of constant
  | AilEident of identifier
  | AilEsizeof of qualifiers * ctype
  | AilEsizeof_expr of expression 'A
  | AilEalignof of qualifiers * ctype
  
  (* NOTE: type annotation on expression, used to remember the type of desugared
           enumeration constants *)
  | AilEannot of ctype * (expression 'A)

and generic_association 'A =
  | AilGAtype of ctype * expression 'A
  | AilGAdefault of expression 'A

and expression 'A [name = "e*"] =
  | AnnotatedExpression of 'A * expression' 'A

(* the storage duration must be Nothing iff the identifier is that of a function *)
type bindings (*[name="b*"]*) = list (identifier * (maybe storageDuration * qualifiers * ctype))

type statement' 'A [name="s*"] = 
  | AilSskip
  | AilSexpr of expression 'A
  | AilSblock of bindings * list (statement 'A)
  | AilSif of expression 'A * statement 'A * statement 'A
  | AilSwhile of expression 'A * statement 'A
  | AilSdo of statement 'A * expression 'A
  | AilSbreak
  | AilScontinue
  | AilSreturnVoid
  | AilSreturn of expression 'A
  | AilSswitch of expression 'A * statement 'A
  | AilScase of integerConstant * statement 'A
  | AilSdefault of statement 'A
  | AilSlabel of identifier * statement 'A
  | AilSgoto of identifier
  | AilSdeclaration of list (identifier * expression 'A)
  | AilSpar of list (statement 'A) (* NON-STD cppmem threads *)
and statement 'A [name="s*"] =
  | AnnotatedStatement of Loc.t * statement' 'A


type declaration =
  | Decl_object   of storageDuration * qualifiers * ctype
    (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  | Decl_function of ctype * (list (qualifiers * ctype)) * bool * bool * bool


type tag_definition =
  | StructDef of list (Cabs.cabs_identifier * ctype)
  | UnionDef of list (Cabs.cabs_identifier * ctype)

instance (Show tag_definition)
  let show def = match def with
    | StructDef _ ->
        "TODO[StructDef]"
    | UnionDef _ ->
        "TODO[UnionDef]"
  end
end


type sigma 'A = <|
  declarations: Context.context identifier declaration;
  object_definitions: Context.context identifier (expression 'A);
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: Context.context identifier (list identifier * statement 'A);
  static_assertions: list (expression 'A * stringLiteral);
  
  tag_definitions: Context.context identifier tag_definition
|>


type gamma = Context.context identifier (maybe storageDuration * qualifiers * ctype)

type program 'A = identifier * sigma 'A
































(* == Equality functions ==================================================== *)

val identifierEqual:         identifier         -> identifier         -> bool
val integerSuffixEqual:      integerSuffix      -> integerSuffix      -> bool
val integerConstantEqual:    integerConstant    -> integerConstant    -> bool
val arithmeticOperatorEqual: arithmeticOperator -> arithmeticOperator -> bool
val constantEqual:           constant           -> constant           -> bool
val unaryOperatorEqual:      unaryOperator      -> unaryOperator      -> bool
val binaryOperatorEqual:     binaryOperator     -> binaryOperator     -> bool

(* NOTE: this is an internal function *)
val argumentsEqual_aux: forall 'A.
                      ('A -> 'A -> bool)                                             ->
                      (('A -> 'A -> bool) -> expression 'A -> expression 'A -> bool) ->
                      list (expression 'A) -> list (expression 'A)                   ->
                      bool

(* NOTE: this is an internal function *)
val expressionEqual': forall 'A.
                    ('A -> 'A -> bool)               ->
                    expression' 'A -> expression' 'A ->
                    bool

val expressionEqual: forall 'A.
                   ('A -> 'A -> bool)             ->
                   expression 'A -> expression 'A ->
                   bool

val argumentsEqual: forall 'A.
                  ('A -> 'A -> bool)                           ->
                  list (expression 'A) -> list (expression 'A) ->
                  bool

val bindingsEqual: bindings -> bindings -> bool

val definitionEqual: forall 'A.
                   ('A -> 'A -> bool)                                           ->
                   (identifier * expression 'A) -> (identifier * expression 'A) ->
                   bool

val declarationEqual: declaration -> declaration -> bool

val blockEqual_aux: forall 'A.
                  ('A -> 'A -> bool)                                           ->
                  (('A -> 'A -> bool) -> statement 'A -> statement 'A -> bool) ->
                  list (statement 'A) -> list (statement 'A)                   ->
                  bool

val statementEqual': forall 'A.
                   ('A -> 'A -> bool)             ->
                   statement' 'A -> statement' 'A ->
                   bool

val statementEqual: forall 'A.
                  ('A -> 'A -> bool)           ->
                  statement 'A -> statement 'A ->
                  bool

val blockEqual: forall 'A.
              ('A -> 'A -> bool)                         ->
              list (statement 'A) -> list (statement 'A) ->
              bool

val sigmaEqual: forall 'A.
              ('A -> 'A -> bool)   ->
              sigma 'A -> sigma 'A ->
              bool

val gammaEqual: gamma -> gamma -> bool

val programEqual: forall 'A.
                ('A -> 'A -> bool)       ->
                program 'A -> program 'A ->
                bool


let identifierEqual =
  (=)

let basisEqual b1 b2 =
  match (b1, b2) with
    | (Octal      , Octal      ) -> true
    | (Decimal    , Decimal    ) -> true
    | (Hexadecimal, Hexadecimal) -> true
    | (_          , _          ) -> false
  end

let integerSuffixEqual s1 s2 =
  match (s1, s2) with
    | (U  , U  ) -> true
    | (UL , UL ) -> true
    | (ULL, ULL) -> true
    | (L  , L  ) -> true
    | (LL , LL ) -> true
    | (_  , _  ) -> false
  end

let integerConstantEqual (IConstant n1 b1 suff1_opt) (IConstant n2 b2 suff2_opt) =
  n1 = n2 && basisEqual b1 b2 && eq_option integerSuffixEqual suff1_opt suff2_opt

instance (Eq integerConstant)
  let (=)  = integerConstantEqual
  let (<>) = fun a b -> not (integerConstantEqual a b)
end

let arithmeticOperatorEqual aop1 aop2 =
  match (aop1, aop2) with
    | (Mul , Mul ) -> true
    | (Div , Div ) -> true
    | (Mod , Mod ) -> true
    | (Add , Add ) -> true
    | (Sub , Sub ) -> true
    | (Shl , Shl ) -> true
    | (Shr , Shr ) -> true
    | (Band, Band) -> true
    | (Bor , Bor ) -> true
    | (Bxor, Bxor) -> true
    | (_   , _   ) -> false
  end


let characterPrefixEqual pref1 pref2 =
  match (pref1, pref2) with
    | (Pref_L, Pref_L) -> true
    | (Pref_u, Pref_u) -> true
    | (Pref_U, Pref_U) -> true
    | (_     , _     ) -> false
  end

let characterConstantEqual =
  eq_pair (eq_option characterPrefixEqual) (=)

let encodingPrefixEqual pref1 pref2 =
  match (pref1, pref2) with
    | (Enc_u8, Enc_u8) -> true
    | (Enc_u , Enc_u ) -> true
    | (Enc_U , Enc_U ) -> true
    | (Enc_L , Enc_L ) -> true
    | (_     , _     ) -> false
  end

let stringLiteralEqual =
  eq_pair (eq_option encodingPrefixEqual) (=)


let constantEqual c1 c2 =
  match (c1, c2) with
    | (ConstantInteger   ic1, ConstantInteger   ic2) -> integerConstantEqual   ic1 ic2
    | (ConstantCharacter cc1, ConstantCharacter cc2) -> characterConstantEqual cc1 cc2
    | (_                    , _                    ) -> false
  end

let unaryOperatorEqual u1 u2 =
  match (u1, u2) with
    | (Plus       , Plus       ) -> true
    | (Minus      , Minus      ) -> true
    | (Bnot       , Bnot       ) -> true
    | (Address    , Address    ) -> true
    | (Indirection, Indirection) -> true
    | (PostfixIncr, PostfixIncr) -> true
    | (PostfixDecr, PostfixDecr) -> true
    | (_          , _          ) -> false
  end

let binaryOperatorEqual bop1 bop2 =
  match (bop1, bop2) with
    | (Arithmetic aop1, Arithmetic aop2) -> arithmeticOperatorEqual aop1 aop2
    | (Comma, Comma) -> true
    | (And  , And  ) -> true
    | (Or   , Or   ) -> true
    | (Lt   , Lt   ) -> true
    | (Gt   , Gt   ) -> true
    | (Le   , Le   ) -> true
    | (Ge   , Ge   ) -> true
    | (Eq   , Eq   ) -> true
    | (Ne   , Ne   ) -> true
    | (_    , _    ) -> false
  end

let rec argumentsEqual_aux eq_A expressionEqual a1 a2 =
  match (a1, a2) with
    | ([]      , []      ) -> true
    | (e1 :: a1, e2 :: a2) -> expressionEqual eq_A e1 e2 && argumentsEqual_aux eq_A expressionEqual a1 a2
    | (_       , _       ) -> false
  end

let rec expressionEqual' eq_A e1 e2 =
  let argumentsEqual = argumentsEqual_aux eq_A expressionEqual in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        unaryOperatorEqual uop1 uop2 &&
        expressionEqual eq_A e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        binaryOperatorEqual bop1 bop2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        arithmeticOperatorEqual aop1 aop2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        expressionEqual eq_A e2_1 e2_2 &&
        expressionEqual eq_A e3_1 e3_2
    | (AilEcast qs1 ty1 e1, AilEcast qs2 ty2 e2) ->
        qs1 = qs2 && ty1 = ty2 &&
        expressionEqual eq_A e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        expressionEqual eq_A e1 e2 &&
        argumentsEqual es1 es2
    | (AilEassert e1, AilEassert e2) ->
        expressionEqual eq_A e1 e2
    | (AilEstr lit1, AilEstr lit2) ->
        stringLiteralEqual lit1 lit2
    | (AilEconst c1, AilEconst c2) ->
        constantEqual c1 c2
    | (AilEident v1, AilEident v2) ->
        identifierEqual v1 v2
    | (AilEsizeof qs1 ty1, AilEsizeof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEsizeof_expr e1, AilEsizeof_expr e2) ->
        expressionEqual eq_A e1 e2
    | (AilEalignof qs1 ty1, AilEalignof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (_, _) -> false
  end
and expressionEqual eq_A e1 e2 =
  match (e1, e2) with
    | (AnnotatedExpression a1 e1, AnnotatedExpression a2 e2) ->
        eq_A a1 a2 && expressionEqual' eq_A e1 e2
  end

let argumentsEqual eq_A a1 a2 =
  argumentsEqual_aux eq_A expressionEqual a1 a2

let bindingsEqual bs1 bs2 =
  eq_list (eq_pair identifierEqual (eq_triple (=) qualifiersEqual ctypeEqual)) bs1 bs2

let definitionEqual eq_A d1 d2 =
  eq_pair identifierEqual (expressionEqual eq_A) d1 d2

let eq_declaration ds1 ds2 =
  match (ds1, ds2) with
    | (Decl_object dur1 qs1 ty1, Decl_object dur2 qs2 ty2) ->
        dur1 = dur2 && qs1 = qs2 && ty1 = ty2
    | (Decl_function ret_ty1 qs_tys1 is_variadic1 is_inline1 is_Noreturn1, Decl_function ret_ty2 qs_tys2 is_variadic2 is_inline2 is_Noreturn2) ->
        ret_ty1 = ret_ty2 &&
        qs_tys1 = qs_tys2 &&
        is_variadic1 = is_variadic2 &&
        is_inline1 = is_inline2 &&
        is_Noreturn1 = is_Noreturn2
    | _ ->
        false
  end

let rec eq_block_aux eq_A equiv_statement ss1 ss2 =
  match (ss1, ss2) with
    | ([]       , []       ) -> true
    | (s1 :: ss1, s2 :: ss2) -> equiv_statement eq_A s1 s2 && eq_block_aux eq_A equiv_statement ss1 ss2
    | (_        , _        ) -> false
  end

let rec statementEqual' eq_A s1 s2 =
  let eq_block = eq_block_aux eq_A statementEqual in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        expressionEqual eq_A e1 e2
    | (AilSblock bs1 ss1, AilSblock bs2 ss2) ->
        bs1 = bs2 &&
        eq_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1_1 s1_2 &&
        statementEqual eq_A s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        expressionEqual eq_A e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        integerConstantEqual ic1 ic2 &&
        statementEqual eq_A s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        statementEqual eq_A s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        identifierEqual v1 v2 &&
        statementEqual eq_A s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        identifierEqual v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        eq_list (eq_pair identifierEqual (expressionEqual eq_A)) d1 d2
    | (_, _) -> false
  end
and statementEqual eq_A s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        statementEqual' eq_A s1 s2
  end

let eq_block eq_A ss1 ss2 =
  eq_block_aux eq_A statementEqual ss1 ss2


(*
let eq_function_declaration eq_A eq_B fdecl1 fdecl2 =
  eq_ctype    fdecl1.fun_return_ty fdecl2.fun_return_ty  &&
  eq_bindings fdecl1.fun_bindings  fdecl2.fun_bindings   &&
  fdecl1.fun_is_variadic <-> fdecl2.fun_is_variadic      &&
  fdecl1.fun_is_inline   <-> fdecl2.fun_is_inline        &&
  fdecl1.fun_is_Noreturn <-> fdecl2.fun_is_Noreturn      &&
  eq_option (statementEqual eq_A eq_B) fdecl1.fun_body fdecl2.fun_body


let eq_sigma_declaration eq_A eq_B sdecl1 sdecl2 =
  match (sdecl1, sdecl2) with
    | (SDecl_fun id1 fdecl1, SDecl_fun id2 fdecl2) ->
        identifierEqual id1 id2 &&
        eq_function_declaration eq_A eq_B fdecl1 fdecl2
    | (SDecl_global id1 glob1, SDecl_global id2 glob2) ->
        identifierEqual id1 id2 &&
        eq_triple eq_qualifiers eq_ctype (eq_option (expressionEqual eq_B))
          glob1 glob2
    | (SDecl_static_assert e1 sc1, SDecl_static_assert e2 sc2) ->
        expressionEqual eq_B e1 e2 &&
        stringLiteralEqual sc1 sc2
    | (_,_) ->
        false
  end
*)



let eq_sigma eq_A sig1 sig2 =
  eq_context identifierEqual eq_declaration sig1.declarations sig1.declarations &&
  eq_context identifierEqual (expressionEqual eq_A) sig1.object_definitions sig2.object_definitions &&
  eq_context identifierEqual (eq_pair (eq_list identifierEqual) (statementEqual eq_A)) sig1.function_definitions sig2.function_definitions &&
  eq_list (eq_pair (expressionEqual eq_A) stringLiteralEqual) sig1.static_assertions sig2.static_assertions

(*
let eq_sigma eq_A eq_B =
  eq_list (eq_sigma_declaration eq_A eq_B)
(* (OLD)  eq_context identifierEqual (eq_pair (eq_pair eq_ctype eq_bindings) (statementEqual eq_A eq_B)) *)
(*  eq_context identifierEqual (eq_sigma_declaration eq_A eq_B) *)
(*
    (eq_either
      (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (expressionEqual eq_B)))
    )
*)
*)

let eq_gamma g1 g2 =
  eq_context identifierEqual (eq_pair qualifiersEqual ctypeEqual) g1 g2

let eq_program eq_A p1 p2 =
  eq_pair identifierEqual (eq_sigma eq_A) p1 p2
(* (NEW OLD)
     identifierEqual p1.startup p2.startup
  && eq_context identifierEqual (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
       p1.functions p2.functions
  && eq_context identifierEqual (eq_pair eq_ctype (eq_option (expressionEqual eq_B)))
       p1.globals p2.globals
  && eq_context identifierEqual (=) p1.strings p2.strings
 *)


(* == Equivalence functions ================================================= *)

val equiv_arguments_aux: forall 'A1 'A2.
                         (expression 'A1 -> expression 'A2 -> bool)     ->
                         list (expression 'A1) -> list (expression 'A2) ->
                         bool

val equiv_expression': forall 'A1 'A2. expression' 'A1                    -> expression' 'A2                    -> bool
val equiv_expression:  forall 'A1 'A2. expression  'A1                    -> expression  'A2                    -> bool
val equiv_arguments:   forall 'A1 'A2. list (expression 'A1)              -> list (expression 'A2)              -> bool
val equiv_definition:  forall 'A1 'A2. identifier * expression 'A1        -> identifier * expression 'A2        -> bool
val equiv_declaration: forall 'A1 'A2. list (identifier * expression 'A1) -> list (identifier * expression 'A2) -> bool

val equiv_block_aux: forall 'A1 'A2.
                     (statement 'A1 -> statement 'A2 -> bool) ->
                     list (statement 'A1) -> list (statement 'A2) ->
                     bool

val equiv_statement': forall 'A1 'A2. statement' 'A1       -> statement' 'A2       -> bool
val equiv_statement:  forall 'A1 'A2. statement  'A1       -> statement  'A2       -> bool
val equiv_block:      forall 'A1 'A2. list (statement 'A1) -> list (statement 'A2) -> bool

(* WIP
val equiv_sigma: forall 'A1 'A2 'B1 'B2. sigma 'A1 'B1 -> sigma 'A2 'B2 -> bool
val equiv_eq_sigma: forall 'A 'B.
                    ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                    sigma 'A 'B -> sigma 'A 'B               ->
                    bool

val equiv_gamma : gamma -> gamma -> bool

val equiv_program: forall 'A1 'A2 'B1 'B2. program 'A1 'B1 -> program 'A2 'B2 -> bool

val equiv_eq_program: forall 'A 'B.
                      ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                      program 'A 'B -> program 'A 'B ->
                      bool
*)


let rec equiv_arguments_aux equiv_expression a1 a2 =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> equiv_expression e1 e2 && equiv_arguments_aux equiv_expression a1 a2
  | (_       , _       ) -> false
    end

let rec equiv_expression' e1 e2 =
  let equiv_arguments = equiv_arguments_aux equiv_expression in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        unaryOperatorEqual uop1 uop2 &&
        equiv_expression e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        binaryOperatorEqual bop1 bop2 &&
        equiv_expression e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        arithmeticOperatorEqual aop1 aop2 &&
        equiv_expression e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2 &&
        equiv_expression e3_1 e3_2
    | (AilEcast qs1 ty1 e1, AilEcast qs2 ty2 e2) ->
        qs1 = qs2 && ty1 = ty2 &&
        equiv_expression e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        equiv_expression e1 e2 &&
        equiv_arguments es1 es2
    | (AilEassert e1, AilEassert e2) ->
        equiv_expression e1 e2
    | (AilEconst c1, AilEconst c2) ->
        constantEqual c1 c2
    | (AilEident v1, AilEident v2) ->
        identifierEqual v1 v2
    | (AilEsizeof qs1 ty1, AilEsizeof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEalignof qs1 ty1, AilEalignof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (_, _) -> false
  end
and equiv_expression e1 e2 =
  match (e1, e2) with
  | (AnnotatedExpression _ e1, AnnotatedExpression _ e2) -> equiv_expression' e1 e2
  end

let equiv_arguments a1 a2 =
  equiv_arguments_aux equiv_expression a1 a2

let equiv_definition d1 d2 =
  equiv_pair identifierEqual equiv_expression d1 d2


let rec equiv_declaration ds1 ds2 =
  match (ds1, ds2) with
  | ([]       , []       ) -> true
  | (d1 :: ds1, d2 :: ds2) -> equiv_definition d1 d2 && equiv_declaration ds1 ds2
  | (_        , _        ) -> false
  end

let rec equiv_block_aux equiv_statement ss1 ss2 =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement s1 s2 && equiv_block_aux equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec equiv_statement' s1 s2 =
  let equiv_block = equiv_block_aux equiv_statement in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        equiv_expression e1 e2
    | (AilSblock bs1 ss1, AilSblock bs2 ss2) ->
        bs1 = bs2 &&
        equiv_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1_1 s1_2 &&
        equiv_statement s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        equiv_expression e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        integerConstantEqual ic1 ic2 &&
        equiv_statement s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        equiv_statement s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        identifierEqual v1 v2 &&
        equiv_statement s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        identifierEqual v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        equiv_declaration d1 d2
    | (_, _) -> false
  end
and equiv_statement s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        equiv_statement' s1 s2
  end

let equiv_block ss1 ss2 =
 equiv_block_aux equiv_statement ss1 ss2


(* Currently unused.
let declaration = identifier * maybe storageDuration.
*)

(*
let equiv_function_declaration fdecl1 fdecl2 =
  eq_ctype    fdecl1.fun_return_ty fdecl2.fun_return_ty  &&
  eq_bindings fdecl1.fun_bindings  fdecl2.fun_bindings   &&
  fdecl1.fun_is_variadic <-> fdecl2.fun_is_variadic      &&
  fdecl1.fun_is_inline   <-> fdecl2.fun_is_inline        &&
  fdecl1.fun_is_Noreturn <-> fdecl2.fun_is_Noreturn      &&
  equiv_option equiv_statement fdecl1.fun_body fdecl2.fun_body

let equiv_sigma_declaration sdecl1 sdecl2 =
  match (sdecl1, sdecl2) with
    | (SDecl_fun id1 fdecl1, SDecl_fun id2 fdecl2) ->
        identifierEqual id1 id2 &&
        equiv_function_declaration fdecl1 fdecl2
    | (SDecl_global id1 glob1, SDecl_global id2 glob2) ->
        identifierEqual id1 id2 &&
        equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression)
          glob1 glob2
    | (SDecl_static_assert e1 sc1, SDecl_static_assert e2 sc2) ->
        equiv_expression e1 e2 &&
        stringLiteralEqual sc1 sc2
    | (_,_) ->
        false
  end
*)

(* WIP

let equiv_sigma S1 S2 =
  sigma_equiv identifierEqual (fun _ ->
    equiv_sigma_declaration
  ) S1 S2
(* (OLD)  equiv identifierEqual (fun _ -> equiv_pair (eq_pair eq_ctype eq_bindings) equiv_statement) S1 S2 *)
(*
    equiv_either
      (equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
      (equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression))
*)

let equiv_eq_sigma eq_A eq_B S1 S2 =
(* (OLD)  equiv identifierEqual (fun _ -> eq_pair (eq_pair eq_ctype eq_bindings) (statementEqual eq_A eq_B)) S1 S2 *)
  sigma_equiv identifierEqual (fun _ ->
    eq_sigma_declaration eq_A eq_B
(*
    eq_either
      (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (expressionEqual eq_B)))
*)
  ) S1 S2

let equiv_gamma g1 g2 =
  sigma_equiv identifierEqual (fun _ -> eq_pair eq_qualifiers eq_ctype) g1 g2

let equiv_program p1 p2 =
  equiv_pair identifierEqual equiv_sigma p1 p2
(* (NEW OLD)
     identifierEqual p1.startup p2.startup
  && equiv identifierEqual (fun _ -> equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
       p1.functions p2.functions
  && equiv identifierEqual (fun _ -> equiv_pair eq_ctype (equiv_option equiv_expression))
       p1.globals p2.globals
  && eq_context identifierEqual (=) p1.strings p2.strings
*)

let equiv_eq_program eq_A eq_B p1 p2 =
  eq_pair identifierEqual (equiv_eq_sigma eq_A eq_B) p1 p2
(* (NEW OLD)
     identifierEqual p1.startup p2.startup
  && equiv identifierEqual (fun _ -> eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
       p1.functions p2.functions
  && equiv identifierEqual (fun _ -> eq_pair eq_ctype (eq_option (expressionEqual eq_B)))
       p1.globals p2.globals
  && eq_context identifierEqual (=) p1.strings p2.strings
*)

*)

(* *)
val     sigma_lookup: forall 'A. sigma 'A -> identifier -> maybe ((* sigma_declaration 'A 'B *) unit)
(*
let rec sigma_lookup S a =
  match S with
    | [] ->
        Nothing
    | (SDecl_fun id fdecl) :: S' ->
        if identifierEqual id a then
          Just (SDecl_fun id fdecl)
        else
          sigma_lookup S' a
    | (SDecl_global id glob) :: S' ->
        if identifierEqual id a then
          Just (SDecl_global id glob)
        else
          sigma_lookup S' a
    | (SDecl_static_assert _ _) :: S' ->
        sigma_lookup S' a
  end
*)

(*
val sigma_mem: forall 'A 'B. identifier -> sigma 'A 'B -> bool
let sigma_mem a S =
  match sigma_lookup S a with
  | Just _  -> true
  | Nothing -> false
  end

val sigma_fresh: forall 'A 'B. identifier -> sigma 'A 'B -> bool
let sigma_fresh a S =
  not (sigma_mem a S)
*)

val sigma_fresh_bindings: forall 'A. bindings -> sigma 'A -> bool
let sigma_fresh_bindings bs S =
  List.all (fun (ident, _) -> Context.fresh identifierEqual ident S.declarations) bs



(*
val lookup:         forall 'B. Context.context identifier 'B -> identifier -> maybe 'B
val mem:            forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh:          forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh_bindings: forall 'B. bindings -> Context.context identifier 'B -> bool

val disjoint: forall 'B1 'B2.
              Context.context identifier 'B1 -> Context.context identifier 'B2 ->
              bool



let lookup C v          = Context.lookup identifierEqual C v
let mem v C             = Context.mem identifierEqual v C
let fresh v C           = Context.fresh identifierEqual v C
let fresh_bindings bs C = Context.fresh_bindings identifierEqual bs C
let disjoint C1 C2      = Context.disjoint identifierEqual C1 C2
*)

val parameters_of_bindings: bindings -> list (maybe storageDuration * qualifiers * ctype)

val type_from_sigma: forall 'A. (ctype * bindings * bool) * maybe (statement 'A) -> ctype

let parameters_of_bindings bs =
  List.map snd bs

let type_from_sigma ((ty, bs, is_variadic), _) =
  Function ty (List.map (fun (_, (_, qs, ty)) -> (qs,ty)) bs) is_variadic







(* K Hack *)

(*
type declaration = qualifiers * ctype (* * maybe storageDuration *)


type file 'a = <|
  main:    identifier;
  id_map:  Pmap.map identifier declaration;
  globals: list (identifier * expression 'a);
  fn_map:  Pmap.map identifier (list identifier * statement Loc.t 'a)
|>

val file_of_program: forall 'B. program Loc.t 'B -> file 'B
let file_of_program (main_id, ctx) =
  let (ids, fns) = List.fold_left (fun (ids_, fns_) (id, ((ty, bds), s)) ->
    (
      Pmap.add id (AilTypes.no_qualifiers, AilTypes.Function ty (List.map snd bds)) ids_,
      Pmap.add id (List.map fst bds, s) fns_
    )
  ) (Pmap.empty, Pmap.empty) ctx in
  <|
      main=    main_id;
      id_map=  ids;
      globals= [];
      fn_map=  fns
   |>
*)
