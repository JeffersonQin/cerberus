open import Pervasives Common AilTypes Context
import Symbol ErrorMonad


(* == Ail syntax datatypes ================================================== *)
type identifier = Symbol.t

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

type basis =
  | Octal
  | Decimal
  | Hexadecimal

type integerConstant (*[name = "ic*"]*) = integer * basis * maybe integerSuffix

type characterPrefix =
  | Pref_L
  | Pref_u
  | Pref_U

type characterConstant =
    maybe characterPrefix * string

type encodingPrefix =
  | Enc_u8
  | Enc_u
  | Enc_U
  | Enc_L

type stringLiteral =
  maybe encodingPrefix * string

type arithmeticOperator [name = "aop.*"] =  (*r 6.5.5 Multiplicative operators *)
 | Mul
 | Div
 | Mod (*r 6.5.6 Additive operators *)
 | Add
 | Sub (*r 6.5.7 Bitwise shift operators *)
 | Shl
 | Shr (*r 6.5.10 Bitwise AND operator *)
 | Band (*r 6.5.11 Bitwise exclusive OR operator *)
 | Bor (*r 6.5.12 Bitwise inclusive OR operator *)
 | Bxor (*r Binary operators from 6.5.5-14, 6.5.17 *)

type constant [name = "c*"] = 
 | ConstantIndeterminate of ctype
 | ConstantNull (* TODO: maybe temporary *)
 | ConstantInteger       of integerConstant
 | ConstantCharacter     of characterConstant
 | ConstantArray         of list constant

type unaryOperator = 
 | Plus
 | Minus
 | Bnot
 | Address
 | Indirection
 | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
 | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assigments *)
 | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
 | Comma (*r 6.5.13 Logical AND operator *)
 | And (*r 6.5.14 Logical OR operator *)
 | Or (*r 6.5.8 Relational operators *)
 | Lt
 | Gt
 | Le
 | Ge (*r 6.5.9 Equality operators *)
 | Eq
 | Ne

type expression' 'A [name = "e*"] = 
  | AilEunary of unaryOperator * expression 'A
  | AilEbinary of expression 'A * binaryOperator * expression 'A
  | AilEassign of expression 'A * expression 'A
  | AilEcompoundAssign of expression 'A * arithmeticOperator * expression 'A
  | AilEcond of expression 'A * expression 'A * expression 'A
  | AilEcast of qualifiers * ctype * expression 'A
  | AilEcall of expression 'A * list (expression 'A)
  | AilEgeneric of expression 'A * list (generic_association 'A)
  
  | AilEmemberof of expression 'A * Cabs.cabs_identifier
  | AilEmemberofptr of expression 'A * Cabs.cabs_identifier
  
  | AilEstr of stringLiteral
  | AilEconst of constant
  | AilEident of identifier
  | AilEsizeof of qualifiers * ctype
  | AilEalignof of qualifiers * ctype

and generic_association 'A =
  | AilGAtype of ctype * expression 'A
  | AilGAdefault of expression 'A

and expression 'A [name = "e*"] =
  | AnnotatedExpression of 'A * expression' 'A

type bindings (*[name="b*"]*) = list (identifier * (qualifiers * ctype))

type statement' 'A 'B [name="s*"] = 
  | AilSskip
  | AilSexpr of expression 'B
  | AilSblock of bindings * list (statement 'A 'B)
  | AilSif of expression 'B * statement 'A 'B * statement 'A 'B
  | AilSwhile of expression 'B * statement 'A 'B
  | AilSdo of statement 'A 'B * expression 'B
  | AilSbreak
  | AilScontinue
  | AilSreturnVoid
  | AilSreturn of expression 'B
  | AilSswitch of expression 'B * statement 'A 'B
  | AilScase of integerConstant * statement 'A 'B
  | AilSdefault of statement 'A 'B
  | AilSlabel of identifier * statement 'A 'B
  | AilSgoto of identifier
  | AilSdeclaration of list (identifier * expression 'B)
and statement 'A 'B [name="s*"] =
  | AnnotatedStatement of 'A * statement' 'A 'B

(* (OLD) type sigma 'A 'B = context identifier ((ctype * bindings) * statement 'A 'B) *)

(*
type function_declaration 'A 'B = <|
  fun_return_ty:   ctype;
  fun_bindings:    bindings;
  fun_is_variadic: bool;
  fun_is_inline:   bool;
  fun_is_Noreturn: bool;
  fun_body:        maybe (statement 'A 'B);
|>

type sigma_declaration 'A 'B =
    (* no statement ==> prototype; the bool is for variadic functions *)
  | SDecl_fun           of identifier * function_declaration 'A 'B
  | SDecl_global        of identifier * (qualifiers * ctype * maybe (expression 'B))
  | SDecl_static_assert of expression 'B * stringConstant
*)

type declaration =
  | Decl_object   of qualifiers * ctype
    (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  | Decl_function of ctype * (list (qualifiers * ctype)) * bool * bool * bool

type sigma 'A 'B = <|
  declarations: Context.context identifier declaration;
  object_definitions: Context.context identifier (expression 'B);
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: Context.context identifier (list identifier * statement 'A 'B);
  static_assertions: list (expression 'B * stringLiteral)
|>

(*
  list (sigma_declaration 'A 'B)
*)

type gamma = Context.context identifier (qualifiers * ctype)

type program 'A 'B = identifier * sigma 'A 'B
(* (NEW OLD )
type program 'A 'B = <|
  startup    : identifier;
  
  (* no statement ==> prototype; the bool is for variadic functions *)
  functions  : context identifier ((ctype * bindings * bool) * maybe (statement 'A 'B));
  globals    : context identifier (ctype * maybe (expression 'B));
  strings    : context identifier string
|>
 *)


(* == Equality functions ==================================================== *)

val eq_identifier:         identifier         -> identifier         -> bool
val eq_integerSuffix:      integerSuffix      -> integerSuffix      -> bool
val eq_integerConstant:    integerConstant    -> integerConstant    -> bool
val eq_arithmeticOperator: arithmeticOperator -> arithmeticOperator -> bool
val eq_constant:           constant           -> constant           -> bool
val eq_unaryOperator:      unaryOperator      -> unaryOperator      -> bool
val eq_binaryOperator:     binaryOperator     -> binaryOperator     -> bool

(* NOTE: this is an internal function *)
val eq_arguments_aux: forall 'A.
                      ('A -> 'A -> bool)                                             ->
                      (('A -> 'A -> bool) -> expression 'A -> expression 'A -> bool) ->
                      list (expression 'A) -> list (expression 'A)                   ->
                      bool

(* NOTE: this is an internal function *)
val eq_expression': forall 'A.
                    ('A -> 'A -> bool)               ->
                    expression' 'A -> expression' 'A ->
                    bool

val eq_expression: forall 'A.
                   ('A -> 'A -> bool)             ->
                   expression 'A -> expression 'A ->
                   bool

val eq_arguments: forall 'A.
                  ('A -> 'A -> bool)                           ->
                  list (expression 'A) -> list (expression 'A) ->
                  bool

val eq_bindings: bindings -> bindings -> bool

val eq_definition: forall 'A.
                   ('A -> 'A -> bool)                                           ->
                   (identifier * expression 'A) -> (identifier * expression 'A) ->
                   bool

val eq_declaration: declaration -> declaration -> bool

val eq_block_aux: forall 'A 'B.
                  ('A -> 'A -> bool) -> ('B -> 'B -> bool)                                                 ->
                  (('A -> 'A -> bool) -> ('B -> 'B -> bool) -> statement 'A 'B -> statement 'A 'B -> bool) ->
                  list (statement 'A 'B) -> list (statement 'A 'B)                                         ->
                  bool

val eq_statement': forall 'A 'B.
                   ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                   statement' 'A 'B -> statement' 'A 'B     ->
                   bool

val eq_statement: forall 'A 'B.
                  ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                  statement 'A 'B -> statement 'A 'B       ->
                  bool

val eq_block: forall 'A 'B.
              ('A -> 'A -> bool) -> ('B -> 'B -> bool)         ->
              list (statement 'A 'B) -> list (statement 'A 'B) ->
              bool

val eq_sigma: forall 'A 'B.
              ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
              sigma 'A 'B -> sigma 'A 'B               ->
              bool

val eq_gamma: gamma -> gamma -> bool

val eq_program: forall 'A 'B.
                ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                program 'A 'B -> program 'A 'B           ->
                bool


let eq_identifier =
  (=)

let eq_basis b1 b2 =
  match (b1, b2) with
    | (Octal      , Octal      ) -> true
    | (Decimal    , Decimal    ) -> true
    | (Hexadecimal, Hexadecimal) -> true
    | (_          , _          ) -> false
  end

let eq_integerSuffix s1 s2 =
  match (s1, s2) with
    | (U  , U  ) -> true
    | (UL , UL ) -> true
    | (ULL, ULL) -> true
    | (L  , L  ) -> true
    | (LL , LL ) -> true
    | (_  , _  ) -> false
  end

let eq_integerConstant =
  eq_triple (=) (eq_basis) (eq_option eq_integerSuffix)

let eq_arithmeticOperator aop1 aop2 =
  match (aop1, aop2) with
    | (Mul , Mul ) -> true
    | (Div , Div ) -> true
    | (Mod , Mod ) -> true
    | (Add , Add ) -> true
    | (Sub , Sub ) -> true
    | (Shl , Shl ) -> true
    | (Shr , Shr ) -> true
    | (Band, Band) -> true
    | (Bor , Bor ) -> true
    | (Bxor, Bxor) -> true
    | (_   , _   ) -> false
  end


let eq_characterPrefix pref1 pref2 =
  match (pref1, pref2) with
    | (Pref_L, Pref_L) -> true
    | (Pref_u, Pref_u) -> true
    | (Pref_U, Pref_U) -> true
    | (_     , _     ) -> false
  end

let eq_characterConstant =
  eq_pair (eq_option eq_characterPrefix) (=)

let eq_encodingPrefix pref1 pref2 =
  match (pref1, pref2) with
    | (Enc_u8, Enc_u8) -> true
    | (Enc_u , Enc_u ) -> true
    | (Enc_U , Enc_U ) -> true
    | (Enc_L , Enc_L ) -> true
    | (_     , _     ) -> false
  end

let eq_stringLiteral =
  eq_pair (eq_option eq_encodingPrefix) (=)


let eq_constant c1 c2 =
  match (c1, c2) with
    | (ConstantInteger   ic1, ConstantInteger   ic2) -> eq_integerConstant   ic1 ic2
    | (ConstantCharacter cc1, ConstantCharacter cc2) -> eq_characterConstant cc1 cc2
    | (_                    , _                    ) -> false
  end

let eq_unaryOperator u1 u2 =
  match (u1, u2) with
    | (Plus       , Plus       ) -> true
    | (Minus      , Minus      ) -> true
    | (Bnot       , Bnot       ) -> true
    | (Address    , Address    ) -> true
    | (Indirection, Indirection) -> true
    | (PostfixIncr, PostfixIncr) -> true
    | (PostfixDecr, PostfixDecr) -> true
    | (_          , _          ) -> false
  end

let eq_binaryOperator bop1 bop2 =
  match (bop1, bop2) with
    | (Arithmetic aop1, Arithmetic aop2) -> eq_arithmeticOperator aop1 aop2
    | (Comma, Comma) -> true
    | (And  , And  ) -> true
    | (Or   , Or   ) -> true
    | (Lt   , Lt   ) -> true
    | (Gt   , Gt   ) -> true
    | (Le   , Le   ) -> true
    | (Ge   , Ge   ) -> true
    | (Eq   , Eq   ) -> true
    | (Ne   , Ne   ) -> true
    | (_    , _    ) -> false
  end

let rec eq_arguments_aux eq_A eq_expression a1 a2 =
  match (a1, a2) with
    | ([]      , []      ) -> true
    | (e1 :: a1, e2 :: a2) -> eq_expression eq_A e1 e2 && eq_arguments_aux eq_A eq_expression a1 a2
    | (_       , _       ) -> false
  end

let rec eq_expression' eq_A e1 e2 =
  let eq_arguments = eq_arguments_aux eq_A eq_expression in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        eq_unaryOperator uop1 uop2 &&
        eq_expression eq_A e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_binaryOperator bop1 bop2 &&
        eq_expression eq_A e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_expression eq_A e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_arithmeticOperator aop1 aop2 &&
        eq_expression eq_A e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_expression eq_A e2_1 e2_2 &&
        eq_expression eq_A e3_1 e3_2
    | (AilEcast q1 t1 e1, AilEcast q2 t2 e2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2 &&
        eq_expression eq_A e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        eq_expression eq_A e1 e2 &&
        eq_arguments es1 es2
    | (AilEstr lit1, AilEstr lit2) ->
        eq_stringLiteral lit1 lit2
    | (AilEconst c1, AilEconst c2) ->
        eq_constant c1 c2
    | (AilEident v1, AilEident v2) ->
        eq_identifier v1 v2
    | (AilEsizeof q1 t1, AilEsizeof q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (AilEalignof q1 t1, AilEalignof q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (_, _) -> false
  end
and eq_expression eq_A e1 e2 =
  match (e1, e2) with
    | (AnnotatedExpression a1 e1, AnnotatedExpression a2 e2) ->
        eq_A a1 a2 && eq_expression' eq_A e1 e2
  end

let eq_arguments eq_A a1 a2 =
  eq_arguments_aux eq_A eq_expression a1 a2

let eq_bindings =
  eq_list (eq_pair eq_identifier (eq_pair eq_qualifiers eq_ctype))

let eq_definition eq_A d1 d2 =
  eq_pair eq_identifier (eq_expression eq_A) d1 d2

let eq_declaration ds1 ds2 =
  match (ds1, ds2) with
    | (Decl_object qs1 ty1, Decl_object qs2 ty2) ->
        eq_qualifiers qs1 qs2 && eq_ctype ty1 ty2
    | (Decl_function ret_ty1 qs_tys1 is_variadic1 is_inline1 is_Noreturn1, Decl_function ret_ty2 qs_tys2 is_variadic2 is_inline2 is_Noreturn2) ->
        eq_ctype ret_ty1 ret_ty2 &&
        eq_list (eq_pair eq_qualifiers eq_ctype) qs_tys1 qs_tys2 &&
        is_variadic1 = is_variadic2 &&
        is_inline1 = is_inline2 &&
        is_Noreturn1 = is_Noreturn2
    | _ ->
        false
  end

let rec eq_block_aux eq_A eq_B equiv_statement ss1 ss2 =
  match (ss1, ss2) with
    | ([]       , []       ) -> true
    | (s1 :: ss1, s2 :: ss2) -> equiv_statement eq_A eq_B s1 s2 && eq_block_aux eq_A eq_B equiv_statement ss1 ss2
    | (_        , _        ) -> false
  end

let rec eq_statement' eq_A eq_B s1 s2 =
  let eq_block = eq_block_aux eq_A eq_B eq_statement in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        eq_expression eq_B e1 e2
    | (AilSblock b1 ss1, AilSblock b2 ss2) ->
        eq_bindings b1 b2 &&
        eq_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1_1 s1_2 &&
        eq_statement eq_A eq_B s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        eq_expression eq_B e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        eq_integerConstant ic1 ic2 &&
        eq_statement eq_A eq_B s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        eq_statement eq_A eq_B s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        eq_identifier v1 v2 &&
        eq_statement eq_A eq_B s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        eq_identifier v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        eq_list (eq_pair eq_identifier (eq_expression eq_B)) d1 d2
    | (_, _) -> false
  end
and eq_statement eq_A eq_B s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement a1 s1, AnnotatedStatement a2 s2) ->
        eq_A a1 a2 && eq_statement' eq_A eq_B s1 s2
  end

let eq_block eq_A eq_B ss1 ss2 =
  eq_block_aux eq_A eq_B eq_statement ss1 ss2


(*
let eq_function_declaration eq_A eq_B fdecl1 fdecl2 =
  eq_ctype    fdecl1.fun_return_ty fdecl2.fun_return_ty  &&
  eq_bindings fdecl1.fun_bindings  fdecl2.fun_bindings   &&
  fdecl1.fun_is_variadic <-> fdecl2.fun_is_variadic      &&
  fdecl1.fun_is_inline   <-> fdecl2.fun_is_inline        &&
  fdecl1.fun_is_Noreturn <-> fdecl2.fun_is_Noreturn      &&
  eq_option (eq_statement eq_A eq_B) fdecl1.fun_body fdecl2.fun_body


let eq_sigma_declaration eq_A eq_B sdecl1 sdecl2 =
  match (sdecl1, sdecl2) with
    | (SDecl_fun id1 fdecl1, SDecl_fun id2 fdecl2) ->
        eq_identifier id1 id2 &&
        eq_function_declaration eq_A eq_B fdecl1 fdecl2
    | (SDecl_global id1 glob1, SDecl_global id2 glob2) ->
        eq_identifier id1 id2 &&
        eq_triple eq_qualifiers eq_ctype (eq_option (eq_expression eq_B))
          glob1 glob2
    | (SDecl_static_assert e1 sc1, SDecl_static_assert e2 sc2) ->
        eq_expression eq_B e1 e2 &&
        eq_stringLiteral sc1 sc2
    | (_,_) ->
        false
  end
*)



let eq_sigma eq_A eq_B sig1 sig2 =
  eq_context eq_identifier eq_declaration sig1.declarations sig1.declarations &&
  eq_context eq_identifier (eq_expression eq_B) sig1.object_definitions sig2.object_definitions &&
  eq_context eq_identifier (eq_pair (eq_list eq_identifier) (eq_statement eq_A eq_B)) sig1.function_definitions sig2.function_definitions &&
  eq_list (eq_pair (eq_expression eq_B) eq_stringLiteral) sig1.static_assertions sig2.static_assertions

(*
let eq_sigma eq_A eq_B =
  eq_list (eq_sigma_declaration eq_A eq_B)
(* (OLD)  eq_context eq_identifier (eq_pair (eq_pair eq_ctype eq_bindings) (eq_statement eq_A eq_B)) *)
(*  eq_context eq_identifier (eq_sigma_declaration eq_A eq_B) *)
(*
    (eq_either
      (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (eq_expression eq_B)))
    )
*)
*)

let eq_gamma g1 g2 =
  eq_context eq_identifier (eq_pair eq_qualifiers eq_ctype) g1 g2

let eq_program eq_A eq_B p1 p2 =
  eq_pair eq_identifier (eq_sigma eq_A eq_B) p1 p2
(* (NEW OLD)
     eq_identifier p1.startup p2.startup
  && eq_context eq_identifier (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
       p1.functions p2.functions
  && eq_context eq_identifier (eq_pair eq_ctype (eq_option (eq_expression eq_B)))
       p1.globals p2.globals
  && eq_context eq_identifier (=) p1.strings p2.strings
 *)


(* == Equivalence functions ================================================= *)

val equiv_arguments_aux: forall 'A1 'A2.
                         (expression 'A1 -> expression 'A2 -> bool)     ->
                         list (expression 'A1) -> list (expression 'A2) ->
                         bool

val equiv_expression': forall 'A1 'A2. expression' 'A1                    -> expression' 'A2                    -> bool
val equiv_expression:  forall 'A1 'A2. expression  'A1                    -> expression  'A2                    -> bool
val equiv_arguments:   forall 'A1 'A2. list (expression 'A1)              -> list (expression 'A2)              -> bool
val equiv_definition:  forall 'A1 'A2. identifier * expression 'A1        -> identifier * expression 'A2        -> bool
val equiv_declaration: forall 'A1 'A2. list (identifier * expression 'A1) -> list (identifier * expression 'A2) -> bool

val equiv_block_aux: forall 'A1 'A2 'B1 'B2.
                     (statement  'A1 'B1 -> statement  'A2 'B2 -> bool) ->
                     list (statement 'A1 'B1) -> list (statement 'A2 'B2) ->
                     bool

val equiv_statement': forall 'A1 'A2 'B1 'B2. statement' 'A1 'B1       -> statement' 'A2 'B2       -> bool
val equiv_statement:  forall 'A1 'A2 'B1 'B2. statement  'A1 'B1       -> statement  'A2 'B2       -> bool
val equiv_block:      forall 'A1 'A2 'B1 'B2. list (statement 'A1 'B1) -> list (statement 'A2 'B2) -> bool

(* WIP
val equiv_sigma: forall 'A1 'A2 'B1 'B2. sigma 'A1 'B1 -> sigma 'A2 'B2 -> bool
val equiv_eq_sigma: forall 'A 'B.
                    ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                    sigma 'A 'B -> sigma 'A 'B               ->
                    bool

val equiv_gamma : gamma -> gamma -> bool

val equiv_program: forall 'A1 'A2 'B1 'B2. program 'A1 'B1 -> program 'A2 'B2 -> bool

val equiv_eq_program: forall 'A 'B.
                      ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                      program 'A 'B -> program 'A 'B ->
                      bool
*)


let rec equiv_arguments_aux equiv_expression a1 a2 =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> equiv_expression e1 e2 && equiv_arguments_aux equiv_expression a1 a2
  | (_       , _       ) -> false
    end

let rec equiv_expression' e1 e2 =
  let equiv_arguments = equiv_arguments_aux equiv_expression in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        eq_unaryOperator uop1 uop2 &&
        equiv_expression e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        eq_binaryOperator bop1 bop2 &&
        equiv_expression e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        eq_arithmeticOperator aop1 aop2 &&
        equiv_expression e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2 &&
        equiv_expression e3_1 e3_2
    | (AilEcast q1 t1 e1, AilEcast q2 t2 e2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2 &&
        equiv_expression e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        equiv_expression e1 e2 &&
        equiv_arguments es1 es2
    | (AilEconst c1, AilEconst c2) ->
        eq_constant c1 c2
    | (AilEident v1, AilEident v2) ->
        eq_identifier v1 v2
    | (AilEsizeof q1 t1, AilEsizeof q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (AilEalignof q1 t1, AilEalignof q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (_, _) -> false
  end
and equiv_expression e1 e2 =
  match (e1, e2) with
  | (AnnotatedExpression _ e1, AnnotatedExpression _ e2) -> equiv_expression' e1 e2
  end

let equiv_arguments a1 a2 =
  equiv_arguments_aux equiv_expression a1 a2

let equiv_definition d1 d2 =
  equiv_pair eq_identifier equiv_expression d1 d2


let rec equiv_declaration ds1 ds2 =
  match (ds1, ds2) with
  | ([]       , []       ) -> true
  | (d1 :: ds1, d2 :: ds2) -> equiv_definition d1 d2 && equiv_declaration ds1 ds2
  | (_        , _        ) -> false
  end

let rec equiv_block_aux equiv_statement ss1 ss2 =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement s1 s2 && equiv_block_aux equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec equiv_statement' s1 s2 =
  let equiv_block = equiv_block_aux equiv_statement in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        equiv_expression e1 e2
    | (AilSblock b1 ss1, AilSblock b2 ss2) ->
        eq_bindings b1 b2 &&
        equiv_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1_1 s1_2 &&
        equiv_statement s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        equiv_expression e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        eq_integerConstant ic1 ic2 &&
        equiv_statement s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        equiv_statement s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        eq_identifier v1 v2 &&
        equiv_statement s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        eq_identifier v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        equiv_declaration d1 d2
    | (_, _) -> false
  end
and equiv_statement s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        equiv_statement' s1 s2
  end

let equiv_block ss1 ss2 =
 equiv_block_aux equiv_statement ss1 ss2


(* Currently unused.
let declaration = identifier * maybe storageDuration.
*)

(*
let equiv_function_declaration fdecl1 fdecl2 =
  eq_ctype    fdecl1.fun_return_ty fdecl2.fun_return_ty  &&
  eq_bindings fdecl1.fun_bindings  fdecl2.fun_bindings   &&
  fdecl1.fun_is_variadic <-> fdecl2.fun_is_variadic      &&
  fdecl1.fun_is_inline   <-> fdecl2.fun_is_inline        &&
  fdecl1.fun_is_Noreturn <-> fdecl2.fun_is_Noreturn      &&
  equiv_option equiv_statement fdecl1.fun_body fdecl2.fun_body

let equiv_sigma_declaration sdecl1 sdecl2 =
  match (sdecl1, sdecl2) with
    | (SDecl_fun id1 fdecl1, SDecl_fun id2 fdecl2) ->
        eq_identifier id1 id2 &&
        equiv_function_declaration fdecl1 fdecl2
    | (SDecl_global id1 glob1, SDecl_global id2 glob2) ->
        eq_identifier id1 id2 &&
        equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression)
          glob1 glob2
    | (SDecl_static_assert e1 sc1, SDecl_static_assert e2 sc2) ->
        equiv_expression e1 e2 &&
        eq_stringLiteral sc1 sc2
    | (_,_) ->
        false
  end
*)

(* WIP

let equiv_sigma S1 S2 =
  sigma_equiv eq_identifier (fun _ ->
    equiv_sigma_declaration
  ) S1 S2
(* (OLD)  equiv eq_identifier (fun _ -> equiv_pair (eq_pair eq_ctype eq_bindings) equiv_statement) S1 S2 *)
(*
    equiv_either
      (equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
      (equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression))
*)

let equiv_eq_sigma eq_A eq_B S1 S2 =
(* (OLD)  equiv eq_identifier (fun _ -> eq_pair (eq_pair eq_ctype eq_bindings) (eq_statement eq_A eq_B)) S1 S2 *)
  sigma_equiv eq_identifier (fun _ ->
    eq_sigma_declaration eq_A eq_B
(*
    eq_either
      (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (eq_expression eq_B)))
*)
  ) S1 S2

let equiv_gamma g1 g2 =
  sigma_equiv eq_identifier (fun _ -> eq_pair eq_qualifiers eq_ctype) g1 g2

let equiv_program p1 p2 =
  equiv_pair eq_identifier equiv_sigma p1 p2
(* (NEW OLD)
     eq_identifier p1.startup p2.startup
  && equiv eq_identifier (fun _ -> equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
       p1.functions p2.functions
  && equiv eq_identifier (fun _ -> equiv_pair eq_ctype (equiv_option equiv_expression))
       p1.globals p2.globals
  && eq_context eq_identifier (=) p1.strings p2.strings
*)

let equiv_eq_program eq_A eq_B p1 p2 =
  eq_pair eq_identifier (equiv_eq_sigma eq_A eq_B) p1 p2
(* (NEW OLD)
     eq_identifier p1.startup p2.startup
  && equiv eq_identifier (fun _ -> eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
       p1.functions p2.functions
  && equiv eq_identifier (fun _ -> eq_pair eq_ctype (eq_option (eq_expression eq_B)))
       p1.globals p2.globals
  && eq_context eq_identifier (=) p1.strings p2.strings
*)

*)

(* *)
val     sigma_lookup: forall 'A 'B. sigma 'A 'B -> identifier -> maybe ((* sigma_declaration 'A 'B *) unit)
(*
let rec sigma_lookup S a =
  match S with
    | [] ->
        Nothing
    | (SDecl_fun id fdecl) :: S' ->
        if eq_identifier id a then
          Just (SDecl_fun id fdecl)
        else
          sigma_lookup S' a
    | (SDecl_global id glob) :: S' ->
        if eq_identifier id a then
          Just (SDecl_global id glob)
        else
          sigma_lookup S' a
    | (SDecl_static_assert _ _) :: S' ->
        sigma_lookup S' a
  end
*)

(*
val sigma_mem: forall 'A 'B. identifier -> sigma 'A 'B -> bool
let sigma_mem a S =
  match sigma_lookup S a with
  | Just _  -> true
  | Nothing -> false
  end

val sigma_fresh: forall 'A 'B. identifier -> sigma 'A 'B -> bool
let sigma_fresh a S =
  not (sigma_mem a S)
*)

val sigma_fresh_bindings: forall 'A 'B1 'B2. bindings -> sigma 'A 'B1 -> bool
let sigma_fresh_bindings bs S =
  all_list (fun (ident, _) -> Context.fresh eq_identifier ident S.declarations) bs



(*
val lookup:         forall 'B. Context.context identifier 'B -> identifier -> maybe 'B
val mem:            forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh:          forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh_bindings: forall 'B. bindings -> Context.context identifier 'B -> bool

val disjoint: forall 'B1 'B2.
              Context.context identifier 'B1 -> Context.context identifier 'B2 ->
              bool



let lookup C v          = Context.lookup eq_identifier C v
let mem v C             = Context.mem eq_identifier v C
let fresh v C           = Context.fresh eq_identifier v C
let fresh_bindings bs C = Context.fresh_bindings eq_identifier bs C
let disjoint C1 C2      = Context.disjoint eq_identifier C1 C2
*)

val parameters_of_bindings: bindings -> list (qualifiers * ctype)

val type_from_sigma: forall 'A 'B. (ctype * bindings * bool) * maybe (statement 'A 'B) -> ctype

let parameters_of_bindings bs =
  List.map snd bs

let type_from_sigma ((ty, bs, is_variadic), _) =
  Function ty (List.map snd bs) is_variadic







(* K Hack *)

(*
type declaration = qualifiers * ctype (* * maybe storageDuration *)


type file 'a = <|
  main:    identifier;
  id_map:  Pmap.map identifier declaration;
  globals: list (identifier * expression 'a);
  fn_map:  Pmap.map identifier (list identifier * statement Location.t 'a)
|>

val file_of_program: forall 'B. program Location.t 'B -> file 'B
let file_of_program (main_id, ctx) =
  let (ids, fns) = List.fold_left (fun (ids_, fns_) (id, ((ty, bds), s)) ->
    (
      Pmap.add id (AilTypes.no_qualifiers, AilTypes.Function ty (List.map snd bds)) ids_,
      Pmap.add id (List.map fst bds, s) fns_
    )
  ) (Pmap.empty, Pmap.empty) ctx in
  <|
      main=    main_id;
      id_map=  ids;
      globals= [];
      fn_map=  fns
   |>
*)
