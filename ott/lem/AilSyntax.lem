open import Pervasives Common AilTypes Context ErrorMonad
import Symbol


(* == Ail syntax datatypes ================================================== *)
type identifier = Symbol.t

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

type integerConstant (*[name = "ic*"]*) = integer * maybe integerSuffix

type arithmeticOperator [name = "aop*"] =  (*r 6.5.5 Multiplicative operators *)
 | Mul
 | Div
 | Mod (*r 6.5.6 Additive operators *)
 | Add
 | Sub (*r 6.5.7 Bitwise shift operators *)
 | Shl
 | Shr (*r 6.5.10 Bitwise AND operator *)
 | Band (*r 6.5.11 Bitwise exclusive OR operator *)
 | Bor (*r 6.5.12 Bitwise inclusive OR operator *)
 | Xor (*r Binary operators from 6.5.5-14, 6.5.17 *)

type constant [name = "c*"] = 
 | ConstantInteger of integerConstant
 | ConstantString of string

type unaryOperator = 
 | Plus
 | Minus
 | Bnot
 | Address
 | Indirection
 | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
 | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assigments *)
 | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
 | Comma (*r 6.5.13 Logical AND operator *)
 | And (*r 6.5.14 Logical OR operator *)
 | Or (*r 6.5.8 Relational operators *)
 | Lt
 | Gt
 | Le
 | Ge (*r 6.5.9 Equality operators *)
 | Eq
 | Ne

type expression' 'A [name = "e*"] = 
  | Unary of unaryOperator * expression 'A
  | Binary of expression 'A * binaryOperator * expression 'A
  | Assign of expression 'A * expression 'A
  | CompoundAssign of expression 'A * arithmeticOperator * expression 'A
  | Conditional of expression 'A * expression 'A * expression 'A
  | Cast of qualifiers * ctype * expression 'A
  | Call of expression 'A * list (expression 'A)
  | Constant of constant
  | Var of identifier
  | SizeOf of qualifiers * ctype
  | AlignOf of qualifiers * ctype
and expression 'A [name = "e*"] =
  | AnnotatedExpression of 'A * expression' 'A

type bindings (*[name="b*"]*) = list (identifier * (qualifiers * ctype))

type statement' 'A 'B [name="s*"] = 
  | Skip
  | Expression of expression 'B
  | Block of bindings * list (statement 'A 'B)
  | If of expression 'B * statement 'A 'B * statement 'A 'B
  | While of expression 'B * statement 'A 'B
  | Do of statement 'A 'B * expression 'B
  | Break
  | Continue
  | ReturnVoid
  | Return of expression 'B
  | Switch of expression 'B * statement 'A 'B
  | Case of integerConstant * statement 'A 'B
  | Default of statement 'A 'B
  | Label of identifier * statement 'A 'B
  | Goto of identifier
  | Declaration of list (identifier * expression 'B)
and statement 'A 'B [name="s*"] =
  | AnnotatedStatement of 'A * statement' 'A 'B

(* (OLD) type sigma 'A 'B = context identifier ((ctype * bindings) * statement 'A 'B) *)
type sigma 'A 'B =
  context identifier
    (either
      (* no statement ==> prototype; the bool is for variadic functions *)
      ((ctype * bindings * bool) * maybe (statement 'A 'B)) (* a function *)
      (qualifiers * ctype * maybe (expression 'B)) (* a global variable *)
    )

type gamma = Context.context identifier (qualifiers * ctype)

type program 'A 'B = identifier * sigma 'A 'B
(* (NEW OLD )
type program 'A 'B = <|
  startup    : identifier;
  
  (* no statement ==> prototype; the bool is for variadic functions *)
  functions  : context identifier ((ctype * bindings * bool) * maybe (statement 'A 'B));
  globals    : context identifier (ctype * maybe (expression 'B));
  strings    : context identifier string
|>
 *)






(* == Equality functions ==================================================== *)

val eq_identifier:         identifier         -> identifier         -> bool
val eq_integerSuffix:      integerSuffix      -> integerSuffix      -> bool
val eq_integerConstant:    integerConstant    -> integerConstant    -> bool
val eq_arithmeticOperator: arithmeticOperator -> arithmeticOperator -> bool
val eq_constant:           constant           -> constant           -> bool
val eq_unaryOperator:      unaryOperator      -> unaryOperator      -> bool
val eq_binaryOperator:     binaryOperator     -> binaryOperator     -> bool

(* NOTE: this is an internal function *)
val eq_arguments_aux: forall 'A.
                      ('A -> 'A -> bool)                                             ->
                      (('A -> 'A -> bool) -> expression 'A -> expression 'A -> bool) ->
                      list (expression 'A) -> list (expression 'A)                   ->
                      bool

(* NOTE: this is an internal function *)
val eq_expression': forall 'A.
                    ('A -> 'A -> bool)               ->
                    expression' 'A -> expression' 'A ->
                    bool

val eq_expression: forall 'A.
                   ('A -> 'A -> bool)             ->
                   expression 'A -> expression 'A ->
                   bool

val eq_arguments: forall 'A.
                  ('A -> 'A -> bool)                           ->
                  list (expression 'A) -> list (expression 'A) ->
                  bool

val eq_bindings: bindings -> bindings -> bool

val eq_definition: forall 'A.
                   ('A -> 'A -> bool)                                           ->
                   (identifier * expression 'A) -> (identifier * expression 'A) ->
                   bool

val eq_declaration: forall 'A.
                    ('A -> 'A -> bool)                                                     ->
                    list (identifier * expression 'A) -> list (identifier * expression 'A) ->
                    bool

val eq_block_aux: forall 'A 'B.
                  ('A -> 'A -> bool) -> ('B -> 'B -> bool)                                                 ->
                  (('A -> 'A -> bool) -> ('B -> 'B -> bool) -> statement 'A 'B -> statement 'A 'B -> bool) ->
                  list (statement 'A 'B) -> list (statement 'A 'B)                                         ->
                  bool

val eq_statement': forall 'A 'B.
                   ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                   statement' 'A 'B -> statement' 'A 'B     ->
                   bool

val eq_statement: forall 'A 'B.
                  ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                  statement 'A 'B -> statement 'A 'B       ->
                  bool

val eq_block: forall 'A 'B.
              ('A -> 'A -> bool) -> ('B -> 'B -> bool)         ->
              list (statement 'A 'B) -> list (statement 'A 'B) ->
              bool

val eq_sigma: forall 'A 'B.
              ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
              sigma 'A 'B -> sigma 'A 'B               ->
              bool

val eq_gamma: gamma -> gamma -> bool

val eq_program: forall 'A 'B.
                ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                program 'A 'B -> program 'A 'B           ->
                bool


let eq_identifier =
  (=)

let eq_integerSuffix s1 s2 =
  match (s1, s2) with
    | (U  , U  ) -> true
    | (UL , UL ) -> true
    | (ULL, ULL) -> true
    | (L  , L  ) -> true
    | (LL , LL ) -> true
    | (_  , _  ) -> false
  end

let eq_integerConstant =
  eq_pair (=) (eq_option eq_integerSuffix)

let eq_arithmeticOperator aop1 aop2 =
  match (aop1, aop2) with
    | (Mul , Mul ) -> true
    | (Div , Div ) -> true
    | (Mod , Mod ) -> true
    | (Add , Add ) -> true
    | (Sub , Sub ) -> true
    | (Shl , Shl ) -> true
    | (Shr , Shr ) -> true
    | (Band, Band) -> true
    | (Bor , Bor ) -> true
    | (Xor , Xor ) -> true
    | (_   , _   ) -> false
  end

let eq_constant c1 c2 =
  match (c1, c2) with
    | (ConstantInteger ic1, ConstantInteger ic2) -> eq_integerConstant ic1 ic2
    | (ConstantString str1, ConstantString str2) -> str1 = str2
    | (_,_)                                      -> false
  end

let eq_unaryOperator u1 u2 =
  match (u1, u2) with
    | (Plus       , Plus       ) -> true
    | (Minus      , Minus      ) -> true
    | (Bnot       , Bnot       ) -> true
    | (Address    , Address    ) -> true
    | (Indirection, Indirection) -> true
    | (PostfixIncr, PostfixIncr) -> true
    | (PostfixDecr, PostfixDecr) -> true
    | (_          , _          ) -> false
  end

let eq_binaryOperator bop1 bop2 =
  match (bop1, bop2) with
    | (Arithmetic aop1, Arithmetic aop2) -> eq_arithmeticOperator aop1 aop2
    | (Comma, Comma) -> true
    | (And  , And  ) -> true
    | (Or   , Or   ) -> true
    | (Lt   , Lt   ) -> true
    | (Gt   , Gt   ) -> true
    | (Le   , Le   ) -> true
    | (Ge   , Ge   ) -> true
    | (Eq   , Eq   ) -> true
    | (Ne   , Ne   ) -> true
    | (_    , _    ) -> false
  end

let rec eq_arguments_aux eq_A eq_expression a1 a2 =
  match (a1, a2) with
    | ([]      , []      ) -> true
    | (e1 :: a1, e2 :: a2) -> eq_expression eq_A e1 e2 && eq_arguments_aux eq_A eq_expression a1 a2
    | (_       , _       ) -> false
  end

let rec eq_expression' eq_A e1 e2 =
  let eq_arguments = eq_arguments_aux eq_A eq_expression in
  match (e1, e2) with
    | (Unary uop1 e1, Unary uop2 e2) ->
        eq_unaryOperator uop1 uop2 &&
        eq_expression eq_A e1 e2
    | (Binary e1_1 bop1 e2_1, Binary e1_2 bop2 e2_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_binaryOperator bop1 bop2 &&
        eq_expression eq_A e2_1 e2_2
    | (Assign e1_1 e2_1, Assign e1_2 e2_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_expression eq_A e2_1 e2_2
    | (CompoundAssign e1_1 aop1 e2_1, CompoundAssign e1_2 aop2 e2_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_arithmeticOperator aop1 aop2 &&
        eq_expression eq_A e2_1 e2_2
    | (Conditional e1_1 e2_1 e3_1, Conditional e1_2 e2_2 e3_2) ->
        eq_expression eq_A e1_1 e1_2 &&
        eq_expression eq_A e2_1 e2_2 &&
        eq_expression eq_A e3_1 e3_2
    | (Cast q1 t1 e1, Cast q2 t2 e2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2 &&
        eq_expression eq_A e1 e2
    | (Call e1 es1, Call e2 es2) ->
        eq_expression eq_A e1 e2 &&
        eq_arguments es1 es2
    | (Constant c1, Constant c2) ->
        eq_constant c1 c2
    | (Var v1, Var v2) ->
        eq_identifier v1 v2
    | (SizeOf q1 t1, SizeOf q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (AlignOf q1 t1, AlignOf q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (_, _) -> false
  end
and eq_expression eq_A e1 e2 =
  match (e1, e2) with
    | (AnnotatedExpression a1 e1, AnnotatedExpression a2 e2) ->
        eq_A a1 a2 && eq_expression' eq_A e1 e2
  end

let eq_arguments eq_A a1 a2 =
  eq_arguments_aux eq_A eq_expression a1 a2

let eq_bindings =
  eq_list (eq_pair eq_identifier (eq_pair eq_qualifiers eq_ctype))

let eq_definition eq_A d1 d2 =
  eq_pair eq_identifier (eq_expression eq_A) d1 d2

let eq_declaration eq_A ds1 ds2 =
  eq_list (eq_definition eq_A) ds1 ds2

let rec eq_block_aux eq_A eq_B equiv_statement ss1 ss2 =
  match (ss1, ss2) with
    | ([]       , []       ) -> true
    | (s1 :: ss1, s2 :: ss2) -> equiv_statement eq_A eq_B s1 s2 && eq_block_aux eq_A eq_B equiv_statement ss1 ss2
    | (_        , _        ) -> false
  end

let rec eq_statement' eq_A eq_B s1 s2 =
  let eq_block = eq_block_aux eq_A eq_B eq_statement in
  match (s1, s2) with
    | (Skip, Skip) -> true
    | (Expression e1, Expression e2) ->
        eq_expression eq_B e1 e2
    | (Block b1 ss1, Block b2 ss2) ->
        eq_bindings b1 b2 &&
        eq_block ss1 ss2
    | (If e1 s1_1 s2_1, If e2 s1_2 s2_2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1_1 s1_2 &&
        eq_statement eq_A eq_B s2_1 s2_2  
    | (While e1 s1, While e2 s2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1 s2
    | (Do s1 e1, Do s2 e2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1 s2
    | (Break, Break) -> true
    | (Continue, Continue) -> true
    | (ReturnVoid, ReturnVoid) -> true
    | (Return e1, Return e2) ->
        eq_expression eq_B e1 e2
    | (Switch e1 s1, Switch e2 s2) ->
        eq_expression eq_B e1 e2 &&
        eq_statement eq_A eq_B s1 s2
    | (Case ic1 s1, Case ic2 s2) ->
        eq_integerConstant ic1 ic2 &&
        eq_statement eq_A eq_B s1 s2
    | (Default s1, Default s2) ->
        eq_statement eq_A eq_B s1 s2
    | (Label v1 s1, Label v2 s2) ->
        eq_identifier v1 v2 &&
        eq_statement eq_A eq_B s1 s2
    | (Goto v1, Goto v2) ->
        eq_identifier v1 v2
    | (Declaration d1, Declaration d2) ->
        eq_declaration eq_B d1 d2
    | (_, _) -> false
  end
and eq_statement eq_A eq_B s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement a1 s1, AnnotatedStatement a2 s2) ->
        eq_A a1 a2 && eq_statement' eq_A eq_B s1 s2
  end

let eq_block eq_A eq_B ss1 ss2 =
  eq_block_aux eq_A eq_B eq_statement ss1 ss2

let eq_sigma eq_A eq_B =
(* (OLD)  eq_context eq_identifier (eq_pair (eq_pair eq_ctype eq_bindings) (eq_statement eq_A eq_B)) *)
  eq_context eq_identifier
    (eq_either
      (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (eq_expression eq_B)))
    )

let eq_gamma g1 g2 =
  eq_context eq_identifier (eq_pair eq_qualifiers eq_ctype) g1 g2

let eq_program eq_A eq_B p1 p2 =
  eq_pair eq_identifier (eq_sigma eq_A eq_B) p1 p2
(* (NEW OLD)
     eq_identifier p1.startup p2.startup
  && eq_context eq_identifier (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
       p1.functions p2.functions
  && eq_context eq_identifier (eq_pair eq_ctype (eq_option (eq_expression eq_B)))
       p1.globals p2.globals
  && eq_context eq_identifier (=) p1.strings p2.strings
 *)


(* == Equivalence functions ================================================= *)

val equiv_arguments_aux: forall 'A1 'A2.
                         (expression 'A1 -> expression 'A2 -> bool)     ->
                         list (expression 'A1) -> list (expression 'A2) ->
                         bool

val equiv_expression': forall 'A1 'A2. expression' 'A1                    -> expression' 'A2                    -> bool
val equiv_expression:  forall 'A1 'A2. expression  'A1                    -> expression  'A2                    -> bool
val equiv_arguments:   forall 'A1 'A2. list (expression 'A1)              -> list (expression 'A2)              -> bool
val equiv_definition:  forall 'A1 'A2. identifier * expression 'A1        -> identifier * expression 'A2        -> bool
val equiv_declaration: forall 'A1 'A2. list (identifier * expression 'A1) -> list (identifier * expression 'A2) -> bool

val equiv_block_aux: forall 'A1 'A2 'B1 'B2.
                     (statement  'A1 'B1 -> statement  'A2 'B2 -> bool) ->
                     list (statement 'A1 'B1) -> list (statement 'A2 'B2) ->
                     bool

val equiv_statement': forall 'A1 'A2 'B1 'B2. statement' 'A1 'B1       -> statement' 'A2 'B2       -> bool
val equiv_statement:  forall 'A1 'A2 'B1 'B2. statement  'A1 'B1       -> statement  'A2 'B2       -> bool
val equiv_block:      forall 'A1 'A2 'B1 'B2. list (statement 'A1 'B1) -> list (statement 'A2 'B2) -> bool

val equiv_sigma: forall 'A1 'A2 'B1 'B2. sigma 'A1 'B1 -> sigma 'A2 'B2 -> bool
val equiv_eq_sigma: forall 'A 'B.
                    ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                    sigma 'A 'B -> sigma 'A 'B               ->
                    bool

val equiv_gamma : gamma -> gamma -> bool

val equiv_program: forall 'A1 'A2 'B1 'B2. program 'A1 'B1 -> program 'A2 'B2 -> bool

val equiv_eq_program: forall 'A 'B.
                      ('A -> 'A -> bool) -> ('B -> 'B -> bool) ->
                      program 'A 'B -> program 'A 'B ->
                      bool


let rec equiv_arguments_aux equiv_expression a1 a2 =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> equiv_expression e1 e2 && equiv_arguments_aux equiv_expression a1 a2
  | (_       , _       ) -> false
    end

let rec equiv_expression' e1 e2 =
  let equiv_arguments = equiv_arguments_aux equiv_expression in
  match (e1, e2) with
    | (Unary uop1 e1, Unary uop2 e2) ->
        eq_unaryOperator uop1 uop2 &&
        equiv_expression e1 e2
    | (Binary e1_1 bop1 e2_1, Binary e1_2 bop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        eq_binaryOperator bop1 bop2 &&
        equiv_expression e2_1 e2_2
    | (Assign e1_1 e2_1, Assign e1_2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2
    | (CompoundAssign e1_1 aop1 e2_1, CompoundAssign e1_2 aop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        eq_arithmeticOperator aop1 aop2 &&
        equiv_expression e2_1 e2_2
    | (Conditional e1_1 e2_1 e3_1, Conditional e1_2 e2_2 e3_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2 &&
        equiv_expression e3_1 e3_2
    | (Cast q1 t1 e1, Cast q2 t2 e2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2 &&
        equiv_expression e1 e2
    | (Call e1 es1, Call e2 es2) ->
        equiv_expression e1 e2 &&
        equiv_arguments es1 es2
    | (Constant c1, Constant c2) ->
        eq_constant c1 c2
    | (Var v1, Var v2) ->
        eq_identifier v1 v2
    | (SizeOf q1 t1, SizeOf q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (AlignOf q1 t1, AlignOf q2 t2) ->
        eq_qualifiers q1 q2 &&
        eq_ctype t1 t2
    | (_, _) -> false
  end
and equiv_expression e1 e2 =
  match (e1, e2) with
  | (AnnotatedExpression _ e1, AnnotatedExpression _ e2) -> equiv_expression' e1 e2
  end

let equiv_arguments a1 a2 =
  equiv_arguments_aux equiv_expression a1 a2

let equiv_definition d1 d2 =
  equiv_pair eq_identifier equiv_expression d1 d2


let rec equiv_declaration ds1 ds2 =
  match (ds1, ds2) with
  | ([]       , []       ) -> true
  | (d1 :: ds1, d2 :: ds2) -> equiv_definition d1 d2 && equiv_declaration ds1 ds2
  | (_        , _        ) -> false
  end

let rec equiv_block_aux equiv_statement ss1 ss2 =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement s1 s2 && equiv_block_aux equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec equiv_statement' s1 s2 =
  let equiv_block = equiv_block_aux equiv_statement in
  match (s1, s2) with
    | (Skip, Skip) -> true
    | (Expression e1, Expression e2) ->
        equiv_expression e1 e2
    | (Block b1 ss1, Block b2 ss2) ->
        eq_bindings b1 b2 &&
        equiv_block ss1 ss2
    | (If e1 s1_1 s2_1, If e2 s1_2 s2_2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1_1 s1_2 &&
        equiv_statement s2_1 s2_2  
    | (While e1 s1, While e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (Do s1 e1, Do s2 e2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (Break, Break) -> true
    | (Continue, Continue) -> true
    | (ReturnVoid, ReturnVoid) -> true
    | (Return e1, Return e2) ->
        equiv_expression e1 e2
    | (Switch e1 s1, Switch e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (Case ic1 s1, Case ic2 s2) ->
        eq_integerConstant ic1 ic2 &&
        equiv_statement s1 s2
    | (Default s1, Default s2) ->
        equiv_statement s1 s2
    | (Label v1 s1, Label v2 s2) ->
        eq_identifier v1 v2 &&
        equiv_statement s1 s2
    | (Goto v1, Goto v2) ->
        eq_identifier v1 v2
    | (Declaration d1, Declaration d2) ->
        equiv_declaration d1 d2
    | (_, _) -> false
  end
and equiv_statement s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        equiv_statement' s1 s2
  end

let equiv_block ss1 ss2 =
 equiv_block_aux equiv_statement ss1 ss2


(* Currently unused.
let declaration = identifier * maybe storageDuration.
*)


let equiv_sigma S1 S2 =
(* (OLD)  equiv eq_identifier (fun _ -> equiv_pair (eq_pair eq_ctype eq_bindings) equiv_statement) S1 S2 *)
  equiv eq_identifier (fun _ ->
    equiv_either
      (equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
      (equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression))
  ) S1 S2

let equiv_eq_sigma eq_A eq_B S1 S2 =
(* (OLD)  equiv eq_identifier (fun _ -> eq_pair (eq_pair eq_ctype eq_bindings) (eq_statement eq_A eq_B)) S1 S2 *)
  equiv eq_identifier (fun _ ->
    eq_either
      (eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (eq_expression eq_B)))
  ) S1 S2

let equiv_gamma g1 g2 =
  equiv eq_identifier (fun _ -> eq_pair eq_qualifiers eq_ctype) g1 g2

let equiv_program p1 p2 =
  equiv_pair eq_identifier equiv_sigma p1 p2
(* (NEW OLD)
     eq_identifier p1.startup p2.startup
  && equiv eq_identifier (fun _ -> equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
       p1.functions p2.functions
  && equiv eq_identifier (fun _ -> equiv_pair eq_ctype (equiv_option equiv_expression))
       p1.globals p2.globals
  && eq_context eq_identifier (=) p1.strings p2.strings
*)

let equiv_eq_program eq_A eq_B p1 p2 =
  eq_pair eq_identifier (equiv_eq_sigma eq_A eq_B) p1 p2
(* (NEW OLD)
     eq_identifier p1.startup p2.startup
  && equiv eq_identifier (fun _ -> eq_pair (eq_triple eq_ctype eq_bindings (=)) (eq_option (eq_statement eq_A eq_B)))
       p1.functions p2.functions
  && equiv eq_identifier (fun _ -> eq_pair eq_ctype (eq_option (eq_expression eq_B)))
       p1.globals p2.globals
  && eq_context eq_identifier (=) p1.strings p2.strings
*)


(* *)

val lookup:         forall 'B. Context.context identifier 'B -> identifier -> maybe 'B
val mem:            forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh:          forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh_bindings: forall 'B. bindings -> Context.context identifier 'B -> bool

val disjoint: forall 'B1 'B2.
              Context.context identifier 'B1 -> Context.context identifier 'B2 ->
              bool

val parameters_of_bindings: bindings -> list (qualifiers * ctype)

val type_from_sigma: forall 'A 'B. (ctype * bindings * bool) * maybe (statement 'A 'B) -> ctype


let lookup C v          = Context.lookup eq_identifier C v
let mem v C             = Context.mem eq_identifier v C
let fresh v C           = Context.fresh eq_identifier v C
let fresh_bindings bs C = Context.fresh_bindings eq_identifier bs C
let disjoint C1 C2      = Context.disjoint eq_identifier C1 C2

let parameters_of_bindings bs =
  List.map snd bs

let type_from_sigma ((ty, bs, is_variadic), _) =
  Function ty (List.map snd bs) is_variadic







(* K Hack *)

(*
type declaration = qualifiers * ctype (* * maybe storageDuration *)


type file 'a = <|
  main:    identifier;
  id_map:  Pmap.map identifier declaration;
  globals: list (identifier * expression 'a);
  fn_map:  Pmap.map identifier (list identifier * statement Location.t 'a)
|>

val file_of_program: forall 'B. program Location.t 'B -> file 'B
let file_of_program (main_id, ctx) =
  let (ids, fns) = List.fold_left (fun (ids_, fns_) (id, ((ty, bds), s)) ->
    (
      Pmap.add id (AilTypes.no_qualifiers, AilTypes.Function ty (List.map snd bds)) ids_,
      Pmap.add id (List.map fst bds, s) fns_
    )
  ) (Pmap.empty, Pmap.empty) ctx in
  <|
      main=    main_id;
      id_map=  ids;
      globals= [];
      fn_map=  fns
   |>
*)
