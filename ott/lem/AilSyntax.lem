open Common
open AilTypes
open Context
 
type identifier = Symbol.t
let eq_identifier : identifier -> identifier -> bool = (=)

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

let eq_integerSuffix s1 s2 : bool =
  match (s1, s2) with
  | (U  , U  ) -> true
  | (UL , UL ) -> true
  | (ULL, ULL) -> true
  | (L  , L  ) -> true
  | (LL , LL ) -> true
  | (_  , _  ) -> false
  end

type integerConstant (*[name = "ic*"]*) = int * option integerSuffix

let eq_integerConstant = eq_pair (=) (eq_option eq_integerSuffix)

type arithmeticOperator [name = "aop*"] =  (*r 6.5.5 Multiplicative operators *)
 | Mul
 | Div
 | Mod (*r 6.5.6 Additive operators *)
 | Add
 | Sub (*r 6.5.7 Bitwise shift operators *)
 | Shl
 | Shr (*r 6.5.10 Bitwise AND operator *)
 | Band (*r 6.5.11 Bitwise exclusive OR operator *)
 | Bor (*r 6.5.12 Bitwise inclusive OR operator *)
 | Xor (*r Binary operators from 6.5.5-14, 6.5.17 *)

let eq_arithmeticOperator aop1 aop2 =
  match (aop1, aop2) with
  | (Mul , Mul ) -> true
  | (Div , Div ) -> true
  | (Mod , Mod ) -> true
  | (Add , Add ) -> true
  | (Sub , Sub ) -> true
  | (Shl , Shl ) -> true
  | (Shr , Shr ) -> true
  | (Band, Band) -> true
  | (Bor , Bor ) -> true
  | (Xor , Xor ) -> true
  | (_   , _   ) -> false
  end

type constant [name = "c*"] = 
 | ConstantInteger of integerConstant

let eq_constant c1 c2 =
  match (c1, c2) with
  | (ConstantInteger ic1, ConstantInteger ic2) -> eq_integerConstant ic1 ic2
  end

type unaryOperator = 
 | Plus
 | Minus
 | Bnot
 | Address
 | Indirection
 | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
 | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

let eq_unaryOperator u1 u2 =
  match (u1, u2) with
  | (Plus       , Plus       ) -> true
  | (Minus      , Minus      ) -> true
  | (Bnot       , Bnot       ) -> true
  | (Address    , Address    ) -> true
  | (Indirection, Indirection) -> true
  | (PostfixIncr, PostfixIncr) -> true
  | (PostfixDecr, PostfixDecr) -> true
  | (_          , _          ) -> false
  end

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assigments *)
 | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
 | Comma (*r 6.5.13 Logical AND operator *)
 | And (*r 6.5.14 Logical OR operator *)
 | Or (*r 6.5.8 Relational operators *)
 | Lt
 | Gt
 | Le
 | Ge (*r 6.5.9 Equality operators *)
 | Eq
 | Ne

let eq_binaryOperator bop1 bop2 =
  match (bop1, bop2) with
  | (Arithmetic aop1, Arithmetic aop2) -> eq_arithmeticOperator aop1 aop2
  | (Comma, Comma) -> true
  | (And  , And  ) -> true
  | (Or   , Or   ) -> true
  | (Lt   , Lt   ) -> true
  | (Gt   , Gt   ) -> true
  | (Le   , Le   ) -> true
  | (Ge   , Ge   ) -> true
  | (Eq   , Eq   ) -> true
  | (Ne   , Ne   ) -> true
  | (_    , _    ) -> false
  end

type expression' 'A [name = "e*"] = 
  | Unary of unaryOperator * expression 'A
  | Binary of expression 'A * binaryOperator * expression 'A
  | Assign of expression 'A * expression 'A
  | CompoundAssign of expression 'A * arithmeticOperator * expression 'A
  | Conditional of expression 'A * expression 'A * expression 'A
  | Cast of qualifiers * ctype * expression 'A
  | Call of expression 'A * list (expression 'A)
  | Constant of constant
  | Var of identifier
  | SizeOf of qualifiers * ctype
  | AlignOf of qualifiers * ctype
and expression 'A [name = "e*"] =
  | AnnotatedExpression of 'A * expression' 'A

let rec eq_arguments_aux (eq_A : 'A -> 'A -> bool) eq_expression a1 a2 : bool =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> eq_expression eq_A e1 e2 && eq_arguments_aux eq_A eq_expression a1 a2
  | (_       , _       ) -> false
  end

let rec eq_expression' eq_A e1 e2 : bool =
  let eq_arguments = eq_arguments_aux eq_A eq_expression in
  match (e1, e2) with
  | (Unary uop1 e1, Unary uop2 e2) ->
      eq_unaryOperator uop1 uop2 &&
      eq_expression eq_A e1 e2
  | (Binary e1_1 bop1 e2_1, Binary e1_2 bop2 e2_2) ->
      eq_expression eq_A e1_1 e1_2 &&
      eq_binaryOperator bop1 bop2 &&
      eq_expression eq_A e2_1 e2_2
  | (Assign e1_1 e2_1, Assign e1_2 e2_2) ->
      eq_expression eq_A e1_1 e1_2 &&
      eq_expression eq_A e2_1 e2_2
  | (CompoundAssign e1_1 aop1 e2_1, CompoundAssign e1_2 aop2 e2_2) ->
      eq_expression eq_A e1_1 e1_2 &&
      eq_arithmeticOperator aop1 aop2 &&
      eq_expression eq_A e2_1 e2_2
  | (Conditional e1_1 e2_1 e3_1, Conditional e1_2 e2_2 e3_2) ->
      eq_expression eq_A e1_1 e1_2 &&
      eq_expression eq_A e2_1 e2_2 &&
      eq_expression eq_A e3_1 e3_2
  | (Cast q1 t1 e1, Cast q2 t2 e2) ->
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2 &&
      eq_expression eq_A e1 e2
  | (Call e1 es1, Call e2 es2) ->
      eq_expression eq_A e1 e2 &&
      eq_arguments es1 es2
  | (Constant c1, Constant c2) ->
      eq_constant c1 c2
  | (Var v1, Var v2) ->
      eq_identifier v1 v2
  | (SizeOf q1 t1, SizeOf q2 t2) ->
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2
  | (AlignOf q1 t1, AlignOf q2 t2) ->
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2
  | (_, _) -> false
  end
and eq_expression eq_A e1 e2 : bool =
  match (e1, e2) with
  | (AnnotatedExpression a1 e1, AnnotatedExpression a2 e2) -> eq_A a1 a2 && eq_expression' eq_A e1 e2
  end

let eq_arguments eq_A a1 a2 =
  eq_arguments_aux eq_A eq_expression a1 a2

let rec equiv_arguments_aux equiv_expression (a1 : list (expression 'A1)) (a2 : list (expression 'A2)) : bool =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> equiv_expression e1 e2 && equiv_arguments_aux equiv_expression a1 a2
  | (_       , _       ) -> false
    end

let rec equiv_expression' (e1 : expression' 'A1) (e2 : expression' 'A2) : bool =
  let equiv_arguments = equiv_arguments_aux equiv_expression in
  match (e1, e2) with
  | (Unary uop1 e1, Unary uop2 e2) ->
      eq_unaryOperator uop1 uop2 &&
      equiv_expression e1 e2
  | (Binary e1_1 bop1 e2_1, Binary e1_2 bop2 e2_2) ->
      equiv_expression e1_1 e1_2 &&
      eq_binaryOperator bop1 bop2 &&
      equiv_expression e2_1 e2_2
  | (Assign e1_1 e2_1, Assign e1_2 e2_2) ->
      equiv_expression e1_1 e1_2 &&
      equiv_expression e2_1 e2_2
  | (CompoundAssign e1_1 aop1 e2_1, CompoundAssign e1_2 aop2 e2_2) ->
      equiv_expression e1_1 e1_2 &&
      eq_arithmeticOperator aop1 aop2 &&
      equiv_expression e2_1 e2_2
  | (Conditional e1_1 e2_1 e3_1, Conditional e1_2 e2_2 e3_2) ->
      equiv_expression e1_1 e1_2 &&
      equiv_expression e2_1 e2_2 &&
      equiv_expression e3_1 e3_2
  | (Cast q1 t1 e1, Cast q2 t2 e2) ->
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2 &&
      equiv_expression e1 e2
  | (Call e1 es1, Call e2 es2) ->
      equiv_expression e1 e2 &&
      equiv_arguments es1 es2
  | (Constant c1, Constant c2) ->
      eq_constant c1 c2
  | (Var v1, Var v2) ->
      eq_identifier v1 v2
  | (SizeOf q1 t1, SizeOf q2 t2) ->
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2
  | (AlignOf q1 t1, AlignOf q2 t2) ->
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2
  | (_, _) -> false
  end
and equiv_expression (e1 : expression 'A1) (e2 : expression 'A2) : bool =
  match (e1, e2) with
  | (AnnotatedExpression _ e1, AnnotatedExpression _ e2) -> equiv_expression' e1 e2
  end

let equiv_arguments (a1 : list (expression 'A1)) (a2 : list (expression 'A2)) =
  equiv_arguments_aux equiv_expression a1 a2

type bindings (*[name="b*"]*) = list (identifier * (qualifiers * ctype))

let eq_bindings : bindings -> bindings -> bool =
  eq_list (eq_pair eq_identifier (eq_pair eq_qualifiers eq_ctype))
 
type statement' 'A 'B [name="s*"] = 
  | Skip
  | Expression of expression 'B
  | Block of bindings * list (statement 'A 'B)
  | If of expression 'B * statement 'A 'B * statement 'A 'B
  | While of expression 'B * statement 'A 'B
  | Do of statement 'A 'B * expression 'B
  | Break
  | Continue
  | ReturnVoid
  | Return of expression 'B
  | Switch of expression 'B * statement 'A 'B
  | Case of integerConstant * statement 'A 'B
  | Default of statement 'A 'B
  | Label of identifier * statement 'A 'B
  | Goto of identifier
  | Declaration of list (identifier * expression 'B)
and statement 'A 'B [name="s*"] =
  | AnnotatedStatement of 'A * statement' 'A 'B

let eq_definition eq_A d1 d2 : bool =
  eq_pair eq_identifier (eq_expression eq_A) d1 d2

let eq_declaration eq_A ds1 ds2 : bool =
  eq_list (eq_definition eq_A) ds1 ds2

let equiv_definition (d1 : identifier * expression 'A1) (d2 : identifier * expression 'A2) : bool =
  equiv_pair eq_identifier equiv_expression d1 d2

let rec equiv_declaration (ds1 : list (identifier * expression 'A1)) (ds2 : list (identifier * expression 'A2)) : bool =
  match (ds1, ds2) with
  | ([]       , []       ) -> true
  | (d1 :: ds1, d2 :: ds2) -> equiv_definition d1 d2 && equiv_declaration ds1 ds2
  | (_        , _        ) -> false
  end

let rec eq_block_aux eq_A eq_B equiv_statement ss1 ss2 : bool =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement eq_A eq_B s1 s2 && eq_block_aux eq_A eq_B equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec eq_statement' eq_A eq_B s1 s2 : bool =
  let eq_block = eq_block_aux eq_A eq_B eq_statement in
  match (s1, s2) with
  | (Skip, Skip) -> true
  | (Expression e1, Expression e2) ->
      eq_expression eq_B e1 e2
  | (Block b1 ss1, Block b2 ss2) ->
      eq_bindings b1 b2 &&
      eq_block ss1 ss2
  | (If e1 s1_1 s2_1, If e2 s1_2 s2_2) ->
      eq_expression eq_B e1 e2 &&
      eq_statement eq_A eq_B s1_1 s1_2 &&
      eq_statement eq_A eq_B s2_1 s2_2  
  | (While e1 s1, While e2 s2) ->
      eq_expression eq_B e1 e2 &&
      eq_statement eq_A eq_B s1 s2
  | (Do s1 e1, Do s2 e2) ->
      eq_expression eq_B e1 e2 &&
      eq_statement eq_A eq_B s1 s2
  | (Break, Break) -> true
  | (Continue, Continue) -> true
  | (ReturnVoid, ReturnVoid) -> true
  | (Return e1, Return e2) ->
      eq_expression eq_B e1 e2
  | (Switch e1 s1, Switch e2 s2) ->
      eq_expression eq_B e1 e2 &&
      eq_statement eq_A eq_B s1 s2
  | (Case ic1 s1, Case ic2 s2) ->
      eq_integerConstant ic1 ic2 &&
      eq_statement eq_A eq_B s1 s2
  | (Default s1, Default s2) ->
      eq_statement eq_A eq_B s1 s2
  | (Label v1 s1, Label v2 s2) ->
      eq_identifier v1 v2 &&
      eq_statement eq_A eq_B s1 s2
  | (Goto v1, Goto v2) ->
      eq_identifier v1 v2
  | (Declaration d1, Declaration d2) ->
      eq_declaration eq_B d1 d2
  | (_, _) -> false
  end
and eq_statement eq_A eq_B s1 s2 : bool =
  match (s1, s2) with
  | (AnnotatedStatement a1 s1, AnnotatedStatement a2 s2) ->
      eq_A a1 a2 && eq_statement' eq_A eq_B s1 s2
  end

let eq_block eq_A eq_B ss1 ss2 = eq_block_aux eq_A eq_B eq_statement ss1 ss2

let rec equiv_block_aux equiv_statement (ss1 : list (statement 'A1 'B1)) (ss2 : list (statement 'A2 'B2)) : bool =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement s1 s2 && equiv_block_aux equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec equiv_statement' (s1 : statement' 'A1 'B1) (s2 : statement' 'A2 'B2) : bool =
  let equiv_block = equiv_block_aux equiv_statement in
  match (s1, s2) with
  | (Skip, Skip) -> true
  | (Expression e1, Expression e2) ->
      equiv_expression e1 e2
  | (Block b1 ss1, Block b2 ss2) ->
      eq_bindings b1 b2 &&
      equiv_block ss1 ss2
  | (If e1 s1_1 s2_1, If e2 s1_2 s2_2) ->
      equiv_expression e1 e2 &&
      equiv_statement s1_1 s1_2 &&
      equiv_statement s2_1 s2_2  
  | (While e1 s1, While e2 s2) ->
      equiv_expression e1 e2 &&
      equiv_statement s1 s2
  | (Do s1 e1, Do s2 e2) ->
      equiv_expression e1 e2 &&
      equiv_statement s1 s2
  | (Break, Break) -> true
  | (Continue, Continue) -> true
  | (ReturnVoid, ReturnVoid) -> true
  | (Return e1, Return e2) ->
      equiv_expression e1 e2
  | (Switch e1 s1, Switch e2 s2) ->
      equiv_expression e1 e2 &&
      equiv_statement s1 s2
  | (Case ic1 s1, Case ic2 s2) ->
      eq_integerConstant ic1 ic2 &&
      equiv_statement s1 s2
  | (Default s1, Default s2) ->
      equiv_statement s1 s2
  | (Label v1 s1, Label v2 s2) ->
      eq_identifier v1 v2 &&
      equiv_statement s1 s2
  | (Goto v1, Goto v2) ->
      eq_identifier v1 v2
  | (Declaration d1, Declaration d2) ->
      equiv_declaration d1 d2
  | (_, _) -> false
  end
and equiv_statement (s1 : statement 'A1 'B1) (s2 : statement 'A2 'B2) : bool =
  match (s1, s2) with
  | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
      equiv_statement' s1 s2
  end

let equiv_block (ss1 : list (statement 'A1 'B1)) (ss2 : list (statement 'A2 'B2)) = equiv_block_aux equiv_statement ss1 ss2

(* Currently unused.
let declaration = identifier * option storageDuration.
*)

type sigma 'A 'B = context identifier ((ctype * bindings) * statement 'A 'B)

let eq_sigma (eq_A : 'A -> 'A -> bool) (eq_B : 'B -> 'B -> bool) =
  eq_context eq_identifier (eq_pair (eq_pair eq_ctype eq_bindings) (eq_statement eq_A eq_B))

let equiv_sigma (S1 : sigma 'A1 'B1) (S2 : sigma 'A2 'B2) =
  equiv eq_identifier (fun _ -> equiv_pair (eq_pair eq_ctype eq_bindings) equiv_statement) S1 S2

let equiv_eq_sigma (eq_A : 'A -> 'A -> bool) (eq_B : 'B -> 'B -> bool) S1 S2 =
  equiv eq_identifier (fun _ -> eq_pair (eq_pair eq_ctype eq_bindings) (eq_statement eq_A eq_B)) S1 S2

type gamma = Context.context identifier (qualifiers * ctype)

let eq_gamma : gamma -> gamma -> bool =
  eq_context eq_identifier (eq_pair eq_qualifiers eq_ctype)

let equiv_gamma : gamma -> gamma -> bool =
  equiv eq_identifier (fun _ -> eq_pair eq_qualifiers eq_ctype)

let lookup (C : Context.context identifier 'B) = Context.lookup eq_identifier C
let mem v (C : Context.context identifier 'B) = Context.mem eq_identifier v C
let fresh v (C : Context.context identifier 'B) = Context.fresh eq_identifier v C
let fresh_bindings (bs : bindings) (C : Context.context identifier 'B) = Context.fresh_bindings eq_identifier bs C
let disjoint (C1: Context.context identifier 'B1) (C2: Context.context identifier 'B2) : bool = Context.disjoint eq_identifier C1 C2

let parameters_of_bindings : bindings -> list (qualifiers * ctype) = List.map snd

let type_from_sigma (f : (ctype * bindings) * statement 'A 'B) =
  Function (fst (fst f)) (parameters_of_bindings (snd (fst f)))

type program 'A 'B = identifier * sigma 'A 'B

let eq_program (eq_A : 'A -> 'A -> bool) (eq_B : 'B -> 'B -> bool) =
  eq_pair eq_identifier (eq_sigma eq_A eq_B)

let equiv_program (p1 : program 'A1 'B1) (p2 : program 'A2 'B2)  =
  equiv_pair eq_identifier equiv_sigma p1 p2

let equiv_eq_program (eq_A : 'A -> 'A -> bool) (eq_B : 'B -> 'B -> bool) =
  eq_pair eq_identifier (equiv_eq_sigma eq_A eq_B)
