open import Pervasives Common Context AilTypes AilSyntax
open import GenTypes Annotation OptionMonad

let rec equiv_annotation_arguments_aux (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') equiv_annotation_expression (a1 : list (expression 'A1)) (a2 : list (expression 'A2)) : maybe (list (expression 'A2')) =
    match (a1, a2) with
    | ([]      , []      ) -> Just []
    | (e1 :: a1, e2 :: a2) -> equiv_annotation_expression e1 e2 >>= fun e ->
                            equiv_annotation_arguments_aux A A' equiv_annotation_expression a1 a2 >>= fun a ->
                            Just (e :: a)
    | (_       , _       ) -> Nothing
    end

let rec equiv_annotation_expression' (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (e1 : expression' 'A1) (e2 : expression' 'A2) : maybe (expression' 'A2') =
  let equiv_annotation_arguments = equiv_annotation_arguments_aux A A' (equiv_annotation_expression A A') in
  match (e1, e2) with
  | (Unary uop1 e1, Unary uop2 e2) ->
      if eq_unaryOperator uop1 uop2 then
        equiv_annotation_expression A A' e1 e2 >>= fun e ->
        Just (Unary uop1 e)
      else
        Nothing
  | (Binary e1_1 bop1 e2_1, Binary e1_2 bop2 e2_2) ->
      if eq_binaryOperator bop1 bop2 then
        equiv_annotation_expression A A' e1_1 e1_2 >>= fun e1 ->
        equiv_annotation_expression A A' e2_1 e2_2 >>= fun e2 ->
        Just (Binary e1 bop1 e2)
      else
        Nothing
  | (Assign e1_1 e2_1, Assign e1_2 e2_2) ->
      equiv_annotation_expression A A' e1_1 e1_2 >>= fun e1 ->
      equiv_annotation_expression A A' e2_1 e2_2 >>= fun e2 ->
      Just (Assign e1 e2)
  | (CompoundAssign e1_1 aop1 e2_1, CompoundAssign e1_2 aop2 e2_2) ->
      if eq_arithmeticOperator aop1 aop2 then
        equiv_annotation_expression A A' e1_1 e1_2 >>= fun e1 ->
        equiv_annotation_expression A A' e2_1 e2_2 >>= fun e2 ->
        Just (CompoundAssign e1 aop1 e2)
      else
        Nothing
  | (Conditional e1_1 e2_1 e3_1, Conditional e1_2 e2_2 e3_2) ->
      equiv_annotation_expression A A' e1_1 e1_2 >>= fun e1 ->
      equiv_annotation_expression A A' e2_1 e2_2 >>= fun e2 ->
      equiv_annotation_expression A A' e3_1 e3_2 >>= fun e3 ->
      Just (Conditional e1 e2 e3)
  | (Cast q1 t1 e1, Cast q2 t2 e2) ->
      if eq_qualifiers q1 q2 && eq_ctype t1 t2 then
        equiv_annotation_expression A A' e1 e2 >>= fun e ->
        Just (Cast q1 t1 e)
      else
        Nothing
  | (Call e1 es1, Call e2 es2) ->
      equiv_annotation_expression A A' e1  e2  >>= fun e  ->
      equiv_annotation_arguments  es1 es2 >>= fun es ->
      Just (Call e es)
  | (Constant c1, Constant c2) ->
      if eq_constant c1 c2 then
        Just (Constant c1)
      else
        Nothing
  | (Var v1, Var v2) ->
      if eq_identifier v1 v2 then
        Just (Var v1)
      else
        Nothing
  | (SizeOf q1 t1, SizeOf q2 t2) ->
      if eq_qualifiers q1 q2 && eq_ctype t1 t2 then
        Just (SizeOf q1 t1)
      else
        Nothing
  | (AlignOf q1 t1, AlignOf q2 t2) ->
      if eq_qualifiers q1 q2 && eq_ctype t1 t2 then
        Just (AlignOf q1 t1)
      else
        Nothing
  | (_, _) -> Nothing
  end
and equiv_annotation_expression (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (e1 : expression 'A1) (e2 : expression 'A2) : maybe (expression 'A2') =
  match (e1, e2) with
  | (AnnotatedExpression a1 e1, AnnotatedExpression a2 e2) ->
      equiv_annotation_expression' A A' e1 e2 >>= fun e ->
      Just (AnnotatedExpression (A'.add_type (A.get_type a2) a1) e)
  end

let equiv_annotation_arguments (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (a1 : list (expression 'A1)) (a2 : list (expression 'A2)) : maybe (list (expression 'A2')) =
  equiv_annotation_arguments_aux A A' (equiv_annotation_expression A A') a1 a2

let equiv_annotation_definition (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (d1 : identifier * expression 'A1) (d2 : identifier * expression 'A2) : maybe (identifier * expression 'A2') =
  let (v1, e1) = d1 in
  let (v2, e2) = d2 in
  if eq_identifier v1 v2 then
    equiv_annotation_expression A A' e1 e2 >>= fun e ->
    Just (v1, e)
  else
    Nothing

let rec equiv_annotation_declaration (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (ds1 : list (identifier * expression 'A1)) (ds2 : list (identifier * expression 'A2)) : maybe (list (identifier * expression 'A2')) =
  match (ds1, ds2) with
  | ([]       , []       ) -> Just []
  | (d1 :: ds1, d2 :: ds2) -> equiv_annotation_definition  A A' d1  d2  >>= fun d  ->
                              equiv_annotation_declaration A A' ds1 ds2 >>= fun ds ->
                              Just (d :: ds)
  | (_        , _        ) -> Nothing
  end

let rec equiv_annotation_block_aux (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') equiv_annotation_statement (ss1 : list (statement 'B 'A1)) (ss2 : list (statement 'B 'A2)) : maybe (list (statement 'B 'A2')) =
    match (ss1, ss2) with
    | ([]       , []       ) -> Just []
    | (s1 :: ss1, s2 :: ss2) -> equiv_annotation_statement s1  s2  >>= fun s  ->
                                equiv_annotation_block_aux A A' equiv_annotation_statement ss1 ss2 >>= fun ss ->
                                Just (s :: ss)
    | (_        , _        ) -> Nothing
    end

let rec equiv_annotation_statement' (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (s1 : statement' 'B 'A1) (s2 : statement' 'B 'A2) : maybe (statement' 'B 'A2') =
  let equiv_annotation_block = equiv_annotation_block_aux A A' (equiv_annotation_statement A A') in
  match (s1, s2) with
  | (Skip, Skip) -> Just Skip
  | (Expression e1, Expression e2) ->
      equiv_annotation_expression A A' e1 e2 >>= fun e ->
      Just (Expression e)
  | (Block b1 ss1, Block b2 ss2) ->
      if eq_bindings b1 b2 then
        equiv_annotation_block ss1 ss2 >>= fun ss ->
        Just (Block b1 ss)
      else
        Nothing
  | (If e1 s1_1 s2_1, If e2 s1_2 s2_2) ->
      equiv_annotation_expression A A' e1   e2   >>= fun e  ->
      equiv_annotation_statement  A A' s1_1 s1_2 >>= fun s1 ->
      equiv_annotation_statement  A A' s2_1 s2_2 >>= fun s2 ->
      Just (If e s1 s2)
  | (While e1 s1, While e2 s2) ->
      equiv_annotation_expression A A' e1 e2 >>= fun e ->
      equiv_annotation_statement  A A' s1 s2 >>= fun s ->
      Just (While e s)
  | (Do s1 e1, Do s2 e2) ->
      equiv_annotation_statement  A A' s1 s2 >>= fun s ->
      equiv_annotation_expression A A' e1 e2 >>= fun e ->
      Just (Do s e)
  | (Break, Break) -> Just Break
  | (Continue, Continue) -> Just Continue
  | (ReturnVoid, ReturnVoid) -> Just ReturnVoid
  | (Return e1, Return e2) ->
      equiv_annotation_expression A A' e1 e2 >>= fun e ->
      Just (Return e)
  | (Switch e1 s1, Switch e2 s2) ->
      equiv_annotation_expression A A' e1 e2 >>= fun e ->
      equiv_annotation_statement  A A' s1 s2 >>= fun s ->
      Just (Switch e s)
  | (Case ic1 s1, Case ic2 s2) ->
      if eq_integerConstant ic1 ic2 then
        equiv_annotation_statement A A' s1 s2 >>= fun s ->
        Just (Case ic1 s)
      else
        Nothing
  | (Default s1, Default s2) ->
      equiv_annotation_statement A A' s1 s2 >>= fun s ->
      Just (Default s)
  | (Label v1 s1, Label v2 s2) ->
      if eq_identifier v1 v2 then
        equiv_annotation_statement A A' s1 s2 >>= fun s ->
        Just (Label v1 s)
      else
        Nothing
  | (Goto v1, Goto v2) ->
      if eq_identifier v1 v2 then
        Just (Goto v1)
      else
        Nothing
  | (Declaration ds1, Declaration ds2) ->
      equiv_annotation_declaration A A' ds1 ds2 >>= fun ds ->
      Just (Declaration ds)
  | (_, _) -> Nothing
  end
and equiv_annotation_statement (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (s1 : statement 'B 'A1) (s2 : statement 'B 'A2) : maybe (statement 'B 'A2') =
  match (s1, s2) with
  | (AnnotatedStatement b s1, AnnotatedStatement _ s2) ->
      equiv_annotation_statement' A A' s1 s2 >>= fun s ->
      Just (AnnotatedStatement b s)
  end

let equiv_annotation_block (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (ss1 : list (statement 'B 'A1)) (ss2 : list (statement 'B 'A2)) = equiv_annotation_block_aux A A' (equiv_annotation_statement A A') ss1 ss2

let equiv_annotation_function (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (p1 : (_ * _) * statement 'B 'A1) (p2 : (_ * _) * statement 'B 'A2) : maybe ((_ * _) * statement 'B 'A2') =
  let ((t1, bs1), s1) = p1 in
  let ((t2, bs2), s2) = p2 in
  if eq_ctype t1 t2 && eq_bindings  bs1 bs2 then
    equiv_annotation_statement A A' s1 s2 >>= fun s ->
    Just ((t1, bs1), s)
  else
    Nothing

let equiv_annotation_sigma_map (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (S1 : sigma 'B 'A1) v (p2 : (_ * _) * statement 'B 'A2) =
  AilSyntax.lookup S1 v >>= fun p1 -> equiv_annotation_function A A' p1 p2

let equiv_annotation_sigma (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (S1 : sigma 'B 'A1) (S2 : sigma 'B 'A2) : maybe (sigma 'B 'A2') =
  if equiv_sigma S1 S2 then
    mapP eq_identifier (equiv_annotation_sigma_map A A' S1) S2
  else
    Nothing

let equiv_annotation_program (A : annotation 'A1 'A2) (A' : annotation 'A1 'A2') (p1 : program 'B 'A1) (p2 : program 'B 'A2) =
  let (v1, S1) = p1 in
  let (v2, S2) = p2 in
  if eq_identifier v1 v2 then
    equiv_annotation_sigma A A' S1 S2 >>= fun S ->
    Just (v1, S)
  else
    Nothing
