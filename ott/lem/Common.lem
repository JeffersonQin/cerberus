open import Pervasives

val option_bool : forall 'A. maybe 'A -> ('A -> bool) -> bool
let option_bool =
  fun o f ->
    match o with
    | Just a  -> f a
    | Nothing -> false
    end

let rec eq_list (eq_A : 'A -> 'A -> bool) l1 l2 : bool =
    match (l1, l2) with
    | ([]      , []      ) -> true
    | (a1 :: l1, a2 :: l2) -> eq_A a1 a2 && eq_list eq_A l1 l2
    | (_       , _       ) -> false
    end

let equiv_pair (equiv_A : 'A1 -> 'A2 -> bool) (equiv_B : 'B1 -> 'B2 -> bool) : 'A1 * 'B1 -> 'A2 * 'B2 -> bool =
  fun p1 p2 -> 
    let (a1, b1) = p1 in
    let (a2, b2) = p2 in
    equiv_A a1 a2 && equiv_B b1 b2

let equiv_triple (equiv_A : 'A1 -> 'A2 -> bool) (equiv_B : 'B1 -> 'B2 -> bool) (equiv_C : 'C1 -> 'C2 -> bool) :
                 'A1 * 'B1 * 'C1 -> 'A2 * 'B2 * 'C2 -> bool =
  fun p1 p2 -> 
    let (a1, b1, c1) = p1 in
    let (a2, b2, c2) = p2 in
    equiv_A a1 a2 && equiv_B b1 b2 && equiv_C c1 c2

let eq_pair (eq_A : 'A -> 'A -> bool) (eq_B : 'B -> 'B -> bool) : 'A * 'B -> 'A * 'B -> bool =
  fun p1 p2 -> 
    let (a1, b1) = p1 in
    let (a2, b2) = p2 in
    eq_A a1 a2 && eq_B b1 b2


let eq_triple (eq_A : 'A -> 'A -> bool) (eq_B : 'B -> 'B -> bool) (eq_C : 'C -> 'C -> bool) :
    'A * 'B * 'C -> 'A * 'B * 'C -> bool =
  fun p1 p2 -> 
    let (a1, b1, c1) = p1 in
    let (a2, b2, c2) = p2 in
    eq_A a1 a2 && eq_B b1 b2 && eq_C c1 c2

let eq_option (eq_A : 'A -> 'A -> bool) : maybe 'A -> maybe 'A -> bool =
  fun o1 o2 -> 
    match (o1, o2) with
    | (Just a1, Just a2) -> eq_A a1 a2
    | (Nothing, Nothing) -> true
    | (_      , _      ) -> false
end

let equiv_option (equiv_A : 'A1 -> 'A2 -> bool) : maybe 'A1 -> maybe 'A2 -> bool =
  fun o1 o2 -> 
    match (o1, o2) with
    | (Just a1, Just a2) -> equiv_A a1 a2
    | (Nothing, Nothing) -> true
    | (_      , _      ) -> false
end


val eq_either: forall 'A 'B. ('A -> 'A -> bool) -> ('B -> 'B -> bool) -> either 'A 'B -> either 'A 'B -> bool
let eq_either eq_A eq_B e1 e2 =
  match (e1, e2) with
    | (Left  l1, Left  l2) -> eq_A l1 l2
    | (Right r1, Right r2) -> eq_B r1 r2
    | (_       , _       ) -> false
  end

val equiv_either: forall 'A1 'A2 'B1 'B2.
                  ('A1 -> 'A2 -> bool) -> ('B1 -> 'B2 -> bool) ->
                  either 'A1 'B1 -> either 'A2 'B2 ->
                  bool
let equiv_either equiv_A equiv_B e1 e2 =
  match (e1, e2) with
    | (Left  l1, Left  l2) -> equiv_A l1 l2
    | (Right r1, Right r2) -> equiv_B r1 r2
    | (_       , _       ) -> false
  end


let rec in_list (eq_A : 'A -> 'A -> bool) (a : 'A) (ls : list 'A) : bool =
  match ls with
  | []    -> false
  | x::xs -> eq_A x a || in_list eq_A a xs
  end

let rec all_list (dec : 'A -> bool) (l : list 'A) : bool =
    match l with
    | []    -> true
    | x::xs -> dec x && all_list dec xs
    end

let sub_list (eq_A : 'A -> 'A -> bool) l1 l2 =
  all_list (fun x -> in_list eq_A x l2) l1

let equiv_list (eq_A : 'A -> 'A -> bool) l1 l2 =
  sub_list eq_A l1 l2 && sub_list eq_A l2 l1
