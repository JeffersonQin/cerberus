import Implementation

(* Qualifiers functions *)
val combine_qualifiers: qualifiers -> qualifiers -> qualifiers
val sub_qualifiers: qualifiers -> qualifiers -> bool








(* Type classe for C types *)
class ( Ctype 'a ) 
  val is_void:    'a -> bool;
  val is_integer: 'a -> bool;
  val is_pointer: 'a -> bool;
  val is_bool:    'a -> bool;

val is_struct: ctype -> bool
val is_union: ctype -> bool

end


(* val is_unqualified: qualifiers -> bool *)
(* val is_unsigned: implementation -> integerType -> bool *)
(* val signed_type: integerType -> bool *)
(* val unsigned_type: integerType -> bool *)
(* val in_integer_range: implementation -> integer -> integerType -> bool *)
(* val in_min_integer_range: integer -> integerType -> bool *)
(* val le_integer_range: implementation -> integerType -> integerType -> bool *)
(* val eq_integer_rank_base: integerType -> integerType -> bool *)
(* val eq_integer_rank: integerType -> integerType -> bool *)
(* val lt_integer_rank_base: implementation -> integerType -> integerType -> bool *)
(* val lt_integer_rank_congruence: implementation -> integerType -> integerType -> bool *)
(* val lt_integer_rank: integerType -> integerType -> bool *)
(* val le_integer_rank: integerType -> integerType -> bool *)



(* TODO *)
val is_arithmetic: forall 'a. Ctype 'a => 'a -> bool
val is_scalar: forall 'a. Ctype 'a => 'a -> bool


val is_array: 'a -> bool
val is_function: 'a -> bool


val is_corresponding_unsigned: integerType -> integerType -> bool
val corresponding_unsigned: integerType -> maybe integerType
val make_corresponding_unsigned: integerType -> integerType
val is_integer_promotion: implementation -> integerType -> integerType -> bool
val integer_promotion: implementation -> integerType -> integerType
val is_promotion: forall 'a. Ctype 'a => implementation -> 'a -> 'a -> bool
val promotion: forall 'a. Ctype 'a => implementation -> 'a -> maybe 'a

val is_usual_arithmetic_promoted_integer: implementation -> integerType -> integerType -> integerType -> bool
val usual_arithmetic_promoted_integer: implementation -> integerType -> integerType -> integerType
val is_usual_arithmetic_integer: implementation ->  integerType ->  integerType ->  integerType -> bool

let usual_arithmetic_integer P it1 it2 : integerType =
  usual_arithmetic_promoted_integer P (integer_promotion P it1)
                                      (integer_promotion P it2)

let is_usual_arithmetic P t1 t2 t3 : bool =
  match (t1, t2, t3) with
  | (Basic (Integer it1), Basic (Integer it2), Basic (Integer it3)) -> is_usual_arithmetic_integer P it1 it2 it3
  | (_                  , _                  , _                  ) -> false
  end

let usual_arithmetic P t1 t2 : maybe ctype =
  match (t1, t2) with
  | (Basic (Integer it1), Basic (Integer it2)) -> Just (Basic (Integer (usual_arithmetic_integer P it1 it2)))
  | (_                  , _                  ) -> Nothing
  end

val is_object: forall 'a. Ctype 'a => 'a -> bool
val is_complete: forall 'a. Ctype 'a => 'a -> bool
val is_incomplete: forall 'a. Ctype 'a => 'a -> bool
val modifiable: forall 'a. Ctype 'a => qualifiers -> 'a -> bool
val real: forall 'a. Ctype 'a => 'a -> bool




val is_signed_integer_type: ctype -> bool
let is_signed_integer_type = function
  | Basic (Integer it) ->
      signed_type it
  | _ ->
      false
end

val is_unsigned_integer_type: ctype -> bool
let is_unsigned_integer_type = function
  | Basic (Integer it) ->
      unsigned_type it
  | _ ->
      false
end





(*
let rec ~{coq} compatible_params_aux compatible p1 p2 : bool =
  match (p1, p2) with
  | ([]           , []           ) -> true
  | ((_, t1) :: p1, (_, t2) :: p2) -> compatible t1 t2 && compatible_params_aux compatible p1 p2
  | (_            , _            ) -> false
  end
*)

(*
(* (§6.2.7) Compatible type *)
let rec ~{coq} compatible t1 t2 : bool =
  let compatible_params = compatible_params_aux compatible in
  match (t1, t2) with
  | (Void             , Void             ) -> true
  | (Basic bt1        , Basic bt2        ) -> eq_basicType bt1 bt2
  | (Array    t1 n1   , Array    t2 n2   ) -> compatible t1 t2 && n1 = n2
  | (Function t1 p1 b1, Function t2 p2 b2) -> compatible t1 t2 && compatible_params p1 p2 && b1 = b2
  | (Pointer  q1 t1   , Pointer  q2 t2   ) -> compatible t1 t2 && eq_qualifiers q1 q2
  | (_                , _                ) -> false
  end
*)

let ~{coq} compatible_params p1 p2 = compatible_params_aux compatible p1 p2

let rec ~{coq} is_composite_params_aux is_composite p1 p2 p3 : bool =
  match (p1, p2, p3) with
  | ([]           , []           , []            ) -> true
  | ((_, t1) :: p1, (_, t2) :: p2, (q3, t3) :: p3) -> is_unqualified q3 &&
                                                      is_composite t1 t2 t3 &&
                                                      is_composite_params_aux is_composite p1 p2 p3
  | (_            , _            , _             ) -> false
  end

let rec ~{coq} is_composite t1 t2 t3 : bool =
  let is_composite_params = is_composite_params_aux is_composite in
  match (t1, t2, t3) with
  | (Void            , Void            , Void            ) -> true
  | (Basic bt1       , Basic bt2       , Basic bt3       ) -> eq_basicType bt1 bt2 && eq_basicType bt1 bt3
  | (Array t1 n1     , Array t2 n2     , Array t3 n3     ) -> is_composite t1 t2 t3 && n1 = n2 && n1 = n3
  | (Function t1 p1 _, Function t2 p2 _, Function t3 p3 _) -> is_composite t1 t2 t3 && is_composite_params p1 p2 p3
  | (Pointer  q1 t1  , Pointer  q2 t2  , Pointer  q3 t3  ) -> is_composite t1 t2 t3 && eq_qualifiers q1 q2 && eq_qualifiers q1 q3
  | (_               , _               , _               ) -> false
  end

let ~{coq} is_composite_params p1 p2 p3 = is_composite_params_aux is_composite p1 p2 p3

let rec ~{coq} composite_params_aux composite p1 p2 : maybe (list (qualifiers * ctype))=
    match (p1, p2) with
    | ([]           , []           ) -> Just []
    | ((_, t1) :: p1, (_, t2) :: p2) -> match (composite t1 t2, composite_params_aux composite p1 p2) with
                                        | (Just t, Just p) -> Just ((no_qualifiers, t) :: p)
                                        | (_     , _     ) -> Nothing
                                        end
    | (_            , _            ) -> Nothing
    end

(* (§6.2.7#3) composite type *)
let rec ~{coq} composite t1 t2 : maybe ctype =
  let composite_params = composite_params_aux composite in
  match (t1, t2) with
  | (Void          , Void          ) -> Just Void
  | (Basic bt1     , Basic bt2     ) -> if eq_basicType bt1 bt2
                                          then Just (Basic bt1)
                                          else Nothing
  | (Array t1 n1   , Array t2 n2   ) -> if n1 = n2
                                          then Maybe.map (fun t -> Array t n1) (composite t1 t2)
                                          else Nothing
  | (Function t1 p1 b1, Function t2 p2 b2) ->
      match (composite t1 t2, composite_params p1 p2) with
      | (Just t, Just p) -> if b1 = b2 then Just (Function t p b1) else Nothing
      | (_     , _     ) -> Nothing
      end
  | (Pointer  q1 t1, Pointer  q2 t2) -> if eq_qualifiers q1 q2
                                          then Maybe.map (Pointer q1) (composite t1 t2)
                                          else Nothing
  | (_             , _             ) -> Nothing
  end

let ~{coq} composite_params p1 p2 = composite_params_aux composite p1 p2



(* following (§6.3.2.1)#3 *)
let array_coercion = function
  | Array    ty _ -> Pointer no_qualifiers ty
  | ty            -> ty
end

(* following (§6.3.2.1)#4 *)
let function_coercion = function
  | Function ty' qs b -> Pointer no_qualifiers (Function ty' qs b)
  | ty                -> ty
end

(* following (§6.3.2.1)#2 *)
let lvalue_convertible ty : bool =
  not (is_array ty) && is_complete ty

(* following (§6.3.2.1)#2 and #3 *)
let lvalue_coercion ty : errorM ctype =
  if lvalue_convertible ty then
    return ty
  else if is_array ty then
    return (array_coercion ty)
  else
    fail (TError_TODO 1)

(* following (§6.3.2.1)#3 and #4 *)
let rvalue_coercion ty : ctype =
  if is_array ty then
    array_coercion ty
  else if is_function ty then
    function_coercion ty
  else
    ty

let pointer_to_complete_object t : bool =
  match t with
  | Pointer _ t -> is_complete t
  | _           -> false
  end

let ~{coq} pointers_to_compatible_complete_objects t1 t2 : bool =
  match (t1, t2) with
  | (Pointer _ t1, Pointer _ t2) -> is_complete t1 && is_complete t2 && compatible t1 t2
  | (_           , _           ) -> false
  end  

let ~{coq} pointers_to_compatible_objects t1 t2 : bool =
  match (t1, t2) with
  | (Pointer _ t1, Pointer _ t2) -> is_object t1 && is_object t2 && compatible t1 t2
  | (_           , _           ) -> false
  end  

let pointer_to_object t : bool =
  match t with
  | Pointer _ t -> is_object t
  | _           -> false
  end

let pointer_to_void t : bool =
  match t with
  | Pointer _ Void -> true
  | _              -> false
  end

let ~{coq} pointers_to_compatible_types t1 t2 : bool =
  match (t1, t2) with
  | (Pointer _ t1, Pointer _ t2) -> compatible t1 t2
  | (_           , _           ) -> false
  end  










val variably_modified: forall 'a. Ctype 'a => 'a -> bool
