open import Pervasives Common Global Range AilTypes

(* TODO: temporary hack *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`


type binaryMode =
  | Two'sComplement
  | One'sComplement
  | SignPlusMagnitude

(* From 6.3.1.1
— The rank of a signed integer type shall be greater than the rank of any signed integer
type with less precision.
— The rank of long long int shall be greater than the rank of long int, which
shall be greater than the rank of int, which shall be greater than the rank of short
int, which shall be greater than the rank of signed char.

Suppose precision P (long long int) < precision P (long int). Then ltRank P
(long long int) (long int). But the second bullet tells us that ltRank P (long
int) (long long int). So P (long int) ≤ precision P (long long int).
*)

val min_precision: integerBaseType -> nat
let min_precision = function
  | Ichar         -> 8
  | Short         -> 16
  | Int_          -> 16
  | Long          -> 32
  | LongLong      -> 64
  (* TODO: check the following *)
  | Intptr_t      -> assert_false "Implementation.min_precision Intptr_t"
  | Intmax_t      -> assert_false "Implementation.min_precision Intmax_t"
  | Int8_t        -> 8
  | Int16_t       -> 16
  | Int32_t       -> 32
  | Int64_t       -> 64
  | Int_least8_t  -> 8
  | Int_least16_t -> 16
  | Int_least32_t -> 32
  | Int_least64_t -> 64
  | Int_fast8_t   -> 8
  | Int_fast16_t  -> 16
  | Int_fast32_t  -> 32
  | Int_fast64_t  -> 64
end

type implementation = <|
  binary_mode: binaryMode;
  signed:      integerType -> bool;
  precision:   integerType -> nat;
  size_t:      integerType;
  ptrdiff_t:   integerType;
|>

val make_implementation: binaryMode -> (integerType -> bool) -> (integerType -> nat) -> integerType -> integerType -> implementation
let make_implementation binary_mode signed precision size_t ptrdiff_t = <|
  binary_mode= binary_mode;
  signed=      signed;
  precision=   precision;
  size_t=      size_t;
  ptrdiff_t=   ptrdiff_t
|>

val integer_range: implementation -> integerType -> range
let integer_range P it =
  let prec = P.precision it in
  if P.signed it then
(*    let prec_minus_one = prec - 1 in *)
    match P.binary_mode with
(*
    | Two'sComplement   -> make_range (~(2 ** (prec - 1)))
                                      ((2 ** (prec - 1)) - 1)
    | One'sComplement   -> make_range (~((2 ** (prec - 1)) + 1))
                                      ((2 ** (prec - 1)) - 1)
    | SignPlusMagnitude -> make_range (~((2 ** (prec - 1)) + 1))
                                      ((2 ** (prec - 1)) - 1)
*)
    | Two'sComplement   -> make_range (~(2 ** prec))
                                      ((2 ** prec) - 1)
    | One'sComplement   -> make_range (~((2 ** prec)) + 1)
                                      ((2 ** prec) - 1)
    | SignPlusMagnitude -> make_range (~((2 ** prec)) + 1)
                                      ((2 ** prec) - 1)
    end
  else
    make_range 0 ((2 ** prec) - 1)

val min_range_unsigned: integerBaseType -> range
let min_range_unsigned ibt =
  let prec = min_precision ibt in
  make_range 0 ((2 ** prec) - 1)

val min_range_signed: integerBaseType -> range
let min_range_signed ibt =
  let prec = (min_precision ibt) - 1 in
  make_range ((~(2 ** (prec - 1))) + 1)
             ((2 ** (prec - 1)) - 1)

val min_integer_range: integerType -> range
let min_integer_range = function
  | Char         -> make_range 0 ((2 ** ((min_precision Ichar)- 1)) - 1)
  | Bool         -> make_range 0 1
  | Unsigned ibt -> min_range_unsigned ibt
  | Signed   ibt -> min_range_signed   ibt
  | Wchar_t      -> assert_false "Implementation.min_integer_range: Wchar_t"
  | Char16_t     -> assert_false "Implementation.min_integer_range: Char16_t"
  | Char32_t     -> assert_false "Implementation.min_integer_range: Char32_t"
  | Size_t       -> assert_false "Implementation.min_integer_range: Size_t"
  | Ptrdiff_t    -> assert_false "Implementation.min_integer_range: Ptrdiff_t"
end

val min_implementation_signed_char: implementation
let min_implementation_signed_char =
  make_implementation
    SignPlusMagnitude
    ( function
        | Char       -> true
	| Signed   _ -> true
        | Bool       -> false
	| Unsigned _ -> false
        | Wchar_t    -> assert_false "Implementation.min_implementation_signed_char: signedness of Wchar_t"
        | Char16_t   -> false
        | Char32_t   -> false
        | Size_t     -> false
        | Ptrdiff_t  -> true
      end
    )
    ( function
        | Char              -> 7
        | Bool              -> 1
        | Signed   Ichar    -> 7
        | Unsigned Ichar    -> 8
        | Signed   Short    -> 15
        | Unsigned Short    -> 16
        | Signed   Int_     -> 15
        | Unsigned Int_     -> 16
        | Signed   Long     -> 31
        | Unsigned Long     -> 32
        | Signed   LongLong -> 63
        | Unsigned LongLong -> 64

        | Signed Int8_t     -> 7
        | Signed Int16_t    -> 15
        | Signed Int32_t    -> 31
        | Signed Int64_t    -> 63
        | Unsigned Int8_t   -> 8
        | Unsigned Int16_t  -> 16
        | Unsigned Int32_t  -> 32
        | Unsigned Int64_t  -> 64
        
        | _ -> assert_false "Implementation.min_implementation_signed_char: precision on standard types"
      end
    )
    (Unsigned Long)
    (Signed   Long)

val min_implementation_unsigned_char: implementation
let min_implementation_unsigned_char =
  make_implementation
    SignPlusMagnitude
    ( function
        | Signed   _ -> true
        | Char       -> false
	| Bool       -> false
	| Unsigned _ -> false
        | Wchar_t    -> assert_false "Implementation.min_implementation_unsigned_char: signedness of Wchar_t"
        | Char16_t   -> false
        | Char32_t   -> false
        | Size_t     -> false
        | Ptrdiff_t  -> true
      end
    )
    ( function
        | Char              -> 8
        | Bool              -> 1
        | Signed   Ichar    -> 7
        | Unsigned Ichar    -> 8
        | Signed   Short    -> 15
        | Unsigned Short    -> 16
        | Signed   Int_     -> 15
        | Unsigned Int_     -> 16
        | Signed   Long     -> 31
        | Unsigned Long     -> 32
        | Signed   LongLong -> 63
        | Unsigned LongLong -> 64
        
        | _ -> assert_false "Implementation.min_implementation_unsigned_char: precision on standard types"
      end
    )
    (Unsigned Long)
    (Signed   Long)

