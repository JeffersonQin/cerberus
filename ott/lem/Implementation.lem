open Int

open Range
open AilTypes

type binaryMode =
  | Two'sComplement
  | One'sComplement
  | SignPlusMagnitude

(* From 6.3.1.1
— The rank of a signed integer type shall be greater than the rank of any signed integer
type with less precision.
— The rank of long long int shall be greater than the rank of long int, which
shall be greater than the rank of int, which shall be greater than the rank of short
int, which shall be greater than the rank of signed char.

Suppose precision P (long long int) < precision P (long int). Then ltRank P
(long long int) (long int). But the second bullet tells us that ltRank P (long
int) (long long int). So P (long int) ≤ precision P (long long int).
*)

let min_precision ibt : int =
  int (*TODO remove conversion or switch to nat in Coq development *) match ibt with
  | Ichar    -> 8
  | Short    -> 16
  | Int      -> 16
  | Long     -> 32
  | LongLong -> 64
  end

type implementation = <|
  binary_mode : binaryMode;
  signed : integerType -> bool;
  precision : integerType -> int;
  size_t : integerType;
  ptrdiff_t : integerType;
|>

let make_implementation binary_mode signed precision size_t ptrdiff_t = <|
  binary_mode = binary_mode;
  signed = signed;
  precision = precision;
  size_t = size_t;
  ptrdiff_t = ptrdiff_t
|>

let integer_range P it =
  let prec = P.precision it in
  if P.signed it then
    match P.binary_mode with
    | Two'sComplement   -> make_range (neg ((int 2)^^(prec - (int 1))))     ((int 2)^^(prec - (int 1)) - (int 1))
    | One'sComplement   -> make_range (neg ((int 2)^^(prec - (int 1))) + (int 1)) ((int 2)^^(prec - (int 1)) - (int 1))
    | SignPlusMagnitude -> make_range (neg ((int 2)^^(prec - (int 1))) + (int 1)) ((int 2)^^(prec - (int 1)) - (int 1))
    end
  else
    make_range (int 0) ((int 2)^^prec - (int 1))

let min_range_unsigned ibt =
  let prec = min_precision ibt in
  make_range (int 0) ((int 2)^^prec - (int 1))

let min_range_signed ibt =
  let prec = min_precision ibt - (int 1) in
  make_range (neg ((int 2)^^(prec - (int 1))) + (int 1)) ((int 2)^^(prec - (int 1)) - (int 1))

let min_integer_range it =
  match it with
  | Char         -> make_range (int 0) ((int 2) ^^ (min_precision Ichar - (int 1) - (int 1)) - (int 1))
  | Bool         -> make_range (int 0) (int 1)
  | Unsigned ibt -> min_range_unsigned ibt
  | Signed   ibt -> min_range_signed   ibt
  end

let min_implementation_signed_char : implementation =
  make_implementation
    SignPlusMagnitude
    ( fun it ->
        match it with
        | Char       -> true
	| Signed   _ -> true
        | Bool       -> false
	| Unsigned _ -> false
        end
    )
    ( fun it ->
        int match it with
        | Char -> 7
        | Bool -> 1
        | Signed   Ichar -> 7
        | Unsigned Ichar -> 8
        | Signed   Short -> 15
        | Unsigned Short -> 16
        | Signed   Int      -> 15
        | Unsigned Int      -> 16
        | Signed   Long     -> 31
        | Unsigned Long     -> 32
        | Signed   LongLong -> 63
        | Unsigned LongLong -> 64
        end
    )
    (Unsigned Long)
    (Signed   Long)

let min_implementation_unsigned_char : implementation =
  make_implementation
    SignPlusMagnitude
    ( fun it ->
        match it with
        | Signed   _ -> true
        | Char       -> false
	| Bool       -> false
	| Unsigned _ -> false
        end
    )
    ( fun it ->
        int match it with
        | Char -> 8
        | Bool -> 1
        | Signed   Ichar -> 7
        | Unsigned Ichar -> 8
        | Signed   Short -> 15
        | Unsigned Short -> 16
        | Signed   Int      -> 15
        | Unsigned Int      -> 16
        | Signed   Long     -> 31
        | Unsigned Long     -> 32
        | Signed   LongLong -> 63
        | Unsigned LongLong -> 64
        end
    )
    (Unsigned Long)
    (Signed   Long)

