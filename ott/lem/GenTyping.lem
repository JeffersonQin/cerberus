open import Pervasives Common AilSyntax AilTypes AilSyntaxAux AilWf TypingError
open import GenTypes GenTypesAux Annotation
open import Std

import ErrorMonad
module E = ErrorMonad

let inline (>>=) m f = E.bind m f
let inline (>>) m f = m >>= (fun _ -> f)


val pp_ail_ctype: forall 'a. 'a (* Ail.ctype *) -> string
declare ocaml target_rep function pp_ail_ctype = `Pp_ail.string_of_ail_ctype`

val pp_ail_expr: forall 'a. 'a (* Ail.expression_l *) -> string
declare ocaml target_rep function pp_ail_expr = `Pp_ail.string_of_ail_expr`


val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`

val output_string: string -> unit
declare ocaml target_rep function output_string = `Debug.output_string2`



(*
val annotate_rvalue_aux: forall 'A1 'A2.
                         annotation 'A1 'A2 -> (expression 'A1 -> E.t (expression 'A2)) ->
                         expression 'A1                                                 ->
                         E.t (expression 'A2 * genType)

val type_of_constant: integerConstant -> genIntegerType


val annotate_assignee_aux: forall 'A1 'A2.
                           (expression 'A1 -> E.t (expression 'A2 * genType)) ->
                           ctype -> expression 'A1 ->
                           E.t (expression 'A2)







val annotate_expression': forall 'A1 'A2 'B1 'B2.
                          annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma ->
                          expression' 'A1                              ->
                          E.t (expression' 'A2 * genTypeCategory)

val annotate_expression: forall 'A1 'A2 'B1 'B2.
                         annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma ->
                         expression 'A1                               ->
                         E.t (expression 'A2)

val annotate_rvalue: forall 'A1 'A2 'B1 'B2.
                     annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma ->
                     expression 'A1                               ->
                     E.t (expression 'A2 * genType)

val annotate_assignee: forall 'A1 'A2 'B1 'B2.
                       annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma ->
                       ctype -> expression 'A1                      ->
                       E.t (expression 'A2)

val annotate_arguments: forall 'A1 'A2 'B1 'B2.
                        annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma       ->
                        bool                                               ->
                        list (expression 'A1) -> list (qualifiers * ctype) ->
                        E.t (list (expression 'A2))

val annotate_block_aux: forall 'A1 'A2 'B.
                        annotation 'A1 'A2                           ->
                        (statement 'B 'A1 -> E.t (statement 'B 'A2)) ->
                        list (statement 'B 'A1)                      ->
                        E.t (list (statement 'B 'A2))

val annotate_definition: forall 'A1 'A2 'B1 'B2.
                         annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma ->
                         identifier * expression 'A1                  ->
                         E.t (identifier * expression 'A2)

val annotate_definitions: forall 'A1 'A2 'B1 'B2.
                          annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma ->
                          list (identifier * (expression 'A1))         ->
                          E.t (list (identifier * expression 'A2))

val annotate_statement': forall 'A1 'A2 'B1 'B2 'B.
                         annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma -> ctype ->
                         statement' 'B 'A1                                     ->
                         E.t (statement' 'B 'A2)

val annotate_statement: forall 'A1 'A2 'B1 'B2 'B.
                        annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma -> ctype ->
                        statement 'B 'A1                                      ->
                        E.t (statement 'B 'A2)

val annotate_block: forall 'A1 'A2 'B1 'B2 'B.
                    annotation 'A1 'A2 -> sigma 'B1 'B2 -> gamma -> ctype ->
                    list (statement 'B 'A1)                               ->
                    E.t (list (statement 'B 'A2))

val annotate_sigma: forall 'A1 'A2 'B.
                    annotation 'A1 'A2 -> sigma 'B 'A1 ->
                    E.t (sigma 'B 'A2)

val annotate_program: forall 'A1 'A2 'B.
                      annotation 'A1 'A2 -> program 'B 'A1 ->
                      E.t (program 'B 'A2)
*)


(* ============== *)

let annotate_rvalue_aux A annotate_expression e =
  annotate_expression e >>= fun e ->
  match type_of A e with
    | GenRValueType gty ->
        E.return (e, rvalue_coercion gty)
    | GenLValueType _ ty ->
        AilTypesAux.lvalue_coercion ty >>= fun ty' ->
        E.return (e, inject_type ty')
  end


(* TODO: check if something needs to done regarding the basis *)
let type_of_constant iCst =
  match iCst with
    | IntegerConstant n _ Nothing ->
        if AilTypesAux.in_min_integer_range n (Signed Int_) then
          Concrete (Signed Int_)
        else
          Unknown iCst
    | IntegerConstant n _ (Just U) ->
        if AilTypesAux.in_min_integer_range n (Unsigned Int_) then
          Concrete (Unsigned Int_)
        else
          Unknown iCst
    | IntegerConstant n _ (Just L) ->
        if AilTypesAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
        else
          Unknown iCst
    | IntegerConstant n _ (Just UL) ->
        if AilTypesAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else
          Unknown iCst
    | IntegerConstant _ _ (Just LL) ->
        Concrete (Signed LongLong)
    | IntegerConstant _ _ (Just ULL) ->
        Concrete (Unsigned LongLong)
  end


(* TODO: is only used once, could be inlined *)
val well_typed_assignment: ctype -> genType -> bool -> E.t bool
let well_typed_assignment ty1 gty2 null2 =
  (* §6.5.16.1#1, bullet 1 *)
  if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_arithmetic ty1 && GenTypesAux.is_arithmetic gty2 then
    let _ = output_string "[well_typed_assignment] OK: bullet 1" in
    E.return true
  
  (* §6.5.16.1#1, bullet 2 *)
  else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_struct_or_union ty1 then
    match (ty1, gty2) with
      | (Struct _ _, GenStruct id2 membrs2) ->
          (* TODO: a bit hackish to do it like that *)
          let _ = output_string "[well_typed_assignment] ??: bullet 2" in (* DEBUG *)
          E.return (AilTypesAux.compatible ty1 (Struct id2 membrs2))
      | _ ->
          assert_false "not possible"
    end
  
  else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_pointer ty1 then
    AilTypesAux.lvalue_conversion ty1 >>= fun conv_ty1 ->
    match (conv_ty1, gty2) with
      | (Pointer ref_qs1 ref_ty1, GenPointer ref_qs2 ref_ty2) ->
          (* §6.5.16.1#1, bullet 3 *)
          if AilTypesAux.compatible ref_ty1 ref_ty2 && AilTypesAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = output_string "[well_typed_assignment] OK: bullet 3" in (* DEBUG *)
            E.return true
          
          (* §6.5.16.1#1, bullet 4 *)
          else if (AilTypesAux.is_void ref_ty1 || AilTypesAux.is_void ref_ty2) &&
                  AilTypesAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = output_string "[well_typed_assignment] OK: bullet 4" in                     (* DEBUG *)
            let _ = output_string $ "qs1: " ^ (if ref_qs1.const    then "const "    else "") ^  (* DEBUG *)
                                              (if ref_qs1.restrict then "restrict " else "") ^  (* DEBUG *)
                                              (if ref_qs1.volatile then "volatile " else "") ^  (* DEBUG *)
                                              (if ref_qs1.atomic   then "atomic "   else "") in (* DEBUG *)
            let _ = output_string $ "qs2: " ^ (if ref_qs2.const    then "const "    else "") ^  (* DEBUG *)
                                              (if ref_qs2.restrict then "restrict " else "") ^  (* DEBUG *)
                                              (if ref_qs2.volatile then "volatile " else "") ^  (* DEBUG *)
                                              (if ref_qs2.atomic   then "atomic "   else "") in (* DEBUG *)
            E.return true
          
          (* §6.5.16.1#1, bullet 5 *)
          else if null2 then
            let _ = output_string "[well_typed_assignment] OK: bullet 5" in (* DEBUG *)
            E.return true
          
          else
            let _ = output_string "[well_typed_assignment] KO: is_pointer ty1 && gty2" in (* DEBUG *)
            E.return false
      | _ ->
          let _ = output_string "[well_typed_assignment] KO: is_pointer ty1" in (* DEBUG *)
          E.return false
    end
  
  (* §6.5.16.1#1, bullet 6 *)
  else if AilTypesAux.atomic_qualified_unqualified AilTypesAux.is_Bool ty1 && GenTypesAux.is_pointer gty2 then
    let _ = output_string "[well_typed_assignment] OK: bullet 6" in (* DEBUG *)
    E.return true
  
  else
    let _ = output_string "[well_typed_assignment] KO: the end" in (* DEBUG *)
    E.return false


(* STD §6.5.9#2 *)
val well_typed_equality: genType -> genType -> bool -> bool -> bool
let well_typed_equality gty1 gty2 is_null1 is_null2 =
     is_arithmetic gty1 && is_arithmetic gty2               (* STD §6.5.9#2, item 1 *)
  || are_pointers_to_compatible_types gty1 gty2             (* STD §6.5.9#2, item 2 *)
  || is_pointer_to_void gty1   && is_pointer_to_object gty2 (* STD §6.5.9#2, item 3 *)
  || is_pointer_to_object gty1 && is_pointer_to_void gty2   (* STD §6.5.9#2, item 3 *)
  || is_pointer gty1 && is_null2                            (* STD §6.5.9#2, item 4 *)
  || is_null1        && is_pointer gty2                     (* STD §6.5.9#2, item 4 *)


let well_typed_binary_arithmetic gt1 aop gt2 : bool =
  match aop with
    | Mul  -> is_arithmetic gt1 && is_arithmetic gt2
    | Div  -> is_arithmetic gt1 && is_arithmetic gt2
    | Mod  -> is_integer    gt1 && is_integer    gt2
    | Add  -> is_arithmetic gt1 && is_arithmetic gt2
    | Sub  -> is_arithmetic gt1 && is_arithmetic gt2
    | Shl  -> is_integer    gt1 && is_integer    gt2
    | Shr  -> is_integer    gt1 && is_integer    gt2
    | Band -> is_integer    gt1 && is_integer    gt2
    | Bxor -> is_integer    gt1 && is_integer    gt2
    | Bor  -> is_integer    gt1 && is_integer    gt2
  end


val combine_qualifiers_left: genType -> genType -> genType
let combine_qualifiers_left gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 ty1, GenPointer qs2 _) ->
        GenPointer (AilTypesAux.combine_qualifiers qs1 qs2) ty1
    | (GenPointer _  _ , _) ->
        gty1
    | _ ->
        gty1
  end


val combine_qualifiers_right: genType -> genType -> genType
let combine_qualifiers_right gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 _, GenPointer qs2 ty2) ->
        GenPointer (AilTypesAux.combine_qualifiers qs1 qs2) ty2
    | (_, GenPointer _ _) ->
        gty2
    | _ ->
        gty2
  end


val well_typed_conditional: genType -> genType -> genType -> bool -> bool -> E.t genTypeCategory
let well_typed_conditional gty1 gty2 gty3 is_null2 is_null3 =
  if is_scalar gty1 then
    if is_arithmetic gty2 && is_arithmetic gty3 then
      match usual_arithmetic gty2 gty3 with
        | Just gty ->
            E.return (GenRValueType gty)
        | Nothing ->
            E.fail Loc.unknown (TError_TODO 8)
      end
    
    else match composite_pointer gty2 gty3 with
      | Just gty ->
          E.return (GenRValueType gty)
      | Nothing ->
          if void gty2 && void gty3 then
            E.return (GenRValueType GenVoid)
          else if is_pointer gty2 && is_null3 then
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else if is_pointer gty3 && is_null2 then
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty2 && is_pointer_to_void gty3 then
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty3 && is_pointer_to_void gty2 then
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else E.fail Loc.unknown (TError_TODO 9)
    end
  else
    E.fail Loc.unknown (TError_TODO 10)


val annotate_assignee_aux: forall 'A1 'A2. (expression 'A1 -> E.t (expression 'A2 * genType)) -> ctype -> expression 'A1 -> E.t (expression 'A2)
let annotate_assignee_aux annotate_rvalue ty1 e2 =
  annotate_rvalue e2                                           >>= fun (e2, gty2) ->
  well_typed_assignment ty1 gty2 (is_null_pointer_constant e2) >>= function
    | true ->
        E.return e2
    | false ->
        E.fail Loc.unknown (TError "§6.5.16.1#1")
  end

val annotate_arguments_aux: forall 'A1 'A2.
                            annotation 'A1 'A2                                ->
                            (expression 'A1 -> E.t (expression 'A2))          ->
                            (ctype -> expression 'A1 -> E.t (expression 'A2)) ->
                            bool                                              ->
                            list (expression 'A1)                             ->
                            list (qualifiers * ctype)                         ->
                            E.t (list (expression 'A2))



(* let rec annotate_arguments_aux (A : annotation 'A1 'A2) (annotate_assignee : ctype -> expression 'A1 -> E.t (expression 'A2)) es (p : list (qualifiers * _)) : E.t (list (expression 'A2)) = *)
let rec annotate_arguments_aux A annotate_expression annotate_assignee is_variadic es p =
  match (es, p) with
    | ([], []) ->
        E.return []
    | ([], [(_, Void)]) ->
        E.return []
    | (e :: es, (_, ty1) :: p) ->
        annotate_assignee (AilTypesAux.rvalue_coercion ty1) e                            >>= fun e  ->
        annotate_arguments_aux A annotate_expression annotate_assignee is_variadic es p >>= fun es ->
        E.return (e :: es)
    | (_, []) ->
        (* This case must correspond to a call to a variadic function *)
        if not is_variadic then
          E.fail Loc.unknown (TError_TODO 68)
        else
          (* following (§6.5.2.2#7) *)
          (* TODO: check *)
          E.mapM annotate_expression es
    | (_, _) ->
        E.fail Loc.unknown (TError_TODO 12)
  end
















let annotate_stringLiteral (pref_opt, strs) =
  let elem_ty = match pref_opt with
                  | Nothing     -> Basic (Integer Char)                 (* STD §6.4.5#6 sentence 3 *)
                  | Just Enc_u8 -> Basic (Integer Char)                 (* STD §6.4.5#6 sentence 4 *)
                  | Just Enc_u  -> char16_t                             (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_U  -> char32_t                             (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_L  -> Basic (Integer (IBuiltin "wchar_t")) (* STD §6.4.5#6 sentence 5 *)
                end in

(* TODO: check the type *)
  E.return (AilEstr (pref_opt, strs),
          GenRValueType (GenArray elem_ty (Just $ integerFromNatural (naturalFromNat (List.length strs + 1))))
         )




let rec annotate_constant cst =
  match cst with
    | ConstantInteger ic ->
        E.return (ConstantInteger ic, GenRValueType (GenBasic (GenInteger (type_of_constant ic))))
    | ConstantCharacter cc ->
        (* TODO: §6.4.4.4#9 *)
        match fst cc with
          | Nothing ->
              (* §6.4.4.4#10 *)
              E.return (ConstantCharacter cc, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
          | Just Pref_L ->
              (* §6.4.4.4#11 *)
              E.return (ConstantCharacter cc, GenRValueType (GenBasic (GenInteger (Concrete (IBuiltin "wchar_t")))))
          | Just Pref_u ->
              (* §6.4.4.4#11 *)
              E.return (ConstantCharacter cc, GenRValueType genChar16_t)
          | Just Pref_U ->
              (* §6.4.4.4#11 *)
              E.return (ConstantCharacter cc, GenRValueType genChar32_t)
        end
    
    | ConstantArray csts ->
        E.mapM annotate_constant csts >>= fun a_csts ->
        (* TODO: this is probably too strong *)
        match a_csts with
          | [] ->
              E.fail Loc.unknown (TError "empty array constant")
          | (_, genTy)::a_csts' ->
              if List.all (fun (_, genTy') -> genTy = genTy') a_csts' then
                E.return (ConstantArray (List.map fst a_csts),
                          GenRValueType (GenArray (* TODO *) Void (Just $ integerFromNat (List.length a_csts))))
              else
                E.fail Loc.unknown (TError "array constant elements don't all have the same type")
        end
    | ConstantIndeterminate _ ->
        assert_false "WIP typing: ConstantIndeterminate"
    | ConstantNull ->
        assert_false "WIP typing: ConstantNull"
  end


(* TODO: temporary *)
val     are_all_eq: forall 'a. Eq 'a => list 'a -> bool
let rec are_all_eq xs =
  match xs with
    | [] ->
        true
    | [x] ->
        true
    | x::y::xs' ->
        x=y && are_all_eq (y::xs')
  end

let rec annotate_expression' A S G e =
  let annotate_rvalue    = annotate_rvalue_aux A (annotate_expression A S G)                      in
  let annotate_assignee  = annotate_assignee_aux annotate_rvalue                                  in
  let annotate_arguments = annotate_arguments_aux A (annotate_expression A S G) annotate_assignee in
  match e with
    | AilEarray es ->
        (* TODO: I have pretty much no idea what I'm doing *)
        E.mapM annotate_rvalue es >>= fun xs ->
        (* TODO: I guess the equality should be relaxed to compatibility *)
        if are_all_eq (List.map snd xs) then
          match xs with
            | (_, gty)::_ ->
                (* TODO !!!! *)
                E.return (AilEarray $ List.map fst xs, GenRValueType (GenArray (Basic (Integer Char)) (Just (integerFromNat $ List.length xs))))
(*
                E.return (AilEarray $ List.map fst xs, GenRValueType (GenArray gty (Just (integerFromNat $ List.length xs))))
*)
          end
        else
          E.fail Loc.unknown (TError "TODO[msg]: failed to type an array constant")
    
    | AilEbuiltin str ->
        (* TODO: check *)
        let ity = match str with
          | "INT8_MIN" ->
              Signed Int_
          | "INT16_MIN" ->
              Signed Int_
          | "INT32_MIN" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MIN" ->
              Signed Long
          | "INT8_MAX" ->
              Signed Int_
          | "INT16_MAX" ->
              Signed Int_
          | "INT32_MAX" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MAX" ->
              Signed Long
          | "UINT8_MAX" ->
              Unsigned Int_
          | "UINT16_MAX" ->
              Unsigned Int_
          | "UINT32_MAX" ->
              Unsigned Int_ (* TODO: this might not fit in a signed int ... *)
          | "UINT64_MAX" ->
              Unsigned Long
          | _ ->
              assert_false ("WIP typing, AilEbuiltin: " ^ str)
        end in
        E.return (AilEbuiltin str, GenRValueType (GenBasic (GenInteger (Concrete ity))))
    
    | AilEident v ->
        match (Context.lookup identifierEqual G v, Context.lookup identifierEqual S.declarations v) with
          | (Just (qs, ty), Nothing) ->
              E.return (AilEident v, GenLValueType qs ty)
          | (Nothing, Just (Decl_object _ qs ty)) ->
              E.return (AilEident v, GenLValueType qs ty)
          | (Nothing, Just (Decl_function ret_ty bs is_variadic _ (* is_inline *) _ (* is_Noreturn *))) ->
              (* TODO: is_inline, is_Noreturn *)
              E.return (AilEident v, GenRValueType (inject_type (Function ret_ty bs is_variadic)))
          | _ ->
              E.fail Loc.unknown (TError_TODO 13)
        end
(* TODO(clean)
        tryM (lookup G v)
          (* block variable *)
          (fun (qs, ty) -> E.return (Var v, GenLValueType qs ty))
          (lookup S v >>= function
            | Right (qs, ty, _) ->
                (* global variable *)
                E.return (Var v, GenLValueType qs ty)
            | Left p ->
                (* function name *)
                E.return (Var v, GenRValueType (inject_type (type_from_sigma p)))
          end)
*)

(*
OLD(sigma_declaration)

        match (lookup G v, sigma_lookup S v) with
          | (Just (qs, ty), Nothing) ->
              E.return (AilEident v, GenLValueType qs ty)
          | (Nothing, Just (SDecl_global _ (qs, ty, _))) ->
              (* global variable *)
              E.return (AilEident v, GenLValueType qs ty)
          | (Nothing, Just (SDecl_fun _ fdecl)) ->
              (* function name *)
              E.return (AilEident v,
                      GenRValueType (inject_type (type_from_sigma ((fdecl.fun_return_ty, fdecl.fun_bindings, fdecl.fun_is_variadic), fdecl.fun_body))))
          | (_, _) ->
              E.fail Loc.unknown (TError_TODO 13)
        end
*)
(* (OLD)
      match (lookup G v, lookup S v) with
      | (Just (q, t), Nothing) -> Just (Var v, GenLValueType q t)
      | (Nothing    , Just p ) -> Just (Var v, GenRValueType (inject_type (type_from_sigma p)))
      | (_          , _      ) -> Nothing
      end
*)
    | AilEbinary e1 Comma e2 ->
        (* STD §6.5.17#3, sentence 3 *)
        annotate_rvalue e1 >>= fun (e1', _  ) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        E.return (AilEbinary e1' Comma e2', GenRValueType gty2)
    
    | AilEunary Address e ->
        annotate_expression A S G e >>= fun e ->
        match type_of A e with
          | GenLValueType qs ty ->
              E.return (AilEunary Address e, GenRValueType (GenPointer qs ty))
          | GenRValueType (GenFunction ty p b) ->
              E.return (AilEunary Address e, GenRValueType (GenPointer no_qualifiers (Function ty p b)))
          | _ ->
              E.fail Loc.unknown (TError_TODO 14)
        end
    
    | AilEunary (Plus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        annotate_rvalue e >>= fun (e', gty) ->
        if is_arithmetic gty then
          match promotion gty with
            | Nothing ->
                assert_false "promotion failed on an arithmetic genType"
            | Just gty' ->
                E.return (AilEunary uop e', GenRValueType gty')
          end
        else
          E.fail Loc.unknown (TError "§6.5.3.3#1, sentence 1")
    
    | AilEunary (Minus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        annotate_rvalue e >>= fun (e', gty) ->
        if is_arithmetic gty then
          match promotion gty with
            | Nothing ->
                assert_false "promotion failed on an arithmetic genType"
            | Just gty' ->
                E.return (AilEunary uop e', GenRValueType gty')
          end
        else
          E.fail Loc.unknown (TError "§6.5.3.3#1, sentence 1")
    
    | AilEunary Bnot e ->
        (* STD §6.5.3.3#1, sentence 2 *)
        annotate_rvalue e >>= fun (e', gty) ->
        if is_integer gty then
          match promotion gty with
            | Nothing ->
                assert_false "promotion failed on an arithmetic genType"
            | Just gty' ->
                E.return (AilEunary Bnot e', GenRValueType gty')
          end
        else
          E.fail Loc.unknown (TError "§6.5.3.3#1, sentence 2")
    
    | AilEunary Indirection e ->
        annotate_rvalue e >>= fun (e, gty) ->
        match gty with
          | GenPointer qs (Function ty p b) ->
              if AilTypesAux.is_unqualified qs
              then E.return (AilEunary Indirection e, GenRValueType (GenPointer qs (Function ty p b)))
              else E.fail Loc.unknown (TError_TODO 18)
          | GenPointer qs ty ->
              if AilTypesAux.is_complete ty && AilTypesAux.is_object ty
              then E.return (AilEunary Indirection e, GenLValueType qs ty)
              else E.fail Loc.unknown (TError_TODO 19)
          | _ ->
              E.fail Loc.unknown (TError_TODO 20)
        end
    | AilEunary (PostfixIncr as uop) e ->
        annotate_expression A S G e >>= fun e ->
        match type_of A e with
          | GenLValueType qs' ty' ->
              AilTypesAux.lvalue_coercion ty' >>= fun ty ->
              if AilTypesAux.modifiable qs' ty' && (AilTypesAux.real ty' || AilTypesAux.is_pointer ty')
              then E.return (AilEunary uop e, GenRValueType (inject_type ty))
              else E.fail Loc.unknown (TError_TODO 21)
          | _ -> E.fail Loc.unknown (TError_TODO 22)
        end
    | AilEunary (PostfixDecr as uop) e ->
        annotate_expression A S G e >>= fun e ->
        match type_of A e with
          | GenLValueType qs' ty' ->
              AilTypesAux.lvalue_coercion ty' >>= fun ty ->
              if AilTypesAux.modifiable qs' ty' && (AilTypesAux.real ty' || AilTypesAux.is_pointer ty')
              then E.return (AilEunary uop e, GenRValueType (inject_type ty))
              else E.fail Loc.unknown (TError_TODO 23)
          | _ -> E.fail Loc.unknown (TError_TODO 24)
        end
    | AilEcall e es ->
        annotate_rvalue e >>= fun (e, gty) ->
(* _STD "§6.5.2.2#1" $ *)
        match gty with
          | GenPointer qs (Function ty p is_variadic) ->
              if AilTypesAux.is_unqualified qs then
                annotate_arguments is_variadic es p >>= fun es ->
                E.return (AilEcall e es, GenRValueType (inject_type ty))
              else E.fail Loc.unknown (TError_TODO 25)
          | _ ->
              E.fail Loc.unknown (TError_TODO 26)
        end
    
    | AilEgeneric (* e gas *) _ _ ->
        E.fail Loc.unknown (TError "WIP")
(*
        annotate_expression A S G e                     >>= fun e'   ->
        E.mapM (annotate_generic_association A S G) gas >>= fun gas' ->
        
        let ty_e' = match interpret_genTypeCategory (type_of A e') with
          | LValueType _ ty ->
              ty  KKK
          | RValueType ty ->
              ty
        end in
        
        E.foldM (fun (saw_compatible, saw_default, prev_gas) ga ->
          match ga with
            | AilGAtype ty _ ->
                if List.any (function
                               | AilGAtype ty _ -> AilTypesAux.compatible ty_e' ty
                               | _ -> false
                            end) prev_gas then
                  E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 3")
                
                else if AilTypesAux.compatible ty_e' ty then
                  if saw_compatible then
                    E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 4")
                  else
                    E.return (true, saw_default, ga :: prev_gas)
                else
                  E.return (saw_compatible, saw_default, ga :: prev_gas)
            | AilGAdefault _ ->
                if saw_default then
                  E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 1")
                else
                  E.return (saw_compatible, true, prev_gas)
          end
        ) (false, false, []) gas' >>= fun (saw_compatible, saw_default, _) ->
        
        if not saw_default && not saw_compatible then
          E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 5")
        else
          E.return (AilEgeneric e' gas')
*)
  
  (* TODO: check with J *)
(*
TODO
  | AilEmemberof e x ->
      annotate_rvalue e >>= fun (a_e, gt) ->
      match gt with
        | GenStruct tag_opt members ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#1")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  assert_false "WIP"
            end
        | GenUnion tag_opt members ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#1")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  assert_false "WIP"
            end
        | _ ->
            E.fail Loc.unknown (TError "§6.5.2.3#1")
      end

  (* TODO: check with J *)
  | AilEmemberofptr e x ->
      annotate_rvalue e >>= fun (a_e, gt) ->
      match gt with
        | GenPointer _ (Struct members) ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#2")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  assert_false "WIP"
            end
        | GenPointer _ (Union  members) ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#2")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  assert_false "WIP"
            end
        | _ ->
            E.fail Loc.unknown (TError "§6.5.2.3#2")
      end
*)

  | AilEmemberof _ _ ->
      E.fail Loc.unknown (TError "WIP: memberof")
  | AilEmemberofptr _ _ ->
      E.fail Loc.unknown (TError "WIP: memberofptr")

  | AilEassign e1 e2 ->
      annotate_expression A S G e1 >>= fun a_e1 ->
      match type_of A a_e1 with
        | GenLValueType qs1 ty1 ->
            if AilTypesAux.modifiable qs1 ty1 then
              let ty = AilTypesAux.rvalue_coercion ty1 in
              annotate_assignee ty e2 >>= fun a_e2 -> 
              E.return (AilEassign a_e1 a_e2, GenRValueType (inject_type ty))
            else
              E.fail Loc.unknown (TError "§6.5.16#2")
        | _ ->
            E.fail Loc.unknown (TError_TODO 28)
      end
    
    | AilEbinary e1 (Arithmetic (Mul  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2
          then match usual_arithmetic gt1 gt2 with
                 | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
                 | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
               end
          else E.fail Loc.unknown (TError_TODO 29)
    | AilEbinary e1 (Arithmetic (Div  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2
          then match usual_arithmetic gt1 gt2 with
                 | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
                 | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
               end
          else E.fail Loc.unknown (TError_TODO 30)
    | AilEbinary e1 (Arithmetic (Mod  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2
          then match usual_arithmetic gt1 gt2 with
                 | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
                 | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
               end
          else E.fail Loc.unknown (TError_TODO 31)
    | AilEbinary e1 (Arithmetic (Band as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2
          then match usual_arithmetic gt1 gt2 with
                 | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
                 | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
               end
          else E.fail Loc.unknown (TError_TODO 32)
    | AilEbinary e1 (Arithmetic (Bxor  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2
          then match usual_arithmetic gt1 gt2 with
                 | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
                 | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
               end
          else E.fail Loc.unknown (TError_TODO 33)
    | AilEbinary e1 (Arithmetic (Bor  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2
          then match usual_arithmetic gt1 gt2 with
                 | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
                 | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
               end
          else E.fail Loc.unknown (TError_TODO 34)
    | AilEbinary e1 (Arithmetic (Shl  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2 then
          match promotion gt1 with
            | Nothing -> assert_false "promotion failed on well typed binary arithmetic."
            | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
          end
        else E.fail Loc.unknown (TError_TODO 35)
    | AilEbinary e1 (Arithmetic (Shr  as aop)) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if well_typed_binary_arithmetic gt1 aop gt2 then
          match promotion gt1 with
            | Nothing -> assert_false "promotion failed on well typed binary arithmetic."
            | Just gt -> E.return (AilEbinary e1 (Arithmetic aop) e2, GenRValueType gt)
          end
        else E.fail Loc.unknown (TError_TODO 36)
    | AilEbinary e1 (Arithmetic Add) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
_STD "§6.5.2.1#1" $
        if is_pointer_to_complete_object gt1 && is_integer gt2 then
          E.return (AilEbinary e1 (Arithmetic Add) e2, GenRValueType gt1)
        else if is_pointer_to_complete_object gt2 && is_integer gt1 then
          E.return (AilEbinary e1 (Arithmetic Add) e2, GenRValueType gt2)
        else if well_typed_binary_arithmetic gt1 Add gt2 then
          match usual_arithmetic gt1 gt2 with
            | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
            | Just gt -> E.return (AilEbinary e1 (Arithmetic Add) e2, GenRValueType gt)
          end
        else E.fail Loc.unknown (TError_TODO 37)
    | AilEbinary e1 (Arithmetic Sub) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if are_pointers_to_compatible_complete_objects gt1 gt2 then
          E.return (AilEbinary e1 (Arithmetic Sub) e2, GenRValueType (GenBasic (GenInteger PtrdiffT)))
        else if is_pointer_to_complete_object gt1 && is_integer gt2 then
          E.return (AilEbinary e1 (Arithmetic Sub) e2, GenRValueType gt1)
        else if well_typed_binary_arithmetic gt1 Sub gt2 then
          match usual_arithmetic gt1 gt2 with
            | Nothing -> assert_false "usual_arithmetic failed on two valid genTypes."
            | Just gt -> E.return (AilEbinary e1 (Arithmetic Sub) e2, GenRValueType gt)
          end
        else E.fail Loc.unknown (TError_TODO 38)
    | AilEbinary e1 (And as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if is_scalar gt1 && is_scalar gt2
        then E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else E.fail Loc.unknown (TError_TODO 39)
    | AilEbinary e1 (Or  as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if is_scalar gt1 && is_scalar gt2
        then E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else E.fail Loc.unknown (TError_TODO 40)
    | AilEbinary e1 (Lt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if are_pointers_to_compatible_objects gt1 gt2 then
          E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if real gt1 && real gt2 then
          E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else E.fail Loc.unknown (TError_TODO 41)
    | AilEbinary e1 (Gt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1, gt1) ->
        annotate_rvalue e2 >>= fun (e2, gt2) ->
        if are_pointers_to_compatible_objects gt1 gt2 then
          E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if real gt1 && real gt2 then
          E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else E.fail Loc.unknown (TError_TODO 42)
  | AilEbinary e1 (Le as bop) e2 ->
      annotate_rvalue e1 >>= fun (e1, gt1) ->
      annotate_rvalue e2 >>= fun (e2, gt2) ->
      if are_pointers_to_compatible_objects gt1 gt2 then
        E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
      else if real gt1 && real gt2 then
        E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
      else E.fail Loc.unknown (TError_TODO 43)
  | AilEbinary e1 (Ge as bop) e2 ->
      annotate_rvalue e1 >>= fun (e1, gt1) ->
      annotate_rvalue e2 >>= fun (e2, gt2) ->
      if are_pointers_to_compatible_objects gt1 gt2 then
        E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
      else if real gt1 && real gt2 then
        E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
      else E.fail Loc.unknown (TError_TODO 44)
  
  | AilEbinary e1 (Eq as bop) e2 ->
      (* STD §6.5.9#2 *)
      annotate_rvalue e1 >>= fun (e1, gt1) ->
      annotate_rvalue e2 >>= fun (e2, gt2) ->
      if well_typed_equality gt1 gt2 (is_null_pointer_constant e1) (is_null_pointer_constant e2) then
        E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
      else
        E.fail Loc.unknown (TError "§6.5.9#2")
  
  | AilEbinary e1 (Ne as bop) e2 ->
      annotate_rvalue e1 >>= fun (e1, gt1) ->
      annotate_rvalue e2 >>= fun (e2, gt2) ->
      if well_typed_equality gt1 gt2 (is_null_pointer_constant e1) (is_null_pointer_constant e2)
        then E.return (AilEbinary e1 bop e2, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else E.fail Loc.unknown (TError_TODO 46)
  | AilEsizeof qs ty ->
      wf_lvalue qs ty >>
      if not (AilTypesAux.is_function ty) && not (AilTypesAux.is_incomplete ty) then
        E.return (AilEsizeof qs ty, GenRValueType (GenBasic (GenInteger (SizeT))))
      else
        E.fail Loc.unknown (TError "§6.5.3.4#1, sentence 1")
  | AilEalignof qs ty ->
      wf_lvalue qs ty >>
      if not (AilTypesAux.is_function ty) && not (AilTypesAux.is_incomplete ty) then
        E.return (AilEalignof qs ty, GenRValueType (GenBasic (GenInteger (SizeT))))
      else
        E.fail Loc.unknown (TError "§6.5.3.4#1, sentence 2")
  | AilEcast qs Void e ->
      wf_lvalue qs Void >>
      annotate_rvalue e >>= fun (e, _) ->
      E.return (AilEcast qs Void e, GenRValueType GenVoid)
  | AilEcast qs ty e ->
      wf_lvalue qs ty >>
      annotate_rvalue e >>= fun (e, gty) ->
      if is_scalar gty && AilTypesAux.is_scalar ty then
        E.return (AilEcast qs ty e, GenRValueType (inject_type ty))
      else
        E.fail Loc.unknown (TError_TODO 50)
  | AilEcond e1 e2 e3 ->
      annotate_rvalue e1 >>= fun (e1, gt1) ->
      annotate_rvalue e2 >>= fun (e2, gt2) ->
      annotate_rvalue e3 >>= fun (e3, gt3) ->
      well_typed_conditional gt1 gt2 gt3 (is_null_pointer_constant e2) (is_null_pointer_constant e3) >>= fun gtc ->
      E.return (AilEcond e1 e2 e3, gtc)
  | AilEcompoundAssign e1 (Add as aop) e2 ->
      annotate_expression A S G e1 >>= fun e1 ->
      annotate_rvalue e2 >>= fun (e2, gty2) ->
      match type_of A e1 with
      | GenLValueType qs ty -> 
          AilTypesAux.lvalue_coercion ty >>= fun ty1 ->
          if AilTypesAux.modifiable qs ty && (AilTypesAux.is_arithmetic ty1 && is_arithmetic gty2 || AilTypesAux.is_pointer_to_complete_object ty && is_integer gty2)
            then E.return (AilEcompoundAssign e1 aop e2, GenRValueType (inject_type ty1))
            else E.fail Loc.unknown (TError_TODO 52)
      | _  -> E.fail Loc.unknown (TError_TODO 53)
      end
  | AilEcompoundAssign e1 (Sub as aop) e2 ->
      annotate_expression A S G e1 >>= fun e1 ->
      annotate_rvalue e2 >>= fun (e2, gty2) ->
      match type_of A e1 with
      | GenLValueType qs ty -> 
          AilTypesAux.lvalue_coercion ty >>= fun ty1 ->
          if AilTypesAux.modifiable qs ty && (AilTypesAux.is_arithmetic ty1 && is_arithmetic gty2 || AilTypesAux.is_pointer_to_complete_object ty && is_integer gty2)
            then E.return (AilEcompoundAssign e1 aop e2, GenRValueType (inject_type ty1))
            else E.fail Loc.unknown (TError_TODO 54)
      | _  -> E.fail Loc.unknown (TError_TODO 55)
      end
  | AilEcompoundAssign e1 aop e2 ->
      annotate_expression A S G e1 >>= fun e1        ->
      annotate_rvalue e2 >>= fun (e2, gty2) ->
      match type_of A e1 with
      | GenLValueType qs ty ->
          AilTypesAux.lvalue_coercion ty >>= fun ty1 ->
          let gty1 = inject_type ty1 in
          if AilTypesAux.modifiable qs ty && well_typed_binary_arithmetic gty1 aop gty2
            then E.return (AilEcompoundAssign e1 aop e2, GenRValueType gty1)
            else E.fail Loc.unknown (TError_TODO 56)
      | _  -> E.fail Loc.unknown (TError_TODO 57)
      end
  
  | AilEconst cst ->
      annotate_constant cst >>= fun (cst', genTy) ->
      E.return (AilEconst cst', genTy)
  
  (* TODO: check *)
  | AilEstr lit ->
      annotate_stringLiteral lit
  end

and annotate_generic_association A S G = function
  | AilGAtype ty e ->
      wf_type ty >>
      if AilTypesAux.is_complete ty && AilTypesAux.is_object ty && not (AilTypesAux.variably_modified ty) then
        annotate_expression A S G e >>= fun e' ->
        E.return (AilGAtype ty e')
      else
        E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 2")
    
  | AilGAdefault e ->
      annotate_expression A S G e >>= fun e' ->
      E.return (AilGAdefault e')
end




and annotate_expression A S G (AnnotatedExpression a e) =
  annotate_expression' A S G e >>= fun (e, gty) ->
  E.return (AnnotatedExpression (A.Annotation.add_type gty a) e)

let annotate_rvalue A S G =
  annotate_rvalue_aux A (annotate_expression A S G)

let annotate_assignee A S G =
  annotate_assignee_aux (annotate_rvalue A S G)

let annotate_arguments A S G =
  annotate_arguments_aux A (annotate_expression A S G) (annotate_assignee A S G)


let rec annotate_block_aux A annotate_statement = function
  | [] ->
      E.return []
  | s :: ss ->
      annotate_statement s                       >>= fun s  ->
      annotate_block_aux A annotate_statement ss >>= fun ss ->
      E.return (s :: ss)
end


let annotate_definition A S G (sym, e) =
  match Context.lookup identifierEqual G sym with
    | Just (_, ty) ->
        if    (AilTypesAux.is_array ty --> AilTypesAux.has_unknown_size ty)
           || (AilTypesAux.is_complete_object ty --> not (AilTypesAux.is_vla ty)) then
          if AilTypesAux.is_scalar ty then
            (* STD §6.7.9#11, sentence 3 *)
            annotate_assignee A S G (AilTypesAux.unqualify ty) e >>= fun a_e ->
            E.return (sym, a_e)
          
          (* TODO: "(...) that has automatic storage duration" *)
          (* STD §6.7.9#13 *)
          else if AilTypesAux.is_struct_or_union ty then
            assert_false "WIP: annotate_definition, is_struct_or_union ty"
          
          (* STD §6.7.9#14 *)
          else if AilTypesAux.is_array_of_character ty then
            assert_false "WIP: annotate_definition, is_array_of_character ty"
          
          (* STD §6.7.9#15 *)
          else if AilTypesAux.compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin "wchar_t"; char16_t; char32_t] then
            assert_false "WIP: annotate_definition, compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin \"wchar_t\"; char16_t; char32_t]"
          
          (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)



          else
            assert_false "WIP: annotate_definition, not(is_scalar ty)"
        else
          (* STD §6.7.9#3 *)
          E.fail Loc.unknown (TError "§6.7.9#3")
    
    | Nothing ->
        E.fail Loc.unknown (TError_TODO 58) (* TODO: I think this error shouldn't be possible
                                  coming from Cabs_to_ail *)
  end

let rec annotate_definitions A S G = function
  | [] ->
      E.return []
  | d :: ds ->
      annotate_definition  A S G d  >>= fun d  ->
      annotate_definitions A S G ds >>= fun ds ->
      E.return (d :: ds)
end


let rec annotate_statement' A S G return_ty s =
  let annotate_block bs = annotate_block_aux A (annotate_statement A S (Context.add_bindings bs G) return_ty) in
  match s with
    | AilSlabel l s ->
        annotate_statement A S G return_ty s >>= fun s ->
        E.return (AilSlabel l s)
    | AilScase ic s ->
        annotate_statement A S G return_ty s >>= fun s ->
        E.return (AilScase ic s)
    | AilSdefault s ->
        annotate_statement A S G return_ty s >>= fun s ->
        E.return (AilSdefault s)
    | AilSblock bs ss ->
        AilTyping.well_formed_bindings bs >>
        E.guard (TError "sigma_fressh bindings failed in a AilSblock") (
          sigma_fresh_bindings bs S
        ) >>
        annotate_block bs ss >>= fun ss ->
        E.return (AilSblock bs ss)
    | AilSskip ->
        E.return AilSskip
    | AilSexpr e ->
        annotate_expression A S G e >>= fun e ->
        E.return (AilSexpr e)
    | AilSif e s1 s2 ->
        annotate_rvalue A S G e >>= fun (e, gt) ->
        (* STD §6.8.4.1#1 *)
        if is_scalar gt then
          annotate_statement A S G return_ty s1 >>= fun s1 ->
          annotate_statement A S G return_ty s2 >>= fun s2 ->
          E.return (AilSif e s1 s2)
        else
          E.fail Loc.unknown (TError_TODO 60)
    | AilSswitch e s ->
        annotate_rvalue A S G e >>= fun (e, gt) ->
        (* STD §6.8.4.2#1 *)
        if is_integer gt then
          annotate_statement A S G return_ty s >>= fun s ->
          E.return (AilSswitch e s)
        else
          E.fail Loc.unknown (TError_TODO 61)
    | AilSwhile e s ->
        annotate_rvalue A S G e >>= fun (e, gt) ->
        (* STD §6.8.5#2 *)
        if is_scalar gt then
          annotate_statement A S G return_ty s >>= fun s ->
          E.return (AilSwhile e s)
        else
          E.fail Loc.unknown (TError_TODO 62)
    | AilSdo s e ->
        annotate_rvalue A S G e >>= fun (e, gt) ->
        (* STD §6.8.5#2 *)
        if is_scalar gt then
          annotate_statement A S G return_ty s >>= fun s ->
          E.return (AilSdo s e)
        else
          E.fail Loc.unknown (TError_TODO 63)
    | AilSgoto v ->
        E.return (AilSgoto v)
    | AilScontinue ->
        E.return AilScontinue
    | AilSbreak ->
        E.return AilSbreak
    | AilSreturnVoid ->
        if return_ty = Void then
          E.return AilSreturnVoid
        else
          E.fail Loc.unknown (TError_TODO 64)
    | AilSreturn e ->
        annotate_assignee A S G return_ty e >>= fun e ->
        E.return (AilSreturn e)
    | AilSdeclaration ds ->
        annotate_definitions A S G ds >>= fun ds ->
        E.return (AilSdeclaration ds)
  end

and annotate_statement A S G return_ty (AnnotatedStatement b s) =
  annotate_statement' A S G return_ty s >>= fun s ->
  E.return (AnnotatedStatement b s)


let annotate_block A S G return_ty bs =
  annotate_block_aux A (annotate_statement A S G return_ty) bs


(*
let annotate_function_declaration A S p =
  let ty_return   = p.fun_return_ty   in
  let bs          = p.fun_bindings    in
  let is_variadic = p.fun_is_variadic in
  let s_opt       = p.fun_body        in
  if sigma_fresh_bindings bs S &&
     (* AilTyping.well_formed_bindings bs && *)
     wf_type (Function ty_return (parameters_of_bindings bs) is_variadic)
  then
    match s_opt with
      | Just s ->  annotate_statement A S (Context.add_bindings bs Context.empty) ty_return s >>= fun s' ->
                   (* TODO: using the "with" construct of lem doesn't typecheck like we need here, is this
                            a necessary restriction of the type system ? *)
                   E.return <| fun_return_ty=   ty_return;
                               fun_bindings=    bs;
                               fun_is_variadic= is_variadic;
                               fun_is_inline=   p.fun_is_inline;
                               fun_is_Noreturn= p.fun_is_Noreturn;
                               fun_body=        Just s' |>
      | Nothing -> E.return <| fun_return_ty=   ty_return;
                               fun_bindings=    bs;
                               fun_is_variadic= is_variadic;
                               fun_is_inline=   p.fun_is_inline;
                               fun_is_Noreturn= p.fun_is_Noreturn;
                               fun_body=        Nothing |>
    end
  else
    E.fail Loc.unknown (TError_TODO 65)
*)


(*
(* TODO: check with J *)
let annotate_global A S (qs, ty, e_opt) =
  if wf_type ty then
    match e_opt with
      | Just e  -> annotate_assignee A S Context.empty ty e >>= fun e ->
                   E.return (qs, ty, Just e)
      | Nothing -> E.return (qs, ty, Nothing)
    end
  else
    E.fail Loc.unknown (TError_TODO 66)
*)


(*
let annotate_sigma A S =
  sigma_mapP (function
    | SDecl_fun id fdecl ->
        annotate_function_declaration A S fdecl >>= fun fdecl' ->
        E.return (SDecl_fun id fdecl')
    | SDecl_global id glob ->
        annotate_global A S glob >>= fun glob'->
        E.return (SDecl_global id glob')
    | SDecl_static_assert _ _ ->
        assert_false "TODO"
(*
TODO
        annotate_assignee A S Context.empty ty e >>= fun e' ->
        annotate_stringConstant sc               >>= fun sc' ->
        E.return (SDecl_static_assert e' sc')
*)
  end) S
*)


(*
val annotate_sigma: forall 'A1 'A2 'B.
                    annotation 'A1 'A2 -> sigma 'B 'A1 ->
                    E.t (sigma 'B 'A2)
*)

let annotate_sigma A S =
  (* TODO: morally we want a "mapP_" here *)
  Context.mapP identifierEqual (fun _ decl ->
    match decl with
      | Decl_object _ _ ty ->
          wf_type ty >>
          E.return decl
      | Decl_function ret_ty qs_tys is_variadic _ (* is_inline *) _ (* is_Noreturn *) ->
          (* AilTyping.well_formed_bindings bs && *)
          wf_type (Function ret_ty qs_tys is_variadic) >>
          E.return decl
    end
  ) S.declarations >>
  
  Context.mapP identifierEqual (fun ident e ->
    match Context.lookup identifierEqual S.declarations ident with
      | Just (Decl_object _ _ (* qs *) ty) ->
          annotate_assignee A S Context.empty ty e
      | _ ->
          E.fail Loc.unknown (TError_TODO 1000)
    end
  ) S.object_definitions >>= fun object_defs' ->
  
  Context.mapP identifierEqual (fun ident (param_idents, s) ->
    match Context.lookup identifierEqual S.declarations ident with
      | Just (Decl_function ret_ty qs_tys _ (* is_variadic *) _ (* is_inline *) _ (* is_Noreturn *)) ->
          let bs = List.zip param_idents qs_tys in
          if sigma_fresh_bindings bs S then
            annotate_statement A S (Context.add_bindings bs Context.empty) ret_ty s >>= fun s' ->
              E.return (param_idents, s')
          else
            E.fail Loc.unknown (TError_TODO 1001)
      | _ ->
          E.fail Loc.unknown (TError_TODO 1002)
    end
  ) S.function_definitions >>= fun function_defs' ->
  
(*
TODO: static asserts
  E.mapM (fun (e, strConst) ->
  ) 
*)
  E.return <|
    declarations= S.declarations;
    object_definitions= object_defs';
    function_definitions= function_defs';
    (* TODO: hack *)
    static_assertions= []
  |>

(*
type declaration =
  | Decl_object   of qualifiers * ctype
    (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  | Decl_function of ctype * (list (qualifiers * ctype)) * bool * bool * bool

type sigma 'A 'B = <|
  declarations: Context.context identifier declaration;
  object_definitions: Context.context identifier (expression 'B);
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: Context.context identifier (list identifier * statement 'A 'B);
  static_assertions: list (expression 'B * stringConstant)
|>
*)


let annotate_program A (startup, S) =
  match Context.lookup identifierEqual S.declarations startup with
    | Just (Decl_function ret_ty _ (* bs *) _ (* is_variadic *) _ (* is_inline *) _ (* is_Noreturn *)) ->
        (* TODO: check arguments *)
        if ret_ty = Basic (Integer (Signed Int_)) then
          annotate_sigma A S >>= fun S ->
          E.return (startup, S)
        else
          E.fail Loc.unknown (TError_TODO 1067)
    | _ ->
        E.fail Loc.unknown (TError_TODO 67) (* TODO: this is not realy a type error, but more an csem internal one. *)
  end
