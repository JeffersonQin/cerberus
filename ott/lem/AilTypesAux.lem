open import Pervasives Common AilTypes Implementation ErrorMonad TypingError

(* == Function on qualifiers ==================================================================== *)
val is_unqualified: qualifiers -> bool
let is_unqualified = function
  | <|
      const    = false;
      restrict = false;
      volatile = false;
      atomic   = false
    |> ->
      true
  | _ ->
      false
end

val combine_qualifiers: qualifiers -> qualifiers -> qualifiers
let combine_qualifiers qs1 qs2 = <|
  const    = qs1.const    || qs2.const   ;
  restrict = qs1.restrict || qs2.restrict;
  volatile = qs1.volatile || qs2.volatile;
  atomic   = qs1.atomic   || qs2.atomic  ;
|>

val sub_qualifiers: qualifiers -> qualifiers -> bool
let sub_qualifiers qs1 qs2 =
     qs1.const    --> qs2.const
  && qs1.restrict --> qs2.restrict
  && qs1.volatile --> qs2.volatile
  && qs1.atomic   --> qs2.atomic


(* == predicates on integerTypes ================================================================= *)
(* TODO: change name *)
val is_unsigned: implementation -> integerType -> bool
let is_unsigned P it =
  not (P.signed it)

val signed_type: integerType -> bool
let signed_type = function
  | Signed _ ->
      true
  | _ ->
      false
end

val unsigned_type: integerType -> bool
let unsigned_type = function
  | Unsigned _ ->
      true
  | Bool ->
      true
  | _ ->
      false
 end



(* == constructor predicates on ctypes =========================================================== *)
val is_integer: ctype -> bool
let is_integer = function
  | Basic (Integer _) ->
      true
  | _ ->
      false
end

val is_void: ctype -> bool
let is_void = function
  | Void ->
      true
  | _ ->
      false
end

val is_pointer: ctype -> bool
let is_pointer = function
  | Pointer _ _ ->
      true
  | _ ->
      false
end

val is_bool: ctype -> bool
let is_bool = function
  | Basic (Integer Bool) ->
      true
  | _ ->
      false
end

(* TODO: STD doc *)
val is_array: ctype -> bool
let is_array = function
  | Array _ _ ->
      true
  | _ ->
      false
end

(* STD §6.2.5#1, sentence 3 *)
val is_function: ctype -> bool
let is_function = function
  | Function _ _ _ ->
      true
  | _ ->
      false
end

val is_struct: ctype -> bool
let is_struct = function
  | Struct _ _ ->
      true
  | _ ->
      false
end

val is_union: ctype -> bool
let is_union = function
  | Union _ _ ->
      true
  | _ ->
      false
end



(* == generic predicates on ctypes ============================================================== *)
(* STD §6.2.5#1, sentence 3 *)
val is_object: ctype -> bool
let is_object ty =
  not (is_function ty)

(* STD §6.2.5#18, sentence 1 *)
val is_arithmetic: ctype -> bool
let is_arithmetic ty =
  is_integer ty (* TODO: || is_floating ty *)

(* STD §6.2.5#21, sentence 1 *)
val is_scalar: ctype -> bool
let is_scalar ty =
  is_pointer ty || is_arithmetic ty

(* STD §6.2.5#21, sentence 2 *)
val is_aggregate: ctype -> bool
let is_aggregate ty =
  is_array ty || is_struct ty



(* TODO *)
val is_complete: ctype -> bool
let is_complete = function
  | Basic _ -> true
  | Pointer _ _ -> true
  | Array _ _ -> true
  | _ -> false
end

(* TODO *)
let is_incomplete t : bool =
  match t with
  | Void -> true
  | _ -> false
  end




(* ============================================================================================== *)
let in_integer_range P n it : bool =
  Range.mem n (integer_range P it)

let in_min_integer_range n it : bool =
  Range.mem n (Implementation.min_integer_range it)

let le_integer_range P it1 it2 : bool =
  match (it1, it2) with
  | (Char             , Char             ) -> true
  | (Char             , Signed   Ichar   ) -> P.signed Char
  | (Char             , Signed   ibt     ) -> P.signed Char ||
                                              (P.precision Char) < (P.precision (Signed ibt))
  | (Signed Ichar     , Char             ) -> P.signed Char
  | (Signed ibt       , Char             ) -> P.signed Char &&
                                              P.precision (Signed ibt) = P.precision Char
  | (Unsigned Ichar   , Char             ) -> not (P.signed Char)
  | (Unsigned ibt     , Char             ) -> not (P.signed Char) &&
                                              P.precision (Unsigned ibt) = P.precision Char
  | (Char             , Unsigned _       ) -> not (P.signed Char)
  | (Char             , Bool             ) -> not (P.signed Char) &&
                                              P.precision Char = P.precision Bool
  | (Bool             , Char             ) -> not (P.signed Char) ||
                                              (P.precision Bool) < (P.precision Char)

  | (Signed   Ichar   , Signed   _       ) -> true
  | (Signed   Short   , Signed   Short   ) -> true
  | (Signed   Short   , Signed   Int_    ) -> true
  | (Signed   Short   , Signed   Long    ) -> true
  | (Signed   Short   , Signed   LongLong) -> true
  | (Signed   Int_    , Signed   Int_    ) -> true
  | (Signed   Int_    , Signed   Long    ) -> true
  | (Signed   Int_    , Signed   LongLong) -> true
  | (Signed   Long    , Signed   Long    ) -> true
  | (Signed   Long    , Signed   LongLong) -> true
  | (Signed   LongLong, Signed   LongLong) -> true
  | (Signed   ibt1    , Signed   ibt2    ) -> P.precision (Signed ibt1) = P.precision (Signed ibt2)

  | (Bool             , Bool             ) -> true
  | (Bool             , Unsigned _       ) -> true
  | (Unsigned Ichar   , Unsigned _       ) -> true
  | (Unsigned Short   , Unsigned Short   ) -> true
  | (Unsigned Short   , Unsigned Int_    ) -> true
  | (Unsigned Short   , Unsigned Long    ) -> true
  | (Unsigned Short   , Unsigned LongLong) -> true
  | (Unsigned Int_    , Unsigned Int_    ) -> true
  | (Unsigned Int_    , Unsigned Long    ) -> true
  | (Unsigned Int_    , Unsigned LongLong) -> true
  | (Unsigned Long    , Unsigned Long    ) -> true
  | (Unsigned Long    , Unsigned LongLong) -> true
  | (Unsigned LongLong, Unsigned LongLong) -> true
  | (Unsigned ibt     , Bool             ) -> P.precision (Unsigned ibt) = P.precision Bool
  | (Unsigned ibt1    , Unsigned   ibt2  ) -> P.precision (Unsigned ibt1) = P.precision (Unsigned ibt2)

  | (Signed   _       , Bool             ) -> false
  | (Signed   _       , Unsigned _       ) -> false

  | (Bool             , Signed   ibt2    ) -> (P.precision Bool) < (P.precision (Signed ibt2))
  | (Unsigned _       , Signed   Ichar   ) -> false
  | (Unsigned Short   , Signed   Short   ) -> false
  | (Unsigned Int_    , Signed   Int_    ) -> false
  | (Unsigned Long    , Signed   Long    ) -> false
  | (Unsigned LongLong, Signed   LongLong) -> false
  | (Unsigned ibt1    , Signed   ibt2    ) -> (P.precision (Unsigned ibt1)) < (P.precision (Signed ibt2))
  
  (* TODO: check *)
  | (Wchar_t          , Wchar_t          ) -> true

  | (Char16_t         , Char16_t         ) -> true
  | (Char32_t         , Char32_t         ) -> true
  
  

(*  
  | (Signed Int8_t    , Signed Int8_t    ) -> true
  | (Signed Int8_t    , Signed Int16_t   ) -> true
  | (Signed Int8_t    , Signed Int32_t   ) -> true
  | (Signed Int8_t    , Signed Int64_t   ) -> true
  
  | (Signed Int16_t   , Signed Int8_t    ) -> false
  | (Signed Int16_t   , Signed Int16_t   ) -> true
  | (Signed Int16_t   , Signed Int32_t   ) -> true
  | (Signed Int16_t   , Signed Int64_t   ) -> true
  
  | (Signed Int32_t   , Signed Int8_t    ) -> false
  | (Signed Int32_t   , Signed Int16_t   ) -> false
  | (Signed Int32_t   , Signed Int32_t   ) -> true
  | (Signed Int32_t   , Signed Int64_t   ) -> true
  
  | (Signed Int64_t   , Signed Int8_t    ) -> false
  | (Signed Int64_t   , Signed Int16_t   ) -> false
  | (Signed Int64_t   , Signed Int32_t   ) -> false
  | (Signed Int64_t   , Signed Int64_t   ) -> true
  
  
  | (Unsigned Int8_t  , Unsigned Int8_t  ) -> true
  | (Unsigned Int8_t  , Unsigned Int16_t ) -> true
  | (Unsigned Int8_t  , Unsigned Int32_t ) -> true
  | (Unsigned Int8_t  , Unsigned Int64_t ) -> true
  
  | (Unsigned Int16_t , Unsigned Int8_t  ) -> false
  | (Unsigned Int16_t , Unsigned Int16_t ) -> true
  | (Unsigned Int16_t , Unsigned Int32_t ) -> true
  | (Unsigned Int16_t , Unsigned Int64_t ) -> true
  
  | (Unsigned Int32_t , Unsigned Int8_t  ) -> false
  | (Unsigned Int32_t , Unsigned Int16_t ) -> false
  | (Unsigned Int32_t , Unsigned Int32_t ) -> true
  | (Unsigned Int32_t , Unsigned Int64_t ) -> true
  
  | (Unsigned Int64_t , Unsigned Int8_t  ) -> false
  | (Unsigned Int64_t , Unsigned Int16_t ) -> false
  | (Unsigned Int64_t , Unsigned Int32_t ) -> false
  | (Unsigned Int64_t , Unsigned Int64_t ) -> true
  
  
  | (Unsigned Int8_t  , Signed Int8_t    ) -> false
  | (Unsigned Int8_t  , Signed Int16_t   ) -> false
  | (Unsigned Int8_t  , Signed Int32_t   ) -> false
  | (Unsigned Int8_t  , Signed Int64_t   ) -> false
*)

  | _ -> assert_false "WIP"


(*
 | Int8_t
 | Int16_t
 | Int32_t
 | Int64_t



 | Wchar_t
 | Char16_t
 | Char32_t


*)


  end

let eq_integer_rank_base it1 it2 : bool =
  match (it1, it2) with
  | (Signed ibt1, Unsigned ibt2  ) -> eq_integerBaseType ibt1 ibt2
  | (Char       , Unsigned  Ichar) -> true
  | (Char       , Signed    Ichar) -> true
  | (_          , _              ) -> false
  end

let eq_integer_rank it1 it2 : bool =
  eq_integerType it1 it2 || eq_integer_rank_base it1 it2 || eq_integer_rank_base it2 it1

let lt_integer_rank_base P it1 it2 : bool =
  match (it1, it2) with
  | (Bool        , it             ) -> not (eq_integerType Bool it)
  | (Signed  Long, Signed LongLong) -> true
  | (Signed   Int_, Signed     Long) -> true
  | (Signed Short, Signed      Int_) -> true
  | (Signed Ichar, Signed    Short) -> true
  | (Signed  ibt1, Signed     ibt2) -> (P.precision (Signed ibt1)) < (P.precision (Signed ibt2))
  | (_           , _              ) -> false
  end

let lt_integer_rank_congruence P it1 it2 : bool =
  match (it1, it2) with
  | (_            , Bool         ) -> false
  | (Bool         , _            ) -> true
  | (_            , Char         ) -> false
  | (Char         , Unsigned ibt2) -> lt_integer_rank_base P (Signed Ichar) (Signed ibt2)
  | (Char         , Signed   ibt2) -> lt_integer_rank_base P (Signed Ichar) (Signed ibt2)
  | (Signed ibt1  , Signed   ibt2) -> lt_integer_rank_base P (Signed  ibt1) (Signed ibt2)
  | (Unsigned ibt1, Unsigned ibt2) -> lt_integer_rank_base P (Signed  ibt1) (Signed ibt2)
  | (Unsigned ibt1, it2          ) -> lt_integer_rank_base P (Signed  ibt1) it2
  | (it1          , Unsigned ibt2) -> lt_integer_rank_base P it1            (Signed ibt2)
  | _ -> assert_false "WIP"
  end

let lt_integer_rank it1 it2 : bool =
  match (it1, it2) with
  | (_             , Bool          ) -> false
  | (Bool          , _             ) -> true

  | (_             , Char          ) -> false
  | (_             , Signed   Ichar) -> false
  | (_             , Unsigned Ichar) -> false
  | (Char          , Signed    _   ) -> true
  | (Char          , Unsigned  _   ) -> true
  | (Signed   Ichar, Signed    _   ) -> true
  | (Signed   Ichar, Unsigned  _   ) -> true
  | (Unsigned Ichar, Signed    _   ) -> true
  | (Unsigned Ichar, Unsigned  _   ) -> true

  | (_             , Signed   Short) -> false
  | (_             , Unsigned Short) -> false
  | (Signed   Short, Signed    _   ) -> true
  | (Signed   Short, Unsigned  _   ) -> true
  | (Unsigned Short, Signed    _   ) -> true
  | (Unsigned Short, Unsigned  _   ) -> true

  | (_             , Signed     Int_) -> false
  | (_             , Unsigned   Int_) -> false
  | (Signed     Int_, Signed    _   ) -> true
  | (Signed     Int_, Unsigned  _   ) -> true
  | (Unsigned   Int_, Signed    _   ) -> true
  | (Unsigned   Int_, Unsigned  _   ) -> true

  | (_             , Signed    Long) -> false
  | (_             , Unsigned  Long) -> false
  | (Signed    Long, Signed    _   ) -> true
  | (Signed    Long, Unsigned  _   ) -> true
  | (Unsigned  Long, Signed    _   ) -> true
  | (Unsigned  Long, Unsigned  _   ) -> true

  | (_             , _             ) -> false
  end

let le_integer_rank it1 it2 : bool =
  eq_integer_rank it1 it2 || lt_integer_rank it1 it2


let is_corresponding_unsigned it1 it2 : bool =
  match (it1, it2) with
  | (Signed ibt1, Unsigned ibt2) -> eq_integerBaseType ibt1 ibt2
  | (_          , _            ) -> false
  end

let corresponding_unsigned it : maybe integerType =
  match it with
  | Signed ibt -> Just (Unsigned ibt)
  | _          -> Nothing
  end

let make_corresponding_unsigned it : integerType =
  match it with
  | Signed ibt -> Unsigned ibt
  | _          -> it
  end

let is_integer_promotion P it1 it2 : bool =
  match (it1, it2) with
  | (Signed   Int_, Signed   Int_) -> true
  | (Unsigned Int_, Signed   Int_) -> false
  | (Unsigned Int_, Unsigned Int_) -> true
  | (Signed   Int_, Unsigned Int_) -> false
  | (_           , Signed   Int_) -> le_integer_rank it1 (Signed Int_) &&
                                    le_integer_range P it1 (Signed Int_)
  | (_           , Unsigned Int_) -> le_integer_rank it1 (Signed Int_) &&
                                    not (le_integer_range P it1 (Signed Int_))
  | (_           , _           ) -> eq_integerType it1 it2 &&
                                    not (le_integer_rank it1 (Signed Int_))
  end

let integer_promotion P it : integerType =
  match it with
  | Signed   Int_ -> Signed   Int_
  | Unsigned Int_ -> Unsigned Int_
  | _            -> if le_integer_rank it (Signed Int_)
                      then if le_integer_range P it (Signed Int_)
                             then Signed Int_
                             else Unsigned Int_
                      else it
  end

let is_promotion P t1 t2 : bool =
  match (t1, t2) with
  | (Basic (Integer it1), Basic (Integer it2)) -> is_integer_promotion P it1 it2
  | (_                  , _                  ) -> false
  end

let promotion P t : maybe ctype =
  match t with
  | Basic (Integer it) -> Just (Basic (Integer (integer_promotion P it)))
  | _                  -> Nothing
  end

let is_usual_arithmetic_promoted_integer P it1 it2 it3 : bool =
  if signed_type it1 then
    if signed_type it2 then
      if lt_integer_rank it2 it1 then
        eq_integerType it1 it3
      else
        eq_integerType it2 it3
    else if unsigned_type it2 then
      if le_integer_rank it1 it2 then
        eq_integerType it2 it3
      else
        if le_integer_range P it2 it1 then
          eq_integerType it1 it3
        else
          is_corresponding_unsigned it1 it3
    else
      false
  else if unsigned_type it1 then
    if unsigned_type it2 then
      if lt_integer_rank it2 it1 then
        eq_integerType it1 it3
      else
        eq_integerType it2 it3
    else if signed_type it2 then
      if le_integer_rank it2 it1 then
        eq_integerType it1 it3
      else if le_integer_range P it1 it2 then
        eq_integerType it2 it3
      else
        is_corresponding_unsigned it2 it3
    else
      false
  else
    false

let usual_arithmetic_promoted_integer P it1 it2 : integerType =
  if signed_type it1 then
    if signed_type it2 then
      if lt_integer_rank it2 it1 then
        it1
      else
        it2
    else
      if le_integer_rank it1 it2 then
        it2
      else
        if le_integer_range P it2 it1 then
          it1
        else
          make_corresponding_unsigned it1
  else
    if unsigned_type it2 then
      if lt_integer_rank it2 it1 then
        it1
      else
        it2
    else
      if le_integer_rank it2 it1 then
        it1
      else if le_integer_range P it1 it2 then
        it2
      else
        make_corresponding_unsigned it2

let is_usual_arithmetic_integer P it1 it2 it3 : bool =
  is_usual_arithmetic_promoted_integer P (integer_promotion P it1)
                                         (integer_promotion P it2) it3

let usual_arithmetic_integer P it1 it2 : integerType =
  usual_arithmetic_promoted_integer P (integer_promotion P it1)
                                      (integer_promotion P it2)

let is_usual_arithmetic P t1 t2 t3 : bool =
  match (t1, t2, t3) with
  | (Basic (Integer it1), Basic (Integer it2), Basic (Integer it3)) -> is_usual_arithmetic_integer P it1 it2 it3
  | (_                  , _                  , _                  ) -> false
  end

let usual_arithmetic P t1 t2 : maybe ctype =
  match (t1, t2) with
  | (Basic (Integer it1), Basic (Integer it2)) -> Just (Basic (Integer (usual_arithmetic_integer P it1 it2)))
  | (_                  , _                  ) -> Nothing
  end



(* assuming [ty] is an lvalue type, [modifiable ty] is true iff
   [ty] is modifiable lvalue type (see §6.3.2.1#1, sentence 3) *)

(*
A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const- qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const- qualified type.
*)
val modifiable: qualifiers -> ctype -> bool
let modifiable qs ty =
  not (is_array ty) &&
  not (qs.const) &&
  is_object ty &&
  not (is_incomplete ty)

let real t : bool = is_integer t

let rec ~{coq} compatible_params_aux compatible p1 p2 : bool =
  match (p1, p2) with
  | ([]           , []           ) -> true
  | ((_, t1) :: p1, (_, t2) :: p2) -> compatible t1 t2 && compatible_params_aux compatible p1 p2
  | (_            , _            ) -> false
  end

(* (§6.2.7) Compatible type *)
let rec ~{coq} compatible t1 t2 : bool =
  let compatible_params = compatible_params_aux compatible in
  match (t1, t2) with
  | (Void             , Void             ) -> true
  | (Basic bt1        , Basic bt2        ) -> eq_basicType bt1 bt2
  | (Array    t1 n1   , Array    t2 n2   ) -> compatible t1 t2 && n1 = n2
  | (Function t1 p1 b1, Function t2 p2 b2) -> compatible t1 t2 && compatible_params p1 p2 && b1 = b2
  | (Pointer  q1 t1   , Pointer  q2 t2   ) -> compatible t1 t2 && eq_qualifiers q1 q2
  | (_                , _                ) -> false
  end

let ~{coq} compatible_params p1 p2 = compatible_params_aux compatible p1 p2

let rec ~{coq} is_composite_params_aux is_composite p1 p2 p3 : bool =
  match (p1, p2, p3) with
  | ([]           , []           , []            ) -> true
  | ((_, t1) :: p1, (_, t2) :: p2, (q3, t3) :: p3) -> is_unqualified q3 &&
                                                      is_composite t1 t2 t3 &&
                                                      is_composite_params_aux is_composite p1 p2 p3
  | (_            , _            , _             ) -> false
  end

let rec ~{coq} is_composite t1 t2 t3 : bool =
  let is_composite_params = is_composite_params_aux is_composite in
  match (t1, t2, t3) with
  | (Void            , Void            , Void            ) -> true
  | (Basic bt1       , Basic bt2       , Basic bt3       ) -> eq_basicType bt1 bt2 && eq_basicType bt1 bt3
  | (Array t1 n1     , Array t2 n2     , Array t3 n3     ) -> is_composite t1 t2 t3 && n1 = n2 && n1 = n3
  | (Function t1 p1 _, Function t2 p2 _, Function t3 p3 _) -> is_composite t1 t2 t3 && is_composite_params p1 p2 p3
  | (Pointer  q1 t1  , Pointer  q2 t2  , Pointer  q3 t3  ) -> is_composite t1 t2 t3 && eq_qualifiers q1 q2 && eq_qualifiers q1 q3
  | (_               , _               , _               ) -> false
  end

let ~{coq} is_composite_params p1 p2 p3 = is_composite_params_aux is_composite p1 p2 p3

let rec ~{coq} composite_params_aux composite p1 p2 : maybe (list (qualifiers * ctype))=
    match (p1, p2) with
    | ([]           , []           ) -> Just []
    | ((_, t1) :: p1, (_, t2) :: p2) -> match (composite t1 t2, composite_params_aux composite p1 p2) with
                                        | (Just t, Just p) -> Just ((no_qualifiers, t) :: p)
                                        | (_     , _     ) -> Nothing
                                        end
    | (_            , _            ) -> Nothing
    end

(* (§6.2.7#3) composite type *)
let rec ~{coq} composite t1 t2 : maybe ctype =
  let composite_params = composite_params_aux composite in
  match (t1, t2) with
  | (Void          , Void          ) -> Just Void
  | (Basic bt1     , Basic bt2     ) -> if eq_basicType bt1 bt2
                                          then Just (Basic bt1)
                                          else Nothing
  | (Array t1 n1   , Array t2 n2   ) -> if n1 = n2
                                          then Maybe.map (fun t -> Array t n1) (composite t1 t2)
                                          else Nothing
  | (Function t1 p1 b1, Function t2 p2 b2) ->
      match (composite t1 t2, composite_params p1 p2) with
      | (Just t, Just p) -> if b1 = b2 then Just (Function t p b1) else Nothing
      | (_     , _     ) -> Nothing
      end
  | (Pointer  q1 t1, Pointer  q2 t2) -> if eq_qualifiers q1 q2
                                          then Maybe.map (Pointer q1) (composite t1 t2)
                                          else Nothing
  | (_             , _             ) -> Nothing
  end

let ~{coq} composite_params p1 p2 = composite_params_aux composite p1 p2


(* following (§6.3.2.1)#3 *)
let array_coercion = function
  | Array    ty _ -> Pointer no_qualifiers ty
  | ty            -> ty
end

(* following (§6.3.2.1)#4 *)
let function_coercion = function
  | Function ty' qs b -> Pointer no_qualifiers (Function ty' qs b)
  | ty                -> ty
end

(* following (§6.3.2.1)#2 *)
let lvalue_convertible ty : bool =
  not (is_array ty) && is_complete ty

(* following (§6.3.2.1)#2 and #3 *)
let lvalue_coercion ty : errorM ctype =
  if lvalue_convertible ty then
    return ty
  else if is_array ty then
    return (array_coercion ty)
  else
    fail (TError_TODO 1)

(* following (§6.3.2.1)#3 and #4 *)
let rvalue_coercion ty : ctype =
  if is_array ty then
    array_coercion ty
  else if is_function ty then
    function_coercion ty
  else
    ty

let pointer_to_complete_object t : bool =
  match t with
  | Pointer _ t -> is_complete t
  | _           -> false
  end

let ~{coq} pointers_to_compatible_complete_objects t1 t2 : bool =
  match (t1, t2) with
  | (Pointer _ t1, Pointer _ t2) -> is_complete t1 && is_complete t2 && compatible t1 t2
  | (_           , _           ) -> false
  end  

let ~{coq} pointers_to_compatible_objects t1 t2 : bool =
  match (t1, t2) with
  | (Pointer _ t1, Pointer _ t2) -> is_object t1 && is_object t2 && compatible t1 t2
  | (_           , _           ) -> false
  end  

let pointer_to_object t : bool =
  match t with
  | Pointer _ t -> is_object t
  | _           -> false
  end

let pointer_to_void t : bool =
  match t with
  | Pointer _ Void -> true
  | _              -> false
  end

let ~{coq} pointers_to_compatible_types t1 t2 : bool =
  match (t1, t2) with
  | (Pointer _ t1, Pointer _ t2) -> compatible t1 t2
  | (_           , _           ) -> false
  end  


val is_signed_integer_type: ctype -> bool
let is_signed_integer_type = function
  | Basic (Integer it) ->
      signed_type it
  | _ ->
      false
end

val is_unsigned_integer_type: ctype -> bool
let is_unsigned_integer_type = function
  | Basic (Integer it) ->
      unsigned_type it
  | _ ->
      false
end








val variably_modified: ctype -> bool
let variably_modified _ =
  (* TODO *)
  false



val had_unknown_size: ctype -> bool
let has_unknown_size = function
  | _ ->
      false (* TODO !!!!!!! *)
end

val is_vla: ctype -> bool
let is_vla = function
  | _ ->
      false (* TODO !!!!!!! *)
end

val is_complete_object: ctype -> bool
let is_complete_object ty =
  is_complete ty && is_object ty


val unqualify: ctype -> ctype
let unqualify ty =
  ty (* TODO *)
(*
function
 | Void ->
     Void
 | Basic bty ->
     Basic bty
 | Array ty n ->
     Array (unqualify ty) n
 | Function ty qs_tys is_variadic ->
     Function (unqualify ty) (List.map (fun (qs, ty) -> (qs, unqualify ty)) qs_tys) is_variadic
 | Atomic ty ->
     Atomic (unqualify ty)
 | Struct sym ids_ty ->
     Struct sym 
 | Union of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
 | Builtin of string
end
*)
