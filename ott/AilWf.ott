defns
Jwf :: '' ::=

defn
wfLvalue qualifiers type :: :: wfLvalueType :: WfLvalueType by

wfLvalue qs ty
isObject ty
---------------------- :: PointerObject
wfLvalue qs' (qs ty *)

wfLvalue qs ty
not (isObject ty)
not (restrict in qs')
---------------------- :: PointerOther
wfLvalue qs' (qs ty *)

not (restrict in qs)
---------------------- :: BasicType
wfLvalue qs basicType

not (restrict in qs)
-------------------- :: Void
wfLvalue qs void

wfLvalue qs ty
not (isIncomplete ty)
not (isFunction ty)
--------------------- :: Array
wfLvalue qs (ty [n])

wf ty
wfLvalue qs1 ty1 .. wfLvalue qsk tyk
% After "adjustment"
not(isIncomplete ty1) .. not(isIncomplete tyk)
not(isFunction ty1) .. not(isFunction tyk)
---------------------------------------------- :: Function
wfLvalue [] (ty (qs1 ty1, .., qsk tyk))

defn
wf type :: :: wfType :: WfType
{{ com nested types }}
by

wfLvalue qs ty
-------------- :: PointerObject
wf (qs ty *)

------------ :: BasicType
wf basicType

------- :: Void
wf void

defn
G ; S |- wf e :: :: wfE :: WfE by

G; S |- wf e_l
------------------------------ :: Unary
G; S |- wf (unaryOperator e_l)

G; S |- wf e_l1
G; S |- wf e_l2
------------------------------------- :: Binary
G; S |- wf (e_l1 binaryOperator e_l2)

G; S |- wf e_l1
G; S |- wf e_l2
------------------------ :: Assign
G; S |- wf (e_l1 = e_l2)

G; S |- wf e_l1
G; S |- wf e_l2
------------------------------------------- :: CompoundAssign
G; S |- wf (e_l1 arithmeticOperator = e_l2)

G; S |- wf e_l1
G; S |- wf e_l2
G; S |- wf e_l3
------------------------------- :: Conditional
G; S |- wf (e_l1 ? e_l2 : e_l3)

wfLvalue qs ty
G; S |- wf e_l
--------------------- :: Cast
G; S |- wf ((qs ty) e_l)

G; S |- wf e_l
G; S |- wf e_l1 .. G; S |- wf e_lk
---------------------------------- :: Call
G; S |- wf (e_l (e_l1, .., e_lk))

------------------- :: Constant
G; S |- wf constant

id : qs ty in G
--------------- :: Variable
G; S |- wf id

id :ty = s_l in S
----------------- :: Function
G; S |- wf id

wfLvalue qs ty
------------------------- :: SizeOf
G; S |- wf (sizeof qs ty)

wfLvalue qs ty
-------------------------- :: AlignOf
G; S |- wf (alignof qs ty)

defn
G ; S |- wf e_l :: :: wfEL :: WfEL by

G; S |- wf e
---------------- :: Def
G; S |- wf (a e)

defn
G ; S ; ty ; b |- wf s :: :: wfS :: WfS by

------------------- :: Skip
G; S; ty; b |- wf ;

G; S |- wf e_l
--------------------- :: Expression
G; S; ty; b |- wf (e_l;)

wf G'
(G' @ G); S; ty; b |- wf s_l1 .. (G' @ G); S; ty; b |- wf s_lk
-------------------------------------------------------------- :: Block
G; S; ty; b |- wf ({ G' | s_l1 .. s_lk })

G; S |- wf e_l
G; S; ty; b |- wf s_l1
G; S; ty; b |- wf s_l2
------------------------------------------- :: If
G; S; ty; b |- wf (if (e_l) s_l1 else s_l2)

G; S |- wf e_l
G; S; ty; true |- wf s_l
----------------------------------- :: While
G; S; ty; b |- wf (while (e_l) s_l)

G; S |- wf e_l
G; S; ty; true |- wf s_l
--------------------------------------- :: Do
G; S; ty; b |- wf (do s_l while (e_l);)

----------------------------- :: Break
G; S; ty; true |- wf (break;)

-------------------------------- :: Continue
G; S; ty; true |- wf (continue;)

isVoid ty
------------------------------------------ :: ReturnVoid
G; S; ty (ty1, .., tyk); b |- wf (return;)

not (isVoid ty)
G; S |- wf e_l
---------------------------------------------- :: Return
G; S; ty (ty1, .., tyk); b |- wf (return e_l;)

% TODO (switch (e_l) s_l) :: Switch
% TODO (case integerConstant : s_l) :: Case
% TODO (default : s_l) :: Default
% TODO (id : s_l) :: Label
% TODO (goto id;) :: Goto

G; S |- wf definition1 .. G; S |- wf definitionk
------------------------------------------------- :: Declaration
G; S; ty; b |- wf (definition1, .., definitionk;)

defn
G ; S ; ty ; b |- wf s_l :: :: wfSL :: WfSL by

G; S; ty; b |- wf s
----------------------- :: Def
G; S; ty; b |- wf (a s)

defn
G ; S |- wf definition :: :: wfDefinition :: WfDefinition by

id : qs ty in G
G; S |- wf e_l
------------------- :: Def
G; S |- wf id = e_l

defn
wf G :: :: wfGamma :: WfGamma by

wf G
wfLvalue qs ty
not (isFunction ty)
isComplete ty
% Technically, this is a semantic constraint (c.f. 6.7#7).
-------------------- :: Ctx
wf (G, id : qs ty)

-------- :: Empty
wf empty

defn
S |- wf S' :: :: wfSigma :: WfSigma by

% FIXME:
% - function argument identifiers
% - indentifiers must be unique
S |- wf S'
wfLvalue [] ty
isFunction ty
empty; S; ty; false |- wf s_l
----------------------------- :: Ctx
S |- wf S', id : ty = s_l

------------- :: Empty
S |- wf empty

defn
wf program :: :: wfProgram :: WfProgram by

S |- wf S
id : ty = s_l in S
------------------ :: Def
wf id S
