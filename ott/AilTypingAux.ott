metavar P, Pi ::=
  {{ phantom }}
  {{ tex \Pi }}

funs
TypeTransformation ::=

fun pointerConvert ty' :: ty :: PointerConvert by
pointerConvert void === void
pointerConvert basicType === basicType
pointerConvert (qs ty *) === qs ty *
pointerConvert (ty [n]) === ty *
pointerConvert (ty (qs1 ty1, .., qsk tyk)) === ty (qs1 ty1, .., qsk tyk) *

defns
Jtype :: '' ::=

defn P |= n in tyRange ty :: :: tyRange :: InTyRange by

Z n in tyRange P ty
-------------------- :: Def
P |= n in tyRange ty

defn P |= ty1 <=range ty2 :: :: leTyRange :: LeTyRange by

tyRange P ty1 <= tyRange P ty2
------------------------------ :: Def
P |= ty1 <=range ty2

defn
P |= isSigned ty :: :: isSigned :: IsSigned by

-------------------------------------- :: Int
P |= isSigned (signed integerBaseType)

P |= isCharSigned
------------------ :: Char
P |= isSigned char

defn
P |= isUnsigned ty :: :: isUnsigned :: IsUnsigned by

---------------------------------------- :: Int
P |= isUnsigned unsigned integerBaseType

-------------------- :: Bool
P |= isUnsigned bool

not (P |= isCharSigned)
----------------------- :: Char
P |= isUnsigned char


defn
ty1 =rank ty2 :: :: eqRank :: EqRank by

------------------------------------------------------ :: Unsigned
signed integerBaseType =rank unsigned integerBaseType

------------------------ :: UnsignedChar
char =rank unsigned char

---------------------- :: SignedChar
char =rank signed char

isInteger ty
------------ :: Eq
ty =rank ty

defn
P |= ty1 <rank ty2 :: :: ltRank :: LtRank by

% redundant without extended integer types 
P |= isSigned ty1
P |= isSigned ty2
P |= ty1 <precision ty2
----------------------- :: Precision
P |= ty1 <rank ty2

isInteger ty
not (isBool ty)
------------------ :: Bool
P |= bool <rank ty

--------------------------------------- :: LongLong
P |= signed long <rank signed long long

--------------------------------- :: Long
P |= signed int <rank signed long

---------------------------------- :: Int
P |= signed short <rank signed int

----------------------------------- :: Short
P |= signed char <rank signed short

P |= ty1 <rank ty
P |= ty  <rank ty2
------------------ :: Transitive
P |= ty1 <rank ty2

ty1 =rank ty1'
P |= ty1' <rank ty2
-------------------- :: Congruence1
P |= ty1 <rank ty2

ty2 =rank ty2'
P |= ty1 <rank ty2'
-------------------- :: Congruence2
P |= ty1 <rank ty2

defn
P |= ty1 <=rank ty2 :: :: leRank :: LeRank by

ty1 =rank ty2
------------------- :: Eq
P |= ty1 <=rank ty2

P |= ty1 <rank ty2
------------------- :: Lt
P |= ty1 <=rank ty2

defn
isInteger ty :: :: isInteger :: 'IsInteger' by

--------------------- :: Integer
isInteger integerType

defn
isVoid ty :: :: isVoid :: IsVoid by

----------- :: Def
isVoid void

defn
isPointer ty :: :: isPointer :: IsPointer by

----------------- :: Def
isPointer qs ty *

defn
isBool ty :: :: isBool :: IsBool by

----------- :: Def
isBool bool


defn
isArithmetic ty :: :: isArithmetic :: IsArithmetic
{{ com TODO floats }}
by

isInteger ty
--------------- :: Integer
isArithmetic ty

defn
isScalar ty :: :: isScalar :: IsScalar by

isPointer ty
------------ :: Pointer
isScalar ty

isArithmetic ty
--------------- :: Arithmetic
isScalar ty

defn
isArray ty :: :: isArray :: IsArray by

-------------- :: Def
isArray ty [n]

defn
isFunction ty :: :: isFunction :: IsFunction by

-------------------------------------- :: Def
isFunction (ty (qs1 ty1, .., qsk tyk))

defn
isUnsignedOf ty1 ty2 :: :: isCorrespondingUnsigned :: IsCorrespondingUnsigned by

---------------------------------------------------------------- :: Def
isUnsignedOf (signed integerBaseType) (unsigned integerBaseType)

defn
P |= isPromotion ty1 ty2 :: :: isPromotion :: IsPromotion by

not (integerType = unsigned int)
not (integerType = signed int)
P |= integerType <=rank signed int
P |= integerType <=range signed int
----------------------------------------- :: ToSignedInt
P |= isPromotion integerType (signed int)

not (integerType = unsigned int)
not (integerType = signed int)
P |= integerType <=rank signed int
not (P |= integerType <=range signed int)
------------------------------------------- :: ToUnsignedInt
P |= isPromotion integerType (unsigned int)

---------------------------------------------- :: UnsignedInt
P |= isPromotion (unsigned int) (unsigned int)

------------------------------------------ :: SignedInt
P |= isPromotion (signed int) (signed int)

not (P |= integerType <=rank signed int)
---------------------------------------- :: Rank
P |= isPromotion integerType integerType

defn
P |= isUsualArithmetic ty1 ty2 ty :: :: isUsualArithmetic :: IsUsualArithmetic
{{ com TODO floats }}
by

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty
P |= isPromotion ty2 ty
--------------------------------- :: Eq
P |= isUsualArithmetic ty1 ty2 ty

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isSigned ty1'
P |= isSigned ty2'
P |= ty2' <rank ty1'
----------------------------------- :: GtSameSigned
P |= isUsualArithmetic ty1 ty2 ty1'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isUnsigned ty1'
P |= isUnsigned ty2'
P |= ty2' <rank ty1'
----------------------------------- :: GtSameUnsigned
P |= isUsualArithmetic ty1 ty2 ty1'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isSigned ty1'
P |= isSigned ty2'
P |= ty1' <rank ty2'
----------------------------------- :: LtSameSigned
P |= isUsualArithmetic ty1 ty2 ty2'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isUnsigned ty1'
P |= isUnsigned ty2'
P |= ty1' <rank ty2'
----------------------------------- :: LtSameUnsigned
P |= isUsualArithmetic ty1 ty2 ty2'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isSigned ty1'
P |= isUnsigned ty2'
P |= ty1' <=rank ty2'
----------------------------------- :: LtUnsigned
P |= isUsualArithmetic ty1 ty2 ty2'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isUnsigned ty1'
P |= isSigned ty2'
P |= ty2' <=rank ty1'
----------------------------------- :: GtUnsigned
P |= isUsualArithmetic ty1 ty2 ty1'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isUnsigned ty1'
P |= isSigned ty2'
P |= ty1' <=rank ty2'
P |= ty1' <=range ty2'
----------------------------------- :: LtSigned
P |= isUsualArithmetic ty1 ty2 ty2'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isSigned ty1'
P |= isUnsigned ty2'
P |= ty2' <=rank ty1'
P |= ty2' <=range ty1'
----------------------------------- :: GtSigned
P |= isUsualArithmetic ty1 ty2 ty1'

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isUnsigned ty1'
P |= isSigned ty2'
P |= ty1' <=rank ty2'
not (P |= ty1' <=range ty2')
isUnsignedOf ty2' ty2''
------------------------------------ :: LtSigned'
P |= isUsualArithmetic ty1 ty2 ty2''

isInteger ty1
isInteger ty2
P |= isPromotion ty1 ty1'
P |= isPromotion ty2 ty2'
not (ty1' = ty2')
P |= isSigned ty1'
P |= isUnsigned ty2'
P |= ty2' <=rank ty1'
not (P |= ty2' <=range ty1')
isUnsignedOf ty1' ty1''
------------------------------------ :: GtSigned'
P |= isUsualArithmetic ty1 ty2 ty1''


defn
isLvalueConvertable ty :: :: isLvalueConvertable :: IsLvalueConvertable
{{ com TODO incomplete non-array type results in undefined behaviour }}by

not (isArray ty)
isComplete ty
---------------------- :: Def
isLvalueConvertable ty


defn
isObject ty :: :: isObject :: IsObject
{{ com TODO struct/enum }}
by

------------------- :: BasicType
isObject basicType

------------- :: Void
isObject void

------------------ :: Pointer
isObject (qs ty *)

----------------- :: Array
isObject (ty [n])

defn
isComplete ty :: :: isComplete :: IsComplete
% No VLA implies that arrays are always complete.
% Note: Completeness is a property of object types, i.e
%   isComplete ty -> isObject ty
by

-------------------- :: BasicType
isComplete basicType

-------------------- :: Pointer
isComplete (qs ty *)

------------------- :: Array
isComplete (ty [n])

defn
isIncomplete ty :: :: isIncomplete :: IsIncomplete by

----------------- :: Void
isIncomplete void

defn
isModifiable qualifiers type :: :: isModifiable :: IsModifiable
{{ com TODO struct/enum types }}
by

isObject ty
not (isArray ty)
not (isIncomplete ty)
not (const in qs)
--------------------- :: Def
isModifiable qs ty

defn
isReal ty :: :: isReal :: IsReal
{{ com TODO floating }}
by

isInteger ty
------------:: Integer
isReal ty

defn
isCompatible ty1 ty2 :: :: isCompatible :: IsCompatible by

------------------ :: Eq
isCompatible ty ty

isCompatible ty ty'
isCompatible ty1 ty'1 .. isCompatible tyk ty'k
------------------------------------------------------------------------- :: Function
isCompatible (ty (qs1 ty1, .., qsk tyk)) (ty' (qs'1 ty'1, .., qs'k ty'k))

defn
isComposite ty1 ty2 ty :: :: isComposite :: IsComposite
{{ com Currently, only first rule is relevant (missing function prototypes, VLAs, arrays of unknown size).}}
by
% lemma: isComposite ty1 ty2 ty ->
%          isCompatible ty1 ty2 /\isCompatible ty1 ty /\ isCompatible ty2 ty

-------------------- :: Eq
isComposite ty ty ty

isComposite ty1 ty2 ty
---------------------------------------- :: Array
isComposite (ty1 [n]) (ty2 [n]) (ty [n])

isComposite ty' ty'' ty
isComposite ty'1 ty''1 ty1 .. isComposite ty'k ty''k tyk
------------------------------------------------------------------------------------------------------ :: Function
isComposite (ty' (qs'1 ty'1, .., qs'k ty'k)) (ty'' (qs''1 ty''1, .., qs''k ty''k)) (ty (ty1, .., tyk))
