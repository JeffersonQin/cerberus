(* generated by Ott 0.21.2 from: Implementation_.ott *)

Require Import ZArith Omega.

Require Export Range.
Require Import AilTypes.

Local Open Scope Z.

Inductive binaryMode :=
  | TwosComplement : binaryMode
  | OnesComplement : binaryMode
  | SignPlusMagnitude : binaryMode.

(* From 6.3.1.1
— The rank of a signed integer type shall be greater than the rank of any signed integer
type with less precision.
— The rank of long long int shall be greater than the rank of long int, which
shall be greater than the rank of int, which shall be greater than the rank of short
int, which shall be greater than the rank of signed char.

Suppose precision P (long long int) < precision P (long int). Then ltRank P
(long long int) (long int). But the second bullet tells us that ltRank P (long
int) (long long int). So P (long int) ≤ precision P (long long int).
*)

Definition minPrecision ibt : Z :=
  match ibt with
  | Ichar    => 8
  | Short    => 16
  | Int      => 16
  | Long     => 32
  | LongLong => 64
  end.

Record impl := mkImpl {
  binMode : binaryMode;
  isSigned_fun : integerType -> bool;
  precision : integerType -> Z;
  size_t : integerType;
  ptrdiff_t : integerType;

  isSigned_Signed   ibt : isSigned_fun (Signed   ibt) = true;
  isSigned_Bool         : isSigned_fun Bool           = false;
  isSigned_Unsigned ibt : isSigned_fun (Unsigned ibt) = false;

  isSigned_size_t    : isSigned_fun size_t    = false;
  isSigned_ptrdiff_t : isSigned_fun ptrdiff_t = true;

  minPrecision_ptrdiff_t : 16 <= precision ptrdiff_t;
  minPrecision_size_t    : 16 <= precision size_t;

  precision_Char :  precision Char = if isSigned_fun Char
                                       then precision (Signed   Ichar)
                                       else precision (Unsigned Ichar);

  minPrecision_Bool            :  1 <= precision Bool;
  minPrecision_Signed ibt      :  minPrecision ibt <= precision (Signed ibt);

  (* Follows from 6.2.6.2 #2:
       if there are M value bits in the signed type and N in the unsigned
       type, then M ≤ N
   *)
  lePrecision_Signed_Unsigned ibt    : precision (Signed   ibt) <= precision (Unsigned    ibt);
  (* unsigned char has no padding. *)
  lePrecision_Signed_Unsigned_Ichar  : precision (Signed Ichar) <  precision (Unsigned  Ichar);

  lePrecision_Signed_Long_LongLong   : precision (Signed  Long) <= precision (Signed LongLong);
  lePrecision_Signed_Int_Long        : precision (Signed   Int) <= precision (Signed     Long);
  lePrecision_Signed_Short_Int       : precision (Signed Short) <= precision (Signed      Int);
  lePrecision_Signed_Ichar_Short     : precision (Signed Ichar) <= precision (Signed    Short);

  (* Note: this cannot be inferred from the standard text but it is vital for
           integer conversions.
   *)
  lePrecision_Unsigned_Long_LongLong : precision (Unsigned  Long) <= precision (Unsigned LongLong);
  lePrecision_Unsigned_Int_Long      : precision (Unsigned   Int) <= precision (Unsigned     Long);
  lePrecision_Unsigned_Short_Int     : precision (Unsigned Short) <= precision (Unsigned      Int);
  lePrecision_Unsigned_Ichar_Short   : precision (Unsigned Ichar) <= precision (Unsigned    Short);
  lePrecision_Unsigned_Bool_Ichar    : precision Bool             <= precision (Unsigned    Ichar)
}.

Lemma precision_ge_one P it : 1 <= precision P it.
Proof.
  destruct it.
  + set (precision_Char P) as Hchar;
    case_eq (isSigned_fun P Char); intros Heq; rewrite Heq in Hchar; clear Heq;
    set (minPrecision_Signed P Ichar) as Hmin; simpl in Hmin;
    [|set (lePrecision_Signed_Unsigned P Ichar)];
    omega.
  + exact (minPrecision_Bool P).
  + set (minPrecision_Signed P ibt) as Hmin.
    destruct ibt; simpl in Hmin; omega.
  + set (minPrecision_Signed P ibt) as Hmin.
    set (lePrecision_Signed_Unsigned P ibt).
    destruct ibt; simpl in Hmin; omega.
Defined.


Lemma two_p_ge_one : forall {p}, 0 <= p -> 1 <= 2^p.
Proof.
  apply (natlike_rec2).
  + simpl; omega.
  + intros z Hge_zero IH.
    rewrite (Z.pow_succ_r _ _ Hge_zero).
    omega.
Qed.

Definition integerTypeRange_unsigned {p} : 1 <= p -> 0 <= 2^p - 1.
Proof.
  intros.
  assert (0 <= p) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed_upper {p} : 1 <= p -> 0 <= 2^(p-1) - 1.
Proof.
  intros.
  assert (0 <= p - 1) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed_lower1 {p} : 1 <= p -> -2^(p-1) <= 0.
Proof.
  intros.
  assert (0 <= p - 1) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed_lower2 {p} : 1 <= p -> -2^(p-1) + 1 <= 0.
Proof.
  intros.
  assert (0 <= p - 1) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed1 {p} : 1 <= p -> -2^(p-1) <= 2^(p-1) - 1.
Proof.
  intros Hge_one.
  set (integerTypeRange_signed_upper  Hge_one).
  set (integerTypeRange_signed_lower1 Hge_one).
  apply (Z.le_trans _ 0 _); assumption.
Qed.

Definition integerTypeRange_signed2 {p} : 1 <= p -> -2^(p-1) + 1 <= 2^(p-1) - 1.
Proof.
  intros Hge_one.
  set (integerTypeRange_signed_upper  Hge_one).
  set (integerTypeRange_signed_lower2 Hge_one).
  apply (Z.le_trans _ 0 _); assumption.
Qed.
