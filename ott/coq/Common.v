(* generated by Ott 0.21.2 from: Common_.ott *)
Require Relations.
Require List.

Open Scope type.

Definition neg P := P -> False.
Definition boolSpec (b : bool) p := if b then p else neg p.

Lemma boolSpec_true {p} : boolSpec true p = p.
Proof. reflexivity. Defined.

Lemma boolSpec_false {p} : boolSpec false p = neg p.
Proof. reflexivity. Defined.

Ltac boolSpec_destruct :=
  match goal with
  | [ H : boolSpec ?b _ |- _] =>
      match b with
      | true  => fail 1
      | false => fail 1
      | _     =>
          let Heq := fresh in
          case_eq b; intros Heq; rewrite Heq in *; clear Heq; simpl in H
      end
  end.

Ltac boolSpec_simpl :=
  repeat match goal with
  | [H : boolSpec ?B _ |- _] =>
      match B with
      | true  => rewrite boolSpec_true  in H
      | false => rewrite boolSpec_false in H
      | _     => let b := fresh in
                 progress (set B as b in H; simpl in b; subst b)
      end
  end.

Definition decidable P := P + neg P.
Class Decision (P : Type) := decision : decidable P.

Definition boolSpec_Decision {b : bool} {P : Type} (B : boolSpec b P) : Decision P.
Proof. destruct b; [left | right]; assumption. Defined.
Definition boolSpec_elim1 {b : bool} {P : Type} : boolSpec b P -> b = true -> P.
Proof. intros; subst; assumption. Defined.
Definition boolSpec_elim2 {b : bool} {P : Type} : boolSpec b P -> b = false -> neg P.
Proof. intros; subst; assumption. Defined.

Definition bool_of_decision {P} : Decision P -> bool :=
  fun d => match d with
           | inl _ => true
           | inr _ => false
           end.

Definition relation A := A -> A -> Type.
Definition complement {A} (R : relation A) x y := neg (R x y).
Class Reflexive {A} (R : relation A) :=
  reflexive x : R x x.
Class Irreflexive {A} (R : relation A) :=
  irreflexive : Reflexive (complement R).
Class Asymmetric {A} (R : relation A) :=
  asymmetric x y : R x y -> R y x -> False.

Class DecidableRelation {A} (R : Relation_Definitions.relation A) :=
  decide : forall x y : A, Decision (R x y).
Class DecidableEq (A : Type) :=
  Decidable_Equality :> DecidableRelation (@eq A).

Ltac finish t := solve [intros; inversion 1; solve [contradiction | congruence]
                       | inversion 1; solve [contradiction | congruence]
                       | congruence
                       | constructor
                       | t].
Ltac decide_destruct :=
  match goal with
  | [ |- context[match ?d with _ => _ end] ] =>
      match type of d with
      | bool => (
          let H := fresh "H" in
          assert {H : bool & d = H};
          [ exists d; reflexivity 
          | destruct H as [H Heq];
            replace d with H;
            destruct H;
            revert Heq ]
          ) || fail 1
      | _ => destruct d
      end
  | [ |- context[decide ?a ?b] ] => destruct (decide a b)
  | [ |- ?a = ?a -> _] => intros _
  end.
Ltac scatter d := subst; simpl; first [d | decide_destruct].
Ltac finish_scatter_loop f d := repeat (first [finish f | scatter d | constructor]).
Ltac my_auto' f d := repeat (subst; simpl; auto; try (now finish_scatter_loop f d); try scatter d).
Ltac my_auto := my_auto' fail fail.
Obligation Tactic := my_auto.

Definition Decision_elim {P} {A} : Decision P -> (P -> A) -> (neg P -> A) -> A :=
  fun d pos neg =>
    match d with
    | inl P => pos P
    | inr N => neg N
    end.

Ltac destruct_decide :=
  match goal with
  | [ |- context[decide ?a ?b] ] => destruct (decide a b)
  end.

Lemma decision_sumbool {P : Prop} : Decision P -> {P} + {~P}.
Proof. destruct 1; auto. Defined.

Lemma decision_sumbool_inv {P : Prop} : {P} + {~P} -> Decision P.
Proof. destruct 1; [left | right]; auto. Defined.

Lemma decidableRelation_sumbool {A} {R : Relation_Definitions.relation A} : DecidableRelation R -> forall x y, {R x y} + {~R x y}.
Proof. intros dec_R. intros x y. destruct (dec_R x y); auto. Defined.

Lemma decidableRelation_sumbool_inv {A} {R : Relation_Definitions.relation A} : (forall x y, {R x y} + {~R x y}) -> DecidableRelation R.
Proof. intros sum_R. intros x y. destruct (sum_R x y); [left | right]; auto. Defined.

Definition decidableEq_sumbool {A} : DecidableEq A -> (forall x y : A, {x = y} + {x <> y}) := decidableRelation_sumbool.
Definition decidableEq_sumbool_inv {A} : (forall x y : A, {x = y} + {x <> y}) -> DecidableEq A := decidableRelation_sumbool_inv.

Program Instance makeDecidableRelation {A} {R : Relation_Definitions.relation A} `{d : forall x y : A, Decision (R x y)} : DecidableRelation R.
Program Instance makeDecidableEq       {A}                  `{d : forall x y : A, Decision (x = y)} : DecidableEq A.

Ltac decision_eq :=
  match goal with [ |- Decision (eq ?a ?b) ] =>
    match a with appcontext C1 [?c ?t1] =>
    match b with appcontext C2 [ c ?t2] =>
      let H := fresh in
      assert (Decision (t1 = t2)) as H by apply decide;
      destruct H;
      [subst | right; inversion 1; contradiction]
    end end
  end.

Ltac decision_eq_aux :=
  let IH := fresh in fix IH 1;
  match goal with [ |- forall x y, _] =>
    destruct x; destruct y; try solve [left; reflexivity | right; inversion 1]
  end.

Ltac decidable_eq :=
  match goal with [ |- DecidableEq ?A] =>
    cut (forall x y : A, Decision (x = y)); [now trivial|]
  end.

Ltac dec_eq :=
  decidable_eq;
  decision_eq_aux;
  repeat decision_eq;
  left; reflexivity.

Instance bool_DecEq : DecidableEq bool.
Proof. dec_eq. Defined.

Instance list_DecEq {A} `{dec_A : DecidableEq A} : DecidableEq (list A).
Proof. dec_eq. Defined.

Instance pair_DecEq {A B : Type} `{dec_A : DecidableEq A} `{dec_B : DecidableEq B} : DecidableEq (A * B).
Proof. dec_eq. Defined. 

Instance option_DecEq {A : Type} (dec_A : DecidableEq A) : DecidableEq (option A).
Proof. dec_eq. Defined. 

Require Import RelationClasses.

Class Trichotomous {A} (R: Relation_Definitions.relation A) := {
  trichotomous : forall x y : A, {R x y} + {R y x} + {x = y}
}.

Class StrictTotalOrder {A} (R : Relation_Definitions.relation A) := {
  strict_STO       :> StrictOrder R ;
  trichotomous_STO :> Trichotomous R
}.

Ltac hyp H :=
  match goal with
  | [ H : _ |- _ ] => idtac
  | _ => fail 1
  end.

Ltac unfold_goal :=
  match goal with
  | [ |- appcontext[?d] ] =>
      unfold d
  end.

Ltac notHyp P :=
  match goal with
  | [ _ : P |- _ ] => fail 1
  | _ => idtac
  end.

Ltac destruct_sum :=
  repeat match goal with
  | [ H : sum _ _ |- _          ] => destruct H
  | [             |- _ + _ -> _ ] => destruct 1
  end.

Ltac apply_ctx :=
  match goal with
  | [ f : _ -> ?t |- ?t ] => apply f
  end.

