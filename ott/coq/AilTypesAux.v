(* generated by Ott 0.21.2 from: AilTypesAux_.ott *)
Add LoadPath "../../../ott/coq".

(* Equations
Require Import Equations.
*)
Require Import Arith.
Require Import Bool.
Require Import List.
Require Import ott_list_core.

Require Import Common.
Require Import ZArith.
Require Import Omega.
Require Import Range AilTypes.
Require Import Implementation.

Require Import Coq.Classes.RelationClasses.

(** definitions *)

(** funs TypeTransformation *)
Fixpoint pointerConvert (x1:type) : type:=
  match x1 with
  | Void => Void
  | (Basic bt) => (Basic bt)
  |  (Pointer qs ty)  => (Pointer qs ty)
  |  (Array ty n)  => (Pointer  nil  ty)
  |  (Function ty qs_ty_list)  => (Pointer  nil  (Function ty qs_ty_list))
end.

(** definitions *)

(* defns JisInteger *)
Inductive isInteger : type -> Set :=    (* defn isInteger *)
 | IsInteger : forall (it:integerType),
     isInteger (Basic (Integer it)).
(** definitions *)

(*Equations
isInteger_dec t : Decision (isInteger t) :=
isInteger_dec (Basic (Integer _)) := inl (IsInteger _);
isInteger_dec _                   := inr _.
*)

Definition isInteger_fun t :=
  match t with
  | Basic (Integer _) => true
  | _ => false
  end.

Lemma isInteger_fun_correct t : boolSpec (isInteger_fun t) (isInteger t).
Proof. destruct t; my_auto. Qed.

Instance isInteger_dec t : Decision (isInteger t) := boolSpec_Decision (isInteger_fun_correct t).

(* defns JisVoid *)
Inductive isVoid : type -> Prop :=    (* defn isVoid *)
 | IsVoid : 
     isVoid Void.
(** definitions *)

(* Equations
isVoid_dec t : Decision (isVoid t) :=
isVoid_dec Void := inl IsVoid;
isVoid_dec _    := inr _.
*)

Definition isVoid_fun t :=
  match t with
  | Void => true
  | _ => false
  end.

Lemma isVoid_fun_correct t : boolSpec (isVoid_fun t) (isVoid t).
Proof. destruct t; my_auto. Qed.

Instance isVoid_dec t : Decision (isVoid t) := boolSpec_Decision (isVoid_fun_correct t).

(* defns JisPointer *)
Inductive isPointer : type -> Prop :=    (* defn isPointer *)
 | IsPointer : forall (qs:qualifiers) (ty:type),
     isPointer (Pointer qs ty).
(** definitions *)

(* Equations
isPointer_dec t : Decision (isPointer t) :=
isPointer_dec (Pointer _ _) := inl (IsPointer _ _);
isPointer_dec _             := inr _.
*)

Definition isPointer_fun t :=
  match t with
  | Pointer _ _ => true
  | _ => false
  end.

Lemma isPointer_fun_correct t : boolSpec (isPointer_fun t) (isPointer t).
Proof. destruct t; my_auto. Qed.

Instance isPointer_dec t : Decision (isPointer t) := boolSpec_Decision (isPointer_fun_correct t).

(* defns JisBool *)
Inductive isBool : integerType -> Prop :=    (* defn isBool *)
 | IsBool : 
     isBool Bool.

(* Equations
isBool_dec it : Decision (isBool it) :=
isBool_dec Bool := inl IsBool;
isBool_dec _    := inr _.
*)

Definition isBool_fun it :=
  match it with
  | Bool => true
  | _ => false
  end.

Lemma isBool_fun_correct it : boolSpec (isBool_fun it) (isBool it).
Proof. destruct it; my_auto. Qed.

Instance isBool_dec t : Decision (isBool t) := boolSpec_Decision (isBool_fun_correct t).


(* defns JisSigned *)
Inductive isSigned : impl -> integerType -> Prop :=    (* defn isSigned *)
 | IsSignedInt : forall (P:impl) (ibt:integerBaseType),
     isSigned P  (Signed ibt) 
 | IsSignedChar : forall (P:impl),
      Implementation.isCharSigned  P  = true  ->
     isSigned P Char.

(* Equations
isSigned_dec P it : Decision (isSigned P it) :=
isSigned_dec P (Signed _) := inl (IsSignedInt P _) ;
isSigned_dec P Char with decide (Implementation.isCharSigned P) true := {
 | inl E  := inl (IsSignedChar P E) ;
 | inr _  := inr _};
isSigned_dec P _ := inr _.
Next Obligation. destruct it; my_auto. Qed.
*)

Definition isSigned_fun P it : bool :=
  match it with
  | Signed _ => true
  | Char => Implementation.isCharSigned P
  | _ => false
  end.

Lemma isSigned_fun_correct P it : boolSpec (isSigned_fun P it) (isSigned P it).
Proof. destruct it; unfold_goal; my_auto. Qed.

Instance isSigned_dec P it : Decision (isSigned P it) := boolSpec_Decision (isSigned_fun_correct P it).

Inductive isSignedType : integerType -> Prop :=    (* defn isSigned *)
 | IsSignedType : forall (ibt:integerBaseType),
     isSignedType (Signed ibt).


Lemma isSigned_incl {P} {it} : isSignedType it -> isSigned P it.
Proof. inversion 1; my_auto. Qed.

(* Equations
isSignedType_dec it : Decision (isSignedType it) :=
isSignedType_dec (Signed _) := inl (IsSignedType _) ;
isSignedType_dec _          := inr _                .
*)

Definition isSignedType_fun it : bool :=
  match it with
  | Signed _ => true
  | _ => false
  end.

Lemma isSignedType_fun_correct it : boolSpec (isSignedType_fun it) (isSignedType it).
Proof. do 2 unfold_goal; my_auto. Qed.

Instance isSignedType_dec it : Decision (isSignedType it) := boolSpec_Decision (isSignedType_fun_correct it).

(* defns JisUnsigned *)
Inductive isUnsigned : impl -> integerType -> Prop :=    (* defn isUnsigned *)
 | IsUnsignedInt : forall (P:impl) (ibt:integerBaseType),
     isUnsigned P (Unsigned ibt)
 | IsUnsignedBool : forall (P:impl),
     isUnsigned P Bool
 | IsUnsignedChar : forall (P:impl),
      ~ (   Implementation.isCharSigned  P  = true   )  ->
     isUnsigned P Char.
(** definitions *)

(* Equations
isUnsigned_dec P it : Decision (isUnsigned P it) :=
isUnsigned_dec P (Unsigned _) := inl (IsUnsignedInt P _)   ;
isUnsigned_dec P Bool         := inl (IsUnsignedBool P)    ;
isUnsigned_dec P Char
  with decide (Implementation.isCharSigned P) true := {
  | inl _ := inr _                     ;
  | inr _ := inl (IsUnsignedChar P _) };
isUnsigned_dec P _ := inr _ .
Next Obligation. destruct it; my_auto. Qed.
*)

Definition isUnsigned_fun P it : bool :=
  match it with
  | Unsigned _ => true
  | Bool => true
  | Char => negb (Implementation.isCharSigned P)
  | _ => false
  end.

Lemma isUnsigned_fun_correct P it : boolSpec (isUnsigned_fun P it) (isUnsigned P it).
Proof. do 3 unfold_goal. my_auto. Qed.

Instance isUnsigned_dec P it : Decision (isUnsigned P it) := boolSpec_Decision (isUnsigned_fun_correct P it).

Inductive isUnsignedType : integerType -> Prop :=    (* defn isUnsigned *)
 | IsUnsignedTypeInt : forall (ibt:integerBaseType),
     isUnsignedType (Unsigned ibt)
 | IsUnsignedTypeBool : isUnsignedType Bool.

Lemma isUnsigned_incl {P} {it} : isUnsignedType it -> isUnsigned P it.
Proof. inversion 1; my_auto. Qed.

(* Equations
isUnsignedType_dec it : Decision (isUnsignedType it) :=
isUnsignedType_dec (Unsigned _) := inl (IsUnsignedTypeInt _) ;
isUnsignedType_dec Bool         := inl (IsUnsignedTypeBool)  ;
isUnsignedType_dec _            := inr _                     .
*)

Definition isUnsignedType_fun it : bool :=
  match it with
  | Unsigned _ => true
  | Bool => true
  | _ => false
  end.

Lemma isUnsignedType_fun_correct it : boolSpec (isUnsignedType_fun it) (isUnsignedType it).
Proof. do 3 unfold_goal; my_auto. Qed.

Instance isUnsignedType_dec it : Decision (isUnsignedType it) := boolSpec_Decision (isUnsignedType_fun_correct it).

Lemma two_p_ge_one : forall {p}, 0 <= p -> 1 <= 2^p.
Proof.
  apply (natlike_rec2).
  + simpl; omega.
  + intros z Hge_zero IH.
    rewrite (Z.pow_succ_r _ _ Hge_zero).
    omega.
Qed.

Definition integerTypeRange_unsigned {p} : 1 <= p -> 0 <= 2^p - 1.
Proof.
  intros.
  assert (0 <= p) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed_upper {p} : 1 <= p -> 0 <= 2^(p-1) - 1.
Proof.
  intros.
  assert (0 <= p - 1) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed_lower1 {p} : 1 <= p -> -2^(p-1) <= 0.
Proof.
  intros.
  assert (0 <= p - 1) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed_lower2 {p} : 1 <= p -> -2^(p-1) + 1 <= 0.
Proof.
  intros.
  assert (0 <= p - 1) as Hge_zero by omega.
  set (two_p_ge_one Hge_zero).
  omega.
Qed.

Definition integerTypeRange_signed1 {p} : 1 <= p -> -2^(p-1) <= 2^(p-1) - 1.
Proof.
  intros Hge_one.
  set (integerTypeRange_signed_upper  Hge_one).
  set (integerTypeRange_signed_lower1 Hge_one).
  apply (Z.le_trans _ 0 _); assumption.
Qed.

Definition integerTypeRange_signed2 {p} : 1 <= p -> -2^(p-1) + 1 <= 2^(p-1) - 1.
Proof.
  intros Hge_one.
  set (integerTypeRange_signed_upper  Hge_one).
  set (integerTypeRange_signed_lower2 Hge_one).
  apply (Z.le_trans _ 0 _); assumption.
Qed.

Definition integerTypeRange P it :=
  let prec := Implementation.precision P it in
  if isUnsigned_fun P it then
    @mkRange 0 (2^prec - 1) (integerTypeRange_unsigned (precision_ge_one P _))
  else
      match Implementation.binMode P with
      | Implementation.TwosComplement    => @mkRange (-2^(prec - 1))     (2^(prec - 1) - 1) (integerTypeRange_signed1 (precision_ge_one P _))
      | Implementation.OnesComplement    => @mkRange (-2^(prec - 1) + 1) (2^(prec - 1) - 1) (integerTypeRange_signed2 (precision_ge_one P _))
      | Implementation.SignPlusMagnitude => @mkRange (-2^(prec - 1) + 1) (2^(prec - 1) - 1) (integerTypeRange_signed2 (precision_ge_one P _))
      end.

Lemma integerTypeRange_precision_Signed P it1 it2 :
  isSigned P it1 ->
  isSigned P it2 ->
  precision P it1 <= precision P it2 ->
  le (integerTypeRange P it1) (integerTypeRange P it2).
Proof.
  inversion 1;
  inversion 1;
  subst; intros;
  constructor;
  destruct_integerBaseType;
  unfold integerTypeRange;
  abstract (
  destruct (binMode P);
  match goal with 
  | [ H : isCharSigned _ = true |- _] => unfold isUnsigned_fun; rewrite_all H; simpl
  | _ => idtac
  end;
  repeat rewrite max_mkRange;
  repeat rewrite min_mkRange;
  solve
        [ apply Z.sub_le_mono  ; [|omega];
          apply Z.pow_le_mono_r;   omega ;
          apply Z.pow_le_mono_r;   omega
        | apply (proj1 (Z.opp_le_mono _ _));
          apply Z.pow_le_mono_r;  omega
        | apply Z.add_le_mono;[|omega];
          apply (proj1 (Z.opp_le_mono _ _));
          apply Z.pow_le_mono_r; omega
        | omega]).
Qed.

Lemma integerTypeRange_precision_Signed_inv P it1 it2 :
  isSigned P it1 ->
  isSigned P it2 ->
  le (integerTypeRange P it1) (integerTypeRange P it2) ->
  precision P it1 <= precision P it2.
Proof.
  set (precision_ge_one P it1).
  set (precision_ge_one P it2).
  inversion 1;
  inversion 1;
  inversion 1;
  subst;
  match goal with
  | [ H : max (_ _ ?it1) <= max (_ _ ?it2) |- _] =>
      unfold integerTypeRange    in H;
      unfold isUnsigned_fun      in H;
      destruct (binMode P);
      match goal with 
      | [ R : isCharSigned _ = true |- _] => repeat rewrite R in H; simpl in H
      | _ => idtac
      end;
      repeat rewrite max_mkRange in H;
      apply (Z.le_le_sub_lt 1 1 _ _ (Z.le_refl 1)) in H;
      apply (Z.le_le_sub_lt 1 1 _ _ (Z.le_refl 1));
      apply (Z.pow_le_mono_r_iff 2); omega
  end.
Qed.

Lemma integerTypeRange_precision_Unsigned P it1 it2 :
  isUnsigned P it1 ->
  isUnsigned P it2 ->
  precision P it1 <= precision P it2 ->
  le (integerTypeRange P it1) (integerTypeRange P it2).
Proof.
  inversion 1;
  inversion 1;
  subst; intros;
  constructor;
  unfold integerTypeRange;
  match goal with 
  | [ H : isCharSigned _ <> true |- _] => unfold isUnsigned_fun; rewrite_all (not_true_is_false _ H)
  | _ => idtac
  end;
  simpl;
  repeat rewrite max_mkRange;
  repeat rewrite min_mkRange;
  solve
    [ apply Z.sub_le_mono  ; [|omega];
      apply Z.pow_le_mono_r;   omega
    | omega].
Qed.

Lemma integerTypeRange_precision_Unsigned_inv P it1 it2 :
  isUnsigned P it1 ->
  isUnsigned P it2 ->
  le (integerTypeRange P it1) (integerTypeRange P it2) ->
  precision P it1 <= precision P it2.
Proof.
  set (precision_ge_one P it1).
  set (precision_ge_one P it2).
  inversion 1;
  inversion 1;
  inversion 1;
  subst;
  match goal with
  | [ H : max (_ _ ?it1) <= max (_ _ ?it2) |- _] =>
      unfold integerTypeRange    in H;
      unfold isUnsigned_fun      in H;
      match goal with 
      | [ R : isCharSigned _ <> true |- _] => repeat rewrite (not_true_is_false _ R) in H; simpl in H
      | _ => idtac
      end;
      repeat rewrite max_mkRange in H;
      apply (Z.pow_le_mono_r_iff 2); omega
  end.
Qed.

Lemma precision_signed_ge_two {P} {it} : isSigned P it -> 2 <= precision P it.
Proof.
  destruct 1;
  match goal with
  | [H : isCharSigned ?P = true |- _] =>
      let Hprec := fresh in
      set (precision_Char P) as Hprec; rewrite H in Hprec; simpl in Hprec;
      set (minPrecision_Signed_Ichar    P)
  | [|- _ <= precision ?P _] =>
    destruct_integerBaseType;
    set (minPrecision_Signed_Ichar    P);
    set (minPrecision_Signed_Short    P);
    set (minPrecision_Signed_Int      P);
    set (minPrecision_Signed_Long     P);
    set (minPrecision_Signed_LongLong P)
  end;
  omega.
Qed.

Lemma integerTypeRange_precision_Signed_Unsigned P it1 it2 :
  isSigned   P it1 ->
  isUnsigned P it2 ->
  neg(le (integerTypeRange P it1) (integerTypeRange P it2)).
Proof.
  inversion 1;
  inversion 1;
  inversion 1;
  subst;
  match goal with
  | [ H : isSigned _ _ |- _] =>
      set (precision_signed_ge_two H)
  end;
  match goal with
  | [ H : min (integerTypeRange P _) <= min (integerTypeRange P _) |- _] =>
      try destruct_integerBaseType;
      unfold integerTypeRange in H;
      match goal with 
      | [ R : isCharSigned _  = true |- _] => unfold isUnsigned_fun in H; rewrite_all R
      | [ R : isCharSigned _ <> true |- _] => unfold isUnsigned_fun in H; rewrite_all (not_true_is_false _ R)
      | _ => idtac
      end;
      destruct (binMode P);
      simpl in H;
      repeat rewrite min_mkRange in H
  end;
  match goal with
  | [ H : true <> true |- False] =>
      apply H; reflexivity
  | [ H : 0 <= - 2 ^ (precision P ?it - 1) |- _] =>
      rewrite <- Z.opp_0 in H;
      apply Z.opp_le_mono in H;
      set (integerTypeRange_signed_upper (precision_ge_one P it));
      omega
  | [ H : 0 <= - 2 ^ (precision P _ - 1) + 1 |- _] =>
      apply (Z.sub_le_mono_r _ _ 1) in H;
      rewrite <- Z.add_sub_assoc in H;
      rewrite Z.sub_diag in H;
      rewrite Z.sub_0_l in H;
      rewrite Zplus_0_r in H;
      rewrite <- (Z.pow_0_r 2) in H at 1;
      apply (proj2 (Z.opp_le_mono _ _)) in H;
      apply Z.pow_le_mono_r_iff in H; omega
  end.
Qed.

Lemma integerTypeRange_precision_Unsigned_Signed P it1 it2 :
  isUnsigned P it1 ->
  isSigned   P it2 ->
  precision P it1 < precision P it2 ->
  le (integerTypeRange P it1) (integerTypeRange P it2).
Proof.
  inversion 1;
  inversion 1;
  subst; intros;
  constructor;
  unfold integerTypeRange;
  unfold isUnsigned_fun;
  match goal with 
  | [ R    : isCharSigned ?P =  true
    , notR : isCharSigned ?P <> true |- _] => destruct (notR R)
  | [ R : isCharSigned _  = true |- _] => rewrite_all R                      ; simpl
  | [ R : isCharSigned _ <> true |- _] => rewrite_all (not_true_is_false _ R); simpl
  | _ => idtac
  end;
  destruct (binMode P);
  match goal with
  | [|- min _ <= min _ ] =>
      repeat rewrite min_mkRange;
      solve [
          apply integerTypeRange_signed_lower1; apply precision_ge_one
        | apply integerTypeRange_signed_lower2; apply precision_ge_one]
  | [|- max _ <= max _ ] =>
      repeat rewrite max_mkRange;
      apply Z.sub_le_mono_r;
      apply Z.pow_le_mono_r; omega
  end.
Qed.

Lemma integerTypeRange_precision_Unsigned_Signed_inv P it1 it2 :
  isUnsigned P it1 ->
  isSigned   P it2 ->
  le (integerTypeRange P it1) (integerTypeRange P it2) ->
  precision P it1 < precision P it2.
Proof.
  set (precision_ge_one P it2).
  inversion 1;
  inversion 1;
  inversion 1;
  subst;
  match goal with
  | [H : max _ <= max _|- _] =>
    unfold integerTypeRange in H;
    unfold isUnsigned_fun   in H;
    match goal with 
    | [ R    : isCharSigned _ =  true
      , notR : isCharSigned _ <> true |- _] => destruct (notR R)
    | [ R    : isCharSigned _  = true |- _] => rewrite R                       in H; simpl in H
    | [ R    : isCharSigned _ <> true |- _] => rewrite (not_true_is_false _ R) in H; simpl in H
    | _ => idtac
    end;
    destruct (binMode P);
    repeat rewrite max_mkRange in H;
    apply (proj2 (Z.sub_le_mono_r _ _ 1)) in H;
    apply Z.lt_le_pred;
    rewrite <- Z.sub_1_r;
    apply (Z.pow_le_mono_r_iff 2); omega
  end.
Qed.

Lemma integerTypeRange_precision_Unsigned_Signed_eq P ibt :
  neg (precision P (Unsigned ibt) = precision P (Signed ibt)) ->
  neg (le (integerTypeRange P (Unsigned ibt)) (integerTypeRange P (Signed ibt))).
Proof.
  intros Hneq HleRange.
  assert (neg (precision P (Unsigned ibt) < precision P (Signed ibt))) as Hnlt.
    apply (Zle_not_lt _ _ (lePrecision_Signed_Unsigned P ibt)).
  exact (Hnlt (integerTypeRange_precision_Unsigned_Signed_inv P _ _ (IsUnsignedInt P ibt) (IsSignedInt P ibt) HleRange)).
Qed.

(*
Section TypeRanges.
Definition rangeSignedInt := {|min := -32767; max:= 32767|}.
Definition rangeUnsignedInt := {|min := 0; max:= 65535|}.
Definition rangeSignedLong := {|min := -2147483647; max:= 2147483647|}.
Definition rangeUnsignedLong := {|min := 0; max:=  4294967295|}.
Definition rangeSignedLongLong := {|min := -9223372036854775807; max:= 9223372036854775807|}.
Definition rangeUnsignedLongLong := {|min := 0; max:= 18446744073709551615|}.
End TypeRanges.

Section Properties.
Axiom precisionPos: forall P t (H : isInteger t), (precision P H > 0)%Z.
Axiom sizeTUnsigned: forall P, isUnsigned P (size_t P).
Axiom ptrdiffTInteger: forall P, isInteger (ptrdiff_t P).
End Properties.
*)

(** definitions *)

(* defns JinTypeRange *)
Inductive inIntegerTypeRange : impl -> nat -> integerType -> Prop :=    (* defn inTypeRange *)
 | InIntegerTypeRange : forall (P:impl) (n:nat) (it:integerType),
     memNat  n    (integerTypeRange  P   it )  ->
     inIntegerTypeRange P n it.
(** definitions *)

(* Equations
inIntegerTypeRange_dec P n it : Decision (inIntegerTypeRange P n it) :=
inIntegerTypeRange_dec P n it with mem_dec (Z_of_nat n) (integerTypeRange P it) := {
  | inl M := inl (InIntegerTypeRange P n it M)  ;
  | inr _ := inr _                      };
inIntegerTypeRange_dec P n _ := inr _.
*)

Definition inIntegerTypeRange_fun P n it : bool :=
  memNat_fun n (integerTypeRange P it).

Lemma inIntegerTypeRange_fun_correct P n it : boolSpec (inIntegerTypeRange_fun P n it) (inIntegerTypeRange P n it).
Proof.
  do 3 unfold_goal; my_auto; intros Heq;
  [ set (boolSpec_elim1 (memNat_fun_correct _ _) Heq)
  | set (boolSpec_elim2 (memNat_fun_correct _ _) Heq)];
  my_auto.
Qed.

(* defns JleTypeRange *)
Inductive leIntegerTypeRange : impl -> integerType -> integerType -> Prop :=    (* defn leTypeRange *)
 | LeIntegerTypeRange : forall (P:impl) (it1 it2:integerType),
     le  (integerTypeRange  P   it1 )   (integerTypeRange  P   it2 )  ->
     leIntegerTypeRange P it1 it2.
(** definitions *)

(* Equations
leIntegerTypeRange_dec P it1 it2 : Decision (leIntegerTypeRange P it1 it2) :=
leIntegerTypeRange_dec P it1 it2 with le_dec (integerTypeRange P it1) (integerTypeRange P it2) := {
  | inl L := inl (LeIntegerTypeRange P it1 it2 L) ;
  | inr _ := inr _                               };
leIntegerTypeRange_dec _ _ _ := inr _.
*)

(* Be more clever! *)
Definition leIntegerTypeRange_fun P it1 it2 : bool :=
  match it1, it2 with
  | Char             , Char              => true
  | Char             , Signed   Ichar    => isCharSigned P
  | Char             , Signed   ibt      => orb (isCharSigned P)
                                                (Z.ltb (precision P Char) (precision P (Signed ibt)))
  | Signed Ichar     , Char              => isCharSigned P
  | Signed ibt       , Char              => andb (isCharSigned P)
                                                 (Z.eqb (precision P (Signed ibt)) (precision P Char))
  | Unsigned Ichar   , Char              => negb (isCharSigned P)
  | Unsigned ibt     , Char              => andb (negb (isCharSigned P))
                                                 (Z.eqb (precision P (Unsigned ibt)) (precision P Char))
  | Char             , Unsigned _        => negb (isCharSigned P)
  | Char             , Bool              => andb (negb (isCharSigned P))
                                                 (Z.eqb (precision P Char) (precision P Bool))
  | Bool             , Char              => orb (negb (isCharSigned P))
                                                (Z.ltb (precision P Bool) (precision P Char))

  | Signed   Ichar   , Signed   _        => true
  | Signed   Short   , Signed   Short    => true
  | Signed   Short   , Signed   Int      => true
  | Signed   Short   , Signed   Long     => true
  | Signed   Short   , Signed   LongLong => true
  | Signed   Int     , Signed   Int      => true
  | Signed   Int     , Signed   Long     => true
  | Signed   Int     , Signed   LongLong => true
  | Signed   Long    , Signed   Long     => true
  | Signed   Long    , Signed   LongLong => true
  | Signed   LongLong, Signed   LongLong => true
  | Signed   ibt1    , Signed   ibt2     => Z.eqb (precision P (Signed ibt1))
                                                  (precision P (Signed ibt2))

  | Bool             , Bool              => true
  | Bool             , Unsigned _        => true
  | Unsigned Ichar   , Unsigned _        => true
  | Unsigned Short   , Unsigned Short    => true
  | Unsigned Short   , Unsigned Int      => true
  | Unsigned Short   , Unsigned Long     => true
  | Unsigned Short   , Unsigned LongLong => true
  | Unsigned Int     , Unsigned Int      => true
  | Unsigned Int     , Unsigned Long     => true
  | Unsigned Int     , Unsigned LongLong => true
  | Unsigned Long    , Unsigned Long     => true
  | Unsigned Long    , Unsigned LongLong  => true
  | Unsigned LongLong, Unsigned LongLong => true
  | Unsigned ibt     , Bool              => Z.eqb (precision P (Unsigned ibt))
                                                  (precision P Bool)
  | Unsigned ibt1    , Unsigned   ibt2   => Z.eqb (precision P (Unsigned ibt1))
                                                  (precision P (Unsigned ibt2))

  | Signed   _       , Bool              => false
  | Signed   _       , Unsigned _        => false

  | Bool             , Signed   ibt2     => Z.ltb (precision P Bool)
                                                  (precision P (Signed   ibt2))
  | Unsigned _       , Signed   Ichar    => false
  | Unsigned Short   , Signed   Short    => false
  | Unsigned Int     , Signed   Int      => false
  | Unsigned Long    , Signed   Long     => false
  | Unsigned LongLong, Signed   LongLong => false
  | Unsigned ibt1    , Signed   ibt2     => Z.ltb (precision P (Unsigned ibt1))
                                                  (precision P (Signed   ibt2))
  end.

Lemma Zeqb_correct x y : boolSpec (Z.eqb x y) (x = y).
Proof.
  case_eq (Z.eqb x y); intros Heq.
  + exact (proj1 (Z.eqb_eq  _ _) Heq).
  + exact (proj1 (Z.eqb_neq _ _) Heq).
Qed.

Lemma Zltb_correct x y : boolSpec (Z.ltb x y) (x < y).
Proof.
  case_eq (Z.ltb x y); intros Heq.
  + exact (proj1 (Z.ltb_lt  _ _) Heq).
  + exact (proj1 (Z.ltb_nlt _ _) Heq).
Qed.

Lemma leIntegerTypeRange_fun_correct P it1 it2 : boolSpec (leIntegerTypeRange_fun P it1 it2) (leIntegerTypeRange P it1 it2).
Proof.
  set (isUnsigned_fun_correct P it1) as Hunsigned1.
  set (isUnsigned_fun_correct P it2) as Hunsigned2.
  set (isSigned_fun_correct   P it1) as Hsigned1.
  set (isSigned_fun_correct   P it2) as Hsigned2.
  destruct_integerType;
  unfold isUnsigned_fun in *;
  unfold isSigned_fun   in *;
  unfold leIntegerTypeRange_fun;
  match goal with
  | [ _ : context [isCharSigned ?P] |- _] =>
      let Heq := fresh in
      set (precision_Char P);
      set (lePrecision_Signed_Unsigned_Ichar P);
      case_eq (isCharSigned P); intros Heq; rewrite Heq in *
  | _ => idtac
  end;
  boolSpec_simpl; simpl;
  match goal with
  | [|- context[Z.ltb ?x ?y] ] =>
      let Heq := fresh in
      set (Zltb_correct x y);
      case_eq (Z.ltb x y); intros Heq; rewrite Heq in *; clear Heq
  | [|- context[Z.eqb ?x ?y] ] =>
      let Heq := fresh in
      set (Zeqb_correct x y);
      case_eq (Z.eqb x y); intros Heq; rewrite Heq in *; clear Heq
  | _ => idtac
  end; boolSpec_simpl; simpl;
  try
  match goal with
  | [|- leIntegerTypeRange _ ?it ?it ] =>
      constructor; constructor; apply Z.le_refl
  | [ Hunsigned1 : isUnsigned ?P ?it1, Hunsigned2 : isUnsigned ?P ?it2 |- leIntegerTypeRange ?P ?it1 ?it2 ] =>
      constructor;
      apply (integerTypeRange_precision_Unsigned P it1 it2 Hunsigned1 Hunsigned2);
      set (lePrecision_Unsigned_Long_LongLong P);
      set (lePrecision_Unsigned_Int_Long      P);
      set (lePrecision_Unsigned_Short_Int     P);
      set (lePrecision_Unsigned_Ichar_Short   P);
      set (lePrecision_Unsigned_Bool_Ichar    P);
      omega
  | [ Hunsigned1 : isUnsigned ?P ?it1, Hunsigned2 : isUnsigned ?P ?it2 |- neg (leIntegerTypeRange ?P ?it1 ?it2) ] =>
      inversion 1; subst;
      match goal with
      | [H : le _ _ |- _] => set (integerTypeRange_precision_Unsigned_inv _ _ _ Hunsigned1 Hunsigned2 H)
      end;
      set (lePrecision_Unsigned_Long_LongLong P);
      set (lePrecision_Unsigned_Int_Long      P);
      set (lePrecision_Unsigned_Short_Int     P);
      set (lePrecision_Unsigned_Ichar_Short   P);
      set (lePrecision_Unsigned_Bool_Ichar    P);
      match goal with
      | [ H : neg (_ = _) |- _ ] => apply H
      end;
      omega
  | [ Hsigned1 : isSigned ?P ?it1, Hsigned2 : isSigned ?P ?it2 |- leIntegerTypeRange ?P ?it1 ?it2 ] =>
      constructor;
      apply (integerTypeRange_precision_Signed P it1 it2 Hsigned1 Hsigned2);
      set (lePrecision_Signed_Long_LongLong P);
      set (lePrecision_Signed_Int_Long      P);
      set (lePrecision_Signed_Short_Int     P);
      set (lePrecision_Signed_Ichar_Short   P);
      omega
  | [ Hsigned1 : isSigned ?P ?it1, Hsigned2 : isSigned ?P ?it2 |- neg (leIntegerTypeRange ?P ?it1 ?it2) ] =>
      inversion 1; subst;
      match goal with
      | [H : le _ _ |- _] => set (integerTypeRange_precision_Signed_inv _ _ _ Hsigned1 Hsigned2 H)
      end;
      set (lePrecision_Signed_Long_LongLong P);
      set (lePrecision_Signed_Int_Long      P);
      set (lePrecision_Signed_Short_Int     P);
      set (lePrecision_Signed_Ichar_Short   P);
      match goal with
      | [ H : neg (_ = _) |- _ ] => apply H
      end;
      omega
  | [ Hsigned1 : isSigned ?P ?it1, Hunsigned2 : isUnsigned ?P ?it2 |- neg (leIntegerTypeRange ?P ?it1 ?it2) ] =>
      set (integerTypeRange_precision_Signed_Unsigned P it1 it2 Hsigned1 Hunsigned2);
      inversion 1; contradiction
  | [ Hunsigned1 : isUnsigned ?P ?it1, Hsigned2 : isSigned ?P ?it2 |- neg (leIntegerTypeRange ?P ?it1 ?it2) ] =>
      inversion 1; subst;
      match goal with
      | [H : le _ _ |- _] => set (integerTypeRange_precision_Unsigned_Signed_inv _ _ _ Hunsigned1 Hsigned2 H)
      end;
      match it1 with
      | Unsigned ?ibt => set (lePrecision_Signed_Unsigned P ibt)
      | _ => idtac
      end;
      set (lePrecision_Signed_Unsigned_Ichar  P);
      set (lePrecision_Unsigned_Long_LongLong P);
      set (lePrecision_Unsigned_Int_Long      P);
      set (lePrecision_Unsigned_Short_Int     P);
      set (lePrecision_Unsigned_Ichar_Short   P);
      set (lePrecision_Unsigned_Bool_Ichar    P);
      solve [ contradiction | omega]
  | [ Hunsigned1 : isUnsigned ?P ?it1, Hsigned2 : isSigned ?P ?it2 |- leIntegerTypeRange ?P ?it1 ?it2 ] =>
      constructor;
      apply (integerTypeRange_precision_Unsigned_Signed P it1 it2 Hunsigned1 Hsigned2); assumption
  end.
Qed.

Instance leIntegerTypeRange_dec P : DecidableRelation (leIntegerTypeRange P) := {
  decide it1 it2 := boolSpec_Decision (leIntegerTypeRange_fun_correct P it1 it2)
}.

(* defns JeqRank *)
Inductive eqIntegerRankBase : integerType -> integerType -> Prop :=    (* defn eqRank *)
 | EqIntegerRankBaseUnsigned : forall (ibt:integerBaseType),
     eqIntegerRankBase (Signed ibt) (Unsigned ibt)
 | EqIntegerRankBaseUnsignedChar : 
     eqIntegerRankBase Char (Unsigned Ichar)
 | EqIntegerRankBaseSignedChar : 
     eqIntegerRankBase Char (Signed Ichar).

Instance eqIntegerRankBase_irrefl : Irreflexive eqIntegerRankBase.
Proof. inversion 1. Qed.

(* Equations
eqIntegerRankBase_dec it1 it2 : Decision (eqIntegerRankBase it1 it2) :=
eqIntegerRankBase_dec (Signed ibt1) (Unsigned ibt2) with decide ibt1 ibt2 := {
  | inl eq_refl := inl (EqIntegerRankBaseUnsigned _)  ;
  | inr _       := inr _                             };
eqIntegerRankBase_dec Char          (Unsigned  Ichar) := inl EqIntegerRankBaseUnsignedChar  ;
eqIntegerRankBase_dec Char          (Signed    Ichar) := inl EqIntegerRankBaseSignedChar    ;
eqIntegerRankBase_dec _              _                := inr _                              .

Next Obligation.
  intros.
  repeat match goal with
  | [ it  : integerType     |- _ ] => destruct it
  | [ ibt : integerBaseType |- _ ] => destruct ibt
  end; my_auto.
Qed.
*)

Definition eqIntegerRankBase_fun it1 it2 : bool :=
  match it1, it2 with
  | Signed ibt1, Unsigned ibt2   => bool_of_decision (decide ibt1 ibt2 : Decision (ibt1 = ibt2))
  | Char       , Unsigned  Ichar => true
  | Char       , Signed    Ichar => true
  | _          , _               => false
  end.

Lemma eqIntegerRankBase_fun_correct it1 it2 : boolSpec (eqIntegerRankBase_fun it1 it2) (eqIntegerRankBase it1 it2).
Proof. do 2 unfold_goal; my_auto. Qed.

Instance eqIntegerRankBase_DecR : DecidableRelation eqIntegerRankBase := {
  decide it1 it2 := boolSpec_Decision (eqIntegerRankBase_fun_correct it1 it2)
}.

Inductive eqIntegerRank : integerType -> integerType -> Prop :=    (* defn eqRank *)
 | EqIntegerRankBase  : forall it1 it2, eqIntegerRankBase it1 it2 -> eqIntegerRank it1 it2
 | EqIntegerRankSym   : forall it1 it2, eqIntegerRankBase it1 it2 -> eqIntegerRank it2 it1
 | EqIntegerRankRefl  : forall (it:integerType), eqIntegerRank it it.
(** definitions *)

Ltac eqIntegerRankBase_false :=
  match goal with
  | [ H : eqIntegerRankBase ?a ?b |- _ ] => inversion H; congruence
  end.

Ltac eqIntegerRank_finish :=
  solve [ eqIntegerRankBase_false 
        | apply EqIntegerRankSym; my_auto
        | intros; apply EqIntegerRankRefl].
Ltac eqIntegerRank_tac := my_auto' eqIntegerRank_finish fail.

Lemma eqIntegerRank_dec_aux it1 it2 : eqIntegerRankBase it1 it2 + eqIntegerRankBase it2 it1 + (it1 = it2) + neg (eqIntegerRank it1 it2).
Proof.
  destruct (decide it1 it2 : Decision (it1 = it2)).
  - left; right; assumption.
  - destruct (decide it1 it2 : Decision (eqIntegerRankBase it1 it2)).
    + left; left; left; assumption.
    + destruct (decide it2 it1 : Decision (eqIntegerRankBase it2 it1)).
      * left; left; right; assumption.
      * right; my_auto.
Qed.

(* Equations
eqIntegerRank_dec it1 it2 : Decision (eqIntegerRank it1 it2) :=
eqIntegerRank_dec it1 it2 with eqIntegerRank_dec_aux it1 it2 := {
  | inl (inl (inl b)) := inl (EqIntegerRankBase _ _ b) ;
  | inl (inl (inr s)) := inl (EqIntegerRankSym  _ _ s) ;
  | inl (inr eq_refl) := inl (EqIntegerRankRefl     _) ;
  | inr N             := inr N
}.
*)

Definition eqIntegerRank_fun it1 it2 : bool :=
  orb (bool_of_decision (decide it1 it2 : Decision (it1 = it2)))
      (orb (eqIntegerRankBase_fun it1 it2)
           (eqIntegerRankBase_fun it2 it1)).

Lemma eqIntegerRank_fun_correct it1 it2 : boolSpec (eqIntegerRank_fun it1 it2) (eqIntegerRank it1 it2).
Proof.
  do 2 unfold_goal.
  repeat match goal with
  | [ |- context[eqIntegerRankBase_fun ?it1 ?it2] ] =>
      set (eqIntegerRankBase_fun_correct it1 it2); boolSpec_destruct 
  end;
  eqIntegerRank_tac.
Qed.

Instance eqIntegerRank_DecR : DecidableRelation eqIntegerRank := {
  decide it1 it2 := boolSpec_Decision (eqIntegerRank_fun_correct it1 it2)
}.

Instance eqIntegerRank_trans : Transitive eqIntegerRank.
Proof.
  intros it1 it it2.
  generalize (eqIntegerRank_dec_aux it1 it);
  generalize (eqIntegerRank_dec_aux it it2);
  destruct_sum; eqIntegerRank_tac;
  repeat (
    match goal with
    | [ it : integerType |- _ ] => destruct it
    | [ ibt1 : integerBaseType , ibt2 : integerBaseType |- context[_ : eqIntegerRank (Signed ?ibt1) (Unsigned ?ibt2)] ]
        => notHyp (neg (ibt1 = ibt2)); notHyp (ibt1 = ibt2);
           destruct (decide ibt1 ibt2 : Decision (ibt1 = ibt2))
    | [ |- (eqIntegerRank _ _) -> _ ] => inversion 1
    | [ ibt : integerBaseType |- _ ] => destruct ibt
    end; eqIntegerRank_tac).
Qed.

Instance eqIntegerRank_sym : Symmetric eqIntegerRank.
Proof. inversion 1; eqIntegerRank_tac. Qed.

Instance eqIntegerRank_equiv : Equivalence eqIntegerRank := {
  Equivalence_Reflexive  := EqIntegerRankRefl   ;
  Equivalence_Symmetric  := eqIntegerRank_sym   ;
  Equivalence_Transitive := eqIntegerRank_trans
}.

(* defns JltRank *)
Inductive ltIntegerRankBase : impl -> integerType -> integerType -> Prop :=    (* defn ltRank *)
 | LtIntegerRankBasePrecision : forall (P:impl) (ibt1 ibt2:integerBaseType),
      (precision  P   (Signed ibt1)  < precision  P   (Signed ibt2) )%Z  ->
     ltIntegerRankBase P (Signed ibt1) (Signed ibt2)
 | LtIntegerRankBaseBool : forall (P:impl) (it:integerType),
      ~ (  isBool it  )  ->
     ltIntegerRankBase P Bool it
 | LtIntegerRankBaseLongLong : forall (P:impl),
     ltIntegerRankBase P (Signed Long) (Signed LongLong)
 | LtIntegerRankBaseLong : forall (P:impl),
     ltIntegerRankBase P (Signed Int) (Signed Long)
 | LtIntegerRankBaseInt : forall (P:impl),
     ltIntegerRankBase P (Signed Short) (Signed Int)
 | LtIntegerRankBaseShort : forall (P:impl),
     ltIntegerRankBase P (Signed Ichar) (Signed Short).

Instance ltIntegerRankBase_irrefl {P} : Irreflexive (ltIntegerRankBase P).
Proof. generalize Z.lt_irrefl; inversion 2; my_auto; intuition. Qed.

Ltac precision_tac :=
  match goal with
  | [P : impl, _ : _ < _ |- _ ] =>
      generalize (lePrecision_Signed_Ichar_Short    P); 
      generalize (lePrecision_Signed_Short_Int      P);
      generalize (lePrecision_Signed_Int_Long       P);
      generalize (lePrecision_Signed_Long_LongLong  P);
      omega
  | _ => idtac
  end.

Instance ltIntegerRankBase_asymm {P} : Asymmetric (ltIntegerRankBase P).
Proof. intros; inversion 1; inversion 1; my_auto; precision_tac; intuition. Qed.

Lemma ltIntegerRankBase_least P it : neg (ltIntegerRankBase P it Bool).
Proof. inversion 1; intuition. Qed.

(* Equations
ltIntegerRankBase_dec P it1 it2 : Decision (ltIntegerRankBase P it1 it2) :=
ltIntegerRankBase_dec P Bool it with isBool_dec it := {
  | inl _ := inr _                               ;
  | inr N := inl (LtIntegerRankBaseBool P it N) };
ltIntegerRankBase_dec P (Signed  Long) (Signed LongLong) := inl (LtIntegerRankBaseLongLong P) ;
ltIntegerRankBase_dec P (Signed   Int) (Signed     Long) := inl (LtIntegerRankBaseLong     P) ;
ltIntegerRankBase_dec P (Signed Short) (Signed      Int) := inl (LtIntegerRankBaseInt      P) ;
ltIntegerRankBase_dec P (Signed Ichar) (Signed    Short) := inl (LtIntegerRankBaseShort    P) ;
ltIntegerRankBase_dec P (Signed  ibt1) (Signed     ibt2)
  with Z_lt_dec (precision P (Signed ibt1)) (precision P (Signed ibt2)) := {
  | left  L := inl (LtIntegerRankBasePrecision P _ _ L)  ;
  | right _ := inr _                                    };
ltIntegerRankBase_dec P _ _ := inr _.
*)

Definition ltIntegerRankBase_fun P it1 it2 : bool :=
  match it1, it2 with
  | Bool        , it              => negb (isBool_fun it)
  | Signed  Long, Signed LongLong => true
  | Signed   Int, Signed     Long => true
  | Signed Short, Signed      Int => true
  | Signed Ichar, Signed    Short => true
  | Signed  ibt1, Signed     ibt2 => Z.ltb (precision P (Signed ibt1)) (precision P (Signed ibt2))
  | _           , _               => false
  end.

Ltac ltIntegerRankBase_tac :=
  match goal with
  | [ |- ltIntegerRankBase ?P (Signed  Long) (Signed LongLong) ] => exact (LtIntegerRankBaseLongLong P)
  | [ |- ltIntegerRankBase ?P (Signed   Int) (Signed     Long) ] => exact (LtIntegerRankBaseLong     P)
  | [ |- ltIntegerRankBase ?P (Signed Short) (Signed      Int) ] => exact (LtIntegerRankBaseInt      P)
  | [ |- ltIntegerRankBase ?P (Signed Ichar) (Signed    Short) ] => exact (LtIntegerRankBaseShort    P)
  end.

Lemma ltIntegerRankBase_fun_correct P it1 it2 : boolSpec (ltIntegerRankBase_fun P it1 it2) (ltIntegerRankBase P it1 it2).
Proof.
  do 2 unfold_goal; my_auto; intros;
  try match goal with
  | [ H : negb (isBool_fun ?it) = ?b |- _] =>
      let Hcorrect := fresh in
      match b with
      | true  => rewrite negb_true_iff  in H
      | false => rewrite negb_false_iff in H
      end;
      set (isBool_fun_correct it2) as Hcorrect;
      rewrite H in Hcorrect
  | [ H : Z.ltb ?z ?z = true  |- _ ] => rewrite Z.ltb_irrefl in H
  | [ H : Z.ltb ?x ?y = true  |- _ ] => set (proj1 (Z.ltb_lt  x y) H)
  | [ H : Z.ltb ?x ?y = false |- _ ] => set (proj1 (Z.ltb_nlt x y) H)
  | _ => ltIntegerRankBase_tac
  end; my_auto.
Qed.

Instance ltIntegerRankBase_DecR P : DecidableRelation (ltIntegerRankBase P) := {
  decide it1 it2 := boolSpec_Decision (ltIntegerRankBase_fun_correct P it1 it2)
}.

Inductive ltIntegerRankCongruence : impl -> integerType -> integerType -> Prop :=
 | LtIntegerRankCongruence :  forall (P:impl) (it1 it2 it1' it2':integerType),
     eqIntegerRank it1 it1' ->
     eqIntegerRank it2 it2' ->
     ltIntegerRankBase P it1 it2 ->
     ltIntegerRankCongruence P it1' it2'.

Ltac ltIntegerRankCongruence_destruct :=
  match goal with
  | [ H : eqIntegerRank     _ _ |- _ ] => inversion H; clear H
  | [ H : eqIntegerRankBase _ _ |- _ ] => inversion H; clear H
  | [ H : ltIntegerRankBase _  _  (Unsigned _) |- _ ] => inversion H; clear H
  | [ H : ltIntegerRankBase _  _  Char |- _ ] => inversion H; clear H
  end.

Ltac ltIntegerRankCongruence_finish :=
  match goal with
  | [ H : ltIntegerRankBase _  _   _    |- _     ] => now inversion H
  | [ H : ltIntegerRankBase ?P ?it Bool |- _     ] => destruct (ltIntegerRankBase_least P it H)
  | [ H : ltIntegerRankBase _  ?x  ?x   |- False ] => exact (ltIntegerRankBase_irrefl x H)
(*
TODO Coq can't find instance for
  exact (irreflexive x H)
*)
  | [ H1 : ltIntegerRankBase _ ?x ?y , H2 : ltIntegerRankBase _ ?y ?x |- False ] => exact (ltIntegerRankBase_asymm x y H1 H2)
(*
TODO Coq can't find instance for
  exact (asymmetric x y H1 H2)
*)
  end.

Ltac ltIntegerRankCongruence_tac := repeat (ltIntegerRankCongruence_destruct; my_auto); try ltIntegerRankCongruence_finish; my_auto.

(*
Ltac ltIntegerRankCongruence_finish :=
  repeat (match goal with
  | [ H : eqIntegerRank     _ _ |- _ ] => inversion H; clear H
  | [ H : eqIntegerRankBase _ _ |- _ ] => inversion H; clear H
  | [ H : ltIntegerRankBase _  _  _ |- _ ] => now inversion H
  | [ H : ltIntegerRankBase ?P ?it Bool |- _ ] => destruct (ltIntegerRankBase_least P it H)
  | [ H : ltIntegerRankBase _  _  (Unsigned _) |- _ ] => inversion H; clear H
  | [ H : ltIntegerRankBase _  _  Char |- _ ] => inversion H; clear H
  | [ H : ltIntegerRankBase _ ?x ?x |- False ] => exact (irreflexive x H)
  | [ H1 : ltIntegerRankBase _ ?x ?y , H2 : ltIntegerRankBase _ ?y ?x |- False ] => exact (asymmetric x y H1 H2)
  end; my_auto); my_auto.
*)

Instance ltIntegerRankCongruence_irrefl {P} : Irreflexive (ltIntegerRankCongruence P).
Proof. inversion 1; ltIntegerRankCongruence_tac. Qed.

Instance ltIntegerRankCongruence_asymm {P} : Asymmetric (ltIntegerRankCongruence P).
Proof. intros ? ?; inversion 1; inversion 1; ltIntegerRankCongruence_tac. Qed.

Definition ltIntegerRankCongruence_incl {P} {it1 it2} : ltIntegerRankBase P it1 it2 -> ltIntegerRankCongruence P it1 it2.
Proof.
  intros; econstructor.
  - apply EqIntegerRankRefl.
  - apply EqIntegerRankRefl.
  - assumption.
Qed.

Lemma ltIntegerRankCongruence_Unsigned_Unsigned {P} {ibt1} {ibt2} :
  ltIntegerRankBase P (Signed ibt1) (Signed ibt2) ->
  ltIntegerRankCongruence P (Unsigned ibt1) (Unsigned ibt2).
Proof.
  intros.
  econstructor.
  - constructor; constructor.
  - constructor; constructor.
  - assumption.
Qed.

Lemma ltIntegerRankCongruence_Unsigned1 {P} {ibt1} {it2} :
  ltIntegerRankBase P (Signed ibt1) it2 ->
  ltIntegerRankCongruence P (Unsigned ibt1) it2.
Proof.
  intros.
  econstructor.
  - constructor; constructor.
  - constructor 3.
  - assumption.
Qed.

Lemma ltIntegerRankCongruence_Unsigned2 {P} {it1} {ibt2} :
  ltIntegerRankBase P it1 (Signed ibt2) ->
  ltIntegerRankCongruence P it1 (Unsigned ibt2).
Proof.
  intros.
  econstructor.
  - constructor 3.
  - constructor; constructor.
  - assumption.
Qed.

Lemma ltIntegerRankBaseCongruence_Char1 {P} {it2} :
  ltIntegerRankBase P (Signed Ichar) it2 ->
  ltIntegerRankCongruence P Char it2.
Proof.
  intros.
  econstructor.
  - constructor 2. constructor 3.
  - constructor 3.
  - assumption.
Qed.

Lemma ltIntegerRankBaseCongruence_Char_Unsigned {P} {ibt2} :
  ltIntegerRankBase P (Signed Ichar) (Signed ibt2) ->
  ltIntegerRankCongruence P Char (Unsigned ibt2).
Proof.
  intros.
  econstructor.
  - constructor 2. constructor 3.
  - constructor 1; constructor 1.
  - assumption.
Qed.

Ltac ltIntegerRankCongruence_dec_tac :=
  ltIntegerRankCongruence_tac;
  try solve
    [ inversion 1; ltIntegerRankCongruence_tac
    | unfold neg; intros; apply_ctx; constructor; inversion 1
    | inversion 2; ltIntegerRankCongruence_tac
    | inversion 1; ltIntegerRankCongruence_tac;
      match goal with
      | [ H : ltIntegerRankBase _ (Signed ?ibt) (Signed Ichar) |- _ ] =>
          destruct ibt; inversion H;
          ltIntegerRankCongruence_tac;
          precision_tac;
          intuition
      end].

(*Equations
Obligation Tactic := ltIntegerRankCongruence_dec_tac.
Equations(noind nocomp)
ltIntegerRankCongruence_dec P it1 it2 : Decision (ltIntegerRankCongruence P it1 it2) :=
ltIntegerRankCongruence_dec P _    Bool := inr _ ;
ltIntegerRankCongruence_dec P Bool it2  := inl (ltIntegerRankCongruence_incl (LtIntegerRankBaseBool P it2 _)) ;
ltIntegerRankCongruence_dec P Char Char := inr _ ;
ltIntegerRankCongruence_dec P Char (Unsigned ibt2)
  with ltIntegerRankBase_dec P (Signed Ichar) (Signed ibt2) := {
     | inl Y := inl (ltIntegerRankBaseCongruence_Char_Unsigned Y) ;
     | inr N := inr (N ∘ _)    };
ltIntegerRankCongruence_dec P Char (Signed ibt2)
  with ltIntegerRankBase_dec P (Signed Ichar) (Signed ibt2) := {
     | inl Y := inl (ltIntegerRankBaseCongruence_Char1 Y) ;
     | inr N := inr (N ∘ _)    };
ltIntegerRankCongruence_dec P (Unsigned ibt1) Char := inr _;
ltIntegerRankCongruence_dec P (Signed   ibt1) Char := inr _;
ltIntegerRankCongruence_dec P (Unsigned ibt1) (Unsigned ibt2)
  with ltIntegerRankBase_dec P (Signed ibt1) (Signed ibt2) := {
     | inl Y := inl (ltIntegerRankCongruence_Unsigned_Unsigned Y)  ;
     | inr N := inr (N ∘ _) };
ltIntegerRankCongruence_dec P (Unsigned ibt1) it2 with (ltIntegerRankBase_dec P (Signed ibt1) it2) := {
  | inl Y := inl (ltIntegerRankCongruence_Unsigned1 Y)    ;
  | inr N := inr (N ∘ _) };
ltIntegerRankCongruence_dec P it1 (Unsigned ibt2) with (ltIntegerRankBase_dec P it1 (Signed ibt2)) := {
  | inl Y := inl (ltIntegerRankCongruence_Unsigned2 Y)    ;
  | inr N := inr (N ∘ _) };
ltIntegerRankCongruence_dec P it1 it2
  with ltIntegerRankBase_dec P it1 it2 := {
     | inl Y := inl (ltIntegerRankCongruence_incl Y) ;
     | inr _ := inr _}.
*)

Definition ltIntegerRankCongruence_fun P it1 it2 : bool :=
  match it1, it2 with
  | _            , Bool          => false
  | Bool         , _             => true
  | _            , Char          => false
  | Char         , Unsigned ibt2 => ltIntegerRankBase_fun P (Signed Ichar) (Signed ibt2)
  | Char         , Signed   ibt2 => ltIntegerRankBase_fun P (Signed Ichar) (Signed ibt2)
  | Signed ibt1  , Signed   ibt2 => ltIntegerRankBase_fun P (Signed  ibt1) (Signed ibt2)
  | Unsigned ibt1, Unsigned ibt2 => ltIntegerRankBase_fun P (Signed  ibt1) (Signed ibt2)
  | Unsigned ibt1, it2           => ltIntegerRankBase_fun P (Signed  ibt1) it2
  | it1          , Unsigned ibt2 => ltIntegerRankBase_fun P it1            (Signed ibt2)
  end.

Ltac ltIntegerRankCongruence_pos_tac tac :=
  match goal with
  | [ |- ltIntegerRankCongruence ?P Bool ?it2 ] => apply ltIntegerRankCongruence_incl; apply (LtIntegerRankBaseBool P it2); inversion 1
  | [ |- ltIntegerRankCongruence _ Char         (Signed   _) ] => apply ltIntegerRankBaseCongruence_Char1        ; tac
  | [ |- ltIntegerRankCongruence _ Char         (Unsigned _) ] => apply ltIntegerRankBaseCongruence_Char_Unsigned; tac
  | [ |- ltIntegerRankCongruence _ (Signed   _) (Signed   _) ] => apply ltIntegerRankCongruence_incl             ; tac
  | [ |- ltIntegerRankCongruence _ (Unsigned _) (Unsigned _) ] => apply ltIntegerRankCongruence_Unsigned_Unsigned; tac
  | [ |- ltIntegerRankCongruence _ (Unsigned _) (Signed   _) ] => apply ltIntegerRankCongruence_Unsigned1        ; tac
  | [ |- ltIntegerRankCongruence _ (Signed   _) (Unsigned _) ] => apply ltIntegerRankCongruence_Unsigned2        ; tac
  end.

Lemma ltIntegerRankCongruence_fun_correct P it1 it2 : boolSpec (ltIntegerRankCongruence_fun P it1 it2) (ltIntegerRankCongruence P it1 it2).
Proof.
  do 2 unfold_goal; destruct it1; destruct it2;
  repeat match goal with
  | [ |- context[ltIntegerRankBase_fun ?P ?it1 ?it2] ] =>
      set (ltIntegerRankBase_fun_correct P it1 it2);
      boolSpec_destruct
  | _ => ltIntegerRankCongruence_pos_tac assumption
  | _ => ltIntegerRankCongruence_dec_tac
  end.
Qed.

Instance ltIntegerRankCongruence_dec P : DecidableRelation (ltIntegerRankCongruence P) := {
  decide it1 it2 := boolSpec_Decision (ltIntegerRankCongruence_fun_correct P it1 it2)
}.

Inductive ltIntegerRank : impl -> integerType -> integerType -> Prop :=    (* defn ltRank *)
 | LtIntegerRankBase : forall P it1 it2, ltIntegerRankCongruence P it1 it2 -> ltIntegerRank P it1 it2
 | LtIntegerRankTransitive : forall (P:impl) (it1 it2 it:integerType),
     ltIntegerRankCongruence P it1 it ->
     ltIntegerRank P it it2 ->
     ltIntegerRank P it1 it2.
(** definitions *)

Definition ltIntegerRank_fun it1 it2 : bool :=
  match it1, it2 with
  | _             , Bool           => false
  | Bool          , _              => true

  | _             , Char           => false
  | _             , Signed   Ichar => false
  | _             , Unsigned Ichar => false
  | Char          , Signed    ibt2 => true
  | Char          , Unsigned  ibt2 => true
  | Signed   Ichar, Signed    ibt2 => true
  | Signed   Ichar, Unsigned  ibt2 => true
  | Unsigned Ichar, Signed    ibt2 => true
  | Unsigned Ichar, Unsigned  ibt2 => true

  | _             , Signed   Short => false
  | _             , Unsigned Short => false
  | Signed   Short, Signed    ibt2 => true
  | Signed   Short, Unsigned  ibt2 => true
  | Unsigned Short, Signed    ibt2 => true
  | Unsigned Short, Unsigned  ibt2 => true

  | _             , Signed     Int => false
  | _             , Unsigned   Int => false
  | Signed     Int, Signed    ibt2 => true
  | Signed     Int, Unsigned  ibt2 => true
  | Unsigned   Int, Signed    ibt2 => true
  | Unsigned   Int, Unsigned  ibt2 => true

  | _             , Signed    Long => false
  | _             , Unsigned  Long => false
  | Signed    Long, Signed    ibt2 => true
  | Signed    Long, Unsigned  ibt2 => true
  | Unsigned  Long, Signed    ibt2 => true
  | Unsigned  Long, Unsigned  ibt2 => true

  | _             , _              => false
  end.

Ltac ltIntegerRank_pos_tac :=
  match goal with
  | [ |- ltIntegerRank _ _                _] =>
      apply LtIntegerRankBase;
      ltIntegerRankCongruence_pos_tac idtac;
      now ltIntegerRankBase_tac
  | [ |- ltIntegerRank _ Char             _] => ltIntegerRank_pos_tac_iter (Signed    Short)
  | [ |- ltIntegerRank _ (Signed   Ichar) _] => ltIntegerRank_pos_tac_iter (Signed    Short)
  | [ |- ltIntegerRank _ (Unsigned Ichar) _] => ltIntegerRank_pos_tac_iter (Signed    Short)
  | [ |- ltIntegerRank _ (Signed   Short) _] => ltIntegerRank_pos_tac_iter (Signed      Int)
  | [ |- ltIntegerRank _ (Unsigned Short) _] => ltIntegerRank_pos_tac_iter (Signed      Int)
  | [ |- ltIntegerRank _ (Signed     Int) _] => ltIntegerRank_pos_tac_iter (Signed     Long)
  | [ |- ltIntegerRank _ (Unsigned   Int) _] => ltIntegerRank_pos_tac_iter (Signed     Long)
  | [ |- ltIntegerRank _ (Signed    Long) _] => ltIntegerRank_pos_tac_iter (Signed LongLong)
  | [ |- ltIntegerRank _ (Unsigned  Long) _] => ltIntegerRank_pos_tac_iter (Signed LongLong)
  end
with ltIntegerRank_pos_tac_iter t :=
  apply (LtIntegerRankTransitive _ _ _ t);
  [ ltIntegerRankCongruence_pos_tac idtac; ltIntegerRankBase_tac
  | ltIntegerRank_pos_tac ].

Ltac ltIntegerRank_neg_tac :=
  match goal with
  | _ => contradiction
  | [ H  : ltIntegerRankCongruence _ ?x ?x |- False ] => exact (ltIntegerRankCongruence_irrefl x H)
  | [ H : ltIntegerRankCongruence _ _ _         |- _] => inversion H; ltIntegerRankCongruence_tac; clear H
  | [ ibt : integerBaseType                     |- _] => destruct ibt
  | [ it : integerType                          |- _] => destruct it
  | [ H : ltIntegerRankBase _ _ _               |- _] => ltIntegerRankCongruence_finish
  | [ H1 : precision ?P ?it1 < precision ?P ?it2, H2 : ltIntegerRankBase ?P ?it1 ?it2 |- _] => (now precision_tac) || (clear H1; clear H2)
  | [ H : ltIntegerRankBase _ _ _               |- _] => inversion H; now precision_tac
  | [ H : ltIntegerRankBase _ _ _               |- _] => clear H
  | [ H : ltIntegerRank _ _ _                   |- _] => inversion H; subst; clear H
  end.

Definition ltIntegerRank_neg_next it : option integerType :=
  match it with
  | Unsigned ibt    => Some (Signed ibt)
  | Signed LongLong => Some (Unsigned Long)
  | Signed Long     => Some (Unsigned Int)
  | Signed Int      => Some (Unsigned Short)
  | Signed Short    => Some (Unsigned Ichar)
  | Signed Ichar    => Some Char
  | Char            => Some Bool
  | Bool            => None
  end.

Ltac ltIntegerRank_neg_tac_next P it1 it2 :=
  let next := eval compute in (ltIntegerRank_neg_next it1) in
  assert (neg (ltIntegerRank P it1 it2)) by (clear_integerType; intros ?; now abstract (do 5 ltIntegerRank_neg_tac));
  match next with
  | Some ?it1' =>
      let eq      := eval compute in (eqIntegerRank_fun it1  it2) in
      let eq_next := eval compute in (eqIntegerRank_fun it1' it2) in
      match eval compute in (andb eq (negb eq_next)) with
      | true  => idtac
      | false => ltIntegerRank_neg_tac_next P it1' it2
      end
  | None => idtac
  end.

Lemma ltIntegerRank_fun_correct P it1 it2 : boolSpec (ltIntegerRank_fun it1 it2) (ltIntegerRank P it1 it2).
Proof.
  unfold_goal; scatter fail.
  - destruct_integerType; my_auto; ltIntegerRank_pos_tac.
  - destruct_integerType_hyp it2;
    abstract (
      match goal with
      | [ |- context[ltIntegerRank ?P ?H ?it2]] =>
          ltIntegerRank_neg_tac_next P (Unsigned LongLong) it2; destruct_integerType; my_auto
      end
    ).
Qed.

Instance ltIntegerRank_decR P : DecidableRelation (ltIntegerRank P) := {
  decide it1 it2 := boolSpec_Decision (ltIntegerRank_fun_correct P it1 it2)
}.

Instance ltIntegerRank_asymm P : Asymmetric (ltIntegerRank P).
Proof.
  intros x y Hxy Hyx.
  set (ltIntegerRank_fun_correct P x y) as Hxy'.
  set (ltIntegerRank_fun_correct P y x) as Hyx'.
  destruct_integerType;
  boolSpec_simpl;
  contradiction.
Qed.

Instance ltIntegerRank_irrefl P : Irreflexive (ltIntegerRank P) :=
  fun it H => ltIntegerRank_asymm P it it H H.

Instance ltIntegerRank_trans P : Transitive (ltIntegerRank P).
Proof.
  unfold Transitive; fix IH 4.
  inversion 1; subst.
  + econstructor 2; eassumption.
  +  match goal with
    | [ _ : ltIntegerRankCongruence ?P _ ?it1, H1 : ltIntegerRank ?P ?it1 ?it |- ltIntegerRank ?P ?it ?it2 -> _] =>
        let H2 := fresh in
        intros H2; set (IH it1 it it2 H1 H2)
    end.
    econstructor 2; eassumption.
Qed.

Lemma ltIntegerRank_cong1 P it1 it it2 : eqIntegerRank it1 it -> ltIntegerRank P it it2 -> ltIntegerRank P it1 it2.
Proof.
  inversion 2; subst;
  match goal with
  | [H : ltIntegerRankCongruence _ _ _ |- _] => inversion H; subst; clear H
  end;
  match goal with
  | [ E  : eqIntegerRank       ?it1 ?it
    , Eb : eqIntegerRank       ?itb ?it
    , Ee : eqIntegerRank       ?ite ?it2
    , L  : ltIntegerRankBase P ?itb ?ite |- ltIntegerRank ?P ?it1 _] =>
    set (LtIntegerRankCongruence _ _ _ _ _ (eqIntegerRank_trans _ _ _ Eb (eqIntegerRank_sym _ _ E)) Ee L)
  end.
  + constructor  1;  assumption.
  + econstructor 2; eassumption.
Qed.

Lemma ltIntegerRank_cong2 P :
  forall it1 it it2, eqIntegerRank it it2 -> ltIntegerRank P it1 it -> ltIntegerRank P it1 it2.
Proof.
  fix IH 5.
  inversion 2; subst.
  + match goal with
    | [H : ltIntegerRankCongruence _ _ _ |- _] => inversion H; subst; clear H
    end.
    match goal with
    | [ E  : eqIntegerRank       ?it ?it2
      , Eb : eqIntegerRank       ?itb ?it1
      , Ee : eqIntegerRank       ?ite _
      , L  : ltIntegerRankBase P ?itb ?ite |- ltIntegerRank ?P ?it1 ?it2] =>
        set (LtIntegerRankCongruence _ _ _ _ _ Eb (eqIntegerRank_trans _ _ _ Ee E) L)
    end; constructor 1; assumption.
  + match goal with
    | [ E  : eqIntegerRank ?it _
      , _ : ltIntegerRankCongruence ?P ?it1 ?itn
      , L : ltIntegerRank           ?P ?itn ?it  |- _] => set (IH _ _ _ E L); econstructor 2; eassumption
    end.
Qed.

(* defns JleRank *)
Inductive leIntegerRank : impl -> integerType -> integerType -> Prop :=    (* defn leRank *)
 | LeIntegerRankEq : forall (P:impl) (it1 it2:integerType),
     eqIntegerRank it1 it2 ->
     leIntegerRank P it1 it2
 | LeIntegerRankLt : forall (P:impl) (it1 it2:integerType),
     ltIntegerRank P it1 it2 ->
     leIntegerRank P it1 it2.
(** definitions *)

Definition leIntegerRank_fun it1 it2 : bool :=
  orb (eqIntegerRank_fun it1 it2) (ltIntegerRank_fun it1 it2).

Lemma leIntegerRank_fun_correct P it1 it2 : boolSpec (leIntegerRank_fun it1 it2) (leIntegerRank P it1 it2).
Proof.
  do 2 unfold_goal.
  set (eqIntegerRank_fun_correct   it1 it2).
  set (ltIntegerRank_fun_correct P it1 it2).
  repeat boolSpec_destruct;
  solve [ constructor 1; assumption
        | constructor 2; assumption
        | inversion 1; my_auto
  ].
Qed.

Instance leIntegerRank_decR P : DecidableRelation (leIntegerRank P) := {
  decide it1 it2 := boolSpec_Decision (leIntegerRank_fun_correct P it1 it2)
}.

Instance leIntegerRank_refl P : Reflexive (leIntegerRank P).
Proof. intros ?; constructor; apply EqIntegerRankRefl. Qed.

Instance leIntegerRank_trans P : Transitive (leIntegerRank P).
Proof.
  inversion 1; inversion 1; my_auto.
  + constructor 1; eapply eqIntegerRank_trans; eassumption.
  + constructor 2; eapply ltIntegerRank_cong1; eassumption.
  + constructor 2; eapply ltIntegerRank_cong2; eassumption.
  + constructor 2; eapply ltIntegerRank_trans; eassumption.
Qed.

Lemma leIntegerRank_cong1 P it1 it it2 : eqIntegerRank it1 it -> leIntegerRank P it it2 -> leIntegerRank P it1 it2.
Proof.
  inversion 2; subst.
  + constructor 1; eapply eqIntegerRank_trans; eassumption.
  + constructor 2; eapply ltIntegerRank_cong1; eassumption.
Qed.

Lemma leIntegerRank_cong2 P it1 it it2 : eqIntegerRank it it2 -> leIntegerRank P it1 it -> leIntegerRank P it1 it2.
Proof.
  inversion 2; subst.
  + constructor 1; eapply eqIntegerRank_trans; eassumption.
  + constructor 2; eapply ltIntegerRank_cong2; eassumption.
Qed.

(* defns JisArithmetic *)
Inductive isArithmetic : type -> Prop :=    (* defn isArithmetic *)
 | IsArithmeticInteger : forall (ty:type),
     isInteger ty ->
     isArithmetic ty.
(** definitions *)

Definition isArithmetic_fun t : bool := isInteger_fun t.

Lemma isArithmetic_fun_correct t : boolSpec (isArithmetic_fun t) (isArithmetic t).
Proof.
  do 2 unfold_goal.
  set (isInteger_fun_correct t).
  boolSpec_destruct; my_auto.
Qed.  

Instance isArithmetic_dec t : Decision (isArithmetic t) := boolSpec_Decision (isArithmetic_fun_correct t).

(* defns JisScalar *)
Inductive isScalar : type -> Prop :=    (* defn isScalar *)
 | IsScalarPointer : forall (ty:type),
     isPointer ty ->
     isScalar ty
 | IsScalarArithmetic : forall (ty:type),
     isArithmetic ty ->
     isScalar ty.
(** definitions *)

Definition isScalar_fun t : bool := orb (isPointer_fun t) (isArithmetic_fun t).

Lemma isScalar_fun_correct t : boolSpec (isScalar_fun t) (isScalar t).
Proof.
  do 2 unfold_goal.
  set (isPointer_fun_correct    t).
  set (isArithmetic_fun_correct t).
  boolSpec_destruct;
  destruct t; solve [constructor 1; assumption | constructor 2; assumption | my_auto].
Qed.

Instance isScalar_dec t : Decision (isScalar t) := boolSpec_Decision (isScalar_fun_correct t).

(* defns JisArray *)
Inductive isArray : type -> Prop :=    (* defn isArray *)
 | IsArray : forall (ty:type) (n:nat),
     isArray (Array ty n).
(** definitions *)

Definition isArray_fun t : bool :=
  match t with
  | Array _ _ => true
  | _         => false
  end.

Lemma isArray_fun_correct t : boolSpec (isArray_fun t) (isArray t).
Proof. destruct t; my_auto. Qed.

Instance isArray_dec t : Decision (isArray t) := boolSpec_Decision (isArray_fun_correct t).

(* defns JisFunction *)
Inductive isFunction : type -> Prop :=    (* defn isFunction *)
 | IsFunction : forall (ls : args) (ty:type),
     isFunction  (Function ty ls) .
(** definitions *)

Definition isFunction_fun t : bool :=
  match t with
  | Function _ _ => true
  | _            => false
  end.

Lemma isFunction_fun_correct t : boolSpec (isFunction_fun t) (isFunction t).
Proof. destruct t; my_auto. Qed.

Instance isFunction_dec t : Decision (isFunction t) := boolSpec_Decision (isFunction_fun_correct t).

(* defns JisUnsignedOf *)
Inductive isCorrespondingUnsigned : integerType -> integerType -> Prop :=    (* defn isCorrespondingUnsigned *)
 | IsCorrespondingUnsigned : forall (ibt:integerBaseType),
     isCorrespondingUnsigned  (Signed ibt)   (Unsigned ibt).
(** definitions *)

Definition isCorrespondingUnsigned_fun it1 it2 : bool :=
  match it1, it2 with
  | Signed ibt1, Unsigned ibt2 => bool_of_decision (decide ibt1 ibt2 : Decision (ibt1 = ibt2))
  | _          , _             => false
  end.

Lemma isCorrespondingUnsigned_fun_correct it1 it2 : boolSpec (isCorrespondingUnsigned_fun it1 it2) (isCorrespondingUnsigned it1 it2).
Proof. destruct it1; destruct it2; my_auto. Qed.

Instance isCorrespondingUnsigned_decR : DecidableRelation isCorrespondingUnsigned :=
  fun it1 it2 => boolSpec_Decision (isCorrespondingUnsigned_fun_correct it1 it2).

Definition isCorrespondingUnsigned_find it : option integerType :=
  match it with
  | Signed ibt => Some (Unsigned ibt)
  | _          => None
  end.

Lemma isCorrespondingUnsigned_find_correct it :
  match isCorrespondingUnsigned_find it with
  | Some it' => isCorrespondingUnsigned it it'
  | None     => forall it', neg (isCorrespondingUnsigned it it')
  end.
Proof. destruct it; my_auto. Qed.

Lemma isCorrespondingUnsigned_find_unique it1 it2 :
  isCorrespondingUnsigned it1 it2 ->
  isCorrespondingUnsigned_find it1 = Some it2.
Proof. destruct 1; reflexivity. Qed.

(* defns JisPromotion *)
Inductive isIntegerPromotion : impl -> integerType -> integerType -> Prop :=    (* defn isPromotion *)
 | IsPromotionToSignedInt : forall (P:impl) (it:integerType),
      ~ it = Unsigned Int ->
      ~ it = Signed   Int ->
     leIntegerRank P it (Signed Int) ->
     leIntegerTypeRange P it (Signed Int) ->
     isIntegerPromotion P it (Signed Int)
 | IsIntegerPromotionToUnsignedInt : forall (P:impl) (it:integerType),
      ~ it = Unsigned Int ->
      ~ it = Signed   Int ->
     leIntegerRank P it (Signed Int) ->
      ~ leIntegerTypeRange P it (Signed Int) ->
     isIntegerPromotion P it (Unsigned Int)
 | IsIntegerPromotionUnsignedInt : forall (P:impl),
     isIntegerPromotion P (Unsigned Int) (Unsigned Int)
 | IsIntegerPromotionSignedInt : forall (P:impl),
     isIntegerPromotion P (Signed Int) (Signed Int)
 | IsIntegerPromotionRank : forall (P:impl) (it:integerType),
      ~ leIntegerRank P it (Signed Int) ->
     isIntegerPromotion P it it.

Definition isIntegerPromotion_fun P it1 it2 : bool :=
  match it1, it2 with
  | Signed   Int, Signed   Int => true
  | Unsigned Int, Signed   Int => false
  | Unsigned Int, Unsigned Int => true
  | Signed   Int, Unsigned Int => false
  | _           , Signed   Int => andb (leIntegerRank_fun        it1 (Signed Int))
                                       (leIntegerTypeRange_fun P it1 (Signed Int))
  | _           , Unsigned Int => andb (leIntegerRank_fun        it1 (Signed Int))
                                       (negb (leIntegerTypeRange_fun P it1 (Signed Int)))
  | _           , _            => andb (bool_of_decision (decide it1 it2 : Decision (it1 = it2)))
                                       (negb (leIntegerRank_fun it1 (Signed Int)))
  end.

Lemma isIntegerPromotion_fun_correct P it1 it2 : boolSpec (isIntegerPromotion_fun P it1 it2) (isIntegerPromotion P it1 it2).
Proof.
  do 2 unfold_goal.
  set (leIntegerRank_fun_correct      P it1 (Signed Int)).
  set (leIntegerTypeRange_fun_correct P it1 (Signed Int)).
  destruct_integerType;
  match goal with
  | [ |- isIntegerPromotion _ (Signed   Int) (Signed   Int) ] => apply IsIntegerPromotionSignedInt
  | [ |- isIntegerPromotion _ (Unsigned Int) (Unsigned Int) ] => apply IsIntegerPromotionUnsignedInt
  | _ => repeat boolSpec_destruct; my_auto
  end.
Qed.  

Definition isIntegerPromotion_find P it : integerType :=
  match it with
  | Signed   Int => Signed   Int
  | Unsigned Int => Unsigned Int
  | _            => if leIntegerRank_fun it (Signed Int)
                      then if leIntegerTypeRange_fun P it (Signed Int)
                             then Signed Int
                             else Unsigned Int
                      else it
  end.

Lemma isIntegerPromotion_find_correct P it : isIntegerPromotion P it (isIntegerPromotion_find P it).
Proof.
  unfold_goal.
  set (leIntegerRank_fun_correct      P it (Signed Int)).
  set (leIntegerTypeRange_fun_correct P it (Signed Int)).
  destruct_integerType;
  match goal with
  | [ |- isIntegerPromotion _ (Signed   Int) (Signed   Int) ] => apply IsIntegerPromotionSignedInt
  | [ |- isIntegerPromotion _ (Unsigned Int) (Unsigned Int) ] => apply IsIntegerPromotionUnsignedInt
  | _ => repeat boolSpec_destruct; my_auto
  end.
Qed.

Lemma isIntegerPromotion_find_unique P it1 it2 : isIntegerPromotion P it1 it2 -> it2 = isIntegerPromotion_find P it1.
Proof.
  unfold_goal.
  set (leIntegerRank_fun_correct      P it1 (Signed Int)).
  set (leIntegerTypeRange_fun_correct P it1 (Signed Int)).
  destruct_integerType; boolSpec_destruct; my_auto.
Qed.

(* defns JisUsualArith-metic *)
Inductive isUsualArithmeticInteger : impl -> integerType -> integerType -> integerType -> Prop :=    (* defn isUsualArithmetic *)
 | IsUsualArithmeticIntegerEq : forall (P:impl) (it:integerType),
     isUsualArithmeticInteger P it it it
 | IsUsualArithmeticIntegerGtSameSigned : forall (P:impl) (it1 it2:integerType),
      ~ it1 = it2 ->
      isSignedType it1 ->
      isSignedType it2 ->
     ltIntegerRank P it2 it1 ->
     isUsualArithmeticInteger P it1 it2 it1
 | IsUsualArithmeticIntegerGtSameUnsigned : forall (P:impl) (it1 it2:integerType),
      ~ it1 = it2 ->
      isUnsignedType it1 ->
      isUnsignedType it2 ->
     ltIntegerRank P it2 it1 ->
     isUsualArithmeticInteger P it1 it2 it1
 | IsUsualArithmeticIntegerLtSameSigned : forall (P:impl) (it1 it2:integerType),
      ~ it1 = it2 ->
      isSignedType it1 ->
      isSignedType it2 ->
     ltIntegerRank P it1 it2 ->
     isUsualArithmeticInteger P it1 it2 it2
 | IsUsualArithmeticIntegerLtSameUnsigned : forall (P:impl) (it1 it2:integerType),
      ~ it1 = it2 ->
     isUnsignedType it1 ->
     isUnsignedType it2 ->
     ltIntegerRank P it1 it2 ->
     isUsualArithmeticInteger P it1 it2 it2
 | IsUsualArithmeticIntegerLtUnsigned : forall (P:impl) (it1 it2 :integerType),
      ~ it1 = it2->
     isSignedType   it1 ->
     isUnsignedType it2 ->
     leIntegerRank P it1 it2 ->
     isUsualArithmeticInteger P it1 it2 it2
 | IsUsualArithmeticIntegerGtUnsigned : forall (P:impl) (it1 it2:integerType),
      ~ (   it1  =  it2   )  ->
     isUnsignedType it1 ->
     isSignedType it2 ->
     leIntegerRank P it2 it1 ->
     isUsualArithmeticInteger P it1 it2 it1
 | IsUsualArithmeticIntegerLtSigned : forall (P:impl) (it1 it2:integerType),
      ~ (   it1  =  it2   )  ->
     isUnsignedType it1 ->
     isSignedType it2 ->
     leIntegerRank P it1 it2 ->
     leIntegerTypeRange P it1 it2 ->
     isUsualArithmeticInteger P it1 it2 it2
 | IsUsualArithmeticIntegerGtSigned : forall (P:impl) (it1 it2 :integerType),
      ~ (   it1  =  it2   )  ->
     isSignedType it1 ->
     isUnsignedType it2 ->
     leIntegerRank P it2 it1 ->
     leIntegerTypeRange P it2 it1 ->
     isUsualArithmeticInteger P it1 it2 it1
 | IsUsualArithmeticIntegerLtSigned' : forall (P:impl) (it1 it2 it2':integerType),
      ~ (   it1  =  it2   )  ->
     isUnsignedType it1 ->
     isSignedType it2 ->
     leIntegerRank P it1 it2 ->
      ~ (  leIntegerTypeRange P it1 it2  )  ->
     isCorrespondingUnsigned it2 it2' ->
     isUsualArithmeticInteger P it1 it2 it2'
 | IsUsualArithmeticIntegerGtSigned' : forall (P:impl) (it1 it2 it1':integerType),
      ~ (   it1  =  it2   )  ->
     isSignedType it1 ->
     isUnsignedType it2 ->
     leIntegerRank P it2 it1 ->
      ~ (  leIntegerTypeRange P it2 it1  )  ->
     isCorrespondingUnsigned it1 it1' ->
     isUsualArithmeticInteger P it1 it2 it1'.
(** definitions *)

Definition isUsualArithmeticInteger_fun P it1 it2 it3 : bool :=
  if bool_of_decision(decide it1 it2 : Decision (it1 = it2)) then
    bool_of_decision(decide it1 it3 : Decision (it1 = it3))
  else
    if isSignedType_fun it1 then
      if isSignedType_fun it2 then
        if ltIntegerRank_fun it2 it1 then
          bool_of_decision(decide it1 it3 : Decision (it1 = it3))
        else
          bool_of_decision(decide it2 it3 : Decision (it2 = it3))
      else if isUnsignedType_fun it2 then
        if leIntegerRank_fun it1 it2 then
          bool_of_decision(decide it2 it3 : Decision (it2 = it3))
        else
          if leIntegerTypeRange_fun P it2 it1 then
            bool_of_decision(decide it1 it3 : Decision (it1 = it3))
          else
            isCorrespondingUnsigned_fun it1 it3
      else
        false
    else if isUnsignedType_fun it1 then
      if isUnsignedType_fun it2 then
        if ltIntegerRank_fun it2 it1 then
          bool_of_decision(decide it1 it3 : Decision (it1 = it3))
        else
          bool_of_decision(decide it2 it3 : Decision (it2 = it3))
      else if isSignedType_fun it2 then
        if leIntegerRank_fun it2 it1 then
          bool_of_decision(decide it1 it3 : Decision (it1 = it3))
        else if leIntegerTypeRange_fun P it1 it2 then
          bool_of_decision(decide it2 it3 : Decision (it2 = it3))
        else
          isCorrespondingUnsigned_fun it2 it3
      else
        false
    else
      false.

Lemma isUsualArithmeticInteger_fun_correct P it1 it2 it3 :
 boolSpec (isUsualArithmeticInteger_fun P it1 it2 it3)
          (isUsualArithmeticInteger     P it1 it2 it3).
Proof.
  do 2 unfold_goal.
  set (decide it1 it2 : Decision (it1 = it2)) as Heq.
  destruct Heq.
  - my_auto.
  - set (isSignedType_fun_correct it1) as Hsigned1_correct.
    set (isSignedType_fun_correct it2) as Hsigned2_correct.
    set (isUnsignedType_fun_correct it1) as Hunsigned1_correct.
    set (isUnsignedType_fun_correct it2) as Hunsigned2_correct.
    destruct it1; destruct it2;
    boolSpec_simpl;
    abstract (
    match goal with
    | [_ : isSignedType   ?it1, _ : isSignedType   ?it2 |- context[isUsualArithmeticInteger ?P ?it1 ?it2 _]] =>
        set (ltIntegerRank_fun_correct P it2 it1) as Hgt_correct;
        set (ltIntegerRank_fun_correct P it1 it2) as Hlt_correct;
        destruct_integerBaseType;
        boolSpec_simpl;
        destruct_decide;
        now my_auto
    | [_ : isUnsignedType ?it1, _ : isUnsignedType ?it2 |- context[isUsualArithmeticInteger ?P ?it1 ?it2 _]] =>
        set (ltIntegerRank_fun_correct P it2 it1) as Hgt_correct;
        set (ltIntegerRank_fun_correct P it1 it2) as Hlt_correct;
        (try destruct_integerBaseType);
        boolSpec_simpl;
        my_auto;
        solve [apply IsUsualArithmeticIntegerLtSameUnsigned; assumption
              |apply IsUsualArithmeticIntegerGtSameUnsigned; assumption]
    | [_ : isSignedType   ?it1, _ : isUnsignedType ?it2 |- context[isUsualArithmeticInteger ?P ?it1 ?it2 _]] =>
        set (leIntegerRank_fun_correct P it1 it2) as Hle_correct;
        set (leIntegerRank_fun_correct P it2 it1) as Hge_correct;
        set (leIntegerTypeRange_fun_correct P it2 it1) as HleRange_correct;
        set (isCorrespondingUnsigned_fun_correct it1 it3) as Hcorr_correct;
        destruct_integerType;
        boolSpec_simpl;
        my_auto;
        match goal with
        | [_ : context [leIntegerRank_fun _ _] |- _] =>
            unfold leIntegerRank_fun in Hle_correct;
            unfold ltIntegerRank_fun in Hle_correct;
            unfold eqIntegerRank_fun in Hle_correct;
            unfold leIntegerRank_fun in Hge_correct;
            unfold ltIntegerRank_fun in Hge_correct;
            unfold eqIntegerRank_fun in Hge_correct;
            boolSpec_simpl
        | _ => idtac
        end;
        match goal with
        | [_ : boolSpec (Z.ltb ?x ?y) (leIntegerTypeRange _ _ _) |- (Z.ltb ?x ?y) = _ -> _] =>
            let Heq := fresh in            
            intros Heq; rewrite Heq in HleRange_correct; boolSpec_simpl
        | _ => idtac
        end;
        my_auto;
        solve [ apply IsUsualArithmeticIntegerLtUnsigned; my_auto
              | apply IsUsualArithmeticIntegerGtSigned  ; my_auto
              | apply IsUsualArithmeticIntegerGtSigned' ; my_auto ]
    | [_ : isUnsignedType ?it1, _ : isSignedType   ?it2 |- context[isUsualArithmeticInteger ?P ?it1 ?it2 ?it3]] =>
        set (leIntegerRank_fun_correct P it1 it2) as Hle_correct;
        set (leIntegerRank_fun_correct P it2 it1) as Hge_correct;
        set (leIntegerTypeRange_fun_correct P it1 it2) as HleRange_correct;
        set (isCorrespondingUnsigned_fun_correct it2 it3) as Hcorr_correct;
        destruct_integerType;
        boolSpec_simpl;
        my_auto;
        match goal with
        | [_ : context [leIntegerRank_fun _ _] |- _] =>
            unfold leIntegerRank_fun in Hle_correct;
            unfold ltIntegerRank_fun in Hle_correct;
            unfold eqIntegerRank_fun in Hle_correct;
            unfold leIntegerRank_fun in Hge_correct;
            unfold ltIntegerRank_fun in Hge_correct;
            unfold eqIntegerRank_fun in Hge_correct;
            boolSpec_simpl
        | _ => idtac
        end;
        match goal with
        | [_ : boolSpec (Z.ltb ?x ?y) (leIntegerTypeRange _ _ _) |- (Z.ltb ?x ?y) = _ -> _] =>
            let Heq := fresh in            
            intros Heq; rewrite Heq in HleRange_correct; boolSpec_simpl
        | _ => idtac
        end;
        my_auto;
        solve [ apply IsUsualArithmeticIntegerLtSigned  ; my_auto
              | apply IsUsualArithmeticIntegerGtUnsigned; my_auto ]
    | _ => repeat destruct_decide; finish fail
    end).
Qed.

Definition isUsualArithmeticInteger_find P it1 it2 : option integerType :=
  if bool_of_decision(decide it1 it2 : Decision (it1 = it2)) then
    Some it1
  else
    if isSignedType_fun it1 then
      if isSignedType_fun it2 then
        if ltIntegerRank_fun it2 it1 then
          Some it1
        else
          Some it2
      else if isUnsignedType_fun it2 then
        if leIntegerRank_fun it1 it2 then
          Some it2
        else
          if leIntegerTypeRange_fun P it2 it1 then
            Some it1
          else
            isCorrespondingUnsigned_find it1
      else
        None
    else if isUnsignedType_fun it1 then
      if isUnsignedType_fun it2 then
        if ltIntegerRank_fun it2 it1 then
          Some it1
        else
          Some it2
      else if isSignedType_fun it2 then
        if leIntegerRank_fun it2 it1 then
          Some it1
        else if leIntegerTypeRange_fun P it1 it2 then
          Some it2
        else
          isCorrespondingUnsigned_find it2
      else
        None
    else
      None.

Lemma isUsualArithmeticInteger_find_correct P it1 it2 :
  match isUsualArithmeticInteger_find P it1 it2 with
  | Some it3 => isUsualArithmeticInteger P it1 it2 it3
  | None     => forall it3, neg (isUsualArithmeticInteger P it1 it2 it3)
  end.
Proof.
  destruct_integerType; simpl;
  match goal with
  | [|- isUsualArithmeticInteger ?P ?it1 ?it2 ?it3] =>
      exact (isUsualArithmeticInteger_fun_correct P it1 it2 it3)
  | [|- forall _, neg (isUsualArithmeticInteger ?P ?it1 ?it2 _)] =>
      intros it3;
      exact (isUsualArithmeticInteger_fun_correct P it1 it2 it3)
  | _ =>
    unfold_goal; simpl;
    match goal with
    | [|- match ?c with _ => _ end] =>
        let Heq := fresh in
        match c with
        | context[Z.ltb ?x ?y] => case_eq (Z.ltb x y); intros Heq
        end;
        match goal with
        | [|- isUsualArithmeticInteger ?P ?it1 ?it2 ?it3] =>
            let H := fresh in
            set (isUsualArithmeticInteger_fun_correct P it1 it2 it3) as H;
            unfold isUsualArithmeticInteger_fun in H;
            boolSpec_simpl;
            rewrite Heq in H;
            assumption
        end
    end
  end.
Qed.

Lemma isUsualArithmeticInteger_find_unique P it1 it2 it3 :
  isUsualArithmeticInteger P it1 it2 it3 ->
  isUsualArithmeticInteger_find P it1 it2 = Some it3.
Proof.
  set (isSignedType_fun_correct it1).
  set (isSignedType_fun_correct it2).
  set (isUnsignedType_fun_correct it1).
  set (isUnsignedType_fun_correct it2).
  set (ltIntegerRank_fun_correct P it1 it2).
  set (ltIntegerRank_fun_correct P it2 it1).
  set (leIntegerRank_fun_correct P it1 it2).
  set (leIntegerRank_fun_correct P it2 it1).
  set (leIntegerTypeRange_fun_correct P it2 it1).
  set (leIntegerTypeRange_fun_correct P it1 it2).
  unfold isUsualArithmeticInteger_find.
  inversion 1;
  my_auto;
  (repeat match goal with
  | [it : integerType|- _] => destruct it
  end);
  my_auto;
  abstract (
    destruct_integerType; boolSpec_simpl;
    simpl; repeat match goal with
    | [H : context [leIntegerRank_fun _ _] |- _] =>
        unfold leIntegerRank_fun in H;
        unfold ltIntegerRank_fun in H;
        unfold eqIntegerRank_fun in H;
        unfold leIntegerRank_fun;
        unfold ltIntegerRank_fun;
        unfold eqIntegerRank_fun;
        boolSpec_simpl
    | _ => idtac
    end;
    match goal with
    | [H : boolSpec (Z.ltb ?x ?y) (leIntegerTypeRange _ _ _) |- (Z.ltb ?x ?y) = _ -> _] =>
        let Heq := fresh in            
        intros Heq; rewrite Heq in H; boolSpec_simpl
    | _ => idtac
    end;
    my_auto
  ).
Qed.

(*
Only defined on promoted integers. Hence, whether char is signed or unsigned
is insignificant here. Since we separated the two notions, we still have to
test though.

'If both operands have the same type, then no further conversion is needed.'
(1)+ it1 = it2 (= it3)
  IsUsualArithmeticIntegerEq it it it

'Otherwise,'
(1)- it1 <> it2

  'both operands have signed integer types'
  (2)+ signed it1
  (2)+ signed it2
    'operand with the type of lesser integer conversion rank'
    (3)+ ltIntegerRank it2 it1
    'converted to the type of the operand with greater rank.'
    IsUsualArithmeticIntegerGtSameSigned it1

    'operand with the type of lesser integer conversion rank'
    ?(3)- ltIntegerRank it1 it2
      (No test necessary; have
      	  it1 <rank it2 \/ it2 <rank it1 \/ it1 = it2
       if it1, it2 signed.)
    'converted to the type of the operand with greater rank.'
    IsUsualArithmeticIntegerLtSameSigned it2

  'both operands have unsigned integer types'
  (2)- unsigned it1
  (2)- unsigned it2
    (3)+ ltIntegerRank it2 it1
    IsUsualArithmeticIntegerGtSameUnsigned it1

    ?(3)- ltIntegerRank it1 it2
      (Again, no test necessary.)
    IsUsualArithmeticIntegerLtSameUnsigned it2

  (2)+ signed it1
  (2)- unsigned it2
    (4)+ leIntegerRank it1 it2
    IsUsualArithmeticIntegerLtUnsigned it2

    ?(4)- leIntegerRank it2 it1
    (<=rank is total; no test necessary.)
      ?(5)- leIntegerTypeRange P it2 it1
      (Also, total.)
      IsUsualArithmeticIntegerGtSigned  it1

      (5)- (leIntegerTypeRange P it1 it2)
      (6)+ isCorrespondingUnsigned it1 it1'
      IsUsualArithmeticIntegerGtSigned' it1' (isCorrespondingUnsigned it1 it1')

  (2)- unsigned it1
  (2)+ signed it2
    ?(4)- leIntegerRank it2 it1
    IsUsualArithmeticIntegerGtUnsigned it1

    (4)+ leIntegerRank it1 it2
      (5)+ leIntegerTypeRange P it1 it2
      IsUsualArithmeticIntegerLtSigned it2


      (5)- ~(leIntegerTypeRange P it1 it2)
      (6)+ isCorrespondingUnsigned it2 it2'
      IsUsualArithmeticIntegerLtSigned' it2' (isCorrespondingUnsigned it2 it2')
*)

Inductive isUsualArithmetic (P : impl) : type -> type -> type -> Prop :=
  | IsUsualArithmeticInteger :
      forall (it1 it2 it1' it2' it : integerType),
      isIntegerPromotion P it1 it1' ->
      isIntegerPromotion P it2 it2' ->
      isUsualArithmeticInteger P it1' it2' it ->
      isUsualArithmetic P (Basic (Integer it1)) (Basic (Integer it2)) (Basic (Integer it)).

Definition isUsualArithmetic_find P t1 t2 : option type :=
  match t1, t2 with
  | Basic (Integer it1), Basic (Integer it2) =>
      match isUsualArithmeticInteger_find P (isIntegerPromotion_find P it1) (isIntegerPromotion_find P it2) with
      | Some it => Some (Basic (Integer it))
      | None    => None
      end
  | _, _ => None
  end.

Definition isUsualArithmetic_find_correct P t1 t2 :
  match isUsualArithmetic_find P t1 t2 with
  | Some t3 => isUsualArithmetic P t1 t2 t3
  | None    => forall t3, neg (isUsualArithmetic P t1 t2 t3)
  end.
Proof.
  unfold_goal.
  destruct t1; destruct t2;
  repeat match goal with
  | [bt : basicType|- _] => destruct bt
  end;
  match goal with
  | [|- forall _, neg _] => inversion 1
  | [|- context[isUsualArithmeticInteger_find P
                  (isIntegerPromotion_find P ?it1)
                  (isIntegerPromotion_find P ?it2)]] =>
      let Heq1 := fresh in
      let Heq2 := fresh in
      let Heq3 := fresh in
      set (isIntegerPromotion_find_correct P it1);
      set (isIntegerPromotion_find_correct P it2);
      set (isUsualArithmeticInteger_find_correct P (isIntegerPromotion_find P it1) (isIntegerPromotion_find P it2));
      case_eq (isIntegerPromotion_find P it1);
      match goal with
      | [|- forall (_ : integerBaseType), _ -> _] => intros ? Heq1
      | _ => intros Heq1
      end;
      case_eq (isIntegerPromotion_find P it2);
      match goal with
      | [|- forall (_ : integerBaseType), _ -> _] => intros ? Heq2
      | _ => intros Heq2
      end;
      case_eq (isUsualArithmeticInteger_find P (isIntegerPromotion_find P it1) (isIntegerPromotion_find P it2));
      match goal with
      | [|- forall (_ : integerType), _ = Some _ -> _] => intros ? Heq3
      | [|- _ = None                             -> _] => intros Heq3
      | _ => idtac
      end;
      rewrite Heq1 in *;
      rewrite Heq2 in *;
      rewrite Heq3 in *;
      (try rewrite <- Heq1);
      (try rewrite <- Heq2);
      (try rewrite    Heq3);
      simpl;
      solve [econstructor; eassumption
            | inversion 1; my_auto; intuition
            | destruct t3; inversion 1; my_auto;
              match goal with
              | [ H1 : isIntegerPromotion ?P ?it1 ?it1'
              , H2 : isIntegerPromotion ?P ?it2 ?it2'
              , _  : isUsualArithmeticInteger _ _ _ ?it3
              , H  : forall _, neg (isUsualArithmeticInteger _ _ _ _) |- _] =>
                let Heq1 := fresh in
                let Heq2 := fresh in
                set (isIntegerPromotion_find_unique P it1 it1' H1);
                set (isIntegerPromotion_find_unique P it2 it2' H2);
                apply (H it3); congruence
              end
            ]
  end.
Qed.

Definition isUsualArithmetic_find_unique P t1 t2 t3 :
  isUsualArithmetic P t1 t2 t3 ->
  isUsualArithmetic_find P t1 t2 = Some t3.
Proof.
  inversion 1; subst.
  unfold isUsualArithmetic_find.
  match goal with
  | [ H1 : isIntegerPromotion ?P ?it1 ?it1'
    , H2 : isIntegerPromotion ?P ?it2 ?it2'
    , H3 : isUsualArithmeticInteger ?P ?it1' ?it2' ?it3 |- _] =>
      let Heq1 := fresh in
      let Heq2 := fresh in
      let Heq3 := fresh in
      set (isIntegerPromotion_find_unique P it1 it1' H1) as Heq1;
      rewrite <- Heq1;
      set (isIntegerPromotion_find_unique P it2 it2' H2) as Heq2;
      rewrite <- Heq2;
      set (isUsualArithmeticInteger_find_unique P it1' it2' it3 H3) as Heq3;
      rewrite Heq3
  end.
  congruence.
Qed.

Definition isUsualArithmetic_fun P t1 t2 t3 : bool :=
  bool_of_decision (decide (isUsualArithmetic_find P t1 t2) (Some t3) : Decision (_ = _)).

Lemma isUsualArithmetic_fun_correct P t1 t2 t3 :
  boolSpec (isUsualArithmetic_fun P t1 t2 t3) (isUsualArithmetic P t1 t2 t3).
Proof.
  do 2 unfold_goal.
  set (isUsualArithmetic_find_correct P t1 t2) as Hcorrect.
  set (isUsualArithmetic_find_unique P t1 t2 t3) as Hunique.
  set (isUsualArithmetic_find P t1 t2) as H in *.
  destruct_decide.
  + match goal with | [Heq : _ = Some _|- _] => rewrite Heq in Hcorrect; assumption end.
  + intros Husual; set (Hunique Husual); contradiction.
Qed.

(* defns JisObject *)
Inductive isObject : type -> Prop :=    (* defn isObject *)
 | IsObjectBasicType : forall (bt:basicType),
     isObject (Basic bt)
 | IsObjectVoid : 
     isObject Void
 | IsObjectPointer : forall (qs:qualifiers) (ty:type),
     isObject  (Pointer qs ty) 
 | IsObjectArray : forall (ty:type) (n:nat),
     isObject  (Array ty n) .
(** definitions *)

Definition isObject_fun t : bool :=
  match t with
  | Basic _ => true
  | Void => true
  | Pointer _ _ => true
  | Array _ _ => true
  | _ => false
  end.

Lemma isObject_fun_correct t : boolSpec (isObject_fun t) (isObject t).
Proof. destruct t; my_auto. Qed.

(* defns JisComplete *)
Inductive isComplete : type -> Prop :=    (* defn isComplete *)
 | IsCompleteBasicType : forall (bt:basicType),
     isComplete (Basic bt)
 | IsCompletePointer : forall (qs:qualifiers) (ty:type),
     isComplete  (Pointer qs ty) 
 | IsCompleteArray : forall (ty:type) (n:nat),
     isComplete  (Array ty n) .
(** definitions *)

Definition isComplete_fun t : bool :=
  match t with
  | Basic _ => true
  | Pointer _ _ => true
  | Array _ _ => true
  | _ => false
  end.

Lemma isComplete_fun_correct t : boolSpec (isComplete_fun t) (isComplete t).
Proof. destruct t; my_auto. Qed.

(* defns JisIncomplete *)
Inductive isIncomplete : type -> Prop :=    (* defn isIncomplete *)
 | IsIncompleteVoid : 
     isIncomplete Void.
(** definitions *)

Definition isIncomplete_fun t : bool :=
  match t with
  | Void => true
  | _ => false
  end.

Lemma isIncomplete_fun_correct t : boolSpec (isIncomplete_fun t) (isIncomplete t).
Proof. destruct t; my_auto. Qed.

(* defns JisModifiable *)
Inductive isModifiable : qualifiers -> type -> Prop :=    (* defn isModifiable *)
 | IsModifiable : forall (qs:qualifiers) (ty:type),
     isObject ty ->
      ~ (  isArray ty  )  ->
      ~ (  isIncomplete ty  )  ->
      ~ (   (List.In  Const   qs )   )  ->
     isModifiable qs ty.
(** definitions *)

Fixpoint list_in_fun {A:Type} (eq : A -> A -> bool) (a : A) (ls : list A) : bool :=
  match ls with
  | nil   => false
  | x::xs => orb (eq a x) (list_in_fun eq a xs)
  end.

Fixpoint list_in_fun_correct {A:Type} (eq : A -> A -> bool) (a : A) (ls : list A) :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  boolSpec (list_in_fun eq a ls) (List.In a ls).
Proof.
  intros eq_correct.
  destruct ls.
  + inversion 1.
  + simpl.
    match goal with
    | [|- context[eq a ?x]] =>
      let Heq := fresh in
      set (eq_correct a x);
      case_eq (eq a x); intros Heq; rewrite Heq in *; clear Heq
    end.
    - left; my_auto.
    - set (list_in_fun_correct A eq a ls eq_correct).
      let Heq := fresh in
      case_eq (list_in_fun eq a ls); intros Heq; rewrite Heq in *; clear Heq.
      * right; my_auto.
      * inversion 1; my_auto.
Qed.

Definition isModifiable_fun qs t : bool :=
  andb (isObject_fun t)
       (andb (negb (isArray_fun t)) 
             (andb (negb (isIncomplete_fun t))
                   (negb (list_in_fun (fun x y => bool_of_decision (decide x y : Decision (x = y))) Const qs))
             )
       ).

Lemma Decision_boolSpec {P} (D : Decision P) : boolSpec (bool_of_decision D) P.
Proof. destruct D; assumption. Qed.

Lemma isModifiable_fun_correct qs t : boolSpec (isModifiable_fun qs t) (isModifiable qs t).
Proof.
  do 2 unfold_goal.
  set (isObject_fun_correct t).
  set (isArray_fun_correct t).
  set (isIncomplete_fun_correct t).
  set (list_in_fun_correct (fun x y => bool_of_decision (decide x y)) Const qs (fun x y => Decision_boolSpec ((decide x y)))).
  unfold andb.
  unfold negb.
  destruct t; my_auto;
  intros Heq; rewrite Heq in *; clear Heq;
  boolSpec_simpl; my_auto.
Qed.

(* defns JisReal *)
Inductive isReal : type -> Prop :=    (* defn isReal *)
 | IsRealInteger : forall (ty:type),
     isInteger ty ->
     isReal ty.
(** definitions *)

Definition isReal_fun t : bool := isInteger_fun t.

Lemma isReal_correct t : boolSpec (isReal_fun t) (isReal t).
Proof.
  do 2 unfold_goal.
  generalize (isInteger_fun_correct t).
  destruct (isInteger_fun t); my_auto.
Qed.

(* defns JisLvalueConvertable *)
Inductive isLvalueConvertable : type -> Prop :=    (* defn isLvalueConvertable *)
 | IsLvalueConvertable : forall (ty:type),
      ~ (  isArray ty  )  ->
     isComplete ty ->
     isLvalueConvertable ty.
(** definitions *)

Definition isLvalueConvertable_fun t : bool := andb (negb (isArray_fun t)) (isComplete_fun t).

Lemma isLvalueConvertable_correct t : boolSpec (isLvalueConvertable_fun t) (isLvalueConvertable t).
Proof.
  do 2 unfold_goal.
  generalize (isArray_fun_correct t).
  generalize (isComplete_fun_correct t).
  destruct (isArray_fun t);
  destruct (isComplete_fun t);
  my_auto.
Qed.

(* defns JisCompatible *)
Inductive isCompatible : type -> type -> Prop :=    (* defn isCompatible *)
 | IsCompatibleEq : forall (ty:type),
     isCompatible ty ty
 | IsCompatibleFunction : forall (args1 args2 : args) (res1 res2 : type),
     isCompatible res1 res2 ->
     isCompatible_args args1 args2 ->
     isCompatible (Function res1 args1) (Function res2 args2)
with isCompatible_args : args -> args -> Prop :=
 | IsCompatible_nil  :
     isCompatible_args Argument_nil Argument_nil
 | IsCompatible_cons : forall qs1 t1 args1 qs2 t2 args2, 
     isCompatible t1 t2 ->
     isCompatible_args args1 args2 ->
     isCompatible_args (Argument_cons qs1 t1 args1) (Argument_cons qs2 t2 args2).

(*
 | IsCompatibleFunction : forall (qs_ty_qs'_ty'_list:list (qualifiers*type*qualifiers*type)) (ty ty':type),
     isCompatible ty ty' ->
     (forall ty_ ty'_, List.In (ty_,ty'_) (List.map (fun (pat_: (qualifiers*type*qualifiers*type)) => match pat_ with (qs_,ty_,qs'_,ty'_) => (ty_,ty'_) end) qs_ty_qs'_ty'_list) -> (isCompatible ty_ ty'_)) ->
     isCompatible  (Function ty (map (fun (pat_:(qualifiers*type*qualifiers*type)) => match pat_ with (qs_,ty_,qs'_,ty'_) => (qs_,ty_) end ) qs_ty_qs'_ty'_list))   (Function ty' (map (fun (pat_:(qualifiers*type*qualifiers*type)) => match pat_ with (qs_,ty_,qs'_,ty'_) => (qs'_,ty'_) end ) qs_ty_qs'_ty'_list)) .
*)
(** definitions *)

Fixpoint isCompatible_fun t1 t2 {struct t1} : bool :=
  if bool_of_decision(decide t1 t2 : Decision (t1 = t2)) then
    true
  else
    match t1, t2 with
    | Function res1 args1, Function res2 args2 =>
        andb (isCompatible_fun res1 res2) (isCompatible_args_fun args1 args2)
    | _, _ => false
    end
with isCompatible_args_fun args1 args2 : bool :=
  match args1, args2 with
  | Argument_nil          , Argument_nil           => true
  | Argument_nil          , _                      => false
  | _                     , Argument_nil           => false
  | Argument_cons _ t1 ls1, Argument_cons _ t2 ls2 => andb (isCompatible_fun t1 t2) (isCompatible_args_fun ls1 ls2)
  end.

Fixpoint isCompatible_fun_correct      t1 t2 : boolSpec (isCompatible_fun      t1 t2) (isCompatible      t1 t2)
with     isCompatible_args_fun_correct l1 l2 : boolSpec (isCompatible_args_fun l1 l2) (isCompatible_args l1 l2).
Proof.
  + do 2 unfold_goal.
    my_auto;
    destruct t1; destruct t2;
    my_auto;
    fold isCompatible_fun;
    fold isCompatible_args_fun;
    match goal with
    | [Heq : ?x = ?y |- isCompatible ?x ?y] =>
        rewrite Heq; constructor
    | [_ : neg (Function ?t1 ?l1 = Function ?t2 ?l2) |- _] =>
        let Heq := fresh in
        generalize (isCompatible_fun_correct t1 t2);
        destruct (isCompatible_fun t1 t2); my_auto; intros ? Heq;
        generalize (isCompatible_args_fun_correct l1 l2);
        rewrite Heq; intros;
        solve [constructor 2; my_auto | inversion 1; my_auto ] 
    end.
  + do 2 unfold_goal.
    my_auto;
    destruct l1; destruct l2;
    my_auto;
    fold isCompatible_fun;
    fold isCompatible_args_fun;
    match goal with
    | [t1 : type, t2 : type |- _] =>
        let Heq := fresh in
        generalize (isCompatible_fun_correct t1 t2);
        destruct (isCompatible_fun t1 t2); my_auto; intros ? Heq;
        generalize (isCompatible_args_fun_correct l1 l2);
        rewrite Heq; intros; my_auto
    end.
Defined.

(* defns JisComposite *)
Inductive isComposite : type -> type -> type -> Prop :=    (* defn isComposite *)
 | IsCompositeEq : forall (ty:type),
     isComposite ty ty ty
 | IsCompositeArray : forall (ty1:type) (n:nat) (ty2 ty:type),
     isComposite ty1 ty2 ty ->
     isComposite  (Array ty1 n)   (Array ty2 n)   (Array ty n)
 | IsCompositeFunction : forall (l1 l2 l : args) (t1 t2 t : type),
     isComposite t1 t2 t ->
     isComposite_args l1 l2 l ->
     isComposite (Function t1 l1) (Function t2 l2) (Function t l)
with isComposite_args : args -> args -> args -> Prop :=
 | IsComposite_nil :
     isComposite_args Argument_nil
                      Argument_nil
                      Argument_nil
 | IsComposite_cons : forall t1 l1 qs1 t2 l2 qs2 t3 l3,
     isComposite      t1 t2 t3 ->
     isComposite_args l1 l2 l3 ->
     isComposite_args (Argument_cons qs1 t1 l1)
                      (Argument_cons qs2 t2 l2)
                      (Argument_cons nil t3 l3).

Fixpoint isComposite_fun t1 t2 t3 : bool :=
  if andb (bool_of_decision (decide t1 t2 : Decision (t1 = t2)))
          (bool_of_decision (decide t1 t3 : Decision (t1 = t3))) then
    true
  else
    match t1, t2, t3 with
    | Array t1 n1, Array t2 n2, Array t3 n3 =>
        andb (andb (bool_of_decision (decide n1 n2 : Decision (n1 = n2)))
                   (bool_of_decision (decide n1 n3 : Decision (n1 = n3))))
             (isComposite_fun t1 t2 t3)
    | Function t1 l1, Function t2 l2, Function t3 l3 =>
        andb (isComposite_fun      t1 t2 t3)
             (isComposite_args_fun l1 l2 l3)
    | _, _, _ => false
    end
with isComposite_args_fun l1 l2 l3 : bool :=
  match l1, l2, l3 with
  | Argument_nil         , Argument_nil         , Argument_nil            => true
  | Argument_cons _ t1 l1, Argument_cons _ t2 l2, Argument_cons nil t3 l3 =>
      andb (isComposite_fun      t1 t2 t3)
           (isComposite_args_fun l1 l2 l3) 
  | _                    , _                    , _                       => false
  end.

Fixpoint isComposite_fun_correct      t1 t2 t3 : boolSpec (isComposite_fun      t1 t2 t3) (isComposite      t1 t2 t3)
with     isComposite_args_fun_correct l1 l2 l3 : boolSpec (isComposite_args_fun l1 l2 l3) (isComposite_args l1 l2 l3).
Proof.
  + do 2 unfold_goal.
    destruct t1;
    destruct t2;
    destruct t3;
    my_auto;
    fold isComposite_fun;
    fold isComposite_args_fun;
    match goal with
    | [ Heq1 : ?t1 = ?it2, Heq2 : ?t1 = ?it3 |- isComposite ?t1 ?t2 ?it3 ] =>
        rewrite <- Heq1; rewrite <- Heq2; constructor
    | [|- isComposite_fun ?t1 ?t2 ?t3 = _ -> _] =>
        let Heq := fresh in
        intros Heq;
        generalize (isComposite_fun_correct t1 t2 t3);
        rewrite Heq; intros ?
    | [|- isComposite_fun ?t1 ?t2 ?t3 && isComposite_args_fun ?l1 ?l2 ?l3 = _ -> _] =>
        let Heq := fresh in
        generalize (isComposite_fun_correct t1 t2 t3);
        destruct (isComposite_fun t1 t2 t3); my_auto;
        intros ? Heq;
        generalize (isComposite_args_fun_correct l1 l2 l3);
        rewrite Heq; intros ?
    end;
    my_auto.
  + do 2 unfold_goal.
    destruct l1;
    destruct l2;
    destruct l3;
    my_auto;
    fold isComposite_fun;
    fold isComposite_args_fun;
    match goal with
    | [|- isComposite_fun ?t1 ?t2 ?t3 && isComposite_args_fun ?l1 ?l2 ?l3 = _ -> _] =>
        generalize (isComposite_fun_correct t1 t2 t3);
        destruct (isComposite_fun t1 t2 t3); my_auto;
        intros ? Heq;
        generalize (isComposite_args_fun_correct l1 l2 l3);
        rewrite Heq; intros ?
    end;
    my_auto.
Qed.
