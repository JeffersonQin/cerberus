(* generated by Ott 0.21.2 from: AilSyntax_.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.

Require Import Common.
Require Import AilTypes.

Open Scope type.

Definition identifier := nat.
Definition eq_identifier : identifier -> identifier -> bool := eq_nat.

Inductive integerSuffix : Set := 
 | U : integerSuffix
 | UL : integerSuffix
 | ULL : integerSuffix
 | L : integerSuffix
 | LL : integerSuffix.

Definition eq_integerSuffix s1 s2 : bool :=
  match s1, s2 with
  | U  , U   => true
  | UL , UL  => true
  | ULL, ULL => true
  | L  , L   => true
  | LL , LL  => true
  | _  , _   => false
  end.

Definition integerConstant : Set := nat * option integerSuffix.

Definition eq_integerConstant := eq_pair eq_nat (eq_option eq_integerSuffix).

Inductive arithmeticOperator : Set :=  (*r 6.5.5 Multiplicative operators *)
 | Mul : arithmeticOperator
 | Div : arithmeticOperator
 | Mod : arithmeticOperator (*r 6.5.6 Additive operators *)
 | Add : arithmeticOperator
 | Sub : arithmeticOperator (*r 6.5.7 Bitwise shift operators *)
 | Shl : arithmeticOperator
 | Shr : arithmeticOperator (*r 6.5.10 Bitwise AND operator *)
 | Band : arithmeticOperator (*r 6.5.11 Bitwise exclusive OR operator *)
 | Bor : arithmeticOperator (*r 6.5.12 Bitwise inclusive OR operator *)
 | Xor : arithmeticOperator (*r Binary operators from 6.5.5-14, 6.5.17 *).

Definition eq_arithmeticOperator a1 a2 :=
  match a1, a2 with
  | Mul , Mul
  | Div , Div
  | Mod , Mod
  | Add , Add
  | Sub , Sub
  | Shl , Shl
  | Shr , Shr
  | Band, Band
  | Bor , Bor
  | Xor , Xor => true
  | _   , _   => false
  end.

Inductive constant : Set := 
 | ConstantInteger (int_const:integerConstant).

Definition eq_constant c1 c2 :=
  match c1, c2 with
  | ConstantInteger ic1, ConstantInteger ic2 => eq_integerConstant ic1 ic2
  end.

Inductive unaryOperator : Set := 
 | Plus : unaryOperator
 | Minus : unaryOperator
 | Bnot : unaryOperator
 | Address : unaryOperator
 | Indirection : unaryOperator
 | PostfixIncr : unaryOperator (*r Note: Appears prefix in concrete syntax. *)
 | PostfixDecr : unaryOperator (*r Note: Appears prefix in concrete syntax. *).

Definition eq_unaryOperator u1 u2 :=
  match u1, u2 with
  | Plus       , Plus
  | Minus      , Minus
  | Bnot       , Bnot
  | Address    , Address
  | Indirection, Indirection
  | PostfixIncr, PostfixIncr
  | PostfixDecr, PostfixDecr => true
  | _          , _           => false
  end.

Inductive binaryOperator : Set :=  (*r Group of operators also used for assigments *)
 | Arithmetic (aop:arithmeticOperator) (*r 6.5.17 Comma operator *)
 | Comma : binaryOperator (*r 6.5.13 Logical AND operator *)
 | And : binaryOperator (*r 6.5.14 Logical OR operator *)
 | Or : binaryOperator (*r 6.5.8 Relational operators *)
 | Lt : binaryOperator
 | Gt : binaryOperator
 | Le : binaryOperator
 | Ge : binaryOperator (*r 6.5.9 Equality operators *)
 | Eq : binaryOperator
 | Ne : binaryOperator.

Definition eq_binaryOperator b1 b2 :=
  match b1, b2 with
  | Arithmetic a1, Arithmetic a2 => eq_arithmeticOperator a1 a2
  | Comma, Comma
  | And  , And
  | Or   , Or
  | Lt   , Lt
  | Gt   , Gt
  | Le   , Le
  | Ge   , Ge
  | Eq   , Eq
  | Ne   , Ne    => true
  | _    , _     => false
  end.

Inductive expression' {A : Set} : Set := 
  | Unary (uop:unaryOperator) (e:expression)
  | Binary (e1:expression) (bop:binaryOperator) (e2:expression)
  | Assign (e1:expression) (e2:expression)
  | CompoundAssign (e1:expression) (aop:arithmeticOperator) (e2:expression)
  | Conditional (e1:expression) (e2:expression) (e3:expression)
  | Cast (q:qualifiers) (t:ctype) (e:expression)
  | Call (e:expression) (es:list expression)
  | Constant (c:constant)
  | Var (v:identifier)
  | SizeOf (q:qualifiers) (t:ctype)
  | AlignOf (q:qualifiers) (t:ctype)
with expression {A : Set} : Set :=
  | AnnotatedExpression (a:A) (e:expression').
Arguments expression  : default implicits.
Arguments expression' : default implicits.

Definition equiv_arguments_aux {A} equiv_expression :=
  fix equiv_arguments (a1 a2 : list (expression A)) : bool :=
    match a1, a2 with
    | nil     , nil      => true
    | e1 :: a1, e2 :: a2 => equiv_expression e1 e2 && equiv_arguments a1 a2
    | _       , _        => false
    end.
Arguments equiv_arguments_aux : default implicits.

Fixpoint equiv_expression' {A} (e1 e2 : expression' A) {struct e1} : bool :=
  let equiv_arguments := equiv_arguments_aux equiv_expression in
  match e1, e2 with
  | Unary uop1 e1, Unary uop2 e2 =>
      eq_unaryOperator uop1 uop2 &&
      equiv_expression e1 e2
  | Binary e1_1 bop1 e2_1, Binary e1_2 bop2 e2_2 =>
      equiv_expression e1_1 e1_2 &&
      eq_binaryOperator bop1 bop2 &&
      equiv_expression e2_1 e2_2
  | Assign e1_1 e2_1, Assign e1_2 e2_2 =>
      equiv_expression e1_1 e1_2 &&
      equiv_expression e2_1 e2_2
  | CompoundAssign e1_1 aop1 e2_1, CompoundAssign e1_2 aop2 e2_2 =>
      equiv_expression e1_1 e1_2 &&
      eq_arithmeticOperator aop1 aop2 &&
      equiv_expression e2_1 e2_2
  | Conditional e1_1 e2_1 e3_1, Conditional e1_2 e2_2 e3_2 =>
      equiv_expression e1_1 e1_2 &&
      equiv_expression e2_1 e2_2 &&
      equiv_expression e3_1 e3_2
  | Cast q1 t1 e1, Cast q2 t2 e2 =>
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2 &&
      equiv_expression e1 e2
  | Call e1 es1, Call e2 es2 =>
      equiv_expression e1 e2 &&
      equiv_arguments es1 es2
  | Constant c1, Constant c2 =>
      eq_constant c1 c2
  | Var v1, Var v2 =>
      eq_identifier v1 v2
  | SizeOf q1 t1, SizeOf q2 t2 =>
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2
  | AlignOf q1 t1, AlignOf q2 t2 =>
      eq_qualifiers q1 q2 &&
      eq_ctype t1 t2
  | _, _ => false
  end
with equiv_expression {A} (e1 e2 : expression A) {struct e1} : bool :=
  match e1, e2 with
  | AnnotatedExpression _ e1, AnnotatedExpression _ e2 => equiv_expression' e1 e2
  end.

Definition equiv_arguments {A} (a1 a2 : list (expression A)) :=
  equiv_arguments_aux equiv_expression a1 a2.

Definition gamma : Set := list (identifier * (qualifiers * ctype)).
Definition bindings : Set := list (identifier * (qualifiers * ctype)).
 
Inductive statement' {A B : Set} : Set := 
 | Skip
 | Expression (e:expression B)
 | Block (b:bindings) (ss:list statement)
 | If (e:expression B) (s1:statement) (s2:statement)
 | While (e:expression B) (s:statement)
 | Do (s:statement) (e:expression B)
 | Break
 | Continue
 | ReturnVoid
 | Return (e:expression B)
 | Switch (e:expression B) (s:statement)
 | Case (ic:integerConstant) (s:statement)
 | Default (s:statement)
 | Label (v:identifier) (s:statement)
 | Goto (v:identifier)
 | Declaration (d:list (identifier * expression B))
with statement {A B : Set} : Set :=
 | AnnotatedStament (a:A) (s:statement).
Arguments statement  : default implicits.
Arguments statement' : default implicits.

(* Currently unused.
Definition declaration : Set := identifier * option storageDuration.
*)

Definition sigma {A B} : Set := list (identifier * ((ctype * bindings) * statement A B)).
Arguments sigma  : default implicits.

Definition parameters_of_bindings : bindings -> list (qualifiers * ctype) := map snd.

Definition type_from_sigma {A B} (f : (ctype * bindings) * statement A B) :=
  Function (fst (fst f)) (parameters_of_bindings (snd (fst f))).
Arguments type_from_sigma  : default implicits.

Definition program {A B} : Set := identifier * sigma A B.
Arguments program  : default implicits.
(** induction principles *)
