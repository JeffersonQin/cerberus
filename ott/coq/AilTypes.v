(* generated by Ott 0.21.2 from: AilTypes_.ott *)

Require Import Common.
Require Import Bool.
Require Import List.

Inductive integerBaseType : Set :=  (*r standard signed integer types (\S6.2.5\#4) *)
 | Ichar : integerBaseType (*r corresponds to \textbf{signed/unsigned char} *)
 | Short : integerBaseType (*r corresponds to \textbf{short int} *)
 | Int : integerBaseType
 | Long : integerBaseType (*r corresponds to \textbf{long int} *)
 | LongLong : integerBaseType (*r corresponds to \textbf{long long int} *).

Definition eq_integerBaseType x y :=
  match x, y with
  | Ichar   , Ichar    => true
  | Short   , Short    => true
  | Int     , Int      => true
  | Long    , Long     => true
  | LongLong, LongLong => true
  | _       , _        => false
  end.

Lemma eq_integerBaseType_correct x y :
  boolSpec (eq_integerBaseType x y) (x = y).
Proof. destruct x, y; my_auto. Qed.

Inductive integerType : Set :=  (*r integer types (\S6.2.5\#17) *)
 | Char : integerType
 | Bool : integerType (*r corresponds to \textbf{\_Bool} *)
 | Signed (ibt:integerBaseType)
 | Unsigned (ibt:integerBaseType).

Definition eq_integerType x y :=
  match x, y with
  | Char         , Char          => true
  | Bool         , Bool          => true
  | Signed   ibt1, Signed   ibt2 => eq_integerBaseType ibt1 ibt2
  | Unsigned ibt1, Unsigned ibt2 => eq_integerBaseType ibt1 ibt2
  | _            , _             => false
  end.

Lemma eq_integerType_correct x y :
  boolSpec (eq_integerType x y) (x = y).
Proof.
  destruct x, y; simpl;
  match goal with
  | |- context[eq_integerBaseType ?x ?y] => set (eq_integerBaseType_correct x y); boolSpec_destruct
  | _ => idtac
  end; my_auto.
Qed.

Ltac destruct_integerType_hyp H :=
  let ibt := fresh in
  destruct H as [| |ibt|ibt];
  try destruct ibt.

Ltac destruct_integerBaseType :=
  repeat match goal with
  | [ ibt : integerBaseType |- _] => destruct ibt
  end.

Ltac destruct_integerType :=
  repeat match goal with
  | [ it  : integerType     |- _] => destruct it
  | [ ibt : integerBaseType |- _] => destruct ibt
  end.

Ltac clear_integerType :=
  repeat match goal with
  | [ it  : integerType     |- _] => clear dependent it
  | [ ibt : integerBaseType |- _] => clear dependent ibt
end.

Record qualifiers := make_qualifiers {
  const_qualified : bool;
  restrict_qualified : bool;
  volatile_qualified : bool
}.

Definition eq_qualifiers x y := 
     Bool.eqb (const_qualified    x) (const_qualified    y)
  && Bool.eqb (restrict_qualified x) (restrict_qualified y)
  && Bool.eqb (volatile_qualified x) (volatile_qualified y).

Lemma eq_qualifiers_correct x y :
  boolSpec (eq_qualifiers x y) (x = y).
Proof.
  repeat match goal with
  | q : qualifiers |- _ => destruct q
  | b : bool       |- _ => destruct b
  end; my_auto.
Qed.

Inductive basicType : Set :=  (*r basic types (\S6.2.5\#14) *)
 | Integer (it:integerType).

Definition eq_basicType x y :=
  match x, y with
  | Integer x, Integer y => eq_integerType x y
  end.

Lemma eq_basicType_correct x y :
  boolSpec (eq_basicType x y) (x = y).
Proof.
  destruct x, y; simpl;
  match goal with
  | |- context[eq_integerType ?x ?y] => set (eq_integerType_correct x y); boolSpec_destruct
  | _ => idtac
  end; my_auto.
Qed.

Inductive ctype : Set :=  (*r $\texttt{Ail}_\tau$ types *)
 | Void : ctype (*r \texttt{void} type (\S6.2.5\#19) *)
 | Basic (bt:basicType) (*r basic types (\S6.2.5\#14) *)
 | Array (t:ctype) (n:nat) (*r array types (\S6.2.5\#20) *)
 | Function (t:ctype) (p:list (qualifiers * ctype)) (*r function types *)
 | Pointer (q:qualifiers) (t:ctype) (*r pointer types *).

Definition ctype_nrect
         (P : ctype -> Type)
         (Q : list (qualifiers * ctype) -> Type)

         (Hnil      : Q nil)
         (Hcons     : forall {q} {t} {p}, P t -> Q p -> Q (cons (q,t) p))

         (HVoid     : P Void)
         (HBasic    : forall {bt}, P (Basic bt))
         (HArray    : forall {t} {n}, P t -> P (Array t n))
         (HFunction : forall {t} {p}, P t -> Q p -> P (Function t p))
         (HPointer  : forall {q : qualifiers} {t : ctype}, P t -> P (Pointer q t)) :
  forall t, P t
:=
  fix f t : P t :=
    match t return P t with
    | Void         => HVoid
    | Basic    _   => HBasic
    | Array    _ _ => HArray    (f _)
    | Function _ p => let fix g p : Q p :=
                        match p return Q p with
                        | nil          => Hnil
                        | cons (_,t) p => Hcons (f t) (g p)
                        end in
                      HFunction (f _) (g _)
    | Pointer  _ _ => HPointer  (f _)
    end.

Fixpoint eq_ctype x y :=
  match x, y with
  | Void          , Void           => true
  | Basic    bt1  , Basic bt2      => eq_basicType bt1 bt2
  | Array    t1 n1, Array    t2 n2 => eq_ctype t1 t2 && eq_nat n1 n2
  | Function t1 p1, Function t2 p2 => let fix eq_params p1 p2 : bool :=
                                        match p1, p2 with
                                        | nil            , nil             => true
                                        | cons (q1,t1) p1, cons (q2,t2) p2 => eq_qualifiers q1 q2 && eq_ctype t1 t2 && eq_params p1 p2
                                        | _              , _               => false
                                        end in
                                      eq_ctype t1 t2 && eq_params p1 p2
  | Pointer  q1 t1, Pointer  q2 t2 => eq_qualifiers q1 q2 && eq_ctype t1 t2
  | _             , _              => false
  end.

Fixpoint eq_params (p1 p2 : list (qualifiers * ctype)) : bool :=
  match p1, p2 with
  | nil            , nil             => true
  | cons (q1,t1) p1, cons (q2,t2) p2 => eq_qualifiers q1 q2 && eq_ctype t1 t2 && eq_params p1 p2
  | _              , _               => false
  end.

Lemma eq_ctype_correct :
  forall x y, boolSpec (eq_ctype x y) (x = y).
Proof.
  apply (ctype_nrect (fun x => forall y, boolSpec (eq_ctype  x y) (x = y))
                     (fun x => forall y, boolSpec (eq_params x y) (x = y)));
  destruct y; simpl; fold eq_params;
  repeat (
    my_auto;
    match goal with
    | |- context[eq_basicType  ?x ?y] => set (eq_basicType_correct  x y)
    | |- context[eq_qualifiers ?x ?y] => set (eq_qualifiers_correct x y)
    | |- context[eq_nat        ?x ?y] => set (eq_nat_correct        x y)
    | H : forall _, boolSpec (eq_ctype  ?x _) _ |- context[eq_ctype  ?x ?y] => set (H y)
    | H : forall _, boolSpec (eq_params ?x _) _ |- context[eq_params ?x ?y] => set (H y)
    end;
    boolSpec_destruct
  ).
Qed.

Inductive typeCategory : Set := 
 | LvalueType (q:qualifiers) (t:ctype)
 | ExpressionType (t:ctype).

Definition eq_typeCategory x y : bool :=
  match x, y with
  | LvalueType q1  t1, LvalueType q2  t2 => eq_ctype t1 t2 && eq_qualifiers q1 q2
  | ExpressionType t1, ExpressionType t2 => eq_ctype t1 t2
  | _                , _                 => false
  end.

Lemma eq_typeCategory_correct x y :
  boolSpec (eq_typeCategory x y) (x = y).
Proof.
  destruct x, y;
  repeat (
    my_auto;
    match goal with
    | |- context[eq_ctype      ?x ?y] => set (eq_ctype_correct      x y)
    | |- context[eq_qualifiers ?x ?y] => set (eq_qualifiers_correct x y)
    end;
    boolSpec_destruct
  ).
Qed.

Inductive storageDuration : Set :=  (*r storage duration (\S6.2.4\#1) *)
 | Static : storageDuration
 | Thread : storageDuration
 | Automatic : storageDuration
 | Allocated : storageDuration.

Definition eq_storageDuration x y : bool := 
  match x, y with
  | Static   , Static    => true
  | Thread   , Thread    => true
  | Automatic, Automatic => true
  | Allocated, Allocated => true
  | _        , _         => false
  end.

Lemma eq_storageDuration_correct x y :
  boolSpec (eq_storageDuration x y) (x = y).
Proof. destruct x, y; my_auto. Qed.
