(* generated by Ott 0.21.2 from: AilTyping_.ott *)

Require Import Bool.
Require Import List.
Require Import Arith.
Require Export ZArith.

Require Import Common.
Require Import AilTypes.
Require Import AilSyntax.
Require Import AilTypesAux AilTypesAux_fun AilTypesAux_proof.
Require Import AilSyntaxAux AilSyntaxAux_fun AilSyntaxAux_proof.
Require Import AilWf.
Require Import Implementation.

(** definitions *)

Inductive Lookup {A B : Type} : list (A * B) -> A -> B -> Type :=
  | Lookup_hd     a b E :                           Lookup (cons (a,b) E) a b
  | Lookup_tl x y a b E : x <> a -> Lookup E a b -> Lookup (cons (x,y) E) a b.

Fixpoint Lookup_unique {A B : Type} E (a : A) (b1 b2 : B) (L1 : Lookup E a b1) (L2 : Lookup E a b2) {struct E} : b1 = b2.
Proof.
  destruct E; simple inversion L1; simple inversion L2; try congruence; intros.
  + match goal with
    | [L1 : Lookup ?E1 _ _, L2 : Lookup ?E2 _ _ |- _] =>
        is_var E1; is_var E2;
        assert (E1 = E) by congruence;
        assert (E2 = E) by congruence
    end.
    eapply (Lookup_unique A B E a b1 b2); subst; eassumption.
Qed.

Fixpoint lookup_find {A B} (eq : A -> A -> bool) (E : list (A * B)) (a : A) : option B :=
  match E with
  | nil          => None
  | cons (x,b) E => if eq x a then Some b
                              else lookup_find eq E a
  end.

Fixpoint lookup_find_correct {A B} {eq : A -> A -> bool} (E : list (A * B)) (a : A) {struct E} :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  match lookup_find eq E a with
  | Some b => Lookup E a b
  | None   => forall b, neg (Lookup E a b)
  end.
Proof.
  intros eq_correct.
  unfold_goal.
  destruct E; simpl.
  + intros ?; inversion 1.
  + destruct p as [x b]; simpl.
    set (eq_correct x a).
    case_eq (eq x a); boolSpec_simpl; simpl.
    - my_auto.
    - fold (lookup_find eq E a).
      set (lookup_find_correct A B eq E a eq_correct).
      case_eq (lookup_find eq E a).
      * intros ? Heq.
        rewrite Heq in *; my_auto.
      * intros Heq.
        rewrite Heq in *.
        intros ?; inversion 1; firstorder.
Defined.

Fixpoint lookup_find_unique {A B} {eq : A -> A -> bool} (E : list (A * B)) (a : A) (b : B) {struct E} :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  Lookup E a b ->
  lookup_find eq E a = Some b.
Proof.
  intros eq_correct.
  destruct E.
  + my_auto.
  + inversion 1; simpl; set (eq_correct a a); boolSpec_destruct; my_auto.
    set (eq_correct x a); boolSpec_simpl; my_auto.
Defined.

Instance identifier_DecEq : DecidableEq identifier.
Proof. dec_eq. Defined.
Definition id_eq x y := bool_of_decision (identifier_DecEq x y).
Definition id_eq_correct x y : boolSpec (id_eq x y) (x = y) := Decision_boolSpec (identifier_DecEq x y).
Definition lookup_id {B} E id : option B := lookup_find id_eq E id.
Lemma lookup_id_correct {B} E id :
  match lookup_id E id with
  | Some b => Lookup E id b
  | None   => forall b : B, neg (Lookup E id b)
  end.
Proof.
  unfold_goal.
  set (lookup_find_correct E id id_eq_correct) as H.
  case_eq (lookup_find id_eq E id).
  + intros ? Heq.
    rewrite Heq in H.
    assumption.
  + intros Heq.
    rewrite Heq in H.
    assumption.
Qed.

Definition lookup_id_unique {B} {E} {id} {b:B} : Lookup E id b -> lookup_id E id = Some b :=
  lookup_find_unique E id b id_eq_correct.

Definition add {A:Type} (E : list (identifier * A)) (v : identifier) (a : A) :=
  (v, a) :: E.

Inductive isPromotion (P : impl) : type -> type -> Prop :=
 | IsPromotion :
     forall it1 it2,
       isIntegerPromotion P it1 it2 ->
       isPromotion P (Basic (Integer it1)) (Basic (Integer it2)).

Definition isPromotion_fun P t1 t2 : bool :=
  match t1, t2 with
  | Basic (Integer it1), Basic (Integer it2) => isIntegerPromotion_fun P it1 it2
  | _                  , _                   => false
  end.

Lemma isPromotion_fun_correct P t1 t2 : boolSpec (isPromotion_fun P t1 t2) (isPromotion P t1 t2).
Proof.
  do 2 unfold_goal.
  my_auto; intros Heq; [
    set (boolSpec_elim1 (isIntegerPromotion_fun_correct P _ _) Heq)
  | set (boolSpec_elim2 (isIntegerPromotion_fun_correct P _ _) Heq)]; my_auto.
Qed.

Definition isPromotion_find P t : option type :=
  match t with
  | Basic (Integer it) => Some (Basic (Integer (isIntegerPromotion_find P it)))
  | _                  => None
  end.

Lemma isPromotion_find_correct P t1 :
  match isPromotion_find P t1 with
  | Some t2 => isPromotion P t1 t2
  | None    => forall t2, neg (isPromotion P t1 t2)
  end.
Proof.
  unfold_goal; repeat var_destruct.
  constructor; apply isIntegerPromotion_find_correct.
Qed.

Lemma isPromotion_find_unique P t1 t2 : isPromotion P t1 t2 -> isPromotion_find P t1 = Some t2.
Proof.
  unfold_goal.
  inversion 1.
  repeat apply f_equal.
  apply isIntegerPromotion_find_unique.
  assumption.
Qed.

Inductive isBinaryArithmetic : type -> arithmeticOperator -> type -> Prop :=    (* defn eType *)
 | IsBinaryArithmeticMul : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Mul ty2
 | IsBinaryArithmeticDiv : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Div ty2
 | IsBinaryArithmeticMod : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Mod ty2
 | IsBinaryArithmeticAddArithmetic : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Add ty2
 | IsBinaryArithmeticSubArithmetic : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Sub ty2
 | IsBinaryArithmeticShiftL : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Shl ty2
 | IsBinaryArithmeticShiftR : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Shr ty2
 | IsBinaryArithmeticBand : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Band ty2
 | IsBinaryArithmeticXor : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Xor ty2
 | IsBinaryArithmeticBor : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Bor ty2.

Lemma isBinaryArithmetic_Arithmetic {aop} {ty1 ty2} :
  isBinaryArithmetic ty1 aop ty2 ->
  isArithmetic ty1 * isArithmetic ty2.
Proof.
  inversion 1;
  repeat match goal with
  | [H : isInteger _ |- _ ] => apply IsArithmeticInteger in H
  end; split; assumption.
Qed.

Inductive lvalueConversion : type -> type -> Prop :=
  | LvalueConversion : forall ty1 ty2,
      isLvalueConvertible ty1 ->
      pointerConvert ty1 = ty2 ->
      lvalueConversion ty1 ty2.

Definition lvalueConversion_find t : option type :=
  if isLvalueConvertible_fun t then
    Some (pointerConvert t)
  else
    None.

Lemma lvalueConversion_find_correct t1 : optionSpec (lvalueConversion_find t1) (lvalueConversion t1).
Proof. do 2 unfold_goal; context_destruct; case_fun (isLvalueConvertible_fun_correct t1); my_auto. Qed.

Ltac context_destruct :=
  match goal with
  | [|- match ?c with _ => _ end] =>
      context_destruct_inner c
  | [|- ((match ?c with _ => _ end) = _)] =>
      context_destruct_inner c
  | [|- ((match ?c with _ => _ end) = _) -> _] =>
      context_destruct_inner c
  | [|- (match ?c with _ => _ end) -> _] =>
      context_destruct_inner c
  end.

Lemma lvalueConversion_find_unique t1 : optionUnique (lvalueConversion_find t1) (lvalueConversion t1).
Proof. do 2 unfold_goal; inversion 1; context_destruct; case_fun (isLvalueConvertible_fun_correct t1); my_auto. Qed.

(* Lemma: it doesn't matter whether we check isPointer before or after lvalue conversion. *)
Lemma pointConvert_isPointer t : isLvalueConvertible t -> (isPointer t <-> isPointer (pointerConvert t)).
Proof.
  inversion 1 as [? Hnarray Hcomplete].
  destruct t; split;
  solve [ trivial
        | exfalso; apply Hnarray; constructor
        | inversion Hcomplete ].
Qed.

Lemma pointConvert_lvalueConversion t1 t2 : lvalueConversion t1 t2 -> (isPointer t1 <-> isPointer t2).
Proof. inversion 1; subst; apply pointConvert_isPointer; assumption. Qed.

(* Pointer conversion leaves integers untouched. *)
Lemma pointerConvert_Integer_id {t} : isInteger t -> pointerConvert t = t.
Proof. inversion 1; reflexivity. Qed.

Lemma pointerConvert_Integer {t} : isInteger (pointerConvert t) -> isInteger t.
Proof. destruct t; inversion 1; subst; assumption. Qed.

Lemma pointerConvert_Arith_id {t} : isArithmetic t -> pointerConvert t = t.
Proof. inversion 1; apply pointerConvert_Integer_id; assumption. Qed.

Lemma pointerConvert_Arith {t} : isArithmetic (pointerConvert t) -> isArithmetic t.
Proof. inversion 1; constructor; apply pointerConvert_Integer; assumption. Qed.

(* Pointer conversion leaves pointers untouched. *)
Lemma pointerConvert_Integer_Pointer {t} : isPointer t -> pointerConvert t = t.
Proof. inversion 1; reflexivity. Qed.

Definition combineQualifiers qs1 qs2 := {|
  isConstQualified    := isConstQualified    qs1 || isConstQualified    qs2;
  isRestrictQualified := isRestrictQualified qs1 || isRestrictQualified qs2;
  isVolatileQualified := isVolatileQualified qs1 || isVolatileQualified qs2
|}.

Definition subQualifiers qs1 qs2 :=
     implb (isConstQualified    qs1) (isConstQualified    qs2)
  && implb (isRestrictQualified qs1) (isRestrictQualified qs2)
  && implb (isVolatileQualified qs1) (isVolatileQualified qs2).


Lemma inIntegerTypeRange_leIntegerTypeRange {P} {it1 it2} {n} :
  leIntegerTypeRange P it1 it2 ->
  inIntegerTypeRange P n it1 ->
  inIntegerTypeRange P n it2.
Proof.
  inversion_clear 1; inversion_clear 1; subst.
  match goal with
  | [H : le _ _ |- _ ] => inversion_clear H
  end.
  match goal with
  | [H : memNat _ _ |- _ ] => inversion_clear H
  end.
  constructor; constructor; eapply Z.le_trans; eassumption.
Qed.

Definition inIntegerTypeRange_Signed_Int_Long {P} {n} :=
  inIntegerTypeRange_leIntegerTypeRange (n:=n) (
    LeIntegerTypeRange _ _ _
      (integerTypeRange_precision_Signed P _ _ (IsSignedInt P _) (IsSignedInt P _) (lePrecision_Signed_Int_Long P))
  ).

Definition inIntegerTypeRange_Signed_Long_LongLong {P} {n} :=
  inIntegerTypeRange_leIntegerTypeRange (n:=n) (
    LeIntegerTypeRange _ _ _
      (integerTypeRange_precision_Signed P _ _ (IsSignedInt P _) (IsSignedInt P _) (lePrecision_Signed_Long_LongLong P))
  ).

Definition inIntegerTypeRange_Unsigned_Int_Long {P} {n} :=
  inIntegerTypeRange_leIntegerTypeRange (n:=n) (
    LeIntegerTypeRange _ _ _
      (integerTypeRange_precision_Unsigned P _ _ (IsUnsignedInt P _) (IsUnsignedInt P _) (lePrecision_Unsigned_Int_Long P))
  ).

Definition inIntegerTypeRange_Unsigned_Long_LongLong {P} {n} :=
  inIntegerTypeRange_leIntegerTypeRange (n:=n) (
    LeIntegerTypeRange _ _ _
      (integerTypeRange_precision_Unsigned P _ _ (IsUnsignedInt P _) (IsUnsignedInt P _) (lePrecision_Unsigned_Long_LongLong P))
  ).

Inductive cType : impl -> integerConstant -> integerType -> Prop :=    (* defn eType *)
 | CTypeInt P : forall (n:nat),
     inIntegerTypeRange P n (Signed Int) ->
     cType P (n , None) (Signed Int)
 | CTypeLong P : forall (n:nat),
      ~ inIntegerTypeRange P n (Signed Int)  ->
     inIntegerTypeRange P n (Signed Long) ->
     cType P (n , None) (Signed Long)
 | CTypeLongLong P : forall (n:nat),
      ~ inIntegerTypeRange P n (Signed Long)  ->
     inIntegerTypeRange P n (Signed LongLong) ->
     cType P (n , None) (Signed LongLong)
 | CTypeUInt P : forall (n:nat),
     inIntegerTypeRange P n (Unsigned Int) ->
     cType P (n , Some UnsignedInt) (Unsigned Int)
 | CTypeULong P : forall (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Int)  ->
     inIntegerTypeRange P n (Unsigned Long) ->
     cType P (n , Some UnsignedInt) (Unsigned Long)
 | CTypeULongLong P : forall (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Long)  ->
     inIntegerTypeRange P n (Unsigned LongLong) ->
     cType P (n , Some UnsignedInt) (Unsigned LongLong)
 | CTypeLLong P : forall (n:nat),
     inIntegerTypeRange P n (Signed Long) ->
     cType P (n , Some SignedLong) (Signed Long)
 | CTypeLLongLong P : forall (n:nat),
      ~ inIntegerTypeRange P n (Signed Long)  ->
     inIntegerTypeRange P n (Signed LongLong) ->
     cType P (n , Some SignedLong) (Signed LongLong)
 | CTypeULLong P : forall (n:nat),
     inIntegerTypeRange P n (Unsigned Long) ->
     cType P (n , Some UnsignedLong) (Unsigned Long)
 | CTypeULLongLong P : forall (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Long)  ->
     inIntegerTypeRange P n (Unsigned LongLong) ->
     cType P (n , Some UnsignedLong) (Unsigned LongLong)
 | CTypeLL P : forall (n:nat),
     inIntegerTypeRange P n (Signed LongLong) ->
     cType P (n , Some SignedLongLong) (Signed LongLong)
 | CTypeULL P : forall (n:nat),
     inIntegerTypeRange P n (Unsigned LongLong) ->
     cType P (n , Some UnsignedLongLong) (Unsigned LongLong).

Definition cType_fun P ic : option integerType :=
  match ic with
  | (n, None) =>
      if inIntegerTypeRange_fun P n (Signed Int) then
        Some (Signed Int)
      else if inIntegerTypeRange_fun P n (Signed Long) then
        Some (Signed Long)
      else if inIntegerTypeRange_fun P n (Signed LongLong) then
        Some (Signed LongLong)
      else
        None
  | (n, Some UnsignedInt) =>
      if inIntegerTypeRange_fun P n (Unsigned Int) then
        Some (Unsigned Int)
      else if inIntegerTypeRange_fun P n (Unsigned Long) then
        Some (Unsigned Long)
      else if inIntegerTypeRange_fun P n (Unsigned LongLong) then
        Some (Unsigned LongLong)
      else
        None
  | (n, Some SignedLong) =>
      if inIntegerTypeRange_fun P n (Signed Long) then
        Some (Signed Long)
      else if inIntegerTypeRange_fun P n (Signed LongLong) then
        Some (Signed LongLong)
      else
        None
  | (n, Some UnsignedLong) =>
      if inIntegerTypeRange_fun P n (Unsigned Long) then
        Some (Unsigned Long)
      else if inIntegerTypeRange_fun P n (Unsigned LongLong) then
        Some (Unsigned LongLong)
      else
        None
  | (n, Some SignedLongLong) =>
      if inIntegerTypeRange_fun P n (Signed LongLong) then
        Some (Signed LongLong)
      else
        None
  | (n, Some UnsignedLongLong) =>
      if inIntegerTypeRange_fun P n (Unsigned LongLong) then
        Some (Unsigned LongLong)
      else
        None
  end.

Lemma cType_fun_correct P ic :
  match cType_fun P ic with
  | Some it => cType P ic it * forall it', cType P ic it' -> it = it'
  | None    => forall it, neg (cType P ic it)
  end.
Proof.
  unfold_goal.
  destruct ic; simpl;
  repeat match goal with
  | [|- inIntegerTypeRange_fun P ?n ?it = ?o -> _] => case_fun (inIntegerTypeRange_fun_correct P n it)
  | [H : ~ inIntegerTypeRange P ?n (Signed Long) |- _] =>
      notHyp (inIntegerTypeRange P n (Signed Int) -> False);
      unfold not in H;
      set (Program.Basics.compose H inIntegerTypeRange_Signed_Int_Long) ;
      contradiction
  | [H : ~ inIntegerTypeRange P ?n (Unsigned Long) |- _] =>
      notHyp (inIntegerTypeRange P n (Unsigned Int) -> False);
      unfold not in H;
      set (Program.Basics.compose H inIntegerTypeRange_Unsigned_Int_Long) ;
      contradiction
  | [|- cType _ _ _] => econstructor (eassumption)
  | [|- forall _, neg (cType _ _ _)] => inversion 1; subst
  | [|- forall _, cType _ _ _ -> _ = _] => inversion 1; subst
  | [|-  _ * _] => split
  | _ => context_destruct
  end; solve [congruence | contradiction].
Qed.

Lemma cType_unique {P} {ic} {it1 it2} :
  cType P ic it1 ->
  cType P ic it2 ->
  it1 = it2.
Proof.
  generalize (cType_fun_correct P ic).
  destruct (cType_fun P ic).
  + intros [? Hunique] H1 H2.
    set (Hunique _ H1).
    set (Hunique _ H2).
    congruence.
  + firstorder.
Qed.

(* defns JeType *)
Inductive eType : impl -> gamma -> sigma -> expression -> typeCategory -> Prop :=    (* defn eType *)
 | ETypeVariable : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (qs:qualifiers) (ty:type),
     Lookup G id (qs, ty)  ->
     eType P G S (Var id) (LvalueType qs ty)
 | ETypeFunction : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (ty:type) p,
     Lookup S id p ->
     typeOfSigma p = ty ->
     eType P G S (Var id) (ExpressionType ty)
 | ETypeConstant : forall (P:impl) (G:gamma) (S:sigma) ic it,
     cType P ic it ->
     eType P G S (Constant (ConstantInteger ic)) (ExpressionType (Basic (Integer it)))
 | ETypeCall : forall (ls:arguments) (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) qs (ty:type),
     isUnqualified qs ->
     expressionType P G S e (Pointer qs (Function ty ps)) ->
     eType_arguments P G S ls ps ->
     eType P G S (Call e ls) (ExpressionType ty)
 | ETypeAddressFunction : forall (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) qs (ty:type),
     eType P G S e (ExpressionType (Function ty ps)) ->
     isUnqualified qs ->
     eType P G S (Unary Address e) (ExpressionType (Pointer qs (Function ty ps)))
 | ETypeAddressLvalue : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     eType P G S e (LvalueType qs ty) ->
     eType P G S (Unary Address e) (ExpressionType (Pointer qs ty))
 | ETypeIndirectionObject : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     expressionType P G S e (Pointer qs ty) ->
     isComplete ty ->
     isObject ty ->
     eType P G S (Unary Indirection e) (LvalueType qs ty)
 | ETypeIndirectionFunction : forall (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) qs (ty:type),
     isUnqualified qs ->
     expressionType P G S e (Pointer qs (Function ty ps)) ->
     eType P G S (Unary Indirection e) (ExpressionType (Pointer qs (Function ty ps)))
 | ETypePostfixIncrementPointer : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isPointer ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixIncr e) (ExpressionType ty)
 | ETypePostfixIncrementReal : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isReal ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixIncr e) (ExpressionType ty)
 | ETypePostfixDecrementPointer : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isPointer ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixDecr e) (ExpressionType ty)
 | ETypePostfixDecrementReal : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isReal ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixDecr e) (ExpressionType ty)
 | ETypePlus : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isArithmetic ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Plus e) (ExpressionType ty)
 | ETypeMinus : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isArithmetic ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Minus e) (ExpressionType ty)
 | ETypeBnot : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isInteger ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Bnot e) (ExpressionType ty)
 | ETypeSizeOf : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty ty':type),
     wfLvalueType qs ty ->
      ~ (  isFunction ty  )  ->
      ~ (  isIncomplete ty  )  ->
      Implementation.size_t  P  =  ty'  ->
     eType P G S (SizeOf qs ty) (ExpressionType ty')
 | ETypeAlignOf : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty ty':type),
     wfLvalueType qs ty ->
      ~ (  isFunction ty  )  ->
      ~ (  isIncomplete ty  )  ->
      Implementation.size_t  P  =  ty'  ->
     eType P G S (AlignOf qs ty) (ExpressionType ty')
 | ETypeCastScalar : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty:type) (e:expression) (ty':type),
     wfLvalueType qs ty ->
     expressionType P G S e ty' ->
     isScalar ty' ->
     isScalar ty ->
     eType P G S (Cast qs ty e) (ExpressionType ty)
 | ETypeCastVoid : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (e:expression) (ty:type),
     wfLvalueType qs Void ->
     expressionType P G S e ty ->
     eType P G S (Cast qs Void e) (ExpressionType Void)
 | ETypeMul : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Mul ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Mul) e2) (ExpressionType ty)
 | ETypeDiv : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Div ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Div) e2) (ExpressionType ty)
 | ETypeMod : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Mod ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Mod) e2) (ExpressionType ty)
 | ETypeAddArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Add ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType ty)
 | ETypeAddPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isComplete ty1 ->
     isInteger ty2 ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAddPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs2:qualifiers) (ty2 ty1:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isInteger ty1 ->
     isComplete ty2 ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType (Pointer qs2 ty2))
 | ETypeSubArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Sub ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType ty)
 | ETypeSubPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isComplete ty1 ->
     isInteger ty2 ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeSubPointerDiff : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty:type) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isComplete ty1 ->
     isComplete ty2 ->
     isCompatible ty1 ty2 ->
      Implementation.ptrdiff_t  P  =  ty  ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType ty)
 | ETypeShiftL : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1' ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Shl ty2 ->
     isPromotion P ty1 ty1' ->
     eType P G S (Binary e1 (Arithmetic Shl) e2) (ExpressionType ty1')
 | ETypeShiftR : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1' ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Shr ty2 ->
     isPromotion P ty1 ty1' ->
     eType P G S (Binary e1 (Arithmetic Shr) e2) (ExpressionType ty1')
 | ETypeLtReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Lt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLtPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Lt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGtReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Gt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGtPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Gt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLeReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Le e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Le e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGeReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Ge e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Ge e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1 qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 Void) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 Void) ->
     isObject ty1 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqNull1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isNullPointerConstant e1 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqNull2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1 qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 Void) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 Void) ->
     isObject ty1 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeNull1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isNullPointerConstant e1 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeNull2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeBand : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Band ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Band) e2) (ExpressionType ty)
 | ETypeXor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Xor ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Xor) e2) (ExpressionType ty)
 | ETypeBor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Bor ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Bor) e2) (ExpressionType ty)
 | ETypeAnd : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isScalar ty1 ->
     isScalar ty2 ->
     eType P G S (Binary e1 And e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeOr : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isScalar ty1 ->
     isScalar ty2 ->
     eType P G S (Binary e1 Or e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeConditionalArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty ty1 ty2 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isArithmetic ty2 ->
     isArithmetic ty3 ->
     isUsualArithmetic P ty2 ty3 ty ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty)
 | ETypeConditionalVoid : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty1:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 Void ->
     expressionType P G S e3 Void ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType Void)
 | ETypeConditionalPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3 qs:qualifiers) (ty ty1 ty2 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isCompatible ty2 ty3 ->
     isComposite ty2 ty3 ty ->
     combineQualifiers qs2 qs3 = qs ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer qs ty))
 | ETypeConditionalNullPointer1_Pointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty3 ty1 ty2:type) qs2 qs3 qs,
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isNullPointerConstant e2 ->
     combineQualifiers qs2 qs3 = qs ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer qs ty3))
 | ETypeConditionalNullPointer1_Other : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty3 ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     ~ isPointer ty2 ->
     isPointer ty3 ->
     isNullPointerConstant e2 ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty3)
 | ETypeConditionalNullPointer2_Pointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty2 ty1 ty3:type) qs2 qs3 qs,
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isNullPointerConstant e3 ->
     combineQualifiers qs2 qs3 = qs ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer qs ty2))
 | ETypeConditionalNullPointer2_Other : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty2 ty1 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isPointer ty2 ->
     ~ isPointer ty3 ->
     isNullPointerConstant e3 ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty2)
 | ETypeConditionalPointerVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3 qs:qualifiers) (ty2 ty1 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     neg (isCompatible ty2 ty3) ->
     neg (isNullPointerConstant e2) ->
     isVoid ty2 ->
     isObject ty3 ->
     combineQualifiers qs2 qs3 = qs ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer qs ty2))
 | ETypeConditionalPointerVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3 qs:qualifiers) (ty3 ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     neg (isCompatible ty2 ty3) ->
     neg (isNullPointerConstant e3) ->
     isObject ty2 ->
     isVoid ty3 ->
     combineQualifiers qs2 qs3 = qs ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer qs ty3))
 | ETypeAssign : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty:type),
     eType P G S e1 (LvalueType qs1 ty1) ->
     isModifiable qs1 ty1 ->
     pointerConvert ty1 = ty ->
     isAssignable P G S ty e2 ->
     eType P G S (Assign e1 e2) (ExpressionType ty)
 | ETypeCompoundAssignPlusMinusArithmetic : forall (P:impl) (G:gamma) (S:sigma) aop (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2 :type),
     (aop = Add) + (aop = Sub) ->
     eType P G S e1 (LvalueType qs ty) ->
     lvalueConversion ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (CompoundAssign e1 aop e2) (ExpressionType ty1)
 | ETypeCompoundAssignPlusMinusPointer : forall (P:impl) (G:gamma) (S:sigma) aop (e1 e2:expression) (ty1:type) (qs' qs:qualifiers) (ty ty2:type),
     (aop = Add) + (aop = Sub) ->
     eType P G S e1 (LvalueType qs' (Pointer qs ty)) ->
     lvalueConversion (Pointer qs ty) ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs' (Pointer qs ty)  ->
     isComplete ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 aop e2) (ExpressionType ty1)
 | ETypeCompoundAssign : forall (P:impl) (G:gamma) (S:sigma) aop (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     neg ((aop = Add) + (aop = Sub)) ->
     eType P G S e1 (LvalueType qs ty) ->
     lvalueConversion ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isBinaryArithmetic ty1 aop ty2 ->
     eType P G S (CompoundAssign e1 aop e2) (ExpressionType ty1)
 | ETypeComma : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty2 ty1:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     eType P G S (Binary e1 Comma e2) (ExpressionType ty2)
with expressionType : impl -> gamma -> sigma -> expression -> type -> Prop :=    (* defn expressionType *)
 | ExpressionTypeExpressionT : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     eType P G S e (ExpressionType ty') ->
     pointerConvert ty' = ty ->
     expressionType P G S e ty
 | ExpressionTypeLvalueT : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type) (qs:qualifiers),
     eType P G S e (LvalueType qs ty') ->
     lvalueConversion ty' ty ->
     expressionType P G S e ty
with typeable : impl -> gamma -> sigma -> expression -> Prop :=    (* defn typeable *)
 | TypeableDef : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (typeCategory:typeCategory),
     eType P G S e typeCategory ->
     typeable P G S e
with eType_arguments : impl -> gamma -> sigma -> arguments -> params -> Prop :=    (* defn isAssignable *)
 | ETypeNil P G S : eType_arguments P G S ArgumentsNil ParamsNil
 | ETypeCons P G S ls ps : forall e qs ty ty',
     pointerConvert ty = ty' ->
     isAssignable P G S ty' e ->
     eType_arguments P G S ls ps ->
     eType_arguments P G S (ArgumentsCons e ls) (ParamsCons qs ty ps)
with isAssignable : impl -> gamma -> sigma -> type -> expression -> Prop :=
 | IsAssignableArithmetic : forall P G S e2 ty1 ty2,
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isAssignable P G S ty1 e2
 | IsAssignablePointer : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (qs1 qs2:qualifiers) (ty1 ty2:type),
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     subQualifiers qs2 qs1 = true ->
     isAssignable P G S (Pointer qs1 ty1) e2
 | IsAssignableVoidPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (qs1 qs2:qualifiers) (ty1 ty2:type),
     isVoid ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     subQualifiers qs2 qs1 = true ->
     isAssignable P G S (Pointer qs1 ty1) e2
 | IsAssignableVoidPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (qs1 qs2:qualifiers) (ty1 ty2:type),
     isObject ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isVoid ty2 ->
     subQualifiers qs2 qs1 = true ->
     isAssignable P G S (Pointer qs1 ty1) e2
 | IsAssignableNullPointerConstant : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (ty1 ty2:type),
     isPointer ty1 ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     isAssignable P G S ty1 e2
 | IsAssignableBool : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (ty1 ty2:type),
     isBool ty1 ->
     expressionType P G S e2 ty2 ->
     isPointer ty2 ->
     isAssignable P G S ty1 e2.

Definition Disjoint {A B1 B2} E1 E2 : Type :=
  forall (a : A) (b1 : B1) (b2 : B2), Lookup E1 a b1 -> Lookup E2 a b2 -> False.

Definition env_sub {A B} (P : A -> Type) (E1 E2 : list (A * B)) :=
  forall id, P id -> forall b, Lookup E1 id b -> Lookup E2 id b.

Definition env_equiv {A B} (P : A -> Type) (E1 E2 : list (A * B)) :=
  env_sub P E1 E2 * env_sub P E2 E1.

Fixpoint eType_env_sub P (G1 G2:gamma) (S:sigma) e {struct e} :
  env_sub (fun id => fv id e) G1 G2 ->
  forall tc,
  eType P G1 S e tc -> eType P G2 S e tc
with eType_arguments_env_sub P (G1 G2 :gamma) (S:sigma) l p {struct l} :
  env_sub (fun id => fv_arguments id l) G1 G2 ->
  eType_arguments P G1 S l p ->
  eType_arguments P G2 S l p.
Proof.
  + destruct e; intros Hfree;
    inversion 1; subst;
    match goal with
    | [ H1 : expressionType  P G1 S _  _
      , H2 : expressionType  P G1 S _  _
      , H3 : expressionType  P G1 S _  _      |- _] => inversion H1; inversion H2; inversion H3; subst
    | [ H1 : expressionType  P G1 S _  _
      , H2 : expressionType  P G1 S _  _      |- _] => inversion H1; inversion H2; subst
    | [ H  : expressionType  P G1 S _  _      |- _] => inversion H; subst
    | [ H  : isAssignable P G1 S ?e _      |- _] => inversion H; subst;
                                                       match goal with | [H : expressionType  P G1 S ?e _ |- _] => inversion H; subst end
    | [ H  : eType           P G1 S (Var _) _ |- _] => inversion H; subst
    | _ => idtac
    end;
    repeat match goal with
    | [H: eType _ G1 _ ?e _|- _] =>
        notHyp (env_sub (fun id => fv id e) G1 G2);
        let Hfree_sub := fresh in
        assert (env_sub (fun id => fv id e) G1 G2) as Hfree_sub
          by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
        set (eType_env_sub _ G1 G2 _ _ Hfree_sub _ H)
    | [H : eType_arguments P G1 _ ?l _ |- _] =>
        notHyp(env_sub (fun id => fv_arguments id l) G1 G2) ;
        let Hfree_sub := fresh in
        assert (env_sub (fun id => fv_arguments id l) G1 G2) as Hfree_sub
          by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
        set (eType_arguments_env_sub _ G1 G2 _ _ _ Hfree_sub H)
    | [H : Lookup G1 ?v ?p |- eType _ ?G _ (Var ?v) _] =>
        notHyp (Lookup G2 v p);
        assert (Lookup G2 id p) by (apply (Hfree id (FvVariable id)); assumption)
    end;
    econstructor (
      solve [ eassumption
            | econstructor (eassumption)
            | finish eassumption
            | match goal with
              | [|- isAssignable _ _ _ _ _] =>
                  econstructor (
                    solve [ econstructor (solve [ econstructor (eassumption) | finish eassumption ])
                          | eassumption]
                  )
              end
            | apply eq_sym; eassumption ]
    ).
  + destruct l; intros Hfree; inversion 1; subst.
    - constructor.
    - match goal with
      | [ H  : isAssignable P G1 S ?e _ |- _] => inversion H; subst;
          match goal with
          | [H : expressionType  P G1 S ?e _ |- _] => inversion H; subst
          end
      end;
      repeat match goal with
      | [H: eType _ G1 _ ?e _|- _] =>
          notHyp (env_sub (fun id => fv id e) G1 G2);
          let Hfree_sub := fresh in
          assert (env_sub (fun id => fv id e) G1 G2) as Hfree_sub
            by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
        set (eType_env_sub _ G1 G2 _ _ Hfree_sub _ H)
      | [H : eType_arguments P G1 _ ?l _ |- _] =>
          notHyp(env_sub (fun id => fv_arguments id l) G1 G2) ;
          let Hfree_sub := fresh in
          assert (env_sub (fun id => fv_arguments id l) G1 G2) as Hfree_sub
            by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
          set (eType_arguments_env_sub _ G1 G2 _ _ _ Hfree_sub H)
      end;
      econstructor (solve
        [ apply eq_sym; eassumption
        | econstructor (solve [econstructor (eassumption) | finish eassumption])
        | eassumption ]).
Qed.
      
(* Coq's insanely stupid termination checker won't allow me to write a
mutually recursive function so I am resorting to open recursion + tying the
knot manually. *)
Definition expressionType_aux_find tc : option type :=
  match tc with
  | ExpressionType   ty => Some (pointerConvert ty)
  | LvalueType     _ ty => lvalueConversion_find ty
  end.

Lemma expressionType_aux_find_correct_pos {P} {G} {S} {e} {tc} {ty} :
  eType P G S e tc ->
  expressionType_aux_find tc = Some ty ->
  expressionType P G S e ty.
Proof.
  intros ?.
  unfold_goal.
  repeat match goal with
  | [|- lvalueConversion_find ?ty = _ -> _] =>
      let Heq := fresh in
      set (lvalueConversion_find_correct ty);
      intros Heq; rewrite Heq in *;
      econstructor 2; eassumption
  | [|- Some _ = Some _ -> _] =>
      injection 1; intros ?; my_auto
  | _ => context_destruct
  end.
Qed.

Lemma expressionType_aux_find_correct_neg {P} {G} {S} {e} {tc} :
  eType P G S e tc ->
  (forall tc', eType P G S e tc' -> tc = tc') ->
  expressionType_aux_find tc = None ->
  forall ty, neg (expressionType P G S e ty).
Proof.
  intros ? Hunique.
  unfold_goal.
  context_destruct;
  match goal with
  | [|- context[lvalueConversion_find ?ty]] =>
      let Heq := fresh in
      set (lvalueConversion_find_correct ty);
      intros Heq; rewrite Heq in *
  end;
  inversion 1; subst;
  match goal with
  | [ Hunique : forall _ : typeCategory, eType P G S ?e _ -> ?tc = _
    , H       : eType P G S ?e ?tc
    , H'      : eType P G S ?e ?tc' |- _ ] =>
      discriminate (Hunique tc' H') || injection (Hunique tc' H'); intros; subst; now firstorder
  end.
Qed.

Lemma expressionType_unique_lvalue_inj {P} {G} {S} {e} {qs} {ty} :
  expressionType P G S e ty ->
  (forall tc', eType P G S e tc' -> LvalueType qs ty = tc') ->
  forall ty', expressionType P G S e ty' -> ty = ty'.
Proof.
  intros ? Hunique; inversion 1;
  match goal with
  | [H : eType P G S e ?tc |- _] => set (Hunique tc H); try congruence
  end;
  repeat match goal with
  | [H : lvalueConversion _ _      |- _] => inversion_clear H
  | [H : isLvalueConvertible _     |- _] => inversion_clear H
  | [_ : pointerConvert ?t = _     |- _] => is_var t; destruct t
  | [H : isComplete (Function _ _) |- _] => inversion H
  | [H : ~ isArray (Array _ _)     |- _] => exfalso; apply H; constructor
  end; my_auto.
Qed.

Lemma expressionType_unique_expression_inj {P} {G} {S} {e} {ty} :
  (forall tc1 tc2, eType P G S e tc1 -> eType P G S e tc2 -> tc1 = tc2) ->
  expressionType P G S e ty ->
  forall ty', expressionType P G S e ty' -> ty = ty'.
Proof.
  intros Hunique H.
  inversion H; inversion 1; subst;
  match goal with
  | [ H1 : eType P G S e _ , H2 : eType P G S e _ |- _] => set (Hunique _ _ H1 H2)
  end;
  repeat match goal with
  | [H : lvalueConversion _ _ |- _] => inversion_clear H
  end;
  congruence.
Qed.

Hint Extern 1 (ExpressionType _ = ExpressionType _) =>
  apply f_equal;
    solve [ eapply expressionType_unique_lvalue_inj    ; eassumption
          | eapply expressionType_unique_expression_inj; eauto       ].

Hint Extern 1 (LvalueType _ = LvalueType _) =>
  apply f_equal;
    solve [ eapply expressionType_unique_lvalue_inj    ; eassumption
          | eapply expressionType_unique_expression_inj; eauto       ].

Lemma expressionType_aux_find_eq_lvalue {qs1} {ty1 ty2} :
  expressionType_aux_find (LvalueType qs1 ty1) = Some ty2 ->
  ty1 = ty2.
Proof. do 4 unfold_goal; destruct ty1; my_auto. Qed.

Lemma expressionType_aux_find_eq_lvalue_lift {P} {G} {S} {e} {qs1} {ty1 ty2}:
  eType P G S e (LvalueType qs1 ty1) ->
  expressionType_aux_find (LvalueType qs1 ty1) = Some ty2 ->
  expressionType P G S e ty1.
Proof.
  intros ? Heq.
  rewrite <- (expressionType_aux_find_eq_lvalue Heq) in Heq.
  revert Heq; simpl; unfold_goal; context_destruct.
  case_fun (isLvalueConvertible_fun_correct ty1).
  + intros.
    econstructor 2.
    * eassumption.
    * econstructor; [eassumption | injection Heq; trivial].
  + discriminate.
Qed.

Lemma expressionType_neg {P} {G} {S} {e} :
  (forall tc, neg (eType          P G S e tc)) ->
  forall  ty, neg (expressionType P G S e ty).
Proof. inversion 2; firstorder. Qed.

Definition isAssignable_fun ty1 ty2 is_null2 : bool :=
  match ty1, ty2 with
  | Pointer qs1 t1, Pointer qs2 t2 => orb is_null2
                                          (andb (subQualifiers qs2 qs1)
                                                (orb (isCompatible_fun t1 t2)
                                                     (orb (andb (isVoid_fun t1) (isObject_fun t2))
                                                          (andb (isVoid_fun t2) (isObject_fun t1)))))
  | Pointer qs1 t1, _              => is_null2
  | _             , Pointer _   _  => isBool_fun ty1
  | _             , _              => andb (isArithmetic_fun ty1)
                                           (isArithmetic_fun ty2)
  end.

Lemma isAssignable_fun_correct_pos {P} {G} {S} {ty1} {e2} {ty2} :
  expressionType P G S e2 ty2 ->
  isAssignable_fun ty1 ty2 (isNullPointerConstant_fun e2) = true ->
  isAssignable P G S ty1 e2.
Proof.
  unfold_goal; intros ?.
  do 2 context_destruct; bool_simpl;
  repeat (match goal with
  | [|- isArithmetic_fun ?t           = _  -> _] => set (isArithmetic_fun_correct t)
  | [|- isNullPointerConstant_fun ?e2 = _  -> _] => set (isNullPointerConstant_fun_correct e2)
  | [|- isCompatible_fun ?ty1 ?ty2    = _  -> _] => set (isCompatible_fun_correct ty1 ty2)
  | [|- isBool_fun ?t                 = _  -> _] => set (isBool_fun_correct t)
  | [|- isVoid_fun ?t                 = _  -> _] => set (isVoid_fun_correct t)
  | [|- isObject_fun ?t               = _  -> _] => set (isObject_fun_correct t)
  | [|- subQualifiers ?qs1 ?qs2       = ?o -> _] => not_var o; intros ?
  end; boolSpec_simpl);
  econstructor (solve [eassumption|constructor]).
Qed.

Lemma eType_unique_instance {P} {G} {S} {e} {tc} :
  (forall tc', eType P G S e tc' -> tc = tc') ->
  (forall tc1 tc2, eType P G S e tc1 -> eType P G S e tc2 -> tc1 = tc2).
Proof.
  intros Hunique tc1 tc2 Htc1 Htc2.
  assert (tc = tc1) by (apply Hunique; assumption).
  assert (tc = tc2) by (apply Hunique; assumption).
  congruence.
Qed.

Hint Resolve eType_unique_instance.

Ltac isAssignable_neg_tac :=
  repeat match goal with
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic Void           |- _ ] => inversion_clear H
  | [H : neg (isArithmetic (Basic ?bt)) |- _ ] => is_var bt; destruct bt
  | [H : neg (isInteger    (Basic ?bt)) |- _ ] => is_var bt; destruct bt
  | [H : neg (isArithmetic (Basic (Integer _))) |- _ ] => exfalso; apply H; do 2 constructor
  | [H : neg (isInteger    (Basic (Integer _))) |- _ ] => exfalso; apply H; constructor
  | [H : isBool       ?t             |- _ ] =>
      match t with
      | _ => is_var t; inversion H; subst; clear H
      | Basic ?bt => is_var bt; destruct bt
      end
  | [H : isVoid       ?t             |- _ ] => is_var t; inversion H; subst; clear H
  | [H : isPointer    ?t             |- _ ] => 
      match t with
      | Pointer _ _ => fail 1
      | _ => is_var t; inversion H; subst; clear H
      end
  | _ => finish fail
  end.

Lemma isAssignable_fun_correct_neg {P} {G} {S} {ty1 ty2} {e2}:
  expressionType P G S e2 ty2 ->
  (forall tc1 tc2, eType P G S e2 tc1 -> eType P G S e2 tc2 -> tc1 = tc2) ->
  isAssignable_fun ty1 ty2 (isNullPointerConstant_fun e2) = false ->
  neg (isAssignable P G S ty1 e2).
Proof.
  intros ? Hunique.
  unfold_goal; do 2 context_destruct; bool_simpl;
  repeat (match goal with
  | [|- isArithmetic_fun ?t           = _ -> _] => set (isArithmetic_fun_correct t)
  | [|- isNullPointerConstant_fun ?e2 = _ -> _] => set (isNullPointerConstant_fun_correct e2)
  | [|- isCompatible_fun ?ty1 ?ty2    = _ -> _] => set (isCompatible_fun_correct ty1 ty2)
  | [|- isBool_fun ?t                 = _ -> _] => set (isBool_fun_correct t)
  | [|- isVoid_fun ?t                 = _ -> _] => set (isVoid_fun_correct t)
  | [|- isObject_fun ?t               = _ -> _] => set (isObject_fun_correct t)
  | [|- subQualifiers ?qs1 ?qs2       = ?o -> _] => not_var o; intros ?
  end; boolSpec_simpl);
  (try now (inversion 1; my_auto));
  inversion 1; subst;
  isAssignable_neg_tac;
  match goal with
  | [ H1 : expressionType P G S e2 _
    , H2 : expressionType P G S e2 _ |- _] =>
      generalize (expressionType_unique_expression_inj Hunique H1 _ H2);
      discriminate || (try injection; intros; subst; finish ltac:(now isAssignable_neg_tac))
  end.
Qed.

Definition isBinaryArithmetic_fun ty1 aop ty2 : bool :=
  match aop with
  | Mul  => andb (isArithmetic_fun ty1) (isArithmetic_fun ty2)
  | Div  => andb (isArithmetic_fun ty1) (isArithmetic_fun ty2)
  | Mod  => andb (isInteger_fun    ty1) (isInteger_fun    ty2)
  | Add  => andb (isArithmetic_fun ty1) (isArithmetic_fun ty2)
  | Sub  => andb (isArithmetic_fun ty1) (isArithmetic_fun ty2)
  | Shl  => andb (isInteger_fun    ty1) (isInteger_fun    ty2)
  | Shr  => andb (isInteger_fun    ty1) (isInteger_fun    ty2)
  | Band => andb (isInteger_fun    ty1) (isInteger_fun    ty2)
  | Xor  => andb (isInteger_fun    ty1) (isInteger_fun    ty2)
  | Bor  => andb (isInteger_fun    ty1) (isInteger_fun    ty2)
  end.

Lemma isBinaryArithmetic_fun_correct ty1 aop ty2 : boolSpec (isBinaryArithmetic_fun ty1 aop ty2)
                                                            (isBinaryArithmetic     ty1 aop ty2).
Proof.
  do 3 unfold_goal.
  repeat match goal with
  | [|- isArithmetic_fun ?t = ?o -> _] => is_var o; case_fun (isArithmetic_fun_correct t)
  | [|- isInteger_fun    ?t = ?o -> _] => is_var o; case_fun (isInteger_fun_correct    t)
  | _ => context_destruct
  end;
  solve [ constructor; assumption
        | inversion 1; isAssignable_neg_tac].
Qed.

Definition isPointerToCompleteObject_fun ty : bool :=
  match ty with
  | Pointer _ t => isComplete_fun t
  | _           => false
  end.

Lemma isPointerToCompleteObject_fun_correct t :
  if isPointerToCompleteObject_fun t
    then {qs : qualifiers & {ty : type & (t = Pointer qs ty) * isComplete ty}}
    else neg (isPointer t) + forall qs ty, t = Pointer qs ty -> neg (isComplete ty).
Proof.
  unfold_goal;
  repeat match goal with
  | [|- isComplete_fun ?t = _ -> _] => case_fun (isComplete_fun_correct t)
  | [|- _ * _] => split
  | [|- {_ : _ & _}] => eexists; eexists; split; [reflexivity | assumption]
  | [|- neg (isPointer ?t) + _] =>
      match t with
      | Pointer _ _ => right
      | _           => left; inversion 1
      end
  | _ => context_destruct
  end; congruence.
Qed.

Definition arePointersToCompatibleCompleteObjects_fun t1 t2 : bool :=
  match t1, t2 with
  | Pointer _ ty1, Pointer _ ty2 =>
      andb (andb (isComplete_fun ty1)
                 (isComplete_fun ty2))
           (isCompatible_fun ty1 ty2)
  | _, _ => false
  end.  

Lemma arePointersToCompatibleCompleteObjects_fun_correct t1 t2 :
  if arePointersToCompatibleCompleteObjects_fun t1 t2
    then {qs1 : qualifiers & {ty1 : type &
         {qs2 : qualifiers & {ty2 : type &
           (t1 = Pointer qs1 ty1) * (t2 = Pointer qs2 ty2) *
           isComplete ty1         * isComplete ty2         *
           isCompatible ty1 ty2}}}}
    else neg (isPointer t1) + neg (isPointer t2)
         + (forall qs1 ty1, t1 = Pointer qs1 ty1 -> neg (isComplete ty1))
         + (forall qs2 ty2, t2 = Pointer qs2 ty2 -> neg (isComplete ty2))
         + (forall qs1 qs2 ty1 ty2,
              t1 = Pointer qs1 ty1 ->
              t2 = Pointer qs2 ty2 -> neg (isCompatible ty1 ty2)).
Proof.
  do 2 unfold_goal;
  repeat match goal with
  | [|- isComplete_fun ?t = _ -> _] => case_fun (isComplete_fun_correct t)
  | [|- isCompatible_fun ?t1 ?t2 = _ -> _] => case_fun (isCompatible_fun_correct t1 t2)
  | [|- _ * _] => split
  | [|- {_ : _ & _}] => eexists; eexists; eexists; eexists;
                        split; [split; [split; [split; reflexivity
                                               | eassumption]
                                       | eassumption]
                               | eassumption]
  | [|- neg (isPointer ?t) + _ + _ + _ + _] =>
      match t with
      | Pointer _ _ => fail 1
      | _           => left; left; left; left; inversion 1
      end
  | [|- _ + neg (isPointer ?t) + _ + _ + _] =>
      match t with
      | Pointer _ _ => fail 1
      | _           => left; left; left; right; inversion 1
      end
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [_ : neg (isComplete t1)      |- _ + _ + _ + _ + _ ] => left; left; right; intros; congruence
  | [_ : neg (isComplete t2)      |- _ + _ + _ + _ + _ ] => left; right; intros; congruence
  | [_ : neg (isCompatible t1 t2) |- _ + _ + _ + _ + _ ] => right; intros; congruence
  | _ => context_destruct
  end.
Qed.

Definition arePointersToCompatibleObjects_fun t1 t2 : bool :=
  match t1, t2 with
  | Pointer _ ty1, Pointer _ ty2 =>
      andb (andb (isObject_fun ty1) (isObject_fun ty2))
           (isCompatible_fun ty1 ty2)
  | _, _ => false
  end.  

Lemma arePointersToCompatibleObjects_fun_correct t1 t2 :
  if arePointersToCompatibleObjects_fun t1 t2
    then {qs1 : qualifiers & {ty1 : type &
         {qs2 : qualifiers & {ty2 : type &
           (t1 = Pointer qs1 ty1) * (t2 = Pointer qs2 ty2) *
           isObject ty1           * isObject ty2           *
           isCompatible ty1 ty2}}}}
    else neg (isPointer t1) + neg (isPointer t2)
         + (forall qs1 ty1, t1 = Pointer qs1 ty1 -> neg (isObject ty1))
         + (forall qs2 ty2, t2 = Pointer qs2 ty2 -> neg (isObject ty2))
         + (forall qs1 qs2 ty1 ty2,
              t1 = Pointer qs1 ty1 ->
              t2 = Pointer qs2 ty2 -> neg (isCompatible ty1 ty2)).
Proof.
  do 2 unfold_goal;
  repeat match goal with
  | [|- isObject_fun ?t = _ -> _] => case_fun (isObject_fun_correct t)
  | [|- isCompatible_fun ?t1 ?t2 = _ -> _] => case_fun (isCompatible_fun_correct t1 t2)
  | [|- _ * _] => split
  | [|- {_ : _ & _}] => eexists; eexists; eexists; eexists;
                        split; [split; [split; [split; reflexivity
                                               | eassumption]
                                       | eassumption]
                               | eassumption]
  | [|- neg (isPointer ?t) + _ + _ + _ + _] =>
      match t with
      | Pointer _ _ => fail 1
      | _           => left; left; left; left; inversion 1
      end
  | [|- _ + neg (isPointer ?t) + _ + _ + _] =>
      match t with
      | Pointer _ _ => fail 1
      | _           => left; left; left; right; inversion 1
      end
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [_ : neg (isObject t1)      |- _ + _ + _ + _ + _ ] => left; left; right; intros; congruence
  | [_ : neg (isObject t2)      |- _ + _ + _ + _ + _ ] => left; right; intros; congruence
  | [_ : neg (isCompatible t1 t2) |- _ + _ + _ + _ + _ ] => right; intros; congruence
  | _ => context_destruct
  end.
Qed.

Definition isPointerToObject_fun t : bool :=
  match t with
  | Pointer _ ty => isObject_fun ty
  | _ => false
  end.

Lemma isPointerToObject_fun_correct t :
  if isPointerToObject_fun t
    then {qs : qualifiers & {ty : type & (t = Pointer qs ty) * isObject ty}}
    else neg (isPointer t) + forall qs ty, t = Pointer qs ty -> neg (isObject ty).
Proof.
  unfold_goal;
  repeat match goal with
  | [|- isObject_fun ?t = _ -> _] => case_fun (isObject_fun_correct t)
  | [|- _ * _] => split
  | [|- {_ : _ & _}] => eexists; eexists; split; [reflexivity | assumption]
  | [|- neg (isPointer ?t) + _] =>
      match t with
      | Pointer _ _ => right
      | _           => left; inversion 1
      end
  | _ => context_destruct
  end; congruence.
Qed.

Definition isPointerToVoid_fun t : bool :=
  match t with
  | Pointer _ Void => true
  | _ => false
  end.

Lemma isPointerToVoid_fun_correct t :
  if isPointerToVoid_fun t
    then {qs : qualifiers & {ty : type & (t = Pointer qs ty) * isVoid ty}}
    else neg (isPointer t) + forall qs ty, t = Pointer qs ty -> neg (isVoid ty).
Proof.
  unfold_goal;
  repeat match goal with
  | [|- isVoid_fun ?t = _ -> _] => case_fun (isVoid_fun_correct t)
  | [|- neg _] => intros [? [? [? ?]]]
  | [|- _ * _] => split
  | [|- {_ : _ & _}] => eexists; eexists; split; [reflexivity | constructor]
  | [|- neg (isPointer ?t) + _] =>
      match t with
      | Pointer _ _ => right; intros; inversion 1
      | _           => left; inversion 1
      end
  | _ => context_destruct
  end; congruence.
Qed.

Definition arePointersToCompatibleTypes_fun t1 t2 : bool :=
  match t1, t2 with
  | Pointer _ ty1, Pointer _ ty2 => isCompatible_fun ty1 ty2
  | _, _ => false
  end.  

Lemma arePointersToCompatibleTypes_fun_correct t1 t2 :
  if arePointersToCompatibleTypes_fun t1 t2
    then {qs1 : qualifiers & {ty1 : type &
         {qs2 : qualifiers & {ty2 : type &
           (t1 = Pointer qs1 ty1) * (t2 = Pointer qs2 ty2) *
           isCompatible ty1 ty2}}}}
    else neg (isPointer t1) + neg (isPointer t2)
         + (forall qs1 qs2 ty1 ty2,
              t1 = Pointer qs1 ty1 ->
              t2 = Pointer qs2 ty2 -> neg (isCompatible ty1 ty2)).
Proof.
  unfold_goal;
  repeat match goal with
  | [|- isCompatible_fun ?t1 ?t2 = _ -> _] => case_fun (isCompatible_fun_correct t1 t2)
  | [|- _ * _] => split
  | [|- {_ : _ & _}] => eexists; eexists; eexists; eexists;
                        split; [split; reflexivity
                               | eassumption]
  | [|- neg (isPointer ?t) + _ + _ ] =>
      match t with
      | Pointer _ _ => fail 1
      | _           => left; left; inversion 1
      end
  | [|- _ + neg (isPointer ?t) + _ ] =>
      match t with
      | Pointer _ _ => fail 1
      | _           => left; right; inversion 1
      end
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [_ : neg (isCompatible t1 t2) |- _ + _ + _ ] => right; intros; congruence
  | _ => context_destruct
  end.
Qed.

Definition isEquality_fun ty1 ty2 is_null1 is_null2 : bool :=
     andb (isPointer_fun ty1) is_null2
  || andb (isPointer_fun ty2) is_null1
  || andb (isPointerToVoid_fun ty1) (isPointerToObject_fun ty2)
  || andb (isPointerToVoid_fun ty2) (isPointerToObject_fun ty1)
  || arePointersToCompatibleTypes_fun ty1 ty2
  || andb (isArithmetic_fun ty1) (isArithmetic_fun ty2).

Lemma isEquality_fun_correct_pos {aop} {P} {G} {S} {e1 e2} {ty1 ty2} :
  (aop = Eq) + (aop = Ne) ->
  expressionType P G S e1 ty1 ->
  expressionType P G S e2 ty2 ->
  isEquality_fun ty1 ty2 (isNullPointerConstant_fun e1) (isNullPointerConstant_fun e2) = true ->
  eType P G S (Binary e1 aop e2) (ExpressionType (Basic (Integer (Signed Int)))).
Proof.
  intros Haop ? ?.
  pull_out bool (isEquality_fun ty1 ty2 (isNullPointerConstant_fun e1) (isNullPointerConstant_fun e2)).
  unfold_goal.
  repeat match goal with
  | [H : isArithmetic Void           |- _ ] => inversion_clear H
  | [H : isArithmetic (Array _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion_clear H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [|- true = true -> _] => intros _
  | [|- false = false -> _] => intros _
  | [|- false = true -> _] => congruence
  | [|- true = false -> _] => congruence
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (true || _) = _ -> _] => unfold orb at 1
  | [|- (false || _) = _ -> _] => rewrite orb_false_l
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- (?e || _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- isArithmetic_fun ?t           = ?o -> _] => is_var o; case_fun (isArithmetic_fun_correct t)
  | [|- isPointer_fun ?t           = ?o -> _] => is_var o; case_fun (isPointer_fun_correct t)
  | [|- isNullPointerConstant_fun ?e = ?o -> _] => is_var o; case_fun (isNullPointerConstant_fun_correct e)
  | [|- isPointerToCompleteObject_fun ?t           = ?o -> _] =>
      is_var o; case_fun (isPointerToCompleteObject_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? ?]]]; subst
      | _ => idtac
      end
  | [|- isPointerToVoid_fun ?t           = ?o -> _] =>
      is_var o; case_fun (isPointerToVoid_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => let Hvoid := fresh in destruct H as [? [? [? Hvoid]]]; inversion Hvoid; subst
      | _ => idtac
      end
  | [|- isPointerToObject_fun ?t           = ?o -> _] =>
      is_var o; case_fun (isPointerToObject_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? ?]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleCompleteObjects_fun ?t1 ?t2           = ?o -> _] =>
      is_var o; case_fun (arePointersToCompatibleCompleteObjects_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[[[? ?] ?] ?] ?]]]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleObjects_fun ?t1 ?t2           = ?o -> _] =>
      is_var o; case_fun (arePointersToCompatibleObjects_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[[[? ?] ?] ?] ?]]]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleTypes_fun ?t1 ?t2           = ?o -> _] =>
      is_var o; case_fun (arePointersToCompatibleTypes_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[? ?] ?] ]]]]; subst
      | _ => idtac
      end
  | [|- isCompatible_fun ?t1 ?t2           = ?o -> _] => is_var o; case_fun (isCompatible_fun_correct t1 t2)
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [H : isPointer ?t |- _] => is_var t; inversion H; subst
  | [Heq : Pointer _ Void = Pointer _ ?t |- _ ] => is_var t; injection Heq; intros; subst
  | _ => context_destruct
  end; try (destruct Haop; subst; econstructor (solve [eassumption|reflexivity])).
Qed.

Lemma isEquality_fun_correct_neg {aop} {P} {G} {S} {e1 e2} {ty1 ty2} :
  (aop = Eq) + (aop = Ne) ->
  expressionType P G S e1 ty1 ->
  expressionType P G S e2 ty2 ->
  (forall tc1 tc2, eType P G S e1 tc1 -> eType P G S e1 tc2 -> tc1 = tc2) ->
  (forall tc1 tc2, eType P G S e2 tc1 -> eType P G S e2 tc2 -> tc1 = tc2) ->
  isEquality_fun ty1 ty2 (isNullPointerConstant_fun e1) (isNullPointerConstant_fun e2) = false ->
  forall tc, neg (eType P G S (Binary e1 aop e2) tc).
Proof.
  intros Haop Hexp1 Hexp2 Hunique1 Hunique2.
  pull_out bool (isEquality_fun ty1 ty2 (isNullPointerConstant_fun e1) (isNullPointerConstant_fun e2)).
  inversion Hexp1; inversion Hexp2;
  match goal with
  | [H : lvalueConversion _ _ |- _] => inversion H
  | _ => idtac
  end; subst;
  unfold_goal;
  abstract (
  repeat match goal with
  | [H : isArithmetic Void           |- _ ] => inversion_clear H
  | [H : isArithmetic (Array _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion_clear H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : neg (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [|- true = true -> _] => intros _
  | [|- false = false -> _] => intros _
  | [|- false = true -> _] => congruence
  | [|- true = false -> _] => congruence
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (true || _) = _ -> _] => unfold orb at 1
  | [|- (false || _) = _ -> _] => rewrite orb_false_l
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- (?e || _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- isArithmetic_fun ?t           = ?o -> _] => is_var o; case_fun (isArithmetic_fun_correct t)
  | [|- isPointer_fun ?t           = ?o -> _] => is_var o; case_fun (isPointer_fun_correct t)
  | [|- isNullPointerConstant_fun ?e = ?o -> _] => is_var o; case_fun (isNullPointerConstant_fun_correct e)
  | [|- isPointerToCompleteObject_fun ?t           = ?o -> _] =>
      is_var o; case_fun (isPointerToCompleteObject_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? ?]]]; subst
      | _ => idtac
      end
  | [|- isPointerToVoid_fun ?t           = ?o -> _] =>
      is_var o; case_fun (isPointerToVoid_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => let Hvoid := fresh in destruct H as [? [? [? Hvoid]]]; inversion Hvoid; subst
      | _ => idtac
      end
  | [|- isPointerToObject_fun ?t           = ?o -> _] =>
      is_var o; case_fun (isPointerToObject_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? ?]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleCompleteObjects_fun ?t1 ?t2           = ?o -> _] =>
      is_var o; case_fun (arePointersToCompatibleCompleteObjects_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[[[? ?] ?] ?] ?]]]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleObjects_fun ?t1 ?t2           = ?o -> _] =>
      is_var o; case_fun (arePointersToCompatibleObjects_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[[[? ?] ?] ?] ?]]]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleTypes_fun ?t1 ?t2           = ?o -> _] =>
      is_var o; case_fun (arePointersToCompatibleTypes_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[? ?] ?] ]]]]; subst
      | _ => idtac
      end
  | [|- isCompatible_fun ?t1 ?t2           = ?o -> _] => is_var o; case_fun (isCompatible_fun_correct t1 t2)
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [H : isPointer ?t |- _] => is_var t; inversion H; subst
  | _ => context_destruct
  | [Heq : pointerConvert ?t = Pointer _ _, H : context [pointerConvert ?t] |- _ ] => rewrite    Heq in *
  | [Heq : Pointer _ _ = pointerConvert ?t, H : context [pointerConvert ?t] |- _ ] => rewrite <- Heq in *
  | [Heq : Pointer _ Void = Pointer _ ?t |- _] => is_var t; injection Heq; intros; subst
  | [|- forall _, neg _] => destruct Haop; subst; inversion 1; subst
  | [ H : isComplete ?ty1 , Hfalse : forall _ _, Pointer ?qs1 ?ty1 = Pointer _ _ -> neg (isComplete _) |- False ] => now eapply (Hfalse qs1 ty1 eq_refl H)
  | [ H : isObject   ?ty1 , Hfalse : forall _ _, Pointer ?qs1 ?ty1 = Pointer _ _ -> neg (isObject   _) |- False ] => now eapply (Hfalse qs1 ty1 eq_refl H)
  | [                       Hfalse : forall _ _, Pointer ?qs1 Void = Pointer _ _ -> neg (isVoid _)     |- False ] => now eapply (Hfalse qs1 Void eq_refl IsVoid)
  | [ Hfalse : forall _ _ _ _, Pointer ?qs1 ?ty1 = _ ->
                               Pointer ?qs2 ?ty2 = _ ->
                               neg (isCompatible _ _)
    , H : isCompatible ?ty1 ?ty2 |- False] => now eapply (Hfalse qs1 qs2 ty1 ty2 eq_refl eq_refl H)
  | [ Hunique : forall _ _, eType P G S ?e _ -> eType   P G S ?e _ -> _ =  _
    , H1 : expressionType P G S ?e ?t1
    , H2 : expressionType P G S ?e ?t2         |- _ ] =>
      notSame t1 t2;
      let Heq := fresh in
      assert (t1 = t2) as Heq by (eapply (expressionType_unique_expression_inj Hunique); eauto);
      try (congruence || (try injection Heq; intros); subst)
  | [H : _ + _ |- _] => destruct H
  end).
Qed.

Definition combineQualifiers_left t1 t2 : type :=
    match t1, t2 with
    | Pointer qs1 ty1, Pointer qs2 _ => Pointer (combineQualifiers qs1 qs2) ty1
    | Pointer _   _  , _             => t1
    | _              , _             => t1
    end.

Definition combineQualifiers_right t1 t2 : type :=
    match t1, t2 with
    | Pointer qs1 _, Pointer qs2 ty2 => Pointer (combineQualifiers qs1 qs2) ty2
    | _            , Pointer _   _   => t2
    | _              , _             => t2
    end.

Lemma combineQualifiers_left_not_pointer {t1 t2} :
  neg (isPointer t2) -> combineQualifiers_left t1 t2 = t1.
Proof.
  intros Hnpointer;
  destruct t1; destruct t2;
  solve [ reflexivity
        | exfalso; apply Hnpointer; constructor].
Qed.

Lemma combineQualifiers_right_not_pointer {t1 t2} :
  neg (isPointer t1) -> combineQualifiers_right t1 t2 = t2.
Proof.
  intros Hnpointer;
  destruct t1; destruct t2;
  solve [ reflexivity
        | exfalso; apply Hnpointer; constructor].
Qed.

Definition compositePointer_find t1 t2 : option type :=
  match t1, t2 with
  | Pointer qs1 ty1, Pointer qs2 ty2 => if isCompatible_fun ty1 ty2
                                          then option_map (Pointer (combineQualifiers qs1 qs2)) (isComposite_find ty1 ty2)
                                          else None
  | _              , _               => None
  end.

Fixpoint isCompatible_isComposite {t1} {t2} :
  isCompatible t1 t2 ->
  neg (isComposite_find t1 t2 = None)
with isCompatible_params_isComposite_params  {p1} {p2} :
  isCompatible_params p1 p2 ->
  neg (isComposite_params_find p1 p2 = None).
Proof.
- intros Hcompat.
  unfold_goal.
  destruct t1, t2; simpl;
  unfold option_map;
  inversion Hcompat; subst;
  repeat match goal with
  | [|- bool_of_decision ?e = ?o -> _] => is_var o; destruct e; subst; intros ?; subst o; simpl
  | [|- isComposite_find ?t1 ?t2 = ?o -> _] => is_var o; destruct o; intros ?
  | [|- isComposite_params_find ?p1 ?p2 = ?o -> _] => is_var o; destruct o; intros ?
  | _ => context_destruct
  | [Hfind : isComposite_find ?t1 ?t2 = None , H : isCompatible ?t1 ?t2 |- _] => destruct (isCompatible_isComposite _ _ H Hfind)
  | [Hfind : isComposite_params_find ?p1 ?p2 = None , H : isCompatible_params ?p1 ?p2 |- _] => destruct (isCompatible_params_isComposite_params _ _ H Hfind)
  end; try solve [inversion 1|congruence].
- intros Hcompat.
  unfold_goal.
  destruct p1, p2; simpl;
  unfold option_map;
  inversion Hcompat; subst;
  repeat match goal with
  | [|- isComposite_find ?t1 ?t2 = ?o -> _] => is_var o; destruct o; intros ?
  | [|- isComposite_params_find ?p1 ?p2 = ?o -> _] => is_var o; destruct o; intros ?
  | _ => context_destruct
  | [Hfind : isComposite_find ?t1 ?t2 = None , H : isCompatible ?t1 ?t2 |- _] => destruct (isCompatible_isComposite _ _ H Hfind)
  | [Hfind : isComposite_params_find ?p1 ?p2 = None , H : isCompatible_params ?p1 ?p2 |- _] => destruct (isCompatible_params_isComposite_params _ _ H Hfind)
  end; solve [inversion 1|congruence].
Qed.

Lemma compositePointer_find_correct t1 t2 :
  match compositePointer_find t1 t2 with
  | Some t =>
      {qs1 : qualifiers & {ty1 : type &
      {qs2 : qualifiers & {ty2 : type & {
        ty : type &
            (t1 = Pointer  qs1         ty1)
          * (t2 = Pointer         qs2  ty2)
          * (t  = Pointer (combineQualifiers qs1 qs2) ty)
          * isCompatible ty1 ty2
          * isComposite  ty1 ty2 ty
      }}}}}
  | None   => neg (isPointer t1) +
              neg (isPointer t2) +
              {qs1 : qualifiers & {ty1 : type &
              {qs2 : qualifiers & {ty2 : type &
                  (t1 = Pointer  qs1         ty1)
                * (t2 = Pointer         qs2  ty2)
                * neg (isCompatible ty1 ty2)
              }}}}
  end.
Proof.
  unfold_goal;
  unfold option_map;
  repeat match goal with
  | [|- isComposite_find ?t1 ?t2 = _ -> _] => case_fun (isComposite_find_correct t1 t2); unfold optionSpec in *
  | [|- isCompatible_fun ?t1 ?t2 = _ -> _] => case_fun (isCompatible_fun_correct t1 t2); unfold boolSpec   in *
  | [|- neg _ + _ + _] => solve [left; left ; inversion 1
                                |left; right; inversion 1
                                |repeat first [right | eexists | assumption]]
  | _ => context_destruct
  | [|- {_ : _ & _}] => repeat first [eexists | split | reflexivity | assumption]
  | [H : isCompatible ?t1 ?t2, Hfind : isComposite_find t1 t2 = None |- _] => destruct (isCompatible_isComposite H Hfind)
  end.
Qed.

Definition isConditional_fun P ty1 ty2 ty3 is_null2 is_null3 : option typeCategory :=
  if isScalar_fun ty1 then
    if andb (isArithmetic_fun ty2) (isArithmetic_fun ty3) then
      option_map ExpressionType (isUsualArithmetic_find P ty2 ty3)
    else
      match compositePointer_find ty2 ty3 with
      | Some ty => Some (ExpressionType ty)
      | None    => if andb (isVoid_fun ty2) (isVoid_fun ty3) then
                     Some (ExpressionType Void)
                   else if andb (isPointer_fun ty2) is_null3 then
                     Some (ExpressionType (combineQualifiers_left ty2 ty3))
                   else if andb (isPointer_fun ty3) is_null2 then
                     Some (ExpressionType (combineQualifiers_right ty2 ty3))
                   else if andb (isPointerToObject_fun ty2) (isPointerToVoid_fun ty3) then
                     Some (ExpressionType (combineQualifiers_right ty2 ty3))
                   else if andb (isPointerToObject_fun ty3) (isPointerToVoid_fun ty2) then
                     Some (ExpressionType (combineQualifiers_left ty2 ty3))
                   else None
      end
  else
    None.

Lemma isConditional_fun_correct_pos {P G S} {ty1 ty2 ty3} {e1 e2 e3} {tc} :
  expressionType P G S e1 ty1 ->
  expressionType P G S e2 ty2 ->
  expressionType P G S e3 ty3 ->
  isConditional_fun P ty1 ty2 ty3 (isNullPointerConstant_fun e2) (isNullPointerConstant_fun e3)= Some tc ->
  eType P G S (Conditional e1 e2 e3) tc.
Proof.
  intros ? ? ?.
  unfold_goal.
  destruct ty1, ty2, ty3;
  unfold andb;
  unfold option_map;
  unfold combineQualifiers_left;
  unfold combineQualifiers_right;
  repeat match goal with
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [H : isPointer ?t |- _] => is_var t; inversion H; subst
  | [H : isVoid ?t |- _] => is_var t; inversion H; subst
  | [H : isPointer (Basic _) |- _] => inversion H
  | [H : isPointer (Array _ _) |- _] => inversion H
  | [H : isPointer (Function _ _) |- _] => inversion H
  | [H : isPointer Void |- _] => inversion H
  | [H : neg (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [H : neg (isVoid Void) |- _ ] => exfalso; apply H; now constructor
  | [H : isVoid (Basic _) |- _] => inversion H
  | [H : isVoid (Array _ _) |- _] => inversion H
  | [H : isVoid (Function _ _) |- _] => inversion H
  | [H : isVoid (Pointer _ _) |- _] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isArithmetic Void           |- _ ] => inversion H
  | [H : isArithmetic (Array _ _) |- _ ] => inversion H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion H
  | [H : isScalar Void           |- _ ] => inversion H
  | [H : isScalar (Array _ _) |- _ ] => inversion H
  | [H : isScalar (Function _ _) |- _ ] => inversion H
  | [|- isScalar_fun ?t = _ -> _] => case_fun (isScalar_fun_correct t)
  | [|- isArithmetic_fun ?t = _ -> _] => case_fun (isArithmetic_fun_correct t)
  | [|- isUsualArithmetic_find P ?t1 ?t2 = _ -> _] => case_fun (isUsualArithmetic_find_correct P t1 t2)
  | [|- isVoid_fun ?t = _ -> _] => case_fun (isVoid_fun_correct t)
  | [|- isPointer_fun ?t = _ -> _] => case_fun (isPointer_fun_correct t)
  | [|- isNullPointerConstant_fun ?e = _ -> _] => case_fun (isNullPointerConstant_fun_correct e)
  | [|- isPointerToObject_fun ?t = _ -> _] =>
      case_fun (isPointerToObject_fun_correct t); [
      match goal with
      | [H : {_ : _ &  _} |- _ ] => let Heq := fresh in
                                    destruct H as [? [? [Heq ?]]];
                                    try discriminate Heq;
                                    inversion Heq; subst
      end|]
  | [|- isPointerToVoid_fun ?t = _ -> _] =>
      case_fun (isPointerToVoid_fun_correct t); [
      match goal with
      | [H : {_ : _ &  _} |- _ ] => let Heq := fresh in
                                    destruct H as [? [? [Heq ?]]];
                                    try discriminate Heq;
                                    inversion Heq; subst
      end|]
  | [|- compositePointer_find ?t1 ?t2 = _ -> _] =>
      case_fun (compositePointer_find_correct t1 t2); [
      match goal with
      | [H : {_ : _ & _} |- _] =>   let Heq1 := fresh in
                                    let Heq2 := fresh in
                                    destruct H as [? [? [? [? [? [[[[Heq1 Heq2] ?] ?] ?]]]]]];
                                    (try discriminate Heq1);
                                    (try discriminate Heq2);
                                    inversion Heq1;
                                    inversion Heq2; subst
      end|]
  | _ => context_destruct
  | [|- None = Some _ -> _] => now inversion 1
  | [|- Some _ = Some _ -> _] => let Heq := fresh in intros Heq; injection Heq; intros; subst
  | [H : neg _ + neg _ + {_ : _ & {_ : _ & {_ : _ & {_ : _ & (_ = _) * (_ = _) * neg _}}}} |- eType P G S _ _] =>
      destruct H as [[H | H] | H];
      [ exfalso; apply H; constructor
      | exfalso; apply H; constructor
      | let Heq1 := fresh in
        let Heq2 := fresh in
        destruct H as [? [? [? [? [[Heq1 Heq2] ?]]]]];
        inversion Heq1; inversion Heq2; subst; try congruence]
  | [|- eType P G S _ _] =>  econstructor (solve [eassumption | finish fail | econstructor (eassumption)])
  end; congruence.
Qed.

Lemma isUsualArithmetic_unique {P} {ty1 ty2} {t t'} :
  isUsualArithmetic P ty1 ty2 t  ->
  isUsualArithmetic P ty1 ty2 t' ->
  t = t'.
Proof.
  intros H1 H2.
  set (isUsualArithmetic_find_unique H1).
  set (isUsualArithmetic_find_unique H2).
  congruence.
Qed.

Lemma isComposite_unique {ty1 ty2} {t t'} :
  isComposite ty1 ty2 t  ->
  isComposite ty1 ty2 t' ->
  t = t'.
Proof.
  intros H1 H2.
  set (isComposite_find_unique _ _ _ H1).
  set (isComposite_find_unique _ _ _ H2).
  congruence.
Qed.

Fixpoint isNullPointerConstant_eType P G S e {struct e} :
  isNullPointerConstant e ->
    eType P G S e (ExpressionType (Basic (Integer (Signed Int))))
  + eType P G S e (ExpressionType (Pointer unqualified Void))
  + forall tc, neg (eType P G S e tc).
Proof.
  destruct e; inversion 1; subst.
  - repeat match goal with
    | [H : isUnqualified ?qs |- _] => is_var qs; inversion H; subst
    end.
    match goal with
    | [H : isNullPointerConstant e |- _] => destruct (isNullPointerConstant_eType P G S e H)  as [[? | ?] |?]
    end.
    + left; right; econstructor (econstructor (solve [ eassumption
                                                     | reflexivity
                                                     | econstructor (constructor; constructor)
                                                     | econstructor (now repeat first [inversion 1 | constructor])])).
    + left; right; econstructor (econstructor (solve [ eassumption
                                                     | reflexivity
                                                     | econstructor (constructor; constructor)
                                                     | econstructor (now repeat first [inversion 1 | constructor])])).
    + right; inversion 1; subst.
      repeat match goal with
      | [Hfalse : forall _, neg (eType P G S e _), H : eType P G S e _ |- _] => exact (Hfalse _ H)
      | [H : expressionType P G S _ _ |- _] => inversion_clear H
      end.
  - left; left;
    repeat constructor.
    + unfold integerTypeRange.
      destruct (binMode P); simpl;
      rewrite max_mkRange;
      eapply integerTypeRange_signed_upper;
      eapply precision_ge_one.
    + unfold integerTypeRange.
      destruct (binMode P); simpl;
      rewrite min_mkRange; solve [eapply integerTypeRange_signed_lower1; eapply precision_ge_one
                                 |eapply integerTypeRange_signed_lower2; eapply precision_ge_one].
Qed.

Fixpoint isNullPointerConstant_expressionType P G S e {struct e} :
  isNullPointerConstant e ->
    expressionType P G S e (Basic (Integer (Signed Int)))
  + expressionType P G S e (Pointer unqualified Void)
  + forall ty, neg (expressionType P G S e ty).
Proof.
  intros Hnull.
  destruct (isNullPointerConstant_eType P G S e Hnull) as [[? | ?] | ?].
  + left; left ; econstructor (solve [eassumption | reflexivity]).
  + left; right; econstructor (solve [eassumption | reflexivity]).
  + right; inversion 1; firstorder.
Qed.  

Lemma combineQualifiers_unqualified_left {qs} :
  combineQualifiers unqualified qs = qs.
Proof.
  unfold unqualified.
  unfold combineQualifiers.
  destruct qs.
  reflexivity.
Qed.

Lemma combineQualifiers_unqualified_right {qs} :
  combineQualifiers qs unqualified = qs.
Proof.
  unfold unqualified.
  unfold combineQualifiers.
  destruct qs.
  rewrite_all orb_false_r.
  reflexivity.
Qed.

Lemma conditional_uniqueness {P G S} {e1 e2 e3} :
  (forall ty1 ty1', expressionType P G S e1 ty1 -> expressionType P G S e1 ty1' -> ty1 = ty1') ->
  (forall ty2 ty2', expressionType P G S e2 ty2 -> expressionType P G S e2 ty2' -> ty2 = ty2') ->
  (forall ty3 ty3', expressionType P G S e3 ty3 -> expressionType P G S e3 ty3' -> ty3 = ty3') ->
  forall tc tc', eType P G S (Conditional e1 e2 e3) tc  ->
                 eType P G S (Conditional e1 e2 e3) tc' ->
                 tc = tc'.
Proof.
  intros Hunique1 Hunique2 Hunique3.
  inversion 1; inversion 1; subst;
  repeat match goal with
  | [H : isPointer ?t |- _] => is_var t; inversion H; subst
  | [H : isVoid ?t |- _] => is_var t; inversion H; subst
  | [H : isPointer (Basic _) |- _] => inversion H
  | [H : isPointer (Array _ _) |- _] => inversion H
  | [H : isPointer (Function _ _) |- _] => inversion H
  | [H : isPointer Void |- _] => inversion H
  | [H : neg (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [H : ~ (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [H : neg (isVoid Void) |- _ ] => exfalso; apply H; now constructor
  | [H : isVoid (Basic _) |- _] => inversion H
  | [H : isVoid (Array _ _) |- _] => inversion H
  | [H : isVoid (Function _ _) |- _] => inversion H
  | [H : isVoid (Pointer _ _) |- _] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isArithmetic Void           |- _ ] => inversion H
  | [H : isArithmetic (Array _ _) |- _ ] => inversion H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion H
  | [H : isScalar Void           |- _ ] => inversion H
  | [H : isScalar (Array _ _) |- _ ] => inversion H
  | [H : isScalar (Function _ _) |- _ ] => inversion H
  | [ Hunique : forall _ _, expressionType P G S ?e _ -> expressionType P G S ?e _ -> _ = _
    , H1 : expressionType P G S ?e ?t1, H2 : expressionType P G S ?e ?t2 |- _] =>
      notSame t1 t2;
      let Heq := fresh in set (Hunique _ _ H1 H2) as Heq; inversion Heq; clear Heq; subst
  | [ H1 : isUsualArithmetic P ?ty1 ?ty2 ?t, H2 : isUsualArithmetic P ?ty1 ?ty2 ?t' |- _] =>
      notSame t t'; set (isUsualArithmetic_unique H1 H2)
  | [ H1 : isComposite ?ty1 ?ty2 ?t, H2 : isComposite ?ty1 ?ty2 ?t' |- _] =>
      notSame t t'; set (isComposite_unique H1 H2)
  | [ Hunique : forall _ _, expressionType P G S ?e _ -> expressionType P G S ?e _ -> _ = _
    , Hnull : isNullPointerConstant ?e
    , H : expressionType P G S ?e (Pointer _ ?ty) |- _] =>
      notSame ty Void;
      let H' := fresh in
      destruct (isNullPointerConstant_expressionType P G S e Hnull) as [[H' | H']| H'];
      [ discriminate (Hunique _ _ H H')
      | let Heq := fresh in set (Hunique _ _ H H') as Heq; inversion Heq; clear Heq; subst
      | destruct (H' _ H)]
  | [H : isCompatible Void ?t |- _] => is_var t; inversion H; subst
  | [H : isCompatible ?t Void |- _] => is_var t; inversion H; subst
  | [H : isComposite Void Void ?t |- _] => is_var t; inversion H; subst
  end; congruence.
Qed.

Lemma conditional_inj_neg1 {P} {G} {S} {e1 e2 e3} : 
  (forall ty, neg (expressionType P G S e1 ty)) ->
  forall tc, neg (eType P G S (Conditional e1 e2 e3) tc).
Proof. intros ?; inversion 1; firstorder. Qed.

Lemma conditional_inj_neg2 {P} {G} {S} {e1 e2 e3} : 
  (forall ty, neg (expressionType P G S e2 ty)) ->
  forall tc, neg (eType P G S (Conditional e1 e2 e3) tc).
Proof. intros ?; inversion 1; firstorder. Qed.

Lemma conditional_inj_neg3 {P} {G} {S} {e1 e2 e3} : 
  (forall ty, neg (expressionType P G S e3 ty)) ->
  forall tc, neg (eType P G S (Conditional e1 e2 e3) tc).
Proof. intros ?; inversion 1; firstorder. Qed.

Lemma isConditional_fun_correct_neg {P G S} {ty1 ty2 ty3} {e1 e2 e3} :
  (forall ty1 ty1', expressionType P G S e1 ty1 -> expressionType P G S e1 ty1' -> ty1 = ty1') ->
  (forall ty2 ty2', expressionType P G S e2 ty2 -> expressionType P G S e2 ty2' -> ty2 = ty2') ->
  (forall ty3 ty3', expressionType P G S e3 ty3 -> expressionType P G S e3 ty3' -> ty3 = ty3') ->
  expressionType P G S e1 ty1 ->
  expressionType P G S e2 ty2 ->
  expressionType P G S e3 ty3 ->
  isConditional_fun P ty1 ty2 ty3 (isNullPointerConstant_fun e2) (isNullPointerConstant_fun e3) = None ->
  forall tc, neg (eType P G S (Conditional e1 e2 e3) tc).
Proof.
  intros ? ? ? ? ? ?.
  unfold_goal.
  destruct ty1, ty2, ty3;
  unfold andb;
  unfold option_map;
  unfold combineQualifiers_left;
  unfold combineQualifiers_right;
  abstract (
  repeat match goal with
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [H : isPointer ?t |- _] => is_var t; inversion H; subst
  | [H : isVoid ?t |- _] => is_var t; inversion H; subst
  | [H : isPointer (Basic _) |- _] => inversion H
  | [H : isPointer (Array _ _) |- _] => inversion H
  | [H : isPointer (Function _ _) |- _] => inversion H
  | [H : isPointer Void |- _] => inversion H
  | [H : neg (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [H : neg (isVoid Void) |- _ ] => exfalso; apply H; now constructor
  | [H : isVoid (Basic _) |- _] => inversion H
  | [H : isVoid (Array _ _) |- _] => inversion H
  | [H : isVoid (Function _ _) |- _] => inversion H
  | [H : isVoid (Pointer _ _) |- _] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isArithmetic Void           |- _ ] => inversion H
  | [H : isArithmetic (Array _ _) |- _ ] => inversion H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion H
  | [H : isScalar Void           |- _ ] => inversion H
  | [H : isScalar (Array _ _) |- _ ] => inversion H
  | [H : isScalar (Function _ _) |- _ ] => inversion H
  | [|- isScalar_fun ?t = _ -> _] => case_fun (isScalar_fun_correct t)
  | [|- isArithmetic_fun ?t = _ -> _] => case_fun (isArithmetic_fun_correct t)
  | [|- isUsualArithmetic_find P ?t1 ?t2 = _ -> _] => case_fun (isUsualArithmetic_find_correct P t1 t2)
  | [|- isVoid_fun ?t = _ -> _] => case_fun (isVoid_fun_correct t)
  | [|- isPointer_fun ?t = _ -> _] => case_fun (isPointer_fun_correct t)
  | [|- isNullPointerConstant_fun ?e = _ -> _] => case_fun (isNullPointerConstant_fun_correct e)
  | [|- isPointerToObject_fun ?t = _ -> _] =>
      case_fun (isPointerToObject_fun_correct t); [
      match goal with
      | [H : {_ : _ &  _} |- _ ] => let Heq := fresh in
                                    destruct H as [? [? [Heq ?]]];
                                    try discriminate Heq;
                                    inversion Heq; subst
      end|]
  | [|- isPointerToVoid_fun ?t = _ -> _] =>
      case_fun (isPointerToVoid_fun_correct t); [
      match goal with
      | [H : {_ : _ &  _} |- _ ] => let Heq := fresh in
                                    destruct H as [? [? [Heq ?]]];
                                    try discriminate Heq;
                                    inversion Heq; subst
      end|]
  | [|- compositePointer_find ?t1 ?t2 = _ -> _] =>
      case_fun (compositePointer_find_correct t1 t2); [
      match goal with
      | [H : {_ : _ & _} |- _] =>   let Heq1 := fresh in
                                    let Heq2 := fresh in
                                    destruct H as [? [? [? [? [? [[[[Heq1 Heq2] ?] ?] ?]]]]]];
                                    (try discriminate Heq1);
                                    (try discriminate Heq2);
                                    inversion Heq1;
                                    inversion Heq2; subst
      end|]
  | _ => context_destruct
  | [|- None = Some _ -> _] => now inversion 1
  | [|- Some _ = Some _ -> _] => let Heq :=fresh in intros Heq; injection Heq; intros; subst
  | [|- eType P G S _ _] =>  econstructor (solve [eassumption | finish fail | econstructor (eassumption)])
  end;
  abstract (
  intros ?; inversion 1; subst;
  repeat match goal with
  | [H : isPointer ?t |- _] => is_var t; inversion H; subst
  | [H : isVoid ?t |- _] => is_var t; inversion H; subst
  | [H : isPointer (Basic _) |- _] => inversion H
  | [H : isPointer (Array _ _) |- _] => inversion H
  | [H : isPointer (Function _ _) |- _] => inversion H
  | [H : isPointer Void |- _] => inversion H
  | [H : neg (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [H : neg (isVoid Void) |- _ ] => exfalso; apply H; now constructor
  | [H : isVoid (Basic _) |- _] => inversion H
  | [H : isVoid (Array _ _) |- _] => inversion H
  | [H : isVoid (Function _ _) |- _] => inversion H
  | [H : isVoid (Pointer _ _) |- _] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isArithmetic Void           |- _ ] => inversion H
  | [H : isArithmetic (Array _ _) |- _ ] => inversion H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion H
  | [H : isScalar Void           |- _ ] => inversion H
  | [H : isScalar (Array _ _) |- _ ] => inversion H
  | [H : isScalar (Function _ _) |- _ ] => inversion H
  | [ Hfalse : forall _ _, Pointer _ ?ty = Pointer _ _ -> neg (isObject _)
    , H : isObject ?ty |- _] =>
      destruct (Hfalse _ _ eq_refl H)
  | [Hfalse : forall _ _, Pointer _ Void = Pointer _ _ -> neg (isVoid _) |- _ ] =>
      exfalso; apply (Hfalse _ _ eq_refl); constructor
  | [ H : isUsualArithmetic P ?t1 ?t2 _ 
    , Hfalse : forall _, neg (isUsualArithmetic P ?t1 ?t2 _) |- _ ] => destruct (Hfalse _ H)
  | [ H1 : isUsualArithmetic P ?ty1 ?ty2 ?t, H2 : isUsualArithmetic P ?ty1 ?ty2 ?t' |- _] =>
      notSame t t'; set (isUsualArithmetic_unique H1 H2)
  | [ Hunique : forall _ _, expressionType P G S ?e _ -> expressionType P G S ?e _ -> _ = _
    , H1 : expressionType P G S ?e ?ty1
    , H2 : expressionType P G S ?e ?ty2 |- _] =>
      notSame ty1 ty2;
      let Heq := fresh in
      set (Hunique _ _ H1 H2) as Heq;
      inversion Heq; clear Heq; subst; try congruence
  | [H : _ * _ |- _] => destruct H
  | [H : {_ : _ & {_ : _ & {_ : _ & {_ : _ & (_ = _) * (_ = _) * neg _}}}} |- _] =>
      let Heq1 := fresh in
      let Heq2 := fresh in
      destruct H as [? [? [? [? [[Heq1 Heq2] ?]]]]];
      injection Heq1; injection Heq2; intros; clear Heq1; clear Heq2; subst; try congruence
  | [H : _ + _ |- _] => destruct H
  end; congruence)).
Qed.

Fixpoint eType_find (P:impl) (G:gamma) (S:sigma) e {struct e} : option typeCategory :=
  match e with
  | Var id =>
      match lookup_id G id, lookup_id S id with
      | Some (qs, ty), None   => Some (LvalueType     qs ty)
      | None         , Some p => Some (ExpressionType (typeOfSigma p))
      | _            , _      => None
      end
  | Binary e1 Comma e2 => 
     match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
     | Some _, Some ty2 => Some (ExpressionType ty2)
     | _     , _        => None
     end
  | Unary Address e =>
      match eType_find P G S e with
      | Some (LvalueType qs ty)                => Some (ExpressionType (Pointer qs ty))
      | Some (ExpressionType (Function ty ps)) => Some (ExpressionType (Pointer unqualified (Function ty ps)))
      | _                                      => None
      end
  | Unary Plus e
  | Unary Minus e =>
      eType_find P G S e  >>=
      expressionType_aux_find >>= (fun ty =>
        if isArithmetic_fun ty then
          option_map ExpressionType (isPromotion_find P ty)
        else
          None
      )
  | Unary Bnot e =>
      eType_find P G S e  >>=
      expressionType_aux_find >>= (fun ty =>
        if isInteger_fun ty then
          option_map ExpressionType (isPromotion_find P ty)
        else
          None
      )
  | Unary Indirection e =>
      eType_find P G S e >>=
      expressionType_aux_find >>= (fun ty =>
        match ty with
        | Pointer qs (Function t p)  => if isUnqualified_fun qs
                                          then Some (ExpressionType (Pointer qs (Function t p)))
                                          else None
        | Pointer qs  ty             => if andb (isComplete_fun ty) (isObject_fun ty)
                                          then Some (LvalueType qs ty)
                                          else None
        | _                          => None
        end
      )
  | Unary PostfixIncr e
  | Unary PostfixDecr e =>
      match eType_find P G S e with
      | Some (LvalueType qs' ty') =>
          match lvalueConversion_find ty' with
          | Some ty =>
              if andb (isModifiable_fun qs' ty')
                      (orb (isReal_fun ty') (isPointer_fun ty'))
                then Some (ExpressionType ty)
                else None
          | None    => None
          end
      | Some _                    => None
      | None                      => None
      end
  | Call e ls =>
      match eType_find P G S e >>= expressionType_aux_find with
      | Some (Pointer qs (Function ty ps)) => if andb (isUnqualified_fun qs) (eType_arguments_find P G S ls ps)
                                                then Some (ExpressionType ty)
                                                else None
      | _                                  => None
      end
  | Assign e1 e2 =>
      match eType_find P G S e1, eType_find P G S e2 >>= expressionType_aux_find with
      | Some (LvalueType qs1 ty1), Some ty2 =>
          let ty := pointerConvert ty1 in
          if andb (isModifiable_fun qs1 ty1) (isAssignable_fun ty ty2 (isNullPointerConstant_fun e2))
            then Some (ExpressionType ty)
            else None
      | _, _ => None
      end
  | Binary e1 (Arithmetic (Mul  as aop)) e2
  | Binary e1 (Arithmetic (Div  as aop)) e2
  | Binary e1 (Arithmetic (Mod  as aop)) e2
  | Binary e1 (Arithmetic (Band as aop)) e2
  | Binary e1 (Arithmetic (Xor  as aop)) e2
  | Binary e1 (Arithmetic (Bor  as aop)) e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if isBinaryArithmetic_fun ty1 aop ty2
                                then option_map ExpressionType (isUsualArithmetic_find P ty1 ty2)
                                else None
      | _       , _        => None
      end
  | Binary e1 (Arithmetic (Shl  as aop)) e2
  | Binary e1 (Arithmetic (Shr  as aop)) e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if isBinaryArithmetic_fun ty1 aop ty2
                                then option_map ExpressionType (isPromotion_find P ty1)
                                else None
      | _       , _        => None
      end
  | Binary e1 (Arithmetic (Add  as aop)) e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if andb (isPointerToCompleteObject_fun ty1) (isInteger_fun ty2) then
                                Some (ExpressionType ty1)
                              else if andb (isPointerToCompleteObject_fun ty2) (isInteger_fun ty1) then
                                Some (ExpressionType ty2)
                              else if isBinaryArithmetic_fun ty1 aop ty2 then
                                option_map ExpressionType (isUsualArithmetic_find P ty1 ty2)
                              else None
      | _       , _        => None
      end
  | Binary e1 (Arithmetic (Sub  as aop)) e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if arePointersToCompatibleCompleteObjects_fun ty1 ty2 then
                                Some (ExpressionType (ptrdiff_t P))
                              else if andb (isPointerToCompleteObject_fun ty1) (isInteger_fun ty2) then
                                Some (ExpressionType ty1)
                              else if (isBinaryArithmetic_fun ty1 Sub ty2) then
                                option_map ExpressionType (isUsualArithmetic_find P ty1 ty2)
                              else None
      | _       , _        => None
      end
  | Binary e1 And e2
  | Binary e1 Or  e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if andb (isScalar_fun ty1) (isScalar_fun ty2)
                                then Some (ExpressionType (Basic (Integer (Signed Int))))
                                else None
      | _       , _        => None
      end
  | Binary e1 Lt e2
  | Binary e1 Gt e2
  | Binary e1 Le e2
  | Binary e1 Ge e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if arePointersToCompatibleObjects_fun ty1 ty2 then
                                Some (ExpressionType (Basic (Integer (Signed Int))))
                              else if andb (isReal_fun ty1) (isReal_fun ty2) then
                                Some (ExpressionType (Basic (Integer (Signed Int))))
                              else None
      | _       , _        => None
      end
  | Binary e1 Eq e2
  | Binary e1 Ne e2 =>
      match eType_find P G S e1 >>= expressionType_aux_find, eType_find P G S e2 >>= expressionType_aux_find with
      | Some ty1, Some ty2 => if isEquality_fun ty1 ty2 (isNullPointerConstant_fun e1) (isNullPointerConstant_fun e2)
                                then Some (ExpressionType (Basic (Integer (Signed Int))))
                                else None
      | _       , _        => None
      end
  | SizeOf  qs ty
  | AlignOf qs ty =>
      if andb (wfLvalueType_fun qs ty)
              (andb (negb (isFunction_fun   ty))
                    (negb (isIncomplete_fun ty)))
        then Some (ExpressionType (size_t P))
        else None
  | Cast qs Void e =>
      if wfLvalueType_fun qs Void then
        match eType_find P G S e >>= expressionType_aux_find with
        | Some _ => Some (ExpressionType Void)
        | None   => None
        end
      else
        None
  | Cast qs ty e =>
      if wfLvalueType_fun qs ty then
        match eType_find P G S e >>= expressionType_aux_find with
        | Some ty' => if andb (isScalar_fun ty') (isScalar_fun ty)
                        then Some (ExpressionType ty)
                        else None
        | None     => None
        end
      else
        None
  | Constant (ConstantInteger ic) =>
      match cType_fun P ic with
      | Some it => Some (ExpressionType (Basic (Integer it)))
      | None    => None
      end
  | Conditional e1 e2 e3 =>
      match eType_find P G S e1 >>= expressionType_aux_find,
            eType_find P G S e2 >>= expressionType_aux_find,
            eType_find P G S e3 >>= expressionType_aux_find  with
      | Some ty1, Some ty2, Some ty3 => isConditional_fun P ty1 ty2 ty3 (isNullPointerConstant_fun e2) (isNullPointerConstant_fun e3)
      | _       , _       , _        => None
      end
  | CompoundAssign e1 Add e2
  | CompoundAssign e1 Sub e2 =>
      match eType_find P G S e1, eType_find P G S e2 >>= expressionType_aux_find with
      | Some (LvalueType qs ty), Some ty2 => 
          match lvalueConversion_find ty with
          | Some ty1 => if andb (isModifiable_fun qs ty)
                                (orb (andb (isArithmetic_fun ty1)
                                           (isArithmetic_fun ty2))
                                     (andb (isPointerToCompleteObject_fun ty)
                                           (isInteger_fun ty2)))
                          then Some (ExpressionType ty1)
                          else None
          | None    => None
          end
      | _                                    , _  => None
      end
  | CompoundAssign e1 aop e2 =>
      match eType_find P G S e1, eType_find P G S e2 >>= expressionType_aux_find with
      | Some (LvalueType qs ty), Some ty2 => 
          match lvalueConversion_find ty with
          | Some ty1 => if andb (isModifiable_fun qs ty) (isBinaryArithmetic_fun ty1 aop ty2) 
                          then Some (ExpressionType ty1)
                          else None
          | None    => None
          end
      | _                                    , _  => None
      end
  end
with eType_arguments_find (P:impl) (G:gamma) (S:sigma) (l:arguments) (p:params) {struct l} : bool :=
  match l, p with
  | ArgumentsNil     , ParamsNil          => true
  | ArgumentsCons e l, ParamsCons _ ty1 p =>
      match eType_find P G S e >>= expressionType_aux_find with
      | Some ty2 => andb (isAssignable_fun (pointerConvert ty1) ty2 (isNullPointerConstant_fun e))
                         (eType_arguments_find P G S l p)
      | None     => false
      end
  | _                , _                  => false
  end.

Definition eType_find_spec P G S e :=
  Disjoint G S ->
  match eType_find P G S e with
  | Some tc => eType P G S e tc * (forall tc', eType P G S e tc' -> tc = tc')
  | None    => forall tc, neg (eType P G S e tc)
  end.

Definition eType_arguments_find_spec P G S l p :=
  Disjoint G S ->
  boolSpec (eType_arguments_find P G S l p) (eType_arguments P G S l p).

Ltac eType_find_tac Hdisjoint P G S :=
  repeat match goal with
  | [H : boolSpec true  _ |- _] => rewrite boolSpec_true  in H
  | [H : boolSpec false _ |- _] => rewrite boolSpec_false in H
  | [H : isComplete Void |- _ ] => inversion H
  | [H : isObject (Function _ _) |- _ ] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isInteger    (Array _ _) |- _ ] => inversion H
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isArithmetic Void           |- _ ] => inversion H; subst
  | [H : isArithmetic (Array _ _) |- _ ] => inversion H; subst
  | [H : isArithmetic (Function _ _) |- _ ] => inversion H; subst
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion H; subst
  | [H : isBinaryArithmetic Void Add _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Add Void |- _] => inversion H; subst
  | [H : isBinaryArithmetic (Array _ _) Add _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Add (Array _ _) |- _] => inversion H; subst
  | [H : isBinaryArithmetic (Pointer _ _) Add _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Add (Pointer _ _) |- _] => inversion H; subst
  | [H : isBinaryArithmetic (Function _ _) Add _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Add (Function _ _) |- _] => inversion H; subst
  | [H : isBinaryArithmetic Void Sub _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Sub Void |- _] => inversion H; subst
  | [H : isBinaryArithmetic (Array _ _) Sub _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Sub (Array _ _) |- _] => inversion H; subst
  | [H : isBinaryArithmetic (Pointer _ _) Sub _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Sub (Pointer _ _) |- _] => inversion H; subst
  | [H : isBinaryArithmetic (Function _ _) Sub _ |- _] => inversion H; subst
  | [H : isBinaryArithmetic _ Sub (Function _ _) |- _] => inversion H; subst
  | [H : (?aop = Add) + (?aop = Sub) |- _] => notSame aop Add; notSame aop Sub; destruct H as [H|H]; discriminate H
  | [H : neg (isPointer (Pointer _ _)) |- _ ] => exfalso; apply H; now constructor
  | [H : neg ((Add = Add) + _) |- _ ] => exfalso; apply H; left ; reflexivity
  | [H : neg (_ + (Sub = Sub)) |- _ ] => exfalso; apply H; right; reflexivity
  | [Heq : pointerConvert ?t = Pointer _ _, H : context [pointerConvert ?t] |- _ ] => rewrite    Heq in *
  | [Heq : Pointer _ _ = pointerConvert ?t, H : context [pointerConvert ?t] |- _ ] => rewrite <- Heq in *
  | [H : isUnqualified ?qs |- _] => is_var qs; inversion H; subst
  | [|- lookup_id ?E ?id = ?o -> _] =>
      case_fun (lookup_id_correct E id)
  | [|- context[option_map] ] =>
      unfold option_map
  | [|- context[negb] ] =>
      unfold negb
  | [|- (Some _ >>= _) = _ -> _ ] =>
      unfold option_bind at 1
  | [|- Some _ = ?o -> _ ] =>
      is_var o; intros ?; subst o
  | [|- None = ?o -> _ ] =>
      is_var o; intros ?; subst o
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (None >>= _) = ?o -> _] =>
      is_var o; unfold option_bind at 1; intros ?; subst o
  | [|- (None >>= _) = ?o -> _] =>
      unfold option_bind at 1
  | [|- ?e >>= _ = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (true || _) = _ -> _] => unfold orb at 1
  | [|- (false || _) = _ -> _] => rewrite orb_false_l
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- (?e || _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [H : forall _, eType_arguments_find_spec P G S ?l _ |- eType_arguments_find P G S ?l ?p = ?o -> _] =>
      case_fun (H p Hdisjoint)
  | [H : eType_find_spec P G S ?e |- eType_find P G S ?e = ?o -> _] =>
      case_fun (H Hdisjoint);
      match goal with
      | [H : _ * _ |- _] => destruct H
      | _ => idtac
      end
  | [|- isAssignable_fun _ _ _ = ?o -> _] =>
      is_var o; destruct o
  | [H : expressionType P G S _ ?ty2 |- isAssignable_fun ?ty1 ?ty2 (isNullPointerConstant_fun ?e) = true -> _] =>
      let Heq := fresh in
      intros Heq; set (isAssignable_fun_correct_pos H Heq)
  | [ Hunique : forall _, eType P G S ?e2 _ -> _ = _
    , H : expressionType P G S ?e2 ?ty2 |- isAssignable_fun ?ty1 ?ty2 (isNullPointerConstant_fun ?e) = false -> _] =>
      let Heq := fresh in
      intros Heq; set (isAssignable_fun_correct_neg H (eType_unique_instance Hunique) Heq)
  | [|- isEquality_fun _ _ _ _ = ?o -> _ ] => is_var o; destruct o
  | [ H1 : expressionType P G S ?e1 _
    , H2 : expressionType P G S ?e2 _
      |- isEquality_fun _ _ (isNullPointerConstant_fun ?e1) (isNullPointerConstant_fun ?e2) = true -> _] =>
      let Heq := fresh in
      let H := fresh in
      intros Heq;
      match goal with
      | [|- context[Eq]] => set (isEquality_fun_correct_pos (inl (eq_refl Eq)) H1 H2 Heq)
      | [|- context[Ne]] => set (isEquality_fun_correct_pos (inr (eq_refl Ne)) H1 H2 Heq)
      end
  | [ Hunique1 : forall _, eType P G S ?e1 _ -> _ = _
    , Hunique2 : forall _, eType P G S ?e2 _ -> _ = _
    , H1 : expressionType P G S ?e1 _
    , H2 : expressionType P G S ?e2 _
      |- isEquality_fun _ _ (isNullPointerConstant_fun ?e1) (isNullPointerConstant_fun ?e2) = false -> _] =>
      let Heq := fresh in
      intros Heq;
      match goal with
      | [|- context[Eq]] => set (isEquality_fun_correct_neg (inl (eq_refl Eq)) H1 H2 (eType_unique_instance Hunique1) (eType_unique_instance Hunique2) Heq)
      | [|- context[Ne]] => set (isEquality_fun_correct_neg (inr (eq_refl Ne)) H1 H2 (eType_unique_instance Hunique1) (eType_unique_instance Hunique2) Heq)
      end       
  | [|- expressionType_aux_find ?t = _ -> _] =>
      is_var t; destruct t
  | [H : eType P G S _ (ExpressionType ?t) |- expressionType_aux_find (ExpressionType ?t) = ?o -> _] =>
      is_var o; let Heq := fresh in
      intros Heq; subst o;
      assert (expressionType_aux_find (ExpressionType t) = Some (pointerConvert t)) as Heq by reflexivity; rewrite Heq;
      set (expressionType_aux_find_correct_pos H Heq)
  | [|- expressionType_aux_find (LvalueType ?q ?t) = ?o -> _] =>
      is_var o; destruct o
  | [H : eType P G S _ (LvalueType ?q ?t) |- expressionType_aux_find (LvalueType ?q ?t) = Some _ -> _] =>
      let Heq := fresh in
      intros Heq;
      set     (expressionType_aux_find_eq_lvalue_lift H Heq);
      rewrite (expressionType_aux_find_eq_lvalue        Heq) in *
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType ?q ?t = _
    , H : eType P G S ?e (LvalueType ?q ?t) |- expressionType_aux_find (LvalueType ?q ?t) = None -> _] =>
      let Heq := fresh in
      intros Heq; set (expressionType_aux_find_correct_neg H Hunique Heq)
  | [|- isArithmetic_fun ?t           = ?o -> _] => case_fun (isArithmetic_fun_correct t)
  | [|- isComplete_fun ?t           = ?o -> _] => case_fun (isComplete_fun_correct t)
  | [|- isIncomplete_fun ?t           = ?o -> _] => case_fun (isIncomplete_fun_correct t)
  | [|- isObject_fun ?t           = ?o -> _] => case_fun (isObject_fun_correct t)
  | [|- isFunction_fun ?t           = ?o -> _] => case_fun (isFunction_fun_correct t)
  | [|- isScalar_fun ?t           = ?o -> _] => case_fun (isScalar_fun_correct t)
  | [|- isInteger_fun ?t           = ?o -> _] => case_fun (isInteger_fun_correct t)
  | [|- isReal_fun ?t           = ?o -> _] => case_fun (isReal_fun_correct t)
  | [|- isPointer_fun ?t           = ?o -> _] => case_fun (isPointer_fun_correct t)
  | [|- isNullPointerConstant_fun ?e = ?o -> _] => case_fun (isNullPointerConstant_fun_correct e)
  | [|- isPointerToCompleteObject_fun ?t           = ?o -> _] =>
      case_fun (isPointerToCompleteObject_fun_correct t);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? ?]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleCompleteObjects_fun ?t1 ?t2           = ?o -> _] =>
      case_fun (arePointersToCompatibleCompleteObjects_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[[[? ?] ?] ?] ?]]]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleObjects_fun ?t1 ?t2           = ?o -> _] =>
      case_fun (arePointersToCompatibleObjects_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[[[? ?] ?] ?] ?]]]]]; subst
      | _ => idtac
      end
  | [|- arePointersToCompatibleTypes_fun ?t1 ?t2           = ?o -> _] =>
      case_fun (arePointersToCompatibleTypes_fun_correct t1 t2);
      match goal with
      | [H : {_ : _ & _} |- _] => destruct H as [? [? [? [? [[? ?] ?] ]]]]; subst
      | _ => idtac
      end
  | [|- isModifiable_fun ?qs ?ty           = ?o -> _] => case_fun (isModifiable_fun_correct qs ty)
  | [|- isUnqualified_fun ?qs           =  _ -> _] => case_fun (isUnqualified_fun_correct qs)
  | [|- isCompatible_fun ?t1 ?t2           = ?o -> _] => case_fun (isCompatible_fun_correct t1 t2)
  | [|- isBinaryArithmetic_fun ?ty1 ?aop ?ty2 = ?o -> _] => case_fun (isBinaryArithmetic_fun_correct ty1 aop ty2)
  | [|- wfLvalueType_fun ?qs ?ty = _ -> _] => case_fun (wfLvalueType_fun_correct qs ty)
  | [|- isPromotion_find P ?t         = ?o -> _] =>
      is_var o;
      let Heq := fresh in
      let H := fresh in
      set (isPromotion_find_correct P t) as H;
      intros Heq; rewrite Heq in H; destruct o
  | [|- isUsualArithmetic_find P ?t1 ?t2 = ?o -> _] =>
      is_var o;
      let Heq := fresh in
      let H := fresh in
      set (isUsualArithmetic_find_correct P t1 t2) as H;
      intros Heq; rewrite Heq in H; destruct o
  | [|- lvalueConversion_find ?t         = ?o -> _] =>
      is_var o;
      let Heq := fresh in
      let H := fresh in
      set (lvalueConversion_find_correct t) as H;
      unfold optionSpec in H;
      intros Heq; rewrite Heq in H; destruct o
  | [|- cType_fun P ?ic = _ -> _] => case_fun (cType_fun_correct P ic);
      match goal with
      | [H : _ * _ |- _] => destruct H
      | _ => idtac
      end
  | _ => context_destruct
  | [Hfalse : forall _, neg (eType P G S ?e1 _) |- forall _, neg (eType P G S (Conditional ?e1 _ _) _)] => exact (conditional_inj_neg1 (expressionType_neg Hfalse))
  | [Hfalse : forall _, neg (eType P G S ?e2 _) |- forall _, neg (eType P G S (Conditional _ ?e2 _) _)] => exact (conditional_inj_neg2 (expressionType_neg Hfalse))
  | [Hfalse : forall _, neg (eType P G S ?e3 _) |- forall _, neg (eType P G S (Conditional _ _ ?e3) _)] => exact (conditional_inj_neg3 (expressionType_neg Hfalse))
  | [Hfalse : forall _, neg (expressionType P G S ?e1 _) |- forall _, neg (eType P G S (Conditional ?e1 _ _) _)] => exact (conditional_inj_neg1 Hfalse)
  | [Hfalse : forall _, neg (expressionType P G S ?e2 _) |- forall _, neg (eType P G S (Conditional _ ?e2 _) _)] => exact (conditional_inj_neg2 Hfalse)
  | [Hfalse : forall _, neg (expressionType P G S ?e3 _) |- forall _, neg (eType P G S (Conditional _ _ ?e3) _)] => exact (conditional_inj_neg3 Hfalse)
  | [|- isConditional_fun P _ _ _ _ _ = ?o -> _ ] => is_var o; destruct o
  | [ H1 : expressionType P G S ?e1 _
    , H2 : expressionType P G S ?e2 _
    , H3 : expressionType P G S ?e3 _
    |- isConditional_fun P _ _ _ _ _ = Some _ -> _ * _ ] =>
      let Heq := fresh in
      intros Heq; set (isConditional_fun_correct_pos H1 H2 H3 Heq); split; [assumption|]
  | [ Hunique1 : forall _, eType P G S ?e1 _ -> _ = _
    , Hunique2 : forall _, eType P G S ?e2 _ -> _ = _
    , Hunique3 : forall _, eType P G S ?e3 _ -> _ = _
    , H : eType P G S (Conditional ?e1 ?e2 ?e3) ?tc
    |- forall _, eType P G S (Conditional ?e1 ?e2 ?e3) _ -> ?tc = _ ] =>
      let tc' := fresh in
      intros tc';
      exact (conditional_uniqueness (fun ty ty' E => expressionType_unique_expression_inj (eType_unique_instance Hunique1) E ty')
                                    (fun ty ty' E => expressionType_unique_expression_inj (eType_unique_instance Hunique2) E ty')
                                    (fun ty ty' E => expressionType_unique_expression_inj (eType_unique_instance Hunique3) E ty') tc tc' H)
  | [ Hunique1 : forall _, eType P G S ?e1 _ -> _ = _
    , Hunique2 : forall _, eType P G S ?e2 _ -> _ = _
    , Hunique3 : forall _, eType P G S ?e3 _ -> _ = _
    , H1 : expressionType P G S ?e1 _
    , H2 : expressionType P G S ?e2 _
    , H3 : expressionType P G S ?e3 _
    |- isConditional_fun P _ _ _ _ _ = None -> _ ] =>
      let Heq := fresh in
      intros Heq;
      exact (isConditional_fun_correct_neg (fun ty ty' E => expressionType_unique_expression_inj (eType_unique_instance Hunique1) E ty')
                                           (fun ty ty' E => expressionType_unique_expression_inj (eType_unique_instance Hunique2) E ty')
                                           (fun ty ty' E => expressionType_unique_expression_inj (eType_unique_instance Hunique3) E ty') H1 H2 H3 Heq)
  | [|- (match pointerConvert ?ty with _ => _ end) = _ -> _] => destruct ty; unfold pointerConvert in *
  | [|- _ * _] => split
  | [H1 : cType P ?ic ?it1, H2 : cType P ?ic ?it2 |- _] => notSame it1 it2; set (cType_unique H1 H2); try congruence
  | [Hfalse : forall _, neg (cType P ?ic _), H : cType P ?ic _ |- _] => destruct (Hfalse _ H)
  | [|- eType P G S _ _] => assumption || econstructor (solve [eassumption|reflexivity|inversion 1; congruence|left; reflexivity|right; reflexivity])
  | [|- eType_arguments P G S _ _] => econstructor (solve [reflexivity |assumption])
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType _ ?t1 = _
    , H1  : expressionType P G S ?e ?t1
    , H2  : expressionType P G S ?e ?t2         |- _ ] =>
      notSame t1 t2;
      let Heq := fresh in
      assert (t1 = t2) as Heq by (eapply expressionType_unique_lvalue_inj; eauto);
      try (congruence || (try injection Heq; intros); subst)
  | [ Hunique : forall _, eType P G S ?e _ -> ExpressionType ?t = _
    , _   : expressionType_aux_find (ExpressionType ?t) = Some ?t1
    , H1 : expressionType P G S ?e ?t1
    , H2 : expressionType P G S ?e ?t2         |- _ ] =>
      notSame t1 t2;
      let Heq := fresh in
      assert (t1 = t2) as Heq by (eapply (expressionType_unique_expression_inj (eType_unique_instance Hunique)); eauto);
      try (congruence || (try injection Heq; intros); subst)
(*
  | [ _  : expressionType P G S ?e ?t1
    , _  : expressionType P G S ?e ?t2         |- _ ] =>
      notSame t1 t2;
      let Heq := fresh in
      assert (t1 = t2) as Heq by (eapply expressionType_unique_expression_inj; eauto);
      try (congruence || (try injection Heq; intros); subst)
*)
  | [H : isPromotion P ?t1 ?t2 |- _ ] => notHyp (isPromotion_find P t1 = Some t2); set (isPromotion_find_unique P t1 t2 H); try congruence
  | [H : lvalueConversion ?t1 ?t2 |- _ ] => notHyp (lvalueConversion_find t1 = Some t2); set (lvalueConversion_find_unique t1 t2 H); try congruence
  | [H : isUsualArithmetic P ?t1 ?t2 ?t3 |- _ ] => notHyp (isUsualArithmetic_find P t1 t2 = Some t3); set (isUsualArithmetic_find_unique H); try congruence
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType _ _   = _, H : eType P G S ?e (ExpressionType _) |- _] => discriminate (Hunique _ H)
  | [ Hunique : forall _, eType P G S ?e _ -> ExpressionType _ = _, H : eType P G S ?e (LvalueType   _ _) |- _] => discriminate (Hunique _ H)
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType _ _ = _, H : eType P G S ?e (LvalueType _ ?t)  |- _] =>
      discriminate (Hunique _ H) || (einjection (Hunique _ H); congruence)
  | [ Hunique : forall _, eType P G S ?e _ -> ExpressionType _ = _, H : eType P G S ?e (ExpressionType ?t) |- _] =>
      discriminate (Hunique _ H) || (einjection (Hunique _ H); congruence)
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType ?qs ?ty = _
    , H1 : eType P G S ?e (LvalueType ?qs ?ty)
    , H2 : eType P G S ?e (LvalueType _  (Pointer _ _)) |- False] =>
        is_var ty; injection (Hunique _ H2); intros; subst
  | [H : isPointer ?t, _ : expressionType P G S _ ?t |- eType P G S (Binary _ Eq _) _ ] => is_var t; inversion H; subst
  | [H : isPointer ?t, _ : expressionType P G S _ ?t |- eType P G S (Binary _ Ne _) _ ] => is_var t; inversion H; subst
  | [H : isPointer (pointerConvert ?t), _ : expressionType P G S _ (pointerConvert ?t) |- eType P G S (Binary _ Eq _) _ ] => is_var t; inversion H; subst
  | [H : isPointer (pointerConvert ?t), _ : expressionType P G S _ (pointerConvert ?t) |- eType P G S (Binary _ Ne _) _ ] => is_var t; inversion H; subst
  | [ _ : forall _, neg (_ P G S ?e _)
    , H : isAssignable P G S (pointerConvert _) ?e |- False] => inversion_clear H
  | [|- forall _, eType P G S (Binary _ Comma _) _ -> _ = _] => inversion_clear 1; now auto
  | [|- forall _, eType P G S (Binary _ _ _) _ -> _ = _] => inversion 1; subst; try congruence
  | [|- forall _, eType P G S (SizeOf _ _) _ -> _ = _] => inversion 1; subst; try congruence
  | [|- forall _, eType P G S (AlignOf _ _) _ -> _ = _] => inversion 1; subst; try congruence
  | [|- forall _, eType P G S (Cast _ _ _) _ -> _ = _] => inversion 1; subst; try congruence
  | [|- forall _, eType P G S (Unary _ _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (Var _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (Call _ _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (Assign _ _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (CompoundAssign _ _ _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (Constant _) _ -> _ = _] => inversion_clear 1; try congruence
  | [|- forall _, neg (eType P G S (Binary _ _ _) _)] => inversion 1; subst
  | [|- forall _, neg (eType P G S (Unary _ _) _)] => inversion 1; subst
  | [|- forall _, neg (eType P G S (Constant _) _)] => inversion 1; subst; try contradiction
  | [|- forall _, neg (eType P G S (Call _ _) _)] => inversion 1; subst
  | [|- forall _, neg (eType P G S (Assign _ _) _)] => inversion 1; subst
  | [|- forall _, neg (eType P G S (CompoundAssign _ _ _) _)] => inversion 1; subst
  | [|- forall _, neg (eType P G S (AlignOf _ _) _)] => inversion 1; subst; contradiction
  | [|- forall _, neg (eType P G S (SizeOf _ _) _)] => inversion 1; subst; contradiction
  | [|- forall _, neg (eType P G S (Cast _ _ _) _)] => inversion 1; subst; try contradiction
  | [|- neg (eType_arguments P G S _ _)] => inversion 1; subst; try congruence
  | [Heq : pointerConvert ?t = Pointer _ _, H : neg (isPointer (pointerConvert ?t)) |- _ ] => rewrite Heq in H; exfalso; apply H; now constructor
  | [H : _ + _ |- _] => destruct H; try congruence
  | [Hfalse : forall _, neg (eType P G S ?e _), H : eType P G S ?e _ |- False] => exact (Hfalse _ H)
  | [Hfalse : forall _, neg (expressionType P G S ?e _), H : expressionType P G S ?e _ |- False] => exact (Hfalse _ H)
  | [ H : isComplete ?ty1 , Hfalse : forall _ _, Pointer ?qs1 ?ty1 = Pointer _ _ -> neg (isComplete _) |- False ] => now eapply (Hfalse qs1 ty1 eq_refl H)
  | [ H : isObject   ?ty1 , Hfalse : forall _ _, Pointer ?qs1 ?ty1 = Pointer _ _ -> neg (isObject   _) |- False ] => now eapply (Hfalse qs1 ty1 eq_refl H)
  | [                       Hfalse : forall _ _, Pointer ?qs1 Void = Pointer _ _ -> neg (isVoid _)     |- False ] => now eapply (Hfalse qs1 Void eq_refl IsVoid)
  | [ Hfalse : forall _ : type, neg (isPromotion P ?t _)
    , _ : expressionType P G S ?e ?t1
    , H : isPromotion P ?t1 ?t2 |- _ ] => exfalso; eapply Hfalse; congruence
  | [ Hfalse : forall _ _ _ _, Pointer ?qs1 ?ty1 = _ ->
                               Pointer ?qs2 ?ty2 = _ ->
                               neg (isCompatible _ _)
    , H : isCompatible ?ty1 ?ty2 |- False] => now eapply (Hfalse qs1 qs2 ty1 ty2 eq_refl eq_refl H)
  | [|- eType _ _ _ (Var _) (LvalueType _ _) ] => now my_auto
  | [ L1 : Lookup ?G ?id _
    , L2 : Lookup ?S ?id _ |- _ ] =>
      destruct (Hdisjoint id _ _ L1 L2)
  | [ H  : lookup_id ?E ?id = Some ?b1
    , L1 : Lookup ?E ?id ?b1
    , L2 : Lookup ?E ?id _ |- _ = _] => set (lookup_id_unique L2); congruence
  | [_ : forall _, neg (Lookup ?G ?id _) 
    ,_ : forall _, neg (Lookup ?S ?id _) |- forall _, neg (eType _ ?G ?S (Var ?id) _)] =>
      inversion 1; now firstorder
  | [ _ : forall _, neg (eType P G S ?e _) , H : expressionType P G S ?e _ |- _] => inversion H
  end.

Ltac eType_find_tac_finish P G S :=
  intros; intros Hdisjoint;
  unfold eType_find; fold eType_arguments_find; fold eType_find;
  eType_find_tac Hdisjoint P G S.

Definition eType_find_correct_Unary {P} {G} {S} {aop} {e} :
  eType_find_spec P G S e ->
  eType_find_spec P G S (Unary aop e).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Mul {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Mul) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Div {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Div) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Mod {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Mod) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Add {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Add) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Sub {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Sub) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Shl {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Shl) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Shr {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Shr) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Band {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Band) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Bor {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Bor) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Arithmetic_Xor {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 (Arithmetic Xor) e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Comma {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Comma e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_And {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 And e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Or {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Or e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Lt {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Lt e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Gt {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Gt e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Le {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Le e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Ge {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Ge e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Eq {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Eq e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Binary_Ne {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Binary e1 Ne e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Assign {P} {G} {S} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (Assign e1 e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_CompoundAssign {P} {G} {S} {aop} {e1 e2} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S (CompoundAssign e1 aop e2).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Conditional {P} {G} {S} {e1 e2 e3} :
  eType_find_spec P G S e1 ->
  eType_find_spec P G S e2 ->
  eType_find_spec P G S e3 ->
  eType_find_spec P G S (Conditional e1 e2 e3).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Cast {P} {G} {S} {qs} {ty} {e} :
  eType_find_spec P G S e ->
  eType_find_spec P G S (Cast qs ty e).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Call {P} {G} {S} {e} {l} :
  (forall p, eType_arguments_find_spec P G S l p)->
  eType_find_spec P G S e ->
  eType_find_spec P G S (Call e l).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Constant {P} {G} {S} {c} :
  eType_find_spec P G S (Constant c).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_Var {P} {G} {S} {id} :
  eType_find_spec P G S (Var id).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_SizeOf {P} {G} {S} {qs} {ty} :
  eType_find_spec P G S (SizeOf qs ty).
Proof. eType_find_tac_finish P G S. Qed.

Definition eType_find_correct_AlignOf {P} {G} {S} {qs} {ty} :
  eType_find_spec P G S (AlignOf qs ty).
Proof. eType_find_tac_finish P G S. Qed.

Fixpoint eType_find_correct P G S e {struct e}:
  eType_find_spec P G S e
with eType_arguments_find_correct P G S l p {struct l}:
  eType_arguments_find_spec P G S l p.
Proof.
- destruct e;
  match goal with
  | [|- eType_find_spec P G S (Unary _ ?e) ] =>
      exact (eType_find_correct_Unary (eType_find_correct P G S e))
  | [|- eType_find_spec P G S (Binary ?e1 ?bop ?e2) ] =>
      destruct bop;
      match goal with
      | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic ?aop) ?e2)] =>
          destruct aop;
          match goal with
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Mul) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Mul (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Div) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Div (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Mod) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Mod (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Add) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Add (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Sub) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Sub (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Shl) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Shl (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Shr) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Shr (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Band) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Band (eType_find_correct P G S e1)
                                                               (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Bor) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Bor (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          | [|- eType_find_spec P G S (Binary ?e1 (Arithmetic Xor) ?e2)] =>
              exact (eType_find_correct_Binary_Arithmetic_Xor (eType_find_correct P G S e1)
                                                              (eType_find_correct P G S e2))
          end
      | [|- eType_find_spec P G S (Binary ?e1 Comma ?e2)] =>
          exact (eType_find_correct_Binary_Comma (eType_find_correct P G S e1)
                                                 (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 And ?e2)] =>
          exact (eType_find_correct_Binary_And (eType_find_correct P G S e1)
                                               (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Or ?e2)] =>
          exact (eType_find_correct_Binary_Or (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Lt ?e2)] =>
          exact (eType_find_correct_Binary_Lt (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Gt ?e2)] =>
          exact (eType_find_correct_Binary_Gt (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Le ?e2)] =>
          exact (eType_find_correct_Binary_Le (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Ge ?e2)] =>
          exact (eType_find_correct_Binary_Ge (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Eq ?e2)] =>
          exact (eType_find_correct_Binary_Eq (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      | [|- eType_find_spec P G S (Binary ?e1 Ne ?e2)] =>
          exact (eType_find_correct_Binary_Ne (eType_find_correct P G S e1)
                                              (eType_find_correct P G S e2))
      end
  | [|- eType_find_spec P G S (Assign ?e1 ?e2) ] =>
      exact (eType_find_correct_Assign (eType_find_correct P G S e1)
                                       (eType_find_correct P G S e2))
  | [|- eType_find_spec P G S (CompoundAssign ?e1 _ ?e2) ] =>
      exact (eType_find_correct_CompoundAssign (eType_find_correct P G S e1)
                                               (eType_find_correct P G S e2))
  | [|- eType_find_spec P G S (Conditional ?e1 ?e2 ?e3) ] =>
      exact (eType_find_correct_Conditional (eType_find_correct P G S e1)
                                            (eType_find_correct P G S e2)
                                            (eType_find_correct P G S e3))
  | [|- eType_find_spec P G S (Cast _ _ ?e) ] =>
      exact (eType_find_correct_Cast (eType_find_correct P G S e))
  | [|- eType_find_spec P G S (Call ?e ?l) ] =>
      exact (eType_find_correct_Call (eType_arguments_find_correct P G S l)
                                     (eType_find_correct P G S e))
  | [|- eType_find_spec P G S (Constant _) ] =>
      exact (eType_find_correct_Constant)
  | [|- eType_find_spec P G S (Var _) ] =>
      exact (eType_find_correct_Var)
  | [|- eType_find_spec P G S (SizeOf _ _) ] =>
      exact (eType_find_correct_SizeOf)
  | [|- eType_find_spec P G S (AlignOf _ _) ] =>
      exact (eType_find_correct_AlignOf)
  end.
- destruct l, p.
  + constructor.
  + intros ?; inversion 1.
  + intros ?; inversion 1.
  + intros Hdisjoint.
    simpl; unfold_goal.
    set (eType_find_correct P G S e).
    set (eType_arguments_find_correct P G S l).
    eType_find_tac Hdisjoint P G S.
Qed.

Lemma eType_unique {P} {G} {S} {e} {tc1 tc2} :
  Disjoint G S ->
  eType P G S e tc1 ->
  eType P G S e tc2 ->
  tc1 = tc2.
Proof.
  intros Hdisjoint; generalize (eType_find_correct P G S e); unfold_goal.
  destruct (eType_find P G S e).
  - intros [? Hunique] H1 H2.
    + exact Hdisjoint.
    + set (Hunique _ H1).
      set (Hunique _ H2).
      congruence.
  - firstorder.
Qed.

Definition typeable_fun P G S e : bool :=
  match eType_find P G S e with
  | Some _ => true
  | None   => false
  end.

Lemma typeable_fun_correct P G S e :
  Disjoint G S ->
  boolSpec (typeable_fun P G S e) (typeable P G S e).
Proof.
  intros Hdisjoint.
  do 2 unfold_goal.
  generalize (eType_find_correct P G S e Hdisjoint).
  destruct (eType_find P G S e).
  - intros [? _]; econstructor; eassumption.
  - inversion 2; firstorder.
Qed.

Definition expressionType_find P G S e : option type :=
  eType_find P G S e >>= expressionType_aux_find.

Definition expressionType_find_correct P G S e :
  Disjoint G S ->
  optionSpec (expressionType_find P G S e) (expressionType P G S e).
Proof.
  intros Hdisjoint.
  do 2 unfold_goal; unfold option_bind.
  generalize (eType_find_correct P G S e Hdisjoint).
  destruct (eType_find P G S e).
  - intros [? ?].
    + repeat match goal with
      | [|- expressionType_aux_find ?t = _ -> _] =>
          is_var t; destruct t
      | [H : eType P G S _ (ExpressionType ?t) |- expressionType_aux_find (ExpressionType ?t) = ?o -> _] =>
          is_var o; let Heq := fresh in
          intros Heq; subst o;
          assert (expressionType_aux_find (ExpressionType t) = Some (pointerConvert t)) as Heq by reflexivity; rewrite Heq;
          set (expressionType_aux_find_correct_pos H Heq)
      | [|- expressionType_aux_find (LvalueType ?q ?t) = ?o -> _] =>
          is_var o; destruct o
      | [H : eType P G S _ (LvalueType ?q ?t) |- expressionType_aux_find (LvalueType ?q ?t) = Some _ -> _] =>
          let Heq := fresh in
          intros Heq;
          set     (expressionType_aux_find_eq_lvalue_lift H Heq);
          rewrite (expressionType_aux_find_eq_lvalue        Heq) in *
      | [ Hunique : forall _, eType P G S ?e _ -> LvalueType ?q ?t = _
        , H : eType P G S ?e (LvalueType ?q ?t) |- expressionType_aux_find (LvalueType ?q ?t) = None -> _] =>
          let Heq := fresh in
          intros Heq; set (expressionType_aux_find_correct_neg H Hunique Heq)
      | _ => context_destruct
      end; assumption.
  - inversion 2; firstorder.
Qed.

(*
(* defns JsType *)
Inductive sType : impl -> gamma -> sigma -> statement -> Prop :=    (* defn sType *)
 | STypeLabel : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (s:statement),
     sType P G S s ->
     sType P G S (Label id s)
 | STypeCase : forall (P:impl) (G:gamma) (S:sigma) (integerConstant:integerConstant) (s:statement),
     sType P G S s ->
     typeable P G S (Constant (ConstantInteger integerConstant)) ->
     sType P G S (Case integerConstant s)
 | STypeDefault : forall (P:impl) (G:gamma) (S:sigma) (s:statement),
     sType P G S s ->
     sType P G S (Default s)
 | STypeBlock : forall (s_list:list statement) (P:impl) (G:gamma) (S:sigma) (G':gamma),
     (forall s_, List.In (s_) (List.map (fun (s_ : statement) => (s_)) s_list) -> (sType P  ( G  @  G' )%gamma  S s_)) ->
     sType P G S (Block G' s_list)
 | STypeSkip : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Skip
 | STypeExpression : forall (P:impl) (G:gamma) (S:sigma) (e:expression),
     typeable P G S e ->
     sType P G S (Expression e)
 | STypeIf : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s1 s2:statement) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s1 ->
     sType P G S s2 ->
     sType P G S (If e s1 s2)
 | STypeSwitch : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s:statement) (ty:type),
     expressionType P G S e ty ->
     isInteger ty ->
     sType P G S s ->
     sType P G S (Switch e s)
 | STypeWhile : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s:statement) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s ->
     sType P G S (While e s)
 | STypeDo : forall (P:impl) (G:gamma) (S:sigma) (s:statement) (e:expression) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s ->
     sType P G S (Do s e)
 | STypeGoto : forall (P:impl) (G:gamma) (S:sigma) (id:identifier),
     sType P G S (Goto id)
 | STypeContinue : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Continue
 | STypeBreak : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Break
 | STypeReturnVoid : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S ReturnVoid
 | STypeReturn : forall (P:impl) (G:gamma) (S:sigma) (e:expression),
     typeable P G S e ->
     sType P G S (Return e)
 | STypeDeclaration : forall (definition_list:list definition) (P:impl) (G:gamma) (S:sigma),
     (forall definition_, List.In (definition_) (List.map (fun (definition_ : definition) => (definition_)) definition_list) -> (dType P G S definition_)) ->
     sType P G S (Declaration definition_list)
with dType : impl -> gamma -> sigma -> definition -> Prop :=    (* defn dType *)
 | DType : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (e:expression) (qs:qualifiers) (ty:type),
      ( G  [  id  ] = Some ( qs ,  ty ))%gamma  ->
     typeable P   ( G  [  id  <- (  nil  ,  ty ) ])%gamma   S (Assign (Var id) e) ->
     dType P G S  ( id , e ) .
(** definitions *)

(* defns JsigmaType *)
Inductive sigmaType : sigma -> sigma -> Prop :=    (* defn sigmaType *)
 | SigmaTypeEmpty : forall (S:sigma),
     sigmaType S  [] 
 | SigmaTypeCtx : forall (S S':sigma) (id:identifier) (ty:type) (s:statement) (P:impl),
     sType P  gamma_empty  S s ->
     sigmaType S S' ->
     sigmaType S  ( S'  [  id  <- ( ty ,  s ) ])%sigma .
(** definitions *)

(* defns JpType *)
Inductive pType : impl -> program -> Prop :=    (* defn pType *)
 | PType : forall (P:impl) (id:identifier) (S:sigma) (s:statement),
     sigmaType S S ->
      ( S  [  id  ] = Some (  (Function (Basic (Integer (Signed Int))) nil)  ,  s ))%sigma  ->
     pType P  ( id ,  S ) .

*)
