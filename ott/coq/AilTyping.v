(* generated by Ott 0.21.2 from: AilTyping_.ott *)

Require Import Bool.
Require Import List.
Require Import Arith.
Require Export ZArith.

Require Import Common.
Require Import AilTypes.
Require Import AilTypesAux.
Require Import AilTypesAux_fun.
Require Import AilTypesAux_proof.
Require Import AilSyntax.
Require Import AilSyntaxAux.
Require Import AilSyntaxAux_fun.
Require Import AilSyntaxAux_proof.
Require Import Implementation.

(** definitions *)

Inductive Lookup {A B : Type} : list (A * B) -> A -> B -> Type :=
  | Lookup_hd     a b E :                           Lookup (cons (a,b) E) a b
  | Lookup_tl x y a b E : x <> a -> Lookup E a b -> Lookup (cons (x,y) E) a b.

Fixpoint Lookup_unique {A B : Type} E (a : A) (b1 b2 : B) (L1 : Lookup E a b1) (L2 : Lookup E a b2) {struct E} : b1 = b2.
Proof.
  destruct E; simple inversion L1; simple inversion L2; try congruence; intros.
  + match goal with
    | [L1 : Lookup ?E1 _ _, L2 : Lookup ?E2 _ _ |- _] =>
        is_var E1; is_var E2;
        assert (E1 = E) by congruence;
        assert (E2 = E) by congruence
    end.
    eapply (Lookup_unique A B E a b1 b2); subst; eassumption.
Qed.

Fixpoint lookup_find {A B} (eq : A -> A -> bool) (E : list (A * B)) (a : A) : option B :=
  match E with
  | nil          => None
  | cons (x,b) E => if eq x a then Some b
                              else lookup_find eq E a
  end.

Fixpoint lookup_find_correct {A B} {eq : A -> A -> bool} (E : list (A * B)) (a : A) {struct E} :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  match lookup_find eq E a with
  | Some b => Lookup E a b
  | None   => forall b, neg (Lookup E a b)
  end.
Proof.
  intros eq_correct.
  unfold_goal.
  destruct E; simpl.
  + intros ?; inversion 1.
  + destruct p as [x b]; simpl.
    set (eq_correct x a).
    case_eq (eq x a); boolSpec_simpl; simpl.
    - my_auto.
    - fold (lookup_find eq E a).
      set (lookup_find_correct A B eq E a eq_correct).
      case_eq (lookup_find eq E a).
      * intros ? Heq.
        rewrite Heq in *; my_auto.
      * intros Heq.
        rewrite Heq in *.
        intros ?; inversion 1; firstorder.
Defined.

Fixpoint lookup_find_unique {A B} {eq : A -> A -> bool} (E : list (A * B)) (a : A) (b : B) {struct E} :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  Lookup E a b ->
  lookup_find eq E a = Some b.
Proof.
  intros eq_correct.
  destruct E.
  + my_auto.
  + inversion 1; simpl; set (eq_correct a a); boolSpec_destruct; my_auto.
    set (eq_correct x a); boolSpec_simpl; my_auto.
Defined.

Instance identifier_DecEq : DecidableEq identifier.
Proof. dec_eq. Defined.
Definition id_eq x y := bool_of_decision (identifier_DecEq x y).
Definition id_eq_correct x y : boolSpec (id_eq x y) (x = y) := Decision_boolSpec (identifier_DecEq x y).
Definition lookup_id {B} E id : option B := lookup_find id_eq E id.
Lemma lookup_id_correct {B} E id :
  match lookup_id E id with
  | Some b => Lookup E id b
  | None   => forall b : B, neg (Lookup E id b)
  end.
Proof.
  unfold_goal.
  set (lookup_find_correct E id id_eq_correct) as H.
  case_eq (lookup_find id_eq E id).
  + intros ? Heq.
    rewrite Heq in H.
    assumption.
  + intros Heq.
    rewrite Heq in H.
    assumption.
Qed.

Definition lookup_id_unique {B} {E} {id} {b:B} : Lookup E id b -> lookup_id E id = Some b :=
  lookup_find_unique E id b id_eq_correct.

Definition add {A:Type} (E : list (identifier * A)) (v : identifier) (a : A) :=
  (v, a) :: E.

Inductive isPromotion (P : impl) : type -> type -> Prop :=
 | IsPromotion :
     forall it1 it2,
       isIntegerPromotion P it1 it2 ->
       isPromotion P (Basic (Integer it1)) (Basic (Integer it2)).

Definition isPromotion_fun P t1 t2 : bool :=
  match t1, t2 with
  | Basic (Integer it1), Basic (Integer it2) => isIntegerPromotion_fun P it1 it2
  | _                  , _                   => false
  end.

Lemma isPromotion_fun_correct P t1 t2 : boolSpec (isPromotion_fun P t1 t2) (isPromotion P t1 t2).
Proof.
  do 2 unfold_goal.
  my_auto; intros Heq; [
    set (boolSpec_elim1 (isIntegerPromotion_fun_correct P _ _) Heq)
  | set (boolSpec_elim2 (isIntegerPromotion_fun_correct P _ _) Heq)]; my_auto.
Qed.

Definition isPromotion_find P t : option type :=
  match t with
  | Basic (Integer it) => Some (Basic (Integer (isIntegerPromotion_find P it)))
  | _                  => None
  end.

Lemma isPromotion_find_correct P t1 :
  match isPromotion_find P t1 with
  | Some t2 => isPromotion P t1 t2
  | None    => forall t2, neg (isPromotion P t1 t2)
  end.
Proof.
  unfold_goal; repeat var_destruct.
  constructor; apply isIntegerPromotion_find_correct.
Qed.

Lemma isPromotion_find_unique P t1 t2 : isPromotion P t1 t2 -> Some t2 = isPromotion_find P t1.
Proof.
  unfold_goal.
  inversion 1.
  repeat apply f_equal.
  apply isIntegerPromotion_find_unique.
  assumption.
Qed.

(* defns JeType *)
Inductive eType : impl -> gamma -> sigma -> expression -> typeCategory -> Prop :=    (* defn eType *)
 | ETypeVariable : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (qs:qualifiers) (ty:type),
     Lookup G id (qs, ty)  ->
     eType P G S (Var id) (LvalueType qs ty)
 | ETypeFunction : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (ty:type) (s:statement),
     Lookup S id (ty, s)  ->
     eType P G S (Var id) (ExpressionType ty)
 | ETypeConstantInt : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Signed Int) ->
     eType P G S (Constant (ConstantInteger  ( n , None) )) (ExpressionType (Basic (Integer (Signed Int))))
 | ETypeConstantLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Signed Int)  ->
     inIntegerTypeRange P n (Signed Long) ->
     eType P G S (Constant (ConstantInteger  ( n , None) )) (ExpressionType (Basic (Integer (Signed Long))))
 | ETypeConstantLongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Signed Long)  ->
     inIntegerTypeRange P n (Signed LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , None) )) (ExpressionType (Basic (Integer (Signed Long))))
 | ETypeConstantUInt : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Unsigned Int) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  UnsignedInt ) )) (ExpressionType (Basic (Integer (Unsigned Int))))
 | ETypeConstantULong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Int)  ->
     inIntegerTypeRange P n (Unsigned Long) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  UnsignedInt ) )) (ExpressionType (Basic (Integer (Unsigned Long))))
 | ETypeConstantULongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Long)  ->
     inIntegerTypeRange P n (Unsigned LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  UnsignedInt ) )) (ExpressionType (Basic (Integer (Unsigned LongLong))))
 | ETypeConstantLLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Signed Long) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Signed Long))))
 | ETypeConstantLLongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Signed Long)  ->
     inIntegerTypeRange P n (Signed LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Signed LongLong))))
 | ETypeConstantULLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Unsigned Long) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Unsigned Long))))
 | ETypeConstantULLongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Long)  ->
     inIntegerTypeRange P n (Unsigned LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Unsigned LongLong))))
 | ETypeConstantLL : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Signed LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLongLong ) )) (ExpressionType (Basic (Integer (Signed LongLong))))
 | ETypeConstantULL : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Unsigned LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLongLong ) )) (ExpressionType (Basic (Integer (Unsigned LongLong))))
 | ETypeCall : forall (ls:arguments) (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     expressionType P G S e (Pointer  nil  (Function ty ps)) ->
     eType_arguments P G S ls ps ->
     eType P G S (Call e ls) (ExpressionType ty)
 | ETypeAddressFunction : forall (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     eType P G S e (ExpressionType (Function ty ps)) ->
     eType P G S (Unary Address e) (ExpressionType (Pointer  nil  (Function ty ps)))
 | ETypeAddressLvalue : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     eType P G S e (LvalueType qs ty) ->
     eType P G S (Unary Address e) (ExpressionType (Pointer qs ty))
 | ETypeIndirectionObject : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     expressionType P G S e (Pointer qs ty) ->
     isComplete ty ->
     isObject ty ->
     eType P G S (Unary Indirection e) (LvalueType qs ty)
 | ETypeIndirectionFunction : forall (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     expressionType P G S e (Pointer  nil  (Function ty ps)) ->
     eType P G S (Unary Indirection e) (ExpressionType (Pointer  nil  (Function ty ps)))
 | ETypePostfixIncrementPointer : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     lvalueType P G S e qs' ty' ty ->
     isPointer ty' ->
     isModifiable qs' ty' ->
     isComplete ty' ->
     eType P G S (Unary PostfixIncr e) (ExpressionType ty)
 | ETypePostfixIncrementReal : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     lvalueType P G S e qs' ty' ty ->
     isReal ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixIncr e) (ExpressionType ty)
 | ETypePostfixDecrementPointer : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     lvalueType P G S e qs' ty' ty ->
     isPointer ty' ->
     isModifiable qs' ty' ->
     isComplete ty' ->
     eType P G S (Unary PostfixDecr e) (ExpressionType ty)
 | ETypePostfixDecrementReal : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     lvalueType P G S e qs' ty' ty ->
     isReal ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixDecr e) (ExpressionType ty)
 | ETypePlus : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isArithmetic ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Plus e) (ExpressionType ty)
 | ETypeMinus : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isArithmetic ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Minus e) (ExpressionType ty)
 | ETypeBnot : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isInteger ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Bnot e) (ExpressionType ty)
 | ETypeSizeOf : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty ty':type),
      ~ (  isFunction ty  )  ->
      ~ (  isIncomplete ty  )  ->
      Implementation.size_t  P  =  ty'  ->
     eType P G S (SizeOf qs ty) (ExpressionType ty')
 | ETypeAlignOf : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty ty':type),
      ~ (  isFunction ty  )  ->
      ~ (  isIncomplete ty  )  ->
      Implementation.size_t  P  =  ty'  ->
     eType P G S (AlignOf qs ty) (ExpressionType ty')
 | ETypeCastScalar : forall (P:impl) (G:gamma) (S:sigma) (qualifiers:qualifiers) (ty:type) (e:expression) (ty':type),
     expressionType P G S e ty' ->
     isScalar ty' ->
     isScalar ty ->
     eType P G S (Cast qualifiers ty e) (ExpressionType ty)
 | ETypeCastVoid : forall (P:impl) (G:gamma) (S:sigma) (qualifiers:qualifiers) (e:expression) (ty:type),
     expressionType P G S e ty ->
     eType P G S (Cast qualifiers Void e) (ExpressionType Void)
 | ETypeMult : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Mul) e2) (ExpressionType ty)
 | ETypeDiv : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Div) e2) (ExpressionType ty)
 | ETypeMod : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isInteger ty1 ->
     isInteger ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Mod) e2) (ExpressionType ty)
 | ETypeAddArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType ty)
 | ETypeAddPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isComplete ty1 ->
     isInteger ty2 ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAddPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs2:qualifiers) (ty2 ty1:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isInteger ty1 ->
     isComplete ty2 ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType (Pointer qs2 ty2))
 | ETypeSubArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType ty)
 | ETypeSubPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isComplete ty1 ->
     isInteger ty2 ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeSubPointerDiff : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty:type) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isComplete ty1 ->
     isComplete ty2 ->
     isCompatible ty1 ty2 ->
      Implementation.ptrdiff_t  P  =  ty  ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType ty)
 | ETypeShiftL : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1' ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isInteger ty1 ->
     isInteger ty2 ->
     isPromotion P ty1 ty1' ->
     eType P G S (Binary e1 (Arithmetic Shl) e2) (ExpressionType ty1')
 | ETypeShiftR : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1' ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isInteger ty1 ->
     isInteger ty2 ->
     isPromotion P ty1 ty1' ->
     eType P G S (Binary e1 (Arithmetic Shr) e2) (ExpressionType ty1')
 | ETypeLtReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Lt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLtPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Lt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGtReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Gt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGtPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Gt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLeReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Le e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Le e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGeReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Ge e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Ge e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1 qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 Void) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 Void) ->
     isObject ty1 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqNull1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isNullPointerConstant e1 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqNull2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1 qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 Void) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 Void) ->
     isObject ty1 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeNull1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isNullPointerConstant e1 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeNull2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeBand : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isInteger ty1 ->
     isInteger ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Band) e2) (ExpressionType ty)
 | ETypeXor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isInteger ty1 ->
     isInteger ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Xor) e2) (ExpressionType ty)
 | ETypeBor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isInteger ty1 ->
     isInteger ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Bor) e2) (ExpressionType ty)
 | ETypeAnd : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isScalar ty1 ->
     isScalar ty2 ->
     eType P G S (Binary e1 And e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeOr : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isScalar ty1 ->
     isScalar ty2 ->
     eType P G S (Binary e1 Or e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeConditionalArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty ty1 ty2 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isArithmetic ty2 ->
     isArithmetic ty3 ->
     isUsualArithmetic P ty2 ty3 ty ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty)
 | ETypeConditionalVoid : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty1:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 Void ->
     expressionType P G S e3 Void ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType Void)
 | ETypeConditionalPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3:qualifiers) (ty ty1 ty2 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isCompatible ty2 ty3 ->
     isComposite ty2 ty3 ty ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer   (List.app  qs2   qs3 )   ty))
 | ETypeConditionalNullPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty3 ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isPointer ty3 ->
      ~ (  isCompatible ty2 ty3  )  ->
     isNullPointerConstant e2 ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty3)
 | ETypeConditionalNullPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty2 ty1 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isPointer ty2 ->
      ~ (  isCompatible ty2 ty3  )  ->
     isNullPointerConstant e2 ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty2)
 | ETypeConditionalPointerVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3:qualifiers) (ty2 ty1 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isVoid ty2 ->
     isObject ty3 ->
      ~ (  isCompatible ty2 ty3  )  ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer   (List.app  qs2   qs3 )   ty2))
 | ETypeConditionalPointerVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3:qualifiers) (ty3 ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isObject ty2 ->
     isVoid ty3 ->
      ~ (  isCompatible ty2 ty3  )  ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer   (List.app  qs2   qs3 )   ty3))
 | ETypeAssignArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty ->
     isArithmetic ty2 ->
     eType P G S (Assign e1 e2) (ExpressionType ty1)
 | ETypeAssignPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs:qualifiers) (ty:type) (qs2:qualifiers) (ty2:type),
     lvalueType P G S e1 qs ty (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isModifiable qs ty ->
     isPointer ty ->
     isCompatible ty1 ty2 ->
     sub qs2 qs1 ->
     eType P G S (Assign e1 e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAssignVoidPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs:qualifiers) (ty:type) (qs2:qualifiers) (ty2:type),
     lvalueType P G S e1 qs ty (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isModifiable qs ty ->
     isPointer ty ->
     isVoid ty1 ->
     isObject ty2 ->
      sub  qs2   qs1  ->
     eType P G S (Assign e1 e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAssignVoidPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs:qualifiers) (ty:type) (qs2:qualifiers) (ty2 ty1':type),
     lvalueType P G S e1 qs ty (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isModifiable qs ty ->
     isPointer ty1' ->
     isObject ty1 ->
     isVoid ty2 ->
      sub  qs2   qs1  ->
     eType P G S (Assign e1 e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAssignNullPointerConstant : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isPointer ty ->
     isNullPointerConstant e2 ->
     eType P G S (Assign e1 e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAssignBool : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isBool ty ->
     isPointer ty2 ->
     eType P G S (Assign e1 e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeCompoundAssignPlusArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2 ty1':type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty1' ->
     isArithmetic ty2 ->
     eType P G S (CompoundAssign e1 Add e2) (ExpressionType ty1)
 | ETypeCompoundAssignPlusPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs' qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs' (Pointer qs ty) ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs  (Pointer qs ty)  ->
     isComplete ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Add e2) (ExpressionType ty1)
 | ETypeCompoundAssignMinusArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty ->
     isArithmetic ty2 ->
     eType P G S (CompoundAssign e1 Sub e2) (ExpressionType ty1)
 | ETypeCompoundAssignMinusPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs' qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs' (Pointer qs ty) ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs'  (Pointer qs ty)  ->
     isComplete ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Add e2) (ExpressionType ty1)
 | ETypeCompoundAssignMult : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty ->
     isArithmetic ty2 ->
     eType P G S (CompoundAssign e1 Mul e2) (ExpressionType ty1)
 | ETypeCompoundAssignDiv : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty ->
     isArithmetic ty2 ->
     eType P G S (CompoundAssign e1 Div e2) (ExpressionType ty1)
 | ETypeCompoundAssignMod : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2 ty1':type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isInteger ty1' ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Mod e2) (ExpressionType ty1)
 | ETypeCompoundAssignShiftL : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isInteger ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Shl e2) (ExpressionType ty1)
 | ETypeCompoundAssignShiftR : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isInteger ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Shr e2) (ExpressionType ty1)
 | ETypeCompoundAssignBand : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isInteger ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Band e2) (ExpressionType ty1)
 | ETypeCompoundAssignBor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isInteger ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Bor e2) (ExpressionType ty1)
 | ETypeCompoundAssignXor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     lvalueType P G S e1 qs ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isInteger ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 Xor e2) (ExpressionType ty1)
 | ETypeComma : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty2 ty1:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     eType P G S (Binary e1 Comma e2) (ExpressionType ty2)
with expressionType : impl -> gamma -> sigma -> expression -> type -> Prop :=    (* defn expressionType *)
 | ExpressionTypeExpressionT : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     eType P G S e (ExpressionType ty) ->
     expressionType P G S e ty
 | ExpressionTypeLvalueT : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs:qualifiers),
     eType P G S e (LvalueType qs ty) ->
     isLvalueConvertible ty ->
     expressionType P G S e ty
(*
with lvalueType : impl -> gamma -> sigma -> expression -> qualifiers -> type -> Prop :=    (* defn lvalueType *)
 | LvalueTypeDef : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     eType P G S e (LvalueType qs ty) ->
     lvalueType P G S e qs   (pointerConvert ty )  
*)
with lvalueType : impl -> gamma -> sigma -> expression -> qualifiers -> type -> type -> Prop :=    (* defn lvalueType *)
 | LvalueTypeDef : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs':qualifiers) (ty' ty:type),
     eType P G S e (LvalueType qs' ty) ->
     pointerConvert ty = ty' ->
     isLvalueConvertible ty ->
     lvalueType P G S e qs' ty' ty
with typeable : impl -> gamma -> sigma -> expression -> Prop :=    (* defn typeable *)
 | TypeableDef : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (typeCategory:typeCategory),
     eType P G S e typeCategory ->
     typeable P G S e
with eType_arguments : impl -> gamma -> sigma -> arguments -> params -> Prop :=    (* defn isAssignable *)
 | ETypeNil P G S : eType_arguments P G S ArgumentsNil ParamsNil
 | ETypeCons P G S ls ps : forall e qs ty (id:identifier),
     ~ fv id e ->
     typeable P (add G id (nil, ty)) S (Assign (Var id) e) ->
     eType_arguments P G S ls ps ->
     eType_arguments P G S (ArgumentsCons e ls) (ParamsCons qs ty ps).
(** definitions *)

Definition Disjoint {A B1 B2} E1 E2 : Type :=
  forall (a : A) (b1 : B1) (b2 : B2), Lookup E1 a b1 -> Lookup E2 a b2 -> False.

Fixpoint eType_strengthening P (G:gamma) (S:sigma) e id qs ty {struct e} :
  neg (fv id e) ->
  forall tc,
  eType P (add G id (qs, ty)) S e tc ->
  eType P G S e tc
with eType_arguments_strengthening P (G:gamma) (S:sigma) l p id qs ty {struct l} :
  neg (fv_arguments id l) ->
  eType_arguments P (add G id (qs, ty)) S l p ->
  eType_arguments P G S l p
with eType_weakening P (G:gamma) (S:sigma) e id qs ty {struct e} :
  neg (fv id e) ->
  forall tc,
  eType P G S e tc ->
  eType P (add G id (qs, ty)) S e tc
with eType_arguments_weakening P (G:gamma) (S:sigma) l p id qs ty {struct l} :
  neg (fv_arguments id l) ->
  eType_arguments P G S l p ->
  eType_arguments P (add G id (qs, ty)) S l p.
Proof.
  + destruct e; intros Hfree; inversion 1; subst;
    match goal with
    | [ H1 : expressionType P (add G id _) S _ _
      , H2 : expressionType P (add G id _) S _ _
      , H3 : expressionType P (add G id _) S _ _       |- _] => inversion H1; inversion H2; inversion H3; subst
    | [ H1 : expressionType P (add G id _) S _ _
      , H2 : expressionType P (add G id _) S _ _       |- _] => inversion H1; inversion H2; subst
    | [ H1 : expressionType P (add G id _) S _ _
      , H2 : lvalueType     P (add G id _) S _ _ _ _   |- _] => inversion H1; inversion H2; subst
    | [ H  : expressionType P (add G id _) S _ _       |- _] => inversion H; subst
    | [ H  : lvalueType     P (add G id _) S _ _ _ _   |- _] => inversion H; subst
    | [ H  : eType          P (add G id _) S (Var _) _ |- _] => inversion H; subst
    | _ => idtac
    end;
    repeat match goal with
    | [H: eType _ (add G id _) _ ?e _|- _] =>
        notHyp (neg (fv id e));
        let Hfree_sub := fresh in
        assert (neg (fv id e)) as Hfree_sub by (intros ?; apply Hfree; econstructor (solve [eauto]));
        set (eType_strengthening _ G _ _ id _ _ Hfree_sub _ H)
    | [H : eType_arguments P (add G id _) _ ?l ?p |- _] =>
        notHyp(neg (fv_arguments id l));
        let Hfree_sub := fresh in
        assert (neg (fv_arguments id l)) as Hfree_sub by (intros ?; apply Hfree; econstructor (solve [eauto]));
        set (eType_arguments_strengthening _ G _ l p id _ _ Hfree_sub H)
    | [H : Lookup (add G id _) ?v ?p |- eType _ ?G _ (Var ?v) _] =>
        notHyp (Lookup G v p);
        inversion H; subst; [exfalso; apply Hfree; now constructor|]    
    end;
    econstructor (
      solve [ eassumption
            | econstructor 1; finish eassumption
            | econstructor 2; finish eassumption ]
    ).
  + destruct p; intros Hfree; inversion 1; subst.
    - constructor.
    - inversion H8; subst.
      inversion H0; subst.
      inversion H4; subst.
      assert (neg (fv id e)) as Hfree_sub by (intros ?; apply Hfree; econstructor (solve [eauto])).
      set (eType_strengthening _ _ _ e id0 _ _ H7 _ H1) as Hminus1.
      set (eType_strengthening _ _ _ e id _ _ Hfree_sub _ Hminus1) as Hbase.
      set (eType_weakening _ _ _ e id0 nil ty0 H7 _ Hbase) as Hplus1.
      apply ExpressionTypeExpressionT in Hplus1.
      apply TypeableDef in Hplus1.
      assert (neg (fv_arguments id ls)) as Hfree_sub2 by (intros ?; apply Hfree; econstructor (solve [eauto])).
      set (eType_arguments_strengthening _ _ _ ls p id _ _ Hfree_sub2 H9) as Hv.
      econstructor.
      exact H7.
      econstructor.
      econstructor.
      econstructor (
        solve [ eassumption
              | econstructor 1; finish eassumption
              | econstructor 2; finish eassumption ]
        ).
      econstructor.
      eassumption.
      econstructor; eassumption.
      
(*
Definition eType_function_id {P} {G} {S} {e} {t} {ps} :
  (forall id ty s, Lookup S id (ty, s) -> isFunction ty) ->
  eType P G S e (ExpressionType (Function t ps)) ->
  exists id, e = Var id.
Proof.
*)

(*  
Definition eType_expression_lvalue_distinct {P} {G} {S} {e} {ty1} {qs2} {ty2}:
  Disjoint G S ->
  eType P G S e (ExpressionType     ty1) ->
  eType P G S e (LvalueType     qs2 ty2) ->
  False.
Proof.
*)

(*
Fixpoint eType_unique_lvalue {P} {G : gamma} {S : sigma} e qs1 ty1 qs2 ty2
  (Hdisjoint : Disjoint G S)
  (He1 : eType P G S e (LvalueType qs1 ty1))
  (He2 : eType P G S e (LvalueType qs2 ty2)) {struct e} : ty1 = ty2.
Proof.
  destruct e;
  simple inversion He1; try congruence;
  simple inversion He2; try congruence.
  solve
    [ dependent destruction He1; subst; apply (eType_unique P G S _ _ _ Hdisjoint He1 He2)
    | eapply eType_expression_lvalue_distinct; eassumption].
Qed.
*)

(* Coq's insanely stupid termination checker won't allow me to write a
mutually recursive function so I am resorting to open recursion + tying the
knot manually. *)
Definition option_bind {A B} : option A -> (A -> option B) -> option B :=
  fun o f =>
    match o with
    | Some a => f a
    | None   => None
    end.

Definition expressionType_find_aux o : option type :=
  option_bind o (fun tc =>
    match tc with
    | ExpressionType   ty => Some ty
    | LvalueType     _ ty => if isLvalueConvertable_fun ty
                               then Some ty
                               else None
    end).

Ltac pull_out T c :=
  ( let H   := fresh in
    let t   := fresh in
    let Heq := fresh in
    assert {t : T & c = t} as H by (exists c; reflexivity);
    destruct H as [t Heq];
    replace c with t;
    revert Heq
  ) || fail 1.

Ltac context_destruct_inner c :=
  match c with
  | _                        =>
      is_var c; destruct c; try finish fail
  | match ?c with _ => _ end =>
      context_destruct_inner c
  | _ =>
      match type of c with
      | bool      => pull_out bool c
      | option ?A => pull_out (option A) c
      end
  end.

Ltac context_destruct :=
  match goal with
  | [|- match ?c with _ => _ end] =>
      context_destruct_inner c
  | [|- ((match ?c with _ => _ end) = _) -> _] =>
      context_destruct_inner c
  | [|- ((if ?c then _ else _) = _) -> _] =>
      context_destruct_inner c
  end.

Ltac case_fun G :=
  match goal with
  | [|- _ = ?o -> _] =>
      let Heq := fresh in
      is_var o; destruct o;
      intros Heq;
      generalize G;
      rewrite Heq;
      intros ?
  end.

Ltac case_fun_hyp G :=
  match goal with
  | [|- _ = ?o -> _] =>
      let Heq := fresh in
      is_var o;
      destruct o;
      intros Heq;
      revert G;
      rewrite Heq;
      intros G
  end.

Lemma expressionType_find_aux_correct_pos {P} {G} {S} {e} {tc} {ty} :
  eType P G S e tc ->
  expressionType_find_aux (Some tc) = Some ty ->
  expressionType P G S e ty.
Proof.
  intros ?.
  do 2 unfold_goal.
  destruct tc;
  repeat match goal with
  | [|- context[isLvalueConvertable_fun ?ty]] =>
      context_destruct;
      case_fun (isLvalueConvertable_correct ty)
  | [|- Some _ = Some _ -> _] =>
      injection 1; intros ?; subst
  end;
  my_auto.
Qed.  

Lemma expressionType_find_aux_correct_neg {P} {G} {S} {e} {tc} :
  Disjoint G S ->
  eType P G S e tc ->
  (forall tc', eType P G S e tc' -> tc' = tc) ->
  expressionType_find_aux (Some tc) = None ->
  forall ty, neg (expressionType P G S e ty).
Proof.
  intros Hdisjoint H Hunique.
  do 2 unfold_goal.
  destruct tc;
  repeat match goal with
  | [|- context[isLvalueConvertable_fun ?ty]] =>
      context_destruct;
      case_fun (isLvalueConvertable_correct ty)
  | [|- Some _ = Some _ -> _] =>
      injection 1; intros ?; subst
  end; my_auto.
  inversion 1; subst.
  + inversion H; inversion H2; subst;
    match goal with
    | _ => discriminate
    | [Heq : Var _ = Var _ |- _] => injection Heq; intros ?; subst; eapply Hdisjoint; eassumption
    | [Heq : Unary Indirection _ = Unary Indirection ?e2, H : eType P G S (Unary Indirection ?e2) _ |-_] => discriminate (Hunique _ H)
    end.
    (* eapply (eType_expression_lvalue_distinct Hdisjoint); eassumption. *)
  + match goal with
    | [ Hunique : forall _ : typeCategory, eType P G S ?e _ -> _ = ?tc
      , H       : eType P G S ?e ?tc
      , H'      : eType P G S ?e ?tc' |- _ ] =>
        injection (Hunique tc' H')
    end.
    congruence.
Qed.

Lemma expressionType_unique_lvalue_inj {P} {G} {S} {e} {qs} {ty} :
  expressionType P G S e ty ->
  (forall tc', eType P G S e tc' -> tc' = (LvalueType qs ty)) ->
  forall ty', expressionType P G S e ty' -> ty' = ty.
Proof.
  intros H Hunique.
  inversion_clear 1;
  match goal with
  | [H' : eType P G S e ?tc |- _] =>
      set (Hunique tc H'); congruence
  end.
Qed.

Lemma expressionType_unique_expression_inj {P} {G} {S} {e} {ty} :
  expressionType P G S e ty ->
  (forall tc', eType P G S e tc' -> tc' = (ExpressionType ty)) ->
  forall ty', expressionType P G S e ty' -> ty' = ty.
Proof.
  intros H Hunique.
  inversion_clear 1;
  match goal with
  | [H' : eType P G S e ?tc |- _] =>
      set (Hunique tc H'); congruence
  end.
Qed.

Hint Extern 1 (ExpressionType _ = ExpressionType _) =>
  apply f_equal;
    solve [ eapply expressionType_unique_lvalue_inj    ; eassumption
          | eapply expressionType_unique_expression_inj; eassumption].

Hint Extern 1 (LvalueType _ = LvalueType _) =>
  apply f_equal;
    solve [ eapply expressionType_unique_lvalue_inj    ; eassumption
          | eapply expressionType_unique_expression_inj; eassumption].

Lemma expressionType_find_aux_eq_lvalue {qs1} {ty1 ty2} :
  expressionType_find_aux (Some (LvalueType qs1 ty1)) = Some ty2 ->
  ty1 = ty2.
Proof. simpl; destruct (isLvalueConvertable_fun ty1); congruence. Qed.

Lemma expressionType_find_aux_eq_lvalue_lift {P} {G} {S} {e} {qs1} {ty1 ty2}:
  eType P G S e (LvalueType qs1 ty1) ->
  expressionType_find_aux (Some (LvalueType qs1 ty1)) = Some ty2 ->
  expressionType P G S e ty1.
Proof.
  intros ? Heq.
  rewrite <- (expressionType_find_aux_eq_lvalue Heq) in Heq.
  revert Heq; simpl; context_destruct.
  case_fun (isLvalueConvertable_correct ty1); my_auto.
Qed.

Lemma expressionType_neg P G S e :
  (forall tc, neg (eType          P G S e tc)) ->
  forall  ty, neg (expressionType P G S e ty).
Proof. inversion 2; firstorder. Qed.

Fixpoint eType_find (P:impl) (G:gamma) (S:sigma) e {struct e} : option typeCategory :=
  match e with
  | Var id =>
      match lookup_id G id, lookup_id S id with
      | Some (qs, ty), None         => Some (LvalueType     qs ty)
      | None         , Some (ty, _) => Some (ExpressionType    ty)
      | _            , _            => None
      end
  | Binary e1 Comma e2 => 
     match expressionType_find_aux (eType_find P G S e1), expressionType_find_aux (eType_find P G S e2) with
     | Some _, Some ty2 => Some (ExpressionType ty2)
     | _     , _        => None
     end
  | Unary Address e =>
      match eType_find P G S e with
      | Some (LvalueType qs ty) => Some (ExpressionType (Pointer qs ty))
      | _                       => None
      end
  | _ => None 
  end
with eType_arguments_find (P:impl) (G:gamma) (S:sigma) (ls:arguments) (ps:args) {struct ls} : bool :=
  match ls, ps with
  | Arguments_nil      , Argument_nil         => true
  | Arguments_cons e ls, Argument_cons _ t ps =>
      match eType_find P (add G 0 (nil, t)) S e with
      | Some _ => eType_arguments_find P G S ls ps
      | None   => false
      end
  | _                  ,  _                   => false
  end.

Fixpoint eType_find_correct P G S e {struct e}:
  Disjoint G S ->
  match eType_find P G S e with
  | Some tc => eType P G S e tc * (forall tc', eType P G S e tc' -> tc' = tc)
  | None    => forall tc, neg (eType P G S e tc)
  end.
Proof.
  intros Hdisjoint.
  unfold eType_find;
  destruct e;
  fold eType_find.
  repeat
  match goal with
  | [|- lookup_id ?E ?id = ?o -> _] =>
      case_fun (lookup_id_correct E id)
  | [|- eType_find P G S ?e = ?o -> _] =>
      case_fun (eType_find_correct P G S e Hdisjoint);
      match goal with
      | [H : _ * _ |- _] => destruct H
      | _ => idtac
      end
  | [|- context[option_map] ] =>
      unfold option_map
  | [|- expressionType_find_aux (eType_find P G S ?e) = _ -> _] =>
      pull_out (option typeCategory) (eType_find P G S e)
  | [|- expressionType_find_aux (Some ?tc) = _ -> _] =>
      is_var tc; destruct tc
  | [H : eType P G S _ (ExpressionType ?t) |- expressionType_find_aux (Some (ExpressionType ?t)) = ?o -> _] =>
      let Heq := fresh in
      is_var o; intros Heq; subst o;
      assert (expressionType_find_aux (Some (ExpressionType t)) = Some t) as Heq by reflexivity; rewrite Heq;
      set (expressionType_find_aux_correct_pos H Heq)
  | [|- expressionType_find_aux None = ?o -> _] =>
      let Heq := fresh in
      is_var o; intros Heq; subst o;
      assert (expressionType_find_aux None = None) as Heq by reflexivity; rewrite Heq
  | [|- expressionType_find_aux (Some (LvalueType ?q ?t)) = ?o -> _] =>
      is_var o; destruct o
  | [H : eType P G S _ (LvalueType ?q ?t) |- expressionType_find_aux (Some (LvalueType ?q ?t)) = Some _ -> _] =>
      let Heq := fresh in
      intros Heq;
      set     (expressionType_find_aux_eq_lvalue_lift H Heq);
      rewrite (expressionType_find_aux_eq_lvalue        Heq) in *
  | [H : eType P G S _ (LvalueType ?q ?t) |- expressionType_find_aux (Some (LvalueType ?q ?t)) = None -> _] =>
      let Heq := fresh in
      intros Heq;
      inversion_clear 1;
      eapply (expressionType_find_aux_correct_neg Hdisjoint H _ Heq);
      eassumption
  | _ => context_destruct
  | [|- _ * _] => split
  | [|- eType P G S _ (ExpressionType _)] => econstructor; eassumption
  | [|- forall _, eType P G S (Binary _ Comma _) _ -> _ = _] => inversion_clear 1; now auto
  | [|- forall _, neg (eType P G S (Binary ?e1 Comma ?e2) _)] =>
      set (expressionType_neg P G S e1);
      set (expressionType_neg P G S e2);
      inversion_clear 1; now firstorder
  | [|- forall _, eType P G S (Unary Address _) _ -> _ = _] => inversion_clear 1
  | [Hunique : forall _, eType P G S _ _ -> _ = LvalueType ?qs2 ?ty2 |- ExpressionType (Pointer ?qs1 ?ty1) = ExpressionType (Pointer ?qs2 ?ty2)] =>
      einjection (Hunique (LvalueType qs1 ty1) _); congruence
  | [|- forall _, neg (eType P G S (Unary Address _) _)] => inversion 1
  | [Hunique : forall _, eType P G S ?e _ -> _ = ExpressionType _, H : eType P G S ?e (LvalueType _ _) |- False] => discriminate (Hunique _ H)
  | [Hfalse : forall _, neg (eType P G S ?e _), H : eType P G S ?e _ |- False] => exact (Hfalse _ H)
  end.
  Focus 5.
  subst.
  tauto.
  discriminate (e1 _ H1).
  inversion_clear 1.

  congruence.
  auto.
  apply f_equal.
  firstorder.
  constructor; assumption.

  match goal with
  | [|- eType _ _ _ (Var _) (LvalueType _ _) ] =>
      now my_auto
  | [ L1 : Lookup ?G ?id _
    , L2 : Lookup ?S ?id _ |- forall _, neg (eType _ ?G ?S (Var ?id) _)] =>
      destruct (Hdisjoint id _ _ L1 L2)
  | [_ : forall _, neg (Lookup ?G ?id _) 
    ,_ : forall _, neg (Lookup ?S ?id _) |- forall _, neg (eType _ ?G ?S (Var ?id) _)] =>
      inversion 1; now firstorder
  end.
Qed.

(* defns JsType *)
Inductive sType : impl -> gamma -> sigma -> statement -> Prop :=    (* defn sType *)
 | STypeLabel : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (s:statement),
     sType P G S s ->
     sType P G S (Label id s)
 | STypeCase : forall (P:impl) (G:gamma) (S:sigma) (integerConstant:integerConstant) (s:statement),
     sType P G S s ->
     typeable P G S (Constant (ConstantInteger integerConstant)) ->
     sType P G S (Case integerConstant s)
 | STypeDefault : forall (P:impl) (G:gamma) (S:sigma) (s:statement),
     sType P G S s ->
     sType P G S (Default s)
 | STypeBlock : forall (s_list:list statement) (P:impl) (G:gamma) (S:sigma) (G':gamma),
     (forall s_, List.In (s_) (List.map (fun (s_ : statement) => (s_)) s_list) -> (sType P  ( G  @  G' )%gamma  S s_)) ->
     sType P G S (Block G' s_list)
 | STypeSkip : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Skip
 | STypeExpression : forall (P:impl) (G:gamma) (S:sigma) (e:expression),
     typeable P G S e ->
     sType P G S (Expression e)
 | STypeIf : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s1 s2:statement) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s1 ->
     sType P G S s2 ->
     sType P G S (If e s1 s2)
 | STypeSwitch : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s:statement) (ty:type),
     expressionType P G S e ty ->
     isInteger ty ->
     sType P G S s ->
     sType P G S (Switch e s)
 | STypeWhile : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s:statement) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s ->
     sType P G S (While e s)
 | STypeDo : forall (P:impl) (G:gamma) (S:sigma) (s:statement) (e:expression) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s ->
     sType P G S (Do s e)
 | STypeGoto : forall (P:impl) (G:gamma) (S:sigma) (id:identifier),
     sType P G S (Goto id)
 | STypeContinue : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Continue
 | STypeBreak : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Break
 | STypeReturnVoid : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S ReturnVoid
 | STypeReturn : forall (P:impl) (G:gamma) (S:sigma) (e:expression),
     typeable P G S e ->
     sType P G S (Return e)
 | STypeDeclaration : forall (definition_list:list definition) (P:impl) (G:gamma) (S:sigma),
     (forall definition_, List.In (definition_) (List.map (fun (definition_ : definition) => (definition_)) definition_list) -> (dType P G S definition_)) ->
     sType P G S (Declaration definition_list)
with dType : impl -> gamma -> sigma -> definition -> Prop :=    (* defn dType *)
 | DType : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (e:expression) (qs:qualifiers) (ty:type),
      ( G  [  id  ] = Some ( qs ,  ty ))%gamma  ->
     typeable P   ( G  [  id  <- (  nil  ,  ty ) ])%gamma   S (Assign (Var id) e) ->
     dType P G S  ( id , e ) .
(** definitions *)

(* defns JsigmaType *)
Inductive sigmaType : sigma -> sigma -> Prop :=    (* defn sigmaType *)
 | SigmaTypeEmpty : forall (S:sigma),
     sigmaType S  [] 
 | SigmaTypeCtx : forall (S S':sigma) (id:identifier) (ty:type) (s:statement) (P:impl),
     sType P  gamma_empty  S s ->
     sigmaType S S' ->
     sigmaType S  ( S'  [  id  <- ( ty ,  s ) ])%sigma .
(** definitions *)

(* defns JpType *)
Inductive pType : impl -> program -> Prop :=    (* defn pType *)
 | PType : forall (P:impl) (id:identifier) (S:sigma) (s:statement),
     sigmaType S S ->
      ( S  [  id  ] = Some (  (Function (Basic (Integer (Signed Int))) nil)  ,  s ))%sigma  ->
     pType P  ( id ,  S ) .


