(* generated by Ott 0.21.2 from: AilTyping_.ott *)

Require Import Bool.
Require Import List.
Require Import Arith.
Require Export ZArith.

Require Import Common.
Require Import AilTypes.
Require Import AilTypesAux.
Require Import AilTypesAux_fun.
Require Import AilTypesAux_proof.
Require Import AilSyntax.
Require Import AilSyntaxAux.
Require Import AilSyntaxAux_fun.
Require Import AilSyntaxAux_proof.
Require Import Implementation.

(** definitions *)

Inductive Lookup {A B : Type} : list (A * B) -> A -> B -> Type :=
  | Lookup_hd     a b E :                           Lookup (cons (a,b) E) a b
  | Lookup_tl x y a b E : x <> a -> Lookup E a b -> Lookup (cons (x,y) E) a b.

Fixpoint Lookup_unique {A B : Type} E (a : A) (b1 b2 : B) (L1 : Lookup E a b1) (L2 : Lookup E a b2) {struct E} : b1 = b2.
Proof.
  destruct E; simple inversion L1; simple inversion L2; try congruence; intros.
  + match goal with
    | [L1 : Lookup ?E1 _ _, L2 : Lookup ?E2 _ _ |- _] =>
        is_var E1; is_var E2;
        assert (E1 = E) by congruence;
        assert (E2 = E) by congruence
    end.
    eapply (Lookup_unique A B E a b1 b2); subst; eassumption.
Qed.

Fixpoint lookup_find {A B} (eq : A -> A -> bool) (E : list (A * B)) (a : A) : option B :=
  match E with
  | nil          => None
  | cons (x,b) E => if eq x a then Some b
                              else lookup_find eq E a
  end.

Fixpoint lookup_find_correct {A B} {eq : A -> A -> bool} (E : list (A * B)) (a : A) {struct E} :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  match lookup_find eq E a with
  | Some b => Lookup E a b
  | None   => forall b, neg (Lookup E a b)
  end.
Proof.
  intros eq_correct.
  unfold_goal.
  destruct E; simpl.
  + intros ?; inversion 1.
  + destruct p as [x b]; simpl.
    set (eq_correct x a).
    case_eq (eq x a); boolSpec_simpl; simpl.
    - my_auto.
    - fold (lookup_find eq E a).
      set (lookup_find_correct A B eq E a eq_correct).
      case_eq (lookup_find eq E a).
      * intros ? Heq.
        rewrite Heq in *; my_auto.
      * intros Heq.
        rewrite Heq in *.
        intros ?; inversion 1; firstorder.
Defined.

Fixpoint lookup_find_unique {A B} {eq : A -> A -> bool} (E : list (A * B)) (a : A) (b : B) {struct E} :
  (forall x y, boolSpec (eq x y) (x = y)) ->
  Lookup E a b ->
  lookup_find eq E a = Some b.
Proof.
  intros eq_correct.
  destruct E.
  + my_auto.
  + inversion 1; simpl; set (eq_correct a a); boolSpec_destruct; my_auto.
    set (eq_correct x a); boolSpec_simpl; my_auto.
Defined.

Instance identifier_DecEq : DecidableEq identifier.
Proof. dec_eq. Defined.
Definition id_eq x y := bool_of_decision (identifier_DecEq x y).
Definition id_eq_correct x y : boolSpec (id_eq x y) (x = y) := Decision_boolSpec (identifier_DecEq x y).
Definition lookup_id {B} E id : option B := lookup_find id_eq E id.
Lemma lookup_id_correct {B} E id :
  match lookup_id E id with
  | Some b => Lookup E id b
  | None   => forall b : B, neg (Lookup E id b)
  end.
Proof.
  unfold_goal.
  set (lookup_find_correct E id id_eq_correct) as H.
  case_eq (lookup_find id_eq E id).
  + intros ? Heq.
    rewrite Heq in H.
    assumption.
  + intros Heq.
    rewrite Heq in H.
    assumption.
Qed.

Definition lookup_id_unique {B} {E} {id} {b:B} : Lookup E id b -> lookup_id E id = Some b :=
  lookup_find_unique E id b id_eq_correct.

Definition add {A:Type} (E : list (identifier * A)) (v : identifier) (a : A) :=
  (v, a) :: E.

Inductive isPromotion (P : impl) : type -> type -> Prop :=
 | IsPromotion :
     forall it1 it2,
       isIntegerPromotion P it1 it2 ->
       isPromotion P (Basic (Integer it1)) (Basic (Integer it2)).

Definition isPromotion_fun P t1 t2 : bool :=
  match t1, t2 with
  | Basic (Integer it1), Basic (Integer it2) => isIntegerPromotion_fun P it1 it2
  | _                  , _                   => false
  end.

Lemma isPromotion_fun_correct P t1 t2 : boolSpec (isPromotion_fun P t1 t2) (isPromotion P t1 t2).
Proof.
  do 2 unfold_goal.
  my_auto; intros Heq; [
    set (boolSpec_elim1 (isIntegerPromotion_fun_correct P _ _) Heq)
  | set (boolSpec_elim2 (isIntegerPromotion_fun_correct P _ _) Heq)]; my_auto.
Qed.

Definition isPromotion_find P t : option type :=
  match t with
  | Basic (Integer it) => Some (Basic (Integer (isIntegerPromotion_find P it)))
  | _                  => None
  end.

Lemma isPromotion_find_correct P t1 :
  match isPromotion_find P t1 with
  | Some t2 => isPromotion P t1 t2
  | None    => forall t2, neg (isPromotion P t1 t2)
  end.
Proof.
  unfold_goal; repeat var_destruct.
  constructor; apply isIntegerPromotion_find_correct.
Qed.

Lemma isPromotion_find_unique P t1 t2 : isPromotion P t1 t2 -> isPromotion_find P t1 = Some t2.
Proof.
  unfold_goal.
  inversion 1.
  repeat apply f_equal.
  apply isIntegerPromotion_find_unique.
  assumption.
Qed.

Inductive isBinaryArithmetic : type -> arithmeticOperator -> type -> Prop :=    (* defn eType *)
 | IsBinaryArithmeticMult : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Mul ty2
 | IsBinaryArithmeticDiv : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Div ty2
 | IsBinaryArithmeticMod : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Mod ty2
 | IsBinaryArithmeticAddArithmetic : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Add ty2
 | IsBinaryArithmeticSubArithmetic : forall (ty1 ty2:type),
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isBinaryArithmetic ty1 Sub ty2
 | IsBinaryArithmeticShiftL : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Shl ty2
 | IsBinaryArithmeticShiftR : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Shr ty2
 | IsBinaryArithmeticBand : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Band ty2
 | IsBinaryArithmeticXor : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Xor ty2
 | IsBinaryArithmeticBor : forall (ty1 ty2:type),
     isInteger ty1 ->
     isInteger ty2 ->
     isBinaryArithmetic ty1 Bor ty2.

Lemma isBinaryArithmetic_Arithmetic {aop} {ty1 ty2} :
  isBinaryArithmetic ty1 aop ty2 ->
  isArithmetic ty1 * isArithmetic ty2.
Proof.
  inversion 1;
  repeat match goal with
  | [H : isInteger _ |- _ ] => apply IsArithmeticInteger in H
  end; split; assumption.
Qed.

Inductive lvalueConversion : type -> type -> Prop :=
  | LvalueConversion : forall ty1 ty2,
      isLvalueConvertible ty1 ->
      pointerConvert ty1 = ty2 ->
      lvalueConversion ty1 ty2.

Definition lvalueConversion_find t : option type :=
  if isLvalueConvertible_fun t then
    Some (pointerConvert t)
  else
    None.

Definition optionSpec {A} (o : option A) (P : A -> Type) : Type :=
  match o with
  | Some a => P a
  | None   => forall a, neg (P a)
  end.

Definition optionUnique {A} (o : option A) (P : A -> Type) : Type :=
  forall a, P a -> o = Some a.

Lemma lvalueConversion_find_correct t1 : optionSpec (lvalueConversion_find t1) (lvalueConversion t1).
Proof. do 2 unfold_goal; context_destruct; case_fun (isLvalueConvertible_fun_correct t1); my_auto. Qed.

Ltac context_destruct :=
  match goal with
  | [|- match ?c with _ => _ end] =>
      context_destruct_inner c
  | [|- ((match ?c with _ => _ end) = _)] =>
      context_destruct_inner c
  | [|- ((match ?c with _ => _ end) = _) -> _] =>
      context_destruct_inner c
  | [|- (match ?c with _ => _ end) -> _] =>
      context_destruct_inner c
  end.

Lemma lvalueConversion_find_unique t1 : optionUnique (lvalueConversion_find t1) (lvalueConversion t1).
Proof. do 2 unfold_goal; inversion 1; context_destruct; case_fun (isLvalueConvertible_fun_correct t1); my_auto. Qed.

(* Lemma: it doesn't matter whether we check isPointer before or after lvalue conversion. *)
Lemma pointConvert_isPointer t : isLvalueConvertible t -> (isPointer t <-> isPointer (pointerConvert t)).
Proof.
  inversion 1 as [? Hnarray Hcomplete].
  destruct t; split;
  solve [ trivial
        | exfalso; apply Hnarray; constructor
        | inversion Hcomplete ].
Qed.

Lemma pointConvert_lvalueConversion t1 t2 : lvalueConversion t1 t2 -> (isPointer t1 <-> isPointer t2).
Proof. inversion 1; subst; apply pointConvert_isPointer; assumption. Qed.

(* Pointer conversion leaves integers untouched. *)
Lemma pointerConvert_Integer_id {t} : isInteger t -> pointerConvert t = t.
Proof. inversion 1; reflexivity. Qed.

Lemma pointerConvert_Integer {t} : isInteger (pointerConvert t) -> isInteger t.
Proof. destruct t; inversion 1; subst; assumption. Qed.

Lemma pointerConvert_Arith_id {t} : isArithmetic t -> pointerConvert t = t.
Proof. inversion 1; apply pointerConvert_Integer_id; assumption. Qed.

Lemma pointerConvert_Arith {t} : isArithmetic (pointerConvert t) -> isArithmetic t.
Proof. inversion 1; constructor; apply pointerConvert_Integer; assumption. Qed.

(* Pointer conversion leaves pointers untouched. *)
Lemma pointerConvert_Integer_Pointer {t} : isPointer t -> pointerConvert t = t.
Proof. inversion 1; reflexivity. Qed.

(* defns JeType *)
Inductive eType : impl -> gamma -> sigma -> expression -> typeCategory -> Prop :=    (* defn eType *)
 | ETypeVariable : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (qs:qualifiers) (ty:type),
     Lookup G id (qs, ty)  ->
     eType P G S (Var id) (LvalueType qs ty)
 | ETypeFunction : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (ty:type) (s:statement),
     Lookup S id (ty, s)  ->
     eType P G S (Var id) (ExpressionType ty)
 | ETypeConstantInt : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Signed Int) ->
     eType P G S (Constant (ConstantInteger  ( n , None) )) (ExpressionType (Basic (Integer (Signed Int))))
 | ETypeConstantLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Signed Int)  ->
     inIntegerTypeRange P n (Signed Long) ->
     eType P G S (Constant (ConstantInteger  ( n , None) )) (ExpressionType (Basic (Integer (Signed Long))))
 | ETypeConstantLongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Signed Long)  ->
     inIntegerTypeRange P n (Signed LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , None) )) (ExpressionType (Basic (Integer (Signed Long))))
 | ETypeConstantUInt : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Unsigned Int) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  UnsignedInt ) )) (ExpressionType (Basic (Integer (Unsigned Int))))
 | ETypeConstantULong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Int)  ->
     inIntegerTypeRange P n (Unsigned Long) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  UnsignedInt ) )) (ExpressionType (Basic (Integer (Unsigned Long))))
 | ETypeConstantULongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Long)  ->
     inIntegerTypeRange P n (Unsigned LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  UnsignedInt ) )) (ExpressionType (Basic (Integer (Unsigned LongLong))))
 | ETypeConstantLLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Signed Long) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Signed Long))))
 | ETypeConstantLLongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Signed Long)  ->
     inIntegerTypeRange P n (Signed LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Signed LongLong))))
 | ETypeConstantULLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Unsigned Long) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Unsigned Long))))
 | ETypeConstantULLongLong : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
      ~ inIntegerTypeRange P n (Unsigned Long)  ->
     inIntegerTypeRange P n (Unsigned LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLong ) )) (ExpressionType (Basic (Integer (Unsigned LongLong))))
 | ETypeConstantLL : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Signed LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLongLong ) )) (ExpressionType (Basic (Integer (Signed LongLong))))
 | ETypeConstantULL : forall (P:impl) (G:gamma) (S:sigma) (n:nat),
     inIntegerTypeRange P n (Unsigned LongLong) ->
     eType P G S (Constant (ConstantInteger  ( n , Some  SignedLongLong ) )) (ExpressionType (Basic (Integer (Unsigned LongLong))))
 | ETypeCall : forall (ls:arguments) (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     expressionType P G S e (Pointer  nil  (Function ty ps)) ->
     eType_arguments P G S ls ps ->
     eType P G S (Call e ls) (ExpressionType ty)
 | ETypeAddressFunction : forall (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     eType P G S e (ExpressionType (Function ty ps)) ->
     eType P G S (Unary Address e) (ExpressionType (Pointer  nil  (Function ty ps)))
 | ETypeAddressLvalue : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     eType P G S e (LvalueType qs ty) ->
     eType P G S (Unary Address e) (ExpressionType (Pointer qs ty))
 | ETypeIndirectionObject : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (qs:qualifiers) (ty:type),
     expressionType P G S e (Pointer qs ty) ->
     isComplete ty ->
     isObject ty ->
     eType P G S (Unary Indirection e) (LvalueType qs ty)
 | ETypeIndirectionFunction : forall (ps:params) (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type),
     expressionType P G S e (Pointer  nil  (Function ty ps)) ->
     eType P G S (Unary Indirection e) (ExpressionType (Pointer  nil  (Function ty ps)))
 | ETypePostfixIncrementPointer : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isPointer ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixIncr e) (ExpressionType ty)
 | ETypePostfixIncrementReal : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isReal ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixIncr e) (ExpressionType ty)
 | ETypePostfixDecrementPointer : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isPointer ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixDecr e) (ExpressionType ty)
 | ETypePostfixDecrementReal : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty:type) (qs':qualifiers) (ty':type),
     eType P G S e (LvalueType qs' ty') ->
     lvalueConversion ty' ty ->
     isReal ty' ->
     isModifiable qs' ty' ->
     eType P G S (Unary PostfixDecr e) (ExpressionType ty)
 | ETypePlus : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isArithmetic ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Plus e) (ExpressionType ty)
 | ETypeMinus : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isArithmetic ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Minus e) (ExpressionType ty)
 | ETypeBnot : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     expressionType P G S e ty' ->
     isInteger ty' ->
     isPromotion P ty' ty ->
     eType P G S (Unary Bnot e) (ExpressionType ty)
 | ETypeSizeOf : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty ty':type),
      ~ (  isFunction ty  )  ->
      ~ (  isIncomplete ty  )  ->
      Implementation.size_t  P  =  ty'  ->
     eType P G S (SizeOf qs ty) (ExpressionType ty')
 | ETypeAlignOf : forall (P:impl) (G:gamma) (S:sigma) (qs:qualifiers) (ty ty':type),
      ~ (  isFunction ty  )  ->
      ~ (  isIncomplete ty  )  ->
      Implementation.size_t  P  =  ty'  ->
     eType P G S (AlignOf qs ty) (ExpressionType ty')
 | ETypeCastScalar : forall (P:impl) (G:gamma) (S:sigma) (qualifiers:qualifiers) (ty:type) (e:expression) (ty':type),
     expressionType P G S e ty' ->
     isScalar ty' ->
     isScalar ty ->
     eType P G S (Cast qualifiers ty e) (ExpressionType ty)
 | ETypeCastVoid : forall (P:impl) (G:gamma) (S:sigma) (qualifiers:qualifiers) (e:expression) (ty:type),
     expressionType P G S e ty ->
     eType P G S (Cast qualifiers Void e) (ExpressionType Void)
 | ETypeMult : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Mul ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Mul) e2) (ExpressionType ty)
 | ETypeDiv : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Div ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Div) e2) (ExpressionType ty)
 | ETypeMod : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Mod ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Mod) e2) (ExpressionType ty)
 | ETypeAddArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Add ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType ty)
 | ETypeAddPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isComplete ty1 ->
     isInteger ty2 ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeAddPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs2:qualifiers) (ty2 ty1:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isInteger ty1 ->
     isComplete ty2 ->
     eType P G S (Binary e1 (Arithmetic Add) e2) (ExpressionType (Pointer qs2 ty2))
 | ETypeSubArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Sub ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType ty)
 | ETypeSubPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isComplete ty1 ->
     isInteger ty2 ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType (Pointer qs1 ty1))
 | ETypeSubPointerDiff : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty:type) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isComplete ty1 ->
     isComplete ty2 ->
     isCompatible ty1 ty2 ->
      Implementation.ptrdiff_t  P  =  ty  ->
     eType P G S (Binary e1 (Arithmetic Sub) e2) (ExpressionType ty)
 | ETypeShiftL : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1' ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Shl ty2 ->
     isPromotion P ty1 ty1' ->
     eType P G S (Binary e1 (Arithmetic Shl) e2) (ExpressionType ty1')
 | ETypeShiftR : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1' ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Shr ty2 ->
     isPromotion P ty1 ty1' ->
     eType P G S (Binary e1 (Arithmetic Shr) e2) (ExpressionType ty1')
 | ETypeLtReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Lt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLtPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Lt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGtReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Gt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGtPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Gt e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLeReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Le e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeLePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Le e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGeReal : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isReal ty1 ->
     isReal ty2 ->
     eType P G S (Binary e1 Ge e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeGePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty1 ->
     isObject ty2 ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Ge e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1 qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 Void) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 Void) ->
     isObject ty1 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqNull1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isNullPointerConstant e1 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeEqNull2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     eType P G S (Binary e1 Eq e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNePointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1 qs2:qualifiers) (ty2:type),
     expressionType P G S e1 (Pointer qs1 Void) ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1:type) (qs2:qualifiers),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 (Pointer qs2 Void) ->
     isObject ty1 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeNull1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1:type) (qs2:qualifiers) (ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isNullPointerConstant e1 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeNeNull2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty2:type),
     expressionType P G S e1 (Pointer qs1 ty1) ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     eType P G S (Binary e1 Ne e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeBand : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Band ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Band) e2) (ExpressionType ty)
 | ETypeXor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Xor ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Xor) e2) (ExpressionType ty)
 | ETypeBor : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isBinaryArithmetic ty1 Bor ty2 ->
     isUsualArithmetic P ty1 ty2 ty ->
     eType P G S (Binary e1 (Arithmetic Bor) e2) (ExpressionType ty)
 | ETypeAnd : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isScalar ty1 ->
     isScalar ty2 ->
     eType P G S (Binary e1 And e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeOr : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     isScalar ty1 ->
     isScalar ty2 ->
     eType P G S (Binary e1 Or e2) (ExpressionType  (Basic (Integer (Signed Int))) )
 | ETypeConditionalArithmetic : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty ty1 ty2 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isArithmetic ty2 ->
     isArithmetic ty3 ->
     isUsualArithmetic P ty2 ty3 ty ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty)
 | ETypeConditionalVoid : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty1:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 Void ->
     expressionType P G S e3 Void ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType Void)
 | ETypeConditionalPointer : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3:qualifiers) (ty ty1 ty2 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isCompatible ty2 ty3 ->
     isComposite ty2 ty3 ty ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer   (List.app  qs2   qs3 )   ty))
 | ETypeConditionalNullPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty3 ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isPointer ty3 ->
      ~ (  isCompatible ty2 ty3  )  ->
     isNullPointerConstant e2 ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty3)
 | ETypeConditionalNullPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (ty2 ty1 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 ty2 ->
     expressionType P G S e3 ty3 ->
     isPointer ty2 ->
      ~ (  isCompatible ty2 ty3  )  ->
     isNullPointerConstant e2 ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType ty2)
 | ETypeConditionalPointerVoid1 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3:qualifiers) (ty2 ty1 ty3:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isVoid ty2 ->
     isObject ty3 ->
      ~ (  isCompatible ty2 ty3  )  ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer   (List.app  qs2   qs3 )   ty2))
 | ETypeConditionalPointerVoid2 : forall (P:impl) (G:gamma) (S:sigma) (e1 e2 e3:expression) (qs2 qs3:qualifiers) (ty3 ty1 ty2:type),
     expressionType P G S e1 ty1 ->
     isScalar ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     expressionType P G S e3 (Pointer qs3 ty3) ->
     isObject ty2 ->
     isVoid ty3 ->
      ~ (  isCompatible ty2 ty3  )  ->
     eType P G S (Conditional e1 e2 e3) (ExpressionType (Pointer   (List.app  qs2   qs3 )   ty3))
 | ETypeAssign : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (qs1:qualifiers) (ty1 ty:type),
     eType P G S e1 (LvalueType qs1 ty1) ->
     isModifiable qs1 ty1 ->
     pointerConvert ty1 = ty ->
     isAssignable P G S ty e2 ->
     eType P G S (Assign e1 e2) (ExpressionType ty)
 | ETypeCompoundAssignPlusMinusArithmetic : forall (P:impl) (G:gamma) (S:sigma) aop (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2 :type),
     (aop = Add) + (aop = Mul) ->
     eType P G S e1 (LvalueType qs ty) ->
     lvalueConversion ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     eType P G S (CompoundAssign e1 aop e2) (ExpressionType ty1)
 | ETypeCompoundAssignPlusMinusPointer : forall (P:impl) (G:gamma) (S:sigma) aop (e1 e2:expression) (ty1:type) (qs' qs:qualifiers) (ty ty2:type),
     (aop = Add) + (aop = Mul) ->
     eType P G S e1 (LvalueType qs' (Pointer qs ty)) ->
     lvalueConversion (Pointer qs ty) ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs (Pointer qs ty)  ->
     isComplete ty ->
     isInteger ty2 ->
     eType P G S (CompoundAssign e1 aop e2) (ExpressionType ty1)
 | ETypeCompoundAssign : forall (P:impl) (G:gamma) (S:sigma) aop (e1 e2:expression) (ty1:type) (qs:qualifiers) (ty ty2:type),
     neg ((aop = Add) + (aop = Mul)) ->
     eType P G S e1 (LvalueType qs ty) ->
     lvalueConversion ty ty1 ->
     expressionType P G S e2 ty2 ->
     isModifiable qs ty ->
     isBinaryArithmetic ty1 aop ty2 ->
     eType P G S (CompoundAssign e1 aop e2) (ExpressionType ty1)
 | ETypeComma : forall (P:impl) (G:gamma) (S:sigma) (e1 e2:expression) (ty2 ty1:type),
     expressionType P G S e1 ty1 ->
     expressionType P G S e2 ty2 ->
     eType P G S (Binary e1 Comma e2) (ExpressionType ty2)
with expressionType : impl -> gamma -> sigma -> expression -> type -> Prop :=    (* defn expressionType *)
 | ExpressionTypeExpressionT : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type),
     eType P G S e (ExpressionType ty') ->
     pointerConvert ty' = ty ->
     expressionType P G S e ty
 | ExpressionTypeLvalueT : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (ty ty':type) (qs:qualifiers),
     eType P G S e (LvalueType qs ty') ->
     lvalueConversion ty' ty ->
     expressionType P G S e ty
with typeable : impl -> gamma -> sigma -> expression -> Prop :=    (* defn typeable *)
 | TypeableDef : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (typeCategory:typeCategory),
     eType P G S e typeCategory ->
     typeable P G S e
with eType_arguments : impl -> gamma -> sigma -> arguments -> params -> Prop :=    (* defn isAssignable *)
 | ETypeNil P G S : eType_arguments P G S ArgumentsNil ParamsNil
 | ETypeCons P G S ls ps : forall e qs ty ty',
     pointerConvert ty = ty' ->
     isAssignable P G S ty' e ->
     eType_arguments P G S ls ps ->
     eType_arguments P G S (ArgumentsCons e ls) (ParamsCons qs ty ps)
with isAssignable : impl -> gamma -> sigma -> type -> expression -> Prop :=
 | IsAssignableArithmetic : forall P G S e2 ty1 ty2,
     expressionType P G S e2 ty2 ->
     isArithmetic ty1 ->
     isArithmetic ty2 ->
     isAssignable P G S ty1 e2
 | IsAssignablePointer : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (qs1 qs2:qualifiers) (ty1 ty2:type),
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isCompatible ty1 ty2 ->
     sub qs2 qs1 ->
     isAssignable P G S (Pointer qs1 ty1) e2
 | IsAssignableVoidPointer1 : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (qs1 qs2:qualifiers) (ty1 ty2:type),
     isVoid ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isObject ty2 ->
     sub qs2 qs1  ->
     isAssignable P G S (Pointer qs1 ty1) e2
 | IsAssignableVoidPointer2 : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (qs1 qs2:qualifiers) (ty1 ty2:type),
     isObject ty1 ->
     expressionType P G S e2 (Pointer qs2 ty2) ->
     isVoid ty2 ->
     sub qs2 qs1  ->
     isAssignable P G S (Pointer qs1 ty1) e2
 | IsAssignableNullPointerConstant : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (ty1 ty2:type),
     isPointer ty1 ->
     expressionType P G S e2 ty2 ->
     isNullPointerConstant e2 ->
     isAssignable P G S ty1 e2
 | IsAssignableBool : forall (P:impl) (G:gamma) (S:sigma) (e2:expression) (ty1 ty2:type),
     isBool ty1 ->
     expressionType P G S e2 ty2 ->
     isPointer ty2 ->
     isAssignable P G S ty1 e2.

Definition Disjoint {A B1 B2} E1 E2 : Type :=
  forall (a : A) (b1 : B1) (b2 : B2), Lookup E1 a b1 -> Lookup E2 a b2 -> False.

Definition env_sub {A B} (P : A -> Type) (E1 E2 : list (A * B)) :=
  forall id, P id -> forall b, Lookup E1 id b -> Lookup E2 id b.

Definition env_equiv {A B} (P : A -> Type) (E1 E2 : list (A * B)) :=
  env_sub P E1 E2 * env_sub P E2 E1.

Fixpoint eType_env_sub P (G1 G2:gamma) (S:sigma) e {struct e} :
  env_sub (fun id => fv id e) G1 G2 ->
  forall tc,
  eType P G1 S e tc -> eType P G2 S e tc
with eType_arguments_env_sub P (G1 G2 :gamma) (S:sigma) l p {struct l} :
  env_sub (fun id => fv_arguments id l) G1 G2 ->
  eType_arguments P G1 S l p ->
  eType_arguments P G2 S l p.
Proof.
  + destruct e; intros Hfree;
    inversion 1; subst;
    match goal with
    | [ H1 : expressionType  P G1 S _  _
      , H2 : expressionType  P G1 S _  _
      , H3 : expressionType  P G1 S _  _      |- _] => inversion H1; inversion H2; inversion H3; subst
    | [ H1 : expressionType  P G1 S _  _
      , H2 : expressionType  P G1 S _  _      |- _] => inversion H1; inversion H2; subst
    | [ H  : expressionType  P G1 S _  _      |- _] => inversion H; subst
    | [ H  : isAssignable P G1 S ?e _      |- _] => inversion H; subst;
                                                       match goal with | [H : expressionType  P G1 S ?e _ |- _] => inversion H; subst end
    | [ H  : eType           P G1 S (Var _) _ |- _] => inversion H; subst
    | _ => idtac
    end;
    repeat match goal with
    | [H: eType _ G1 _ ?e _|- _] =>
        notHyp (env_sub (fun id => fv id e) G1 G2);
        let Hfree_sub := fresh in
        assert (env_sub (fun id => fv id e) G1 G2) as Hfree_sub
          by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
        set (eType_env_sub _ G1 G2 _ _ Hfree_sub _ H)
    | [H : eType_arguments P G1 _ ?l _ |- _] =>
        notHyp(env_sub (fun id => fv_arguments id l) G1 G2) ;
        let Hfree_sub := fresh in
        assert (env_sub (fun id => fv_arguments id l) G1 G2) as Hfree_sub
          by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
        set (eType_arguments_env_sub _ G1 G2 _ _ _ Hfree_sub H)
    | [H : Lookup G1 ?v ?p |- eType _ ?G _ (Var ?v) _] =>
        notHyp (Lookup G2 v p);
        assert (Lookup G2 id p) by (apply (Hfree id (FvVariable id)); assumption)
    end;
    econstructor (
      solve [ econstructor (eassumption)
            | finish eassumption
            | match goal with
              | [|- isAssignable _ _ _  _ _] =>
                  econstructor (
                    solve [ econstructor (solve [ econstructor (eassumption) | finish eassumption ])
                          | eassumption]
                  )
              end
          | finish eassumption
          | apply eq_sym; eassumption ]
    ).
  + destruct l; intros Hfree; inversion 1; subst.
    - constructor.
    - match goal with
      | [ H  : isAssignable P G1 S ?e _ |- _] => inversion H; subst;
          match goal with
          | [H : expressionType  P G1 S ?e _ |- _] => inversion H; subst
          end
      end;
      repeat match goal with
      | [H: eType _ G1 _ ?e _|- _] =>
          notHyp (env_sub (fun id => fv id e) G1 G2);
          let Hfree_sub := fresh in
          assert (env_sub (fun id => fv id e) G1 G2) as Hfree_sub
            by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
        set (eType_env_sub _ G1 G2 _ _ Hfree_sub _ H)
      | [H : eType_arguments P G1 _ ?l _ |- _] =>
          notHyp(env_sub (fun id => fv_arguments id l) G1 G2) ;
          let Hfree_sub := fresh in
          assert (env_sub (fun id => fv_arguments id l) G1 G2) as Hfree_sub
            by (intros ? ?; apply Hfree; solve [econstructor (eassumption) | assumption]);
          set (eType_arguments_env_sub _ G1 G2 _ _ _ Hfree_sub H)
      end;
      econstructor (solve
        [ apply eq_sym; eassumption
        | econstructor (solve [econstructor (eassumption) | finish eassumption])
        | eassumption ]).
Qed.
      
(* Coq's insanely stupid termination checker won't allow me to write a
mutually recursive function so I am resorting to open recursion + tying the
knot manually. *)
Definition option_bind {A B} : option A -> (A -> option B) -> option B :=
  fun o f =>
    match o with
    | Some a => f a
    | None   => None
    end.

Infix ">>=" := option_bind (at level 42, left associativity).

Definition option_bool {A} : option A -> (A -> bool) -> bool :=
  fun o f =>
    match o with
    | Some a => f a
    | None   => false
    end.

Definition expressionType_find tc : option type :=
  match tc with
  | ExpressionType   ty => Some (pointerConvert ty)
  | LvalueType     _ ty => lvalueConversion_find ty
  end.

Lemma expressionType_find_correct_pos {P} {G} {S} {e} {tc} {ty} :
  eType P G S e tc ->
  expressionType_find tc = Some ty ->
  expressionType P G S e ty.
Proof.
  intros ?.
  do 2 unfold_goal.
  context_destruct;
  match goal with
  | [|- context[lvalueConversion_find ?ty]] =>
      let Heq := fresh in
      set (lvalueConversion_find_correct ty);
      intros Heq; rewrite Heq in *;
      econstructor 2; eassumption
  | [|- Some _ = Some _ -> _] =>
      injection 1; intros ?; my_auto
  end.
Qed.

Lemma expressionType_find_correct_neg {P} {G} {S} {e} {tc} :
  eType P G S e tc ->
  (forall tc', eType P G S e tc' -> tc = tc') ->
  expressionType_find tc = None ->
  forall ty, neg (expressionType P G S e ty).
Proof.
  intros ? Hunique.
  do 2 unfold_goal.
  context_destruct;
  match goal with
  | [|- context[lvalueConversion_find ?ty]] =>
      let Heq := fresh in
      set (lvalueConversion_find_correct ty);
      intros Heq; rewrite Heq in *
  end;
  inversion 1; subst;
  match goal with
  | [ Hunique : forall _ : typeCategory, eType P G S ?e _ -> ?tc = _
    , H       : eType P G S ?e ?tc
    , H'      : eType P G S ?e ?tc' |- _ ] =>
      discriminate (Hunique tc' H') || injection (Hunique tc' H'); intros; subst; now firstorder
  end.
Qed.

Lemma expressionType_unique_lvalue_inj {P} {G} {S} {e} {qs} {ty} :
  expressionType P G S e ty ->
  (forall tc', eType P G S e tc' -> LvalueType qs ty = tc') ->
  forall ty', expressionType P G S e ty' -> ty' = ty.
Proof.
  intros ? Hunique; inversion 1;
  match goal with
  | [H : eType P G S e ?tc |- _] => set (Hunique tc H); try congruence
  end;
  repeat match goal with
  | [H : lvalueConversion _ _      |- _] => inversion_clear H
  | [H : isLvalueConvertible _     |- _] => inversion_clear H
  | [_ : pointerConvert ?t = _     |- _] => is_var t; destruct t
  | [H : isComplete (Function _ _) |- _] => inversion H
  | [H : ~ isArray (Array _ _)     |- _] => exfalso; apply H; constructor
  end; my_auto.
Qed.

Lemma expressionType_unique_expression_inj {P} {G} {S} {e} {ty} :
  (forall tc1 tc2, eType P G S e tc1 -> eType P G S e tc2 -> tc1 = tc2) ->
  expressionType P G S e ty ->
  forall ty', expressionType P G S e ty' -> ty = ty'.
Proof.
  intros Hunique H.
  inversion H; inversion 1; subst;
  match goal with
  | [ H1 : eType P G S e _ , H2 : eType P G S e _ |- _] => set (Hunique _ _ H1 H2)
  end;
  repeat match goal with
  | [H : lvalueConversion _ _ |- _] => inversion_clear H
  end;
  congruence.
Qed.

Hint Extern 1 (ExpressionType _ = ExpressionType _) =>
  apply f_equal;
    solve [ eapply expressionType_unique_lvalue_inj    ; eassumption
          | eapply expressionType_unique_expression_inj; eauto       ].

Hint Extern 1 (LvalueType _ = LvalueType _) =>
  apply f_equal;
    solve [ eapply expressionType_unique_lvalue_inj    ; eassumption
          | eapply expressionType_unique_expression_inj; eauto       ].

Lemma expressionType_find_eq_lvalue {qs1} {ty1 ty2} :
  expressionType_find (LvalueType qs1 ty1) = Some ty2 ->
  ty1 = ty2.
Proof. do 4 unfold_goal; destruct ty1; my_auto. Qed.

Lemma expressionType_find_eq_lvalue_lift {P} {G} {S} {e} {qs1} {ty1 ty2}:
  eType P G S e (LvalueType qs1 ty1) ->
  expressionType_find (LvalueType qs1 ty1) = Some ty2 ->
  expressionType P G S e ty1.
Proof.
  intros ? Heq.
  rewrite <- (expressionType_find_eq_lvalue Heq) in Heq.
  revert Heq; simpl; unfold_goal; context_destruct.
  case_fun (isLvalueConvertible_fun_correct ty1).
  + intros.
    econstructor 2.
    * eassumption.
    * econstructor; [eassumption | injection Heq; trivial].
  + discriminate.
Qed.

Lemma expressionType_neg P G S e :
  (forall tc, neg (eType          P G S e tc)) ->
  forall  ty, neg (expressionType P G S e ty).
Proof. inversion 2; firstorder. Qed.

Definition isAssignable_fun ty1 ty2 is_null2 : bool :=
  match ty1, ty2 with
  | Pointer qs1 t1, Pointer qs2 t2 => orb is_null2
                                          (andb (list_sub_fun (fun q1 q2 => bool_of_decision (qualifier_DecEq q1 q2)) qs2 qs1)
                                                (orb (isCompatible_fun t1 t2)
                                                     (orb (andb (isVoid_fun t1) (isObject_fun t2))
                                                          (andb (isVoid_fun t2) (isObject_fun t1)))))
  | Pointer qs1 t1, _              => is_null2
  | _             , Pointer _   _  => isBool_fun ty1
  | _             , _              => andb (isArithmetic_fun ty1)
                                           (isArithmetic_fun ty2)
  end.

Lemma isAssignable_fun_correct_pos P G S ty1 e2 ty2 :
  expressionType P G S e2 ty2 ->
  isAssignable_fun ty1 ty2 (isNullPointerConstant_fun e2) = true ->
  isAssignable P G S ty1 e2.
Proof.
  unfold_goal; intros ?.
  do 2 context_destruct; bool_simpl;
  repeat (match goal with
  | [|- isArithmetic_fun ?t           = _ -> _] => set (isArithmetic_fun_correct t)
  | [|- isNullPointerConstant_fun ?e2 = _ -> _] => set (isNullPointerConstant_fun_correct e2)
  | [|- isCompatible_fun ?ty1 ?ty2    = _ -> _] => set (isCompatible_fun_correct ty1 ty2)
  | [|- isBool_fun ?t                 = _ -> _] => set (isBool_fun_correct t)
  | [|- isVoid_fun ?t                 = _ -> _] => set (isVoid_fun_correct t)
  | [|- isObject_fun ?t               = _ -> _] => set (isObject_fun_correct t)
  | [|- list_sub_fun ?f ?qs1 ?qs2     = _ -> _] => set (list_sub_fun_correct qs1 qs2 (fun q1 q2 => Decision_boolSpec (qualifier_DecEq q1 q2)))
  end; boolSpec_simpl);
  econstructor (solve [eassumption|constructor]).
Qed.

Lemma eType_unique_instance {P} {G} {S} {e} {tc} :
  (forall tc', eType P G S e tc' -> tc = tc') ->
  (forall tc1 tc2, eType P G S e tc1 -> eType P G S e tc2 -> tc1 = tc2).
Proof.
  intros Hunique tc1 tc2 Htc1 Htc2.
  assert (tc = tc1) by (apply Hunique; assumption).
  assert (tc = tc2) by (apply Hunique; assumption).
  congruence.
Qed.

Hint Resolve eType_unique_instance.

Ltac isAssignable_neg_tac :=
  repeat match goal with
  | [H : isInteger    (Function _ _) |- _ ] => inversion H
  | [H : isInteger    (Pointer  _ _) |- _ ] => inversion H
  | [H : isInteger    Void           |- _ ] => inversion H
  | [H : isArithmetic (Function _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic (Pointer  _ _) |- _ ] => inversion_clear H
  | [H : isArithmetic Void           |- _ ] => inversion_clear H
  | [H : neg (isArithmetic (Basic ?bt)) |- _ ] => is_var bt; destruct bt
  | [H : neg (isInteger    (Basic ?bt)) |- _ ] => is_var bt; destruct bt
  | [H : neg (isArithmetic (Basic (Integer _))) |- _ ] => exfalso; apply H; do 2 constructor
  | [H : neg (isInteger    (Basic (Integer _))) |- _ ] => exfalso; apply H; constructor
  | [H : isBool       ?t             |- _ ] =>
      match t with
      | _ => is_var t; inversion H; subst; clear H
      | Basic ?bt => is_var bt; destruct bt
      end
  | [H : isVoid       ?t             |- _ ] => is_var t; inversion H; subst; clear H
  | [H : isPointer    ?t             |- _ ] => 
      match t with
      | Pointer _ _ => fail 1
      | _ => is_var t; inversion H; subst; clear H
      end
  | _ => finish fail
  end.

Lemma isAssignable_fun_correct_neg {P} {G} {S} {ty1 ty2} {e2}:
  expressionType P G S e2 ty2 ->
  (forall tc1 tc2, eType P G S e2 tc1 -> eType P G S e2 tc2 -> tc1 = tc2) ->
  isAssignable_fun ty1 ty2 (isNullPointerConstant_fun e2) = false ->
  neg (isAssignable P G S ty1 e2).
Proof.
  intros ? Hunique.
  unfold_goal; do 2 context_destruct; bool_simpl;
  repeat (match goal with
  | [|- isArithmetic_fun ?t           = _ -> _] => set (isArithmetic_fun_correct t)
  | [|- isNullPointerConstant_fun ?e2 = _ -> _] => set (isNullPointerConstant_fun_correct e2)
  | [|- isCompatible_fun ?ty1 ?ty2    = _ -> _] => set (isCompatible_fun_correct ty1 ty2)
  | [|- isBool_fun ?t                 = _ -> _] => set (isBool_fun_correct t)
  | [|- isVoid_fun ?t                 = _ -> _] => set (isVoid_fun_correct t)
  | [|- isObject_fun ?t               = _ -> _] => set (isObject_fun_correct t)
  | [|- list_sub_fun ?f ?qs1 ?qs2     = _ -> _] => set (list_sub_fun_correct qs1 qs2 (fun q1 q2 => Decision_boolSpec (qualifier_DecEq q1 q2)))
  end; boolSpec_simpl);
  (try now (inversion 1; my_auto));
  inversion 1; subst;
  isAssignable_neg_tac;
  match goal with
  | [ H1 : expressionType P G S e2 _
    , H2 : expressionType P G S e2 _ |- _] =>
      generalize (expressionType_unique_expression_inj Hunique H1 _ H2);
      discriminate || (try injection; intros; subst; finish ltac:(now isAssignable_neg_tac))
  end.
Qed.

Fixpoint eType_find (P:impl) (G:gamma) (S:sigma) e {struct e} : option typeCategory :=
  match e with
  | Var id =>
      match lookup_id G id, lookup_id S id with
      | Some (qs, ty), None         => Some (LvalueType     qs ty)
      | None         , Some (ty, _) => Some (ExpressionType    ty)
      | _            , _            => None
      end
  | Binary e1 Comma e2 => 
     match eType_find P G S e1 >>= expressionType_find, eType_find P G S e2 >>= expressionType_find with
     | Some _, Some ty2 => Some (ExpressionType ty2)
     | _     , _        => None
     end
  | Unary Address e =>
      match eType_find P G S e with
      | Some (LvalueType qs ty)                => Some (ExpressionType (Pointer qs ty))
      | Some (ExpressionType (Function ty ps)) => Some (ExpressionType (Pointer nil (Function ty ps)))
      | _                                      => None
      end
  | Unary Plus e
  | Unary Minus e =>
      eType_find P G S e  >>=
      expressionType_find >>= (fun ty =>
        if isArithmetic_fun ty then
          option_map ExpressionType (isPromotion_find P ty)
        else
          None
      )
  | Unary Bnot e =>
      eType_find P G S e  >>=
      expressionType_find >>= (fun ty =>
        if isInteger_fun ty then
          option_map ExpressionType (isPromotion_find P ty)
        else
          None
      )
  | Unary Indirection e =>
      eType_find P G S e >>=
      expressionType_find >>= (fun ty =>
        match ty with
        | Pointer nil (Function t p) => Some (ExpressionType (Pointer nil (Function t p)))
        | Pointer qs  ty             => if andb (isComplete_fun ty) (isObject_fun ty)
                                          then Some (LvalueType qs ty)
                                          else None
        | _                          => None
        end
      )
  | Unary PostfixIncr e
  | Unary PostfixDecr e =>
      match eType_find P G S e with
      | Some (LvalueType qs' ty') =>
          match lvalueConversion_find ty' with
          | Some ty =>
              if andb (isModifiable_fun qs' ty')
                      (orb (isReal_fun ty') (isPointer_fun ty'))
                then Some (ExpressionType ty)
                else None
          | None    => None
          end
      | Some _                    => None
      | None                      => None
      end
  | Call e ls =>
      match eType_find P G S e >>= expressionType_find with
      | Some (Pointer nil (Function ty ps)) => if eType_arguments_find P G S ls ps
                                                 then Some (ExpressionType ty)
                                                 else None
      | _                                   => None
      end
  | _ => None 
  end
with eType_arguments_find (P:impl) (G:gamma) (S:sigma) (l:arguments) (p:params) {struct l} : bool :=
  match l, p with
  | ArgumentsNil     , ParamsNil          => true
  | ArgumentsCons e l, ParamsCons _ ty1 p =>
      match eType_find P G S e >>= expressionType_find with
      | Some ty2 => andb (isAssignable_fun (pointerConvert ty1) ty2 (isNullPointerConstant_fun e))
                         (eType_arguments_find P G S l p)
      | None     => false
      end
  | _                , _                  => false
  end.

Fixpoint eType_find_correct P G S e {struct e}:
  Disjoint G S ->
  match eType_find P G S e with
  | Some tc => eType P G S e tc * (forall tc', eType P G S e tc' -> tc = tc')
  | None    => forall tc, neg (eType P G S e tc)
  end
with eType_arguments_find_correct P G S l p {struct l}:
  Disjoint G S ->
  boolSpec (eType_arguments_find P G S l p) (eType_arguments P G S l p).
Proof.
  intros Hdisjoint.
  destruct e; simpl.
  Focus 7.
  repeat
  match goal with
  | [|- lookup_id ?E ?id = ?o -> _] =>
      case_fun (lookup_id_correct E id)
  | [|- eType_find P G S ?e = ?o -> _] =>
      is_var o; case_fun (eType_find_correct P G S e Hdisjoint);
      match goal with
      | [H : _ * _ |- _] => destruct H
      | _ => idtac
      end
  | [|- context[option_map] ] =>
      unfold option_map
  | [|- (Some _ >>= _) = _ -> _ ] =>
      unfold option_bind at 1
  | [|- Some _ = ?o -> _ ] =>
      is_var o; intros ?; subst o
  | [|- None = ?o -> _ ] =>
      is_var o; intros ?; subst o
  | [|- true = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_true_l); (try rewrite orb_true_l)
  | [|- false = ?o -> _ ] =>
      is_var o; intros ?; subst o; (try rewrite andb_false_l); (try rewrite orb_false_l)
  | [|- (None >>= _) = ?o -> _] =>
      is_var o; unfold option_bind at 1; intros ?; subst o
  | [|- (None >>= _) = ?o -> _] =>
      unfold option_bind at 1
  | [|- ?e >>= _ = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- (true && _) = _ -> _] => rewrite andb_true_l
  | [|- (false && _) = _ -> _] => unfold andb at 1
  | [|- (true || _) = _ -> _] => unfold orb at 1
  | [|- (false || _) = _ -> _] => rewrite orb_false_l
  | [|- (?e && _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- (?e || _) = _ -> _] =>
      match type of e with ?t => pull_out t e end
  | [|- expressionType_find ?t = _ -> _] =>
      is_var t; destruct t
  | [H : eType P G S _ (ExpressionType ?t) |- expressionType_find (ExpressionType ?t) = ?o -> _] =>
      is_var o; let Heq := fresh in
      intros Heq; subst o;
      assert (expressionType_find (ExpressionType t) = Some (pointerConvert t)) as Heq by reflexivity; rewrite Heq;
      set (expressionType_find_correct_pos H Heq)
  | [|- expressionType_find (LvalueType ?q ?t) = ?o -> _] =>
      is_var o; destruct o
  | [|- eType_arguments_find P G S ?l ?p = ?o -> _] =>
      is_var o; case_fun (eType_arguments_find_correct P G S l p Hdisjoint)
  | [H : eType P G S _ (LvalueType ?q ?t) |- expressionType_find (LvalueType ?q ?t) = Some _ -> _] =>
      let Heq := fresh in
      intros Heq;
      set     (expressionType_find_eq_lvalue_lift H Heq);
      rewrite (expressionType_find_eq_lvalue        Heq) in *
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType ?q ?t = _
    , H : eType P G S ?e (LvalueType ?q ?t) |- expressionType_find (LvalueType ?q ?t) = None -> _] =>
      let Heq := fresh in
      intros Heq; set (expressionType_find_correct_neg H Hunique Heq)
  | [|- isArithmetic_fun ?t           = ?o -> _] => is_var o; case_fun (isArithmetic_fun_correct t)
  | [|- isComplete_fun ?t           = ?o -> _] => is_var o; case_fun (isComplete_fun_correct t)
  | [|- isObject_fun ?t           = ?o -> _] => is_var o; case_fun (isObject_fun_correct t)
  | [|- isInteger_fun ?t           = ?o -> _] => is_var o; case_fun (isInteger_fun_correct t)
  | [|- isReal_fun ?t           = ?o -> _] => is_var o; case_fun (isReal_fun_correct t)
  | [|- isPointer_fun ?t           = ?o -> _] => is_var o; case_fun (isPointer_fun_correct t)
  | [|- isModifiable_fun ?qs ?ty           = ?o -> _] => is_var o; case_fun (isModifiable_fun_correct qs ty)
  | [|- isPromotion_find P ?t         = ?o -> _] =>
      is_var o;
      let Heq := fresh in
      let H := fresh in
      set (isPromotion_find_correct P t) as H;
      intros Heq; rewrite Heq in H; destruct o
  | [|- lvalueConversion_find ?t         = ?o -> _] =>
      is_var o;
      let Heq := fresh in
      let H := fresh in
      set (lvalueConversion_find_correct t) as H;
      unfold optionSpec in H;
      intros Heq; rewrite Heq in H; destruct o
  | _ => context_destruct
  | [|- (match pointerConvert ?ty with _ => _ end) = _ -> _] => destruct ty; unfold pointerConvert in *
  | [|- _ * _] => split
  | [|- eType P G S _ _] => econstructor (eassumption)
  | [ _  : expressionType P G S ?e ?t1
    , _  : expressionType P G S ?e ?t2         |- _ ] =>
      notHyp (t1 = t2); notHyp (t2 = t1);
      let Heq := fresh in
      assert (t1 = t2) as Heq by (eapply expressionType_unique_expression_inj; eauto);
      try (congruence || injection Heq; intros; subst)
  | [H : isPromotion P ?t1 ?t2 |- _ ] => notHyp (isPromotion_find P t1 = Some t2); set (isPromotion_find_unique P t1 t2 H); try congruence
  | [H : lvalueConversion ?t1 ?t2 |- _ ] => notHyp (lvalueConversion_find t1 = Some t2); set (lvalueConversion_find_unique t1 t2 H); try congruence
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType _ _   = _, H : eType P G S ?e (ExpressionType _) |- _] => discriminate (Hunique _ H)
  | [ Hunique : forall _, eType P G S ?e _ -> ExpressionType _ = _, H : eType P G S ?e (LvalueType   _ _) |- _] => discriminate (Hunique _ H)
  | [ Hunique : forall _, eType P G S ?e _ -> LvalueType _ _ = _, H : eType P G S ?e (LvalueType _ ?t)  |- _] =>
      discriminate (Hunique _ H) || (einjection (Hunique _ H); congruence)
  | [ Hunique : forall _, eType P G S ?e _ -> ExpressionType _ = _, H : eType P G S ?e (ExpressionType ?t) |- _] =>
      discriminate (Hunique _ H) || (einjection (Hunique _ H); congruence)
  | [|- forall _, eType P G S (Binary _ Comma _) _ -> _ = _] => inversion_clear 1; now auto
  | [|- forall _, neg (eType P G S (Binary ?e1 Comma ?e2) _)] =>
      set (expressionType_neg P G S e1);
      set (expressionType_neg P G S e2);
      inversion_clear 1; now firstorder
  | [|- forall _, neg (eType P G S (Unary _ _) _)] => inversion 1; subst
  | [|- forall _, neg (eType P G S (Call _ _) _)] => inversion 1; subst
  | [Hfalse : forall _, neg (eType P G S ?e _), H : eType P G S ?e _ |- False] => exact (Hfalse _ H)
  | [Hfalse : forall _, neg (expressionType P G S ?e _), H : expressionType P G S ?e _ |- False] => exact (Hfalse _ H)
  | [ Hfalse : forall _ : type, neg (isPromotion P ?t _)
    , _ : expressionType P G S ?e ?t1
    , H : isPromotion P ?t1 ?t2 |- _ ] => exfalso; eapply Hfalse; congruence
  | [|- forall _, eType P G S (Unary _ _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (Var _) _ -> _ = _] => inversion_clear 1
  | [|- forall _, eType P G S (Call _ _) _ -> _ = _] => inversion_clear 1
  | [|- eType _ _ _ (Var _) (LvalueType _ _) ] =>
      now my_auto
  | [ L1 : Lookup ?G ?id _
    , L2 : Lookup ?S ?id _ |- _ ] =>
      destruct (Hdisjoint id _ _ L1 L2)
  | [ H  : lookup_id ?E ?id = Some ?b1
    , L1 : Lookup ?E ?id ?b1
    , L2 : Lookup ?E ?id _ |- _ = _] => set (lookup_id_unique L2); congruence
  | [_ : forall _, neg (Lookup ?G ?id _) 
    ,_ : forall _, neg (Lookup ?S ?id _) |- forall _, neg (eType _ ?G ?S (Var ?id) _)] =>
      inversion 1; now firstorder
  | [ _ : forall _, neg (eType P G S ?e _) , H : expressionType P G S ?e _ |- _] => inversion H
  | [H : isComplete Void |- _ ] => inversion H
  | [H : isObject (Function _ _) |- _ ] => inversion H
  | _ => boolSpec_simpl
  end.

  Focus 8.
  match goal with
  | [H : lvalueConversion ?t1 ?t2 |- _ ] => notHyp (lvalueConversion_find t1 = Some t2); set (lvalueConversion_find_unique t1 t2 H); try congruence
  end.
  discriminate.
Qed.

(* defns JsType *)
Inductive sType : impl -> gamma -> sigma -> statement -> Prop :=    (* defn sType *)
 | STypeLabel : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (s:statement),
     sType P G S s ->
     sType P G S (Label id s)
 | STypeCase : forall (P:impl) (G:gamma) (S:sigma) (integerConstant:integerConstant) (s:statement),
     sType P G S s ->
     typeable P G S (Constant (ConstantInteger integerConstant)) ->
     sType P G S (Case integerConstant s)
 | STypeDefault : forall (P:impl) (G:gamma) (S:sigma) (s:statement),
     sType P G S s ->
     sType P G S (Default s)
 | STypeBlock : forall (s_list:list statement) (P:impl) (G:gamma) (S:sigma) (G':gamma),
     (forall s_, List.In (s_) (List.map (fun (s_ : statement) => (s_)) s_list) -> (sType P  ( G  @  G' )%gamma  S s_)) ->
     sType P G S (Block G' s_list)
 | STypeSkip : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Skip
 | STypeExpression : forall (P:impl) (G:gamma) (S:sigma) (e:expression),
     typeable P G S e ->
     sType P G S (Expression e)
 | STypeIf : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s1 s2:statement) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s1 ->
     sType P G S s2 ->
     sType P G S (If e s1 s2)
 | STypeSwitch : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s:statement) (ty:type),
     expressionType P G S e ty ->
     isInteger ty ->
     sType P G S s ->
     sType P G S (Switch e s)
 | STypeWhile : forall (P:impl) (G:gamma) (S:sigma) (e:expression) (s:statement) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s ->
     sType P G S (While e s)
 | STypeDo : forall (P:impl) (G:gamma) (S:sigma) (s:statement) (e:expression) (ty:type),
     expressionType P G S e ty ->
     isScalar ty ->
     sType P G S s ->
     sType P G S (Do s e)
 | STypeGoto : forall (P:impl) (G:gamma) (S:sigma) (id:identifier),
     sType P G S (Goto id)
 | STypeContinue : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Continue
 | STypeBreak : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S Break
 | STypeReturnVoid : forall (P:impl) (G:gamma) (S:sigma),
     sType P G S ReturnVoid
 | STypeReturn : forall (P:impl) (G:gamma) (S:sigma) (e:expression),
     typeable P G S e ->
     sType P G S (Return e)
 | STypeDeclaration : forall (definition_list:list definition) (P:impl) (G:gamma) (S:sigma),
     (forall definition_, List.In (definition_) (List.map (fun (definition_ : definition) => (definition_)) definition_list) -> (dType P G S definition_)) ->
     sType P G S (Declaration definition_list)
with dType : impl -> gamma -> sigma -> definition -> Prop :=    (* defn dType *)
 | DType : forall (P:impl) (G:gamma) (S:sigma) (id:identifier) (e:expression) (qs:qualifiers) (ty:type),
      ( G  [  id  ] = Some ( qs ,  ty ))%gamma  ->
     typeable P   ( G  [  id  <- (  nil  ,  ty ) ])%gamma   S (Assign (Var id) e) ->
     dType P G S  ( id , e ) .
(** definitions *)

(* defns JsigmaType *)
Inductive sigmaType : sigma -> sigma -> Prop :=    (* defn sigmaType *)
 | SigmaTypeEmpty : forall (S:sigma),
     sigmaType S  [] 
 | SigmaTypeCtx : forall (S S':sigma) (id:identifier) (ty:type) (s:statement) (P:impl),
     sType P  gamma_empty  S s ->
     sigmaType S S' ->
     sigmaType S  ( S'  [  id  <- ( ty ,  s ) ])%sigma .
(** definitions *)

(* defns JpType *)
Inductive pType : impl -> program -> Prop :=    (* defn pType *)
 | PType : forall (P:impl) (id:identifier) (S:sigma) (s:statement),
     sigmaType S S ->
      ( S  [  id  ] = Some (  (Function (Basic (Integer (Signed Int))) nil)  ,  s ))%sigma  ->
     pType P  ( id ,  S ) .


