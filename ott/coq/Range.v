(* generated by Ott 0.21.2 from: Range_.ott *)
(* Equations
Require Import Equations.
*)
Require Import Common.

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import ZArith.
Local Open Scope Z_scope.

Require Import Nat.

Definition range := {p : Z * Z | fst p <= snd p}.
Definition min (r : range) := fst (proj1_sig r).
Definition max (r : range) := snd (proj1_sig r).
Definition leq (r : range) : min r <= max r := proj2_sig r.

Definition mkRange {x y} : x <= y -> range :=
  fun p => exist _ (x, y) p.

Lemma max_mkRange {x y} {p : x <= y} : max (mkRange p) = y.
Proof. reflexivity. Defined.  

Lemma min_mkRange {x y} {p : x <= y} : min (mkRange p) = x.
Proof. reflexivity. Defined.

(** definitions *)

(* defns neRange *)
Inductive noOverlap : range -> range -> Prop :=    (* defn noOverlap *)
 | noOverlapI_Below : forall (r1 r2:range),
       max  r1   <=   min  r2   ->
     noOverlap r1 r2
 | noOverlapI_Above : forall (r1 r2:range),
       max  r2   <=   min  r1   ->
     noOverlap r1 r2.
Arguments noOverlapI_Below [r1 r2] _.
Arguments noOverlapI_Above [r1 r2] _.

Definition noOverlap_False {r1 r2} : ~max r1 <= min r2 -> ~max r2 <= min r1 ->  noOverlap r1 r2 -> False.
Proof. intros ? ?; destruct 1; contradiction. Defined.

(* Equations
noOverlap_dec_aux {r1 r2} (is_below : Decision (max r1 <= min r2)) (is_above : Decision (max r2 <= min r1)) : Decision (noOverlap r1 r2) :=
noOverlap_dec_aux r1 r2 (inl  B) _         := inl (noOverlapI_Below B)    ;
noOverlap_dec_aux r1 r2 _        (inl   A) := inl (noOverlapI_Above A)    ;
noOverlap_dec_aux r1 r2 (inr NB) (inr  NA) := inr (noOverlap_False NB NA) .
*)

Instance Z_le_dec : DecidableRelation Z.le := fun x y => decision_sumbool_inv (Z_le_dec x y).

Definition noOverlap_fun (r1 r2 : range) : bool :=
  let is_below := Z.leb (max r1) (min r2) in
  let is_above := Z.leb (max r2) (min r1) in
  match is_below, is_above with
  | true, _    => true
  | _   , true => true
  | _   , _    => false
  end.

Lemma noOverlap_fun_correct r1 r2 : boolSpec (noOverlap_fun r1 r2) (noOverlap r1 r2).
Proof.
  do 2 unfold_goal.
  set (Z.leb (max r1) (min r2)) as is_below.
  set (Z.leb (max r2) (min r1)) as is_above.
  case_eq is_below; intros Hr1r2;
    [ set        (Zle_bool_imp_le _ _  Hr1r2)
    | set (proj1 (Z.leb_nle       _ _) Hr1r2) ].
  + constructor 1; assumption.
  + case_eq is_above; intros Hr2r1;
      [ set        (Zle_bool_imp_le _ _  Hr2r1)
      | set (proj1 (Z.leb_nle       _ _) Hr2r1) ].
    - constructor 2; assumption.
    - inversion 1; contradiction.
Defined.

(* Equations
Definition noOverlap_dec : DecidableRelation noOverlap :=
  fun r1 r2 =>
    let is_below := decide (max r1) (min r2) in
    let is_above := decide (max r2) (min r1) in
    noOverlap_dec_aux is_below is_above.
*)

Instance noOverlap_dec : DecidableRelation noOverlap := {
  decide r1 r2 := boolSpec_Decision (noOverlap_fun_correct r1 r2)
}.

(** definitions *)

(* defns leRange *)
Inductive le : range -> range -> Prop :=    (* defn le *)
 | LeI : forall (r1 r2:range),
       max  r1   <=   max  r2   ->
       min  r2   <=   min  r1   ->
     le r1 r2.
(** definitions *)
Arguments LeI [r1 r2] _ _.

(* Equations
Definition le_max_False {r1 r2 : range} :
  ~max r1 <= max r2 -> le r1 r2 -> False.
Proof. intros ?; destruct 1; contradiction. Defined.

Definition le_min_False {r1 r2 : range} :
  ~min r2 <= min r1 -> le r1 r2 -> False.
Proof. intros ?; destruct 1; contradiction. Defined.

le_dec_aux {r1 r2 : range} (is_le_max : Decision (max r1 <= max r2)) (is_ge_min : Decision (min r2 <= min r1)) : Decision (le r1 r2) :=
le_dec_aux r1 r2 (inl     leMax) (inl leMin)    := inl (LeI leMax leMin)      ;
le_dec_aux r1 r2 (inr  notLeMax) _              := inr (le_max_False notLeMax);
le_dec_aux r1 r2 _               (inr notLeMin) := inr (le_min_False notLeMin).
*)

(* Equations
Definition le_dec : DecidableRelation le :=
  fun r1 r2 =>
    let is_le_max := decide (max r1) (max r2) in
    let is_ge_min := decide (min r2) (min r1) in
    le_dec_aux is_le_max is_ge_min.
*)

Definition le_fun (r1 r2 : range) : bool :=
  let is_le_max := Z.leb (max r1) (max r2) in
  let is_ge_min := Z.leb (min r2) (min r1) in
  match is_le_max, is_ge_min with
  | true, true    => true
  | _   , _       => false
  end.

Lemma le_fun_correct r1 r2 : boolSpec (le_fun r1 r2) (le r1 r2).
Proof.
  do 2 unfold_goal.
  set (Z.leb (max r1) (max r2)) as is_le_max.
  set (Z.leb (min r2) (min r1)) as is_ge_min.
  case_eq is_le_max; intros Hr1r2;
    [ set        (Zle_bool_imp_le _ _  Hr1r2)
    | set (proj1 (Z.leb_nle       _ _) Hr1r2) ].
  + case_eq is_ge_min; intros Hr2r1;
      [ set        (Zle_bool_imp_le _ _  Hr2r1)
      | set (proj1 (Z.leb_nle       _ _) Hr2r1) ];
    my_auto.
  + my_auto.
Defined.

Instance le_DecR : DecidableRelation le := {
  decide r1 r2 := boolSpec_Decision (le_fun_correct r1 r2)
}.

(* defns memRange *)
Inductive mem : Z -> range -> Prop :=    (* defn mem *)
 | memI : forall (w:Z) (r:range),
      w  <=   max  r   ->
       min  r   <=  w  ->
     mem w r.
Arguments memI [w r] _ _.

(* Equations
Definition mem_max_False {w} {r} : ~w <= max r -> mem w r -> False.
Proof. intros ?; destruct 1; contradiction. Defined.

Definition mem_min_False {w} {r} : ~min r <= w -> mem w r -> False.
Proof. intros ?; destruct 1; contradiction. Defined.

mem_dec_aux {w} {r} (is_le_max : Decision (w <= max r)) (is_ge_min : Decision (min r <= w)) : Decision (mem w r) :=
mem_dec_aux w r (inl geMax) (inl leMin) := inl (memI geMax leMin)    ;
mem_dec_aux w r (inr ltMax) _           := inr (mem_max_False ltMax) ;
mem_dec_aux w r _           (inr gtMin) := inr (mem_min_False gtMin) .
*)

(* Equations
Definition mem_dec w r : Decision (mem w r) :=
  let is_le_max := Z_le_dec w (max r) in
  let is_ge_min := Z_le_dec (min r) w in
  mem_dec_aux is_le_max is_ge_min.
*)

Definition mem_fun w r : bool :=
  let is_le_max := Z.leb w (max r) in
  let is_ge_min := Z.leb (min r) w in
  match is_le_max, is_ge_min with
  | true, true => true
  | _   , _    => false
  end.

Lemma mem_fun_correct w r : boolSpec (mem_fun w r) (mem w r).
Proof.
  do 2 unfold_goal.
  set (Z.leb w (max r)) as is_le_max.
  set (Z.leb (min r) w) as is_ge_min.
  case_eq is_le_max; intros Hr1r2;
    [ set        (Zle_bool_imp_le _ _  Hr1r2)
    | set (proj1 (Z.leb_nle       _ _) Hr1r2) ].
  + case_eq is_ge_min; intros Hr2r1;
      [ set        (Zle_bool_imp_le _ _  Hr2r1)
      | set (proj1 (Z.leb_nle       _ _) Hr2r1) ];
    my_auto.
  + my_auto.
Defined.

Instance mem_dec w r : Decision (mem w r) := boolSpec_Decision (mem_fun_correct w r).

Definition memNat (n : nat) (r: range) := mem (Z_of_nat n) r. 
Definition memNat_fun n r : bool := mem_fun (Z_of_nat n) r.
Definition memNat_fun_correct n r : boolSpec (memNat_fun n r) (memNat n r) :=
  mem_fun_correct (Z_of_nat n) r.
Definition memNat_dec n r : Decision (memNat n r) :=
  boolSpec_Decision (memNat_fun_correct n r).
