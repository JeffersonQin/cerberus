open import Pervasives Num_extra

open import Utils
open import Core_ctype AilTypes AilTypesAux
open import Mem_common Defacto_memory_types2



type simpl_state = <|
(*
  min_eqs: map integerType integer_value_base;
  max_eqs: map integerType integer_value_base;
*)
  sizeof_eqs: map ctype integer_value_base;
  alignof_eqs: map ctype integer_value_base;
|>





val simplify_integer_value_base: simpl_state -> integer_value_base -> either integer integer_value_base
let rec simplify_integer_value_base st ival_ =
  let self = simplify_integer_value_base st in
  let proj = function
    | Left n ->
        IVconcrete n
    | Right ival_ ->
        ival_
  end in
  match ival_ with
    | IVunspecified ->
        Right ival_
    | IVconcurRead _ _ ->
        error "Defacto_aux.simplify_integer_value_base IVconcurRead"
    | IVconcrete n ->
        Left n
    | IVaddress _ ->
        Right ival_
(*
    | IVfromptr of ctype * AilTypes.integerType * pointer_value_base 
*)
    | IVop op [ival_1; ival_2] ->
        match (self ival_1, self ival_2) with
          | (Left n1, Left n2) ->
              Left match op with
                | IntAdd ->
                    n1 + n2
                | IntSub ->
                    n1 - n2
                | IntMul ->
                    n1 * n2
                | IntDiv ->
                    if n2 = 0 then 0 else Num_extra.integerDiv_t n1 n2
                | IntRem_t ->
                    if n2 = 0 then 0 else Num_extra.integerRem_t n1 n2
                | IntRem_f ->
                    if n2 = 0 then 0 else Num_extra.integerRem_f n1 n2
                | IntExp ->
                    n1 ** natFromInteger n2
              end
          | (Right IVunspecified, _) ->
              (* Axiom: unspec OP ival = unspec *)
              Right IVunspecified
          | (_, Right IVunspecified) ->
              (* Axiom: ival OP unspec = unspec *)
              Right IVunspecified
          | (simpl1, simpl2) ->
              let ival_1' = proj simpl1 in
              let ival_2' = proj simpl2 in
              (* TODO: Lem needs guard patterns *)
              if op = IntAdd && ival_1' = IVconcrete 0 then
                (* Axiom: 0 + ival = ival *)
                Right ival_2'
              else if op = IntAdd && ival_2' = IVconcrete 0 then
                (* Axiom: ival + 0 = ival *)
                Right ival_1'
              else if op = IntSub && ival_1' = ival_2' then
                (* Axiom: ival - ival = 0 *)
                Left 0
              else if op = IntMul && (ival_1' = IVconcrete 0 || ival_2' = IVconcrete 0) then
                Left 0
              else if op = IntDiv && (ival_1' = IVconcrete 0 || ival_2' = IVconcrete 0) then
                Left 0
              else
                Right (IVop op [ival_1'; ival_2'])
        end
    | IVmin ity ->
        if AilTypesAux.is_unsigned_ity ity then
          Left 0
        else
          Right ival_


(*

    | IVmax of AilTypes.integerType
    | IVsizeof ty ->
        maybe (Right ival_) Right (Map.lookup st.sizeof_eqs ty)
    | IValignof of ctype
    | IVoffsetof of Symbol.sym (*struct/union tag*)  * Cabs.cabs_identifier (*member*)
    | IVptrdiff of pointer_value_base * pointer_value_base
    | IVbyteof of integer_value_base * impl_mem_value (* the integer value is the position (indexed from zero) *)
    | IVcomposite of list integer_value_base (* a list of byte values reassembled *)
    | IVbitwise of AilTypes.integerType * bitwise_operation  end
*)
    | _ ->
        Right ival_
  end

(*
val mk_op_ival_: integer_operator -> integer_value_base -> integer_value_base -> integer_value_base
let mk_op_ival_ iop ival_1 ival_2 =
  either (fun z -> IVconcrete z) id (simplify_integer_value_base (IVop iop [ival_1; ival_2]))
*)

val simplify_integer_value: impl_integer_value -> impl_integer_value
let simplify_integer_value (IV prov ival_) =
  let tmp = <|
    sizeof_eqs= Map.empty;
    alignof_eqs= Map.empty;
  |> in
  IV prov (either IVconcrete id (simplify_integer_value_base tmp ival_))


val     simplify_constraint: mem_constraint impl_integer_value -> mem_constraint impl_integer_value
let rec simplify_constraint constr =
  match constr with
    | MC_empty ->
        constr
    | MC_eq ival1 ival2 ->
        MC_eq (simplify_integer_value ival1) (simplify_integer_value ival2)
    | MC_le ival1 ival2 ->
        MC_le (simplify_integer_value ival1) (simplify_integer_value ival2)
    | MC_lt ival1 ival2 ->
        MC_lt (simplify_integer_value ival1) (simplify_integer_value ival2)
    | MC_or constr1 constr2 ->
        MC_or (simplify_constraint constr1) (simplify_constraint constr2)
    | MC_conj constrs ->
        MC_conj (List.map simplify_constraint constrs)
    | MC_not constr ->
        MC_not (simplify_constraint constr)
  end
