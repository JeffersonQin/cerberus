open import Pervasives Num_extra

open import Utils
open import AilTypes AilTypesAux

open import Core_ctype
import Core_ctype_aux

open import Mem_common Defacto_memory_types2


val stringFromInteger_value: impl_integer_value -> string
declare ocaml target_rep function stringFromInteger_value = `String_defacto_memory.string_of_integer_value`



type simpl_state = <|
(*
  min_eqs: map integerType integer_value_base;
  max_eqs: map integerType integer_value_base;
*)
  sizeof_eqs: map ctype integer_value_base;
  alignof_eqs: map ctype integer_value_base;
|>




(*
val simplify_integer_value_base: simpl_state -> integer_value_base -> either integer integer_value_base
let rec simplify_integer_value_base st ival_ =
  let self = simplify_integer_value_base st in
  let proj = function
    | Left n ->
        IVconcrete n
    | Right ival_ ->
        ival_
  end in
  match ival_ with
    | IVunspecified ->
        Right ival_
    | IVconcurRead _ _ ->
        error "Defacto_aux.simplify_integer_value_base IVconcurRead"
    | IVconcrete n ->
        Left n
    | IVaddress _ ->
        Right ival_
(*
    | IVfromptr of ctype * AilTypes.integerType * pointer_value_base 
*)
    | IVop op [ival_1; ival_2] ->
        match (self ival_1, self ival_2) with
          | (Left n1, Left n2) ->
              Left match op with
                | IntAdd ->
                    n1 + n2
                | IntSub ->
                    n1 - n2
                | IntMul ->
                    n1 * n2
                | IntDiv ->
                    if n2 = 0 then 0 else Num_extra.integerDiv_t n1 n2
                | IntRem_t ->
                    if n2 = 0 then 0 else Num_extra.integerRem_t n1 n2
                | IntRem_f ->
                    if n2 = 0 then 0 else Num_extra.integerRem_f n1 n2
                | IntExp ->
                    n1 ** natFromInteger n2
              end
          | (Right IVunspecified, _) ->
              (* Axiom: unspec OP ival = unspec *)
              Right IVunspecified
          | (_, Right IVunspecified) ->
              (* Axiom: ival OP unspec = unspec *)
              Right IVunspecified
          | (simpl1, simpl2) ->
              let ival_1' = proj simpl1 in
              let ival_2' = proj simpl2 in
              (* TODO: Lem needs guard patterns *)
              if op = IntAdd && ival_1' = IVconcrete 0 then
                (* Axiom: 0 + ival = ival *)
                Right ival_2'
              else if op = IntAdd && ival_2' = IVconcrete 0 then
                (* Axiom: ival + 0 = ival *)
                Right ival_1'
              else if op = IntSub && ival_1' = ival_2' then
                (* Axiom: ival - ival = 0 *)
                Left 0
              else if op = IntMul && (ival_1' = IVconcrete 0 || ival_2' = IVconcrete 0) then
                Left 0
              else if op = IntDiv && (ival_1' = IVconcrete 0 || ival_2' = IVconcrete 0) then
                Left 0
              else
                Right (IVop op [ival_1'; ival_2'])
        end
    | IVmin ity ->
        match ity with
          | Char ->
              (* the sign of Char is implementation defined *)
              Right ival_
          | _ ->
              if AilTypesAux.is_unsigned_ity ity then
                Left 0
              else
                Right ival_
        end



(*

    | IVmax of AilTypes.integerType
    | IVsizeof ty ->
        maybe (Right ival_) Right (Map.lookup st.sizeof_eqs ty)
    | IValignof of ctype
    | IVoffsetof of Symbol.sym (*struct/union tag*)  * Cabs.cabs_identifier (*member*)
    | IVptrdiff of pointer_value_base * pointer_value_base
    | IVbyteof of integer_value_base * impl_mem_value (* the integer value is the position (indexed from zero) *)
    | IVcomposite of list integer_value_base (* a list of byte values reassembled *)
    | IVbitwise of AilTypes.integerType * bitwise_operation  end
*)
    | _ ->
        Right ival_
  end

(*
val mk_op_ival_: integer_operator -> integer_value_base -> integer_value_base -> integer_value_base
let mk_op_ival_ iop ival_1 ival_2 =
  either (fun z -> IVconcrete z) id (simplify_integer_value_base (IVop iop [ival_1; ival_2]))
*)

val simplify_integer_value: impl_integer_value -> impl_integer_value
let simplify_integer_value (IV prov ival_) =
  let tmp = <|
    sizeof_eqs= Map.empty;
    alignof_eqs= Map.empty;
  |> in
  IV prov (either IVconcrete id (simplify_integer_value_base tmp ival_))


val     simplify_constraint: mem_constraint impl_integer_value -> mem_constraint impl_integer_value
let rec simplify_constraint constr =
  match constr with
    | MC_empty ->
        constr
    | MC_eq ival1 ival2 ->
        MC_eq (simplify_integer_value ival1) (simplify_integer_value ival2)
    | MC_le ival1 ival2 ->
        MC_le (simplify_integer_value ival1) (simplify_integer_value ival2)
    | MC_lt ival1 ival2 ->
        MC_lt (simplify_integer_value ival1) (simplify_integer_value ival2)
    | MC_or constr1 constr2 ->
        MC_or (simplify_constraint constr1) (simplify_constraint constr2)
    | MC_conj constrs ->
        MC_conj (List.map simplify_constraint constrs)
    | MC_not constr ->
        MC_not (simplify_constraint constr)
  end
*)


let encode (nbits: nat) (n: integer) =
  if 0 <= n then
    n
  else
    (2 ** nbits) + n

let decode (nbits: nat) (n: integer) =
  if n <= 2 ** (nbits - 1) - 1 then
    n
  else
    n - (2 ** nbits)


val     tmp_compl_aux: nat -> integer -> integer
let rec tmp_compl_aux nbits n =
  if nbits = 0 then
    n
  else
    let n_ = n / 2 in
    (1 - (integerRem_f n 2)) + 2 * tmp_compl_aux (nbits - 1) n_

val tmp_compl: nat -> integer -> integer
let tmp_compl nbits n =
  decode nbits (tmp_compl_aux nbits (encode nbits n))


val     tmp_AND_aux: nat -> integer -> integer -> integer
let rec tmp_AND_aux nbits n1 n2 =
  if nbits = 0 then
    0
  else
    let n1_ = n1 / 2 in
    let n2_ = n2 / 2 in
    (if (integerRem_f n1 2) = 1 && (integerRem_f n2 2) = 1 then 1 else 0) + 2 * (tmp_AND_aux (nbits-1) n1_ n2_)


val     tmp_OR_aux: nat -> integer -> integer -> integer
let rec tmp_OR_aux nbits n1 n2 =
  if nbits = 0 then
    0
  else
    let n1_ = n1 / 2 in
    let n2_ = n2 / 2 in
    (if (integerRem_f n1 2) = 1 || (integerRem_f n2 2) = 1 then 1 else 0) + 2 * (tmp_OR_aux (nbits-1) n1_ n2_)


val     tmp_XOR_aux: nat -> integer -> integer -> integer
let rec tmp_XOR_aux nbits n1 n2 =
  if nbits = 0 then
    0
  else
    let n1_ = n1 / 2 in
    let n2_ = n2 / 2 in
    (if (integerRem_f n1 2) * (integerRem_f n2 2) = 0 &&
        not ((integerRem_f n1 2) + (integerRem_f n2 2) = 0) then 1 else 0) + 2 * (tmp_XOR_aux (nbits-1) n1_ n2_)


val tmp_AND: nat -> integer -> integer -> integer
val tmp_OR:  nat -> integer -> integer -> integer
val tmp_XOR: nat -> integer -> integer -> integer

let tmp_AND width n1 n2 =
  let nbits = 8 * width in
  decode nbits (tmp_AND_aux nbits (encode nbits n1) (encode nbits n2))

let tmp_OR width n1 n2 =
  let nbits = 8 * width in
  let n1_ = encode nbits n1 in
  let n2_ = encode nbits n2 in
  let () = Debug.print_debug 0 [] (fun () ->
    "nbits= " ^ show nbits ^ ", n1 = " ^ show n1 ^ " -- n1_= " ^ show n1_
  ) in
  let () = Debug.print_debug 0 [] (fun () ->
    "nbits= " ^ show nbits ^ ", n2 = " ^ show n2 ^ " -- n2_= " ^ show n2_
  ) in
  decode nbits (tmp_OR_aux nbits n1_ n2_)

let tmp_XOR width n1 n2 =
  let nbits = 8 * width in
  decode nbits (tmp_XOR_aux nbits (encode nbits n1) (encode nbits n2))


let rec simplify_integer_value_base ival_ =
  let lifted_self x =
    either (fun n -> IVconcrete n) (fun z -> z) (simplify_integer_value_base x) in
    match ival_ with
      | IVunspecified ->
          Right ival_
      | IVconcurRead _ _ ->
          Right ival_
      | IVconcrete n ->
          Left n
      | IVaddress alloc_id ->
          Right ival_
      | IVfromptr ty ity ptrval ->
          (* TODO *)
          Right ival_
    | IVop iop [ival_1; ival_2] ->
        let num_op = match iop with
          | IntAdd ->
              (+)
          | IntSub ->
              (-)
          | IntMul ->
              ( * )
          | IntDiv ->
              fun x y -> if y = 0 then 0 else integerDiv_t x y
          | IntRem_t ->
              fun x y -> if y = 0 then 0 else integerRem_t x y
          | IntRem_f ->
              fun x y -> if y = 0 then 0 else integerRem_f x y
          | IntExp ->
              fun x y -> x ** natFromInteger y
        end in
        match (simplify_integer_value_base ival_1, simplify_integer_value_base ival_2) with
          | (Left n1, Left n2) ->
              Left (num_op n1 n2)
          | (x, y) ->
              let f = either (fun z -> IVconcrete z) (fun z -> z) in
              Right (IVop iop [f x; f y])
        end
    | IVop _ _ ->
        (* Core type error *)
        error "Defacto_memory_aux2.simplify_integer_value_base, IVop: Core type error"
    | IVmin ity ->
        match ity with
          | Char ->
              if Implementation_.char_is_signed then
                Left (0 - (2 ** (8-1)))
              else
                Left 0
          | Bool ->
              (* this type is unsigned *)
              Left 0
          | Size_t ->
              (* this type is unsigned *)
              Left 0
          | Unsigned _ ->
              Left 0
          | Ptrdiff_t ->
              (* this type is signed *)
              match Implementation_.sizeof_ity ity with
                | Just n ->
                    Left (0 - (2 ** (8*n-1)))
                | Nothing ->
                    Right ival_
              end
          | Signed _ ->
              match Implementation_.sizeof_ity ity with
                | Just n ->
                    Left (0 -  (2 ** (8*n-1)))
                | Nothing ->
                    Right ival_
              end
          | Enum _ ->
              error "IVmin Enum"
          | IBuiltin _ ->
              error "IVmin IBuiltin"
        end
    | IVmax ity ->
        match Implementation_.sizeof_ity ity with
          | Just n ->
              let signed_max   = (2 ** (8*n-1))  - 1 in
              let unsigned_max = (2 ** (8*n))  - 1   in
              match ity with
                | Char ->
                    Left (if Implementation_.char_is_signed then
                      signed_max
                    else
                      unsigned_max)
                | Bool ->
                    (* TODO: not sure about this (maybe it should be 1 and not 255? *)
                    Left unsigned_max
                | Size_t ->
                    Left unsigned_max
                | Unsigned _ ->
                    Left unsigned_max
                | Ptrdiff_t ->
                    Left signed_max
                | Signed _ ->
                    Left signed_max
                | Enum _ ->
                    error "IVmax Enum"
                | IBuiltin _ ->
                    error "IVmax IBuiltin"
              end
          | Nothing ->
              Right ival_
        end
    | IVsizeof ty ->
        match ty with
          | Core_ctype.Void ->
              (* Ail type error *)
              error "Defacto_memory_aux2.simplify_integer_value_base, IVsizeof Void"
          | Core_ctype.Basic (Integer ity) ->
              match Implementation_.sizeof_ity ity with
                | Just n ->
                    Left (integerFromNat n)
                | Nothing ->
                    Right ival_
              end
          | Core_ctype.Basic (Floating fty) ->
              match Implementation_.sizeof_fty fty with
                | Just n ->
                    Left (integerFromNat n)
                | Nothing ->
                    Right ival_
              end
          | Core_ctype.Array elem_ty Nothing ->
              (* Ail type error *)
              error "Defacto_memory_aux2.simplify_integer_value_base, IVsizeof Array Nothing"
          | Core_ctype.Array elem_ty (Just n) ->
              simplify_integer_value_base (IVop IntMul [IVsizeof elem_ty; IVconcrete n])
          | Core_ctype.Function _ _ _ ->
              (* Ail type error *)
              error "Defacto_memory_aux2.simplify_integer_value_base, IVsizeof Function"
          | Core_ctype.Pointer _ ref_ty ->
              Left 8
          | Core_ctype.Atomic atom_ty ->
              simplify_integer_value_base (IVsizeof atom_ty)
          | Core_ctype.Struct tag_sym ->
              let Core_ctype.StructDef membrs = Core_ctype_aux.get_membersDefs tag_sym in
              simplify_integer_value_base begin
                List.foldl (fun acc (ident, ty) ->
                  IVop IntAdd [ lifted_self (IVsizeof ty);
                                IVop IntAdd [IVpadding tag_sym ident; acc] ]
                ) (IVconcrete 0) membrs
              end
          | Core_ctype.Union tag_sym ->
              error "TODO simplify_integer_value: IVsizeof Union"
          | Core_ctype.Builtin str ->
              error "TODO simplify_integer_value: IVsizeof Builtin"
        end
    | IValignof ty ->
        match ty with
          | Core_ctype.Void ->
              (* Ail type error *)
              error "Defacto_memory_aux2.simplify_integer_value_base, IValignof Void"
          | Core_ctype.Basic (Integer ity) ->
              match Implementation_.alignof_ity ity with
                | Just n ->
                    Left (integerFromNat n)
                | Nothing ->
                    Right ival_
              end
          | Core_ctype.Basic (Floating fty) ->
              match Implementation_.alignof_fty fty with
                | Just n ->
                    Left (integerFromNat n)
                | Nothing ->
                    Right ival_
              end
          | Core_ctype.Array elem_ty _ ->
              simplify_integer_value_base (IValignof elem_ty)
          | Core_ctype.Function _ _ _ ->
              (* Ail type error *)
              error "Defacto_memory_aux2.simplify_integer_value_base, IValignof Function"
          | Core_ctype.Pointer _ ref_ty ->
              Left 8
          | Core_ctype.Atomic atom_ty ->
              simplify_integer_value_base (IValignof atom_ty)
          | Core_ctype.Struct tag_sym ->
              (* TODO *)
              Right ival_
          | Core_ctype.Union tag_sym ->
              error "TODO simplify_integer_value: IValignof Union"
          | Core_ctype.Builtin str ->
              error "TODO simplify_integer_value: IValignof Builtin"
        end
    | IVpadding _ _ ->
        Right ival_
    | IVptrdiff ty ptrval1 ptrval2 ->
        (* TODO: check *)
        Right ival_

    | IVbyteof _ _ ->
        error "TODO: Defacto_memory_aux2.simplify_integer_value_base, IVbyteof"
    | IVcomposite _ ->
        error "TODO: Defacto_memory_aux2.simplify_integer_value_base, IVcomposite"
    | IVbitwise ity (BW_complement ival_1) ->
        match (Implementation_.sizeof_ity ity, simplify_integer_value_base ival_1) with
          | (Just w, Left n1) ->
              Left (tmp_compl w n1)
          | (_, Left n1) ->
              Right (IVbitwise ity (BW_complement (IVconcrete n1)))
          | (_, Right ival_1') ->
              Right (IVbitwise ity (BW_complement ival_1'))
        end
    | IVbitwise ity (BW_AND ival_1 ival_2) ->
        match (Implementation_.sizeof_ity ity, simplify_integer_value_base ival_1, simplify_integer_value_base ival_2) with
          | (Just w, Left n1, Left n2) ->
              Left (tmp_AND w n1 n2)
          | (_, x, y) ->
              let f = either (fun z -> IVconcrete z) (fun z -> z) in
              Right (IVbitwise ity (BW_AND (f x) (f y)))
        end
    | IVbitwise ity (BW_OR ival_1 ival_2) ->
        match (Implementation_.sizeof_ity ity, simplify_integer_value_base ival_1, simplify_integer_value_base ival_2) with
          | (Just w, Left n1, Left n2) ->
              Left (tmp_OR w n1 n2)
          | (_, x, y) ->
              let f = either (fun z -> IVconcrete z) (fun z -> z) in
              Right (IVbitwise ity (BW_OR (f x) (f y)))
        end
    | IVbitwise ity (BW_XOR ival_1 ival_2) ->
        match (Implementation_.sizeof_ity ity, simplify_integer_value_base ival_1, simplify_integer_value_base ival_2) with
          | (Just w, Left n1, Left n2) ->
              Left (tmp_XOR w n1 n2)
          | (_, x, y) ->
              let f = either (fun z -> IVconcrete z) (fun z -> z) in
              Right (IVbitwise ity (BW_XOR (f x) (f y)))
        end
  end

let rec lifted_simplify_integer_value_base ival_ =
  either (fun n -> IVconcrete n) (fun z -> z) (simplify_integer_value_base ival_)
