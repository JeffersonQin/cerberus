open import Pervasives Cabs Std
import Boot Errors Scope_table State_exception UniqueId Symbol
import AilSyntax AilTypes

module A      = AilSyntax
module ATypes = AilTypes



(* STD §6.2.1#1, sentence 1 *)
type identifier_kind =
  (* the boolean is true iff we are dealing with a function parameter (needed to determinate the linkage ...) *)
    (* TODO: should be a different ctor, but using a bool for now to make sure all the occurences
             of the normal Kind_object also apply to `Kind_parameter_object' *)
  (* TODO: putting the qualifiers and ctype here is a hack, to remove *)
  | Kind_object of bool * ATypes.qualifiers * ATypes.ctype
  | Kind_function
  | Kind_tag
  | Kind_member
  | Kind_typedef
  | Kind_label
(*
  | Kind_macro_name
  | Kind_macro_parameter
*)

val is_object_kind: identifier_kind -> bool
let is_object_kind = function
  | Kind_object _ _ _ -> true
  | _                 -> false
end

val is_parameter_object_kind: identifier_kind -> bool
let is_parameter_object_kind = function
  | Kind_object true _ _ -> true
  | _                    -> false
end



(* STD §6.2.1#2 *)
type scope =
  | Scope_function
  | Scope_file
  | Scope_block
  | Scope_prototype


(* STD §6.2.2#1 *)
type linkage =
  | Linkage_external
  | Linkage_internal
  | Linkage_none


(* STD §6.2.3#1 *)
type namespace =
  | Namespace_label
  | Namespace_tag
  | Namespace_member of cabs_identifier
  | Namespace_ordinary







type state = <|
  (* Counter for the symbol generator *)
  symbol_counter: UniqueId.supply Symbol.t;
  (* table (with stacked scopes) associating C identifiers to symbols *)
  
  registered_identifiers: Scope_table.t scope (cabs_identifier * namespace) (A.identifier * identifier_kind * linkage);
  enumeration_constants: map cabs_identifier (A.identifier * A.expression unit);
  registered_declarations: list (A.sigma_declaration Location.t unit);

  
  (* TODO: think about it; thought about it and don't like it anymore *)
(*  scopes: list scope; *)


  current_return_type : ATypes.ctype;
|>

type t 'a = State_exception.t 'a state Errors.t

val return: forall 'a. 'a -> t 'a
let return = State_exception.return

val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
let bind = State_exception.bind


val fail: forall 'a. Errors.desugar_cause -> t 'a
let fail dcause = State_exception.fail (Location.dummy, Errors.Desugar_cause dcause) (* TODO: location *)



val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
let mapM = State_exception.mapM
let mapM_ = State_exception.mapM_

let foldrM = State_exception.foldrM

let iter = State_exception.iter

val tryWith: forall 'a. Errors.t -> t 'a -> t 'a
let tryWith = State_exception.tryWith


val fmap: forall 'a 'b. ('a -> 'b) -> t 'a -> t 'b
let fmap = State_exception.fmap

val app: forall 'a 'b. t ('a -> 'b) -> t 'a -> t 'b
let app  = State_exception.app


let inline (>>=)    = bind
let inline (>>) m f = m >>= fun _ -> f
let inline (<$>)    = fmap
let inline (<*>)    = app


val void: forall 'a. t 'a -> t unit
let void m =
  fmap (const ()) m


val guard: forall 'a. t bool -> string -> t 'a -> t 'a
let guard m_pred err_msg m =
  m_pred >>= function
    | true  -> m
    | false -> Boot.assert_false ("[Cabs_to_ail_effect] failed guard: " ^ err_msg ^ ".")
  end


(* ========================================================================== *)
val current_scope_is: scope -> t bool
let current_scope_is scope =
  State_exception.read (fun st -> Scope_table.current_scope_is st.registered_identifiers = scope)


val get_scope: t scope
let get_scope =
  State_exception.read (fun st -> Scope_table.current_scope_is st.registered_identifiers)


(* TODO: revert this to simply return a `a, and add a collect_bindings function *)
val with_scope: forall 'a. scope -> t 'a -> t (A.bindings * 'a)
let with_scope scope m =
  State_exception.update (fun st ->
    <| st with registered_identifiers= Scope_table.create_scope scope st.registered_identifiers |>
  ) >>
  m >>= fun res ->
  State_exception.modify (fun st ->
    let (idents_map, scope_table') = Scope_table.destroy_scope st.registered_identifiers in
    (Set_extra.toList (Map.toSet idents_map), <| st with registered_identifiers= scope_table' |>)
  ) >>= fun xs ->
  
  let bs = List.foldr (fun (_, (sym, kind, _)) acc ->
    match kind with
      | Kind_object _ qs ty ->
          (sym, (qs, ty)) :: acc
      (* TODO: functions *)
      | _ ->
          acc
    end
  ) [] xs in
  return (bs, res)



(* ========================================================================== *)
val initial_state: state
let initial_state = <|
  symbol_counter=          UniqueId.new_supply;
  registered_identifiers=  Scope_table.empty;
  enumeration_constants=   Map.empty;
  
  registered_declarations= [];
  
(*  scopes= []; *)
  
  current_return_type= ATypes.Void (* TODO: this is morally wrong *)
|>

val eval: forall 'a. t 'a -> Exception.t (UniqueId.supply Symbol.t * 'a) Errors.t
let eval m =
  State_exception.eval (
    m                                                  >>= fun res     ->
    State_exception.read (fun st -> st.symbol_counter) >>= fun counter ->
    return (counter, res)
    ) initial_state




(* ========================================================================== *)
val is_in_scope: cabs_identifier -> namespace -> t bool
let is_in_scope ident namespace =
  State_exception.read (fun st ->
    Scope_table.is_in_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )


val is_in_current_scope: cabs_identifier -> namespace -> t bool
let is_in_current_scope ident namespace =
  State_exception.read (fun st ->
    Scope_table.is_in_current_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )

(* NOTE: this function shouldn't be called outside of the current module *)
val _register_identifier : cabs_identifier -> namespace -> identifier_kind -> linkage -> t A.identifier
let _register_identifier ident namespace kind link =
  State_exception.read (fun st ->
    Scope_table.is_in_current_scope (ident, namespace) st.registered_identifiers
  ) >>= function
    | true ->
        if link = Linkage_none then
          (* TODO: typedef, tags (see §6.7#3 "except that ...") *)
          fail (Errors.Desugar_MultibleDeclaration ident)
        else
          return ()
    | false ->
        return ()
  end >>
  
  (* generates a fresh symbol *)
  State_exception.modify (fun st ->
    let (sym, symbol_counter) = Symbol.fresh_pretty ident st.symbol_counter in
    (sym, <| st with symbol_counter = symbol_counter |>)
  ) >>= fun sym ->
  (* associates it to the identifier *)
  State_exception.update (fun st ->
    let _ = Boot.output_string ("registering " ^ ident) in

    <| st with registered_identifiers= Scope_table.register (ident, namespace) (sym, kind, link) st.registered_identifiers |>
  ) >>
  return sym


val resolve_identifier: cabs_identifier -> namespace -> t (maybe (scope * (A.identifier * identifier_kind * linkage)))
let resolve_identifier ident namespace =
  State_exception.read (fun st ->
    Scope_table.resolve (ident, namespace) st.registered_identifiers
  )


val     determinate_linkage: cabs_identifier -> namespace -> identifier_kind -> list storage_class_specifier -> t linkage
let rec determinate_linkage ident namespace kind storage_classes =
  get_scope >>= fun scope ->
  match (scope, kind, List.delete SC_Thread_local storage_classes) with
    | (Scope_file, Kind_object false _ _, [SC_static]) ->
_STD "§6.2.2#3" $
        return Linkage_internal
    
    | (Scope_file, Kind_function, [SC_static]) ->
_STD "§6.2.2#3" $
        return Linkage_internal
    
    | (_, _, [SC_extern]) ->
_STD "§6.2.2#4" $
        resolve_identifier ident namespace >>= function
          | Just (_, (_, _, link)) ->
              if link = Linkage_internal || link = Linkage_external then
                return link
              else
                return Linkage_external
          | Nothing ->
              return Linkage_external
        end
    
    | (_, Kind_function, []) ->
_STD "§6.2.2#5, sentence 1" $
        determinate_linkage ident namespace kind [SC_extern]
    
    | (Scope_file, Kind_object false _ _, []) ->
_STD "§6.2.2#5, sentence 2" $
        return Linkage_external
    
    | (_, _, storage_class) ->
_STD "§6.2.2#6" $
        if    not (is_object_kind kind || kind = Kind_function)
           || is_parameter_object_kind kind (* identifier declared to be a function parameter *)
           || scope = Scope_block && is_object_kind kind && storage_class <> [SC_extern] then
          return Linkage_none
        else
          Boot.assert_false "[Cabs_to_ail_effect.determinate_linkage] unknown case"
  end


val register_identifier: cabs_identifier -> namespace -> identifier_kind -> list storage_class_specifier -> t A.identifier
let register_identifier ident namespace kind storage_classes =
  determinate_linkage ident namespace kind storage_classes >>=
  _register_identifier ident namespace kind

(*
val register_function_parameter: cabs_identifier -> identifier_kind -> list storage_class_specifier -> t A.identifier
let register_function_parameter ident kind storage_classes =
_STD "§6.2.2#6" $
  _register_identifier ident Namespace_ordinary kind Linkage_none
*)






















(*
val resolve_identifier: cabs_identifier -> t (A.identifier * identifier_kind * linkage)
let resolve_identifier name =
  bind (State_exception.read (fun st -> Scope_table.lookup name st.registered_identifiers))
    function
      | Just x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end
*)













val register_declaration: A.sigma_declaration Location.t unit -> t unit
let register_declaration decl =
  State_exception.update (fun st ->
    <| st with registered_declarations= decl :: st.registered_declarations |>
  )

val resolve_declarations: t (list (A.sigma_declaration Location.t unit))
let resolve_declarations =
  State_exception.read (fun st ->
    st.registered_declarations
  )








val get_typedef: string -> t (ATypes.qualifiers * ATypes.ctype)
let get_typedef id =
  Boot.assert_false "TODO"


val register_label: cabs_identifier -> t unit
let register_label ident =
  void (_register_identifier ident Namespace_label Kind_label Linkage_none)

val resolve_label: cabs_identifier -> t A.identifier
let resolve_label ident =
  (* TODO: §6.8.6.1#1 *)
  resolve_identifier ident Namespace_label >>= function
    | Just (_, (sym ,_, _)) ->
        return sym
    | Nothing ->
        fail (Errors.Desugar_OtherViolation "§6.8.6.1#1, sentence 1")
  end


(* Returns the return type of the function currently being desugared *)
(* val get_current_return_type: t ATypes.ctype *)
let get_current_return_type: t ATypes.ctype =
  State_exception.read (fun st ->
    st.current_return_type
  )

let set_current_return_type (ty: ATypes.ctype) : t unit =
  State_exception.update (fun st ->
    <| st with current_return_type= ty |>
  )


val perform_inside_switch: forall 'a. t 'a ->  t 'a
let perform_inside_switch m =
  (* TODO *)
  m


val perform_inside_loop: forall 'a. t 'a -> t 'a
let perform_inside_loop m =
  (* TODO *)
  m



(* val is_switch_body: t bool *)
let is_switch_body: t bool =
  (* TODO *)
  return false

(* val is_loop_body: t bool *)
let is_loop_body: t bool =
  (* TODO *)
  return false
