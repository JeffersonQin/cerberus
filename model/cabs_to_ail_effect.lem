open import Pervasives Cabs Std
import Boot Errors Scope_table State_exception UniqueId Symbol

import Global
import AilSyntax AilTypes

import Map_extra

module A      = AilSyntax
module ATypes = AilTypes



type tag_declaration =
  | Struct_declaration of list (Cabs.cabs_identifier * ATypes.ctype)
  | Union_declaration of list (Cabs.cabs_identifier * ATypes.ctype)
  | Enum_declaration (* TODO *)


(* STD ยง6.2.1#1, sentence 1 *)
type identifier_kind =
  (* the boolean is true iff we are dealing with a function parameter (needed to determinate the linkage ...) *)
    (* TODO: should be a different ctor, but using a bool for now to make sure all the occurences
             of the normal Kind_object also apply to `Kind_parameter_object' *)
  | Kind_object of bool

  | Kind_function
  (* TODO: putting the struct/union definition here is a bit of a hack *)
  | Kind_tag
  | Kind_member
  | Kind_typedef
  | Kind_label
(*
  | Kind_macro_name
  | Kind_macro_parameter
*)

val is_object_kind: identifier_kind -> bool
let is_object_kind = function
  | Kind_object _ -> true
  | _             -> false
end

val is_parameter_object_kind: identifier_kind -> bool
let is_parameter_object_kind = function
  | Kind_object true -> true
  | _                -> false
end




(* STD ยง6.2.1#2 *)
type scope =
  | Scope_function
  | Scope_file
  | Scope_block
  | Scope_prototype

(* TODO DEBUG *)
let string_of_scope = function
  | Scope_function ->
      "function"
  | Scope_file ->
      "file"
  | Scope_block ->
      "block"
  | Scope_prototype ->
      "prototype"
end


(* STD ยง6.2.2#1 *)
type linkage =
  | Linkage_external
  | Linkage_internal
  | Linkage_none


(* STD ยง6.2.3#1 *)
type namespace =
  | Namespace_label
  | Namespace_tag
  | Namespace_member of cabs_identifier
  | Namespace_ordinary


type state = <|
  (* Counter used to generate fresh cabs label names (see the desugaring of do-while statements) *)
  aux_supply: UniqueId.supply nat;
  (* Counter for the symbol generator *)
  symbol_supply: UniqueId.supply Symbol.t;
  (* table (with stacked scopes) associating C identifiers to symbols *)
  
  (* IMPORTANT: the two scope tables must be updated in sync *)
  registered_identifiers:      Scope_table.t scope (cabs_identifier * namespace) (A.identifier * identifier_kind * linkage);
  registered_tag_declarations: Scope_table.t scope A.identifier tag_declaration;
  
                                                (* return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  function_declarations:        map A.identifier (ATypes.ctype * (list (ATypes.qualifiers * ATypes.ctype)) * bool * bool * bool);
  external_object_declarations: map A.identifier  (ATypes.qualifiers * ATypes.ctype);
  internal_object_declarations: map A.identifier  (ATypes.qualifiers * ATypes.ctype);
  
  function_definitions: map A.identifier (list A.identifier * A.statement Location.t unit);
  external_object_definitions: map A.identifier (A.expression unit);
  
  (* TODO: I really don't like the potential lack of sync between the next field and registered_identifiers *)
  typedef_definitions: map A.identifier (ATypes.qualifiers * ATypes.ctype);
  
  static_assertions: list (A.expression unit * A.stringLiteral);
  
  enumeration_constants: map cabs_identifier (A.identifier * A.expression unit);
  
  (* TODO: this is idiotically inefficient, should store here the converse *)
  (* list the object/functions actually used, so that we can forget everything else that is declared/defined.
     This is particularly useful when stdlib headers are included *)
  used_identifier: list A.identifier;
  current_return_type : ATypes.ctype;
  
  is_inside_loop:   bool;
  is_inside_switch: bool;
|>

type t 'a = State_exception.t 'a state Errors.t

val return: forall 'a. 'a -> t 'a
let return = State_exception.return

val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
let bind = State_exception.bind


val fail: forall 'a. Errors.desugar_cause -> t 'a
let fail dcause = State_exception.fail (Location.unknown, Errors.Desugar_cause dcause) (* TODO: location *)



val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
let mapM = State_exception.mapM
let mapM_ = State_exception.mapM_

let foldlM = State_exception.foldlM
let foldrM = State_exception.foldrM

let iter = State_exception.iter

val tryWith: forall 'a. Errors.t -> t 'a -> t 'a
let tryWith = State_exception.tryWith


val fmap: forall 'a 'b. ('a -> 'b) -> t 'a -> t 'b
let fmap = State_exception.fmap

val app: forall 'a 'b. t ('a -> 'b) -> t 'a -> t 'b
let app  = State_exception.app


let inline (>>=)    = bind
let inline (>>) m f = m >>= fun _ -> f
let inline (<$>)    = fmap
let inline (<*>)    = app


val void: forall 'a. t 'a -> t unit
let void m =
  fmap (const ()) m


val guard: forall 'a. t bool -> string -> t 'a -> t 'a
let guard m_pred err_msg m =
  m_pred >>= function
    | true  -> m
    | false -> Boot.assert_false ("[Cabs_to_ail_effect] failed guard: " ^ err_msg ^ ".")
  end


(* ========================================================================== *)
val current_scope_is: scope -> t bool
let current_scope_is scope =
  (* NOTE: it would be equivalent to use [registered_tag_declarations] *)
  State_exception.read (fun st -> Scope_table.current_scope_is st.registered_identifiers = scope)


val get_scope: t scope
let get_scope =
  (* NOTE: it would be equivalent to use [registered_tag_declarations] *)
  State_exception.read (fun st -> Scope_table.current_scope_is st.registered_identifiers)


(* TODO: revert this to simply return a `a, and add a collect_bindings function *)
val with_scope: forall 'a. scope -> t 'a -> t (A.bindings * 'a)
let with_scope scope m =
  State_exception.update (fun st ->
    let _ = Boot.output_string ("ENTERING Scope: " ^ string_of_scope scope) in
    
    <| st with registered_identifiers=      Scope_table.create_scope scope st.registered_identifiers;
               registered_tag_declarations= Scope_table.create_scope scope st.registered_tag_declarations |>
  ) >>
  m >>= fun res ->
  State_exception.modify (fun st ->
    let (idents_map, ident_table'  ) = Scope_table.destroy_scope st.registered_identifiers      in
    let (_         , tagDecl_table') = Scope_table.destroy_scope st.registered_tag_declarations in
    
    let _ = Boot.output_string ("EXITING Scope: " ^ string_of_scope scope) in
    
    (Set_helpers.fold (fun (sym, kind, _) acc ->
      match kind with
        | Kind_object false ->
            match Map.lookup sym st.external_object_declarations with
              | Just (qs, ty) ->
                  (sym, (qs, ty)) :: acc
              | Nothing ->
                  match Map.lookup sym st.internal_object_declarations with
                    | Just (qs, ty) ->
                        (sym, (qs, ty)) :: acc
                    | Nothing ->
                        (* TODO: check *)
                        acc
                  end
            end
        | _ ->
            (* TODO: functions *)
            acc
      end
    ) (Map.range idents_map) [],
    
    <| st with registered_identifiers=      ident_table';
               registered_tag_declarations= tagDecl_table' |>)
  ) >>= fun bs ->
  return (bs, res)



(* ========================================================================== *)
val initial_state: state
let initial_state = <|
  aux_supply=                  UniqueId.new_supply;
  symbol_supply=               UniqueId.new_supply;
  registered_identifiers=      Scope_table.empty;
  registered_tag_declarations= Scope_table.empty;
  enumeration_constants=       Map.empty;
  
  function_declarations=        Map.empty;
  external_object_declarations= Map.empty;
  internal_object_declarations= Map.empty;
  
  function_definitions=        Map.empty;
  external_object_definitions= Map.empty;
  typedef_definitions=         Map.empty;
  static_assertions=           [];
  
  used_identifier= [];
  current_return_type= ATypes.Void; (* TODO: this is morally wrong *)
  
  is_inside_loop=   false;
  is_inside_switch= false;
|>

val eval: forall 'a. t 'a -> Exception.t (UniqueId.supply Symbol.t * 'a) Errors.t
let eval m =
  State_exception.eval (
    m                                                 >>= fun res    ->
    State_exception.read (fun st -> st.symbol_supply) >>= fun supply ->
    return (supply, res)
    ) initial_state




(* ========================================================================== *)
val ident_is_in_scope: cabs_identifier -> namespace -> t bool
let ident_is_in_scope ident namespace =
  State_exception.read (fun st ->
    Scope_table.is_in_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )


val ident_is_in_current_scope: cabs_identifier -> namespace -> t bool
let ident_is_in_current_scope ident namespace =
  State_exception.read (fun st ->
    Scope_table.is_in_current_scope (ident, namespace) (Scope_table.return_scope st.registered_identifiers)
  )

(*
val register_unamed_struct_union_enum: tag_declaration -> t A.identifier
let register_unamed_struct_union_enum =
  (* generates a fresh symbol *)
  State_exception.modify (fun st ->
    let (sym, symbol_supply) = Symbol.fresh st.symbol_supply in
    (sym, <| st with symbol_supply = symbol_supply |>)
  ) >>= fun tag_sym ->
  (* associates it to the identifier *)
  State_exception.update (fun st ->
    <| st with registered_identifiers= Scope_table.register (tag_sym, Namespace_tag) (tag_sym, kind, link) st.registered_identifiers |>
  ) >>
  return sym
*)


(* NOTE: this function shouldn't be called outside of the current module *)
val _register_identifier : cabs_identifier -> namespace -> identifier_kind -> linkage -> t A.identifier
let _register_identifier ident namespace kind link =
  State_exception.read (fun st ->
    Scope_table.is_in_current_scope (ident, namespace) st.registered_identifiers
  ) >>= function
    | true ->
        if link = Linkage_none then
          (* ยง6.7#3 "except that ..." *)
          if kind = Kind_typedef then
            Boot.assert_false "WIP Kind_typedef"
          else if kind = Kind_tag then
            Boot.assert_false "WIP Kind_tag"
          else
            fail (Errors.Desugar_MultibleDeclaration ident)
        else
          return ()
    | false ->
        return ()
  end >>
  
  (* generates a fresh symbol *)
  State_exception.modify (fun st ->
    let (sym, symbol_supply) = Symbol.fresh_pretty ident st.symbol_supply in
    (sym, <| st with symbol_supply = symbol_supply |>)
  ) >>= fun sym ->
  (* associates it to the identifier *)
  State_exception.update (fun st ->
    <| st with registered_identifiers= Scope_table.register (ident, namespace) (sym, kind, link) st.registered_identifiers |>
  ) >>
  return sym


val resolve_identifier: cabs_identifier -> namespace -> t (maybe (scope * (A.identifier * identifier_kind * linkage)))
let resolve_identifier ident namespace =
  State_exception.read (fun st ->
    Scope_table.resolve (ident, namespace) st.registered_identifiers
  )


val     determinate_linkage: cabs_identifier -> namespace -> identifier_kind -> list storage_class_specifier -> t linkage
let rec determinate_linkage ident namespace kind storage_classes =
  get_scope >>= fun scope ->
  match (scope, kind, List.delete SC_Thread_local storage_classes) with
    | (Scope_file, Kind_object false, [SC_static]) ->
_STD "ยง6.2.2#3" $
        return Linkage_internal
    
    | (Scope_file, Kind_function, [SC_static]) ->
_STD "ยง6.2.2#3" $
        return Linkage_internal
    
    | (_, _, [SC_extern]) ->
_STD "ยง6.2.2#4" $
        resolve_identifier ident namespace >>= function
          | Just (_, (_, _, link)) ->
              if link = Linkage_internal || link = Linkage_external then
                return link
              else
                return Linkage_external
          | Nothing ->
              return Linkage_external
        end
    
    | (_, Kind_function, []) ->
_STD "ยง6.2.2#5, sentence 1" $
        determinate_linkage ident namespace kind [SC_extern]
    
    | (Scope_file, Kind_object false, []) ->
_STD "ยง6.2.2#5, sentence 2" $
        return Linkage_external
    
    | (_, _, storage_class) ->
_STD "ยง6.2.2#6" $
        if    not (is_object_kind kind || kind = Kind_function)
           || is_parameter_object_kind kind (* identifier declared to be a function parameter *)
           || scope = Scope_block && is_object_kind kind && storage_class <> [SC_extern] then
          return Linkage_none
        else
          Boot.assert_false "[Cabs_to_ail_effect.determinate_linkage] unknown case"
  end


val register_identifier: cabs_identifier -> namespace -> identifier_kind -> list storage_class_specifier -> t A.identifier
let register_identifier ident namespace kind storage_classes =
  determinate_linkage ident namespace kind storage_classes >>=
  _register_identifier ident namespace kind

(*
val register_function_parameter: cabs_identifier -> identifier_kind -> list storage_class_specifier -> t A.identifier
let register_function_parameter ident kind storage_classes =
_STD "ยง6.2.2#6" $
  _register_identifier ident Namespace_ordinary kind Linkage_none
*)






















(*
val resolve_identifier: cabs_identifier -> t (A.identifier * identifier_kind * linkage)
let resolve_identifier name =
  bind (State_exception.read (fun st -> Scope_table.lookup name st.registered_identifiers))
    function
      | Just x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end
*)








(* TODO: move somewhere else *)
(* 
TODO: HIP


val     sigma_declarations_insert: forall 'a 'b. A.sigma_declaration 'a 'b -> A.sigma 'a 'b -> A.sigma 'a 'b
let rec sigma_declarations_insert decl decls =
  match (decl, decls) with
    | (_, []) ->
        []
    | (A.SDecl_fun ident fun_decl, [A.SDecl_fun ident' fun_decl']

 function
  | [] ->
      []
  | ((ident', _) as  :: xs ->
      if ident = ident' then
        (ident, decl) :: xs
      else
        (ident', decl') :: sigma_declarations_insert k v xs
end
*)


(*
val register_declaration: A.sigma_declaration Location.t unit -> t unit
let register_declaration decl =
  let ident = match decl with
    | A.SDecl_fun ident _ ->
        ident
    | A.SDecl_global ident _ ->
        ident
    | _ ->
        Boot.assert_false "register_declaration: found a static_assert"
  end in
  
  (* TODO: detect multiple definitions *)
  
  State_exception.update (fun st ->
    <| st with registered_declarations= (* assoc_insert ident decl *) decl :: st.registered_declarations |>
  )

val resolve_declarations: t (list (A.sigma_declaration Location.t unit))
let resolve_declarations =
  State_exception.read (fun st ->
    st.registered_declarations
  )
*)


(* NOTE: no check for redefinition is made here *)
val register_external_object_definition: A.identifier -> A.expression unit -> t unit
let register_external_object_definition sym e =
  (* this guard makes sure we are indeed registering the definition of an
     external object (ยง6.9.2#1) *)
  guard (current_scope_is Scope_file) "register_external_object_definition not in File scope" $
    State_exception.update (fun st ->
      <| st with external_object_definitions= Map.insert sym e st.external_object_definitions |>
    )


(* NOTE: no check for redefinition is made here *)
val register_function_definition: A.identifier -> (list A.identifier * A.statement Location.t unit) -> t unit
let register_function_definition sym fdef =
  (* NOTE: unlike for external objects, we don't need to check the scope here,
     because the parse won't allow block scoped function definitions anyway. *)
  State_exception.update (fun st ->
    <| st with function_definitions= Map.insert sym fdef st.function_definitions |>
  )


val external_object_is_defined: A.identifier -> t bool
let external_object_is_defined sym =
  State_exception.read (fun st ->
    Map.member sym st.external_object_definitions
  )


val function_is_defined: A.identifier -> t bool
let function_is_defined sym =
  State_exception.read (fun st ->
    Map.member sym st.function_definitions
  )


val register_function_declaration: A.identifier -> (ATypes.ctype * (list (ATypes.qualifiers * ATypes.ctype)) * bool * bool * bool) -> t unit
let register_function_declaration sym decl =
  State_exception.read (fun st ->
    Map.lookup sym st.function_declarations
  ) >>= function
    | Just decl' ->
        if decl <> decl' then
          (* TODO: msg *)
          fail (Errors.Desugar_OtherViolation "redeclaration of a function with a different type")
        else
          return ()
    | Nothing ->
        State_exception.update (fun st ->
          <| st with function_declarations= Map.insert sym decl st.function_declarations |>
        )
  end


(* TODO: the redeclaration check don't mix external/internal declarations *)
val register_external_object_declaration: A.identifier -> (ATypes.qualifiers * ATypes.ctype) -> t unit
let register_external_object_declaration sym decl =
  State_exception.read (fun st ->
    Map.lookup sym st.external_object_declarations
  ) >>= function
    | Just decl' ->
        if decl <> decl' then
          (* TODO: msg *)
          fail (Errors.Desugar_OtherViolation "redeclaration of a object with a different type")
        else
          return ()
    | Nothing ->
        State_exception.update (fun st ->
          <| st with external_object_declarations= Map.insert sym decl st.external_object_declarations |>
        )
  end

(* TODO: factorize *)
val register_internal_object_declaration: A.identifier -> (ATypes.qualifiers * ATypes.ctype) -> t unit
let register_internal_object_declaration sym decl =
  State_exception.read (fun st ->
    Map.lookup sym st.internal_object_declarations
  ) >>= function
    | Just decl' ->
        if decl <> decl' then
          (* TODO: msg *)
          fail (Errors.Desugar_OtherViolation "redeclaration of a object with a different type")
        else
          return ()
    | Nothing ->
        State_exception.update (fun st ->
          <| st with internal_object_declarations= Map.insert sym decl st.internal_object_declarations |>
        )
  end


val register_static_assertion: A.expression unit -> A.stringLiteral -> t unit
let register_static_assertion e strCst =
  State_exception.update (fun st ->
    <| st with static_assertions= (e, strCst) :: st.static_assertions |>
  )






val register_label: cabs_identifier -> t unit
let register_label ident =
  void (_register_identifier ident Namespace_label Kind_label Linkage_none)

val resolve_label: cabs_identifier -> t A.identifier
let resolve_label ident =
  (* TODO: ยง6.8.6.1#1 *)
  resolve_identifier ident Namespace_label >>= function
    | Just (_, (sym ,_, _)) ->
        return sym
    | Nothing ->
        fail (Errors.Desugar_OtherViolation "ยง6.8.6.1#1, sentence 1")
  end


(* Returns the return type of the function currently being desugared *)
(* val get_current_return_type: t ATypes.ctype *)
let get_current_return_type: t ATypes.ctype =
  State_exception.read (fun st ->
    st.current_return_type
  )

let set_current_return_type (ty: ATypes.ctype) : t unit =
  State_exception.update (fun st ->
    <| st with current_return_type= ty |>
  )


(* val is_switch_body: t bool *)
let is_inside_switch: t bool =
  State_exception.read (fun st ->
    st.is_inside_switch
  )

(* val is_loop_body: t bool *)
let is_inside_loop: t bool =
  State_exception.read (fun st ->
    st.is_inside_loop
  )


val perform_inside_switch: forall 'a. t 'a ->  t 'a
let perform_inside_switch m =
  is_inside_loop >>= function
    | true ->
        m
    | false ->
        State_exception.update (fun st -> <| st with is_inside_switch= true |>) >>
        m >>= fun ret ->
        State_exception.update (fun st -> <| st with is_inside_switch= false |>) >>
        return ret
  end


val perform_inside_loop: forall 'a. t 'a -> t 'a
let perform_inside_loop m =
  is_inside_loop >>= function
    | true ->
        m
    | false ->
        State_exception.update (fun st -> <| st with is_inside_loop= true |>) >>
        m >>= fun ret ->
        State_exception.update (fun st -> <| st with is_inside_loop= false |>) >>
        return ret
  end



val freshify: cabs_identifier -> t cabs_identifier
let freshify id =
  State_exception.modify (fun st ->
    let (n, aux_supply') = UniqueId.fresh_id st.aux_supply in
    (id ^ string_of_natural (naturalFromNat n), <| st with aux_supply= aux_supply' |>)
  )




(* TODO: would be more efficient to store in the state the list of unused functions *)
val add_used_identifier: A.identifier -> t unit
let add_used_identifier sym =
  State_exception.update (fun st ->
    let _ = Boot.output_string "USED IDENTIFIER" in
    <| st with used_identifier= Global.list_insert sym st.used_identifier |>
  )

val get_used_identifier: t (list A.identifier)
let get_used_identifier =
  State_exception.read (fun st ->
    st.used_identifier
  )



val register_typedef: A.identifier -> ATypes.qualifiers * ATypes.ctype -> t unit
let register_typedef sym qs_ty =
  State_exception.update (fun st ->
    <| st with typedef_definitions= Map.insert sym qs_ty st.typedef_definitions |>
  )


val resolve_typedef: A.identifier -> t (ATypes.qualifiers * ATypes.ctype)
let resolve_typedef sym =
  State_exception.read (fun st ->
    match Map.lookup sym st.typedef_definitions with
      | Just qs_ty -> qs_ty
      | _ -> Boot.assert_false "TODO msg"
    end
  )



(* TODO: hackish, uber inefficient *)
val remove_unused_identifiers: forall 'a. state -> A.identifier -> list (A.identifier * 'a) -> list (A.identifier * 'a)
let remove_unused_identifiers st startup_sym xs =
  List.filter (fun (sym, _) -> sym = startup_sym || List.elem sym st.used_identifier) xs

(*
val remove_block_scoped_identifiers: forall 'a. state -> list (A.identifier * 'a) -> list (A.identifier * 'a)
let remove_block_scoped_identifiers st xs =
  List.filter (fun (sym, _) ->
    match Scope_table.resolve (sym, Namespace_ordinary) st.registered_identifiers with
      | Just (Scope_file, _) ->
          true
      | _ ->
          false
    end
  ) xs
*)


(* TODO: ... *)
let map_union = Map.(union)

val extract_program: cabs_identifier -> t (A.program Location.t unit)
let extract_program startup_ident =
  resolve_identifier startup_ident Namespace_ordinary  >>= function
    | Just (_, (startup_sym, _, _)) ->
        State_exception.read (fun st ->
          let decls = Map_extra.toList (
            map_union
              (Map.map (fun (ty, params, b1, b2, b3) -> A.Decl_function ty params b1 b2 b3) st.function_declarations)
              (Map.map (fun (qs, ty) -> A.Decl_object qs ty) st.external_object_declarations)
          ) in
          
          (startup_sym, <|
             A.declarations=         remove_unused_identifiers st startup_sym decls;
             A.object_definitions=   remove_unused_identifiers st startup_sym $ Map_extra.toList st.external_object_definitions;
             A.function_definitions= remove_unused_identifiers st startup_sym $ Map_extra.toList st.function_definitions;
             A.static_assertions=    st.static_assertions;
           |>)
        )
    | Nothing ->
        fail (Errors.Desugar_NoStartup startup_ident)
  end
