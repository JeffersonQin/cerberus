(* Effects for Cabs_to_ail: state *)
open import Pervasives Global
import Symbol Symbol_table Location State_exception Errors
import Cabs0 AilSyntax AilTypes

module C      = Cabs0
module A      = AilSyntax
module ATypes = AilTypes


type state = <|
  (* Counter for the symbol generator *)
  symbol_counter: Symbol.counter;
  (* table (with stacked scopes) associating C identifiers to symbols *)
  registered_identifiers: Symbol_table.t string;
  
  (* registered_labels *)
  registered_labels:      map string Symbol.t;
  is_inside_switch:       bool;
  
  fun_defs:               A.sigma Location.t unit;
  id_map:                 map Symbol.t (ATypes.qualifiers * ATypes.ctype);
  
  (* type definitions *)
  (* TODO[vla]: ยง6.7.8#2 If a typedef name specifies a variably modified type then it shall have block scope. *)
  typedef_map: map string (ATypes.qualifiers * ATypes.ctype);
  
  (* we save string litterals to be able to do static allocation in the Core *)
  strings:                map Symbol.t string;
  
  
  (* TODO: need to bring back globals (add them to newAil) *)
|>

type t 'a = State_exception.t 'a state Errors.t

val return: forall 'a. 'a -> t 'a
let return = State_exception.return

val fail: forall 'a. Errors.cause -> t 'a
let fail err = State_exception.fail (Location.dummy, err)

let of_option err = State_exception.of_option (Location.dummy, err)

val make_program: Symbol.t -> t (A.program Location.t unit)
let make_program startup =
  State_exception.read (fun st ->
    (startup, st.fun_defs)
  )

val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
let mapM = State_exception.mapM
let mapM_ = State_exception.mapM_

let foldrM = State_exception.foldrM

let iter = State_exception.iter

val tryWith: forall 'a. Errors.t -> t 'a -> t 'a
let tryWith = State_exception.tryWith


let bind = State_exception.bind
let fmap = State_exception.fmap
let app  = State_exception.app



(*  open Operators *)

(* given a computation producing the symbolic name of the startup function,
   produce the desugared Ail file *)
val eval: t Symbol.t -> Exception.t (A.program Location.t unit) Errors.t
let eval m =
  let initial_state : state = <|
    symbol_counter=         Symbol.init;
    registered_identifiers= Symbol_table.create_scope Symbol_table.empty;
    registered_labels=      Map.empty;
    is_inside_switch=       false;
    fun_defs=               [];
    id_map=                 Map.empty;
    typedef_map=            Map.empty;
    strings=                Map.empty
  |> in
  State_exception.eval (bind m make_program) initial_state

val resolve_identifier: string -> t A.identifier
let resolve_identifier name =
  bind (State_exception.read (fun st -> Symbol_table.lookup name st.registered_identifiers))
    function
      | Just x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end

val is_inside_switch: t bool
let is_inside_switch =
  State_exception.read (fun st -> st.is_inside_switch)

val create_scope: t unit
let create_scope =
  State_exception.update (fun st ->
    <| st with registered_identifiers= Symbol_table.create_scope st.registered_identifiers |>)

val destroy_scope: t (list A.identifier)
let destroy_scope =
  State_exception.modify (fun st ->
    (Symbol_table.symbols st.registered_identifiers,
     <| st with registered_identifiers= Symbol_table.destroy_scope st.registered_identifiers |>)
  )

val fresh : t Symbol.t
let fresh =
  State_exception.modify (fun st ->
    let (sym, symbol_counter) = Symbol.fresh st.symbol_counter in
    (sym, <| st with symbol_counter = symbol_counter |>)
  )

val fresh_name : string -> t A.identifier
let fresh_name name =
  State_exception.modify (fun st ->
    let (sym, symbol_counter) = Symbol.fresh_pretty name st.symbol_counter in
    (sym, <| st with symbol_counter = symbol_counter |>)
  )

val register_name_translation : string -> A.identifier -> t unit
let register_name_translation name symbol =
  State_exception.update (fun st ->
    <| st with registered_identifiers = Symbol_table.insert name symbol st.registered_identifiers |>
  )

val name_in_scope : string -> t bool
let name_in_scope name =
  State_exception.read (fun st ->
    Symbol_table.member name (Symbol_table.return_scope st.registered_identifiers)
  )

val register_name : string -> t A.identifier
let register_name name =
  bind (name_in_scope name)
    function
      | true  ->
          State_exception.fail (Location.dummy, Errors.CABS_TO_AIL_MULTIPLE_REGISTRATION)
      | false ->
          bind (fresh_name name)
            (fun sym ->
              bind (register_name_translation name sym)
                (fun _ ->
                  State_exception.return sym))
    end

(* TODO: storage_duration *)
val add_declaration : Symbol.t -> ATypes.qualifiers -> ATypes.ctype -> t unit
let add_declaration id qs ty =
  State_exception.update (fun st ->
    <| st with id_map = Map.insert id (qs, ty) st.id_map |>)

val get_declaration: A.identifier -> t (ATypes.qualifiers * ATypes.ctype)
let get_declaration id =
  State_exception.read (fun st ->
    fromJust $ Map.lookup id st.id_map
  )

val add_function : A.identifier -> ((ATypes.ctype * A.bindings) * A.statement Location.t unit) -> t unit (* TODO: parameters *)
let add_function id fun_def =
  State_exception.update (fun st ->
    <| st with fun_defs = (id, fun_def) :: st.fun_defs |>
  )

(* Labels related functions *)
val return_registered_labels: t (Map.map string Symbol.t)
let return_registered_labels = fun st ->
  Exception.return (st.registered_labels, st)

let fresh_label name =
  State_exception.modify (fun st ->
    let (symbol, symbol_counter') = Symbol.fresh_pretty name st.symbol_counter in
    (symbol, <| st with  symbol_counter=     symbol_counter';
                         registered_labels=  Map.insert name symbol st.registered_labels |>)
  )






val register_typedef: string -> ATypes.qualifiers * ATypes.ctype -> t unit
let register_typedef str qs_ty =
  State_exception.update (fun st ->
    <| st with typedef_map= Map.insert str qs_ty st.typedef_map |>
  )

val get_typedef: string -> t (ATypes.qualifiers * ATypes.ctype)
let get_typedef str =
  bind (State_exception.read (fun st -> Map.lookup str st.typedef_map))
    function
      | Just qs_ty -> return qs_ty
      | Nothing    -> fail (Errors.CABS_TO_AIL_UNDECLARED_TYPENAME str)
    end
