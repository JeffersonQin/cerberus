open import Pervasives
import Symbolic
import Core_ctype

(* TODO: temporary hack *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`


type address = Symbolic.symbolic   (* the type of symbolic integers *)



type allocated_object_id = Symbolic.symbol   (* a type of unique-over-time ids *)
type allocated_space_id = Symbolic.symbol


(* we have two kinds of allocation:

- an "allocated object", including a global, a block-scoped
  variable, a function parameter, an un-named object (from compound
  literals and a string constant).  All these have a static type from
  the program source.

- an "allocated space", coming from malloc etc., which may or
  may not yet have been written into.

BTW, The standard's usage of "object" is confusing (or confused?) here:
it's unclear whether a malloc'd space is an "object" before you've
written into it, for example.  

In our semantics, writes into dynamically allocated space do *not*
create new "objects" inside that space; they just exist in the set of
writes maintained by the concurrency model.

One might thing that malloc'd space should be treated as a char array,
but that wouldn't be correct w.r.t. the standard, e.g. because their
behaviour w.r.t. strong update is different.

As far as the concurrency model is concerned, though, I don't think it
has to distinguish between the two kinds.  It can just have single
Allocate and Deallocate actions (we should rename from the former
Create and Kill for clarity).


*)


(* There is immutable metadata for both kinds of allocations, and
thread through extend-only maps from the ids recording it. *)

type allocated_object_metadata = <|
  ao_original_type: Core_ctype.ctype;
  ao_address:       address;
  ao_size:          Symbolic.symbolic;
  (*ao_alignment:     Symbolic.symbolic;*)

(* the size is determined by the ctype, but as that is via a Core
  program, to calculate the implementation-defined things, it's
  convenient to record it here.  The alignment is likewise determined
  but I think we won't need to use it after the address is created*)

  (* and maybe a size for VLAs and flexible array members
    (for f.a.m., you're not supposed to have any statically allocated f.a.m.'s; for VLAs we're not sure) 
  *)
|>

type allocated_space_metadata = <|
  as_address:  address;
  as_size: Symbolic.symbolic;
|>



(* TODO *)
module UniqueId = struct
  type counter
  val init: counter
  let init = assert_false "WIP"
end


type driver_state = <|
  ao_counter : UniqueId.counter;
  as_counter : UniqueId.counter;
  ao_map : map allocated_object_id allocated_object_metadata;
  as_map : map allocated_space_id allocated_space_metadata;
|>


val initial_driver_state: driver_state
let initial_driver_state = <|
  ao_counter= UniqueId.init;
  as_counter=  UniqueId.init;
  ao_map=           Map.empty;
  as_map=           Map.empty;
|>


