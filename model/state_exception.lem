open Global

type t 'a 's 'msg = 's -> Exception.t ('a * 's) 'msg

let return a = fun s -> Exception.return (a, s)
let fmap f m =
  fun s -> Exception.bind (m s) (fun (a, s') -> Exception.return (f a, s'))
let join mm = fun s -> Exception.bind (mm s) (fun (m, s') -> m s')
let bind m f = join (fmap f m)
let app  mf m = bind mf (fun f -> fmap f m)
let papp mf x = bind mf (fun f -> return (f x))

let fail msg = fun _ -> Exception.fail msg

val update: forall 's 'msg. ('s -> 's) -> t unit 's 'msg
let update f = fun s -> Exception.return ((), f s)
let modify f = fun s -> Exception.return (f s)
let read   f = fun s -> Exception.return (f s, s)


let run m = fun s -> Exception.fmap fst (m s)

module Operators = struct
  let (>>=) = bind
  let (<$>) = fmap
  let (<*>) = app
end

let of_option msg = function
  | Some a -> return a
  | None   -> fail msg
end

let option msg m =
  let f o =
    match o with
      | Some a -> return a
      | None   -> fail msg
    end in
  bind m f

open Operators

let app2 mf mx my = mf <*> mx <*> my
let app3 mf mx my mz = (app2 mf mx my) <*> mz
let map2 f mx my = f <$> mx <*> my
let map3 f mx my mz = (map2 f mx my) <*> mz

let sequence ms =
  List.fold_right
    (fun m m' ->
      m  >>= fun x  ->
      m' >>= fun xs ->
      return (x::xs)
    ) ms (return [])

let listM t xs = sequence (t xs)

let mapM f = listM (List.map f)

let rec foldlM f l a =
  match l with
    | [] -> return a
    | x::xs -> f x a >>= foldlM f xs
  end

let rec foldrM f l a =
  match l with
    | [] -> return a
    | x::xs -> foldrM f xs a >>= f x
  end

let iter f l = foldlM (fun a () -> f a) l ()
