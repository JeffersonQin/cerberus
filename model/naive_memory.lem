open import Pervasives
open import Global Show

import State_exception_undefined
import Symbol Symbolic Core_ctype Thread

import Map_extra (* DEBUG *)


module SEU = State_exception_undefined


(* TODO: debug *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`

(* TODO: debug *)
val output_debug: nat -> string -> unit
declare ocaml target_rep function output_debug = `Debug.print_debug`

val string_of_ail_ctype: forall 'a. 'a (* AilTypes.ctype *) -> string
declare ocaml target_rep function string_of_ail_ctype = `String_core_ctype.string_of_ctype`



type object_id = nat * list Symbol.t (* symbols originating from C, for debugging purpose *)




type pointer_shift =
  | Shift_zero (* TODO: maybe by construction we never need this ctor *)
  | Shift_byte (* sizeof(char) and friends *)
  | Shift_ctype of Core_ctype.ctype
  | Shift_times of pointer_shift * nat

let rec pointer_shiftCompare ptr_sh1 ptr_sh2 =
  let ord = function
    | Shift_zero ->
        (0 : nat)
    | Shift_byte ->
        1
    | Shift_ctype _ ->
        2
    | Shift_times _ _ ->
        3
  end in
  match (ptr_sh1, ptr_sh2) with
    | (Shift_ctype ty1, Shift_ctype ty2) ->
        setElemCompare ty1 ty2
    | (Shift_times ptr_sh1' n1, Shift_times ptr_sh2' n2) ->
        match pointer_shiftCompare ptr_sh1' ptr_sh2' with
          | EQ ->
              setElemCompare n1 n2
          | z ->
              z
        end
    | _ ->
        setElemCompare (ord ptr_sh1) (ord ptr_sh2)
  end

let rec string_of_pointer_shift ptr_sh =
  match ptr_sh with
  | Shift_zero ->
      "Shift_zero"
  | Shift_byte ->
      "Shift_byte"
  | Shift_ctype ty ->
      "Shift_ctype[" ^ string_of_ail_ctype ty ^ "]"
  | Shift_times ptr_sh' n ->
      "Shift_times[" ^ string_of_pointer_shift ptr_sh' ^ ", " ^ show n ^ "]"
  end



instance (Eq pointer_shift)
  let (=) ptr_sh1 ptr_sh2 =
    match pointer_shiftCompare ptr_sh1 ptr_sh2 with
      | EQ -> true
      | _  -> false
    end
  let (<>) ptr_sh1 ptr_sh2 =
    match pointer_shiftCompare ptr_sh1 ptr_sh2 with
      | EQ -> false
      | _  -> true
    end
end

instance (SetType pointer_shift)
  let setElemCompare = pointer_shiftCompare
end






type pointer_value =
(*  | Pointer_null of Core_ctype.ctype *)
  | Pointer_nonnull of Core_ctype.ctype * object_id
  | Pointer_cast of Core_ctype.ctype * pointer_value
  | Pointer_function of Symbol.t
  | Pointer_shift of pointer_value * nat

let rec pointer_value_eq ptr_val1 ptr_val2 =
  let ord = function
    | Pointer_nonnull _ _ ->
        (0 : nat)
    | Pointer_cast _ _ ->
        1
    | Pointer_function _ ->
        2
    | Pointer_shift _ _ ->
        3
  end in
  match (ptr_val1, ptr_val2) with
    | (Pointer_nonnull ty1 oid1, Pointer_nonnull ty2 oid2) ->
        ty1 = ty2 && oid1 = oid2
    | (Pointer_cast ty1 ptr_val1', Pointer_cast ty2 ptr_val2') ->
        ty1 = ty2 && pointer_value_eq ptr_val1' ptr_val2'
    | (Pointer_function sym1, Pointer_function sym2) ->
        sym1 = sym2
    | (Pointer_shift ptr_val1' n1, Pointer_shift ptr_val2' n2) ->
        pointer_value_eq ptr_val1' ptr_val2' &&
        n1 = n2
    | _ ->
        (ord ptr_val1) = (ord ptr_val2)
  end


(* TODO: debug *)
let rec string_of_prefix syms =
  let f = function
    | Symbol.Symbol n (Just str) ->
        str
    | Symbol.Symbol n Nothing ->
        "a_" ^ string_of_natural (naturalFromNat n)
  end in
  match syms with
    | [] ->
        ""
    | [sym] ->
        f sym
    | sym :: syms' ->
        f sym ^ "." ^ string_of_prefix syms'
  end
  

let rec string_of_pointer_value ptr_val =
  match ptr_val with
    | Pointer_nonnull ty (oid, pref) ->
        "Pointer_nonnull[" ^ string_of_ail_ctype ty ^ ", " ^ show oid ^ ":{" ^ string_of_prefix pref ^ "}]"
    | Pointer_cast ty ptr_val' ->
        "Pointer_cast[" ^ string_of_ail_ctype ty ^ ", " ^ string_of_pointer_value ptr_val' ^ "]"
    | Pointer_function (Symbol.Symbol n str_opt) ->
        let sym_str = match str_opt with
          | Just str -> 
              string_of_natural (naturalFromNat n) ^ ": " ^ str
          | Nothing ->
              string_of_natural (naturalFromNat n)
        end in
        "Pointer_function[" ^ sym_str ^ "]"
    | Pointer_shift ptr_val' n ->
        "Pointer_shift[" ^ string_of_pointer_value ptr_val' ^ ", " ^ string_of_natural (naturalFromNat n) ^ "]"
end

instance (Show pointer_value)
  let show ptr_val = string_of_pointer_value ptr_val
end


instance (Eq pointer_value)
  let (=) = pointer_value_eq
  let (<>) = fun x y -> not (pointer_value_eq x y)
end

(* TODO ... *)
let rec setElemCompare_pointer_value ptr_val1 ptr_val2 =
  let ordOf = function
     | Pointer_nonnull _ _ ->
         (0 : nat)
     | Pointer_function _ ->
         1
     | Pointer_shift _ _ ->
         2
  end in
  match setElemCompare (ordOf ptr_val1) (ordOf ptr_val2) with
    | EQ ->
        match (ptr_val1, ptr_val2) with
          | (Pointer_nonnull ty1 oid1, Pointer_nonnull ty2 oid2) ->
              match setElemCompare ty1 ty2 with
                | EQ ->
                    setElemCompare oid1 oid2
                | z ->
                    z
              end
          | (Pointer_cast ty1 ptr_val1', Pointer_cast ty2 ptr_val2') ->
              match setElemCompare ty1 ty2 with
                | EQ ->
                    setElemCompare_pointer_value ptr_val1' ptr_val2'
                | z ->
                    z
              end
          | (Pointer_function sym1, Pointer_function sym2) ->
              setElemCompare sym1 sym2
          | (Pointer_shift ptr_val1' n1, Pointer_shift ptr_val2' n2) ->
              match setElemCompare_pointer_value ptr_val1' ptr_val2' with
                | EQ ->
                    setElemCompare n1 n2
                | z ->
                    z
              end
        end
    | cmp ->
        cmp
  end

(*
instance (MapKeyType pointer_value)
  let mapKeyCompare = compare_pointer_value
end
*)

instance (SetType pointer_value)
  let setElemCompare = setElemCompare_pointer_value
end



type mem_value =
  | MV_pointer of pointer_value
  | MV_integer of Symbolic.symbolic   (* possibly-symbolic integer value *)
  | MV_array of list mem_value
(*
  | MV_struct of list (Symbol.t * mem_value)
  | MV_union of Symbol.t * mem_value
  | MV_pointer_byte of nat * nat * pointer_value 
  | MV_unspecified of Core_ctype.ctype
*)

(* TODO: debug *)
let rec string_of_mem_value mem_val =
  match mem_val with
    | MV_pointer ptr_val ->
        "MV_pointer[" ^ string_of_pointer_value ptr_val ^ "]"
    | MV_integer (Symbolic.SYMBconst n) ->
        string_of_integer n
    | MV_integer symb ->
        "MV_integer[TODO]"
    | MV_array mem_vals ->
        "MV_array[" ^ List.foldr (fun mem_val acc ->  string_of_mem_value mem_val ^ ", " ^ acc) "" mem_vals ^ "]"
end

instance (Show mem_value)
  let show mem_val = string_of_mem_value mem_val
end



type memory_write =
  pointer_value * mem_value

type memory_read =
  pointer_value * nat (* number of bytes being read *)


type memory_state = <|
  oid_supply: UniqueId.supply nat;
  mem_writes: list memory_write; (* TODO: uber non efficient *)
(*  mem_writes: map pointer_value (maybe mem_value); *)
|>

let string_of_memory_state mem_st =
  "TODO_string_of_memory_state"
(*
  let ws = Map_extra.toList mem_st.mem_writes in 
  "state[" ^ (string_of_natural (naturalFromNat (Map.size mem_st.mem_writes))) ^ ";" ^
  (string_of_natural (naturalFromNat (Map.size mem_st.mem_writes))) ^ "]{" ^ 
  List.foldl (fun acc (ptr_val, mem_val_opt) ->
    string_of_pointer_value ptr_val ^ " := " ^
    match mem_val_opt with
      | Just mem_val ->
          string_of_mem_value mem_val
      | Nothing ->
          "uninit"
    end ^ ", " ^ acc
  ) "" ws
  ^ "}"
*)

instance (Show memory_state)
  let show mem_st = string_of_memory_state mem_st
end


val     base_object_id: pointer_value -> object_id
let rec base_object_id ptr_val =
  match ptr_val with
    | Pointer_nonnull _ oid ->
        oid
    | Pointer_function _ ->
        assert_false "base_object_id: found a function pointer"
    | Pointer_shift ptr_val' _ ->
        base_object_id ptr_val'
  end

val     normalise_pointer_value: pointer_value -> pointer_value
let rec normalise_pointer_value ptr_val =
  match ptr_val with
    | Pointer_shift ptr_val 0 ->
        normalise_pointer_value ptr_val
    | Pointer_shift (Pointer_shift ptr_val' n) m ->
        normalise_pointer_value (Pointer_shift ptr_val' (n+m))
    | _ ->
        ptr_val
  end



val is_affected: memory_read -> memory_write -> bool
let is_affected (r_ptr_val, width) (w_ptr_val, _) =
  match (normalise_pointer_value r_ptr_val, normalise_pointer_value w_ptr_val) with
    | (Pointer_nonnull r_ty r_oid, Pointer_nonnull w_ty w_oid) ->
        r_oid = w_oid
    | (Pointer_nonnull r_ty r_oid, Pointer_shift (Pointer_nonnull w_ty w_oid) w_n) ->
        r_oid = w_oid && w_n < width
    | (Pointer_shift (Pointer_nonnull r_ty r_oid) r_n, Pointer_shift (Pointer_nonnull w_ty w_oid) w_n) ->
        let n = w_n - r_n in
        r_oid = w_oid && 0 <= n && n < width
    | _ ->
        false
end



val filter_writes: memory_read -> list memory_write -> list memory_write
let filter_writes r ws =
  List.filter (is_affected r) ws


(* TODO: move that somewhere else *)
(* NOTE: the sort must be stable *)
val sort_assoc_list: forall 'a 'b. list ('a * 'b) -> list ('a * 'b)
declare ocaml target_rep function sort_assoc_list = `Boot_ocaml.sort_assoc_list`

(* remove duplicates from assoc list (keeping the first occurences) *)
(* NOTE: assumes that the assoc list is sorted *)
val uniq_assoc_list: forall 'a 'b. Eq 'a => list ('a * 'b) -> list ('a * 'b)
let rec uniq_assoc_list_aux xs acc =
  match xs with
    | [] ->
        acc
    | [(n, a)] ->
        (n, a) :: acc
    | ((n, a) :: (m, b) :: ws) ->
        if n = m then
          uniq_assoc_list_aux ((n, a) :: ws) acc
        else
          uniq_assoc_list_aux ((m, b) :: ws) ((n, a) :: acc)
  end
let uniq_assoc_list xs =
  List.reverse $ uniq_assoc_list_aux xs []



val combine_writes: memory_read -> list memory_write -> maybe mem_value
let combine_writes ((r_ptr_val, width) as r) ws =
  let offset =
    match normalise_pointer_value r_ptr_val with
      | Pointer_nonnull _ _ -> 0
      | Pointer_shift _ n -> n
    end in
  
  let xs = List.map (function
    | (Pointer_nonnull _ _, mem_val) ->
        (0, mem_val)
    | (Pointer_shift _ n, mem_val) ->
        (n - offset, mem_val)
  end) $ filter_writes r (List.map (fun (x, y) -> (normalise_pointer_value x, y)) ws) in
  
  (* TODO: we don't always want an array *)
  match xs with
    | [] ->
        Nothing
    | _ ->
        (* NOTE: the sorting function REALLY needs to be stable *)
        match uniq_assoc_list $ sort_assoc_list xs with
          | [(_, mem_val)] ->
              Just mem_val
          | mem_vals ->
              Just (MV_array $ List.map snd mem_vals)
        end
  end




let initial_memory_state = <|
  oid_supply= UniqueId.new_supply;
  mem_writes= [];
|>


type memory_error =
  | MemErr_uninitialised
  | MEMORY_ERROR

type memM 'a = SEU.t 'a memory_state memory_error

val runMem: forall 'a. memM 'a -> memory_state -> either memory_error ('a * memory_state)
let runMem m mem_st =
  match SEU.run m mem_st with
    | Exception.Result (Undefined.Defined z, mem_st') ->
        Right (z, mem_st')
    | Exception.Exception err ->
        Left err
(* TODO: undef case *)
  end







(* TODO: part of Mem API *)
val mk_integer: integer -> mem_value
let mk_integer n =
  MV_integer (Symbolic.SYMBconst n)

val mk_pointer: pointer_value -> mem_value
let mk_pointer ptr_val =
  MV_pointer ptr_val

(* TODO: part of Mem API *)
val mk_array : list mem_value -> mem_value
let mk_array mem_vals =
  MV_array mem_vals


let rec mem_value_eq mem_val1 mem_val2 =
  match (mem_val1, mem_val2) with
    | (MV_pointer ptr_val1, MV_pointer ptr_val2) ->
        ptr_val1 = ptr_val2
    | (MV_integer symb1, MV_integer symb2) ->
        (* TODO: should use the constrain solver somewhere *)
        symb1 = symb2
    | (MV_array mem_vals1, MV_array mem_vals2) ->
        List.all (uncurry mem_value_eq) $ List.zip mem_vals1 mem_vals2
    | _ ->
        false
  end

instance (Eq mem_value)
  let (=) = mem_value_eq
  let (<>) = fun x y -> not (mem_value_eq x y)
end


(*
val     setElemCompare_mem_value: mem_value -> mem_value -> ordering
let rec setElemCompare_mem_value mem_value1 mem_value2 =
  match (mem_value1, mem_value2) with
    | (

    | (Tseq tid1', _) -> setElemCompare tid1' tid2
    | (_, Tseq tid2') -> setElemCompare tid1 tid2'
    | (Tzero, Tzero) -> EQ
    | (Tpar n1 tid1', Tpar n2 tid2') -> pairCompare setElemCompare setElemCompare (n1, tid1') (n2, tid2')
    | (Tzero, _) -> LT
    | (_, Tzero) -> GT
  end
*)

(* TODO ... *)
let setElemCompare_mem_value mem_val1 mem_val2 =
  if mem_value_eq mem_val1 mem_val2 then EQ else LT

instance (SetType mem_value)
  let setElemCompare = setElemCompare_mem_value
end





val null_pointer: Core_ctype.ctype -> pointer_value
let null_pointer ty =
  assert_false "Pointer_null ty"


val function_pointer: Symbol.t -> pointer_value
let function_pointer fsym =
  Pointer_function fsym




val fresh_object_id: list Symbol.t -> State.t object_id memory_state
let fresh_object_id pref =
  State.modify (fun st ->
    let (n, oid_suppl') = UniqueId.fresh_id st.oid_supply in
    ((n, pref), <| st with oid_supply= oid_suppl' |>)
  )






open SEU.Operators

val allocate_object:    Thread.thread_id  (* the allocating thread *)
                     -> list Symbol.t     (* symbols coming from the Core/C program, for debugging purpose *)
                     -> Core_ctype.ctype  (* type of the allocation *)
(*
                     -> Symbolic.symbolic (* size of that type *)
                     -> Symbolic.symbolic (* alignment of that type *)
*)
                     -> memM pointer_value
let allocate_object (* tid ty size_symb align_symb *) _ pref ty =
  SEU.runS (fresh_object_id pref) >>= fun oid ->
  let ptr_val = Pointer_nonnull ty oid in

  let _ = output_debug 5 ("Mem.allocate_object: " ^ string_of_pointer_value ptr_val) in (* DEBUG *)
  SEU.return ptr_val
(*
  let ptr_val = Pointer_nonnull oid in
  SEU.update (fun st ->
    let st' = <| st with
      mem_writes= Map.insert ptr_val Nothing st.mem_writes
    |> in
(*    let _ = output_debug 5 ("AFTER0> " ^ string_of_memory_state st') in *)
    st') >>
  
  SEU.read (fun st ->
(*    let _ = output_debug 5 ("AFTER1> " ^ string_of_memory_state st) in *)
    ()
  ) >>
  SEU.return ptr_val
*)



(* TODO: WIP *)
val store: Core_ctype.ctype -> pointer_value -> mem_value -> memM unit
let store ty ptr_val mem_val =
  let _ = output_debug 5 ("Mem.store: (" ^ string_of_ail_ctype ty ^ ") " ^ string_of_pointer_value ptr_val ^ " := " ^ string_of_mem_value mem_val) in (* DEBUG *)
  SEU.update (fun st ->
    <| st with mem_writes= (ptr_val, mem_val) :: st.mem_writes |>
  )

(* TODO: WIP *)
val load: Core_ctype.ctype -> pointer_value -> memM mem_value
let load ty ptr_val =
  SEU.read (fun st -> st.mem_writes) >>= fun ws ->
  match combine_writes (ptr_val, 1 (* TODO *)) ws with
    | Nothing ->
        let _ = output_debug 5 ("Mem.load: (" ^ string_of_ail_ctype ty ^ ") " ^ string_of_pointer_value ptr_val ^ " = UNINIT") in (* DEBUG *)
        SEU.fail MemErr_uninitialised
    | Just mem_val ->
        let _ = output_debug 5 ("Mem.load: (" ^ string_of_ail_ctype ty ^ ") " ^ string_of_pointer_value ptr_val ^ " = " ^ string_of_mem_value mem_val) in (* DEBUG *)
        SEU.return mem_val
  end
(*
  match Map.lookup ptr_val writes with
    | Just (Just mem_val) ->
        SEU.return mem_val
    | Just Nothing ->
        SEU.fail MemErr_uninitialised
    | Nothing ->
        SEU.fail MEMORY_ERROR
  end
*)



val pointer_shift:
  Core_ctype.ctype -> pointer_value -> integer -> memM pointer_value
let pointer_shift ty ptr_val n =
  SEU.return (normalise_pointer_value $ Pointer_shift ptr_val (natFromInteger n)) (* TODO: undef when we run out *)
(*

type pointer_value =
(*  | Pointer_null of Core_ctype.ctype *)
  | Pointer_nonnull of object_id
  | Pointer_function of Symbol.t

*)
