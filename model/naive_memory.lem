open import Pervasives
open import Global Show Show_extra

import State_exception_undefined
import Symbol Symbolic Core_ctype Thread

import Map_extra (* DEBUG *)


module SEU = State_exception_undefined
  let inline (>>=)      = SEU.bind
  let inline (>>) m1 m2 = SEU.bind m1 (fun () -> m2)
  let inline (<$>)      = SEU.fmap



(* TODO: debug *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`

(* TODO: debug *)
val output_debug: nat -> string -> unit
declare ocaml target_rep function output_debug = `Debug.print_debug`

val string_of_ctype: forall 'a. 'a (* AilTypes.ctype *) -> string
declare ocaml target_rep function string_of_ctype = `String_core_ctype.string_of_ctype`



val begin_timing_: string -> unit
declare ocaml target_rep function begin_timing_ = `Debug.begin_timing`
val end_timing_: unit -> unit
declare ocaml target_rep function end_timing_ = `Debug.end_timing`

let begin_timing str =
  let () = begin_timing_ str in
  SEU.return ()

let end_timing () =
  let () = end_timing_ () in
  SEU.return ()



type object_id = nat * list Symbol.t (* symbols originating from C, for debugging purpose *)



(* TODO: protection *)
type offset =
  list Core_ctype.ctype

(* TODO: protection *)
type footprint =
  list Core_ctype.ctype


type pointer_shift =
(* TODO: bring back symbols *)
(*  list (Core_ctype.ctype * Symbolic.symbolic) *)
  list (Core_ctype.ctype * integer)


type pointer_value =
  | PVnull of Core_ctype.ctype
  | PVobject of object_id * pointer_shift
  | PVfunction of Symbol.t

type integer_operator =
  | IntAdd
  | IntSub
  | IntMul
  | IntDiv
  | IntMod
  | IntExp

type integer_value =
  (* TODO: merge the two kind of symbolics *)
  | IVinteger of integer
  | IVsymbolic of Symbolic.symbolic (* possibly-symbolic integer value *)
  | IVptrdiff of pointer_value * pointer_value
  | IVintptr of pointer_value
  | IVop of integer_operator * integer_value * integer_value

type mem_value =
  | MVunspecified of Core_ctype.ctype (* this should only be used for base and union types *)
  | MVinteger of integer_value
  | MVfloating of string
  | MVpointer of pointer_value
  | MVarray of list mem_value (* TODO: list (maybe mem_value) *)
  | MVstruct of Symbol.t * list (Cabs.cabs_identifier * mem_value)
  | MVunion of Symbol.t * Cabs.cabs_identifier * mem_value (* the symbols are respectively the tag and the member *)


type mem_write =
  MemWrite of pointer_value * Core_ctype.ctype * mem_value

type mem_read_request = 
  MemReadRequest of pointer_value * Core_ctype.ctype


type tag_definitions =
  map Symbol.t (list (Cabs.cabs_identifier * Core_ctype.ctype))


type mem_state = <|
  oid_supply: UniqueId.supply nat;
  objTypes: map object_id (maybe Core_ctype.ctype);
  tagDefinitions: tag_definitions;
  memWrites: list mem_write
|>

type mem_error =
  | MerrUnitialised of mem_read_request
  | MerrInternal of string
  | MerrOther of string

type memM 'a = SEU.t 'a mem_state mem_error


(* BEGIN CLASS ======================================================================== *)
let pointer_valueCompare ptr_val1 ptr_val2 =
  let ord = function
    | PVnull _ ->
        (0 : nat)
    | PVobject _ _ ->
        1
    | PVfunction _ ->
        2
  end in
  match (ptr_val1, ptr_val2) with
    | (PVnull ty1, PVnull ty2) ->
        setElemCompare ty1 ty2
    | (PVobject oid1 sh1, PVobject oid2 sh2) ->
        setElemCompare (oid1, sh1) (oid2, sh2)
    | (PVfunction sym1, PVfunction sym2) ->
        setElemCompare sym1 sym2
    | _ ->
        setElemCompare (ord ptr_val1) (ord ptr_val2)
  end

let pointer_valueEquals ptr_val1 ptr_val2 =
  match pointer_valueCompare ptr_val1 ptr_val2 with
    | EQ ->
        true
    | _ ->
        false
  end

instance (Eq pointer_value)
  let (=) = pointer_valueEquals
  let (<>) = fun x y -> not (pointer_valueEquals x y)
end
instance (SetType pointer_value)
  let setElemCompare = pointer_valueCompare
end


let rec mem_valueCompare mem_val1 mem_val2 =
  match (mem_val1, mem_val2) with
    | (MVunspecified ty1, MVunspecified ty2) ->
        setElemCompare ty1 ty2
    | (MVinteger symb1, MVinteger symb2) ->
        (* TODO: should use the constrain solver somewhere *)
        setElemCompare symb1 symb2
    | (MVpointer ptr_val1, MVpointer ptr_val2) ->
        pointer_valueCompare ptr_val1 ptr_val2
    | (MVarray mem_vals1, MVarray mem_vals2) ->
        lexicographicCompareBy mem_valueCompare mem_vals1 mem_vals2
    | (MVstruct tag1 ident_vs1, MVstruct tag2 ident_vs2) ->
        assert_false "WIP: mem_valueCompare, MVstruct"
(*
        pairCompare setElemCompare
          (lexicographicCompare (pairCompare setElemCompare mem_valueCompare))
          (tag1, sym_vs1) (tag2, sym_vs2)
*)
    | (MVunion tag1 sym1 mem_val1, MVunion tag2 sym2 mem_val2) ->
        assert_false "WIP: mem_valueCompare, MVunion"
  end

let mem_valueEquals mem_val1 mem_val2 =
  match mem_valueCompare mem_val1 mem_val2 with
    | EQ ->
        true
    | _ ->
        false
  end

instance (Eq mem_value)
  let (=) = mem_valueEquals
  let (<>) = fun x y -> not (mem_valueEquals x y)
end
instance (SetType mem_value)
  let setElemCompare = mem_valueCompare
end




(* TODO: debug *)
let rec string_of_prefix syms =
  let f = function
    | Symbol.Symbol n (Just str) ->
        str
    | Symbol.Symbol n Nothing ->
        "a_" ^ show n
  end in
  match syms with
    | [] ->
        ""
    | [sym] ->
        f sym
    | sym :: syms' ->
        f sym ^ "." ^ string_of_prefix syms'
  end




let rec stringFromPointer_value ptr_val =
  match ptr_val with
    | PVnull ty ->
        "(PVnull " ^ string_of_ctype ty ^ ")"
    | PVobject oid ptr_sh ->
        "PVobject" ^
        stringFromPair show (stringFromList (stringFromPair string_of_ctype show))
          (oid, ptr_sh)
    | PVfunction sym ->
        "(PVfunction " ^ show sym ^ ")"
  end

instance (Show pointer_value)
  let show = stringFromPointer_value
end

let stringFromInteger_operator = function
  | IntAdd ->
      "IntAdd"
  | IntSub ->
      "IntSub"
  | IntMul ->
      "IntMul"
  | IntDiv ->
      "IntDiv"
  | IntMod ->
      "IntMod"
  | IntExp ->
      "IntExp"
end

instance (Show integer_operator)
  let show = stringFromInteger_operator
end

let rec stringFromInteger_value ival =
  match ival with
    | IVinteger n ->
        "(IVinteger " ^ show n ^ ")"
    | IVsymbolic symb ->
        "(IVsymbolic " ^ show symb ^ ")"
    | IVptrdiff ptr_val1 ptr_val2 ->
        "(IVptrdiff " ^ show ptr_val1 ^ ", " ^ show ptr_val2 ^ ")"
    | IVintptr ptr_val ->
        "(IVintptr " ^ show ptr_val ^ ")"
    | IVop op ival1 ival2 ->
        "(IVop " ^ show op ^ ", " ^ stringFromInteger_value ival1 ^ ", " ^ stringFromInteger_value ival2 ^ ")"
  end

instance (Show integer_value)
  let show = stringFromInteger_value
end

(* TODO: debug *)
let rec stringFromMem_value mem_val =
  match mem_val with
    | MVunspecified ty ->
        "(MVunspecified " ^ string_of_ctype ty ^ ")"
    | MVinteger ival ->
        "(MVinteger " ^ show ival ^ ")"
    | MVpointer ptr_val ->
        "(MVpointer " ^ show ptr_val ^ ")"
    | MVarray mem_vals ->
        "(MVarray " ^ stringFromList stringFromMem_value mem_vals ^ ")"
    | MVstruct sym sym_vs ->
        "MVstruct (" ^ show sym ^ ", " ^
        stringFromList (stringFromPair show stringFromMem_value) sym_vs ^ ")"
    | MVunion tag sym mem_val ->
        "MVunion (" ^ show tag ^ ", " ^ show sym ^ ", " ^ stringFromMem_value mem_val ^ ")"
  end

instance (Show mem_value)
  let show = stringFromMem_value
end

instance (Show mem_write)
  let show w =
    let MemWrite ptr_val ty mval = w in
    "W " ^ show ptr_val ^ "(" ^ string_of_ctype ty ^ ") := " ^ show mval
end

instance (Show mem_read_request)
  let show r =
    let MemReadRequest ptr_val ty = r in
    "R " ^ show ptr_val ^ "(" ^ string_of_ctype ty ^ ")"
end


let rec prettyStringFromMem_value mem_val =
  match mem_val with
    | MVinteger (IVinteger n) ->
        show n
    | MVinteger (IVsymbolic (Symbolic.SYMBconst n)) ->
        show n
    | MVpointer ptr_val ->
        "PTR(" ^ show ptr_val ^ ")"
    | _ ->
        "[TODO]" (* TODO: check (I think this function is only used for printf *)
  end


let stringFromMem_state mem_st =
  "TODO_stringFromMem_state"
(*
  let ws = Map_extra.toList mem_st.mem_writes in 
  "state[" ^ (string_of_natural (naturalFromNat (Map.size mem_st.mem_writes))) ^ ";" ^
  (string_of_natural (naturalFromNat (Map.size mem_st.mem_writes))) ^ "]{" ^ 
  List.foldl (fun acc (ptr_val, mem_val_opt) ->
    string_of_pointer_value ptr_val ^ " := " ^
    match mem_val_opt with
      | Just mem_val ->
          string_of_mem_value mem_val
      | Nothing ->
          "uninit"
    end ^ ", " ^ acc
  ) "" ws
  ^ "}"
*)

instance (Show mem_state)
  let show = stringFromMem_state
end



instance (Show mem_error)
let show err =
  match err with
    | MerrUnitialised r ->
        "MerrUnitialised " ^ show r
    | MerrInternal str ->
        "MErrInternal " ^ show str
    | MerrOther str ->
        "MerrOther " ^ show str
  end
end

(* END CLASS INSTANCES ========================================================================== *)

(* Internals ================================================================ *)

(*
  Split a given offset at the point corresponding to the
  footprint of the given memory value.
  
  Returns 'Nothing' of the offset was too small to cover the
  footprint of the memory value
*)
module MaybeM = struct
  let bind m f =
    match m with
      | Nothing ->
          Nothing
      | Just z ->
          f z
    end
  
  
  (* NOTE: this is a foldl *)
  val     foldM: forall 'a 'b. ('a -> 'b -> maybe 'a) -> 'a -> list 'b -> maybe 'a
  let rec foldM f a = function
    | [] ->
        Just a
    | (x::xs) ->
        bind (f a x) (fun fax -> foldM f fax xs)
  end
end

val     offsetSplitAt: offset -> mem_value -> maybe (offset * offset)
let rec offsetSplitAt off mval =
  match (off, mval) with
    | (ty::off', MVunspecified ty') ->
        if ty = ty' then
          Just ([ty], off')
        else
          Nothing
    
    | (ty::off', MVinteger _) ->
        Just ([ty], off')
    
    | ((Core_ctype.Pointer _ _ as ty)::off', MVpointer _) ->
        Just ([ty], off')
    
    | (_, MVarray vs) ->
        MaybeM.foldM (fun (acc, xs) v ->
            MaybeM.bind (offsetSplitAt xs v) (fun (ys,zs) ->
              Just (acc ++ ys, zs)
            )
        ) ([], off) vs
    
    | (_, MVstruct _ identVs) ->
      MaybeM.foldM (fun (acc, xs) (_, v) ->
        MaybeM.bind (offsetSplitAt xs v) (fun (ys,zs) ->
          Just (acc ++ ys, zs)
        )
      ) ([], off) identVs
    
    | (_, MVunion _ _ mval') ->
      offsetSplitAt off mval'
    
    | _ ->
        Nothing
  end


val fpMatches: footprint -> mem_value -> bool
let fpMatches fp mval =
  match offsetSplitAt fp mval with
    | Just (_, []) ->
        true
    | _ ->
        false
  end










val setValue: tag_definitions -> mem_value -> offset -> mem_value -> mem_value
let setValue tagDefs mval off mval' =
  match (mval, off, mval') with
    | (MVarray vs, [], MVarray vs') ->
        if length vs = length vs' then
          mval
        else
          MVarray $ vs' ++ List.drop (List.length vs') vs
    
    | (MVarray (_::vs), [], _) ->
        MVarray (mval' :: vs)
    
    | ((* MVunspecified *) _, [], _) ->
        mval' (* TODO: maybe check that v' match the footprint of the type of the unspec value *)
    
        
    | _ ->
        assert_false "Mem.setValue: error case"
  end


val getSubValue: mem_value -> offset -> footprint -> maybe mem_value

val     getSubValue_aux:  offset -> footprint -> mem_value -> maybe (either offset mem_value)
val     getSubValue_array_aux: offset -> footprint -> list mem_value -> maybe (either offset mem_value)
let rec getSubValue_array_aux offAcc fp = function
  | [] ->
      Just (Left offAcc)
  | (v::vs') ->
      match getSubValue_aux offAcc fp v with
        | Just (Left offAcc') ->
            getSubValue_array_aux offAcc' fp vs'
        | Just (Right v') ->
            Just (Right v')
        | Nothing ->
            Nothing
      end
end

and getSubValue_struct_aux offAcc fp = function
  | [] ->
      Just (Left offAcc)
  | ((_, mval) :: xs') ->
      match getSubValue_aux offAcc fp mval with
        | Just (Left offAcc') ->
            getSubValue_struct_aux offAcc' fp xs'
        | Just (Right v') ->
            Just (Right v')
        | Nothing ->
            Nothing
      end
end



and getSubValue_aux off fp mval =
  match (mval, off, fp) with
    | (MVunspecified ty, [], [ty']) ->
        if ty = ty' then
          Just (Right mval)
        else
          Nothing
    
    | (MVinteger _, [], [_]) ->
        Just (Right mval)
    
    | (MVpointer _, [], [Core_ctype.Pointer _ _]) ->
        Just (Right mval)
    
    (* only allowing single and complete elem of an array to be a subvalue *)
    | (MVarray vs, _, _) ->
        match off with
          | [] ->
              if fpMatches fp mval then
                Just (Right mval)
              else
                getSubValue_array_aux off fp vs
          | _ ->
              getSubValue_array_aux off fp vs
        end
    
    | (MVstruct _ xs, _, _) ->
        match off with
          | [] ->
              if fpMatches fp mval then
                Just (Right mval)
              else
                getSubValue_struct_aux off fp xs
          | _ ->
              getSubValue_struct_aux off fp xs
        end
    
    | (MVunion _ _ mval, _, _) ->
        getSubValue_aux off fp mval
    
    | _ ->
        match offsetSplitAt off mval with
          | Just (_, off') ->
              Just (Left off')
          | _ ->
              Nothing
        end
  end


















let getSubValue mval off fp =
  match getSubValue_aux off fp mval with
    | Just (Right mval') ->
        Just mval'
    | _ ->
        Nothing
  end



val     unfoldCtypes: tag_definitions -> list Core_ctype.ctype -> list Core_ctype.ctype
let rec unfoldCtypes tagDefs = function
  | [] ->
      []
  
  | (Core_ctype.Array ty (Just n) :: sh) ->
      let xs = unfoldCtypes tagDefs [ty] in
      let ys = unfoldCtypes tagDefs sh   in
      concatMap (replicate $ natFromInteger n) xs ++ ys
  
  | (Core_ctype.Struct tag :: sh) ->
      let (Just ident_tys) = Map.lookup tag tagDefs in
      (unfoldCtypes tagDefs (map snd ident_tys)) ++ (unfoldCtypes tagDefs sh)
  
  | (ty :: sh) ->
      ty :: unfoldCtypes tagDefs sh
end


val offsetFromShift: tag_definitions -> pointer_shift -> offset
val     offsetFromShift_aux: pointer_shift -> maybe (Core_ctype.ctype * pointer_shift)
let rec offsetFromShift_aux xs =
  match xs with
    | [] ->
        Nothing
    | ((ty, n) :: sh' as sh) ->
        if n = 0 then
          offsetFromShift_aux sh'
        else if n > 0 then
          Just (ty, (ty, n-1) :: sh')
        else
          assert_false "[Memory.offsetFromShift_aux] found a negative shift"
  end

let offsetFromShift tagDefs ptr_sh =
  unfoldCtypes tagDefs $ unfoldr offsetFromShift_aux ptr_sh


(* build a pointer shift to "one past" the footprint of a given type *)
val     mkShiftToEnd: Core_ctype.ctype -> memM pointer_shift
let rec mkShiftToEnd ty =
  match ty with
    | Core_ctype.Array ty (Just n) ->
        SEU.replicateM (natFromInteger n) (mkShiftToEnd ty) >>= comb SEU.return List.concat
    | Core_ctype.Struct tag ->
        SEU.read (fun st -> Map.lookup tag st.tagDefinitions) >>= fun (Just ident_tys) ->
        List.concat <$> SEU.mapM (comb mkShiftToEnd snd) ident_tys
    | ty ->
        SEU.return [(ty, 1)]
  end


(* TODO: rename *)
val     foo: forall 'a. Eq 'a => list 'a -> list 'a -> maybe (either (list 'a) (list 'a))
let rec foo xs ys =
  match (xs, ys) with
    | ([], ys) ->
        Just (Right ys)
    | (xs, []) ->
        Just (Left  xs)
    | (x::xs, y::ys) ->
        if x = y then
          foo xs ys
        else
          Nothing
  end


val decider: offset * footprint -> offset * footprint -> mem_value -> maybe (offset * footprint * mem_value)
let decider (rOffset, rFootprint) (wOffset, wFootprint) wVal =
  match foo rOffset wOffset with
    | Nothing ->
        (* some type in the read / write offsets didn't match *)
        assert_false "Mem.decider: type problem"
    | Just (Left rOffset') ->
        (* the read offset is larger than that of the write *)
        match foo rOffset' wFootprint with
          | Just (Right xs) ->
              if xs <> [] then
                Just (rOffset', rFootprint, wVal)
              else
                Nothing
          | _ ->
              Nothing
        end
    | Just (Right wOffset') ->
        (* the read offset is shorter than that of the write *)
        match foo rFootprint wOffset' with
          | Nothing ->
              assert_false "Mem.decider: type problem"
          | Just (Left rFootprint') ->
              Just ([], rFootprint', wVal)
          
          | Just (Right _) ->
              (* the read footprint ends before that of the write *)
              Nothing
        end
  end


val getAffection: mem_read_request -> mem_write -> memM (maybe (offset * footprint * mem_value))
let getAffection r w =
  match (r, w) with
    | (MemReadRequest (PVobject rOid rSh) rTy, MemWrite (PVobject wOid wSh) wTy wVal) ->
        if rOid <> wOid then
          SEU.return Nothing
        else
          SEU.read (fun st -> st.tagDefinitions) >>= fun tagDefs ->
          let rOffset = offsetFromShift tagDefs rSh in
          let wOffset = offsetFromShift tagDefs wSh in
          offsetFromShift tagDefs <$> mkShiftToEnd rTy >>= fun rFootprint ->
          offsetFromShift tagDefs <$> mkShiftToEnd wTy >>= fun wFootprint ->
          SEU.return $ decider (rOffset, rFootprint) (wOffset, wFootprint) wVal
    | _ ->
        assert_false "Mem.getAffection"
  end


val     mkUnspec: tag_definitions -> Core_ctype.ctype -> mem_value
let rec mkUnspec tagDefs ty =
  match ty with
    | (Core_ctype.Basic _ as ty) ->
        MVunspecified ty
    | Core_ctype.Array ty (Just n) ->
        MVarray $ replicate (natFromInteger n) (mkUnspec tagDefs ty)
    | (Core_ctype.Pointer _ _ as ty) ->
        MVunspecified ty
    | (Core_ctype.Atomic _ as ty) ->
        MVunspecified ty
    | Core_ctype.Struct tag ->
        let (Just ident_tys) = Map.lookup tag tagDefs in
        MVstruct tag $ map (fun (ident, ty) -> (ident, mkUnspec tagDefs ty)) ident_tys
    | (Core_ctype.Union _ as ty) ->
        MVunspecified ty
    | (Core_ctype.Builtin _ as ty) ->
        MVunspecified ty
    | _ ->
        assert_false "Mem.mkUnspec: invalid type"
  end


(* TODO: for debug *)
let rec stringFromMemValue mem_val =
  match mem_val with
    | MVunspecified ty ->
        "(MVunspecified " ^ string_of_ctype ty ^ ")"
    | MVinteger (IVinteger n) ->
        "(MVinteger " ^ show n ^ ")"
    | MVinteger _ ->
        "(MVinteger TODO)"
    | MVfloating str ->
        "(MVfloating " ^ str ^ ")"
    | MVpointer ptr_val ->
        "(MVpointer " ^ show ptr_val ^ ")"
    | MVarray mem_vals ->
        "(MVarray " ^ stringFromList stringFromMemValue mem_vals ^ ")"
    | MVstruct sym_tag ident_mem_vals ->
        "(MVstruct " ^ show sym_tag ^ stringFromList (stringFromPair show stringFromMemValue) ident_mem_vals ^ ")"
    | MVunion sym_tag sym_member mem_val ->
        "(MVunion " ^ show sym_tag ^ " " ^ show sym_member ^ stringFromMemValue mem_val ^ ")"
  end


val combineWrites: mem_read_request -> list mem_write -> memM mem_value
let combineWrites (MemReadRequest (PVobject _ rSh) rTy as r) ws =
  catMaybes <$> SEU.mapM (getAffection r) ws >>= function
    | [] ->
        SEU.fail $ MerrOther ("myCombineWrites: uninit ==> " ^ show (r, ws))
    |  xs ->
        SEU.read (fun st -> st.tagDefinitions) >>= fun tagDefs ->
        let unV = mkUnspec tagDefs rTy in
        let rOff = offsetFromShift tagDefs rSh in
        
        (* TODO: may need a reverse of xs *)
        SEU.foldM (fun acc (wOff, wFp, wVal) ->
          match getSubValue wVal wOff wFp with
            | Nothing ->
                SEU.fail $ MerrOther ("myCombineWrites: some footprint was too big: " ^
                                      stringFromMemValue wVal ^ ", " ^ stringFromList string_of_ctype wOff ^ ", " ^ stringFromList string_of_ctype wFp)

            | Just mval ->
                SEU.return $ setValue tagDefs acc (List.deletes wOff rOff) mval
          end
        ) unV (List.reverse xs) (* TODO: there is a problem somewhere (see Sandbox/cerb/array2.c) *)
  end
























(* Memory layout model API ================================================== *)
type memop =
  | Ptreq
  | Ptrdiff (* (address, address) -> integer *)
  | Intptr  (* address -> integer *)
  | PtrLt


val runMem: forall 'a. memM 'a -> mem_state -> either mem_error ('a * mem_state)

val initial_mem_stateWithTagDefinitions: tag_definitions -> mem_state


val allocate_object:    Thread.thread_id  (* the allocating thread *)
                     -> list Symbol.t     (* symbols coming from the Core/C program, for debugging purpose *)
                     -> Core_ctype.ctype  (* type of the allocation *)
(*                   -> Symbolic.symbolic (* size of that type *)
                     -> Symbolic.symbolic (* alignment of that tyepe *)  *)
                     -> memM pointer_value

val load: Core_ctype.ctype -> pointer_value -> memM mem_value
val store: Core_ctype.ctype -> pointer_value -> mem_value -> memM unit

val shift_pointer_value: pointer_value -> list (Core_ctype.ctype * integer_value) -> pointer_value


(* TODO: change the name *)
val mk_integer_value: integer -> integer_value
val mk_integer_op: integer_operator -> integer_value -> integer_value -> integer_value

val mk_unspecified: Core_ctype.ctype -> mem_value
val mk_integer: integer -> mem_value
val mk_floating: string -> mem_value
val mk_pointer: pointer_value -> mem_value
val mk_array: list mem_value -> mem_value

val mk_ptrdiff: pointer_value -> pointer_value -> mem_value

val null_pointer: Core_ctype.ctype -> pointer_value
val function_pointer: Symbol.t -> pointer_value
val ptr_from_mem_value: mem_value -> maybe pointer_value
val symb_from_mem_value: mem_value -> maybe Symbolic.symbolic







let runMem m mem_st =
  match SEU.run m mem_st with
    | Exception.Result (Undefined.Defined z, mem_st') ->
        Right (z, mem_st')
    | Exception.Exception err ->
        Left err
(* TODO: undef case *)
  end


let initial_mem_stateWithTagDefinitions tagDefs = <|
  oid_supply=     UniqueId.new_supply;
  objTypes=       Map.empty;
  tagDefinitions= tagDefs;
  memWrites=      [];
|>


val fresh_object_id: list Symbol.t -> State.t object_id mem_state
let fresh_object_id pref =
  State.modify (fun st ->
    let (n, oid_suppl') = UniqueId.fresh_id st.oid_supply in
    ((n, pref), <| st with oid_supply= oid_suppl' |>)
  )





let allocate_object tid pref ty =
  SEU.runS (fresh_object_id pref) >>= fun oid ->
  SEU.return $ PVobject oid []


let load ty ptr_val =
  begin_timing "Mem.load" >>
  SEU.read (fun st -> st.memWrites) >>=
    combineWrites (MemReadRequest ptr_val ty) >>= fun ret ->
  end_timing () >>
  SEU.return ret


let store ty ptr_val mem_val =
  SEU.update (fun st ->
    <| st with memWrites= (MemWrite ptr_val ty mem_val) :: st.memWrites |>
  )
(*
let store ty ptr_val mem_val =
  let _ = output_debug 3 ("Mem.store: (" ^ string_of_ctype ty ^ ") " ^ show ptr_val ^ " := " ^ show mem_val) in
  (* TODO: ty ?? *)
  SEU.update (fun st ->
    <| st with memWrites= (ptr_val, mem_val) :: st.memWrites |>
  )
*)


let shift_pointer_value ptr_val ptr_sh' =
  (* TODO: forcing concrete offsets for now *)
  let ptr_sh' = map (fun (id, IVinteger n) -> (id, n)) ptr_sh' in
  match ptr_val with
    | PVobject oid ptr_sh ->
        PVobject oid (ptr_sh ++ ptr_sh') (* (normaliseShift $ ptr_sh ++ ptr_sh') *)
  end


let mk_integer_value n =
  IVinteger n


let mk_integer_op op ival1 ival2 =
  match (op, ival1, ival2) with
    | (IntAdd, IVinteger n1, IVinteger n2) ->
        IVinteger (n1 + n2)
    | (IntSub, IVinteger n1, IVinteger n2) ->
        IVinteger (n1 - n2)
    | (IntMul, IVinteger n1, IVinteger n2) ->
        IVinteger (n1 * n2)
    | (IntDiv, IVinteger n1, IVinteger n2) ->
        IVinteger (if n2 = 0 then 0 else n1 / n2)
    | (IntMod, IVinteger n1, IVinteger n2) ->
        IVinteger (if n2 = 0 then 0 else n1 mod n2)
    | (IntExp, IVinteger n1, IVinteger n2) ->
        IVinteger (n1 ** natFromInteger n2)
    | _ ->
        IVop op ival1 ival2
  end



let mk_integer_symbolic symb =
  IVsymbolic symb



let mk_unspecified ty =
  MVunspecified ty



let mk_integer n =
  MVinteger (IVinteger n)

let mk_floating str =
  MVfloating str

let mk_pointer ptr_val =
  MVpointer ptr_val

let mk_array mem_vals =
  (* TODO: assert mem_vals <> [] *)
  MVarray mem_vals

let mk_ptrdiff ptr_val1 ptr_val2 =
  MVinteger (IVptrdiff ptr_val1 ptr_val2)

let null_pointer ty =
  PVnull ty

let function_pointer fsym =
  PVfunction fsym

let ptr_from_mem_value = function
  | MVpointer ptr_val ->
      Just ptr_val
  | _ ->
      Nothing
end

let symb_from_mem_value = function
  | MVinteger (IVsymbolic symb) ->
      Just symb
  | _ ->
      Nothing
end





(* TODO: move up to API *)
val integer_value_is_concrete: integer_value -> bool
let integer_value_is_concrete = function
  | IVsymbolic _ ->
      false
  | _ ->
      (* TODO: should it return false for IVptrdiff and IVintptr? *)
      true
end

val     symbolify_mem_value: mem_value -> Symbolic.symbolic
let rec symbolify_mem_value mem_val =
  match mem_val with
    | MVpointer ptr_val ->
        assert_false "TODO: Core_aux.symbolify_mem_value: MVpointer"
(*
        Symbolic.SYMBptr ptr_val
*)
    | MVinteger ival ->
        assert_false "TODO: symbolify integer_value"
    | MVarray mem_vals ->
        assert_false "TODO: Core_aux.symbolify_mem_value: MVarray"
(*
        Symbolic.SYMBarray (List.map symbolic_mem_value mem_vals)
*)
  end
