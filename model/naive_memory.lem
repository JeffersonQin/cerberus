open import Pervasives
open import Global

import State_exception_undefined
import Symbol Symbolic Core_ctype Thread

module SEU = State_exception_undefined


(* TODO: debug *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`

(* TODO: debug *)
val output_string: string -> unit
declare ocaml target_rep function output_string = `Pervasives.print_endline`



type object_id = nat


type memory_state = <|
  oid_supply: UniqueId.supply object_id
|>

let initial_memory_state = <|
  oid_supply= UniqueId.new_supply;
|>


type memory_error =
  | MEMORY_ERROR

type memM 'a = SEU.t 'a memory_state memory_error


(* val runMem: forall 'a. memM 'a ->  *)


type pointer_value =
(*  | Pointer_null of Core_ctype.ctype *)
  | Pointer_nonnull of object_id
  | Pointer_function of Symbol.t

let pointer_value_eq ptr_val1 ptr_val2 =
  match (ptr_val1, ptr_val2) with
    | (Pointer_nonnull oid1, Pointer_nonnull oid2) ->
        oid1 = oid2
    | (Pointer_function sym1, Pointer_function sym2) ->
        sym1 = sym2
    | _ ->
        false
  end


(* TODO: debug *)
let string_of_pointer_value = function
  | Pointer_nonnull oid ->
      "Pointer_nonnull[" ^ string_of_natural (naturalFromNat oid) ^ "]"
  | Pointer_function (Symbol.Symbol n str_opt) ->
      let sym_str = match str_opt with
        | Just str -> 
            string_of_natural (naturalFromNat n) ^ ": " ^ str
        | Nothing ->
            string_of_natural (naturalFromNat n)
      end in
      "Pointer_function[" ^ sym_str ^ "]"
end



instance (Eq pointer_value)
  let (=) = pointer_value_eq
  let (<>) = fun x y -> not (pointer_value_eq x y)
end

(* TODO ... *)
let mapKeyCompare_pointer_value ptr_val1 ptr_val2 =
  if pointer_value_eq ptr_val1 ptr_val2 then EQ else
  let _ = output_string $ string_of_pointer_value ptr_val1 ^ " /= " ^ string_of_pointer_value ptr_val2 in
  GT

instance (MapKeyType pointer_value)
  let mapKeyCompare = mapKeyCompare_pointer_value
end




type mem_value =
  | MV_pointer of pointer_value
  | MV_integer of Symbolic.symbolic   (* possibly-symbolic integer value *)
  | MV_array of list mem_value
(*
  | MV_struct of list (Symbol.t * mem_value)
  | MV_union of Symbol.t * mem_value
  | MV_pointer_byte of nat * nat * pointer_value 
  | MV_unspecified of Core_ctype.ctype
*)

(* TODO: debug *)
let rec string_of_mem_value mem_val =
  match mem_val with
    | MV_pointer ptr_val ->
        "MV_pointer[" ^ string_of_pointer_value ptr_val ^ "]"
    | MV_integer symb ->
        "MV_integer[TODO]"
    | MV_array mem_vals ->
        "MV_array[" ^ List.foldr (fun mem_val acc ->  string_of_mem_value mem_val ^ ", " ^ acc) "" mem_vals ^ "]"
end




(* TODO: part of Mem API *)
val mk_integer: integer -> mem_value
let mk_integer n =
  MV_integer (Symbolic.SYMBconst n)

(* TODO: part of Mem API *)
val mk_array : list mem_value -> mem_value
let mk_array mem_vals =
  MV_array mem_vals


let rec mem_value_eq mem_val1 mem_val2 =
  match (mem_val1, mem_val2) with
    | (MV_pointer ptr_val1, MV_pointer ptr_val2) ->
        ptr_val1 = ptr_val2
    | (MV_integer symb1, MV_integer symb2) ->
        (* TODO: should use the constrain solver somewhere *)
        symb1 = symb2
    | (MV_array mem_vals1, MV_array mem_vals2) ->
        List.all (uncurry mem_value_eq) $ List.zip mem_vals1 mem_vals2
    | _ ->
        false
  end

instance (Eq mem_value)
  let (=) = mem_value_eq
  let (<>) = fun x y -> not (mem_value_eq x y)
end


(*
val     setElemCompare_mem_value: mem_value -> mem_value -> ordering
let rec setElemCompare_mem_value mem_value1 mem_value2 =
  match (mem_value1, mem_value2) with
    | (

    | (Tseq tid1', _) -> setElemCompare tid1' tid2
    | (_, Tseq tid2') -> setElemCompare tid1 tid2'
    | (Tzero, Tzero) -> EQ
    | (Tpar n1 tid1', Tpar n2 tid2') -> pairCompare setElemCompare setElemCompare (n1, tid1') (n2, tid2')
    | (Tzero, _) -> LT
    | (_, Tzero) -> GT
  end
*)

(* TODO ... *)
let setElemCompare_mem_value mem_val1 mem_val2 =
  if mem_value_eq mem_val1 mem_val2 then EQ else LT

instance (SetType mem_value)
  let setElemCompare = setElemCompare_mem_value
end





val null_pointer: Core_ctype.ctype -> pointer_value
let null_pointer ty =
  assert_false "Pointer_null ty"


val function_pointer: Symbol.t -> pointer_value
let function_pointer fsym =
  Pointer_function fsym




val fresh_object_id: State.t object_id memory_state
let fresh_object_id =
  State.modify (fun st ->
    let (oid, oid_suppl') = UniqueId.fresh_id st.oid_supply in
    (oid, <| st with oid_supply= oid_suppl' |>)
  )






open SEU.Operators

val allocate_object:    Thread.thread_id  (* the allocating thread *)
                     -> Core_ctype.ctype  (* type of the allocation *)
(*
                     -> Symbolic.symbolic (* size of that type *)
                     -> Symbolic.symbolic (* alignment of that type *)
*)
                     -> memM pointer_value
let allocate_object (* tid ty size_symb align_symb *) _ ty =
  SEU.runS fresh_object_id >>= fun oid ->
  SEU.return (Pointer_nonnull oid)
