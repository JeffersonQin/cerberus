(* TODO: the locations are all messed up !! *)
open Global

module C0 = Cabs0
module C = Cabs

val dummy_location: C.cabsloc
let dummy_location =  <|
  C.lineno= 0;
  C.filename= "";
  C.byteno= 0;
  C.ident= 0;
|>


let f_opt f = function
  | Some x -> Some (f x)
  | None   -> None
end

let f_opt_list f = function
  | Some x -> f x
  | None   -> []
end


val translate_typeSpecifier: C0.typeSpecifier -> C.specifier
val translate_storage: C0.storage -> C.storage_class
val translate_cvspec: C0.cvspec -> C.qualifier
val translate_spec_elem_list: list C0.spec_elem -> list C.storage_class * C.qualifiers * C.specifiers
val translate_field_group: C0.field_group -> list C.field

let rec translate_typeSpecifier spec =
  match spec with
    | C0.Tvoid     -> C.VOID
    | C0.Tchar     -> C.CHAR
    | C0.Tshort    -> C.SHORT
    | C0.Tint      -> C.INT
    | C0.Tlong     -> C.LONG
    | C0.Tfloat    -> C.FLOAT
    | C0.Tdouble   -> C.DOUBLE
    | C0.Tsigned   -> C.SIGNED
    | C0.Tunsigned -> C.UNSIGNED
    | C0.T_Bool    -> C.BOOL
    | C0.Tnamed a  -> C.NAMED a
    | C0.Tatomic (specs, decl) ->
        C.ATOMIC (fst $ mk_c_type specs decl)
    (* NOTE: for struct/union, our AST forgets "field groups" *)
    | C0.Tstruct a_opt fields_opt [] ->
        C.STRUCT a_opt (f_opt_list (List.flatten -| List.map translate_field_group) fields_opt) []
    | C0.Tunion a_opt fields_opt [] ->
        C.UNION a_opt (f_opt_list (List.flatten -| List.map translate_field_group) fields_opt) []

(*
    | C0.Tenum a_opt xs attrs ->
        let f (a, e_opt, l) = (a, f_opt (translate_expression) e_opt) in
        C.ENUM a_opt (f_opt (List.map f) xs) (List.map translate_attribute attrs)
*)
  end




and translate_cvspec s =
  match s with
    | C0.CV_CONST    -> C.CONST
    | C0.CV_VOLATILE -> C.VOLATILE
    | C0.CV_RESTRICT -> C.RESTRICT
    | C0.CV_ATOMIC   -> C.ATOMIC_Q
  end


(* OK *)
and translate_spec_elem_list specs =
  (* C0.storage -> C.storage_class *)
  let translate_storage = function
    | C0.AUTO         -> C.AUTO
    | C0.STATIC       -> C.STATIC
    | C0.EXTERN       -> C.EXTERN
    | C0.REGISTER     -> C.REGISTER
    | C0.TYPEDEF      -> C.TYPEDEF
    | C0.THREAD_LOCAL -> C.THREAD_LOCAL
  end in
  let f (scs, qs, ss) = function
    | C0.SpecCV cv      -> (scs, Set.add (translate_cvspec cv) qs, ss)
    | C0.SpecStorage st -> (translate_storage st :: scs, qs, ss)
    | C0.SpecType spec  -> (scs, qs, Multiset.add (translate_typeSpecifier spec) ss)
    
(*
    | C0.SpecInline -> Boot.assert_false "TODO[Cabs_transform.translate_spec_elem_list] SpecInline: not sure what to do with this one"
    | C0.SpecAttr _ -> Boot.assert_false "[Cabs_transform.translate_spec_elem_list] we do not support atrributes"
*)
(* TODO: hack *)
    | _ -> (scs, qs, ss)

  end in
  List.fold_left f ([], {}, Multiset.emp) specs






(* TODO: temporary getting rid of the attributes (to change soon) *)
(* TODO: pretty sure I made a mistake somewhere *)
and translate_decl decl =
  match decl with
    | C0.JUSTBASE ->
        fun (qs, ss) -> C.BASE qs ss


    | C0.ARRAY decl cvspecs attrs e_opt ->
        fun (qs, ss) ->
          
(*          (translate_decl decl ([], Set.from_list (List.map translate_cvspec cvspecs), ss)) *)

          C.ARRAY {} (C.BASE qs ss) (f_opt translate_expression e_opt)

(*
          C.ARRAY qs (translate_decl decl ([], Set.from_list (List.map translate_cvspec cvspecs), ss))
                      (f_opt translate_expression e_opt)
*)

    | C0.PTR cvspecs attrs decl ->
        fun (qs, ss) ->
(*          C.POINTER qs (translate_decl decl ([], Set.from_list (List.map translate_cvspec cvspecs), ss)) *)
          C.POINTER {} (C.BASE qs ss)


    (* NOTE: ignoring the VLA flag (not supported for now) *)
    | C0.PROTO decl (params, is_vla) ->
        let params' = List.map (fun (C0.PARAM specs n_opt decl attrs _) ->
          let n = match n_opt with Some n -> n | None -> "" end in (* HACK!!! to get void params (which are unnamed) (not not) working *)
          let (ty, scs) = mk_c_type specs decl in
          ((n, ty, scs), Location.dummy)
        ) params in
        
        fun (qs, ss) ->
          C.FUNCTION (translate_decl decl ({}, ss))
                      params'


  end






(* list C0.spec_elem -> C0.decl_type -> C.c_type * list C.storage_class *)
and mk_c_type specs decl_t =
  (* extract the storage_classes, qualifiers and specifiers from a list spec_elem.
     This apply to the base type of the declaration. *)
  let (scs, qs, ss) = translate_spec_elem_list specs in
  (translate_decl decl_t (qs, ss), scs)





and translate_field_group fg =
    match fg with
      | C0.Field_group specs nes _ ->
          let (scs, qs, ss) = translate_spec_elem_list specs in
          List.map function
            | (Some (C0.Name n decl attrs l), None) ->
                C.BasicField n (fst $ mk_c_type specs decl)
            | (Some (C0.Name n decl attrs l), Some e) ->
                C.BitField (Some n) (fst $ mk_c_type specs decl) (translate_expression e)
            | (None, Some e) ->
                C.BitField None (fst $ mk_c_type specs C0.JUSTBASE) (translate_expression e)
          end nes
    end


















(* TODO: locations are likely to be messed up *)
(*val     translate_statement: C0.statement -> C.stmt_l *)
and translate_statement s =
  let fe = translate_expression in
  let fd = translate_definition in
  let fs = translate_statement in
  (* TODO(K) Not that we need it anymore, but why does uncommenting the next line makes this function
             ill-typed. Looks like f_opt's polymorphism is restriction but I don't understand why. *)
(*  let f_opt f = function Some x -> Some (f x) | None -> None end in *)
  (match s with
    | C0.NOP _                                      -> C.SKIP
    | C0.COMPUTATION e _                            -> C.EXPRESSION (fe e)
    | C0.BLOCK ss _                                 -> C.BLOCK (List.map fs ss)
    | C0.If e s1 s2_opt _                           -> C.IF (fe e) (fs s1) (f_opt fs s2_opt)
    | C0.WHILE e s _                                -> C.WHILE (fe e) (fs s)
    | C0.DOWHILE e s _                              -> C.DO (fe e) (fs s)
    | C0.FOR None e2_opt e3_opt s _                 -> C.FOR_EXP None (f_opt fe e2_opt) (f_opt fe e3_opt) (fs s)
    | C0.FOR (Some (C0.FC_EXP e1)) e2_opt e3_opt s _ -> C.FOR_EXP (Some (fe e1)) (f_opt fe e2_opt) (f_opt fe e3_opt) (fs s)
(*
C has a single definition but C' has a defn_l list

    | C0.FOR (C0.FC_DECL d, e1_opt, e2_opt, e3_opt, s, l) -> (C.FOR_DECL (List.map fd ), l)
*)

    | C0.BREAK _        -> C.BREAK
    | C0.CONTINUE _     -> C.CONTINUE
    | C0.RETURN e_opt _ -> C.RETURN (f_opt fe e_opt)
    | C0.SWITCH e s _   -> C.SWITCH (fe e) (fs s)
    | C0.CASE e s _     -> C.CASE (fe e) (fs s)
    | C0.DEFAULT s _    -> C.DEFAULT (fs s)
    | C0.LABEL a s _    -> C.LABEL a (fs s)
    | C0.GOTO a _       -> C.GOTO a
    | C0.PAR ss _       -> C.PAR (List.map fs ss)
    | C0.DEFINITION def -> C.DECLARATION (translate_definition_to_declarations def)
(*
TODO: add cppmem's par to the parser
  | PAR of stmt_l list (* TODO: (temporary) adding cppmem's parallel composition *)
*)
   end, Location.dummy)







(* TODO: no attribute for now *)
and translate_definition_to_declarations d =
  match d with
    | C0.FUNDEF _ _ _ _ ->
        Boot.assert_false "[Cabs_transform.translate_definition_to_declarations] found a nested function"

    | C0.DECDEF (specs, []) _ ->
        [(C.TYPE_DEF (fst $ mk_c_type specs C0.JUSTBASE), Location.dummy)]
    
    | C0.DECDEF (specs, ins) _ ->
        (* create a Cabs definition for each Cabs0 init_name *)
        List.map (fun (C0.Init_name (C0.Name ident decl_t [] _) ie) ->
          let (ty, scs) = mk_c_type specs decl_t in
          ((C.OTHER_DEF ((ident, ty, scs), Location.dummy) (translate_init_expression ie)), Location.dummy)
        ) ins
    | C0.PRAGMA s l ->
        Boot.assert_false "[Cabs_transform.translate_definition_to_declarations] PRAGMA: not supported for now"
  end



































(* only supporting decimal for now *)
and decode_integer_constant ic =
  let (n, suff) = Boot.span_string Boot.is_digit ic in
  (Int.int_of_string n,
   match suff with
     | ""    -> None
     | "u"   -> Some C.SUFFIX_UNSIGNED
     | "U"   -> Some C.SUFFIX_UNSIGNED
     | "l"   -> Some C.SUFFIX_LONG
     | "L"   -> Some C.SUFFIX_LONG
     | "ul"  -> Some C.SUFFIX_UNSIGNED_LONG
     | "uL"  -> Some C.SUFFIX_UNSIGNED_LONG
     | "Ul"  -> Some C.SUFFIX_UNSIGNED_LONG
     | "UL"  -> Some C.SUFFIX_UNSIGNED_LONG
     | "ll"  -> Some C.SUFFIX_LONG_LONG
     | "LL"  -> Some C.SUFFIX_LONG_LONG
     | "ull" -> Some C.SUFFIX_UNSIGNED_LONG_LONG
     | "uLL" -> Some C.SUFFIX_UNSIGNED_LONG_LONG
     | "Ull" -> Some C.SUFFIX_UNSIGNED_LONG_LONG
     | "ULL" -> Some C.SUFFIX_UNSIGNED_LONG_LONG
     | _     -> Boot.assert_false ("[Cabs_transform.decode_integer_constant] impossible case: " ^ suff)
   end)

and translate_integer_suffix suff =
  match suff with
    | C0.SUFFIX_UNSIGNED           -> C.SUFFIX_UNSIGNED
    | C0.SUFFIX_UNSIGNED_LONG      -> C.SUFFIX_UNSIGNED_LONG
    | C0.SUFFIX_UNSIGNED_LONG_LONG -> C.SUFFIX_UNSIGNED_LONG_LONG
    | C0.SUFFIX_LONG               -> C.SUFFIX_LONG
    | C0.SUFFIX_LONG_LONG          -> C.SUFFIX_LONG_LONG
  end

and translate_character_prefix pref =
  match pref with
    | C0.PREFIX_L -> C.PREFIX_L
    | C0.PREFIX_u -> C.PREFIX_u
    | C0.PREFIX_U -> C.PREFIX_U
  end

and translate_constant c =
  match c with
    | C0.CONST_INT n None         -> C.CONST_INT (n, None)
    | C0.CONST_INT n (Some suff)  -> C.CONST_INT (n, Some (translate_integer_suffix suff))
    | C0.CONST_FLOAT f            -> C.CONST_FLOAT f
    | C0.CONST_CHAR None c        -> C.CONST_CHAR (None, c)
    | C0.CONST_CHAR (Some pref) c -> C.CONST_CHAR (Some (translate_character_prefix pref), c)
  end


(* val translate_unary_operator: C0.unary_operator -> C.unary_operator *)
and translate_unary_operator uop =
  match uop with
    | C0.MINUS   -> C.MINUS
    | C0.PLUS    -> C.PLUS
    | C0.NOT     -> C.NOT
    | C0.BNOT    -> C.BNOT
    | C0.MEMOF   -> C.INDIRECTION
    | C0.ADDROF  -> C.ADDRESS
    | C0.PREINCR -> C.PREFIX_INCR
    | C0.PREDECR -> C.PREFIX_DECR
    | C0.POSINCR -> C.POSTFIX_INCR
    | C0.POSDECR -> C.POSTFIX_DECR
  end


(* val translate_binary_operator: C0.binary_operator -> C.binary_operator *)
and translate_binary_operator binop =
  match binop with
    | C0.ADD   -> C.ARITHMETIC C.ADD
    | C0.SUB   -> C.ARITHMETIC C.SUB
    | C0.MUL   -> C.ARITHMETIC C.MUL
    | C0.DIV   -> C.ARITHMETIC C.DIV
    | C0.MOD   -> C.ARITHMETIC C.MOD
    | C0.AND   -> C.AND
    | C0.OR    -> C.OR
    | C0.BAND  -> C.ARITHMETIC C.BAND
    | C0.BOR   -> C.ARITHMETIC C.BOR
    | C0.XOR   -> C.ARITHMETIC C.XOR
    | C0.SHL   -> C.ARITHMETIC C.SHL
    | C0.SHR   -> C.ARITHMETIC C.SHR
    | C0.EQ    -> C.EQ
    | C0.NE    -> C.NE
    | C0.LT    -> C.LT
    | C0.GT    -> C.GT
    | C0.LE    -> C.LE
    | C0.GE    -> C.GE
    | C0.COMMA -> C.COMMA
    | _       -> Boot.assert_false "[Cabs_transform] trying to convert an `assign binop' from the Parser to our Cabs"
  end


(* val translate_expression: C0.expression -> C.exp_l *)
(* TODO: the parser AST doesn't have [TYPE_ALIGNOF of c_type], nor [GENERIC_SELECTION of exp_l * generic_association_l list] *)
(* TODO: move [STRING_LITERAL of string_literal] from our AST to constant *)
and translate_expression e =
  let fe = translate_expression in
  (match e with
    | C0.UNARY uop e                 -> C.UNARY (translate_unary_operator uop) (fe e)
    | C0.BINARY C0.ASSIGN e1 e2      -> C.ASSIGN None (fe e1) (fe e2)
    | C0.BINARY C0.ADD_ASSIGN e1 e2  -> C.ASSIGN (Some C.ADD) (fe e1) (fe e2)
    | C0.BINARY C0.SUB_ASSIGN e1 e2  -> C.ASSIGN (Some C.SUB) (fe e1) (fe e2)
    | C0.BINARY C0.MUL_ASSIGN e1 e2  -> C.ASSIGN (Some C.MUL) (fe e1) (fe e2)
    | C0.BINARY C0.DIV_ASSIGN e1 e2  -> C.ASSIGN (Some C.DIV) (fe e1) (fe e2)
    | C0.BINARY C0.MOD_ASSIGN e1 e2  -> C.ASSIGN (Some C.MOD) (fe e1) (fe e2)
    | C0.BINARY C0.BAND_ASSIGN e1 e2 -> C.ASSIGN (Some C.BAND) (fe e1) (fe e2)
    | C0.BINARY C0.BOR_ASSIGN e1 e2  -> C.ASSIGN (Some C.BOR) (fe e1) (fe e2)
    | C0.BINARY C0.XOR_ASSIGN e1 e2  -> C.ASSIGN (Some C.XOR) (fe e1) (fe e2)
    | C0.BINARY C0.SHL_ASSIGN e1 e2  -> C.ASSIGN (Some C.SHL) (fe e1) (fe e2)
    | C0.BINARY C0.SHR_ASSIGN e1 e2  -> C.ASSIGN (Some C.SHR) (fe e1) (fe e2)
    | C0.BINARY binop e1 e2          -> C.BINARY (translate_binary_operator binop) (fe e1) (fe e2)
    | C0.QUESTION e1 e2 e3           -> C.CONDITIONAL (fe e1) (fe e2) (fe e3)

(*
    | C0.CAST (ty, C0.COMPOUND_INIT inits) -> C.COMPOUND_LITERAL 
*)

    | C0.CAST (specs, decl) (C0.SINGLE_INIT e) ->  C.CAST (fst $ mk_c_type specs decl) (translate_expression e)



    | C0.CALL e es                   -> C.CALL (fe e) (List.map fe es)
    | C0.BUILTIN_VA_ARG e specs_decl -> Boot.assert_false "[Cabs_transform.translate_init_expression] TODO: C0.BUILTIN_VA_ARG"
    | C0.CONSTANT (C0.CONST_STRING str) -> C.STRING_LITERAL (None, str) (* HACK for now *)

    | C0.CONSTANT c                  -> C.CONSTANT (translate_constant c)
    | C0.VARIABLE x                  -> C.IDENTIFIER x
    | C0.EXPR_SIZEOF e               -> C.EXPR_SIZEOF (fe e)
    | C0.TYPE_SIZEOF (specs, decl)   -> C.TYPE_SIZEOF (fst $ mk_c_type specs decl)
    | C0.ALIGNOF (specs, decl)       -> C.TYPE_ALIGNOF (fst $ mk_c_type specs decl)
    | C0.INDEX e1 e2                 -> C.SUBSCRIPT (fe e1) (fe e2)
    | C0.MEMBEROF e x                -> C.MEMBEROF (fe e) x
    | C0.MEMBEROFPTR e x             -> C.MEMBEROFPTR (fe e) x
    | C0.OFFSETOF (specs, decl) x    -> C.OFFSETOF (fst $ mk_c_type specs decl) x
  end, Location.dummy)



(* TODO: pretty yucky *)

and translate_init_expression_aux (ie: C0.init_expression) : option C.init  =
  match ie with
    | C0.SINGLE_INIT e -> Some (C.SINGLE_INIT $ translate_expression e)
    | C0.COMPOUND_INIT is ->
        let is' = List.map (fun (xs, ie) ->
          match xs with
            | [] -> translate_init_expression_aux ie
            | _  -> None
          end) is in
        List.fold_left (fun acc_opt ci' ->
          match acc_opt with
            | None                    -> None
            | Some (C.ARRAY_INIT acc) -> match ci' with
                | None     -> None
                | Some ci' -> Some $ C.ARRAY_INIT (ci' :: acc)
               end
          end) (Some $ C.ARRAY_INIT []) is'
  end






(* val translate_init_expression: C0.init_expression -> option C.exp_l *)
and translate_init_expression ie =
  match ie with
    | C0.NO_INIT -> None
    | _ -> match translate_init_expression_aux ie with
             | Some z -> Some z
             | None -> Boot.assert_false "[Cabs_transform.translate_init_expression], \
                                          COMPOUND_INIT TODO: only supporting arrays for now (and \
                                          not even doing length checks as this has to be done in \
                                          the typechecking)"
           end
  end



(* val translate_definition: C0.definition -> C.g_defn_l *)
and translate_definition d =
  match d with
    | C0.FUNDEF specs (C0.Name fname decl attrs _) s _ ->
        Some $
        (* TODO: should be doing something with [attrs] *)
        let (ftype, scs) = mk_c_type specs decl in
        (C.FUNCTION_DEFINITION ((fname, ftype, scs), Location.dummy) (translate_statement s), Location.dummy)
    
    (* TODO: I think this correspond to the def of a struct/union (typedef?) *)
    | C0.DECDEF (specs, []) l ->
        Some $
        (C.EXTERNAL_DECLARATION
          [(C.TYPE_DEF (fst $ mk_c_type specs C0.JUSTBASE), Location.dummy)], Location.dummy)
    
    | C0.DECDEF (specs, ins) l ->
        Some $
        (C.EXTERNAL_DECLARATION $
          List.map (fun (C0.Init_name (C0.Name x decl attrs _) ie) ->
            let (ty, scs) = mk_c_type (specs @ List.map (C0.SpecAttr) attrs) decl in
            (C.OTHER_DEF ((x, ty, scs), Location.dummy) (translate_init_expression ie), Location.dummy)
          ) ins, Location.dummy)
    
    | C0.PRAGMA s l ->
        None
 end


(* TODO: use C0.file / C.file instead *)
val transform_file: list C0.definition -> list C.g_defn_l
let transform_file defs =
  List.fold_left (fun acc def ->
    match translate_definition def with
      | Some z -> z :: acc
      | None   -> acc
   end) [] defs
