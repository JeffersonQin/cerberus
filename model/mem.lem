open import Pervasives
import Symbol Core_ctype Core_ctype AilTypes Float

import Mem_common

type pointer_value
type integer_value
type floating_value
declare ocaml target_rep type pointer_value  = `Ocaml_mem.pointer_value`
declare ocaml target_rep type integer_value  = `Ocaml_mem.integer_value`
declare ocaml target_rep type floating_value = `Ocaml_mem.floating_value`

type mem_value
declare ocaml target_rep type mem_value = `Ocaml_mem.mem_value`

type mem_iv_constraint = Mem_common.mem_constraint integer_value


instance (Show pointer_value)
  let show ptrval = "TODO"
end
instance (Show mem_value)
  let show mval = "TODO"
end


(* This abstract in returns by memory actions and two footprints can be checked for overlapping.
   They are in particular useful to detect races. *)
type footprint
val do_overlap: footprint -> footprint -> bool
declare ocaml target_rep type footprint = `Ocaml_mem.footprint`
declare ocaml target_rep function do_overlap = `Ocaml_mem.do_overlap`


type mem_state
val initial_mem_state: mem_state
declare ocaml target_rep type mem_state = `Ocaml_mem.mem_state`
declare ocaml target_rep function initial_mem_state = `Ocaml_mem.initial_mem_state`


type memM 'a =
  Nondeterminism.ndM 'a string Mem_common.mem_error (Mem_common.mem_constraint integer_value) mem_state

val return: forall 'a. 'a -> memM 'a
let inline return = Nondeterminism.return

val bind: forall 'a 'b. memM 'a -> ('a -> memM 'b) -> memM 'b
let inline bind = Nondeterminism.bind


(* Memory actions *)
val allocate_static:
     Core_ctype.thread_id  (* the allocating thread *)
  -> Symbol.prefix      (* symbols coming from the Core/C program, for debugging purpose *)
  -> integer_value      (* alignment constraint *)
  -> Core_ctype.ctype   (* type of the allocation *)
  -> maybe mem_value    (* optional initialisation value (if provided the allocation is made read-only) *)
  -> memM pointer_value

val allocate_dynamic:
     Core_ctype.thread_id  (* the allocating thread *)
  -> Symbol.prefix      (* symbols coming from the Core/C program, for debugging purpose *)
  -> integer_value      (* alignment constraint *)
  -> integer_value      (* size *)
  -> memM pointer_value

val kill: Loc.t -> bool -> pointer_value -> memM unit
val load: Loc.t -> Core_ctype.ctype -> pointer_value -> memM (footprint * mem_value)
val store: Loc.t -> Core_ctype.ctype -> (* is_locking *)bool -> pointer_value -> mem_value -> memM footprint

declare ocaml target_rep function allocate_static = `Ocaml_mem.allocate_static`
declare ocaml target_rep function allocate_dynamic = `Ocaml_mem.allocate_dynamic`
declare ocaml target_rep function kill = `Ocaml_mem.kill`
declare ocaml target_rep function load = `Ocaml_mem.load`
declare ocaml target_rep function store = `Ocaml_mem.store`


(* Pointer value constructors *)
val null_ptrval: Core_ctype.ctype -> pointer_value
val fun_ptrval: Symbol.sym -> pointer_value
declare ocaml target_rep function null_ptrval = `Ocaml_mem.null_ptrval`
declare ocaml target_rep function fun_ptrval = `Ocaml_mem.fun_ptrval`

(*TODO: revise that, just a hack for codegen*)
val concrete_ptrval: integer -> integer -> pointer_value
val case_ptrval: forall 'a. pointer_value ->
   (* null pointer *) (Core_ctype.ctype -> 'a) ->
   (* function pointer *) (Symbol.sym -> 'a) ->
   (* concrete pointer *) (maybe integer -> integer -> 'a) ->
   (* unspecified value *) (unit -> 'a) -> 'a
val case_funsym_opt: mem_state -> pointer_value -> maybe Symbol.sym

declare ocaml target_rep function concrete_ptrval = `Ocaml_mem.concrete_ptrval`
declare ocaml target_rep function case_ptrval = `Ocaml_mem.case_ptrval`
declare ocaml target_rep function case_funsym_opt = `Ocaml_mem.case_funsym_opt`

(* Operations on pointer values *)
val eq_ptrval: pointer_value -> pointer_value -> memM bool
val ne_ptrval: pointer_value -> pointer_value -> memM bool
val lt_ptrval: pointer_value -> pointer_value -> memM bool
val gt_ptrval: pointer_value -> pointer_value -> memM bool
val le_ptrval: pointer_value -> pointer_value -> memM bool
val ge_ptrval: pointer_value -> pointer_value -> memM bool
val diff_ptrval: Core_ctype.ctype -> pointer_value -> pointer_value -> memM integer_value
declare ocaml target_rep function eq_ptrval = `Ocaml_mem.eq_ptrval`
declare ocaml target_rep function ne_ptrval = `Ocaml_mem.ne_ptrval`
declare ocaml target_rep function lt_ptrval = `Ocaml_mem.lt_ptrval`
declare ocaml target_rep function gt_ptrval = `Ocaml_mem.gt_ptrval`
declare ocaml target_rep function le_ptrval = `Ocaml_mem.le_ptrval`
declare ocaml target_rep function ge_ptrval = `Ocaml_mem.ge_ptrval`
declare ocaml target_rep function diff_ptrval = `Ocaml_mem.diff_ptrval`

val prefix_of_pointer: pointer_value -> memM (maybe string)
declare ocaml target_rep function prefix_of_pointer = `Ocaml_mem.prefix_of_pointer`

val validForDeref_ptrval: Core_ctype.ctype -> pointer_value -> memM bool
declare ocaml target_rep function validForDeref_ptrval = `Ocaml_mem.validForDeref_ptrval`

val isWellAligned_ptrval: Core_ctype.ctype -> pointer_value -> memM bool
declare ocaml target_rep function isWellAligned_ptrval = `Ocaml_mem.isWellAligned_ptrval`

(* Casting operations *)
(* the first ctype is the original integer type, the second is the target referenced type *)
val ptrcast_ival: Core_ctype.ctype -> Core_ctype.ctype -> integer_value -> memM pointer_value
(* the first ctype is the original referenced type, the integerType is the target integer type *)
val intcast_ptrval: Core_ctype.ctype -> AilTypes.integerType -> pointer_value -> memM integer_value
declare ocaml target_rep function ptrcast_ival = `Ocaml_mem.ptrcast_ival`
declare ocaml target_rep function intcast_ptrval = `Ocaml_mem.intcast_ptrval`


(* Pointer shifting constructors *)
val array_shift_ptrval:  pointer_value -> Core_ctype.ctype -> integer_value -> pointer_value
val member_shift_ptrval: pointer_value -> Symbol.sym -> Cabs.cabs_identifier -> pointer_value
declare ocaml target_rep function array_shift_ptrval = `Ocaml_mem.array_shift_ptrval`
declare ocaml target_rep function member_shift_ptrval = `Ocaml_mem.member_shift_ptrval`

(* Effectfull version of pointer shifting constructors *)
val eff_array_shift_ptrval:  pointer_value -> Core_ctype.ctype -> integer_value -> memM pointer_value
declare ocaml target_rep function eff_array_shift_ptrval = `Ocaml_mem.eff_array_shift_ptrval`


val memcpy: pointer_value -> pointer_value -> integer_value -> memM pointer_value
val memcmp: pointer_value -> pointer_value -> integer_value -> memM integer_value
val realloc: Core_ctype.thread_id -> integer_value -> pointer_value -> integer_value -> memM pointer_value

declare ocaml target_rep function memcpy = `Ocaml_mem.memcpy`
declare ocaml target_rep function memcmp = `Ocaml_mem.memcmp`
declare ocaml target_rep function realloc = `Ocaml_mem.realloc`

val va_start: list (Core_ctype.ctype * pointer_value) -> memM integer_value
val va_copy: integer_value -> memM integer_value
val va_arg: integer_value -> Core_ctype.ctype -> memM pointer_value
val va_end: integer_value -> memM unit
val va_list: integer -> memM (list (Core_ctype.ctype * pointer_value))

declare ocaml target_rep function va_start = `Ocaml_mem.va_start`
declare ocaml target_rep function va_copy = `Ocaml_mem.va_copy`
declare ocaml target_rep function va_arg = `Ocaml_mem.va_arg`
declare ocaml target_rep function va_end = `Ocaml_mem.va_end`
declare ocaml target_rep function va_list = `Ocaml_mem.va_list`


(* Integer value constructors *)
val concurRead_ival: AilTypes.integerType -> Symbol.sym -> integer_value
val integer_ival: integer -> integer_value
val max_ival: AilTypes.integerType -> integer_value
val min_ival: AilTypes.integerType -> integer_value
val op_ival: Mem_common.integer_operator -> integer_value -> integer_value -> integer_value
val offsetof_ival: Symbol.sym -> Cabs.cabs_identifier -> integer_value
val sizeof_ival: Core_ctype.ctype -> integer_value
val alignof_ival: Core_ctype.ctype -> integer_value
val bitwise_complement_ival: AilTypes.integerType -> integer_value -> integer_value
val bitwise_and_ival: AilTypes.integerType -> integer_value -> integer_value -> integer_value
val bitwise_or_ival: AilTypes.integerType -> integer_value -> integer_value -> integer_value
val bitwise_xor_ival: AilTypes.integerType -> integer_value -> integer_value -> integer_value
declare ocaml target_rep function concurRead_ival = `Ocaml_mem.concurRead_ival`
declare ocaml target_rep function integer_ival = `Ocaml_mem.integer_ival`
declare ocaml target_rep function max_ival = `Ocaml_mem.max_ival`
declare ocaml target_rep function min_ival = `Ocaml_mem.min_ival`
declare ocaml target_rep function op_ival = `Ocaml_mem.op_ival`
declare ocaml target_rep function offsetof_ival = `Ocaml_mem.offsetof_ival`
declare ocaml target_rep function sizeof_ival = `Ocaml_mem.sizeof_ival`
declare ocaml target_rep function alignof_ival = `Ocaml_mem.alignof_ival`
declare ocaml target_rep function bitwise_complement_ival = `Ocaml_mem.bitwise_complement_ival`
declare ocaml target_rep function bitwise_and_ival = `Ocaml_mem.bitwise_and_ival`
declare ocaml target_rep function bitwise_or_ival = `Ocaml_mem.bitwise_or_ival`
declare ocaml target_rep function bitwise_xor_ival = `Ocaml_mem.bitwise_xor_ival`

(* Integer value destructors *)
val case_integer_value: forall 'a. (* TODO: expose more ctors *)
    integer_value ->
    (integer -> 'a) ->
    (unit -> 'a) ->
    'a
val is_specified_ival: integer_value -> bool
declare ocaml target_rep function case_integer_value = `Ocaml_mem.case_integer_value`
declare ocaml target_rep function is_specified_ival = `Ocaml_mem.is_specified_ival`

(* Predicates on integer values *)
val eq_ival: maybe mem_state -> integer_value -> integer_value -> maybe bool
val lt_ival: maybe mem_state -> integer_value -> integer_value -> maybe bool
val le_ival: maybe mem_state -> integer_value -> integer_value -> maybe bool
declare ocaml target_rep function eq_ival = `Ocaml_mem.eq_ival`
declare ocaml target_rep function lt_ival = `Ocaml_mem.lt_ival`
declare ocaml target_rep function le_ival = `Ocaml_mem.le_ival`


val eval_integer_value: integer_value -> maybe integer
declare ocaml target_rep function eval_integer_value = `Ocaml_mem.eval_integer_value`


(* Floating value constructors *)
val zero_fval: floating_value
val one_fval: floating_value
val str_fval: string -> floating_value
declare ocaml target_rep function zero_fval = `Ocaml_mem.zero_fval`
declare ocaml target_rep function one_fval = `Ocaml_mem.one_fval`
declare ocaml target_rep function str_fval = `Ocaml_mem.str_fval`

(* Floating value destructors *)
val case_fval: forall 'a. floating_value -> (unit -> 'a) -> (Float.float -> 'a) -> 'a
declare ocaml target_rep function case_fval = `Ocaml_mem.case_fval`

(* Predicates on floating values *)
val op_fval: Mem_common.floating_operator -> floating_value -> floating_value -> floating_value
val eq_fval: floating_value -> floating_value -> bool
val lt_fval: floating_value -> floating_value -> bool
val le_fval: floating_value -> floating_value -> bool
declare ocaml target_rep function op_fval = `Ocaml_mem.op_fval`
declare ocaml target_rep function eq_fval = `Ocaml_mem.eq_fval`
declare ocaml target_rep function lt_fval = `Ocaml_mem.lt_fval`
declare ocaml target_rep function le_fval = `Ocaml_mem.le_fval`


(* Integer <-> Floating casting constructors *)
val fvfromint: integer_value -> floating_value
val ivfromfloat: AilTypes.integerType -> floating_value -> integer_value
declare ocaml target_rep function fvfromint = `Ocaml_mem.fvfromint`
declare ocaml target_rep function ivfromfloat = `Ocaml_mem.ivfromfloat`


(* Memory value constructors *)
val unspecified_mval: Core_ctype.ctype -> mem_value
val integer_value_mval: AilTypes.integerType -> integer_value -> mem_value
val floating_value_mval: AilTypes.floatingType -> floating_value -> mem_value
val pointer_mval: Core_ctype.ctype -> pointer_value -> mem_value
val array_mval: list mem_value -> mem_value
val struct_mval: Symbol.sym -> list (Cabs.cabs_identifier * Core_ctype.ctype * mem_value) -> mem_value
val union_mval: Symbol.sym -> Cabs.cabs_identifier -> mem_value -> mem_value
declare ocaml target_rep function unspecified_mval = `Ocaml_mem.unspecified_mval`
declare ocaml target_rep function integer_value_mval = `Ocaml_mem.integer_value_mval`
declare ocaml target_rep function floating_value_mval = `Ocaml_mem.floating_value_mval`
declare ocaml target_rep function pointer_mval = `Ocaml_mem.pointer_mval`
declare ocaml target_rep function array_mval = `Ocaml_mem.array_mval`
declare ocaml target_rep function struct_mval = `Ocaml_mem.struct_mval`
declare ocaml target_rep function union_mval = `Ocaml_mem.union_mval`


(* Memory value destructor *)
val case_mem_value: forall 'a.
  mem_value ->
  (Core_ctype.ctype -> 'a) -> (* unspecified case *)
  (AilTypes.integerType -> Symbol.sym -> 'a) -> (* concurrency read case *)
  (AilTypes.integerType -> integer_value -> 'a) ->
  (AilTypes.floatingType -> floating_value -> 'a) ->
  (Core_ctype.ctype -> pointer_value -> 'a) ->
  (list mem_value -> 'a) ->
  (Symbol.sym -> list (Cabs.cabs_identifier * Core_ctype.ctype * mem_value) -> 'a) ->
  (Symbol.sym -> Cabs.cabs_identifier -> mem_value -> 'a) ->
  'a
declare ocaml target_rep function case_mem_value = `Ocaml_mem.case_mem_value`











val stringFromCtype:  Core_ctype.ctype -> string
val stringFromMem_value: mem_value -> string
val stringFromPointer_value: pointer_value -> string
val stringFromInteger_value: integer_value -> string
declare ocaml target_rep function stringFromCtype  = `String_core_ctype.string_of_ctype`
declare ocaml target_rep function stringFromMem_value = `Ocaml_mem.string_of_mem_value`
declare ocaml target_rep function stringFromPointer_value = `Ocaml_mem.string_of_pointer_value`
declare ocaml target_rep function stringFromInteger_value = `Ocaml_mem.string_of_integer_value`







(*
(* This file abstract the memory layout model actually being used *)
(* include import Naive_memory *)
open import Pervasives

import Symbol Loc Cabs
open import AilTypes Core_ctype Core_ctype Float

include import Mem_common


(*
import Naive_memory
module Impl = Naive_memorf
*)

import Defacto_memory
import Defacto_memory_types
module Impl = struct
  include import Defacto_memory
  include import Defacto_memory_types
end

(*
import Concrete_memory
import Concrete_memory_types
module Impl = struct
  include import Concrete_memory
  include import Concrete_memory_types
end
*)






(* The API *)

type pointer_value  = Impl.impl_pointer_value
type mem_value      = Impl.impl_mem_value
type integer_value  = Impl.impl_integer_value
type floating_value = Impl.impl_floating_value



val stringFromCtype:  Core_ctype.ctype -> string
declare ocaml target_rep function stringFromCtype  = `String_core_ctype.string_of_ctype`
val stringFromMem_value: mem_value -> string
declare ocaml target_rep function stringFromMem_value = `String_defacto_memory.string_of_mem_value`
val stringFromPointer_value: pointer_value -> string
declare ocaml target_rep function stringFromPointer_value = `String_defacto_memory.string_of_pointer_value`
val stringFromInteger_value: integer_value -> string
declare ocaml target_rep function stringFromInteger_value = `String_defacto_memory.string_of_integer_value`




(* This abstract in returns by memory actions and two footprints can be checked for overlapping.
   They are in particular useful to detect races. *)
type footprint = Impl.impl_footprint
val do_overlap: footprint -> footprint -> bool
let do_overlap = Impl.impl_do_overlap


type mem_state = Impl.impl_mem_state


type memM 'a = Impl.impl_memM 'a
val return: forall 'a. 'a -> memM 'a
val bind: forall 'a 'b. memM 'a -> ('a -> memM 'b) -> memM 'b



val initial_mem_state: mem_state

(* Memory actions *)
val allocate_static:    Core_ctype.thread_id  (* the allocating thread *)
                     -> Symbol.prefix     (* symbols coming from the Core/C program, for debugging purpose *)
                     -> integer_value     (* alignment constraint *)
                     -> Core_ctype.ctype  (* type of the allocation *)
                     -> memM pointer_value

val allocate_dynamic:   Core_ctype.thread_id  (* the allocating thread *)
                     -> Symbol.prefix     (* symbols coming from the Core/C program, for debugging purpose *)
                     -> integer_value     (* alignment constraint *)
                     -> integer_value     (* size *)
                     -> memM pointer_value

val kill: pointer_value -> memM unit

val load: Loc.t -> ctype -> pointer_value -> memM (footprint * mem_value)
val store: Loc.t -> ctype -> pointer_value -> mem_value -> memM footprint


(* Pointer value constructors *)
val null_ptrval: ctype -> pointer_value
val fun_ptrval: Symbol.sym -> pointer_value

(* Operations on pointer values *)
val eq_ptrval: pointer_value -> pointer_value -> memM bool
val ne_ptrval: pointer_value -> pointer_value -> memM bool
val lt_ptrval: pointer_value -> pointer_value -> memM bool
val gt_ptrval: pointer_value -> pointer_value -> memM bool
val le_ptrval: pointer_value -> pointer_value -> memM bool
val ge_ptrval: pointer_value -> pointer_value -> memM bool
val diff_ptrval: Core_ctype.ctype -> pointer_value -> pointer_value -> memM integer_value

val validForDeref_ptrval: pointer_value -> bool

val memcmp: pointer_value -> pointer_value -> integer_value -> memM integer_value

(* Cast operations *)
val ptrcast_ival: ctype (* original integer type *) -> ctype (* target reference type *) -> integer_value -> memM pointer_value
val intcast_ptrval: ctype (* original reference type *) -> AilTypes.integerType (* target integer type *) -> pointer_value -> memM integer_value

val array_shift_ptrval:  pointer_value -> Core_ctype.ctype -> integer_value -> pointer_value
val member_shift_ptrval: pointer_value -> Symbol.sym -> Cabs.cabs_identifier -> pointer_value





(* Integer value constructors *)
val concurRead_ival: AilTypes.integerType -> Symbol.sym -> integer_value
val integer_ival: integer -> integer_value
val max_ival: integerType -> integer_value
val min_ival: integerType -> integer_value
val op_ival: integer_operator -> integer_value -> integer_value -> integer_value
val offsetof_ival: Symbol.sym -> Cabs.cabs_identifier -> integer_value

val sizeof_ival: Core_ctype.ctype -> integer_value
val alignof_ival: Core_ctype.ctype -> integer_value

val bitwise_complement_ival: AilTypes.integerType -> integer_value -> integer_value
val bitwise_and_ival: AilTypes.integerType -> integer_value -> integer_value -> integer_value
val bitwise_or_ival: AilTypes.integerType -> integer_value -> integer_value -> integer_value
val bitwise_xor_ival: AilTypes.integerType -> integer_value -> integer_value -> integer_value

val case_integer_value: forall 'a. (* TODO: expose more ctors *)
    integer_value ->
    (integer -> 'a) ->
    (unit -> 'a) ->
    'a

val is_specified_ival: integer_value -> bool

(* Floating operations *)
val op_fval: floating_operator -> floating_value -> floating_value -> floating_value
val eq_fval: floating_value -> floating_value -> bool
val lt_fval: floating_value -> floating_value -> bool
val le_fval: floating_value -> floating_value -> bool

val fvfromint: integer_value -> floating_value
val ivfromfloat: AilTypes.integerType -> floating_value -> integer_value

(* Predicats on integer values *)
val eq_ival: maybe mem_state -> integer_value -> integer_value -> maybe bool
val lt_ival: maybe mem_state -> integer_value -> integer_value -> maybe bool
val le_ival: maybe mem_state -> integer_value -> integer_value -> maybe bool
(* val is_concrete_ival: integer_value -> bool *)

(* Memory value constructors *)
(*symbolic_mval: Symbolic.symbolic mem_value pointer_value -> mem_value *)
val unspecified_mval: ctype -> mem_value
val integer_value_mval: AilTypes.integerType -> integer_value -> mem_value
val floating_value_mval: AilTypes.floatingType -> floating_value -> mem_value
val pointer_mval: Core_ctype.ctype -> pointer_value -> mem_value
val array_mval: list mem_value -> mem_value
val struct_mval: Symbol.sym -> list (Cabs.cabs_identifier * mem_value) -> mem_value
val union_mval: Symbol.sym -> Cabs.cabs_identifier -> mem_value -> mem_value

(* Memory value destructor *)
val case_mem_value: forall 'a.
  mem_value ->
  (Core_ctype.ctype -> 'a) -> (* unspecified case *)
  (AilTypes.integerType -> Symbol.sym -> 'a) -> (* concurrency read case *)
  (AilTypes.integerType -> integer_value -> 'a) ->
  (AilTypes.floatingType -> floating_value -> 'a) ->
  (Core_ctype.ctype -> pointer_value -> 'a) ->
  (list mem_value -> 'a) ->
  (Symbol.sym -> list (Cabs.cabs_identifier * mem_value) -> 'a) ->
  (Symbol.sym -> Cabs.cabs_identifier -> mem_value -> 'a) ->
  'a


(* For race detection *)
val sequencePoint: memM unit
let sequencePoint = Impl.impl_sequencePoint

(* ========== *)


let return = Impl.impl_return
let bind = Impl.impl_bind


let initial_mem_state                   = Impl.impl_initial_mem_state
let null_ptrval                         = Impl.impl_null_ptrval
let fun_ptrval                          = Impl.impl_fun_ptrval



let intcast_ptrval ty ity ptrval =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.intcast_ptrval(" ^ stringFromCtype ty ^ ", " ^ stringFromCtype (Basic (AilTypes.Integer ity)) ^ ", " ^ stringFromPointer_value ptrval ^ ")"
  ) in
  Impl.impl_intcast_ptrval ty ity ptrval

let ptrcast_ival ty1 ty2 ival =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.intcast_ptrval(" ^ stringFromCtype ty1 ^ ", " ^ stringFromCtype ty2 ^ ", " ^ stringFromInteger_value ival ^ ")"
  ) in
  Impl.impl_ptrcast_ival ty1 ty2 ival

let eq_ptrval ptrval1 ptrval2 =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.eq_ptrval(" ^ stringFromPointer_value ptrval1 ^ ", " ^ stringFromPointer_value ptrval2 ^ ")"
  ) in
  Impl.impl_eq_ptrval ptrval1 ptrval2

let ne_ptrval ptrval1 ptrval2 =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.ne_ptrval(" ^ stringFromPointer_value ptrval1 ^ ", " ^ stringFromPointer_value ptrval2 ^ ")"
  ) in
  Impl.impl_ne_ptrval ptrval1 ptrval2

let lt_ptrval ptrval1 ptrval2 =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.lt_ptrval(" ^ stringFromPointer_value ptrval1 ^ ", " ^ stringFromPointer_value ptrval2 ^ ")"
  ) in
  Impl.impl_lt_ptrval ptrval1 ptrval2

let gt_ptrval ptrval1 ptrval2 =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.gt_ptrval(" ^ stringFromPointer_value ptrval1 ^ ", " ^ stringFromPointer_value ptrval2 ^ ")"
  ) in
  Impl.impl_gt_ptrval ptrval1 ptrval2

let le_ptrval ptrval1 ptrval2 =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.le_ptrval(" ^ stringFromPointer_value ptrval1 ^ ", " ^ stringFromPointer_value ptrval2 ^ ")"
  ) in
 Impl.impl_le_ptrval ptrval1 ptrval2

let ge_ptrval ptrval1 ptrval2 =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.ge_ptrval(" ^ stringFromPointer_value ptrval1 ^ ", " ^ stringFromPointer_value ptrval2 ^ ")"
  ) in
  Impl.impl_ge_ptrval ptrval1 ptrval2

let memcmp                              = Impl.impl_memcmp

let validForDeref_ptrval                = Impl.impl_validForDeref_ptrval




let diff_ptrval                         = Impl.impl_diff_ptrval
(* let shift_ptrval                        = Impl.impl_shift_ptrval *)
let array_shift_ptrval                  = Impl.impl_array_shift_ptrval
let member_shift_ptrval                 = Impl.impl_member_shift_ptrval
let concurRead_ival = Impl.impl_concurRead_ival
let integer_ival                        = Impl.impl_integer_ival
let max_ival                            = Impl.impl_max_ival
let min_ival                            = Impl.impl_min_ival
let op_ival                             = Impl.impl_op_ival
let op_fval                             = Impl.impl_op_fval
let offsetof_ival                       = Impl.impl_offsetof_ival
let sizeof_ival                         = Impl.impl_sizeof_ival
let alignof_ival                        = Impl.impl_alignof_ival
let bitwise_complement_ival             = Impl.impl_bitwise_complement_ival
let bitwise_and_ival                    = Impl.impl_bitwise_and_ival
let bitwise_or_ival                     = Impl.impl_bitwise_or_ival
let bitwise_xor_ival                    = Impl.impl_bitwise_xor_ival
let case_integer_value                  = Impl.impl_case_integer_value
let is_specified_ival                   = Impl.impl_is_specified_ival
let eq_ival                             = Impl.impl_eq_ival
let lt_ival                             = Impl.impl_lt_ival
let le_ival                             = Impl.impl_le_ival
let eq_fval                             = Impl.impl_eq_fval
let lt_fval                             = Impl.impl_lt_fval
let le_fval                             = Impl.impl_le_fval
let fvfromint                           = Impl.impl_fvfromint
let ivfromfloat                         = Impl.impl_ivfromfloat
let unspecified_mval                    = Impl.impl_unspecified_mval
let integer_value_mval                  = Impl.impl_integer_value_mval
let floating_value_mval                 = Impl.impl_floating_value_mval
let pointer_mval                        = Impl.impl_pointer_mval
let array_mval                          = Impl.impl_array_mval
let struct_mval                         = Impl.impl_struct_mval
let union_mval                          = Impl.impl_union_mval
let case_mem_value                      = Impl.impl_case_mem_value

val case_fval: forall 'a. floating_value -> (unit -> 'a) -> (float -> 'a) -> 'a
let case_fval = Impl.impl_case_fval
val zero_fval: floating_value
let zero_fval = Impl.impl_zero_fval

val str_fval: string -> floating_value
let str_fval = Impl.impl_str_fval




val eval_integer_value: integer_value -> maybe integer
let eval_integer_value = Impl.impl_eval_integer_value


type mem_iv_constraint = mem_constraint integer_value



(*
type mem_constraint = Impl.impl_mem_constraint

(* TODO: move this up *)
type mem_constraint2 = Impl.impl_mem_constraint2

val constraint_eqIV: integer_value -> integer_value -> mem_constraint2
val constraint_neIV: integer_value -> integer_value -> mem_constraint2
val constraint_ltIV: integer_value -> integer_value -> mem_constraint2
val constraint_leIV: integer_value -> integer_value -> mem_constraint2

let constraint_eqIV = Impl.impl_constraint_eqIV
let constraint_neIV = Impl.impl_constraint_neIV
let constraint_ltIV = Impl.impl_constraint_ltIV
let constraint_leIV = Impl.impl_constraint_leIV
*)










let stringFromPrefix = function
  | Symbol.PrefSource _ syms ->
      "{" ^ String.concat "." (List.map show syms) ^ "}"
  | Symbol.PrefOther str ->
      "{" ^ str ^ "}"
end

let allocate_static tid pref align_ival ty =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.allocate_static(" ^ stringFromPrefix pref ^ ")"
  ) in
  Impl.impl_allocate_static tid pref align_ival ty

let allocate_dynamic tid pref align_ival size_ival =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.allocate_dynamic(" ^ stringFromPrefix pref ^ ")"
  ) in
  Impl.impl_allocate_dynamic tid pref align_ival size_ival

let kill ptrval =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.kill(" ^ stringFromPointer_value ptrval ^ ")"
  ) in
  Impl.impl_kill ptrval

let load loc ty ptrval =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.load(" ^ stringFromCtype ty ^ ", " ^ stringFromPointer_value ptrval ^ ")"
  ) in
  Impl.impl_load loc ty ptrval

let store loc ty ptrval mval =
  let () = Debug.print_debug 1 [Debug.DB_memory] (fun () ->
    "Mem.store(" ^ stringFromCtype ty ^ ", " ^ stringFromPointer_value ptrval ^ ", " ^ stringFromMem_value mval ^ ")"
  ) in
  Impl.impl_store loc ty ptrval mval
*)
