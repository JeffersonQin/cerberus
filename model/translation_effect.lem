(* Effects for Translation: state + exception *)
open import Pervasives Global Show Show_extra
import Boot UniqueId Symbol Undefined Core_ctype AilTypes AilTypesAux

open import Core


type state = <|
  symbol_supply:   UniqueId.supply Symbol.sym; (* counter for Core's symbolic names (all of them) *)
  visible_objects_types: map Symbol.sym AilTypes.ctype;
  visible_objects: list (list Symbol.sym);     (* visible C objects with scoping (used to properly
                                                  annotate Esave/Erun ctors) *)
  
  string_literals: list (Symbol.sym * Core_ctype.ctype * pexpr)
|>


type t 'a = state -> 'a * state

(* monadic operations *)
val return: forall 'a. 'a -> t 'a
let return x = fun st ->
  (x, st)

val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
let bind m f = fun st ->
  let (a, st') = m st in
  f a st'



(* BEGIN: reinventing the wheel (lots of things shamelessly taken from GHC) *)
val     foldlM: forall 'a 'b. ('a -> 'b -> t 'a) -> 'a -> list 'b -> t 'a
let rec foldlM f z0 xs =
  match xs with
    | []     -> return z0
    | x::xs' -> bind (f z0 x) (fun z -> foldlM f z xs')
  end

val foldl1M: forall 'a. ('a -> 'a -> t 'a) -> list 'a -> t 'a
let foldl1M f = function
  | []    -> error "[Translation_effect.E.foldl1M] called on an empty list"
  | x::xs -> foldlM f x xs
end

let sequence ms =
  foldr (fun m acc ->
    bind m (fun x  ->
      bind acc (fun xs ->
        return (x::xs)
      )
    )
  ) (return []) ms
val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
let mapM f xs = sequence (List.map f xs)

let sequence_ ms = foldr (fun m f -> bind m (fun _ -> f)) (return ()) ms
val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
let mapM_ f _as = sequence_ (List.map f _as)

val replicateM: forall 'a. nat -> t 'a -> t (list 'a)
let replicateM n x = sequence (replicate n x)
(* END: reinventing the wheel *)


(* build an initial state from a given Core standard library *)
val init: UniqueId.supply Symbol.sym -> state
let init suppl = <|
  symbol_supply=   suppl;
  visible_objects_types= Map.empty;
  visible_objects= [[]];
  string_literals= [];
|>


(* returns a fresh Core symbolic name. *)
val fresh_symbol: t Symbol.sym
let fresh_symbol = fun (<| symbol_supply= suppl |> as st) ->
  let (sym, suppl') = State.run Symbol.fresh suppl in
  (sym, <| st with symbol_supply= suppl' |>)

val     core_object_type_of_ctype: AilTypes.ctype -> maybe Core.core_object_type
let rec core_object_type_of_ctype ty =
  match AilTypesAux.unatomic ty with
    | AilTypes.Basic (AilTypes.Integer _) ->
        Just Core.OTy_integer
    | AilTypes.Basic (AilTypes.Floating _) ->
        Just Core.OTy_floating
    | AilTypes.Array elem_ty _ ->
        maybe Nothing (fun objTy -> Just (Core.OTy_array objTy)) $
          core_object_type_of_ctype elem_ty
    | AilTypes.Pointer _ _ ->
        Just Core.OTy_pointer
    | _ ->
        Nothing
  end

val fresh_typed_symbol: bool -> AilTypes.ctype -> t (Symbol.sym * Core.core_base_type)
let fresh_typed_symbol is_loaded ty =
  let ctor x = if is_loaded then Core.BTy_loaded x else Core.BTy_object x in
  bind fresh_symbol (fun sym ->
    match core_object_type_of_ctype ty with
      | Just objTy ->
          return (sym, ctor objTy)
      | Nothing ->
          error "Translation_effect.fresh_typed_symbol"
    end)

(* returns a fresh Core symbolic name with a specified name for pretty printing. *)
val fresh_named_symbol: string -> t Symbol.sym
let fresh_named_symbol name = fun (<| symbol_supply= suppl |> as st) ->
  let (sym, suppl') = State.run (Symbol.fresh_pretty_with_id (fun x -> name ^ "_" ^ show x)) suppl in
  (sym, <| st with symbol_supply= suppl' |>)

(* register C objects from block scope. *)
val push_block_objects: list (Symbol.sym * AilTypes.ctype) -> t unit
let push_block_objects binds = fun st ->
  ((), <| st with
    visible_objects_types= List.foldl (fun acc (sym, ty) -> Map.insert sym ty acc) st.visible_objects_types binds;
    visible_objects= (List.map fst binds) :: st.visible_objects
  |>)

(* forget C objects from the most recent block. *)
val pop_block_objects: t unit
let pop_block_objects = fun st ->
  ((), <| st with visible_objects=
      match st.visible_objects with
        | _ :: xs -> xs
        | _       -> error "[Translation.E.pop_block_objects] found an ill-formed scope stack."
      end |>)


let inline (>>=)    = bind
let inline (>>) m f = bind m (fun _ -> f)

(* TODO: UNUSED
val with_block_objects: forall 'a. list (Symbol.sym * AilTypes.ctype) -> t 'a -> t 'a
let with_block_objects binds m =
  push_block_objects binds >>
  m                        >>= fun ret ->
  pop_block_objects        >>
  return ret
*)

(* returns the list of all the C objects in scope. *)
val get_visible_objects: t (list Symbol.sym)
let get_visible_objects = fun st ->
  (foldl (++) [] st.visible_objects, st)





val register_string_literal: Symbol.sym -> Core_ctype.ctype -> pexpr -> t unit
let register_string_literal a ty pe = fun st ->
  ((), <| st with string_literals= (a, ty, pe) :: st.string_literals |>)

val get_string_literals: t (list (Symbol.sym * Core_ctype.ctype * pexpr))
let get_string_literals = fun st ->
  (st.string_literals, st)



val resolve_object_type: Symbol.sym -> t AilTypes.ctype
let resolve_object_type sym = fun st ->
  match Map.lookup sym st.visible_objects_types with
    | Just ty ->
        (ty, st)
    | Nothing ->
        let sym_str = match sym with
          | Symbol.Symbol n Nothing ->
              "sym_" ^ show n
          | Symbol.Symbol n (Just str) ->
              str ^ "{" ^ show n ^ "}"
        end in
        error ("Translation_effect.resolve_object_type ===> " ^ sym_str)
  end



val print_debug: nat -> string -> t unit
let print_debug n str =
  fun st ->
    let () = Debug.print_debug n str in
    ((), st)
