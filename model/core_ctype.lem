open import Pervasives Utils Show
import Symbol (* Symbolic *) AilTypes


(*
val string_of_ail_ctype: forall 'a. 'a (* AilTypes.ctype *) -> string
declare ocaml target_rep function string_of_ail_ctype = `String_ail.string_of_ctype`

val string_of_ail_qualifiers_human: forall 'a. 'a (* AilTypes.qualifiers *) -> string
declare ocaml target_rep function string_of_ail_qualifiers_human = `String_ail.string_of_qualifiers_human`
*)



(* C types (this is a simplication of what is need for typechecking) *)
(* TODO: what about Ail.ATOMIC_Q ? *)


















type struct_tag = Symbol.sym
type union_tag  = Symbol.sym
type member_id  = Symbol.sym


type modifiable =
  | Modifiable_yes
  | Modifiable_no

instance (Eq modifiable)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end


(* TODO: no volatile for now *)
type ctype =
 | Void
 | Basic of AilTypes.basicType
 | Array of ctype * maybe integer
 | Function of (AilTypes.qualifiers * ctype) * list (AilTypes.qualifiers * ctype) * bool (*isVariadic*)
 | Pointer of AilTypes.qualifiers * ctype
 | Atomic of ctype
(*
TODO: it should be like that
 | Struct of struct_tag * list (member_id * modifiable * ctype)
 | Union  of union_tag * list (member_id * modifiable * ctype)
*)
 | Struct of struct_tag
 | Union  of union_tag
 | Builtin of string


type tag_definition =
  | StructDef of list (Cabs.cabs_identifier * ctype)
  | UnionDef of list (Cabs.cabs_identifier * ctype)

declare ocaml target_rep type tag_definition = `Tags.tag_definition`

(* TODO: need these otherwise Lem does some stupid renaming *)
declare ocaml target_rep function StructDef = `Tags.StructDef`
declare ocaml target_rep function UnionDef = `Tags.UnionDef`






val char: ctype
let char =
  Basic (AilTypes.Integer AilTypes.Char)

val signed_char: ctype
let signed_char =
  Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Ichar))

val signed_short: ctype
let signed_short =
  Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Short))

val signed_int: ctype
let signed_int =
  Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Int_))

val signed_long: ctype
let signed_long =
  Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Long))

val signed_long_long: ctype
let signed_long_long =
  Basic (AilTypes.Integer (AilTypes.Signed AilTypes.LongLong))

val intmax_t: ctype
let intmax_t =
  Basic (AilTypes.Integer (AilTypes.Signed AilTypes.Intmax_t))

val ptrdiff_t: ctype
let ptrdiff_t =
  Basic (AilTypes.Integer AilTypes.Ptrdiff_t)

val size_t: ctype
let size_t =
  Basic (AilTypes.Integer AilTypes.Size_t)

val unsigned_char: ctype
let unsigned_char =
  Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Ichar)))

val unsigned_short: ctype
let unsigned_short =
  Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Short))

val unsigned_int: ctype
let unsigned_int =
  Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Int_))

val unsigned_long: ctype
let unsigned_long =
  Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Long))

val unsigned_long_long: ctype
let unsigned_long_long =
  Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.LongLong))

val uintmax_t: ctype
let uintmax_t =
  Basic (AilTypes.Integer (AilTypes.Unsigned AilTypes.Intmax_t))


val char16_t: ctype
let char16_t =
  (* STD ยง7.28#2 *)
  Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Int_leastN_t 16)))

val char32_t: ctype
let char32_t =
  (* STD ยง7.28#2 *)
  Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.Int_leastN_t 32)))

(*
val builtin_signed_integer_type: string -> ctype
let builtin_signed_integer_type str =
  Basic (AilTypes.Integer (AilTypes.Signed (AilTypes.IBBuiltin str)))

val builtin_unsigned_integer_type: string -> ctype
let builtin_unsigned_integer_type str =
  Basic (AilTypes.Integer (AilTypes.Unsigned (AilTypes.IBBuiltin str)))
*)


  (* this alignment is the default for the type unless overridden by
  _Alignas, eg "_Alignas(int32_t) int16_t i", in which case it's that *)


(* choice: do we have a layout environment or do we duplicate the info
in every ctype? For the former:


-  somewhere for every base type, there has to be the default (maybe impl-def) alignment and size 

type layout_environment = 
  (* for every structure member_id, the offset *)
  

then given those, we should be able to define a Lem function from ctype to calculate:

- its alignment
- its size
- its footprint (a list of offset,size pairs)


For the latter, we have to add more stuff into ctype.
*)


let rec ctypeEqual ty1 ty2 =
  let paramsEqual (qs1, ty1) (qs2, ty2) =
    qs1 = qs2 && ctypeEqual ty1 ty2 in
  match (ty1, ty2) with
    | (Void, Void) ->
        true
    | (Basic bty1, Basic bty2) ->
        bty1 = bty2
    | (Array ty1 n1_opt, Array ty2 n2_opt) ->
        ctypeEqual ty1 ty2 && n1_opt = n2_opt
    | (Function (ret_qs1, ret_ty1) tys1 b1, Function (ret_qs2, ret_ty2) tys2 b2) ->
        ret_qs1 = ret_qs2 && ctypeEqual ret_ty1 ret_ty2 &&
        List.all (uncurry paramsEqual) (List.zip tys1 tys2) && b1 = b2
    | (Pointer qs1 ty1, Pointer qs2 ty2) ->
        qs1 = qs2 &&
        ctypeEqual ty1 ty2
    | (Atomic ty1, Atomic ty2) ->
        ctypeEqual ty1 ty2
    | (Struct tag1, Struct tag2) ->
        tag1 = tag2
    | (Union tag1, Union tag2) ->
        tag1 = tag2
    | (Builtin str1, Builtin str2) ->
        str1 = str2
    | _ -> false
  end

instance (Eq ctype)
  let (=) = ctypeEqual
  let (<>) x y = not (ctypeEqual x y)
end

let rec ~{hol} setElemCompare_ctype_aux qs_tys1 qs_tys2 =
  match (qs_tys1, qs_tys2) with
    | ([], []) ->
        EQ
    | ([], _) ->
        LT
    | (_, []) ->
        GT
    | (((qs1, ty1) :: qs_tys1'), ((qs2, ty2) :: qs_tys2')) ->
        match setElemCompare qs1 qs2 with
          | EQ ->
              match setElemCompare_ctype ty1 ty2 with
                | EQ ->
                    setElemCompare_ctype_aux qs_tys1' qs_tys2'
                | x ->
                  x
              end
          | x ->
              x
        end
  end

and setElemCompare_ctype ty1 ty2 =
  let ord = function
    | Void ->
        (0: nat)
    | Basic _ ->
        1
    | Array _ _ ->
        2
    | Function _ _ _ ->
        3
    | Pointer _ _ ->
        4
    | Atomic _ ->
        5
    | Struct _ ->
        6
    | Union _ ->
        7
    | Builtin _ ->
        9
  end in
  match (ty1, ty2) with
    | (Basic bty1, Basic bty2) ->
        setElemCompare bty1 bty2
    | (Array elem_ty1 n_opt1, Array elem_ty2 n_opt2) ->
        match setElemCompare_ctype elem_ty1 elem_ty2 with
          | EQ ->
              setElemCompare n_opt1 n_opt2
          | x ->
              x
        end
    | (Function (ret_qs1, ret_ty1) qs_tys1 b1, Function (ret_qs2, ret_ty2) qs_tys2 b2) ->
        match setElemCompare ret_qs1 ret_qs2 with
          | EQ ->
              match setElemCompare_ctype ret_ty1 ret_ty2 with
                | EQ ->
                    match setElemCompare_ctype_aux qs_tys1 qs_tys2 with
                      | EQ ->
                          setElemCompare b1 b2
                      | x ->
                          x
                    end
                | x ->
                    x
              end
          | x ->
              x
        end
    | (Pointer qs1 ty1', Pointer qs2 ty2') ->
        match setElemCompare qs1 qs2 with
          | EQ ->
              setElemCompare_ctype ty1' ty2'
          | x ->
              x
        end
    | (Atomic ty1', Atomic ty2') ->
        setElemCompare_ctype ty1' ty2'
    | (Struct sym1, Struct sym2) ->
        setElemCompare sym1 sym2
    | (Union sym1, Union sym2) ->
        setElemCompare sym1 sym2
    | (Builtin str1, Builtin str2) ->
        setElemCompare str1 str2
    
    | _ ->
        setElemCompare (ord ty1) (ord ty2)
  end


instance (SetType ctype)
  let setElemCompare = setElemCompare_ctype
end




val is_atomic: ctype -> bool
let is_atomic = function
 | Atomic _ ->
     true
 | _ ->
     false
end


val unatomic: ctype -> ctype
let unatomic = function
  | Atomic ty ->
      ty
  | ty ->
      ty
end
