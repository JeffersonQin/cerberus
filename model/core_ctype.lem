open import Pervasives
import Symbol Symbolic AilTypes

(* TODO: temporary hack *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`


(* C types (this is a simplication of what is need for typechecking) *)
(* TODO: what about Ail.ATOMIC_Q ? *)

type struct_tag = Symbol.t
type union_tag  = Symbol.t
type member_id  = Symbol.t




type ctype =
 | Void
 | Basic of AilTypes.basicType
 | Array of ctype * integer
 | Function of ctype * list (qualifiers * ctype) * bool (*true for variadic*)
 | Pointer of qualifiers * ctype
 | Atomic of ctype
 | Struct of struct_tag * list (member_id * ctype)
 | Union  of union_tag * list (member_id * ctype)


  (* this alignment is the default for the type unless overridden by
  _Alignas, eg "_Alignas(int32_t) int16_t i", in which case it's that *)


(* choice: do we have a layout environment or do we duplicate the info
in every ctype? For the former:


-  somewhere for every base type, there has to be the default (maybe impl-def) alignment and size 

type layout_environment = 
  (* for every structure member_id, the offset *)
  

then given those, we should be able to define a Lem function from ctype to calculate:

- its alignment
- its size
- its footprint (a list of offset,size pairs)


For the latter, we have to add more stuff into ctype.
*)



(*
let rec ctypeEquality ty1 ty2 =
  match (ty1, ty2) with
    | (Void, Void) ->
        true
    | (Basic bty1, Basic bty2) ->
        bty1 = bty2
    | (Array ty1 n1, Array ty2 n2) ->
        ctypeEquality ty1 ty2 && n1 = n2
    | (Function ty1 tys1 b1, Function ty2 tys2 b2) ->
        ctypeEquality ty1 ty2 &&
        List.all (fun (x, y) -> ctypeEquality x y) (zip tys1 tys2) &&
        b1 = b2
    | (Pointer ty1, Pointer ty2) ->
        ctypeEquality ty1 ty2
    | (Atomic ty1, Atomic ty2) ->
        ctypeEquality ty1 ty2

    | (Intptr_t, Intrptr_t) ->
        true
    | (Ptrdiff_t, Ptrdiff_t) ->
        true
(*
    | (SIZE_T, SIZE_T) -> true
    | (INTPTR_T, INTPTR_T) -> true
    | (WCHAR_T, WCHAR_T) -> true
    | (CHAR16_T, CHAR16_T) -> true
    | (CHAR32_T, CHAR32_T) -> true
 *)
    | _ -> false
  end
*)

let ctypeEquality _ _ =
  assert_false "WIP: equality function for Core_ctype.ctype"

instance (Eq ctype)
  let (=) = ctypeEquality
  let (<>) x y = not (ctypeEquality x y)
end


(*
val ctype_to_nat : ctype -> nat
let ctype_to_nat = function
 | Void           -> 0
 | Basic _        -> 1
 | Array _ _      -> 2
 | Function _ _ _ -> 3
 | Pointer _      -> 4
 | Atomic _       -> 5
end

let rec setElemCompare_ctype ty1 ty2 =
  match (ty1, ty2) with
    | (Void, Void) ->
        EQ
    | (Basic bty1, Basic bty2) ->
        setElemCompare bty1 bty2
    | (Array ty1 n1, Array ty2 n2) ->
        pairCompare setElemCompare_ctype setElemCompare (ty1, n1) (ty2, n2)
    | (Function ty1 tys1 b1, Function ty2 tys2 b2) ->
        pairCompare setElemCompare_ctype (pairCompare (lexicographicCompareBy setElemCompare_ctype) setElemCompare)
          (ty1, (tys1, b1)) (ty2, (tys2, b2))
    | (Pointer ty1, Pointer ty2) ->
        setElemCompare_ctype ty1 ty2
    | (Atomic ty1, Atomic ty2) ->
         setElemCompare_ctype ty1 ty2
    | (_, _) ->
        setElemCompare (ctype_to_nat ty1) (ctype_to_nat ty2)
  end
*)

let setElemCompare_ctype _ _ =
  assert_false "WIP: comparition function for Core_ctype.ctype"


instance (SetType ctype)
  let setElemCompare = setElemCompare_ctype
end
