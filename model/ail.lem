open Global

type id = Symbol.t

type storage_duration =
  | STATIC
  | THREAD
  | AUTOMATIC
  | ALLOCATED (*TODO: see 7.22.3 *)

type qualifier =
  | CONST
  | RESTRICT
  | VOLATILE
  | ATOMIC_Q
and qualifiers = set qualifier

type integer_base_type =
  | ICHAR
  | SHORT
  | INT
  | LONG
  | LONG_LONG
  | EXTENDED_INTEGER of string

type integer_type =
  | BOOL
  | SIGNED of integer_base_type
  | UNSIGNED of integer_base_type

type real_floating_type =
  | FLOAT
  | DOUBLE
  | LONG_DOUBLE

type basic_type =
  | CHAR
  | INTEGER of integer_type
  | REAL_FLOATING of real_floating_type
  | COMPLEX of real_floating_type

(* ยง6.7.5 Alignment specifier *)
(*
type alignment_specifier =
  | _ALIGNAS_TYPE of ctype
  | _ALIGNAS_CONST of num
*)

(* TODO: add [alignment_specifier] when needed to the ctors of ctype *)
type ctype =
  | VOID  of qualifiers
  | BASIC of qualifiers * basic_type
  (* TODO Need to convert integer constant to an actual value! Otherwise, we
     cannot compare types! *)
  | ARRAY of ctype * option int
(* need also to support array types without a length, eg for pointer-to-an-array[10] or just pointer-to-an-array. also some length subtyping in function arguments in C11. so another type here, to have pointers to. *)

(* NOTE: will need to make up ids for some of the bitfields *)
  | STRUCT of qualifiers * id * list (id * member)
  | UNION  of qualifiers * id * list (id * member)
  | ENUM of id
  | FUNCTION of ctype * list ctype
  | POINTER of qualifiers * ctype
  | ATOMIC of ctype
  | TYPEDEF of id
  
  | SIZE_T
  | INTPTR_T
  | WCHAR_T
  | CHAR16_T
  | CHAR32_T
  
(*  | IMAXDIV_T (* from inttype.h *) *)

(*
and attribute =
  | ATTR of string * list expression_t 'a
*)



and member =
  | MEMBER of (* alignment_specifier * *) ctype
  | BITFIELD of ctype * int * (option bool) (* the boolean indicates whether or not
                                               there is packing of the next member. *)
(*  | NULL_BITFIELD (* see ยง6.7.2.1#12 *) *)




and type_class =
  | T_EXP of ctype
  | T_LVALUE of ctype
  (* TODO: we need to add a T_BITFIELD *)
























type arithmetic_operator =
  | MUL | DIV | MOD
  | ADD | SUB
  | SHL | SHR
  | BAND
  | XOR
  | BOR

type binary_operator =
  | ARITHMETIC of arithmetic_operator
  | COMMA
  | AND
  | OR
  | LT | GT | LE | GE
  | EQ | NE

type unary_operator =
  | PLUS
  | MINUS
  | BNOT
  | ADDRESS
  | INDIRECTION
  | POSTFIX_INCR
  | POSTFIX_DECR

type integer_suffix =
  | SUFFIX_UNSIGNED
  | SUFFIX_UNSIGNED_LONG
  | SUFFIX_UNSIGNED_LONG_LONG
  | SUFFIX_LONG
  | SUFFIX_LONG_LONG

and encoding_basis =
  | DECIMAL
  | HEXADECIMAL
  | OCTAL

and integer_constant =
  int * encoding_basis * option integer_suffix



type latin_letter =
  | LETTER_A | LETTER_B | LETTER_C | LETTER_D | LETTER_E | LETTER_F | LETTER_G | LETTER_H | LETTER_I
  | LETTER_J | LETTER_K | LETTER_L | LETTER_M | LETTER_N | LETTER_O | LETTER_P | LETTER_Q | LETTER_R
  | LETTER_S | LETTER_T | LETTER_U | LETTER_V | LETTER_W | LETTER_X | LETTER_Y | LETTER_Z

type digit =
  | DIGIT_0 | DIGIT_1 | DIGIT_2 | DIGIT_3 | DIGIT_4 | DIGIT_5
  | DIGIT_6 | DIGIT_7 | DIGIT_8 | DIGIT_9

type graphic_letter =
  | GRAPHIC_EXCLAM | GRAPHIC_DQUOTE | GRAPHIC_HASH | GRAPHIC_PERCENT | GRAPHIC_SQUOTE
  | GRAPHIC_LPAREN | GRAPHIC_RPAREN | GRAPHIC_STAR | GRAPHIC_PLUS | GRAPHIC_COMMA | GRAPHIC_MINUS
  | GRAPHIC_DOT | GRAPHIC_SLASH | GRAPHIC_COLON | GRAPHIC_SEMI | GRAPHIC_LT | GRAPHIC_EQ
  | GRAPHIC_GT | GRAPHIC_QUESTION | GRAPHIC_LBRACKET | GRAPHIC_BACKSLASH | GRAPHIC_RBRACKET
  | GRAPHIC_CARET | GRAPHIC_UNDERSCORE | GRAPHIC_LBRACE | GRAPHIC_PIPE | GRAPHIC_RBRACE
  | GRAPHIC_TILDE


type source_character_set =
  | UPPERCASE of latin_letter
  | LOWERCASE of latin_letter
  | DIGIT of digit
  | GRAPHIC of graphic_letter



type character_prefix =
  | PREFIX_L
  | PREFIX_u
  | PREFIX_U
and character_constant = option character_prefix * string (* the textual representaton *)

type constant =
  | CONST_INT of integer_constant
  | CONST_FLOAT of string (* the textual representaton *)
  | CONST_CHAR of character_constant
  | CONST_ENUM of string
(* 
(* TODO *)
  | CONST_CHAR of list int64
  | CONST_WCHAR of list int64
*)

type encoding_prefix =
  | ENCODING_u8
  | ENCODING_u
  | ENCODING_U
  | ENCODING_L
  
type string_literal = option encoding_prefix * string (* textual representation *)


type declaration = ctype * option storage_duration


type expression 'a =
  | NULL (* TODO: move inside constant ? *)
  | STRING_LITERAL of string_literal
  | UNARY of unary_operator * expression_t 'a
  | BINARY of binary_operator * expression_t 'a * expression_t 'a
  | ASSIGN of option arithmetic_operator * expression_t 'a * expression_t 'a
  | CONDITIONAL of expression_t 'a * expression_t 'a * expression_t 'a
  | CAST of ctype * expression_t 'a
  | CALL of expression_t 'a * list (expression_t 'a)
  | MEMBEROF of expression_t 'a * (id * id)    (* struct/union name and field name *)
  | MEMBEROFPTR of expression_t 'a * (id * id) (* struct/union name and field name *)
  | CONSTANT of constant
  | VARIABLE of id

  (* TODO: this ctor should probably disappear in the end, but to transform a
           EXPR_SIZEOF into a SIZEOF, I need to know the type of the operand and
           can't at the time of Cabs_to_ail (...).
           Currently this ctor is only used between Cabs_to_ail and Typing, and
           get transform into a SIZEOF in Typing *)
  | EXPR_SIZEOF of expression_t 'a
  
  | SIZEOF of ctype
  | ALIGNOF of ctype
  
  | MALLOC of expression_t 'a
  | FREE of expression_t 'a
  | MEMCMP of expression_t 'a * expression_t 'a * expression_t 'a
  | MEMCPY of expression_t 'a * expression_t 'a * expression_t 'a


  (* HACKISH: making it a special case because its type is "polymorphic" *)
  | ASSERT of expression_t 'a

  (* TODO: could be move as a ctor of [constant] if we decide to evaluate the expressions
           during [cabs_to_ail] *)
  | CONST_ARRAY of list (expression_t 'a)
  | CONST_STRUCT_UNION of list (id * expression_t 'a)

  | OFFSETOF of ctype * id
  
  (* TODO: this is a temporary hack *)
  | PRINTF of expression_t 'a * list (expression_t 'a)

(* 'a gets instanciated to [unit], then [type_class] *)
and expression_t 'a = 'a * expression 'a



type definition 'a = id * expression_t 'a

(* Statements *)
type statement 'a =
  | SKIP
  | EXPRESSION of expression_t 'a
  | BLOCK of list id * list (statement_l 'a)
  | IF of expression_t 'a * statement_l 'a * statement_l 'a
  | WHILE of expression_t 'a * statement_l 'a
  | DO of expression_t 'a * statement_l 'a
  | BREAK
  | CONTINUE
  | RETURN_VOID
  | RETURN_EXPRESSION of expression_t 'a
  | SWITCH of expression_t 'a * statement_l 'a
  | CASE of integer_constant * statement_l 'a
  | DEFAULT of statement_l 'a
  | LABEL of id * statement_l 'a
  | GOTO of id
  | DECLARATION of list (definition 'a)
  | PAR of list (statement_l 'a)

and statement_l 'a = Location.t * statement 'a

type file 'a = <|
  (* the main function name *)
  main:    id;
  id_map:  map id declaration; (* declared identifiers *)
  globals: list (id * expression_t 'a);
  fn_map:  map id (list id * statement_l 'a) (* functions *)
|>

(*
type env 'a = <|
  symbol : id;
  symbol_map : map id string;
  file : file 'a
|>
*)


(* HACK: equality over ctypes. *)
let rec and2 f l1 l2 =
  match (l1,l2) with
    | ([]   ,[]    ) -> true
    | (x::xs, y::ys) -> f x y && and2 f xs ys
  end

let rec ctype_eq ty1 ty2 =
  match (ty1, ty2) with
    | (VOID qs1         , VOID qs2         ) -> Set.(=) qs1 qs2
    | (BASIC qs1 b1     , BASIC qs2 b2     ) -> Set.(=) qs1 qs2 && b1 = b2
    | (ARRAY ty1 n1     , ARRAY ty2 n2     ) -> ctype_eq ty1 ty2 && n1 = n2
    | (POINTER qs1 ty1  , POINTER qs2 ty2  ) -> Set.(=) qs1 qs2 && ctype_eq ty1 ty2
    | (FUNCTION ty1 tys1, FUNCTION ty2 tys2) -> ctype_eq ty1 ty2 && and2 ctype_eq tys1 tys2
    | (STRUCT qs1 x1 ms1, STRUCT qs2 x2 ms2) -> Set.(=) qs1 qs2 && x1 = x2 && ms1 = ms2
    | (UNION qs1 x1 ms1 , UNION qs2 x2 ms2 ) -> Set.(=) qs1 qs2 && x1 = x2 && ms1 = ms2
  end









(* Some useful aliases *)
val unsigned_char: ctype
let unsigned_char = BASIC {} (INTEGER (UNSIGNED ICHAR))

