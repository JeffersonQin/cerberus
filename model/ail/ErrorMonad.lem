open import Pervasives TypingError
import Loc Exception

(* HACK: most of the inlines are only added to prevent Lem's renaming *)


type errorM 'a = either (Loc.t * typing_error) 'a

val return: forall 'a. 'a -> errorM 'a
let inline return z         = Right z

val fail: forall 'a. Loc.t -> typing_error -> errorM 'a
let inline fail loc err = Left (loc, err)

val bind: forall 'a 'b. errorM 'a -> ('a -> errorM 'b) -> errorM 'b
let inline bind m f =
  match m with
    | Left l  -> Left l
    | Right r -> f r
  end

let inline fmap f = function
  | Left  z -> Left z
  | Right z -> Right (f z)
end

let inline (>>=) m f = bind m f
let inline (>>) m f = m >>= (fun _ -> f)
let inline (<$>) = fmap



val tryM: forall 'a 'b. errorM 'a -> ('a -> errorM 'b) -> errorM 'b -> errorM 'b
let tryM m f errCase =
  match m with
    | Left _ -> errCase
    | Right z  -> f z
  end

val runErrorMonad: forall 'a. errorM 'a -> either (Loc.t * typing_error) 'a
let runErrorMonad m =
  m

val to_exception: forall 'a 'msg. (Loc.t * typing_error -> 'msg) -> errorM 'a -> Exception.exceptM 'a 'msg
let to_exception f = function
  | Left loc_err ->
      Exception.Exception (f loc_err)
  | Right z ->
      Exception.Result z
end


val     ailErr_mapM: forall 'a 'b. ('a -> errorM 'b) -> list 'a -> errorM (list 'b)
let rec ailErr_mapM f ys =
  match ys with
  | []      -> return []
  | (x::xs) -> f x       >>= fun z  ->
               ailErr_mapM f xs >>= fun zs ->
               return (z::zs)
end

let inline sequence_ ms = List.foldr (>>) (return ()) ms
val mapM_: forall 'a 'b. ('a -> errorM 'b) -> list 'a -> errorM unit
let inline mapM_ f _as =
  sequence_ (List.map f _as)



val     ailErr_foldM: forall 'a 'b. ('a -> 'b -> errorM 'a) -> 'a -> list 'b -> errorM 'a (* GENERIC Monad *)
let rec ailErr_foldM f a = function                                                       (* GENERIC Monad *)
  | [] ->                                                                                 (* GENERIC Monad *)
      return a                                                                            (* GENERIC Monad *)
  | x::xs ->                                                                              (* GENERIC Monad *)
      f a x >>= fun fax -> ailErr_foldM f fax xs                                          (* GENERIC Monad *)
end

val guard: typing_error -> bool -> errorM unit
let inline guard err = function
  | true ->
      return ()
  | false ->
      fail Loc.unknown err
end

(* HACK: this is to prevent Lem's from renaming *)
let inline mapM  = ailErr_mapM
let inline foldM = ailErr_foldM
