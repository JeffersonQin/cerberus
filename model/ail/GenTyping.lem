open import Pervasives Common Utils AilSyntax AilTypes AilSyntaxAux AilWf TypingError
open import GenTypes GenTypesAux
open import Std Loc

import Undefined
import Builtins Debug Pp

import Global

open import {hol} `utilTheory`

module AAux = AilTypesAux
module GAux = GenTypesAux

import ErrorMonad
module E = ErrorMonad

let inline (>>=) m f = E.bind m f
let inline (>>) m f = m >>= (fun _ -> f)
let inline (<$>) = E.fmap


val lookup_tag_definition: forall 'a. sigma 'a -> identifier -> maybe tag_definition
let lookup_tag_definition s sym =
  Context.lookup (=) s.tag_definitions sym


val type_of_constant: integerConstant -> genIntegerType
let gen_typing_type_of_constant iCst =
  let () = Debug.warn [] (fun () ->
    "GenTyping.type_of_constant is BROKEN, using min ranges is wrong"
  ) in
  match iCst with
    | IConstant n Decimal Nothing ->
        if AAux.in_min_integer_range n (Signed Int_) then
          Concrete (Signed Int_)
(*
        else if AAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
*)
        else
          Unknown iCst
    | IConstant n _ Nothing ->
        (* Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Signed Int_) then
          Concrete (Signed Int_)
(*
        else if AAux.in_min_integer_range n (Unsigned Int_) then
          Concrete (Unsigned Int_)
        else if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n _ (Just U) ->
        (* Decimal, Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Unsigned Int_) then
          Concrete (Unsigned Int_)
(*
        else if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n Decimal (Just L) ->
        if AAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
(*
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
*)
        else
          Unknown iCst
    | IConstant n _ (Just L) ->
        (* Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Signed Long) then
          Concrete (Signed Long)
(*
        else if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
        else if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n _ (Just UL) ->
        (* Decimal, Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Unsigned Long) then
          Concrete (Unsigned Long)
(*
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n Decimal (Just LL) ->
        if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
        else
          Unknown iCst
    | IConstant n _ (Just LL) ->
        (* Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Signed LongLong) then
          Concrete (Signed LongLong)
(*
        else if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
*)
        else
          Unknown iCst
    
    | IConstant n _ (Just ULL) ->
        (* Decimal, Octal or Hexadecimal *)
        if AAux.in_min_integer_range n (Unsigned LongLong) then
          Concrete (Unsigned LongLong)
        else
          Unknown iCst
    
    | IConstantMax ity ->
        Concrete ity
    
    | IConstantMin ity ->
        Concrete ity
end
let inline type_of_constant = gen_typing_type_of_constant

(* TODO: is only used once, could be inlined *)
(* STD §6.5.16.1#1 *)
val well_typed_assignment: sigma unit -> ctype -> genType -> bool -> E.errorM bool
let well_typed_assignment s ty1 gty2 null2 =
  (* STD §6.5.16.1#1, bullet 1 *)
  if AAux.atomic_qualified_unqualified AAux.is_arithmetic ty1 && GAux.is_arithmetic gty2 then
    let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 1") in
    E.return true
  
  (* STD §6.5.16.1#1, bullet 2 *)
  else if AAux.atomic_qualified_unqualified AAux.is_struct_or_union ty1 then
    match (ty1, gty2) with
      | (Struct tag_sym1, GenStruct tag_sym2) ->
          (* TODO: this is maybe too conservative *)
          let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
            "[well_typed_assignment] exiting with bullet 2 ==> " ^
            Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
          E.return (tag_sym1 = tag_sym2)
      
      | (Union tag_sym1, GenUnion tag_sym2) ->
          (* TODO: this is maybe too conservative *)
          let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
            "[well_typed_assignment] exiting with bullet 2 ==> " ^
            Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
          E.return (tag_sym1 = tag_sym2)
      | _ ->
          error "not possible"
    end
  
  else if AAux.atomic_qualified_unqualified AAux.is_pointer ty1 then
    let () = Debug.print_debug 2 [] (fun () ->
      "TODO: check the use of AAux.lvalue_conversion"
    ) in
    AAux.lvalue_conversion s ty1 >>= fun conv_ty1 ->
    let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
      "[well_typed_assignment] before bullet 3: conv_ty1= " ^Pp.stringFromAil_ctype no_qualifiers conv_ty1  ^
      " -- gty2= " ^ Pp.stringFromAil_genType gty2) in
    match (ty1, conv_ty1, gty2) with
      | (Pointer ref_qs1 _, Pointer _ conv_ref_ty1, GenPointer ref_qs2 ref_ty2) ->
          (* STD §6.5.16.1#1, bullet 3 *)
          (* doing the "qualified or unqualified versions of" by checking the compatibility of
             the unqualified referenced type with no qualifiers *)
          (* NOTE: for the left operand, we are looking at the qualifiers before
             conversion (since the lvalue conversion removes the qualifiers) *)
          if    AAux.are_compatible (no_qualifiers, conv_ref_ty1) (no_qualifiers, ref_ty2)
             && AAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 3") in (* DEBUG *)
            let () = Debug.print_debug 1 [] (fun () ->
              (* TODO !!!! *)
              "FIXME: sub_qualifiers sees the wrong qualifiers (GenTypeCategory RValue seems to be at fault) !!!!"
            ) in
            E.return true
          
          (* STD §6.5.16.1#1, bullet 4 *)
          else if (   (AAux.is_object conv_ref_ty1 && AAux.is_void   ref_ty2)
                   || (AAux.is_void   conv_ref_ty1 && AAux.is_object ref_ty2) ) &&
                  AAux.sub_qualifiers ref_qs2 ref_qs1 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 4")        in (* DEBUG *)
            E.return true
          
          (* STD §6.5.16.1#1, bullet 5 *)
          else if null2 then
            let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 5") in (* DEBUG *)
            E.return true
          
          else
            let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
              "[well_typed_assignment] KO: is_pointer ty1 && gty2 ==> (ref_qs1, conv_ref_ty1)= " ^
              Pp.stringFromAil_human_ctype ref_qs1 conv_ref_ty1 ^ ", (ref_qs2, ref_ty2)= " ^
              Pp.stringFromAil_human_ctype ref_qs2 ref_ty2
            ) in (* DEBUG *)
            E.return false
      | _ ->
          (* STD §6.5.16.1#1, bullet 5 *)
          E.return null2
(*
          let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] KO: is_pointer ty1") in (* DEBUG *)
          E.return false
*)
    end
  
  (* STD §6.5.16.1#1, bullet 6 *)
  else if AAux.atomic_qualified_unqualified AAux.is_Bool ty1 && GAux.is_pointer gty2 then
    let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] OK: bullet 6") in (* DEBUG *)
    E.return true
  
  else
    let _ = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () -> "[well_typed_assignment] KO: the end") in (* DEBUG *)
    E.return false


(* STD §6.5.9#2 *)
val well_typed_equality: genType -> genType -> bool -> bool -> bool
let well_typed_equality gty1 gty2 is_null1 is_null2 =
     is_arithmetic gty1 && is_arithmetic gty2               (* STD §6.5.9#2, item 1 *)
  || are_pointers_to_compatible_types gty1 gty2             (* STD §6.5.9#2, item 2 *)
  || (Global.isDefacto () && is_pointer_to_object gty1 && is_pointer_to_object gty2)
  || is_pointer_to_void gty1   && is_pointer_to_object gty2 (* STD §6.5.9#2, item 3 *)
  || is_pointer_to_object gty1 && is_pointer_to_void gty2   (* STD §6.5.9#2, item 3 *)
  || is_pointer gty1 && is_null2                            (* STD §6.5.9#2, item 4 *)
  || is_null1        && is_pointer gty2                     (* STD §6.5.9#2, item 4 *)


let well_typed_binary_arithmetic gt1 aop gt2 : bool =
  match aop with
    | Mul  -> is_arithmetic gt1 && is_arithmetic gt2
    | Div  -> is_arithmetic gt1 && is_arithmetic gt2
    | Mod  -> is_integer    gt1 && is_integer    gt2
    | Add  -> is_arithmetic gt1 && is_arithmetic gt2
    | Sub  -> is_arithmetic gt1 && is_arithmetic gt2
    (* STD §6.5#4, sentence 1 *)
    | Shl  -> is_integer    gt1 && is_integer    gt2
    | Shr  -> is_integer    gt1 && is_integer    gt2
    | Band -> is_integer    gt1 && is_integer    gt2
    | Bxor -> is_integer    gt1 && is_integer    gt2
    | Bor  -> is_integer    gt1 && is_integer    gt2
  end


val combine_qualifiers_left: genType -> genType -> genType
let combine_qualifiers_left gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 ty1, GenPointer qs2 _) ->
        GenPointer (AAux.combine_qualifiers qs1 qs2) ty1
    | (GenPointer _  _ , _) ->
        gty1
    | _ ->
        gty1
  end


val combine_qualifiers_right: genType -> genType -> genType
let combine_qualifiers_right gty1 gty2 =
  match (gty1, gty2) with
    | (GenPointer qs1 _, GenPointer qs2 ty2) ->
        GenPointer (AAux.combine_qualifiers qs1 qs2) ty2
    | (_, GenPointer _ _) ->
        gty2
    | _ ->
        gty2
  end


val well_typed_conditional:
    (Loc.t * Loc.t * Loc.t * Loc.t) ->
    genType -> genType -> genType -> bool -> bool -> E.errorM genTypeCategory
let well_typed_conditional (loc_cond, loc_e1, loc_e2, loc_e3) gty1 gty2 gty3 is_null2 is_null3 =
  let () = Debug.warn [] (fun () -> "TODO: need to clean GenTyping.well_typed_conditional (see the WIP comment)") in
  
(* STD §6.5.15#2 *)
  if is_scalar gty1 then
    (* STD §6.5.15#3, bullet 1 *)
    if is_arithmetic gty2 && is_arithmetic gty3 then
      (* STD §6.5.15#5, sentence 1 *)
      E.return (GenRValueType (usual_arithmetic gty2 gty3))
    
    (* STD §6.5.15#3, bullet 2 *)
    else if GAux.is_struct_or_union gty2 && gty2 = gty3 then
      (* STD §6.5.15#5, sentence 2 *)
      E.return (GenRValueType gty2)
    
    (* STD §6.5.15#3, bullet 3 *)
    else if GAux.void gty2 && GAux.void gty3 then
      (* STD §6.5.15#5, sentence 3 *)
      E.return (GenRValueType GenVoid)
    
(* WIP
    else match (gty2, gty3) with
      | (GenPointer ref_qs2 ref_ty2, GenPointer ref_qs3 ref_ty3) ->
          (*  *)
          let result_qs = AAux.combine_qualifiers ref_qs ref_qs2 in
      



    (* STD §6.5.15#3, bullet 5 *)
    else if GAux.is_pointer gty2 && is_null3 then
      (* STD §6.5.15#6, sentence 1 *)
      (* STD §6.5.15#6, sentence 3 *)
      E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
    else if is_null2 && GAux.is_pointer gty3 then
      (* STD §6.5.15#6, sentence 1 *)
      (* STD §6.5.15#6, sentence 3 *)
      E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
    else 


    (* STD §6.5.15#3, bullet 4 *)
    (* STD §6.5.15#3, bullet 6 *)

    else 

    end
*)
    
    else match composite_pointer gty2 gty3 with
      | Just gty ->
          E.return (GenRValueType gty)
      | Nothing ->
          if void gty2 && void gty3 then
            E.return (GenRValueType GenVoid)
          else if is_pointer gty2 && is_null3 then
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else if is_pointer gty3 && is_null2 then
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty2 && is_pointer_to_void gty3 then
            E.return (GenRValueType (combine_qualifiers_right gty2 gty3))
          else if is_pointer_to_object gty3 && is_pointer_to_void gty2 then
            E.return (GenRValueType (combine_qualifiers_left gty2 gty3))
          else E.fail Loc.unknown (TError_TODO 9)
    end
  else
    E.fail (Loc.with_cursor_from loc_e1 loc_cond) (TError "§6.5.15#2")


val annotate_stringLiteral: stringLiteral -> E.errorM (expression_ genTypeCategory * genTypeCategory)
let annotate_stringLiteral (pref_opt, strs) =
  let elem_ty = match pref_opt with
                  | Nothing     -> Basic (Integer Char)                 (* STD §6.4.5#6 sentence 3 *)
                  | Just Enc_u8 -> Basic (Integer Char)                 (* STD §6.4.5#6 sentence 4 *)
                  | Just Enc_u  -> char16_t                             (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_U  -> char32_t                             (* STD §6.4.5#6 sentence 6 *)
                  | Just Enc_L  -> Basic (Integer (IBuiltin "wchar_t")) (* STD §6.4.5#6 sentence 5 *)
                end in

  (* TODO: check the type *)
  E.return
    ( AilEstr (pref_opt, strs)
    , GenLValueType no_qualifiers (Array elem_ty (Just $ integerFromNatural (naturalFromNat (List.length strs + 1)))) false )


val     annotate_constant: constant -> E.errorM (constant * genTypeCategory)
let rec annotate_constant cst =
  match cst with
    | ConstantInteger iCst ->
        E.return (ConstantInteger iCst, GenRValueType (GenBasic (GenInteger (type_of_constant iCst))))
    | ConstantFloating ((_, suff_opt) as fCst) ->
        (* STD §6.4.4.2#4 *)
        let rfty = match suff_opt with
          | Nothing ->
              Double
          | Just Fsuf_F ->
              Float
          | Just Fsuf_L ->
              LongDouble
        end in
        E.return (ConstantFloating fCst, GenRValueType (GenBasic (GenFloating (RealFloating rfty))))
    | ConstantCharacter cc ->
        (* TODO: §6.4.4.4#9 *)
        match fst cc with
          | Nothing ->
              (* §6.4.4.4#10 *)
              E.return (ConstantCharacter cc, GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
          | Just Pref_L ->
              (* §6.4.4.4#11 *)
              E.return (ConstantCharacter cc, GenRValueType (GenBasic (GenInteger (Concrete (IBuiltin "wchar_t")))))
          | Just Pref_u ->
              (* §6.4.4.4#11 *)
              E.return (ConstantCharacter cc, GenRValueType genChar16_t)
          | Just Pref_U ->
              (* §6.4.4.4#11 *)
              E.return (ConstantCharacter cc, GenRValueType genChar32_t)
        end
    
    | ConstantArray csts ->
        E.mapM annotate_constant csts >>= fun a_csts ->
        (* TODO: this is probably too strong *)
        match a_csts with
          | [] ->
              E.fail Loc.unknown (TError "empty array constant")
          | (_, genTy)::a_csts' ->
              if List.all (fun (_, genTy') -> genTy = genTy') a_csts' then
                E.return (ConstantArray (List.map fst a_csts),
                          GenRValueType (GenArray (* TODO *)Void (Just $ integerFromNat (List.length a_csts))))
              else
                E.fail Loc.unknown (TError "array constant elements don't all have the same type")
        end
    | ConstantIndeterminate ty ->
        E.return (ConstantIndeterminate ty, GenRValueType (GenTypes.inject_type ty))
    | ConstantNull ->
        (* TODO: check *)
        E.return (ConstantNull, GenRValueType (GenPointer no_qualifiers Void))
    | ConstantStruct tag_sym xs ->
        E.mapM (fun (memb_ident, e) ->
          (* TODO: need to check that the members type match ... *)
          annotate_constant e >>= fun a_e -> E.return (memb_ident, fst a_e)
        ) xs >>= fun a_xs ->
        E.return (ConstantStruct tag_sym a_xs, GenRValueType (GenTypes.GenStruct tag_sym))
    | ConstantUnion tag_sym memb_ident cst ->
        error "WIP: annotate_constant, ConstantUnion"
  end


(* TODO: temporary *)
val     are_all_eq: forall 'a. Eq 'a => list 'a -> bool
let rec are_all_eq xs =
  match xs with
    | [] ->
        true
    | [_] ->
        true
    | x::y::xs' ->
        x=y && are_all_eq (y::xs')
  end

val annotate_rvalue: sigma unit -> gamma -> expression unit -> E.errorM (expression genTypeCategory * genType)
val annotate_assignee: sigma unit -> gamma -> ctype -> expression unit -> E.errorM (expression genTypeCategory)
val annotate_arguments:
  sigma unit -> gamma -> bool -> bool -> list (expression unit) -> list (qualifiers * ctype * bool) ->
  E.errorM (list (expression genTypeCategory))

(* context given to [annotate_expression] to inform it on the what the current
   expression is: *)
type annotation_context =
    (* operand of AilEsizeof_expr *)
  | CTXsizeof
    (* operand of AilEunary Address *)
  | CTXaddr
    (* operand of AilEunary PostfixIncr *)
  | CTXincr
    (* operand of AilEunary PostfixDecr *)
  | CTXdecr
    (* left operand of AilEmemberof *)
  | CTXmemberof
    (* left operand of AilEassign or AilEcompoundAssign *)
  | CTXassign
  (* array initialiser (used by AilEstr) *)
  | CTXarray_init
    (* otherwise *)
  | CTXother

val     annotate_expression: sigma unit -> gamma -> annotation_context -> expression unit -> E.errorM (expression genTypeCategory)
let rec annotate_expression sigm gamm ctx (AnnotatedExpression () std_annots loc expr_) =
  let annotate_expression = annotate_expression sigm gamm in
  let annotate_rvalue     = annotate_rvalue sigm gamm     in
  let annotate_assignee   = annotate_assignee sigm gamm   in
  let annotate_arguments  = annotate_arguments sigm gamm  in
  match expr_ with
    | AilEunary (Plus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        E.add "§6.5.3.3#1, sentence 1" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_arithmetic gty then
          let mk_conversion =
            if is_integer gty then integer_promote else (fun z -> z) in
          E.return (AilEunary uop a_e, GenRValueType (mk_conversion gty))
        else
          E.fail (locOf e) (TError "§6.5.3.3#1, sentence 1")
    
    | AilEunary (Minus as uop) e ->
        (* STD §6.5.3.3#1, sentence 1 *)
        E.add "§6.5.3.3#1, sentence 1" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_arithmetic gty then
          let mk_conversion =
            if is_integer gty then integer_promote else (fun z -> z) in
          E.return (AilEunary uop a_e, GenRValueType (mk_conversion gty))
        else
          E.fail (locOf e) (TError "§6.5.3.3#1, sentence 1")
    
    | AilEunary (Bnot as uop) e ->
        (* STD §6.5#4, sentence 1 *)
        (* STD §6.5.3.3#1, sentence 2 *)
        E.add "STD §6.5.3.3#1, sentence 2" >>
        annotate_rvalue e >>= fun (a_e, gty) ->
        if is_integer gty then
          E.return (AilEunary uop a_e, GenRValueType (integer_promote gty))
        else
          E.fail (locOf e) (TError "§6.5.3.3#1, sentence 2")
    
    | AilEunary (Address as uop) e ->
        (* STD §6.5.3.2#1 *)
        E.add "§6.5.3.2#1" >>
        annotate_expression CTXaddr e >>= fun a_e ->
        match GenTypes.genTypeCategoryOf a_e with
          | GenRValueType (GenFunction hasProto ty params isVariadic) ->
              (* e is a 'function designator' *)
              let gty' = GenPointer no_qualifiers (Function hasProto ty params isVariadic) in
              E.return (AilEunary Address a_e, GenRValueType gty') 
          | GenRValueType _ ->
              E.fail (locOf e) (TError "§6.5.3.2#1, non function rvalue")
          | GenLValueType qs ty isRegister ->
              (* e is an 'lvalue' *)
              let () = Debug.warn [Debug.DB_ail_typing]
                 (fun () -> "(TODO) GenTyping.annotate_expression AilEunary Address, not checking for bit-field member") in
              if isRegister then
                E.fail (locOf e) (TError "§6.5.3.2#1, register")
              else
                (* STD §6.5.3.2#3, 2nd sentence *)
                E.return (AilEunary Address a_e, GenRValueType (GenPointer qs ty))
        end
    
    | AilEunary Indirection e ->
        annotate_rvalue e >>= fun (e', gty) ->
        match gty with
          | GenPointer qs (Function has_proto ty params is_variadic) ->
              if AAux.is_unqualified qs
              then E.return (AilEunary Indirection e', GenRValueType (GenPointer qs (Function has_proto ty params is_variadic)))
              else E.fail loc (TError_TODO 18)
          | GenPointer qs ty ->
              if AAux.is_complete sigm ty && AAux.is_object ty
              then E.return (AilEunary Indirection e', GenLValueType qs ty false)
              else E.fail loc (TError_TODO 19)
          | _ ->
              E.fail loc (TError_TODO 20)
        end
*)
    
    | AilEunary (PostfixIncr as uop) e ->
        annotate_expression CTXincr e >>= fun e' ->
        match GenTypes.genTypeCategoryOf e' with
          | GenLValueType qs' ty' _ ->
              AAux.lvalue_coercion sigm ty' >>= fun ty' ->
              if AAux.modifiable sigm qs' ty' && (AAux.is_real ty' || AAux.is_pointer ty') then
                E.return (AilEunary uop e', GenRValueType (inject_type ty'))
              else
                E.fail loc (TError_TODO 21)
          | _ -> E.fail loc (TError_TODO 22)
        end
    
    | AilEunary (PostfixDecr as uop) e ->
        annotate_expression CTXdecr e >>= fun e' ->
        match GenTypes.genTypeCategoryOf e' with
          | GenLValueType qs' ty' _ ->
              AAux.lvalue_coercion sigm ty' >>= fun ty' ->
              if AAux.modifiable sigm qs' ty' && (AAux.is_real ty' || AAux.is_pointer ty') then
                E.return (AilEunary uop e', GenRValueType (inject_type ty'))
              else
                E.fail loc (TError_TODO 23)
          | _ -> E.fail loc (TError_TODO 24)
        end
    
    | AilEarray is_str elem_ty e_opts ->
        (* TODO: think about it *)
        E.mapM (maybe (E.return Nothing) (fun e ->
          annotate_rvalue e >>= fun (e', gty) ->
          (* TODO: maybe this is too strict and we want to relax to only having
             the types compatibles? *)
          if inject_type elem_ty <> gty then
            E.fail loc (TError "illtyped element of an AilEarray")
          else
            E.return (Just e')
        )) e_opts >>= fun xs ->
        (* TODO: checking that the types in [xs] match ty *)
        E.return ( AilEarray is_str elem_ty xs
                 , GenRValueType (GenArray elem_ty (Just (integerFromNat $ List.length xs))) )
    
    | AilEstruct tag_sym xs ->
        E.mapM (fun (ident, e_opt) ->
          maybe (E.return Nothing) (fun e -> Just <$> annotate_rvalue e) e_opt >>= fun a_e_opt ->
          E.return (ident, Maybe.map fst a_e_opt)
        ) xs >>= fun xs' ->
        (* TODO: the actual type checking of the members ... *)
        let () = Debug.warn [Debug.DB_ail_typing] (fun () -> "typing of struct constant doesn't check the members are valid for the tag") in
        E.return (AilEstruct tag_sym xs', GenRValueType (GenStruct tag_sym))
    
    | AilEunion tag_sym memb_ident e_opt ->
        maybe (E.return Nothing) (fun e -> (Just -| fst) <$> annotate_rvalue e) e_opt >>= fun a_e_opt ->
        let () = Debug.warn [Debug.DB_ail_typing] (fun () -> "typing of union constant doesn't check the member is valid for the tag") in
        E.return (AilEunion tag_sym memb_ident a_e_opt, GenRValueType (GenUnion tag_sym))
    
    | AilEcompound ty e ->
        (* STD §6.5.2.5#1 *)
        E.add "§6.5.2.5#1" >>
        if    (AAux.is_complete sigm ty && AAux.is_object ty)
           || (AAux.is_array_unknown_size ty && not (AAux.is_vla ty)) then
          (* TODO: check that *)
          annotate_definition_aux sigm gamm (ty, e) >>= fun a_e ->
          E.return (AilEcompound ty a_e, GenLValueType no_qualifiers ty false)
        else
          E.fail loc (TError "AilEcompound")
    
    | AilEbuiltin str ->
        match Builtins.ctype_of_builtin_varname str with
          | Just ty ->
              E.return (AilEbuiltin str, GenRValueType (inject_type ty))
          | Nothing ->
              error ("WIP typing, AilEbuiltin: " ^ str)
        end
(*

(GenBasic (GenInteger (Concrete ity))))


        (* TODO: check *)
        let ity = match str with
          | "INT8_MIN" ->
              Signed Int_
          | "INT16_MIN" ->
              Signed Int_
          | "INT32_MIN" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MIN" ->
              Signed Long
          | "INT8_MAX" ->
              Signed Int_
          | "INT16_MAX" ->
              Signed Int_
          | "INT32_MAX" ->
              Signed Int_ (* TODO: this might not fit in a signed int ... *)
          | "INT64_MAX" ->
              Signed Long
          | "UINT8_MAX" ->
              Unsigned Int_
          | "UINT16_MAX" ->
              Unsigned Int_
          | "UINT32_MAX" ->
              Unsigned Int_ (* TODO: this might not fit in a signed int ... *)
          | "UINT64_MAX" ->
              Unsigned Long
          | _ ->
              error ("WIP typing, AilEbuiltin: " ^ str)
        end in
        E.return (AilEbuiltin str, GenRValueType (GenBasic (GenInteger (Concrete ity))))
*)
    
    | AilEident sym ->
        match (Context.lookup identifierEqual gamm sym, Context.lookup identifierEqual sigm.declarations sym) with
          | (Just ((_, isRegister), qs, ty), Nothing) ->
              let () = Debug.print_debug 1 [Debug.DB_ail_typing] (fun () ->
                "[AilEident (gamma)] " ^ show sym ^ " -- " ^ Pp.stringFromAil_ctype qs ty
              ) in
              E.return (AilEident sym, GenLValueType qs ty isRegister)
          | (Nothing, Just (_, Decl_object (_, isRegister) qs ty)) ->
              let () = Debug.print_debug 1 [Debug.DB_ail_typing] (fun () ->
                "[AilEident (sigma)] " ^ show sym ^ " -- " ^ Pp.stringFromAil_ctype qs ty
              ) in
              E.return (AilEident sym, GenLValueType qs ty isRegister)
          | (Nothing, Just (_, Decl_function has_proto (ret_qs, ret_ty) params is_variadic _ (* is_inline *) _ (* is_Noreturn *))) ->
              (* TODO: is_inline, is_Noreturn *)
              (* NOTE: here sym is a 'function designator', hence it has function type. BUT
                 other part of the typechecker MUST perform the 'function_coercion' as described in
                 (§6.3.2.1#4). *)
              E.return (AilEident sym, GenRValueType (inject_type (Function has_proto (ret_qs, ret_ty) params is_variadic)))
          | _ ->
              E.fail loc (TError_TODO 13)
        end
(* TODO(clean)
        tryM (lookup g v)
          (* block variable *)
          (fun (qs, ty) -> E.return (Var v, GenLValueType qs ty))
          (lookup s v >>= function
            | Right (qs, ty, _) ->
                (* global variable *)
                E.return (Var v, GenLValueType qs ty)
            | Left p ->
                (* function name *)
                E.return (Var v, GenRValueType (inject_type (type_from_sigma p)))
          end)
*)

(*
OLD(sigma_declaration)

        match (lookup g v, sigma_lookup s v) with
          | (Just (qs, ty), Nothing) ->
              E.return (AilEident v, GenLValueType qs ty)
          | (Nothing, Just (SDecl_global _ (qs, ty, _))) ->
              (* global variable *)
              E.return (AilEident v, GenLValueType qs ty)
          | (Nothing, Just (SDecl_fun _ fdecl)) ->
              (* function name *)
              E.return (AilEident v,
                      GenRValueType (inject_type (type_from_sigma ((fdecl.fun_return_ty, fdecl.fun_bindings, fdecl.fun_is_variadic), fdecl.fun_body))))
          | (_, _) ->
              E.fail Loc.unknown (TError_TODO 13)
        end
*)
(* (OLD)
      match (lookup g v, lookup s v) with
      | (Just (q, t), Nothing) -> Just (Var v, GenLValueType q t)
      | (Nothing    , Just p ) -> Just (Var v, GenRValueType (inject_type (type_from_sigma p)))
      | (_          , _      ) -> Nothing
      end
*)
    
    | AilEbinary e1 Comma e2 ->
        (* STD §6.5.17#3, sentence 3 *)
        E.add "§6.5.17#3, sentence 3" >>
        annotate_rvalue e1 >>= fun (e1', _  ) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        E.return (AilEbinary e1' Comma e2', GenRValueType gty2)
    
     (* TODO: it may be to restrictive to only direct left-expressions for atomic functions *)
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEbuiltin "atomic_load_explicit")) [object_e; order_e] ->
        annotate_rvalue object_e >>= fun (object_e', object_gty) ->
        annotate_rvalue order_e  >>= fun (order_e' , order_gty ) ->
        match (object_gty, order_gty) with
          | (GenPointer qs object_ty, GenBasic (GenInteger _ (* TODO: need to enforce enum *))) ->
(*               if AAux.is_atomic object_ty then *)
              E.return (AilEcall (AnnotatedExpression ((* TODO: HACK *) GenRValueType GenVoid) annots' loc' (AilEbuiltin "atomic_load_explicit")) [object_e'; order_e'], GenRValueType (inject_type $ AAux.unatomic object_ty))
(*
               else
                 error "WIP: typing of atomic_load_explicit 2"
*)
          | _ ->
              error "WIP: typing of atomic_load_explicit"
        end
    
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEbuiltin "atomic_store_explicit")) [object_e; desired_e; order_e] ->
        annotate_rvalue object_e  >>= fun (object_e',  object_gty)  ->
        annotate_rvalue desired_e >>= fun (desired_e', desired_gty) ->
        annotate_rvalue order_e   >>= fun (order_e',   order_gty)   ->
        E.return (AilEcall (AnnotatedExpression ((* TODO: HACK *) GenRValueType GenVoid) annots' loc' (AilEbuiltin "atomic_store_explicit")) [object_e'; desired_e'; order_e'],
                  GenRValueType GenVoid)
(*
         match (object_gty, desired_e; order_gty) with
           | () ->
                 E.return (AilEcall (AnnotatedExpression ((* TODO: HACK *) GenRValueType GenVoid) (AilEbuiltin "atomic_load_explicit")) [object_e'; order_e'], GenRValueType (inject_type $ AAux.unat           | _ ->
               error "WIP: typing of atomic_store_explicit"
         end
*)
    
    | AilEcall (AnnotatedExpression _ annots' loc' (AilEbuiltin "atomic_compare_exchange_strong_explicit")) [object_e; expected_e; desired_e; order_success_e; order_failure_e] ->
        annotate_rvalue object_e        >>= fun (object_e',        object_gty)        ->
        annotate_rvalue expected_e      >>= fun (expected_e',      expected_gty)      ->
        annotate_rvalue desired_e       >>= fun (desired_e',       desired_gty)       ->
        annotate_rvalue order_success_e >>= fun (order_success_e', order_success_gty) ->
        annotate_rvalue order_failure_e >>= fun (order_failure_e', order_failure_gty) ->
        (* TODO: do actual checks *)
        
        E.return (AilEcall (AnnotatedExpression ((* TODO: HACK *) GenRValueType GenVoid) annots' loc' (AilEbuiltin "atomic_compare_exchange_strong_explicit"))
                    [object_e'; expected_e'; desired_e'; order_success_e'; order_failure_e'],
                   GenRValueType (GenBasic (GenInteger (Concrete (AilTypes.Bool)))))
    
    | AilEcall e es ->
        (* STD §6.5.2.2#1 *)
        E.add "§6.5.2.2#1" >>
        annotate_rvalue e >>= function
          | (e', GenPointer qs (Function has_proto (ret_qs, ret_ty) params is_variadic)) ->
              (* TODO: qualifiers *)
              let () = Debug.warn [] (fun () ->
                "(unsure) the typing of AilEcall doesn't look at [ret_qs]"
              ) in
              (* NOTE: I don't see how the C syntax would allow one to have
                 a "pointer to function returning array" anyway... *)
              if not (ret_ty = Void || (AAux.is_complete_object sigm ret_ty && not (AAux.is_array ret_ty))) then
                E.fail loc (TError "§6.5.2.2#1")
              else if AAux.is_unqualified qs then
                annotate_arguments has_proto is_variadic es params >>= fun es' ->
                E.return (AilEcall e' es', GenRValueType (inject_type ret_ty))
              else
                E.fail loc (TError_TODO 25)
          | _ ->
              E.fail loc (TError_TODO 26)
        end
    
    | AilEassert e ->
        annotate_rvalue e >>= fun (e', gty) ->
        if is_scalar gty then
          E.return (AilEassert e', GenRValueType GenVoid)
        else
          E.fail loc (TError "§7.2.1.1#1")
    
    | AilEoffsetof ty ident ->
        E.return (AilEoffsetof ty ident, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEgeneric (* e gas *) _ _ ->
        E.fail loc (TError "WIP: GenTyping AilEgeneric")
(*
        annotate_expression e                     >>= fun e'   ->
        E.mapM (annotate_generic_association a s g) gas >>= fun gas' ->
        
        let ty_e' = match interpret_genTypeCategory (GenTypes.genTypeCategoryOf e') with
          | LValueType _ ty ->
              ty  KKK
          | RValueType ty ->
              ty
        end in
        
        E.foldM (fun (saw_compatible, saw_default, prev_gas) ga ->
          match ga with
            | AilGAtype ty _ ->
                if List.any (function
                               | AilGAtype ty _ -> AAux.compatible ty_e' ty
                               | _ -> false
                            end) prev_gas then
                  E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 3")
                
                else if AAux.compatible ty_e' ty then
                  if saw_compatible then
                    E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 4")
                  else
                    E.return (true, saw_default, ga :: prev_gas)
                else
                  E.return (saw_compatible, saw_default, ga :: prev_gas)
            | AilGAdefault _ ->
                if saw_default then
                  E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 1")
                else
                  E.return (saw_compatible, true, prev_gas)
          end
        ) (false, false, []) gas' >>= fun (saw_compatible, saw_default, _) ->
        
        if not saw_default && not saw_compatible then
          E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 5")
        else
          E.return (AilEgeneric e' gas')
*)
  
  (* TODO: check with J *)
(*
TODO
  | AilEmemberof e x ->
      annotate_rvalue e >>= fun (a_e, gt) ->
      match gt with
        | GenStruct tag_opt members ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#1")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  error "WIP"
            end
        | GenUnion tag_opt members ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#1")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  error "WIP"
            end
        | _ ->
            E.fail Loc.unknown (TError "§6.5.2.3#1")
      end

  (* TODO: check with J *)
  | AilEmemberofptr e x ->
      annotate_rvalue e >>= fun (a_e, gt) ->
      match gt with
        | GenPointer _ (Struct members) ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#2")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  error "WIP"
            end
        | GenPointer _ (Union  members) ->
            match List.lookup x members with
              | Nothing ->
                  E.fail Loc.unknown (TError "§6.5.2.3#2")
              | Just ty ->
                  let _TODO = (ty, a_e) in
                  error "WIP"
            end
        | _ ->
            E.fail Loc.unknown (TError "§6.5.2.3#2")
      end
*)
    
    | AilEmemberof e memb_ident ->
        (* TODO: factorise *)
        (* TODO: Atomic types *)
        annotate_expression CTXmemberof e >>= fun a_e ->
        (* the value of the AilEmemberof operator is an lvalue if [e] is an lvalue *)
        match GenTypes.genTypeCategoryOf a_e with
          | GenLValueType qs ty _ ->
              (* NOTE: the member his not a "register" regardless of whether the
                 struct/union was *)
              (* NOTE: the qualifiers of the value are the combination of the ones
                of the left operand [e] and the ones in the declaration of the
                 member type (see §6.5.2.3#3 and #8) *)
              match ty with
                | Struct tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (StructDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (memb_qs, memb_ty) ->
                                E.return ( AilEmemberof a_e memb_ident
                                         , GenLValueType (AAux.combine_qualifiers qs memb_qs) memb_ty false )
                            | Nothing ->
                                E.fail loc (TError "TODO[msg] Struct memberof: invalid member")
                          end
                      | _ ->
                          E.fail loc (TError "TODO[msg] AilEmemberof Struct, failed to kind a valid tag definition")
                    end
                | Union tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (UnionDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (memb_qs, memb_ty) ->
                                E.return ( AilEmemberof a_e memb_ident
                                         , GenLValueType (AAux.combine_qualifiers qs memb_qs) memb_ty false )
                            | Nothing ->
                                E.fail loc (TError "TODO[msg] Union memberof: invalid member")
                          end
                      | _ ->
                          E.fail loc (TError "TODO[msg] AilEmemberof Union, failed to kind a valid tag definition")
                    end
                | _ ->
                    E.fail loc (TError "TODO[msg] AilEmemberof, the postfix-expression must have struct/union type")
              end
          | GenRValueType gty ->
              match gty with
                | GenStruct tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (StructDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (_, memb_ty) ->
                                E.return (AilEmemberof a_e memb_ident, GenRValueType (GenTypes.inject_type memb_ty))
                            | Nothing ->
                                E.fail loc (TError "TODO[msg] Struct memberof: invalid member")
                          end
                      | _ ->
                          E.fail loc (TError "TODO[msg] AilEmemberof Struct, failed to kind a valid tag definition")
                    end
                | GenUnion tag_sym ->
                    match lookup_tag_definition sigm tag_sym with
                      | Just (UnionDef membersDefs) ->
                          match List.lookup memb_ident membersDefs with
                            | Just (_, memb_ty) ->
                                E.return (AilEmemberof a_e memb_ident, GenRValueType (GenTypes.inject_type memb_ty))
                            | Nothing ->
                                E.fail loc (TError "TODO[msg] Union memberof: invalid member")
                          end
                      | _ ->
                          E.fail loc (TError "TODO[msg] AilEmemberof Union, failed to find a valid tag definition")
                    end
                | _ ->
                    E.fail loc (TError "TODO[msg] AilEmemberof, the postfix-expression must have struct/union type")
              end
        end
    
    | AilEmemberofptr e memb_ident ->
      (* TODO: factorize *)
      (* TODO: Atomic types *)
      (* NOTE: the qualifiers of the value are the combination of the ones
         of the referenced type of left operand [e] and the ones in the
         declaration of the member type (see §6.5.2.3#4) *)
        annotate_rvalue e >>= function
          | (e', GenPointer ref_qs (Struct tag_sym)) ->
              match lookup_tag_definition sigm tag_sym with
                | Just (StructDef membersDefs) ->
                    match List.lookup memb_ident membersDefs with
                      | Just (memb_qs, memb_ty) ->
                          E.return ( AilEmemberofptr e' memb_ident
                                   , GenLValueType (AAux.combine_qualifiers ref_qs memb_qs) memb_ty false )
                      | Nothing ->
                          E.fail loc (TError "TODO[msg] Struct memberofptr: invalid member")
                    end
                | _ ->
                    E.fail loc (TError "TODO: AilEmemberofptr Struct, failed to find a valid tag definition")
              end
          | (e', GenPointer ref_qs (Union tag_sym)) ->
              match lookup_tag_definition sigm tag_sym with
                | Just (UnionDef membersDefs) ->
                    match List.lookup memb_ident membersDefs with
                      | Just (memb_qs, memb_ty) ->
                          E.return ( AilEmemberofptr e' memb_ident
                                   , GenLValueType (AAux.combine_qualifiers ref_qs memb_qs) memb_ty false )
                      | Nothing ->
                          E.fail loc (TError "TODO[msg] Union memberofptr: invalid member")
                    end
                | _ ->
                    E.fail loc (TError "TODO: AilEmemberofptr Union, failed to kind a valid tag definition")
              end
          | _ ->
              E.fail (Loc.with_cursor_from (Loc.locOf e) loc)
                        (TError "TODO[msg] AilEmemberofptr, the left operand must be a pointer to a struct/union")
        end
    
    | AilEassign e1 e2 ->
        let fail =
          E.fail (Loc.with_cursor_from (Loc.locOf e1) loc) (TError "§6.5.16#2") in
        annotate_expression CTXassign e1 >>= fun e1' ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs1 ty1 _ ->
              if AAux.modifiable sigm qs1 ty1 then
                (* STD §6.5.16#3, sentence 3 *)
                let assign_ty = AAux.rvalue_coercion ty1 in
                annotate_assignee assign_ty e2 >>= fun e2' -> 
                E.return (AilEassign e1' e2', GenRValueType (inject_type assign_ty))
              else
                fail (* lvalue was not modifiable *)
          | _ ->
              fail (* was not a lvalue *)
        end
    
    | AilEbinary e1 (Arithmetic (Mul  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 29)
    
    | AilEbinary e1 (Arithmetic (Div  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 30)
    
    | AilEbinary e1 (Arithmetic (Mod  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 31)
    
    | AilEbinary e1 (Arithmetic (Band as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 32)
    
    | AilEbinary e1 (Arithmetic (Bxor  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 33)
    
    | AilEbinary e1 (Arithmetic (Bor  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 34)
    
    | AilEbinary e1 (Arithmetic (Shl  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (integer_promote gty1))
        else E.fail loc (TError_TODO 35)
    
    | AilEbinary e1 (Arithmetic (Shr  as aop) as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_binary_arithmetic gty1 aop gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (integer_promote gty1))
        else E.fail loc (TError_TODO 36)
    
    | AilEbinary e1 (Arithmetic Add as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        (* NOTE: this is also relates to §6.5.2.1#1 *)
        (* STD §6.5.6#2 *)
        if is_pointer_to_complete_object sigm gty1 && is_integer gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty1)
        else if is_pointer_to_complete_object sigm gty2 && is_integer gty1 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty2)
        else if well_typed_binary_arithmetic gty1 Add gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError "§6.5.2.1#1")
    
    | AilEbinary e1 (Arithmetic Sub as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_compatible_complete_objects sigm gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger PtrdiffT)))
        else if is_pointer_to_complete_object sigm gty1 && is_integer gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType gty1)
        else if well_typed_binary_arithmetic gty1 Sub gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (usual_arithmetic gty1 gty2))
        else
          E.fail loc (TError_TODO 38)
    
    | AilEbinary e1 (And as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if is_scalar gty1 && is_scalar gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError_TODO 39)
    
    | AilEbinary e1 (Or  as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if is_scalar gty1 && is_scalar gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError_TODO 40)
    
    | AilEbinary e1 (Lt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_compatible_objects gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError_TODO 41)
    
    | AilEbinary e1 (Gt as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_compatible_objects gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else E.fail loc (TError_TODO 42)
    
    | AilEbinary e1 (Le as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_compatible_objects gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError_TODO 43)
    
    | AilEbinary e1 (Ge as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if are_pointers_to_compatible_objects gty1 gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else if is_real gty1 && is_real gty2 then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError_TODO 44)
    
    | AilEbinary e1 (Eq as bop) e2 ->
        (* STD §6.5.9#2 *)
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_equality gty1 gty2 (is_null_pointer_constant e1') (is_null_pointer_constant e2') then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError "§6.5.9#2")
    
    | AilEbinary e1 (Ne as bop) e2 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        if well_typed_equality gty1 gty2 (is_null_pointer_constant e1') (is_null_pointer_constant e2') then
          E.return (AilEbinary e1' bop e2', GenRValueType (GenBasic (GenInteger (Concrete (Signed Int_)))))
        else
          E.fail loc (TError_TODO 46)
    
    | AilEsizeof qs ty ->
        wf_lvalue sigm qs ty >>
        (* STD §6.5.3.4#1 *)
        E.add "§6.5.3.4#1" >>
        if AAux.is_function ty || AAux.is_incomplete sigm ty then
          E.fail loc (TError "§6.5.3.4#1, sentence 1")
        else
          (* STD §6.5.3.4#6 *)
          E.return (AilEsizeof qs ty, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEsizeof_expr e ->
        (* STD §6.5.3.4#1 *)
        let () = Debug.warn [Debug.DB_ail_typing]
          (fun () -> "(TODO) GenTyping.annotate_expression AilEsizeof_expr, not checking for bit-field member") in
        (* because we are dealing with the operand of sizeof(), we do not call
           any of the conversion/decay functions (see §6.3.2.1#2-4) *)
        annotate_expression CTXsizeof e >>= fun a_e ->
        let gty = match GenTypes.genTypeCategoryOf a_e with
          | GenRValueType gty ->
              gty
          | GenLValueType _ ty _ ->
              inject_type ty
        end in
        if GAux.is_function gty || GAux.is_incomplete sigm gty then
          E.fail loc (TError "§6.5.3.4#1, sentence 1")
        else
          (* STD §6.5.3.4#6 *)
          E.return (AilEsizeof_expr a_e, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEalignof qs ty ->
        wf_lvalue sigm qs ty >>
        (* STD §6.5.3.4#1 *)
        if AAux.is_function ty || AAux.is_incomplete sigm ty then
          E.fail loc (TError "§6.5.3.4#1, sentence 2")
        else
          (* STD §6.5.3.4#6 *)
          E.return (AilEalignof qs ty, GenRValueType (GenBasic (GenInteger SizeT)))
    
    | AilEcast qs Void e ->
        wf_lvalue sigm qs Void >>
        annotate_rvalue e >>= fun (e', _) ->
        E.return (AilEcast qs Void e', GenRValueType GenVoid)
    
      (* STD §6.5.4#2 *)
    | AilEcast qs ty e ->
        wf_lvalue sigm qs ty >>
        annotate_rvalue e >>= fun (e', gty) ->
        if not (is_scalar gty && AAux.is_scalar ty) then
          E.fail loc (TError "§6.5.4#2")
        else if    is_pointer gty && AAux.is_floating ty
           || is_floating gty && AAux.is_pointer ty then
          E.fail loc (TError "§6.5.4#4")
        else
          E.return (AilEcast qs ty e', GenRValueType (inject_type ty))
    
    | AilEcond e1 e2 e3 ->
        annotate_rvalue e1 >>= fun (e1', gty1) ->
        annotate_rvalue e2 >>= fun (e2', gty2) ->
        annotate_rvalue e3 >>= fun (e3', gty3) ->
        well_typed_conditional (loc, locOf e1, locOf e2, locOf e3)
            gty1 gty2 gty3 (is_null_pointer_constant e2') (is_null_pointer_constant e3') >>= fun genCat ->
        E.return (AilEcond e1' e2' e3', genCat)
    
    | AilEcompoundAssign e1 (Add as aop) e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ -> 
              AAux.lvalue_coercion sigm ty >>= fun ty1 ->
                if    AAux.modifiable sigm qs ty
                   && (AAux.is_arithmetic ty1 && is_arithmetic gty2 || AAux.is_pointer_to_complete_object sigm ty && is_integer gty2) then
                  E.return (AilEcompoundAssign e1' aop e2', GenRValueType (inject_type ty1))
                else
                  E.fail loc (TError_TODO 52)
          | _ ->
              E.fail loc (TError_TODO 53)
        end
    
    | AilEcompoundAssign e1 (Sub as aop) e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ -> 
              AAux.lvalue_coercion sigm ty >>= fun ty1 ->
                if    AAux.modifiable sigm qs ty
                   && (AAux.is_arithmetic ty1 && is_arithmetic gty2 || AAux.is_pointer_to_complete_object sigm ty && is_integer gty2) then
                  E.return (AilEcompoundAssign e1' aop e2', GenRValueType (inject_type ty1))
                else
                  E.fail loc (TError_TODO 54)
          | _ ->
              E.fail loc (TError_TODO 55)
        end
    
    | AilEcompoundAssign e1 aop e2 ->
        annotate_expression CTXassign e1 >>= fun e1'         ->
        annotate_rvalue e2     >>= fun (e2', gty2) ->
        match GenTypes.genTypeCategoryOf e1' with
          | GenLValueType qs ty _ ->
              inject_type <$> AAux.lvalue_coercion sigm ty >>= fun gty1 ->
              if AAux.modifiable sigm qs ty && well_typed_binary_arithmetic gty1 aop gty2 then
                E.return (AilEcompoundAssign e1' aop e2', GenRValueType gty1)
              else
                E.fail loc (TError_TODO 56)
          | _ ->
              E.fail loc (TError_TODO 57)
        end
    
    | AilEconst cst ->
        (* STD §6.5.1#3 *)
        E.add "§6.5.1#3" >>
        annotate_constant cst >>= fun (cst', gty) ->
        E.return (AilEconst cst', gty)
    
    (* TODO: check *)
    | AilEstr lit ->
        (* STD §6.5.1#4 *)
        E.add "§6.5.1#4" >>
        annotate_stringLiteral lit
    
    (* TODO: maybe look at the type of inside? *)
    | AilEannot ty e ->
        annotate_expression ctx e >>= function
          | AnnotatedExpression (GenLValueType qs _ isRegister) _ _ e' ->
              E.return (e', GenLValueType qs ty isRegister)
          | AnnotatedExpression (GenRValueType _) annots loc e' ->
              E.return (e', GenRValueType (inject_type ty))
        end
    
    | AilEva_start e sym ->
        annotate_rvalue e >>= function
          | (e', GenBuiltin "va_list") ->
              E.return (AilEva_start e' sym, GenRValueType GenVoid)
          | _ ->
              E.fail loc (TError "va_start")
        end
    
    | AilEva_arg e ty ->
        annotate_rvalue e >>= function
          | (e', GenBuiltin "va_list") ->
              E.return (AilEva_arg e' ty, GenRValueType (inject_type ty))
          | _ ->
              E.fail loc (TError "va_arg")
        end
    
    | AilEprint_type e ->
        annotate_expression ctx e >>= fun a_e ->
        E.return (AilEprint_type a_e, genTypeCategoryOf a_e)
    
    | AilErvalue _ ->
        (* This should be impossible because the desugaring doesn't emit
           any AilErvalue *)
        E.fail loc (TError "ail typing found a AilErvalue")
    | AilEarray_decay _ ->
        (* This should be impossible because the Desugaring doesn't emit
           any AilEarray_decay *)
        E.fail loc (TError "ail typing found a AilEarray_decay")
    | AilEfunction_decay _ ->
        (* This should be impossible because the Desugaring doesn't emit
           any AilEfunction_decay *)
        E.fail loc (TError "ail typing found a AilEfunction_decay")
  end
  >>= fun (expr_', gtc) ->
  E.unpack >>= fun annots ->
  perform_decays sigm ctx (AnnotatedExpression gtc annots loc expr_')


and annotate_generic_association sigm gamm = function
  | AilGAtype ty e ->
      wf_type sigm ty >>
      if AAux.is_complete sigm ty && AAux.is_object ty && not (AAux.variably_modified ty) then
        AilGAtype ty <$> annotate_expression sigm gamm CTXother e
      else
        E.fail Loc.unknown (TError "§6.5.1.1#2, sentence 2")
  | AilGAdefault e ->
      AilGAdefault <$> annotate_expression sigm gamm CTXother e
end








(*
(* Must NOT BE CALLED for:
     - the operand of the AilEsizeof_expr
     - the operand of the AilEunary Address
     - the operand of the AilEunary PostIncr
     - the operand of the AilEunary PostDecr
     - the left operand of AilEmemberof
     - the left operand of AilEassign and AilEcompoundAssign *)
(* STD §6.3.2.1#2 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and nonarray_lvalue_conversion sigm a_expr =
  match genTypeCategoryOf a_expr with
    | GenLValueType qs ty isRegister ->
        if not (AAux.is_array ty) then
          let rvalue_ty = AAux.unatomic (AAux.unqualify ty) in
          if AAux.is_incomplete sigm ty then
            error "TODO: nonarray_lvalue_conversion ==> undefined behaviour"
          else
            E.return (
              AnnotatedExpression (GenRValueType (inject_type rvalue_ty))
                (Loc.locOf a_expr) (AilErvalue a_expr)
            )
        else
          E.return a_expr
    | GenRValueType gty ->
        error "WIP: nonarray_lvalue_conversion, GenRValueType"
  end

(* Must NOT BE CALLED for:
     - the operand of AilEsizeof_expr
     - the operand of AilEunary Address
     - a AilEstr used to initialize an array *)
(* STD §6.3.2.1#3 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and array_decay sigm a_expr =
  (* TODO: DEAD CODE *)
  match genTypeCategoryOf a_expr with
    | GenLValueType qs ty isRegister ->
        if AAux.is_array ty then
          if isRegister then
            error "TODO: array_decay ==> undefined behaviour"
          else
            (* TODO: qualifiers?? *)
            let () = begin
              if not (AAux.is_unqualified qs) then
                Debug.warn [Debug.DB_ail_typing] (fun () -> "(UNSURE) GenTyping.array_decay, qs <> {}")
              else
              ()
            end in
            E.return (
              AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                (Loc.locOf a_expr) (AilEarray_decay a_expr)
            )
        else
          E.return a_expr
    | GenRValueType gty ->
        error "WIP: array_decay, GenRValueType"
  end

(* Must NOT BE CALLED for:
     - the operand of AilEsizeof_expr
     - the operand of AilEunary Address *)
(* STD §6.3.2.1#4 *)
(* TYPE: sigma unit -> expression genTypeCategory -> E.errorM (expression genTypeCategory) *)
and function_decay sigm a_expr =
  (* TODO: DEAD CODE *)
  error "WIP: function_decay"
*)

and perform_decays sigm ctx a_expr =
  let is_literal = match a_expr with
    | AnnotatedExpression _ _ _ (AilEarray true _ _) ->
        true
    | AnnotatedExpression _ _ _ (AilEstr _) -> (* TODO: this is probably dead now *)
        true
    | _ ->
        false
  end in
  match annotations a_expr with
    | (std_annots, GenLValueType qs ty isRegister) ->
        let () = Debug.print_debug 1 [] (fun () ->
          "GenLValueType ==>" ^ Pp.stringFromAil_ctype qs ty
        ) in
        if    not (AAux.is_array ty)
           && not (List.elem ctx [CTXsizeof; CTXaddr; CTXincr; CTXdecr; CTXmemberof; CTXassign]) then
          (* STD §6.3.2.1#2 *)
          (* performing the lvalue conversion *)
          let rvalue_ty = AAux.unatomic ty in
          if AAux.is_incomplete sigm ty then
            (* STD §6.3.2.1#2, sentence 3 *)
            E.fail Loc.unknown (TError_undef Undefined.UB020_nonarray_incomplete_lvalue_conversion)
          else
            E.return (
              AnnotatedExpression (GenRValueType (inject_type rvalue_ty))
                std_annots (Loc.locOf a_expr) (AilErvalue a_expr)
            )
        else if    AAux.is_array ty
                && not (List.elem ctx [CTXsizeof; CTXaddr])
                && not (List.elem ctx [CTXarray_init] && is_literal) then
          (* STD §6.3.2.1#3 *)
          (* performing the array decay *)
          if isRegister then
            E.fail Loc.unknown (TError_undef Undefined.UB022_register_array_decay)
          else
            (* TODO: qualifiers?? *)
            let () = begin
              if not (AAux.is_unqualified qs) then
                Debug.warn [Debug.DB_ail_typing] (fun () -> "(UNSURE) GenTyping.array_decay, qs <> {}")
              else
                ()
            end in
            E.return (
              AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                std_annots (Loc.locOf a_expr) (AilEarray_decay a_expr)
            )
        else
          E.return a_expr
    | (std_annots, GenRValueType gty) ->
        if not (List.elem ctx [CTXsizeof; CTXaddr]) then
          (* STD §6.3.2.1#4 *)
          (* performing the function decay *)
          E.return match gty with
            | GenFunction hasProto ty params isVariadic ->
                AnnotatedExpression
                  (GenRValueType (GenPointer no_qualifiers (Function hasProto ty params isVariadic)))
                  std_annots (Loc.locOf a_expr) (AilEfunction_decay a_expr)
            | GenArray elem_ty sz_opt ->
              match a_expr with
                | AnnotatedExpression _ _ _ (AilEarray false _ _) ->
                    (* NOTE: this case doesn't syntactically exist in C, since
                       array values don't exist *)
                    a_expr
                | _ ->
                    if not (List.elem ctx [CTXarray_init] && is_literal) then
                      let ty = Array elem_ty sz_opt in
                      (* STD §6.3.2.1#3 *)
                      (* performing the array decay *)
                      AnnotatedExpression (GenRValueType (inject_type (AAux.array_coercion ty)))
                        std_annots (Loc.locOf a_expr) (AilEarray_decay a_expr)
                    else
                      a_expr
              end
            | _ ->
                a_expr
          end
        else
          E.return a_expr
  end













and annotate_rvalue sigm gamm expr =
  annotate_expression sigm gamm CTXother expr >>= fun (AnnotatedExpression gtc std_annots loc expr_) ->
   E.return match gtc with
     | GenRValueType gty ->
         (AnnotatedExpression (GenRValueType gty) std_annots loc expr_, gty)
     | GenLValueType qs ty isRegister ->
         (AnnotatedExpression (GenLValueType qs ty isRegister) std_annots loc expr_, inject_type ty)
   end


and annotate_assignee sigm gamm ty1 e2 =
  annotate_rvalue sigm gamm e2 >>= fun (e2, gty2) ->
  well_typed_assignment sigm ty1 gty2 (is_null_pointer_constant e2) >>= function
    | true ->
        E.return e2
    | false ->
        let () = Debug.print_debug 2 [Debug.DB_ail_typing] (fun () ->
          "[well_typed_assignment] false ==> " ^
          Pp.stringFromAil_ctype no_qualifiers ty1 ^ " -- " ^ Pp.stringFromAil_genType gty2) in
        E.fail (locOf e2) (TError "§6.5.16.1#1")
  end


and annotate_arguments sigm gamm has_proto is_variadic args params =
  let annotate_expression = annotate_expression sigm gamm CTXother in
  let annotate_assignee   = annotate_assignee sigm gamm   in
  match (args, params) with
    | ([], []) ->
        E.return []
    | ([], [(_, Void, _)]) ->
        (* TODO: document this case *)
        E.return []
    | (arg_e :: args', (_, param_ty1, isRegister) :: params') ->

(*
        if has_proto then
*)
          annotate_assignee (AAux.rvalue_coercion param_ty1) arg_e          >>= fun a_arg_e ->
          annotate_arguments sigm gamm has_proto is_variadic args' params' >>= fun a_args' ->
          E.return (a_arg_e :: a_args')
(*
        else
          (* the called function has a type that does not include a prototype *)
          (* STD §6.5.2.2#6 *)
          let ty1' = KKKK
*)


    | (_, []) ->
        (* This case must correspond to a call to a variadic function *)
        if not is_variadic then
          E.fail Loc.unknown (TError_TODO 68)
        else
          (* following (§6.5.2.2#7) *)
          (* TODO: default argument promotion + checks (at least that there are no void-expression, though this might already be done by the promotion) *)
          E.mapM annotate_expression args
(*
          E.mapM annotate_expression args >>= fun a_args ->
          if List.any (fun z -> type_of annot z = Void) a_args then
            E.fail Loc.unknown (TError "called a variadic function with a void expression")
          else
            E.return a_args
*)
    | (_, _) ->
        E.fail Loc.unknown (TError_TODO 12)
  end












(*
(* returns both the annotated intializer and the infered type (used for arrays) *)
and annotate_initialization sigm gamm ty e =
  (* §6.7.9#3 *)
  E.guard (TError "failed §6.7.9#3")
    (   AAux.is_array_unknown_size ty
     || AAux.is_complete_object sigm ty && not (AAux.is_vla ty)) >>
  
  if AAux.is_scalar ty then
    (* STD §6.7.9#11, sentence 3 *)
    annotate_assignee sigm gamm (AAux.unqualify ty) e >>= fun a_e ->
    E.return (a_e, ty)
  
  (* TODO: "(...) that has automatic storage duration" *)
  (* STD §6.7.9#13 *)
  else if AAux.is_struct_or_union ty then
    (* TODO: check *)
    annotate_rvalue sigm gamm e >>= fun (a_e, gty) ->
    (* TODO: need to make sure that gty is compatible with ty *)
    E.return (a_e, ty)
  
  (* STD §6.7.9#14 *)
  else if AAux.is_array_of_character ty then
    error ("WIP: annotate_initialization, is_array_of_character ty ==> " ^ Pp.stringFromAil_ctype ty)
  
  (* STD §6.7.9#15 *)
  else if AAux.compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin "wchar_t"; char16_t; char32_t] then
    error "WIP: annotate_initialization, compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin \"wchar_t\"; char16_t; char32_t]"
  
  (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)
  (* TODO: at this point we should now have a non character array *)
  else if AAux.is_array ty then
    (* TODO: check the std. (not that it says anything useful here ...) *)
    annotate_expression sigm gamm e >>= fun a_e ->
    match (ty, GenTypes.genTypeCategoryOf a_e) with
      | (Array elem_qs1 elem_ty1 Nothing, GenRValueType (GenArray _ elem_ty2 (Just n2))) ->
          (* TODO: check, but I don't think we need to do anything regarding qualifiers here *)
          if AAux.compatible elem_ty1 elem_ty2 then
            E.return (a_e, Array elem_ty1 (Just n2))
          else
            error ("TODO(annotate_initialisation, 1): error message: array object definition, types didn't match ==> " ^
                   Pp.stringFromAil_ctype elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype elem_ty2)
     | (Array _ elem_ty1 (Just n1), GenRValueType (GenArray _ elem_ty2 (Just n2))) ->
          (* TODO: check, but I don't think we need to do anything regarding qualifiers here *)
         if AAux.compatible elem_ty1 elem_ty2 && n1 = n2 then
           E.return (a_e, Array elem_ty1 (Just n1))
         else
            error ("TODO(annotate_initialisation, 2): error message: array object definition, types didn't match ==> " ^
                   Pp.stringFromAil_ctype elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype elem_ty2)
     | _ ->
         error "WIP: annotate_initialization, not(is_scalar ty), not array (or had no size)"
    end
  else
    error "WIP: annotate_initialization, final case"

*)














and annotate_definition_aux sigm gamm (ty, e) =
  if    (AAux.is_array ty --> AAux.has_unknown_size ty)
     || (AAux.is_complete_object sigm ty --> not (AAux.is_vla ty)) then
    if AAux.is_scalar ty then
      (* STD §6.7.9#11, sentence 3 *)
      (* NOTE: since we are not passing a `qs' with `ty' to annotate_assignee,
         we are indeed unqualifying the scalar type *)
      annotate_assignee sigm gamm ty e
      
      (* TODO: "(...) that has automatic storage duration" *)
      (* STD §6.7.9#13 *)
      else if AAux.is_struct_or_union ty then
        (* TODO: check *)
        annotate_rvalue sigm gamm e >>= fun (a_e, gty) ->
        (* TODO: need to make sure that gty is compatible with ty *)
        E.return a_e
      
      (* STD §6.7.9#15 *)
      else if AAux.compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin "wchar_t"; char16_t; char32_t] then
        error "WIP: annotate_definition_aux, compatibleWithQualifiedUnqualifiedVersionOf ty [Builtin \"wchar_t\"; char16_t; char32_t]"
      
          (* STD §6.7.9#16 *)
(*          else if  then *) (* KKK *)

      (* TODO: at this point we should now have a non character array *)
      else if AAux.is_array ty then
        (* TODO: check the std. (not that it says anything useful here ...) *)
        let ctx =
          if AAux.is_array_of_character ty then
            CTXarray_init
          else
            CTXother in
        annotate_expression sigm gamm ctx e >>= fun a_e ->
          let () = Debug.warn [Debug.DB_ail_typing]
            (fun () -> "(UNSURE) for the definition of arrays the compatilibity of types is checked for they unqualified versions and ignoring the elem_qs") in
        match (ty, GenTypes.genTypeCategoryOf a_e) with
          | (Array elem_ty1 Nothing, GenRValueType (GenArray elem_ty2 (Just n))) ->
              if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) then
                E.return a_e (* (e', GenArray elem_ty1 (Just n)) *)
              else
                error ("TODO(annotate_definition_aux, 1): error message: array object definition, types didn't match ==> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty2)
         | (Array elem_ty1 (Just n1), GenRValueType (GenArray elem_ty2 (Just n2))) ->
              if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) && n1 = n2 then
                E.return a_e (* (e', GenArray elem_ty1 (Just n1)) *)
              else
                error ("TODO(annotate_definition_aux, 2): error message: array object definition, types didn't match ==> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ " <-> " ^ Pp.stringFromAil_ctype no_qualifiers elem_ty2)

         | (Array elem_ty1 (Just n1), GenLValueType qs2 (Array elem_ty2 (Just n2)) _) ->
             (* TODO: isRegister? *)
             (* TODO: what if n1 < n2? *)
             (* TODO: check std *)
             if AAux.are_compatible (no_qualifiers, elem_ty1) (no_qualifiers, elem_ty2) && n1 >= n2 then
               E.return a_e
             else
                error ("TODO(annotate_definition_aux, 3): error message: array object definition, types didn't match ==> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty1 ^ "[" ^ show n1 ^ "] <-> " ^
                       Pp.stringFromAil_ctype no_qualifiers elem_ty2 ^ "[" ^ show n2 ^ "]")
         | _ ->
             (* STD §6.7.9#14 *)
             if AAux.is_array_of_character ty then
               error ("WIP: annotate_definition_aux, is_array_of_character ty ==> " ^
                      Pp.stringFromAil_ctype no_qualifiers ty ^ " <===> " ^ Pp.stringFromAil_expression a_e)
             else
               error "WIP: annotate_definition, not(is_scalar ty), not array (or had no size)"
        end
      else
        error "WIP: annotate_definition_aux, final case"
  else
    (* STD §6.7.9#3 *)
    E.fail Loc.unknown (TError "§6.7.9#3")

val annotate_definition: sigma unit -> gamma -> (Symbol.sym * expression unit) -> E.errorM (Symbol.sym * expression genTypeCategory)
let annotate_definition sigm gamm (sym, e) =
  match Context.lookup identifierEqual gamm sym with
    | Just (_, sym_qs, sym_ty) ->
        annotate_definition_aux sigm gamm (sym_ty, e) >>= fun a_e ->
        E.return (sym, a_e)
    
    | Nothing ->
        E.fail Loc.unknown (TError_TODO 58) (* TODO: I think this error shouldn't be possible
                                  coming from Cabs_to_ail *)
  end


val annotate_definitions:
  sigma unit -> gamma -> list (Symbol.sym * expression unit) -> E.errorM (list (Symbol.sym * expression genTypeCategory))
let rec annotate_definitions sigm gamm = function
  | [] ->
      E.return []
  | d :: ds ->
      annotate_definition  sigm gamm d  >>= fun d  ->
      annotate_definitions sigm gamm ds >>= fun ds ->
      E.return (d :: ds)
end


val     annotate_statement_: sigma unit -> gamma -> ctype -> statement_ unit -> E.errorM (statement_ genTypeCategory)
let rec annotate_statement_ sigm gamm ty stmt =
  let annotate_expression = annotate_expression sigm gamm CTXother   in
  let annotate_rvalue     = annotate_rvalue sigm gamm       in
  let annotate_block bindings =
    (* WIP *)
    E.mapM (annotate_statement sigm (Context.add_bindings bindings gamm) ty) in
  let annotate_statement  = annotate_statement sigm gamm ty in
  
  match stmt with
    | AilSskip ->
        E.return AilSskip
    | AilSexpr e ->
        annotate_expression e >>= fun e' ->
        E.return (AilSexpr e')
    | AilSblock bindings ss ->
        AilTyping.well_formed_bindings sigm bindings >>
        E.guard (TError "sigma_fresh bindings failed in a AilSblock") (
          sigma_fresh_bindings bindings sigm
        ) >>
        annotate_block bindings ss >>= fun ss' ->
        E.return (AilSblock bindings ss')
    | AilSif e s1 s2 ->
        annotate_rvalue e >>= fun (e', gty) ->
        (* STD §6.8.4.1#1 *)
        E.add "§6.8.4.1#1" >>
        if is_scalar gty then
          annotate_statement s1 >>= fun s1' ->
          annotate_statement s2 >>= fun s2' ->
          E.return (AilSif e' s1' s2')
        else
          E.fail Loc.unknown (TError_TODO 60)
    | AilSwhile e s ->
        annotate_rvalue e >>= fun (e', gty) ->
        (* STD §6.8.5#2 *)
        if is_scalar gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSwhile e' s')
        else
          E.fail Loc.unknown (TError_TODO 62)
    | AilSdo s e ->
        annotate_rvalue e >>= fun (e', gty) ->
        (* STD §6.8.5#2 *)
        if is_scalar gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSdo s' e')
        else
          E.fail Loc.unknown (TError_TODO 63)
    | AilSbreak ->
        E.return AilSbreak
    | AilScontinue ->
        E.return AilScontinue
    | AilSreturnVoid ->
        if ty = Void then
          E.return AilSreturnVoid
        else
          E.fail Loc.unknown (TError_TODO 64)
    | AilSreturn e ->
        annotate_assignee sigm gamm ty e >>= fun e' ->
        E.return (AilSreturn e')
    | AilSswitch e s ->
        annotate_rvalue e >>= fun (e', gty) ->
        (* STD §6.8.4.2#1 *)
        if is_integer gty then
          annotate_statement s >>= fun s' ->
          E.return (AilSswitch e' s')
        else
          E.fail Loc.unknown (TError_TODO 61)
    | AilScase ic s ->
        annotate_statement s >>= fun s' ->
        E.return (AilScase ic s')
    | AilSdefault s ->
        annotate_statement s >>= fun s' ->
        E.return (AilSdefault s')
    | AilSlabel sym s ->
        annotate_statement s >>= fun s' ->
        E.return (AilSlabel sym s')
    | AilSgoto sym ->
        E.return (AilSgoto sym)
    | AilSdeclaration sym_es ->
        annotate_definitions sigm gamm sym_es >>= fun sym_es' ->
        E.return (AilSdeclaration sym_es')
    | AilSpar ss ->
        E.mapM annotate_statement ss >>= fun ss' ->
        E.return (AilSpar ss')
  end

and annotate_statement sigm gamm ty (AnnotatedStatement loc stmt) =
  annotate_statement_ sigm gamm ty stmt >>= fun stmt' ->
  E.return (AnnotatedStatement loc stmt')


val annotate_block:
      sigma unit -> gamma -> ctype -> list (statement unit) -> E.errorM (list (statement genTypeCategory))
let annotate_block sigm gamm ty stmts =
  E.mapM (annotate_statement sigm gamm ty) stmts





(*
let annotate_function_declaration a s p =
  let ty_return   = p.fun_return_ty   in
  let bs          = p.fun_bindings    in
  let is_variadic = p.fun_is_variadic in
  let s_opt       = p.fun_body        in
  if sigma_fresh_bindings bs s &&
     (* AilTyping.well_formed_bindings bs && *)
     wf_type (Function ty_return (parameters_of_bindings bs) is_variadic)
  then
    match s_opt with
      | Just s ->  annotate_statement a s (Context.add_bindings bs Context.empty) ty_return s >>= fun s' ->
                   (* TODO: using the "with" construct of lem doesn't typecheck like we need here, is this
                            a necessary restriction of the type system ? *)
                   E.return <| fun_return_ty=   ty_return;
                               fun_bindings=    bs;
                               fun_is_variadic= is_variadic;
                               fun_is_inline=   p.fun_is_inline;
                               fun_is_Noreturn= p.fun_is_Noreturn;
                               fun_body=        Just s' |>
      | Nothing -> E.return <| fun_return_ty=   ty_return;
                               fun_bindings=    bs;
                               fun_is_variadic= is_variadic;
                               fun_is_inline=   p.fun_is_inline;
                               fun_is_Noreturn= p.fun_is_Noreturn;
                               fun_body=        Nothing |>
    end
  else
    E.fail Loc.unknown (TError_TODO 65)
*)


(*
(* TODO: check with J *)
let annotate_global a s (qs, ty, e_opt) =
  if wf_type ty then
    match e_opt with
      | Just e  -> annotate_assignee a s Context.empty ty e >>= fun e ->
                   E.return (qs, ty, Just e)
      | Nothing -> E.return (qs, ty, Nothing)
    end
  else
    E.fail Loc.unknown (TError_TODO 66)
*)


(*
let annotate_sigma a s =
  sigma_mapP (function
    | SDecl_fun id fdecl ->
        annotate_function_declaration a s fdecl >>= fun fdecl' ->
        E.return (SDecl_fun id fdecl')
    | SDecl_global id glob ->
        annotate_global a s glob >>= fun glob'->
        E.return (SDecl_global id glob')
    | SDecl_static_assert _ _ ->
        error "TODO_"
(*
TODO
        annotate_assignee a s Context.empty ty e >>= fun e' ->
        annotate_stringConstant sc               >>= fun sc' ->
        E.return (SDecl_static_assert e' sc')
*)
  end) s
*)




val annotate_sigma: sigma unit -> E.errorM (sigma genTypeCategory)
let annotate_sigma sigm =
  (* TODO: morally we want a "mapP_" here *)
  (* Checking that declarations are well-formed *)
  Context.mapP identifierEqual (fun _ -> function
    | (_, (Decl_object dur_opt qs ty as decl)) ->
        wf_lvalue sigm qs ty >>
        E.return decl
    | (_, (Decl_function hasProto ret_ty params isVariadic _ (* isInline *) _ (* isNoreturn *) as decl)) ->
        (* TODO?   ==> AilTyping.well_formed_bindings bs && *)
        wf_type sigm (Function hasProto ret_ty params isVariadic) >>
        E.return decl
    end
  ) sigm.declarations >>
  
  (* Typechecking of external objects that have a definition *)
  Context.mapP identifierEqual (fun ident e ->
    match Context.lookup identifierEqual sigm.declarations ident with
      | Just (_, Decl_object _ _ (* qs *) ty) ->
          (* TODO: qualifiers?; storage duration? *)
          annotate_definition_aux sigm Context.empty (ty, e)
      | _ ->
          E.fail Loc.unknown (TError_TODO 1000)
    end
  ) sigm.object_definitions >>= fun object_defs' ->
  
  (* Typechecking of functions that have a definition *)
  Context.mapP identifierEqual (fun ident (loc, param_idents, s) ->
    match Context.lookup identifierEqual sigm.declarations ident with
      | Just (_, Decl_function hasProto (ret_qs, ret_ty) params _ (* isVariadic *) _ (* isInline *) _ (* isNoreturn *)) ->
          (* TODO: qualifiers *)
          let () = Debug.warn [] (fun () ->
            "(unsure) annotate_sigma doesn't look at [ret_qs]"
           ) in
          let bindings = List.map (fun (ident, (qs, ty, isRegister)) ->
            (* STD §6.9.1#9, first sentence *)
            (ident, ((Automatic, isRegister), qs, ty))
          ) (List.zip param_idents params) in
          if sigma_fresh_bindings bindings sigm then
            annotate_statement sigm (Context.add_bindings bindings Context.empty) ret_ty s >>= fun s' ->
              E.return (loc, param_idents, s')
          else
            E.fail loc (TError_TODO 1001)
      | _ ->
          E.fail loc (TError_TODO 1002)
    end
  ) sigm.function_definitions >>= fun function_defs' ->
  
(*
TODO: static asserts
  E.mapM (fun (e, strConst) ->
  ) 
*)
  E.mapM (function
    | (_, StructDef xs) ->
        (* STD §6.7.2.1#3 *)
        match List.dest_init xs with
          | Nothing ->
              (* NOTE: this should be dead code because of the C syntax *)
              error "GenTyping.annotate_sigma, StructDef, empty sdecls_opt"
          | Just ([], (_, (_, ty))) ->
              if AilTypesAux.is_incomplete sigm ty || AilTypesAux.is_function ty then
                E.fail Loc.unknown (TError "§6.7.2.1#3, 1st sentence")
              else if AilTypesAux.has_flexible_array_member sigm ty then
                E.fail Loc.unknown (TError "§6.7.2.1#3, 2nd sentence")
              else
                E.return ()
          | Just (xs', (_, (_, last_ty))) ->
              E.mapM_ (fun (_, (_, ty)) ->
                if AilTypesAux.has_flexible_array_member sigm ty then
                  E.fail Loc.unknown (TError "§6.7.2.1#3, 2nd sentence")
                else if AilTypesAux.is_incomplete sigm ty || AilTypesAux.is_function ty then
                  E.fail Loc.unknown (TError "§6.7.2.1#3, 1st sentence")
                else
                  E.return ()
              ) xs' >>
              if AilTypesAux.has_flexible_array_member sigm last_ty then
                E.fail Loc.unknown (TError "§6.7.2.1#3, 2nd sentence")
              (* This allows flexible array members *)
              else if    (AilTypesAux.is_incomplete sigm last_ty && not (AilTypesAux.is_array_unknown_size last_ty))
                      || AilTypesAux.is_function last_ty then
                E.fail Loc.unknown (TError "§6.7.2.1#3, 1st sentence")
              else
                E.return ()
        end >>
        E.mapM_ (fun (_, (qs, ty)) ->
          (* TODO: check that it is ok to use wf_lvalue (instead of just wf_type) *)
          wf_lvalue sigm qs ty
        ) xs
    | (_, UnionDef xs) ->
        (* STD §6.7.2.1#3 *)
        let pred (_, (_, ty)) =
          AilTypesAux.is_incomplete sigm ty || AilTypesAux.is_function ty in
        if List.any pred xs then
          E.fail Loc.unknown (TError "§6.7.2.1#3, 1st sentence")
        
        else if List.any (fun (_, (_, ty)) -> AilTypesAux.has_flexible_array_member sigm ty) xs then
          E.fail Loc.unknown (TError "§6.7.2.1#3, 2nd sentence")
        else
          E.return ()
        >>
        E.mapM_ (fun (_, (qs, ty)) ->
          (* TODO: check that it is ok to use wf_lvalue (instead of just wf_type) *)
          wf_lvalue sigm qs ty
        ) xs
  end) sigm.tag_definitions >>
  
  E.return <|
    declarations=         sigm.declarations;
    object_definitions=   object_defs';
    function_definitions= function_defs';
    (* TODO: hack *)
    static_assertions= [];
    tag_definitions= sigm.tag_definitions
  |>




(* NOTE: this is the only thing this module exports *)
val annotate_program: ail_program unit -> E.errorM (ail_program genTypeCategory)
let annotate_program (startup_opt, sigm) =
  match startup_opt with
    | Nothing ->
        annotate_sigma sigm >>= fun sigm' ->
        E.return (startup_opt, sigm')
    | Just startup ->
        match Context.lookup identifierEqual sigm.declarations startup with
          | Just (_, Decl_function hasProto (ret_qs, ret_ty) params (* bs *) _ (* isVariadic *) _ (* isInline *) _ (* isNoreturn *)) ->
              
              (* §5.1.2.2.1 *)
              (* TODO: "... or equivalent;10) or in some other implementation-defined manner." *)
              match params with
                | [] ->
                    (* TODO: not sure if really allowed by the std, clearly used a lot *)
                    E.return ()
                | [(<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Void, _)] ->
                    E.return ()
                | [(<| const= false; restrict= false; volatile= false(*; atomic= false*) |>, Basic (Integer (Signed Int_)), _);
                   (<| const= false; restrict= false; volatile= false(*; atomic= false*) |>,
                    Pointer <| const= false; restrict= false; volatile= false(*; atomic= false*) |>
                      (Pointer <| const= false; restrict= false; volatile= false(*; atomic= false*) |> (Basic (Integer Char))), _)] ->
                    E.return ()
                | _ ->
                    E.fail Loc.unknown (TError_main_params params)
              end >>
              
              
              (* TODO: check arguments *)
              if ret_qs = no_qualifiers && ret_ty = Basic (Integer (Signed Int_)) then
                annotate_sigma sigm >>= fun sigm' ->
                E.return (startup_opt, sigm')
              else
                E.fail Loc.unknown TError_main_return_type
          | _ ->
              let () = Debug.print_debug 1 [] (fun () ->
                "STARTUP ==> " ^ show startup
              ) in
              (* TODO: this is not realy a type error, but more an csem internal one. *)
              E.fail Loc.unknown (TError_TODO 67)
        end
  end
