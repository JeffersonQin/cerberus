open import Pervasives Common AilTypes Context
open import Loc
import Symbol ErrorMonad (* Cmm_csem *)

(* module Cmm = Cmm_csem *)


(* == Ail syntax datatypes ================================================== *)
type identifier = Symbol.sym

type integerSuffix = 
 | U
 | UL
 | ULL
 | L
 | LL

type basis =
  | Octal
  | Decimal
  | Hexadecimal

type integerConstant (*[name = "ic*"]*) =
  | IConstant of integer * basis * maybe integerSuffix
  | IConstantMax of integerType
  | IConstantMin of integerType

type floatingConstant = string

type characterPrefix =
  | Pref_L
  | Pref_u
  | Pref_U

type characterConstant = maybe characterPrefix * string

type encodingPrefix =
  | Enc_u8
  | Enc_u
  | Enc_U
  | Enc_L

type stringLiteral = maybe encodingPrefix * list string

type arithmeticOperator [name = "aop.*"] =
 (* STD §6.5.5 Multiplicative operators *)
 | Mul | Div | Mod
 (* STD §6.5.6 Additive operators *)
 | Add | Sub
 (* STD §6.5.7 Bitwise shift operators *)
 | Shl | Shr
 (* STD §6.5.10 Bitwise AND operator *)
 | Band
 (* STD §6.5.11 Bitwise exclusive OR operator *)
 | Bxor
 (* STD §6.5.12 Bitwise inclusive OR operator *)
 | Bor

type constant [name = "c*"] = 
 | ConstantIndeterminate of ctype
 | ConstantNull (* TODO: maybe temporary *)
 | ConstantInteger       of integerConstant
 | ConstantFloating      of floatingConstant
 | ConstantCharacter     of characterConstant
 | ConstantArray         of list constant
 | ConstantStruct        of identifier * list (Cabs.cabs_identifier * constant)
 | ConstantUnion         of identifier * Cabs.cabs_identifier * constant

(* 
 (* TODO: this is a kind of integer constant, may need to update some predicates *)
 | ConstantMemoryOrder of Cmm.memory_order
*)

type unaryOperator = 
 | Plus
 | Minus
 | Bnot
 | Address
 | Indirection
 | PostfixIncr (*r Note: Appears prefix in concrete syntax. *)
 | PostfixDecr (*r Note: Appears prefix in concrete syntax. *)

type binaryOperator [name = "bop*"] =  (*r Group of operators also used for assigments *)
 | Arithmetic of arithmeticOperator (*r 6.5.17 Comma operator *)
 | Comma (*r 6.5.13 Logical AND operator *)
 | And (*r 6.5.14 Logical OR operator *)
 | Or (*r 6.5.8 Relational operators *)
 | Lt
 | Gt
 | Le
 | Ge (*r 6.5.9 Equality operators *)
 | Eq
 | Ne

type expression_ 'a [name = "e*"] = 
  | AilEunary of unaryOperator * expression 'a
  | AilEbinary of expression 'a * binaryOperator * expression 'a
  | AilEassign of expression 'a * expression 'a
  | AilEcompoundAssign of expression 'a * arithmeticOperator * expression 'a
  | AilEcond of expression 'a * expression 'a * expression 'a
  | AilEcast of qualifiers * ctype * expression 'a
  | AilEcall of expression 'a * list (expression 'a)
  | AilEassert of expression 'a
  | AilEoffsetof of ctype * Cabs.cabs_identifier
  | AilEgeneric of expression 'a * list (generic_association 'a)
  
  (* TODO: hackish? *)
  (* TODO: these two don't exist in C (apart from in decl) *)
  | AilEarray of ctype * list (maybe (expression 'a))
  | AilEstruct of identifier * list (Cabs.cabs_identifier * maybe (expression 'a)) (* tag, pairs of member id, expression *)
  | AilEunion of identifier * Cabs.cabs_identifier * maybe (expression 'a)
  
  (* NOTE: the expression obviously need to match the type, and will typically be
           a AilEarray or AilEstruct *)
  | AilEcompound of ctype * expression 'a
  
  
  | AilEmemberof of expression 'a * Cabs.cabs_identifier
  | AilEmemberofptr of expression 'a * Cabs.cabs_identifier
  
  | AilEbuiltin of string (* TODO: see if that can be moved to [constant] *)
  
  | AilEstr of stringLiteral
  | AilEconst of constant
  | AilEident of identifier
  | AilEsizeof of qualifiers * ctype
  | AilEsizeof_expr of expression 'a
  | AilEalignof of qualifiers * ctype
  
  (* NOTE: type annotation on expression, used to remember the type of desugared
           enumeration constants *)
  | AilEannot of ctype * (expression 'a)
  | AilEva_start of expression 'a * identifier
  | AilEva_arg of expression 'a * ctype
  
  
    (* §6.3.2.1#2, the result of a non-array lvalue conversion *)
  | AilErvalue of expression 'a (* NOTE: never generated by the desugaring *)
    (* §6.3.2.1#3 *)
  | AilEarray_decay of expression 'a (* NOTE: never generated by the desugaring *)
  

and generic_association 'a =
  | AilGAtype of ctype * expression 'a
  | AilGAdefault of expression 'a

and expression 'a [name = "e*"] =
  | AnnotatedExpression of 'a * Loc.t * expression_ 'a

instance forall 'a. (Located (expression 'a))
  let locOf a_expr =
    let (AnnotatedExpression _ loc _) = a_expr in
    loc
end


(* the storage duration must be Nothing iff the identifier is that of a function,
   the boolean tells whether the object was declared with the register storage-class *)
type bindings (*[name="b*"]*) = list (identifier * (maybe (storageDuration * bool) * qualifiers * ctype))

type statement_ 'a [name="s*"] = 
  | AilSskip
  | AilSexpr of expression 'a
  | AilSblock of bindings * list (statement 'a)
  | AilSif of expression 'a * statement 'a * statement 'a
  | AilSwhile of expression 'a * statement 'a
  | AilSdo of statement 'a * expression 'a
  | AilSbreak
  | AilScontinue
  | AilSreturnVoid
  | AilSreturn of expression 'a
  | AilSswitch of expression 'a * statement 'a
  | AilScase of integerConstant * statement 'a
  | AilSdefault of statement 'a
  | AilSlabel of identifier * statement 'a
  | AilSgoto of identifier
  | AilSdeclaration of list (identifier * expression 'a)
  | AilSpar of list (statement 'a) (* NON-STD cppmem threads *)
and statement 'a [name="s*"] =
  | AnnotatedStatement of Loc.t * statement_ 'a


type declaration =
    (* the storage duration is Nothin iff the object was declared with the register storage-class *)
  | Decl_object   of maybe (storageDuration * bool) * qualifiers * ctype
    (* has_prototype; return type; parameters types; is_variadic; is_inline; is_Noreturn *)
  | Decl_function of bool * ctype * (list (qualifiers * ctype * (* isRegister *)bool)) * bool * bool * bool


type tag_definition =
  | StructDef of list (Cabs.cabs_identifier * (qualifiers * ctype))
  | UnionDef of list (Cabs.cabs_identifier * (qualifiers * ctype))

instance (Show tag_definition)
  let show def = match def with
    | StructDef _ ->
        "TODO[StructDef]"
    | UnionDef _ ->
        "TODO[UnionDef]"
  end
end


type sigma 'a = <|
  declarations: Context.context identifier declaration;
  object_definitions: Context.context identifier (expression 'a);
  (* the list of identifiers are the parameter names used in the body *)
  function_definitions: Context.context identifier (list identifier * statement 'a);
  static_assertions: list (expression 'a * stringLiteral);
  
  tag_definitions: Context.context identifier tag_definition
|>


type gamma = Context.context identifier (maybe (storageDuration * bool) * qualifiers * ctype)

type program 'a = maybe identifier * sigma 'a
































(* == Equality functions ==================================================== *)

val identifierEqual:         identifier         -> identifier         -> bool
val integerSuffixEqual:      integerSuffix      -> integerSuffix      -> bool
val integerConstantEqual:    integerConstant    -> integerConstant    -> bool
val arithmeticOperatorEqual: arithmeticOperator -> arithmeticOperator -> bool
val constantEqual:           constant           -> constant           -> bool
val unaryOperatorEqual:      unaryOperator      -> unaryOperator      -> bool
val binaryOperatorEqual:     binaryOperator     -> binaryOperator     -> bool

(* NOTE: this is an internal function *)
val argumentsEqual_aux: forall 'a.
                      ('a -> 'a -> bool)                                             ->
                      (('a -> 'a -> bool) -> expression 'a -> expression 'a -> bool) ->
                      list (expression 'a) -> list (expression 'a)                   ->
                      bool

(* NOTE: this is an internal function *)
val expressionEqual': forall 'a.
                    ('a -> 'a -> bool)               ->
                    expression_ 'a -> expression_ 'a ->
                    bool

val expressionEqual: forall 'a.
                   ('a -> 'a -> bool)             ->
                   expression 'a -> expression 'a ->
                   bool

val argumentsEqual: forall 'a.
                  ('a -> 'a -> bool)                           ->
                  list (expression 'a) -> list (expression 'a) ->
                  bool

val bindingsEqual: bindings -> bindings -> bool

val definitionEqual: forall 'a.
                   ('a -> 'a -> bool)                                           ->
                   (identifier * expression 'a) -> (identifier * expression 'a) ->
                   bool

val declarationEqual: declaration -> declaration -> bool

val blockEqual_aux: forall 'a.
                  ('a -> 'a -> bool)                                           ->
                  (('a -> 'a -> bool) -> statement 'a -> statement 'a -> bool) ->
                  list (statement 'a) -> list (statement 'a)                   ->
                  bool

val statementEqual': forall 'a.
                   ('a -> 'a -> bool)             ->
                   statement_ 'a -> statement_ 'a ->
                   bool

val statementEqual: forall 'a.
                  ('a -> 'a -> bool)           ->
                  statement 'a -> statement 'a ->
                  bool

val blockEqual: forall 'a.
              ('a -> 'a -> bool)                         ->
              list (statement 'a) -> list (statement 'a) ->
              bool

val sigmaEqual: forall 'a.
              ('a -> 'a -> bool)   ->
              sigma 'a -> sigma 'a ->
              bool

val gammaEqual: gamma -> gamma -> bool

val programEqual: forall 'a.
                ('a -> 'a -> bool)       ->
                program 'a -> program 'a ->
                bool


let identifierEqual =
  (=)

let basisEqual b1 b2 =
  match (b1, b2) with
    | (Octal      , Octal      ) -> true
    | (Decimal    , Decimal    ) -> true
    | (Hexadecimal, Hexadecimal) -> true
    | (_          , _          ) -> false
  end

let integerSuffixEqual s1 s2 =
  match (s1, s2) with
    | (U  , U  ) -> true
    | (UL , UL ) -> true
    | (ULL, ULL) -> true
    | (L  , L  ) -> true
    | (LL , LL ) -> true
    | (_  , _  ) -> false
  end

let integerConstantEqual iCst1 iCst2 =
  match (iCst1, iCst2) with
    | (IConstant n1 b1 suff1_opt, IConstant n2 b2 suff2_opt) ->
        n1 = n2 && basisEqual b1 b2 && eq_option integerSuffixEqual suff1_opt suff2_opt
    | (IConstantMax ity1, IConstantMax ity2) ->
        integerTypeEqual ity1 ity2
    | (IConstantMin ity1, IConstantMin ity2) ->
        integerTypeEqual ity1 ity2
    | _ ->
        false
end

instance (Eq integerConstant)
  let (=)  = integerConstantEqual
  let (<>) = fun a b -> not (integerConstantEqual a b)
end

let arithmeticOperatorEqual aop1 aop2 =
  match (aop1, aop2) with
    | (Mul , Mul ) -> true
    | (Div , Div ) -> true
    | (Mod , Mod ) -> true
    | (Add , Add ) -> true
    | (Sub , Sub ) -> true
    | (Shl , Shl ) -> true
    | (Shr , Shr ) -> true
    | (Band, Band) -> true
    | (Bor , Bor ) -> true
    | (Bxor, Bxor) -> true
    | (_   , _   ) -> false
  end


let characterPrefixEqual pref1 pref2 =
  match (pref1, pref2) with
    | (Pref_L, Pref_L) -> true
    | (Pref_u, Pref_u) -> true
    | (Pref_U, Pref_U) -> true
    | (_     , _     ) -> false
  end

let characterConstantEqual =
  pairEqualBy (eq_option characterPrefixEqual) (=)

let encodingPrefixEqual pref1 pref2 =
  match (pref1, pref2) with
    | (Enc_u8, Enc_u8) -> true
    | (Enc_u , Enc_u ) -> true
    | (Enc_U , Enc_U ) -> true
    | (Enc_L , Enc_L ) -> true
    | (_     , _     ) -> false
  end

let stringLiteralEqual =
  pairEqualBy (eq_option encodingPrefixEqual) (=)


let rec constantEqual c1 c2 =
  match (c1, c2) with
    | (ConstantIndeterminate ty1, ConstantIndeterminate ty2) ->
        ty1 = ty2
    | (ConstantNull, ConstantNull) ->
        true
    | (ConstantInteger ic1, ConstantInteger ic2) ->
        integerConstantEqual   ic1 ic2
    | (ConstantFloating fc1, ConstantFloating fc2) ->
        fc1 = fc2
    | (ConstantCharacter cc1, ConstantCharacter cc2) ->
        characterConstantEqual cc1 cc2
    | (ConstantArray cs1, ConstantArray cs2) ->
        List.listEqualBy constantEqual cs1 cs2
    | (ConstantStruct tag_sym1 xs1, ConstantStruct tag_sym2 xs2) ->
        tag_sym1 = tag_sym2 && List.listEqualBy (pairEqualBy (=) constantEqual) xs1 xs2
    | (ConstantUnion tag_sym1 memb_ident1 cst1, ConstantUnion tag_sym2 memb_ident2 cst2) ->
        tag_sym1 = tag_sym2 && memb_ident1 = memb_ident1 && constantEqual cst1 cst2
    | _ ->
        false
  end

let unaryOperatorEqual u1 u2 =
  match (u1, u2) with
    | (Plus       , Plus       ) -> true
    | (Minus      , Minus      ) -> true
    | (Bnot       , Bnot       ) -> true
    | (Address    , Address    ) -> true
    | (Indirection, Indirection) -> true
    | (PostfixIncr, PostfixIncr) -> true
    | (PostfixDecr, PostfixDecr) -> true
    | (_          , _          ) -> false
  end

let binaryOperatorEqual bop1 bop2 =
  match (bop1, bop2) with
    | (Arithmetic aop1, Arithmetic aop2) -> arithmeticOperatorEqual aop1 aop2
    | (Comma, Comma) -> true
    | (And  , And  ) -> true
    | (Or   , Or   ) -> true
    | (Lt   , Lt   ) -> true
    | (Gt   , Gt   ) -> true
    | (Le   , Le   ) -> true
    | (Ge   , Ge   ) -> true
    | (Eq   , Eq   ) -> true
    | (Ne   , Ne   ) -> true
    | (_    , _    ) -> false
  end

let rec argumentsEqual_aux eq_A expressionEqual a1 a2 =
  match (a1, a2) with
    | ([]      , []      ) -> true
    | (e1 :: a1, e2 :: a2) -> expressionEqual eq_A e1 e2 && argumentsEqual_aux eq_A expressionEqual a1 a2
    | (_       , _       ) -> false
  end

let rec expressionEqual' (eq_A : 'a -> 'a -> bool) e1 e2 =
  let argumentsEqual = argumentsEqual_aux eq_A 
(* Bug HOL: mutually recursive call with a high order function as argument *)
        (fun eq a b -> expressionEqual eq a b) in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        unaryOperatorEqual uop1 uop2 &&
        expressionEqual eq_A e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        binaryOperatorEqual bop1 bop2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        arithmeticOperatorEqual aop1 aop2 &&
        expressionEqual eq_A e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        expressionEqual eq_A e1_1 e1_2 &&
        expressionEqual eq_A e2_1 e2_2 &&
        expressionEqual eq_A e3_1 e3_2
    | (AilEcast qs1 ty1 e1, AilEcast qs2 ty2 e2) ->
        qs1 = qs2 && ty1 = ty2 &&
        expressionEqual eq_A e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        expressionEqual eq_A e1 e2 &&
        argumentsEqual es1 es2
    | (AilEassert e1, AilEassert e2) ->
        expressionEqual eq_A e1 e2
    | (AilEoffsetof ty1 ident1, AilEoffsetof ty2 ident2) ->
        ty1 = ty1 && ident1 = ident2
    | (AilEstr lit1, AilEstr lit2) ->
        stringLiteralEqual lit1 lit2
    | (AilEconst c1, AilEconst c2) ->
        constantEqual c1 c2
    | (AilEident v1, AilEident v2) ->
        identifierEqual v1 v2
    | (AilEsizeof qs1 ty1, AilEsizeof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEsizeof_expr e1, AilEsizeof_expr e2) ->
        expressionEqual eq_A e1 e2
    | (AilEalignof qs1 ty1, AilEalignof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (_, _) -> false (* TODO: this is wrong *)
  end
and expressionEqual eq_A e1 e2 =
  match (e1, e2) with
    | (AnnotatedExpression a1 _ e1, AnnotatedExpression a2 _ e2) ->
        eq_A a1 a2 && expressionEqual' eq_A e1 e2
  end

let argumentsEqual eq_A a1 a2 =
  argumentsEqual_aux eq_A expressionEqual a1 a2

let bindingsEqual bs1 bs2 =
  List.listEqualBy (pairEqualBy identifierEqual (eq_triple (=) qualifiersEqual ctypeEqual)) bs1 bs2

let definitionEqual eq_A d1 d2 =
  pairEqualBy identifierEqual (expressionEqual eq_A) d1 d2

let eq_declaration ds1 ds2 =
  match (ds1, ds2) with
    | (Decl_object dur1 qs1 ty1, Decl_object dur2 qs2 ty2) ->
        dur1 = dur2 && qs1 = qs2 && ty1 = ty2
    | (Decl_function has_proto1 ret_ty1 qs_tys1 is_variadic1 is_inline1 is_Noreturn1,
       Decl_function has_proto2 ret_ty2 qs_tys2 is_variadic2 is_inline2 is_Noreturn2) ->
        has_proto1 = has_proto2 &&
        ret_ty1 = ret_ty2 &&
        qs_tys1 = qs_tys2 &&
        is_variadic1 = is_variadic2 &&
        is_inline1 = is_inline2 &&
        is_Noreturn1 = is_Noreturn2
    | _ ->
        false
  end

let rec eq_block_aux eq_A equiv_statement ss1 ss2 =
  match (ss1, ss2) with
    | ([]       , []       ) -> true
    | (s1 :: ss1, s2 :: ss2) -> equiv_statement eq_A s1 s2 && eq_block_aux eq_A equiv_statement ss1 ss2
    | (_        , _        ) -> false
  end

let rec statementEqual' eq_A s1 s2 =
  let eq_block = eq_block_aux eq_A 
(* Bug HOL: mutually recursive call with a high order function as argument *)
      (fun eq a b -> statementEqual eq a b) in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        expressionEqual eq_A e1 e2
    | (AilSblock bs1 ss1, AilSblock bs2 ss2) ->
        bs1 = bs2 &&
        eq_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1_1 s1_2 &&
        statementEqual eq_A s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        expressionEqual eq_A e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        expressionEqual eq_A e1 e2 &&
        statementEqual eq_A s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        integerConstantEqual ic1 ic2 &&
        statementEqual eq_A s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        statementEqual eq_A s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        identifierEqual v1 v2 &&
        statementEqual eq_A s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        identifierEqual v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        List.listEqualBy (pairEqualBy identifierEqual (expressionEqual eq_A)) d1 d2
    | (_, _) -> false
  end
and statementEqual eq_A s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        statementEqual' eq_A s1 s2
  end

let eq_block eq_A ss1 ss2 =
  eq_block_aux eq_A statementEqual ss1 ss2


(*
let eq_function_declaration eq_A eq_B fdecl1 fdecl2 =
  eq_ctype    fdecl1.fun_return_ty fdecl2.fun_return_ty  &&
  eq_bindings fdecl1.fun_bindings  fdecl2.fun_bindings   &&
  fdecl1.fun_is_variadic <-> fdecl2.fun_is_variadic      &&
  fdecl1.fun_is_inline   <-> fdecl2.fun_is_inline        &&
  fdecl1.fun_is_Noreturn <-> fdecl2.fun_is_Noreturn      &&
  eq_option (statementEqual eq_A eq_B) fdecl1.fun_body fdecl2.fun_body


let eq_sigma_declaration eq_A eq_B sdecl1 sdecl2 =
  match (sdecl1, sdecl2) with
    | (SDecl_fun id1 fdecl1, SDecl_fun id2 fdecl2) ->
        identifierEqual id1 id2 &&
        eq_function_declaration eq_A eq_B fdecl1 fdecl2
    | (SDecl_global id1 glob1, SDecl_global id2 glob2) ->
        identifierEqual id1 id2 &&
        eq_triple eq_qualifiers eq_ctype (eq_option (expressionEqual eq_B))
          glob1 glob2
    | (SDecl_static_assert e1 sc1, SDecl_static_assert e2 sc2) ->
        expressionEqual eq_B e1 e2 &&
        stringLiteralEqual sc1 sc2
    | (_,_) ->
        false
  end
*)



let eq_sigma eq_A sig1 sig2 =
  eq_context identifierEqual eq_declaration sig1.declarations sig1.declarations &&
  eq_context identifierEqual (expressionEqual eq_A) sig1.object_definitions sig2.object_definitions &&
  eq_context identifierEqual (pairEqualBy (List.listEqualBy identifierEqual) (statementEqual eq_A)) sig1.function_definitions sig2.function_definitions &&
  List.listEqualBy (pairEqualBy (expressionEqual eq_A) stringLiteralEqual) sig1.static_assertions sig2.static_assertions

(*
let eq_sigma eq_A eq_B =
  List.listEqualBy (eq_sigma_declaration eq_A eq_B)
(* (OLD)  eq_context identifierEqual (pairEqualBy (pairEqualBy eq_ctype eq_bindings) (statementEqual eq_A eq_B)) *)
(*  eq_context identifierEqual (eq_sigma_declaration eq_A eq_B) *)
(*
    (eq_either
      (pairEqualBy (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (expressionEqual eq_B)))
    )
*)
*)

let eq_gamma g1 g2 =
  eq_context identifierEqual (pairEqualBy qualifiersEqual ctypeEqual) g1 g2

let eq_program eq_A p1 p2 =
  pairEqualBy identifierEqual (eq_sigma eq_A) p1 p2
(* (NEW OLD)
     identifierEqual p1.startup p2.startup
  && eq_context identifierEqual (pairEqualBy (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
       p1.functions p2.functions
  && eq_context identifierEqual (pairEqualBy eq_ctype (eq_option (expressionEqual eq_B)))
       p1.globals p2.globals
  && eq_context identifierEqual (=) p1.strings p2.strings
 *)


(* == Equivalence functions ================================================= *)

val equiv_arguments_aux: forall 'a1 'a2.
                         (expression 'a1 -> expression 'a2 -> bool)     ->
                         list (expression 'a1) -> list (expression 'a2) ->
                         bool

val equiv_expression_: forall 'a1 'a2. expression_ 'a1                    -> expression_ 'a2                    -> bool
val equiv_expression:  forall 'a1 'a2. expression  'a1                    -> expression  'a2                    -> bool
val equiv_arguments:   forall 'a1 'a2. list (expression 'a1)              -> list (expression 'a2)              -> bool
val equiv_definition:  forall 'a1 'a2. identifier * expression 'a1        -> identifier * expression 'a2        -> bool
val equiv_declaration: forall 'a1 'a2. list (identifier * expression 'a1) -> list (identifier * expression 'a2) -> bool

val equiv_block_aux: forall 'a1 'a2.
                     (statement 'a1 -> statement 'a2 -> bool) ->
                     list (statement 'a1) -> list (statement 'a2) ->
                     bool

val equiv_statement_: forall 'a1 'a2. statement_ 'a1       -> statement_ 'a2       -> bool
val equiv_statement:  forall 'a1 'a2. statement  'a1       -> statement  'a2       -> bool
val equiv_block:      forall 'a1 'a2. list (statement 'a1) -> list (statement 'a2) -> bool

(* WIP
val equiv_sigma: forall 'a1 'a2 'B1 'B2. sigma 'a1 'B1 -> sigma 'a2 'B2 -> bool
val equiv_eq_sigma: forall 'a 'B.
                    ('a -> 'a -> bool) -> ('B -> 'B -> bool) ->
                    sigma 'a 'B -> sigma 'a 'B               ->
                    bool

val equiv_gamma : gamma -> gamma -> bool

val equiv_program: forall 'a1 'a2 'B1 'B2. program 'a1 'B1 -> program 'a2 'B2 -> bool

val equiv_eq_program: forall 'a 'B.
                      ('a -> 'a -> bool) -> ('B -> 'B -> bool) ->
                      program 'a 'B -> program 'a 'B ->
                      bool
*)


let rec equiv_arguments_aux equiv_expression a1 a2 =
  match (a1, a2) with
  | ([]      , []      ) -> true
  | (e1 :: a1, e2 :: a2) -> equiv_expression e1 e2 && equiv_arguments_aux equiv_expression a1 a2
  | (_       , _       ) -> false
    end

let rec equiv_expression_ e1 e2 =
  let equiv_arguments = equiv_arguments_aux 
(* Bug HOL: mutually recursive call with a high order function as argument *)
      (fun a b -> equiv_expression a b) in
  match (e1, e2) with
    | (AilEunary uop1 e1, AilEunary uop2 e2) ->
        unaryOperatorEqual uop1 uop2 &&
        equiv_expression e1 e2
    | (AilEbinary e1_1 bop1 e2_1, AilEbinary e1_2 bop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        binaryOperatorEqual bop1 bop2 &&
        equiv_expression e2_1 e2_2
    | (AilEassign e1_1 e2_1, AilEassign e1_2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2
    | (AilEcompoundAssign e1_1 aop1 e2_1, AilEcompoundAssign e1_2 aop2 e2_2) ->
        equiv_expression e1_1 e1_2 &&
        arithmeticOperatorEqual aop1 aop2 &&
        equiv_expression e2_1 e2_2
    | (AilEcond e1_1 e2_1 e3_1, AilEcond e1_2 e2_2 e3_2) ->
        equiv_expression e1_1 e1_2 &&
        equiv_expression e2_1 e2_2 &&
        equiv_expression e3_1 e3_2
    | (AilEcast qs1 ty1 e1, AilEcast qs2 ty2 e2) ->
        qs1 = qs2 && ty1 = ty2 &&
        equiv_expression e1 e2
    | (AilEcall e1 es1, AilEcall e2 es2) ->
        equiv_expression e1 e2 &&
        equiv_arguments es1 es2
    | (AilEassert e1, AilEassert e2) ->
        equiv_expression e1 e2
    | (AilEconst c1, AilEconst c2) ->
        constantEqual c1 c2
    | (AilEident v1, AilEident v2) ->
        identifierEqual v1 v2
    | (AilEsizeof qs1 ty1, AilEsizeof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (AilEalignof qs1 ty1, AilEalignof qs2 ty2) ->
        qs1 = qs2 && ty1 = ty2
    | (_, _) -> false
  end
and equiv_expression e1 e2 =
  match (e1, e2) with
  | (AnnotatedExpression _ _ e1, AnnotatedExpression _ _ e2) -> equiv_expression_ e1 e2
  end

let equiv_arguments a1 a2 =
  equiv_arguments_aux equiv_expression a1 a2

let equiv_definition d1 d2 =
  equiv_pair identifierEqual equiv_expression d1 d2


let rec equiv_declaration ds1 ds2 =
  match (ds1, ds2) with
  | ([]       , []       ) -> true
  | (d1 :: ds1, d2 :: ds2) -> equiv_definition d1 d2 && equiv_declaration ds1 ds2
  | (_        , _        ) -> false
  end

let rec equiv_block_aux equiv_statement ss1 ss2 =
  match (ss1, ss2) with
  | ([]       , []       ) -> true
  | (s1 :: ss1, s2 :: ss2) -> equiv_statement s1 s2 && equiv_block_aux equiv_statement ss1 ss2
  | (_        , _        ) -> false
  end

let rec equiv_statement_ s1 s2 =
  let equiv_block = equiv_block_aux 
(* Bug HOL: mutually recursive call with a high order function as argument *)
      (fun a b -> equiv_statement a b) in
  match (s1, s2) with
    | (AilSskip, AilSskip) -> true
    | (AilSexpr e1, AilSexpr e2) ->
        equiv_expression e1 e2
    | (AilSblock bs1 ss1, AilSblock bs2 ss2) ->
        bs1 = bs2 &&
        equiv_block ss1 ss2
    | (AilSif e1 s1_1 s2_1, AilSif e2 s1_2 s2_2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1_1 s1_2 &&
        equiv_statement s2_1 s2_2  
    | (AilSwhile e1 s1, AilSwhile e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSdo s1 e1, AilSdo s2 e2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilSbreak, AilSbreak) -> true
    | (AilScontinue, AilScontinue) -> true
    | (AilSreturnVoid, AilSreturnVoid) -> true
    | (AilSreturn e1, AilSreturn e2) ->
        equiv_expression e1 e2
    | (AilSswitch e1 s1, AilSswitch e2 s2) ->
        equiv_expression e1 e2 &&
        equiv_statement s1 s2
    | (AilScase ic1 s1, AilScase ic2 s2) ->
        integerConstantEqual ic1 ic2 &&
        equiv_statement s1 s2
    | (AilSdefault s1, AilSdefault s2) ->
        equiv_statement s1 s2
    | (AilSlabel v1 s1, AilSlabel v2 s2) ->
        identifierEqual v1 v2 &&
        equiv_statement s1 s2
    | (AilSgoto v1, AilSgoto v2) ->
        identifierEqual v1 v2
    | (AilSdeclaration d1, AilSdeclaration d2) ->
        equiv_declaration d1 d2
    | (_, _) -> false
  end
and equiv_statement s1 s2 =
  match (s1, s2) with
    | (AnnotatedStatement _ s1, AnnotatedStatement _ s2) ->
        equiv_statement_ s1 s2
  end

let equiv_block ss1 ss2 =
 equiv_block_aux equiv_statement ss1 ss2


(* HOL Hack
declare hol target_rep function expressionEqual' f a b = (a = b)
declare hol target_rep function expressionEqual  f a b = (a = b)
declare hol target_rep function statementEqual' f a b = (a = b)
declare hol target_rep function statementEqual  f a b = (a = b)
declare hol target_rep function equiv_expression_ a b = (a = b)
declare hol target_rep function equiv_expression  a b = (a = b)
*)


(* Currently unused.
let declaration = identifier * maybe storageDuration.
*)

(*
let equiv_function_declaration fdecl1 fdecl2 =
  eq_ctype    fdecl1.fun_return_ty fdecl2.fun_return_ty  &&
  eq_bindings fdecl1.fun_bindings  fdecl2.fun_bindings   &&
  fdecl1.fun_is_variadic <-> fdecl2.fun_is_variadic      &&
  fdecl1.fun_is_inline   <-> fdecl2.fun_is_inline        &&
  fdecl1.fun_is_Noreturn <-> fdecl2.fun_is_Noreturn      &&
  equiv_option equiv_statement fdecl1.fun_body fdecl2.fun_body

let equiv_sigma_declaration sdecl1 sdecl2 =
  match (sdecl1, sdecl2) with
    | (SDecl_fun id1 fdecl1, SDecl_fun id2 fdecl2) ->
        identifierEqual id1 id2 &&
        equiv_function_declaration fdecl1 fdecl2
    | (SDecl_global id1 glob1, SDecl_global id2 glob2) ->
        identifierEqual id1 id2 &&
        equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression)
          glob1 glob2
    | (SDecl_static_assert e1 sc1, SDecl_static_assert e2 sc2) ->
        equiv_expression e1 e2 &&
        stringLiteralEqual sc1 sc2
    | (_,_) ->
        false
  end
*)

(* WIP

let equiv_sigma S1 S2 =
  sigma_equiv identifierEqual (fun _ ->
    equiv_sigma_declaration
  ) S1 S2
(* (OLD)  equiv identifierEqual (fun _ -> equiv_pair (pairEqualBy eq_ctype eq_bindings) equiv_statement) S1 S2 *)
(*
    equiv_either
      (equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
      (equiv_triple eq_qualifiers eq_ctype (equiv_option equiv_expression))
*)

let equiv_eq_sigma eq_A eq_B S1 S2 =
(* (OLD)  equiv identifierEqual (fun _ -> pairEqualBy (pairEqualBy eq_ctype eq_bindings) (statementEqual eq_A eq_B)) S1 S2 *)
  sigma_equiv identifierEqual (fun _ ->
    eq_sigma_declaration eq_A eq_B
(*
    eq_either
      (pairEqualBy (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
      (eq_triple eq_qualifiers eq_ctype (eq_option (expressionEqual eq_B)))
*)
  ) S1 S2

let equiv_gamma g1 g2 =
  sigma_equiv identifierEqual (fun _ -> pairEqualBy eq_qualifiers eq_ctype) g1 g2

let equiv_program p1 p2 =
  equiv_pair identifierEqual equiv_sigma p1 p2
(* (NEW OLD)
     identifierEqual p1.startup p2.startup
  && equiv identifierEqual (fun _ -> equiv_pair (eq_triple eq_ctype eq_bindings (=)) (equiv_option equiv_statement))
       p1.functions p2.functions
  && equiv identifierEqual (fun _ -> equiv_pair eq_ctype (equiv_option equiv_expression))
       p1.globals p2.globals
  && eq_context identifierEqual (=) p1.strings p2.strings
*)

let equiv_eq_program eq_A eq_B p1 p2 =
  pairEqualBy identifierEqual (equiv_eq_sigma eq_A eq_B) p1 p2
(* (NEW OLD)
     identifierEqual p1.startup p2.startup
  && equiv identifierEqual (fun _ -> pairEqualBy (eq_triple eq_ctype eq_bindings (=)) (eq_option (statementEqual eq_A eq_B)))
       p1.functions p2.functions
  && equiv identifierEqual (fun _ -> pairEqualBy eq_ctype (eq_option (expressionEqual eq_B)))
       p1.globals p2.globals
  && eq_context identifierEqual (=) p1.strings p2.strings
*)

*)

(* *)
val     sigma_lookup: forall 'a. sigma 'a -> identifier -> maybe ((* sigma_declaration 'a 'B *) unit)
(*
let rec sigma_lookup S a =
  match S with
    | [] ->
        Nothing
    | (SDecl_fun id fdecl) :: S' ->
        if identifierEqual id a then
          Just (SDecl_fun id fdecl)
        else
          sigma_lookup S' a
    | (SDecl_global id glob) :: S' ->
        if identifierEqual id a then
          Just (SDecl_global id glob)
        else
          sigma_lookup S' a
    | (SDecl_static_assert _ _) :: S' ->
        sigma_lookup S' a
  end
*)

(*
val sigma_mem: forall 'a 'B. identifier -> sigma 'a 'B -> bool
let sigma_mem a S =
  match sigma_lookup S a with
  | Just _  -> true
  | Nothing -> false
  end

val sigma_fresh: forall 'a 'B. identifier -> sigma 'a 'B -> bool
let sigma_fresh a S =
  not (sigma_mem a S)
*)

val sigma_fresh_bindings: forall 'a. bindings -> sigma 'a -> bool
let sigma_fresh_bindings bs S =
  List.all (fun (ident, _) -> Context.fresh identifierEqual ident S.declarations) bs



(*
val lookup:         forall 'B. Context.context identifier 'B -> identifier -> maybe 'B
val mem:            forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh:          forall 'B. identifier -> Context.context identifier 'B -> bool
val fresh_bindings: forall 'B. bindings -> Context.context identifier 'B -> bool

val disjoint: forall 'B1 'B2.
              Context.context identifier 'B1 -> Context.context identifier 'B2 ->
              bool



let lookup C v          = Context.lookup identifierEqual C v
let mem v C             = Context.mem identifierEqual v C
let fresh v C           = Context.fresh identifierEqual v C
let fresh_bindings bs C = Context.fresh_bindings identifierEqual bs C
let disjoint C1 C2      = Context.disjoint identifierEqual C1 C2
*)

val parameters_of_bindings: bindings -> list (maybe (storageDuration * bool) * qualifiers * ctype)

val type_from_sigma: forall 'a. (ctype * bindings * bool) * maybe (statement 'a) -> ctype

let parameters_of_bindings bs =
  List.map snd bs

    (*
let type_from_sigma ((ty, bs, is_variadic), _) =
  Function ty (List.map (fun (_, (_, qs, ty)) -> (qs,ty)) bs) is_variadic
*)






(* K Hack *)

(*
type declaration = qualifiers * ctype (* * maybe storageDuration *)


type file 'a = <|
  main:    identifier;
  id_map:  Pmap.map identifier declaration;
  globals: list (identifier * expression 'a);
  fn_map:  Pmap.map identifier (list identifier * statement Loc.t 'a)
|>

val file_of_program: forall 'B. program Loc.t 'B -> file 'B
let file_of_program (main_id, ctx) =
  let (ids, fns) = List.fold_left (fun (ids_, fns_) (id, ((ty, bds), s)) ->
    (
      Pmap.add id (AilTypes.no_qualifiers, AilTypes.Function ty (List.map snd bds)) ids_,
      Pmap.add id (List.map fst bds, s) fns_
    )
  ) (Pmap.empty, Pmap.empty) ctx in
  <|
      main=    main_id;
      id_map=  ids;
      globals= [];
      fn_map=  fns
   |>
*)
