open Global

module C    = Core
module Caux = Core_aux

open Translation_effect


(* this is only used by [mk_stdcall] *)
val     mk_stdcall_aux: forall 'a. ('a -> bool) -> list 'a -> option 'a
let rec mk_stdcall_aux pred xs =
 match xs with
    | []     -> None
    | x::xs' -> if pred x then Some x else mk_stdcall_aux pred xs'
  end

val mk_stdcall: Core.fun_map zero -> string -> (list (Core.expr zero) -> Core.expr zero)
let mk_stdcall stdlib fname =
  match mk_stdcall_aux (function ((_, Some z), _) -> z = fname | _ -> false end) (Pmap.bindings stdlib) with
    | Some (f, _) -> Core.Ecall (Core.Sym f)
    | None        -> Boot.assert_false $ "[Translate_effect.E.mk_stdcall] `" ^ fname ^ "' is not a Core standard function."
 end



let promote_value (e: C.expr 'b ) : C.expr 'b = e




open Implementation
(* TODO: temporary *)
val tmp_implementation: implementation
let tmp_implementation =
  min_implementation_signed_char



open AilTypes
val is_unsigned_integer_type: ctype -> bool
let is_unsigned_integer_type = function
  | Basic (Integer it) ->
      AilTypesAux.unsigned_type it
  | _ ->
      false
end

let function_return_type = function
  | Function t _ -> t
end


val from_lvalue_type: AilSyntax.expression GenTypes.genTypeCategory -> qualifiers * ctype
let from_lvalue_type (AilSyntax.AnnotatedExpression (GenTypes.GenLValueType qs ty) _) =
  (qs, ty)


val exp_type_of: AilSyntax.expression GenTypes.genTypeCategory -> ctype
let exp_type_of a_expr =
  match GenTypesAux.interpret_genTypeCategory tmp_implementation
      (Annotation.type_of Annotation.concrete_annotation a_expr) with
    | Some (AilTypes.LValueType _ ty) -> (* unqualify *) ty
    | Some (AilTypes.RValueType   ty) -> ty
  end


val ctype_of: AilSyntax.expression GenTypes.genTypeCategory -> ctype
let ctype_of a_expr =
  match GenTypesAux.interpret_genTypeCategory tmp_implementation
      (Annotation.type_of Annotation.concrete_annotation a_expr) with
    | Some (AilTypes.LValueType _ ty) -> ty
    | Some (AilTypes.RValueType   ty) -> ty
  end
