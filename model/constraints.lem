open import Pervasives
open import Global Symbolic

  (*
type t
declare ocaml target_rep type t = `Smt_wrapper.assertions`


val empty: t
declare ocaml target_rep function empty = `Smt_wrapper.empty_assertions`


val is_empty: t -> bool
declare ocaml target_rep function is_empty = `Smt_wrapper.is_empty_assertions`

val combine: t -> t -> t
declare ocaml target_rep function combine = `Smt_wrapper.combine_assertions`

val assert_eq: symbolic -> symbolic -> t -> t
declare ocaml target_rep function assert_eq = `Smt_wrapper.assert_eq`

val assert_neq: symbolic -> symbolic -> t -> t
declare ocaml target_rep function assert_neq = `Smt_wrapper.assert_neq`

val assert_lt: symbolic -> symbolic -> t -> t
declare ocaml target_rep function assert_lt = `Smt_wrapper.assert_lt`

val assert_ge: symbolic -> symbolic -> t -> t
declare ocaml target_rep function assert_ge = `Smt_wrapper.assert_ge`





val isUnsat: t -> bool
declare ocaml target_rep function isUnsat = `Smt_wrapper.is_unsat`
*)

type t =
  (* TODO: assumes that the symbolic expressions have type "bool" *)
  | Constraints of list symbolic


val empty: t
let empty =
  Constraints []


val is_empty: t -> bool
let is_empty (Constraints xs) =
  List.null xs


val combine: t -> t -> t
let combine (Constraints xs) (Constraints ys) =
  Constraints (xs ++ ys) (* TODO: simplification ? *)




val assert_eq: symbolic -> symbolic -> t -> t
let assert_eq symb1 symb2 (Constraints xs) =
  Constraints (SYMBop Eq symb1 symb2 :: xs)

val assert_neq: symbolic -> symbolic -> t -> t
let assert_neq symb1 symb2 (Constraints xs) =
  Constraints (SYMBop Neq symb1 symb2 :: xs)







val isUnsat: t -> bool
let isUnsat _ =
  false (* TODO: WIP *)



(* ============================================================================================== *)



(*
type assertion =
  | Assert_eq  of symbolic * symbolic
  | Assert_neq of symbolic * symbolic
  | Assert_lt  of symbolic * symbolic
  | Assert_ge  of symbolic * symbolic

type t =
  Constraints of list assertion


val empty: t
let empty =
  Constraints []

val singleton: assertion -> t
let singleton x =
  Constraints [x]


val combine: t -> t -> t
let combine (Constraints a) (Constraints b) =
  Constraints (a ++ b)


(* TODO *)
let trivially_sat = function
  | Assert_eq (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 = n2 then
        true
      else
        false (* TODO *)
  | Assert_neq (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 <> n2 then
        true
      else
        false (* TODO *)
  | Assert_lt (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 < n2 then
        true
      else
        false (* TODO *)
  | Assert_ge (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 >= n2 then
        true
      else
        false (* TODO *)
  | _ ->
      false (* TODO *)
end


val simplify: t -> t
let simplify (Constraints xs) =
  (* TODO *)
  Constraints (List.filter (not -| trivially_sat) xs)


let trivially_unsat = function
  | Assert_eq (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 <> n2 then
        true
      else
        false (* TODO *)
  | Assert_neq (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 = n2 then
        true
      else
        false (* TODO *)
  | Assert_lt (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 >= n2 then
        true
      else
        false (* TODO *)
  | Assert_ge (Symbolic_constant n1) (Symbolic_constant n2) ->
      if n1 < n2 then
        true
      else
        false (* TODO *)
  | _ ->
      false (* TODO *)
end

val isUnsat: t -> bool
let isUnsat (Constraints asserts) =
  any trivially_unsat asserts
*)
