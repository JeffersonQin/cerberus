open import Global Pervasives Cabs AilSyntax Std

open import Cabs_to_ail_aux
import Cabs_to_ail_effect

import Boot Cabs Multiset Decode UniqueId
import AilTypes AilTypesAux Builtins


module ATypes = AilTypes


module E = Cabs_to_ail_effect

let inline (>>=)    = E.bind

let inline (>>) m f = m >>= fun _ -> f
let inline (<$>)    = E.fmap
let inline (<*>)    = E.app



type declaration_context =
  | Object_decl_context
  | Function_decl_context






(* BEGIN predicates on Ail syntax *)
(* see §6.6#6 *)
(* TODO: make the function pure, when complete *)
val     is_integer_constant_expression: expression unit -> E.t bool
let rec is_integer_constant_expression (AnnotatedExpression () expr) =
  match expr with
    | AilEunary uop e ->
        match uop with
          | Plus ->
              is_integer_constant_expression e
          | Minus ->
              is_integer_constant_expression e
          | Bnot ->
              is_integer_constant_expression e
          | Address ->
              E.return false
          | Indirection ->
              E.return false
          | PostfixIncr ->
              E.return false
          | PostfixDecr ->
              E.return false
        end
    
    | AilEbinary _ Comma _ ->
        E.return false
    | AilEbinary e1 _ e2 ->
        is_integer_constant_expression e1 >>= fun b1 ->
        if b1 then
          is_integer_constant_expression e2
        else
          E.return false
    
    | AilEassign _ _ ->
        E.return false
    | AilEcompoundAssign _ _ _ ->
        E.return false
    
    | AilEcond _ _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "conditional operator in `integer constant expressions'")
    
    | AilEcast _ _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "cast operator in `integer constant expressions'")
    
    | AilEcall _ _ ->
        E.return false
    | AilEmemberof _ _ ->
        E.return false
    | AilEmemberofptr _ _ ->
        E.return false
    
    | AilEconst (ConstantInteger _) ->
        E.return true
    | AilEconst (ConstantCharacter _) ->
        E.return true
    
    | AilEident _ ->
        E.return false
    
    | AilEsizeof _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "sizeof operator in `integer constant expressions'")

    | AilEalignof _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "_Alignof operator in `integer constant expressions'")
end


(* END predicates on Ail syntax *)






















val determinate_storage_duration: E.linkage -> specifiers -> ATypes.storageDuration
let determinate_storage_duration link specifs =
  let scs = specifs.storage_classes in
  if not (List.elem SC_Thread_local scs) &&
     (link = E.Linkage_external || link = E.Linkage_internal ||
      List.elem SC_static scs) then
_STD "§6.2.4#3, sentence 1"
    ATypes.Static
  
  else if List.elem SC_Thread_local scs then
_STD "§6.2.4#4, sentence 1"
    ATypes.Thread
  
  else if link = E.Linkage_none && not (List.elem SC_static scs) then
_STD "§6.2.4#5, sentence 1"
    ATypes.Automatic
  
  else
    Boot.assert_false "determinate_storage_duration"











val desugar_generic_association:        cabs_generic_association -> E.t (generic_association unit)
(* val desugar_declaration:                declaration -> E.t (list (sigma_declaration Location.t unit)) *)
val desugar_specifiers:                 declaration_context -> E.scope -> specifiers -> E.t unit (* TODO *)
val desugar_init_declarator:            ATypes.ctype -> init_declarator -> E.t (cabs_identifier * ATypes.ctype * maybe (expression unit))
val desugar_struct_declaration:         struct_declaration -> E.t (list (cabs_identifier * ATypes.ctype)) (* TODO *)
val desugar_struct_declarator:          struct_declarator -> E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype)) (* TODO *)
val desugar_enumerator:                 enumerator -> E.t unit (* TODO *)
val desugar_alignment_specifier:        alignment_specifier -> E.t unit (* TODO *)

(* NOTE: these twos functions do NOT register identifier being declared, this is
         left to the called (who can know the `kind' of the identifier from its
         type *)
val desugar_declarator:                 declarator        -> E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype))
val desugar_direct_declarator:          direct_declarator -> E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype))


val desugar_array_declarator:           bool -> array_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)
val desugar_parameter_array_declarator: array_declarator -> E.t unit (* TODO *)
val desugar_array_declarator_size:      array_declarator_size -> E.t unit (* TODO *)
val desugar_pointer_declarator:         pointer_declarator -> E.t (ATypes.ctype -> ATypes.ctype)
val desugar_parameter_type_list:        parameter_type_list -> E.t (list (maybe (cabs_identifier * list storage_class_specifier) *
                                                                          (ATypes.qualifiers * ATypes.ctype)) * bool)
val desugar_parameter_declaration:      parameter_declaration -> E.t (maybe (cabs_identifier * list storage_class_specifier) *
                                                                      (ATypes.qualifiers * ATypes.ctype))


val desugar_type_name:                  type_name -> E.t (ATypes.qualifiers * AilTypes.ctype)
val desugar_abstract_declarator:        bool -> abstract_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)
val desugar_direct_abstract_declarator: bool -> direct_abstract_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)


val desugar_initializer_:               initializer_ -> E.t (expression unit) (* TODO *)
val desugar_designator:                 designator -> E.t unit (* TODO *)

val desugar_and_register_static_assert_declaration:  static_assert_declaration -> E.t unit

val desugar_for_clause:                 for_clause -> E.t unit (* TODO *)

(* TODO: WIP *)
val wip_desugar_initializer_: ATypes.storageDuration -> ATypes.ctype -> initializer_ -> E.t constant
val static_thread_implicit_initializer: ATypes.ctype -> constant



































val translate_integer_suffix: cabs_integer_suffix -> integerSuffix
let translate_integer_suffix = function
  | CabsSuffix_U   -> U
  | CabsSuffix_UL  -> UL
  | CabsSuffix_ULL -> ULL
  | CabsSuffix_L   -> L
  | CabsSuffix_LL  -> LL
end


val translate_integer_constant: cabs_integer_constant -> integerConstant
let translate_integer_constant (str, suff_opt) =
  let (basis, n) = Decode.decode_integer_constant str in
  match suff_opt with
    | Just suff -> (n, basis, Just (translate_integer_suffix suff))
    | Nothing   -> (n, basis, Nothing)
  end


val translate_character_constant: cabs_character_prefix -> characterPrefix
let translate_character_constant = function
  | CabsPrefix_L -> Pref_L
  | CabsPrefix_u -> Pref_u
  | CabsPrefix_U -> Pref_U
end


val desugar_character_constant: cabs_character_constant -> E.t characterConstant
let desugar_character_constant (pref_opt, str) =
  E.return (maybe Nothing (Just -| translate_character_constant) pref_opt, str)










(* TODO: this is very partial for now *)
val     evaluate_integer_constant_expression: expression unit -> E.t integerConstant
let rec evaluate_integer_constant_expression (AnnotatedExpression () expr) =
  match expr with
    | AilEunary uop e ->
(*
        evaluate_integer_constant_expression e >>= fun ((n, b, suff_opt) as iCst) ->
        match uop with
          | Plus ->
              E.return iCst
          | Minus ->
              E.return (0-n)
          | Bnot ->
              E.fail (Errors.Desugar_NotyetSupported "Bnot operator in `integer constant expressions'")
        end
*)
        E.fail (Errors.Desugar_NotyetSupported "unary operator in `integer constant expressions'")
    | AilEbinary e1 _ e2 ->
        E.fail (Errors.Desugar_NotyetSupported "binary operator in `integer constant expressions'")
    | AilEcond _ _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "conditional operator in `integer constant expressions'")
    | AilEcast _ _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "cast operator in `integer constant expressions'")
    | AilEconst (ConstantInteger iCst) ->
        E.return iCst
    | AilEconst (ConstantCharacter _) ->
        E.fail (Errors.Desugar_NotyetSupported "character constant in `integer constant expressions'")
    | AilEsizeof _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "sizeof operator in `integer constant expressions'")
    | AilEalignof _ _ ->
        E.fail (Errors.Desugar_NotyetSupported "_Alignof operator in `integer constant expressions'")
    (* Not dealing with an integer constant expression *)
    | _ ->
        E.fail Errors.Desugar_impossible
  end

























val translate_unary_operator: cabs_unary_operator -> unaryOperator
let translate_unary_operator = function
  | CabsAddress     -> Address
  | CabsIndirection -> Indirection
  | CabsPlus        -> Plus
  | CabsMinus       -> Minus
  | CabsBnot        -> Bnot
  (* This case cannot occurs since Not is translated away. *)
  | CabsNot         -> Boot.assert_false "[Cabs_to_ail.translate_unary_operator] Not"
end


val translate_arithmetic_operator: cabs_binary_operator -> arithmeticOperator
let translate_arithmetic_operator = function
  | CabsAdd  -> Add
  | CabsSub  -> Sub
  | CabsMul  -> Mul
  | CabsDiv  -> Div
  | CabsMod  -> Mod
  | CabsBand -> Band
  | CabsBxor -> Bxor
  | CabsBor  -> Bor
  | CabsShl  -> Shl
  | CabsShr  -> Shr
  | _ -> Boot.assert_false "[Cabs0_to_ail.translate_arithmetic_operator] should only be called on \
                            operators allowed for compound assignments [§6.5.16#1]."
end


val translate_binary_operator: cabs_binary_operator -> binaryOperator
let translate_binary_operator = function
  | CabsAnd   -> And
  | CabsOr    -> Or
  | CabsEq    -> Eq
  | CabsNe    -> Ne
  | CabsLt    -> Lt
  | CabsGt    -> Gt
  | CabsLe    -> Le
  | CabsGe    -> Ge
  | op      -> Arithmetic (translate_arithmetic_operator op)
end


val translate_assignment_operator: cabs_assignment_operator -> maybe arithmeticOperator
let translate_assignment_operator = function
  | CabsAssign      -> Nothing
  | CabsAssign_Mul  -> Just Mul
  | CabsAssign_Div  -> Just Div
  | CabsAssign_Mod  -> Just Mod
  | CabsAssign_Add  -> Just Add
  | CabsAssign_Sub  -> Just Sub
  | CabsAssign_Shl  -> Just Shl
  | CabsAssign_Shr  -> Just Shr
  | CabsAssign_Band -> Just Band
  | CabsAssign_Bxor -> Just Bxor
  | CabsAssign_Bor  -> Just Bor
end

(* TODO
val translate_storage_class_specifier: C.storage_class_specifier -> 
let translate_storage_class_specifier = function
  | C.SC_typedef
  | C.SC_extern
  | C.SC_static
  | C.SC_Thread_local
  | C.SC_auto
  | C.SC_register
end
*)






val desugar_cabs_constant: forall 'a. cabs_constant -> E.t constant
let desugar_cabs_constant = function
  | CabsInteger_const iCst ->
      E.return (ConstantInteger (translate_integer_constant iCst))
  | CabsFloating_const str ->
      E.fail (Errors.Desugar_NeverSupported "floating constants")
  | CabsEnumeration_const ->
      E.fail (Errors.Desugar_NotyetSupported "WIP: desugar_cabs_constant, CabsEnumeration_const")
  | CabsCharacter_const cCst ->
      desugar_character_constant cCst >>= fun d_cCst ->
      E.return (ConstantCharacter d_cCst)
end


val translate_cabs_encoding_prefix: cabs_encoding_prefix -> encodingPrefix
let translate_cabs_encoding_prefix = function
  | CabsEncPrefix_u8 ->
      Enc_u8
  | CabsEncPrefix_u ->
      Enc_u
  | CabsEncPrefix_U ->
      Enc_U
  | CabsEncPrefix_L ->
      Enc_L
end

val translate_cabs_string_literal: cabs_string_literal -> stringLiteral
let translate_cabs_string_literal (pref_opt, str) =
   (maybe Nothing (Just -| translate_cabs_encoding_prefix) pref_opt, str)








val desugar_basic_type_specifiers: Multiset.t cabs_type_specifier -> E.t (ATypes.basicType)
let desugar_basic_type_specifiers specs =
_STD "§6.7.2#2, sentence 2 (non `void' case)" $
  if      specs = Multiset.from_list [TSpec_char] then
    E.return $ ATypes.Integer ATypes.Char
  else if specs = Multiset.from_list [TSpec_signed; TSpec_char] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Ichar)
  else if specs = Multiset.from_list [TSpec_unsigned; TSpec_char] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Ichar)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_short];
            Multiset.from_list [TSpec_signed; TSpec_short];
            Multiset.from_list [TSpec_short; TSpec_int];
            Multiset.from_list [TSpec_signed; TSpec_short; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned; TSpec_short];
            Multiset.from_list [TSpec_unsigned; TSpec_short; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_int];
            Multiset.from_list [TSpec_signed];
            Multiset.from_list [TSpec_signed; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned];
            Multiset.from_list [TSpec_unsigned; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_long];
            Multiset.from_list [TSpec_signed; TSpec_long];
            Multiset.from_list [TSpec_long; TSpec_int];
            Multiset.from_list [TSpec_signed; TSpec_long; TSpec_int] ]then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned; TSpec_long];
            Multiset.from_list [TSpec_unsigned; TSpec_long; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_long; TSpec_long];
            Multiset.from_list [TSpec_signed; TSpec_long; TSpec_long];
            Multiset.from_list [TSpec_long; TSpec_long; TSpec_int];
            Multiset.from_list [TSpec_signed; TSpec_long; TSpec_long; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.LongLong)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned; TSpec_long; TSpec_long];
            Multiset.from_list [TSpec_unsigned; TSpec_long; TSpec_long; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.LongLong)
  else if specs = Multiset.from_list [TSpec_Bool] then E.return $ ATypes.Integer (ATypes.Bool)
  (* NOTE: real floating not supported *)
  else if    specs = Multiset.from_list [TSpec_float]
          || specs = Multiset.from_list [TSpec_double]
          || specs = Multiset.from_list [TSpec_long; TSpec_double]
          || specs = Multiset.from_list [TSpec_float; TSpec_Complex]
          || specs = Multiset.from_list [TSpec_double; TSpec_Complex]
          || specs = Multiset.from_list [TSpec_long; TSpec_double; TSpec_Complex] then
    E.fail $ Errors.Desugar_NeverSupported "real floating types"
  else
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.2#2, 2nd sentence")



val translate_type_qualifiers: list cabs_type_qualifier -> ATypes.qualifiers
let translate_type_qualifiers qs =
_STD "§6.7.3#5, sentence 1" $
  ATypes.make_qualifiers
    (List.elem Q_const qs) (List.elem Q_restrict qs)
    (List.elem Q_volatile qs) (List.elem Q_Atomic qs)


val     desugar_type_specifiers : list cabs_type_specifier -> E.t (ATypes.ctype)
let rec desugar_type_specifiers specs =
  match specs with
  | [] ->
_STD "§6.7.2#2, sentence 1"
      E.fail (Errors.Desugar_ConstraintViolation "§6.7.2#2, 1st sentence")
  
  | [TSpec_void] ->
_STD "§6.7.2#2, sentence 2 (`void' case)"
      E.return ATypes.Void
  
  | [TSpec_struct (Just tag_ident) Nothing] ->
      (* §6.7.3.2#7 *)
      E.register_identifier tag_ident E.Namespace_tag E.Kind_tag [(* TODO: check *)] >>= fun tag_sym ->
      (* TODO: bogus? *)
      E.return (ATypes.Struct tag_sym [])

(*
      (* NOTE: in this case the struct type has already been declared *)
      E.resolve_identifier ident E.Namespace_tag >>= function
        | Just (_, (tag_sym, E.Kind_tag members, _)) ->
            E.return (ATypes.Struct tag_sym members)
        | Nothing ->
            E.fail (Errors.Desugar_OtherViolation "Couldn't resolve a struct identifier") (* TODO: check if this id the proper quote *)
      end
*)



(*
  | [TSpec_struct Nothing (Just sdecls)] ->
      (* §6.7.3.2#5, sentence 2 *)
      E.foldrM (fun z acc ->
        desugar_struct_declaration z >>= fun xs ->
        E.return (xs ++ acc)
      ) sdecls []    >>= fun members ->
      E.fresh_symbol >>= fun tag_sym ->
      E.register_tag_declaration tag_sym (E.Struct_declaration members) >>
      E.return (ATypes.Struct tag_sym members)

  | [TSpec_struct ident_opt (Just sdecls)] ->
      (* TODO: check std *)
      E.foldrM (fun z acc ->
        desugar_struct_declaration z >>= fun xs ->
        E.return (xs ++ acc)
      ) sdecls [] >>= fun members ->
      maybe (E.register_unamed) (fun ident ->
        E.register_identifier ident E.Namespace_tag (E.Kind_tag members) [(* TODO: check *)]
      ) ident_opt >>= fun tag_sym ->
      E.return (ATypes.Struct tag_sym members)
*)


(*
 | Struct of list (identifier * ctype) (* TODO: no bitfields for now *)
*)

(*
TSpec_struct of maybe cabs_identifier * maybe (list struct_declaration)


and struct_declaration =
  | Struct_declaration of list cabs_type_specifier * list cabs_type_qualifier * list struct_declarator
  | Struct_assert      of static_assert_declaration


*)


(*  WIP

  
  | [TSpec_Atomic tyname] -> do E
      (qs, ty) <- desugar_type_name tyname; in
        E.return (ATypes.Atomic ty)
      end

  | [TSpec_struct id_opt sdecls_opt] ->
      Boot.assert_false "TODO"
  
  | [TSpec_union id_opt sdecls_opt] ->
      Boot.assert_false "TODO"
  
  | [TSpec_enum id_opt enums_opt] ->
      Boot.assert_false "TODO"
  
    (* TODO: this break impl-def independance *)
  | [TSpec_name str] ->
      match Builtins.translate_builtin_typenames str with
        | Just ty ->
            E.return ty
        | Nothing ->
            (* TODO [tmp hack] removing the qualifiers *)
            E.get_typedef str >>= fun (qs, ty) ->
            E.return ty
      end
*)  
  
  (* *)
  | [TSpec_name str] ->
      match Builtins.translate_builtin_typenames str with
        | Just ty ->
            E.return ty
        | Nothing ->
            (* TODO: check the namespace *)
            E.resolve_identifier str E.Namespace_ordinary >>= function
              | Just (_, (sym, E.Kind_typedef, _)) ->
                  E.resolve_typedef sym >>= fun (qs, ty) ->
                  (* TODO: qualifiers *)
                  E.return ty
              | _ ->
                  E.fail (Errors.Desugar_NotyetSupported "WIP: error case")
            end
      end
  | ss ->
      ATypes.Basic <$> desugar_basic_type_specifiers (Multiset.from_list ss)
end












(*
int                                     int
int *                                   pointer to int
int *[3]                                array of three pointers to int
int ( * )[3]                            pointer to an array of three ints
int ( * )[*]                            pointer to a variable length array of an unspecified number of ints,
int *()                                 function with no parameter specification returning a pointer to int
int ( * )(void)                         pointer to function with no parameters returning an int
int ( * const [])(unsigned int, ...)    array of an unspecified number of constant pointers to functions, each with
                                        one parameter that has type unsigned int and an unspecified number of other
                                        parameters, returning an int.



*)













































(* val     desugar_expression: cabs_expression -> E.t (expression unit) *)
and desugar_expression expr =
  AnnotatedExpression () <$>
  match expr with
    | CabsEident ident ->
        let _ = Boot.output_string ("desugar_expression: " ^ ident) in (* DEBUG *)
_STD "§6.5.1#2" $
        E.resolve_identifier ident E.Namespace_ordinary >>= function
          | Just (_, (id, kind, _)) ->
              (* I love the fact that it is a footnote that says that undeclared
                 identifiers are syntax errors ... *)
              if not (E.is_object_kind kind || kind = E.Kind_function) then
                E.fail (Errors.Desugar_OtherViolation "§6.5.1#2")
              else
                E.add_used_identifier id >>
                E.return (AilEident id)
          | Nothing ->
              E.fail (Errors.Desugar_OtherViolation "§6.5.1#2")
        end
    
    | CabsEconst cst ->
        AilEconst <$> desugar_cabs_constant cst
    | CabsEstring lit ->
        E.return (AilEstr $ translate_cabs_string_literal lit)
    | CabsEgeneric e gas ->
        AilEgeneric <$> desugar_expression e
                    <*> E.mapM desugar_generic_association gas
    
    | CabsEsubscript e1 e2 ->
_STD "§6.5.2.1#2, sentence 2" $
        AilEunary Indirection <$> (
          AnnotatedExpression () <$>
          (AilEbinary <$> desugar_expression e1
                      <*> E.return (Arithmetic Add)
                      <*> desugar_expression e2)
        )
    | CabsEcall e es ->
        (* TODO: STD check + annot *)
        AilEcall <$> desugar_expression e <*> E.mapM desugar_expression es
    | CabsEmemberof e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberof <$> desugar_expression e <*> (E.return ident)
    | CabsEmemberofptr e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberofptr <$> desugar_expression e <*> (E.return ident)
    | CabsEpostincr e ->
        AilEunary PostfixIncr <$> desugar_expression e
    | CabsEpostdecr e ->
        AilEunary PostfixDecr <$> desugar_expression e
    | CabsEcompound tyname inits ->
        Boot.assert_false "WIP 18"
    | CabsEpreincr e ->
_STD "§6.5.3.1#2, sentence 3" $
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Add (AnnotatedExpression () (AilEconst (ConstantInteger (1, Decimal, Nothing))))
    | CabsEpredecr e ->
_STD "§6.5.3.1#3" $
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Sub (AnnotatedExpression () (AilEconst (ConstantInteger (1, Decimal, Nothing))))

      (* (§6.5.3.3#5) *)
    | CabsEunary CabsNot e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEbinary (AnnotatedExpression () (AilEconst (ConstantInteger (0, Octal, Nothing)))) Eq d_e
    
    | CabsEunary uop e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEunary (translate_unary_operator uop) d_e
    | CabsEsizeof_expr e ->
        Boot.assert_false "WIP 22"
    | CabsEsizeof_type tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEsizeof qs ty
    | CabsEalignof tyname ->
        Boot.assert_false "WIP 24"
    | CabsEcast tyname e ->
        (* TODO: check *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        desugar_expression e     >>= fun d_e      ->
        E.return (AilEcast qs ty d_e)
    
    | CabsEbinary bop e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return (translate_binary_operator bop)
                   <*> desugar_expression e2
    | CabsEcond e1 e2 e3 ->
        AilEcond <$> desugar_expression e1
                 <*> desugar_expression e2
                 <*> desugar_expression e3
    | CabsEassign aop e1 e2 ->
        match translate_assignment_operator aop with
          | Nothing  -> AilEassign
          | Just aop -> (fun z -> AilEcompoundAssign z aop)
        end <$> desugar_expression e1
            <*> desugar_expression e2
    | CabsEcomma e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return Comma
                   <*> desugar_expression e2
  end

and desugar_generic_association gas =
  match gas with
    | GA_type tyname e ->
        desugar_type_name tyname >>= fun (_, ty) ->
        (* TODO: (§6.5.1.1#2, sentence 2), ty must be complete and not variably modified *)
        desugar_expression e     >>= fun d_e     ->
        E.return (AilGAtype ty d_e)
    | GA_default e ->
        AilGAdefault <$> desugar_expression e
  end






and desugar_specifiers decl_ctxt scope specifs =
  let scs = specifs.storage_classes in
  if not (List.length scs <= 1 || List.elem SC_Thread_local scs &&
                                  (List.elem SC_static scs || List.elem SC_extern scs))then
_STD "§6.7.1#2" $
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#2")
  
  else if not (decl_ctxt = Object_decl_context && scope = E.Scope_block &&
               List.elem SC_Thread_local scs -->
                 (List.elem SC_static scs || List.elem SC_extern scs)
              ) then
_STD "§6.7.1#3, sentence 1" $
         E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#3, 1st sentence")
  
  else if decl_ctxt = Function_decl_context && List.elem SC_Thread_local scs then
_STD "§6.7.1#4" $
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#4")
  
  else if not (decl_ctxt = Function_decl_context && scope = E.Scope_block -->
               scs = [] || scs = [SC_extern]) then
_STD "§6.7.1#7" $
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#7")
  else
_STD "§6.7.1#8" $ (* TODO *)
    Boot.assert_false "WIP 33"

(*
<|
  C.storage_classes:      list storage_class_specifier;
  C.type_specifiers:      list type_specifier;
  C.type_qualifiers:      list type_qualifier;
  C.function_specifiers:  list function_specifier;
  C.alignment_specifiers: list alignment_specifier;
|>
*)

(* TODO: check *)
and desugar_init_declarator _ty idecltor : E.t (cabs_identifier * ATypes.ctype * maybe (expression unit)) =
  match idecltor with
    | InitDecl decltor Nothing ->
        desugar_declarator decltor >>= fun (ident, mk_ty) ->
        E.return (ident, mk_ty _ty, Nothing)
    | InitDecl decltor (Just init) ->
        desugar_declarator decltor >>= fun (ident, mk_ty) ->
        let ty = mk_ty _ty in
        wip_desugar_initializer_ (* TODO *) ATypes.Static ty init  >>= fun d_cst            ->
        E.return (ident, ty, Just (AnnotatedExpression () $ AilEconst d_cst))
  end



and desugar_struct_declaration struct_decl =
  match struct_decl with
    | Struct_declaration specs qs sdecltors ->
        (* TODO: qualifiers *)
        desugar_type_specifiers specs >>= fun ty ->
        E.mapM (fun sdecltor ->
          desugar_struct_declarator sdecltor >>= fun (ident, mk_type) ->
          E.return (ident, mk_type ty)
        ) sdecltors
    | Struct_assert _ ->
        E.fail (Errors.Desugar_NotyetSupported "Struct_assert")
  end

and desugar_struct_declarator struct_decltor =
  match struct_decltor with
    | SDecl_simple decltor ->
        desugar_declarator decltor
    | SDecl_bitfield declor_opt e ->
        E.fail (Errors.Desugar_NotyetSupported "SDecl_bitfield")
  end

and desugar_enumerator (id, e_opt) =
  Boot.assert_false "WIP 39"


and desugar_alignment_specifier align_spec =
  match align_spec with
    | AS_type tyname ->
      Boot.assert_false "WIP 40"
    | AS_expr e ->
      Boot.assert_false "WIP 41"
  end


(* val desugar_declarator: declarator -> E.t (identifier * ATypes.ctype -> ATypes.ctype) *)
and desugar_declarator (Declarator ptr_decltor_opt ddecltor) : E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype)) = do E
  mk_ptr_type      <- maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt;
  (ident, mk_type) <- desugar_direct_declarator ddecltor; in
    E.return (ident, fun ty -> mk_type $ mk_ptr_type ty)
end


and desugar_direct_declarator ddecltor : E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype)) =
  match ddecltor with
    | DDecl_identifier ident ->
        E.return (ident, fun ty -> ty)
    | DDecl_declarator decltor ->
        desugar_declarator decltor
    
      (* TODO: STD check + annot *)
    | DDecl_array ddecltor a_decltor -> do E
        (ident, mk_type) <- desugar_direct_declarator ddecltor;
        mk_array_type    <- desugar_array_declarator (* TODO: is_under_array *) false a_decltor; in
          E.return (ident, fun ty -> mk_type (mk_array_type ty))
        end
    
    | DDecl_function ddecltor param_tys ->
        (* TODO: check + annotate with STD *)
        desugar_direct_declarator ddecltor    >>= fun (ident, mk_ty)    ->
        desugar_parameter_type_list param_tys >>= fun (xs, is_variadic) ->
        E.with_scope E.Scope_prototype (
          E.mapM_ (function
            | (Just (ident, storage_classes), (qs, ty)) ->
                (* TODO: register the declaration (qs, ty) *)
                E.void $
                  E.register_identifier ident
                    E.Namespace_ordinary (E.Kind_object true) storage_classes
            | (Nothing, _) ->
                E.return ()
          end
          ) xs
        ) >>
        (* TODO: check *)
        E.return (ident, fun ty -> mk_ty (ATypes.Function ty (List.map snd xs) is_variadic))

(*
        E.register_identifier ident
          E.Namespace_ordinary E.Kind_object specifs.storage_classes >>= fun sym            ->
*)




(* WIP
_STD "§6.7.6.3#5" $
          E.return (sym, fun ty -> mk_ty (ATypes.Function ty bs is_variadic))
        end
*)
  end

and desugar_array_declarator is_under_array a_decltor =
  match a_decltor with
    | ADecl _ _ Nothing ->
        E.fail (Errors.Desugar_NotyetSupported "array type with no size")
    
    | ADecl _ _ (Just ADeclSize_asterisk) ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              E.fail (Errors.Desugar_NotyetSupported "variable length array type")
          | _ ->
              E.fail (Errors.Desugar_ConstraintViolation "§6.7.6.2#4, 2nd sentence")
        end
    
    (* TODO: hacking the simple case for now *)
    | ADecl [] false (Just (ADeclSize_expression (CabsEconst (CabsInteger_const (str,_))))) ->
        E.return (fun ty -> ATypes.Array ty (snd $ Decode.decode_integer_constant str))
    
    | ADecl [] false (Just (ADeclSize_expression e)) ->
        E.return (fun ty -> ATypes.Array ty 42) (* TODO: constant *)
    
    | ADecl qs is_static a_decltor_size_opt ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              if is_under_array then
_STD "§6.7.6.2#1, sentence 5" $
                E.fail (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, 5th sentence")
              else
                E.return ()
          | _ ->
              if qs <> [] || is_static then
_STD "§6.7.6.2#1, sentence 5" $
                E.fail (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, 5th sentence")
              else
                E.return ()
        end >>
        Boot.assert_false "WIP 46"
  end


(* NOTE: this is called for declarators of function parameters *)
and desugar_parameter_array_declarator a_decltor =
  match a_decltor with
    | ADecl qs is_static a_decltor_size ->
        Boot.assert_false "WIP desugar_parameter_array_declarator"
  end

and desugar_array_declarator_size a_decltor_size =
  match a_decltor_size with
    | ADeclSize_expression e ->
        Boot.assert_false "WIP 47"
    | ADeclSize_asterisk ->
        Boot.assert_false "WIP 48"
  end

(* val desugar_pointer_declarator: pointer_declarator -> E.t (ctype -> ctype) *)
and desugar_pointer_declarator ptr_decltor =
  match ptr_decltor with
    | PDecl tquals ptr_decltor_opt ->
_STD "§6.7.6.1#1" do E
        mk_ty <- maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt; in
          let ptr_qs = translate_type_qualifiers tquals in
          E.return $
            fun ty -> ATypes.Pointer ptr_qs ty
        end
  end

and desugar_parameter_type_list params =
  match params with
    | Params param_decls is_variadic -> do E
        xs <- E.mapM desugar_parameter_declaration param_decls; in
          E.return (xs, is_variadic)
        end
  end

and desugar_parameter_declaration param_decl =
  match param_decl with
    | PDeclaration_decl specifs decltor ->
        desugar_type_specifiers specifs.type_specifiers >>= fun ty             ->
        desugar_declarator decltor                      >>= fun (ident, mk_ty) ->
        E.return (Just (ident, specifs.storage_classes), (translate_type_qualifiers specifs.type_qualifiers, mk_ty ty))
    
    | PDeclaration_abs_decl specifs abs_decltor_opt ->
        desugar_type_specifiers specifs.type_specifiers                         >>= fun ty    ->
        maybe (E.return id) (desugar_abstract_declarator false) abs_decltor_opt >>= fun mk_ty ->
        E.return (Nothing, (translate_type_qualifiers specifs.type_qualifiers, mk_ty ty))
  end









(* STATUS: maybe ok *)
(* val     desugar_type_name: type_name -> E.t (ATypes.qualifiers * ATypes.ctype) *)
and desugar_type_name (Type_name specs tquals abs_decltor_opt) = do E
  ty    <- desugar_type_specifiers specs;
  mk_ty <- maybe (E.return id) (desugar_abstract_declarator false) abs_decltor_opt; in
    E.return (translate_type_qualifiers tquals, mk_ty ty)
  end


(* TODO: yuck *)
(* the bool argument `is_under_array' is true iff we went through array type derivation
   since the last call to desugar_type_name *)
and desugar_abstract_declarator is_under_array abs_decltor =
  match abs_decltor with
    | AbsDecl_pointer ptr_decltor ->
        desugar_pointer_declarator ptr_decltor
    | AbsDecl_direct ptr_decltor_opt dabs_decltor -> do E
        mk_ptr_type <- maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt;
        mk_ty       <- desugar_direct_abstract_declarator is_under_array dabs_decltor; in
          E.return (fun ty -> mk_ty (mk_ptr_type ty))
        end
  end


and desugar_direct_abstract_declarator is_under_array dabs_decltor =
  match dabs_decltor with
    | DAbs_abs_declarator abs_decltor ->
        desugar_abstract_declarator is_under_array abs_decltor
    | DAbs_array dabs_decltor_opt a_decltor -> do E
        mk_ty         <- maybe (E.return id) (desugar_direct_abstract_declarator true) dabs_decltor_opt;
        mk_array_type <- desugar_array_declarator is_under_array a_decltor; in
          E.return (fun ty -> mk_ty (mk_array_type ty))
        end
    | DAbs_function dabs_decltor_opt param_tys -> do E
        mk_ty             <- maybe (E.return id) (desugar_direct_abstract_declarator is_under_array) dabs_decltor_opt;
        (_, (tys, is_variadic)) <- E.with_scope E.Scope_prototype (desugar_parameter_type_list param_tys); in
          (* TODO: check *)
          E.return (fun ty -> mk_ty (ATypes.Function ty (List.map snd tys) is_variadic))
        end
  end












(*

DESUGARING (DUH)

2-  No initializer shall attempt to provide a value for an object not contained within the entity being initialized.


STATIC-TYPING

3-  The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.


OTHER

4-  All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.



5-  If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier.


*)




and static_thread_implicit_initializer ty =
  match ty with
    | ATypes.Pointer _ _ ->
        ConstantNull
    | ATypes.Basic _ ->
        if AilTypesAux.is_arithmetic ty then
          ConstantInteger (0, Octal, Nothing)
        else
          Boot.assert_false "type error"
    | ATypes.Array elem_ty n ->
        ConstantArray (Global.replicate_list (static_thread_implicit_initializer elem_ty) (natFromInteger n))
    | _ ->
        Boot.assert_false "type error"
(*
    | Function ty qs_tys is_variadic ->
        
    | Atomic ty ->
        
    | Struct of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
    | Union of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
    | Builtin of string
*)
  end


(*  wip_desugar_initializer_: storageDuration -> ctype -> initializer_ -> E.t ? *)
and wip_desugar_initializer_ sd current_ty = function
  | Init_expr e ->
      (* we ignore the type here because the type checking will catch
         errors later *)
      match sd with
        | ATypes.Automatic ->
            Boot.assert_false "WIP"
        | ATypes.Allocated ->
            Boot.assert_false "not possible"
        (* Static | Thread *)
        | _ ->
            desugar_expression e               >>= fun d_e ->
            is_integer_constant_expression d_e >>= function
              | true ->
                  ConstantInteger <$> evaluate_integer_constant_expression d_e
              | false ->
                  E.fail (Errors.Desugar_ConstraintViolation "§6.7.9#4")
            end
      end
  
  | Init_list desigs_opt_inits ->
      match current_ty with
        | ATypes.Array elem_ty n ->
            (* STD §6.7.9#10 *)
            let implicit = match sd with
              | ATypes.Automatic ->
                  ConstantIndeterminate elem_ty
              | ATypes.Allocated ->
                  Boot.assert_false "not possible"
              (* Static | Thread *)
              | _ ->
                  static_thread_implicit_initializer elem_ty
            end in
            
            E.foldlM (fun (desigs_opt, init) (i, acc) ->
              match desigs_opt with
                | Just [Desig_array e] ->
                    desugar_expression e               >>= fun d_e ->
                    is_integer_constant_expression d_e >>= function
                      | true ->
                          evaluate_integer_constant_expression d_e >>= fun (j, _, _) ->
                          wip_desugar_initializer_ sd elem_ty init >>= fun cst       ->
                          
                          match compare j i with
                            | LT ->
                                E.fail (Errors.Desugar_ConstraintViolation "WIP: find the STD text")
                            | EQ ->
                                E.return (i+1, acc)
                            | GT ->
                                E.return (j+1, cst :: (Global.replicate_list implicit (natFromInteger $ j-i)) ++ acc)
                          end
                      
                      | false ->
                          E.fail (Errors.Desugar_ConstraintViolation "§6.7.9#6")
                    end
(*
                | Just [Desig_member id] ->
*)
                | Nothing ->
                    wip_desugar_initializer_ sd elem_ty init >>= fun cst ->
                    E.return (i+1, cst :: acc)
                | _ ->
                    (* Multi-array designator *)
                    E.fail (Errors.Desugar_NotyetSupported "sucks to be you")
              end
            ) desigs_opt_inits (0, []) >>= fun (_, xs) ->
            E.return $
              ConstantArray (List.reverse (Global.replicate_list implicit (natFromInteger n - List.length xs) ++ xs))
            
(*
        | Struct of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
        | Union of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
*)
        (* NOTE: should be a scalar type *)
        | _ ->
            (* STD §6.7.9#11, sentence 1 *)
            match desigs_opt_inits with
              (* this the "optionnally enclosed in braces" case from (§6.7.9#11, sentence 1) *)
              | [(Nothing, init)] ->
                  wip_desugar_initializer_ sd current_ty init
              | _ ->
                  Boot.assert_false "WIP: error message. is that event a possible case?"
            end
(*
(§6.7.9#11, sentence 1) The initializer for a scalar shall be a single expression, optionally enclosed in braces.

(§6.7.9#11, sentence 2) The initial value of the object is that of the expression (after conversion);

(§6.7.9#11, sentence 3) the same type constraints and conversions as for simple assignment apply, taking the type of the scalar to be the unqualified version of its declared type.
*)



      end
end


(*
and desugar_initializer_ init =
  match init with
    | Init_expr e ->
        desugar_expression e
    | Init_list inits ->
        Boot.assert_false "WIP 58"
  end

and desugar_designator desig =
  match desig with
    | Desig_array e ->
       Boot.assert_false "WIP 59"
    | Desig_member id ->
       Boot.assert_false "WIP 60"
  end
*)


and desugar_and_register_static_assert_declaration sa_decl =
  match sa_decl with
   | Static_assert e lit ->
       desugar_expression e >>= fun d_e ->
       E.register_static_assertion d_e (translate_cabs_string_literal lit)
  end


val desugar_declaration_base: specifiers -> list init_declarator -> E.t (list (identifier * expression unit))
let desugar_declaration_base specifs idecltors =
  desugar_type_specifiers specifs.type_specifiers >>= fun _ty ->
  E.mapM (desugar_init_declarator _ty) idecltors  >>= fun xs  ->
  
  (* for each [init_declarator] *)
    E.foldrM (fun (ident, ty, d_e_opt) acc ->
      let qs = translate_type_qualifiers specifs.type_qualifiers in
      
      if specifs.storage_classes = [SC_typedef] then
        (* Case of a typedef *)
        E.register_identifier ident
          E.Namespace_ordinary E.Kind_typedef specifs.storage_classes >>= fun sym ->
        E.register_typedef sym (qs, ty) >>
        E.return acc
        
      else match ty with
        | ATypes.Function return_ty params is_variadic ->
            E.register_identifier ident
              E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun sym ->
            E.register_function_declaration sym (
              return_ty,
              params,
              is_variadic,
              List.elem FS_inline   specifs.function_specifiers,
              List.elem FS_Noreturn specifs.function_specifiers
            ) >>
            E.return acc
        | _ ->
            E.register_identifier ident
              E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun sym ->
            E.register_internal_object_declaration sym (qs, ty) >>
            match d_e_opt with
              | Just d_e ->
                  E.return ((sym, d_e) :: acc)
              | Nothing ->
                  E.return acc
            end
      end
    ) xs []



(* transforms a Cabs do-while loop into a while-loop + stuff to deal with
   break/continue statements *)
(* substitute break/continue statements that are not enclosed in an inner loop/switch, by
   gotos to given labels *)
(* returns Left if no break/continue was found, Right otherwise *)
val     substitute_naked_break_continue: cabs_identifier -> maybe cabs_identifier -> cabs_statement -> either cabs_statement cabs_statement
let rec substitute_naked_break_continue continue_label break_label_opt stmt =
  let self stmt = substitute_naked_break_continue continue_label break_label_opt stmt in
  match stmt with
    | CabsSlabel id s ->
        either (Left -| CabsSlabel id) (Right -| CabsSlabel id) (self s)
    | CabsScase e s ->
        either (Left -| CabsScase e) (Right -| CabsScase e) (self s)
    | CabsSdefault s ->
        either (Left -| CabsSdefault) (Right -| CabsSdefault) (self s)
    | CabsSblock ss ->
        let ss' = List.map self ss in
        (fun z -> if List.any isRight ss' then Right z else Left z) $
          CabsSblock (List.map (either id id) ss')
    | CabsSif e s1 Nothing ->
        either (fun z -> Left (CabsSif e z Nothing))
               (fun z -> Right (CabsSif e z Nothing)) (self s1)
    | CabsSif e s1 (Just s2) ->
        match (self s1, self s2) with
          | (Left _, Left _) ->
              Left stmt
          | (_s1', _s2') ->
              Right $ CabsSif e (either id id _s1') (Just $ either id id _s2')
        end
    | CabsSswitch e s ->
        (* only look for continue statements, since the break statements are
           enclosed by the switch *)
        either (Left -| CabsSswitch e) (Right -| CabsSswitch e)
          (substitute_naked_break_continue continue_label Nothing stmt)
    | CabsScontinue ->
        Right (CabsSgoto continue_label)
    | CabsSbreak ->
        match break_label_opt with
          | Just break_label ->
              Right (CabsSgoto break_label)
          | Nothing ->
              Left stmt
        end
    | _ ->
        Left stmt
  end


val do_while_hack: cabs_expression -> cabs_statement -> E.t cabs_statement
let do_while_hack e s =
  (* TODO: it would be nice to only generate these names, if they are needed *)
  (* one way would be to have substitute_... generate a function taking label
     names and returning the new statement *)
  E.freshify "continue_" >>= fun continue_label ->
  E.freshify "break_"    >>= fun break_label    ->
  match substitute_naked_break_continue continue_label (Just break_label) s with
    | Left _ ->
        E.return $ CabsSblock [s; CabsSwhile e s]
    | Right s' ->
        E.register_label continue_label >>
        E.register_label break_label    >>
        E.return (
          CabsSblock [s'; CabsSlabel continue_label (CabsSwhile e s); CabsSlabel break_label CabsSnull]
        )
  end

val     desugar_statement: cabs_statement -> E.t (statement Location.t unit)
let rec desugar_statement stmt =
  AnnotatedStatement Location.unknown <$>
    match stmt with
      | CabsSlabel ident s ->
	  AilSlabel <$> E.resolve_label ident
                    <*> desugar_statement s
      
      | CabsScase e s ->
          E.is_inside_switch >>= function
            | true ->
                AilScase <$> (desugar_expression e >>= evaluate_integer_constant_expression)
                         <*> desugar_statement s
            | false ->
                E.fail (Errors.Desugar_ConstraintViolation "§6.8.1#2")
          end
      
      | CabsSdefault s ->
          E.is_inside_switch >>= function
            | true ->
                AilSdefault <$> desugar_statement s
            | false ->
                E.fail (Errors.Desugar_ConstraintViolation "§6.8.1#2")
          end
      
      | CabsSblock ss ->
          (* TODO: STD check + annot *)
          E.with_scope E.Scope_block (
            E.mapM desugar_statement ss
          ) >>= fun (bs, d_ss) ->
          E.return (AilSblock bs d_ss)
      
      | CabsSdecl (Declaration_base specifs idecltors) ->
          AilSdeclaration <$> desugar_declaration_base specifs idecltors
      
      | CabsSdecl (Declaration_static_assert sa_decl) ->
          desugar_and_register_static_assert_declaration sa_decl >>
          (* TODO: hackish *)
          E.return AilSskip
      
      | CabsSnull ->
          E.return AilSskip
      
      | CabsSexpr e ->
          AilSexpr <$> desugar_expression e
      
      | CabsSif e s1 s2_opt ->
          (* TODO: check *)
          AilSif <$> desugar_expression e
                 <*> desugar_statement s1
                 <*> maybe (E.return $ AnnotatedStatement Location.unknown AilSskip) desugar_statement s2_opt
      
      | CabsSswitch e s ->
          (* TODO: check *)
          AilSswitch <$> desugar_expression e
                     <*> E.perform_inside_switch (desugar_statement s)
          
      
      | CabsSwhile e s ->
          (* TODO: check *)
          AilSwhile <$> desugar_expression e
                    <*> E.perform_inside_loop (desugar_statement s)
      
      | CabsSdo e s ->
          (* TODO: check *)
          (* TODO: this is a bit hackish *)
          do_while_hack e s    >>= fun s' ->
          desugar_statement s' >>= fun (AnnotatedStatement _ d_s) ->
          E.return d_s
      
      | CabsSfor (Just (FC_decl ((Declaration_base specifs idecltors)))) e2_opt e3_opt s ->
          (* TODO: this is not really a block scope (...) *)
          E.with_scope E.Scope_block (
            desugar_type_specifiers specifs.type_specifiers >>= fun _ty ->
            E.mapM (desugar_init_declarator _ty) idecltors  >>= fun xs  ->
            
            (* for each [init_declarator] *)
            E.foldrM (fun (ident, ty, d_e_opt) (acc1, acc2) ->
              let qs = translate_type_qualifiers specifs.type_qualifiers in
              
              if not (specifs.storage_classes = []        ||
                      specifs.storage_classes = [SC_auto] ||
                      specifs.storage_classes = [SC_register]) then
                (* NOTE: amusingly, as it is written, the STD doesn't allow the absence of storage-class ... *)
                E.fail (Errors.Desugar_ConstraintViolation "§6.8.5#3")
              
              else match ty with
                | ATypes.Function _ _ _ ->
                    E.fail (Errors.Desugar_ConstraintViolation "§6.8.5#3")
                | _ ->
                    E.register_identifier ident
                      E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun sym ->
                    match d_e_opt with
                      | Just d_e ->
                          E.return ((sym, d_e) :: acc1, (sym, (qs, ty)) :: acc2)
                      | Nothing ->
                          E.return (acc1, acc2)
                    end
              end
            ) xs ([], []) >>= fun (sym_d_es, bs) ->
            
            let e_one = AnnotatedExpression () $
                AilEconst (ConstantInteger (1, Decimal, Nothing)) in
              (* see (§6.8.5.3#2, second sentence) for the Nothing case *)
              maybe (E.return e_one) desugar_expression e2_opt >>= fun d_e2 ->
              E.perform_inside_loop $ desugar_statement s      >>= fun d_s  ->
              
              match e3_opt with
                | Just e3 ->
                    desugar_expression e3 >>= fun d_e3 ->
                    let d_s_e3 = AnnotatedStatement Location.unknown $ AilSexpr d_e3 in
                    
                    let d_s_body = match d_s with
                      | AnnotatedStatement loc (AilSblock bs d_ss) ->
                          AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                      | _ ->
                          AnnotatedStatement Location.unknown $
                            AilSblock [] [d_s; d_s_e3]
                    end in
                    E.return (AilSwhile d_e2 d_s_body)
                
                | Nothing ->
                    E.return (AilSwhile d_e2 d_s)
              end >>= fun d_s_for ->
              
              E.return $
                AilSblock bs [
                  AnnotatedStatement Location.unknown (AilSdeclaration sym_d_es);
                  AnnotatedStatement Location.unknown d_s_for
                ]
          ) >>= fun (_, ret) ->
          E.return ret
      
      | CabsSfor fc_opt e2_opt e3_opt s ->
          let e_one = AnnotatedExpression () $
            AilEconst (ConstantInteger (1, Decimal, Nothing)) in
          (* see (§6.8.5.3#2, second sentence) for the Nothing case *)
          maybe (E.return e_one) desugar_expression e2_opt >>= fun d_e2 ->
          E.perform_inside_loop $ desugar_statement s      >>= fun d_s  ->
          
          match (fc_opt, e3_opt) with
            | (Just (FC_expr e1), Just e3) ->
                desugar_expression e1 >>= fun d_e1 ->
                desugar_expression e3 >>= fun d_e3 ->
                let d_s_e1 = AnnotatedStatement Location.unknown $ AilSexpr d_e1 in
                let d_s_e3 = AnnotatedStatement Location.unknown $ AilSexpr d_e3 in
                
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_s_e1 :: d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Location.unknown $
                        AilSblock [] [d_s_e1; d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
            
            | (Just (FC_decl (Declaration_base _ _)), Just e3) ->
                E.fail Errors.Desugar_impossible
            
            | (Just (FC_decl (Declaration_static_assert sa_decl)), Just e3) ->
                desugar_and_register_static_assert_declaration sa_decl >>
                desugar_expression e3 >>= fun d_e3 ->
                let d_s_e3 = AnnotatedStatement Location.unknown $ AilSexpr d_e3 in
                
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Location.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
            
            | (Nothing, Just e3) ->
                desugar_expression e3 >>= fun d_e3 ->
                let d_s_e3 = AnnotatedStatement Location.unknown $ AilSexpr d_e3 in
                
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Location.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
            
            | (Nothing, Nothing) ->
                E.return (AilSwhile d_e2 d_s)
          end
      
      | CabsSgoto ident ->
          AilSgoto <$> E.resolve_label ident
      
      | CabsScontinue ->
          E.is_inside_loop >>= function
            | true ->
                E.return AilScontinue
            | false ->
                E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.2#1")
          end
      
      | CabsSbreak ->
          E.is_inside_switch >>= fun b1 ->
          E.is_inside_loop   >>= fun b2 ->
          if b1 || b2 then
            E.return AilSbreak
          else
            E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.3#1")
      
      | CabsSreturn Nothing ->
          E.get_current_return_type >>= function
            | ATypes.Void ->
                E.return AilSreturnVoid
            | _ ->
                E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.4#1, 2nd sentence")
          end
      
      | CabsSreturn (Just e) ->
          E.get_current_return_type >>= function
            | ATypes.Void ->
                E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.4#1, 1st sentence")
            | _ ->
                AilSreturn <$> desugar_expression e
          end
    end


val     register_labels: cabs_statement -> E.t unit
let rec register_labels stmt =
  match stmt with
    | CabsSlabel ident s ->
        E.register_label ident
    | CabsScase _ s ->
        register_labels s
    | CabsSdefault s ->
        register_labels s
    | CabsSblock ss ->
        E.mapM_ register_labels ss
    | CabsSdecl _ ->
        E.return ()
    | CabsSnull ->
        E.return ()
    | CabsSexpr _ ->
        E.return ()
    | CabsSif _ s1 s2_opt ->
        register_labels s1 >>
        maybe (E.return ()) register_labels s2_opt
    | CabsSswitch _ s ->
        register_labels s
    | CabsSwhile _ s ->
        register_labels s
    | CabsSdo _ s ->
        register_labels s
    | CabsSfor _ _ _ s ->
        register_labels s
    | CabsSgoto _ ->
        E.return ()
    | CabsScontinue ->
        E.return ()
    | CabsSbreak ->
        E.return ()
    | CabsSreturn _ ->
        E.return ()
  end






(* TODO: check + annotate with STD *)
val desugar_and_register_function_definition: function_definition -> E.t unit
let desugar_and_register_function_definition (FunDef specifs (Declarator ptr_decltor_opt ddecltor) s) =
  if List.any (fun sc -> SC_extern <> sc && SC_static <> sc) specifs.storage_classes then
    E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#4")
  else
    match ddecltor with
      | DDecl_function ddecltor param_tys ->
          maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt >>= fun mk_ptr_type           ->
          desugar_type_specifiers specifs.type_specifiers                >>= fun ty                    ->
          desugar_direct_declarator ddecltor                             >>= fun (fun_ident, mk_ty)    ->
          desugar_parameter_type_list param_tys                          >>= fun (params, is_variadic) ->
          
          (* TODO: this is probably wrong *)
          let return_ty = mk_ptr_type ty in
          
          E.register_identifier fun_ident
            E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun fun_sym ->
          
          E.function_is_defined fun_sym >>= function
            | true  -> E.fail (Errors.Desugar_FunctionRedefinition fun_sym)
            | false -> E.return ()
          end >>
          
          E.void (E.with_scope E.Scope_function (
            register_labels s >>
            E.void (E.with_scope E.Scope_block (
              match params with
                | [(x_opt, (qs, ATypes.Void))] ->
                    if isJust x_opt then
                      E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#5, sentence 1, sub-sentence 4")
                    else if qs <> ATypes.no_qualifiers then
                      E.fail (Errors.Desugar_ConstraintViolation "TODO: find where the Std forbids this")
                    else
                      E.return []
                | _ ->
                    E.mapM (fun (x_opt, (qs, ty)) ->
                      if ty = ATypes.Void then
                        E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#5, void not alone")
                      else match x_opt with
                        | Nothing ->
                            E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#5, sentence 1, sub-sentence 2")
                        | Just (ident, storage_classes) ->
                            E.register_identifier ident E.Namespace_ordinary (E.Kind_object true) storage_classes >>= fun sym ->
                            E.return (sym, (qs, ty))
                      end
                    ) params
              end >>= fun bindings ->
              
              E.register_function_declaration fun_sym (
                return_ty,
                List.map snd bindings,
                is_variadic,
                List.elem FS_inline   specifs.function_specifiers,
                List.elem FS_Noreturn specifs.function_specifiers
               ) >>
              
              E.set_current_return_type return_ty >>
              desugar_statement s                 >>= fun d_s ->
              
              E.register_function_definition fun_sym (List.map fst bindings, d_s)
            ))
          ))
    | _ ->
        E.fail Errors.Desugar_impossible
  end


(*
(* TODO place somewhere else *)
val     extract_typedef_name: list cabs_type_specifier -> list cabs_type_specifier -> string * list cabs_type_specifier
let rec extract_typedef_name specs acc =
  match specs with
    | [] ->
        Boot.assert_false "extract_typedef_name found no TSpec_name"
    | TSpec_name str :: specs' ->
        (str, acc ++ specs')
    | x :: xs ->
        extract_typedef_name xs (x::acc)
  end
*)

val desugar_and_register_external_declaration: external_declaration -> E.t unit
let desugar_and_register_external_declaration edecl =
  let storage_classes =
    maybe [] (fun z -> z.storage_classes) (specifiers_of_external_declaration edecl) in
  
  if List.elem SC_auto storage_classes || List.elem SC_register storage_classes then
    E.fail (Errors.Desugar_ConstraintViolation "§6.9#2")
  else
    match edecl with
      | EDecl_func fdef ->
          let _ = Boot.output_string "EDecl_func" in (* DEBUG *)
          desugar_and_register_function_definition fdef
      
      (* TODO: check *)
      | EDecl_decl (Declaration_base specifs idecltors) ->
          desugar_type_specifiers specifs.type_specifiers >>= fun _ty ->
          E.mapM (desugar_init_declarator _ty) idecltors  >>= fun xs  ->
          
          (* for each [init_declarator] *)
          E.mapM_ (fun (ident, ty, d_e_opt) ->
            let qs = translate_type_qualifiers specifs.type_qualifiers in
            
            if specifs.storage_classes = [SC_typedef] then
              (* Case of a typedef *)
              E.register_identifier ident
                E.Namespace_ordinary E.Kind_typedef specifs.storage_classes >>= fun sym ->
              E.register_typedef sym (qs, ty)
              
            else match ty with
              | ATypes.Function return_ty params is_variadic ->
                  E.register_identifier ident
                    E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun sym ->
                  E.register_function_declaration sym (
                    return_ty,
                    params,
                    is_variadic,
                    List.elem FS_inline   specifs.function_specifiers,
                    List.elem FS_Noreturn specifs.function_specifiers
                  )
              | _ ->
                  E.register_identifier ident
                    E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun sym ->
                  E.register_external_object_declaration sym (qs, ty) >>
                  match d_e_opt with
                    | Just d_e ->
                        E.register_external_object_definition sym d_e
                    | Nothing ->
                        E.return ()
                  end
            end
          ) xs
      
      | EDecl_decl (Declaration_static_assert sa_decl) ->
          desugar_and_register_static_assert_declaration sa_decl
    end


val desugar: cabs_identifier -> translation_unit -> Exception.t (UniqueId.supply Symbol.t * program Location.t unit) Errors.t
let desugar startup_ident (TUnit edecls) =
  E.eval (
    E.with_scope E.Scope_file (
      E.mapM_ desugar_and_register_external_declaration edecls >>
      E.extract_program startup_ident
    ) >>= fun (_, ret) ->
    E.return ret
  )
