open import Global Pervasives Cabs AilSyntax Std

open import Cabs_to_ail_aux
import Cabs_to_ail_effect

import Boot Cabs Multiset Decode UniqueId
import AilSyntaxAux AilTypes AilTypesAux Builtins


module ATypes = AilTypes


module E = Cabs_to_ail_effect

let inline (>>=)    = E.bind

let inline (>>) m f = m >>= fun _ -> f
let inline (<$>)    = E.fmap
let inline (<*>)    = E.app



type declaration_context =
  | Object_decl_context
  | Function_decl_context

instance (Eq declaration_context)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end


val zeroAil': expression' unit
let zeroAil' =
  AilEconst (ConstantInteger (IConstant 0 Octal Nothing))

val oneAil': expression' unit
let oneAil' =
  AilEconst (ConstantInteger (IConstant 1 Decimal Nothing))

val zeroAil: expression unit
let zeroAil =
  AnnotatedExpression () Loc.unknown zeroAil'

val oneAil: expression unit
let oneAil =
  AnnotatedExpression () Loc.unknown oneAil'
























(* inject the given qualifiers to the base of the given ctype *)
val     inject_qualifiers: ATypes.qualifiers -> ATypes.ctype -> (ATypes.qualifiers * ATypes.ctype)
let rec inject_qualifiers qs = function
  | ATypes.Array elem_ty n_opt ->
      (* TODO: check, we loose the qualifiers if elem_ty is not a pointer type *)
      (ATypes.no_qualifiers, ATypes.Array (snd $ inject_qualifiers qs elem_ty) n_opt)
  | ATypes.Function ret_ty params is_variadic ->
      (ATypes.no_qualifiers, ATypes.Function (snd $ inject_qualifiers qs ret_ty) params is_variadic)
  | ATypes.Pointer ref_qs ref_ty ->
      let (ref_qs', ref_ty') = inject_qualifiers qs ref_ty in
      if not (AilTypesAux.is_unqualified ref_qs) && not (AilTypesAux.is_unqualified ref_qs') then
        error "TODO: inject_qualifiers, is that possible?"
      else
        (ATypes.no_qualifiers, ATypes.Pointer (AilTypesAux.combine_qualifiers ref_qs ref_qs') ref_ty')
  | ATypes.Atomic ty' ->
      (ATypes.no_qualifiers, ATypes.Atomic (snd $ inject_qualifiers qs ty'))

(* TODO: not sure at all about struct/union *)
  | (ATypes.Struct _ as ty) ->
      (qs, ty)
  | (ATypes.Union _ as ty) ->
      (qs, ty)
  | ty ->
      (qs, ty)
end



(*

(* STD: sort of defined at ยง6.6#3 *)
val is_constant_expression: expression unit -> E.t bool
let rec is_constant_expression (AnnotatedExpression () loc expr) =
  match expr with
    | AilEassign _ _ ->
        false
    | AilEcompoundAssign _ _ _ ->
        false
    | AilEunary PostfixIncr _ ->
        false
    | AilEunary PostfixDecr _ ->
        false
    | AilEcall _ _ ->
        false
    | AilEbinary _ Comma _ ->
        false
    
    | AilEunary _ e ->
        is_constant_expression e
    | AilEbinary e1 _ e2 ->
        is_constant_expression e1 && is_constant_expression e2
    | AilEcond e1 e2 e3 ->
        is_constant_expression e1 && is_constant_expression e2 && is_constant_expression e3



  end

    | AilEcast of qualifiers * ctype * expression 'A


  | AilEassert of expression 'A
  | AilEoffsetof of ctype * Cabs.cabs_identifier
  | AilEgeneric of expression 'A * list (generic_association 'A)
  
  (* TODO: hackish? *)
  (* TODO: these two don't exist in C (apart from in decl) *)
  | AilEarray of ctype * list (maybe (expression 'A))
  | AilEstruct of identifier * list (Cabs.cabs_identifier * maybe (expression 'A)) (* tag, pairs of member id, expression *)
  
  (* NOTE: the expression obviously need to match the type, and will typically be
           a AilEarray or AilEstruct *)
  | AilEcompound of ctype * expression 'A
  
  
  | AilEmemberof of expression 'A * Cabs.cabs_identifier
  | AilEmemberofptr of expression 'A * Cabs.cabs_identifier
  
  | AilEbuiltin of string (* TODO: see if that can be moved to [constant] *)
  
  | AilEstr of stringLiteral
  | AilEconst of constant
  | AilEident of identifier
  | AilEsizeof of qualifiers * ctype
  | AilEsizeof_expr of expression 'A
  | AilEalignof of qualifiers * ctype
  
  (* NOTE: type annotation on expression, used to remember the type of desugared
           enumeration constants *)
  | AilEannot of ctype * (expression 'A)


*)

















(*
An integer constant expression117) shall have integer type and shall only have operands that are integer constants,

enumeration constants,

character constants,

sizeof expressions whose results are integer constants,

_Alignof expressions,

and floating constants that are the immediate operands of casts. Cast operators in an integer constant expression shall only convert arithmetic types to integer types,

except as part of an operand to the sizeof or _Alignof operator.
*)



(* BEGIN predicates on Ail syntax *)
(* see ยง6.6#6 *)
(* TODO: make the function pure, when complete *)
val     is_integer_constant_expression: expression unit -> E.t bool
let rec is_integer_constant_expression (AnnotatedExpression () loc expr) =
  match expr with
    | AilEunary uop e ->
        match uop with
          | Plus ->
              is_integer_constant_expression e
          | Minus ->
              is_integer_constant_expression e
          | Bnot ->
              is_integer_constant_expression e
          | Address ->
              E.return false
          | Indirection ->
              E.return false
          | PostfixIncr ->
              E.return false
          | PostfixDecr ->
              E.return false
        end
    
    | AilEbinary _ Comma _ ->
        E.return false
    | AilEbinary e1 _ e2 ->
        is_integer_constant_expression e1 >>= fun b1 ->
        if b1 then
          is_integer_constant_expression e2
        else
          E.return false
    
    | AilEassign _ _ ->
        E.return false
    | AilEcompoundAssign _ _ _ ->
        E.return false
    
    | AilEcond _ _ _ ->
        (* TODO: location *)
        E.fail loc (Errors.Desugar_NotyetSupported "conditional operator in `integer constant expressions'")
    
    | AilEcast _ _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "cast operator in `integer constant expressions'")
    
    | AilEcall _ _ ->
        E.return false
    | AilEmemberof _ _ ->
        E.return false
    | AilEmemberofptr _ _ ->
        E.return false
    
    | AilEconst (ConstantInteger _) ->
        E.return true
    | AilEconst (ConstantCharacter _) ->
        E.return true
    
    | AilEident _ ->
        E.return false
    
    | AilEsizeof _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "sizeof operator in `integer constant expressions'")

    | AilEalignof _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "_Alignof operator in `integer constant expressions'")
    | _ ->
        error "WIP: Cabs_to_ail.is_integer_constant_expression, wildcard"
end




(* STD ยง6.6#8 *)
(* TODO: I assume from the "shall only have operands" that arithmetic operations are allowed *)
val     is_arithmetic_constant_expression: expression unit -> E.t bool
let rec is_arithmetic_constant_expression ((AnnotatedExpression () loc expr) as a_expr) =
  (* TODO: enumeration constant *)
  match expr with
    | AilEconst (ConstantInteger _) ->
        E.return true
    | AilEconst (ConstantFloating _) ->
        E.return true
    | AilEconst (ConstantCharacter _) ->
        E.return true
(*
    | AilEconst (ConstantArray _) ->
        (* NOTE: is Ail specific *)
        E.return true
*)

    | AilEunary _ e ->
        is_arithmetic_constant_expression e

    | AilEbinary e1 _ e2 ->
        is_arithmetic_constant_expression e1 >>= fun b1 ->
        is_arithmetic_constant_expression e2 >>= fun b2 ->
        E.return (b1 && b2)

    | AilEsizeof _ ty ->
        (* TODO: sizeof expressions whose results are integer constants *)
        E.return (AilTypesAux.is_vla ty)
    | AilEalignof _ _ ->
        E.return true
    | AilEcast _ ty e ->
        if not (AilTypesAux.is_arithmetic ty) then
          E.return false
        else
          let () = Boot.print_debug 0 "WARNING[Cabs_to_ail.is_arithmetic_constant_expression] AilEcast: annoying ==> need to typecheck e..." in
          E.return true
        
    | _ ->
        E.return false

  end
(*
  An arithmetic constant expression shall have arithmetic type and

  shall only have operands that are:
  
    - integer constants,
    - floating constants,
    - enumeration constants,
    - character constants,
    - sizeof expressions whose results are integer constants,
    - and _Alignof expressions.
  
  Cast operators in an arithmetic constant expression shall only convert arithmetic types to arithmetic types,
  except as part of an operand to a sizeof or _Alignof operator.

*)



(* WIP
val     is_arithmetic_constant_expression: expression unit -> E.t bool
let rec is_arithmetic_constant_expression expr =
  match expr with

  end
*)


val     is_lvalue_to_static_object: expression unit -> E.t bool
let rec is_lvalue_to_static_object (AnnotatedExpression () loc expr) =
  match expr with
    | AilEident sym ->
        E.fetch_object_declaration sym >>= fun (dur, _, _) ->
        match dur with
          | ATypes.Static ->
              E.return true
          | _ ->
              E.return false
        end


(* The array-subscript [] and member-access . and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators. *)
    | AilEbinary e1 (Arithmetic Add) e2 ->
        (* NOTE: this case corresponds to array-subcript *)
        is_lvalue_to_static_object e1        >>= fun b11 ->
        is_arithmetic_constant_expression e1 >>= fun b12 ->
        is_lvalue_to_static_object e2        >>= fun b21 ->
        is_arithmetic_constant_expression e2 >>= fun b22 ->
        E.return (b11 && b22 || b12 && b21)
(* TODO
    | AilEmemberof e ident ->
        
    | AilEmemberofptr e ident ->
*)
    | _ ->
        E.return false
  end



(* STD ยง6.6#9 *)
val is_address_constant: expression unit -> E.t bool
let is_address_constant a_expr =
  (* TODO: not sure is_null_pointer_constant is the right predicate *)
  (* An address constant (...) *)
  if AilSyntaxAux.is_null_pointer_constant a_expr then
    (* (...) is a null pointer, *)
    E.return true
  
  else match a_expr with
    | AnnotatedExpression () loc (AilEunary Address expr) ->
        is_lvalue_to_static_object expr
    | _ ->
        E.return false
  end

(*
match expr with
    (* (...) a pointer to an lvalue designating an object of static storage
       duration, or a pointer to a function designator; (...) *)
    | AilEunary Address (AnnotatedExpression () loc' (AilEident sym)) ->
        (* (...) it shall be created explicitly using the unary & operator (...) *)
        E.fetch_object_declaration sym >>= fun (dur, _, _) ->
        match dur with
          | ATypes.Static ->
              E.return true
          | _ ->
              E.return false
        end
    
    | AilEcast _ ty (AnnotatedExpression () loc' (AilEconst (ConstantInteger _))) ->
        (* (...) an integer constant cast to pointer type, (...) *)
        E.return (AilTypesAux.is_pointer ty)
    
    | _ ->
        E.return false
        (* TODO *)
(*
or implicitly by the use of an expression of array or function type.

The array-subscript [] and member-access . and -> operators, the address & and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators.
*)

  end
*)


(* STD ยง6.6#7 *)
(* TODO: "or evaluate to" *)
val is_initializer_constant_expression: expression unit -> E.t bool
let is_initializer_constant_expression a_expr =
  is_arithmetic_constant_expression a_expr >>= fun b1 ->
  is_address_constant a_expr               >>= fun b2 ->
  if b1 || AilSyntaxAux.is_null_pointer_constant a_expr || b2 then
    E.return true
  
  else match a_expr with
    | AnnotatedExpression () loc (AilEbinary e1 (Arithmetic Add) e2) ->
        is_address_constant e1            >>= fun b11 ->
        is_integer_constant_expression e2 >>= fun b12 ->
        is_address_constant e2            >>= fun b21 ->
        is_integer_constant_expression e1 >>= fun b22 ->
        E.return (b11 && b12 || b21 && b22)
    | AnnotatedExpression () loc (AilEbinary e1 (Arithmetic Sub) e2) ->
        is_address_constant e1            >>= fun b11 ->
        is_integer_constant_expression e2 >>= fun b12 ->
        is_address_constant e2            >>= fun b21 ->
        is_integer_constant_expression e1 >>= fun b22 ->
        E.return (b11 && b12 || b21 && b22)
    | _ ->
        E.return false
  end
(* END predicates on Ail syntax *)

































val desugar_generic_association:        cabs_generic_association -> E.t (generic_association unit)
(* val desugar_declaration:                declaration -> E.t (list (sigma_declaration Loc.t unit)) *)
val desugar_specifiers:                 declaration_context -> E.scope -> specifiers -> E.t unit (* TODO *)
val desugar_init_declarator:            ATypes.ctype -> list storage_class_specifier -> init_declarator ->
                                        E.t (cabs_identifier * ATypes.qualifiers * ATypes.ctype * maybe (expression unit))
val desugar_struct_declaration:         struct_declaration -> E.t (list (cabs_identifier * ATypes.ctype))

val desugar_struct_declarator:          struct_declarator -> E.t (cabs_identifier * ATypes.qualifiers * (ATypes.ctype -> ATypes.ctype)) (* TODO *)
val desugar_enumerator:                 enumerator -> E.t unit (* TODO *)
val desugar_alignment_specifier:        alignment_specifier -> E.t unit (* TODO *)

(* NOTE: these twos functions do NOT register identifier being declared, this is
         left to the called (who can know the `kind' of the identifier from its
         type *)
val desugar_declarator:                 declarator        -> E.t (cabs_identifier * ATypes.qualifiers * (ATypes.ctype -> ATypes.ctype))
val desugar_direct_declarator:          direct_declarator -> E.t (cabs_identifier (* * ATypes.qualifiers *) * (ATypes.ctype -> ATypes.ctype))


val desugar_array_declarator:           bool -> array_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)
val desugar_parameter_array_declarator: array_declarator -> E.t unit (* TODO *)
val desugar_array_declarator_size:      array_declarator_size -> E.t unit (* TODO *)
val desugar_pointer_declarator:         pointer_declarator -> E.t (ATypes.qualifiers * (ATypes.ctype -> ATypes.ctype))
val desugar_parameter_type_list:        parameter_type_list -> E.t (list (maybe (cabs_identifier * list storage_class_specifier) *
                                                                          (ATypes.qualifiers * ATypes.ctype)) * bool)
val desugar_parameter_declaration:      parameter_declaration -> E.t (maybe (cabs_identifier * list storage_class_specifier) *
                                                                      (ATypes.qualifiers * ATypes.ctype))


val desugar_type_name:                  type_name -> E.t (ATypes.qualifiers * AilTypes.ctype)
val desugar_abstract_declarator:        bool -> abstract_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)
val desugar_direct_abstract_declarator: bool -> direct_abstract_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)


val desugar_initializer_:               initializer_ -> E.t (expression unit) (* TODO *)
val desugar_designator:                 designator -> E.t unit (* TODO *)

val desugar_and_register_static_assert_declaration:  static_assert_declaration -> E.t unit

val desugar_for_clause:                 for_clause -> E.t unit (* TODO *)

(* TODO: WIP *)
val wip_desugar_initializer_: ATypes.storageDuration -> ATypes.ctype -> initializer_ -> E.t (expression unit)
val static_thread_implicit_initializer: map identifier E.tag_definition -> ATypes.ctype -> constant



































val translate_integer_suffix: cabs_integer_suffix -> integerSuffix
let translate_integer_suffix = function
  | CabsSuffix_U   -> U
  | CabsSuffix_UL  -> UL
  | CabsSuffix_ULL -> ULL
  | CabsSuffix_L   -> L
  | CabsSuffix_LL  -> LL
end


val translate_integer_constant: cabs_integer_constant -> integerConstant
let translate_integer_constant (str, suff_opt) =
  let (basis, n) = Decode.decode_integer_constant str in
  match suff_opt with
    | Just suff -> IConstant n basis (Just (translate_integer_suffix suff))
    | Nothing   -> IConstant n basis Nothing
  end


val translate_character_constant: cabs_character_prefix -> characterPrefix
let translate_character_constant = function
  | CabsPrefix_L -> Pref_L
  | CabsPrefix_u -> Pref_u
  | CabsPrefix_U -> Pref_U
end


val desugar_character_constant: cabs_character_constant -> E.t characterConstant
let desugar_character_constant (pref_opt, str) =
  E.return (maybe Nothing (Just -| translate_character_constant) pref_opt, str)










(* TODO: this is very partial for now *)
val     evaluate_integer_constant_expression: Loc.t -> expression unit -> E.t integerConstant
let rec evaluate_integer_constant_expression loc (AnnotatedExpression () _(*TODO: get rid of the other loc? *) expr) =
  match expr with
    | AilEunary uop e ->
(*
        evaluate_integer_constant_expression e >>= fun ((n, b, suff_opt) as iCst) ->
        match uop with
          | Plus ->
              E.return iCst
          | Minus ->
              E.return (0-n)
          | Bnot ->
              E.fail Loc.unknown (Errors.Desugar_NotyetSupported "Bnot operator in `integer constant expressions'")
        end
*)
        E.fail loc (Errors.Desugar_NotyetSupported "unary operator in `integer constant expressions'")
    | AilEbinary e1 _ e2 ->
        E.fail loc (Errors.Desugar_NotyetSupported "binary operator in `integer constant expressions'")
    | AilEcond _ _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "conditional operator in `integer constant expressions'")
    | AilEcast _ _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "cast operator in `integer constant expressions'")
    | AilEconst (ConstantInteger iCst) ->
        E.return iCst
    | AilEconst (ConstantCharacter _) ->
        E.fail loc (Errors.Desugar_NotyetSupported "character constant in `integer constant expressions'")
    | AilEsizeof _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "sizeof operator in `integer constant expressions'")
    | AilEalignof _ _ ->
        E.fail loc (Errors.Desugar_NotyetSupported "_Alignof operator in `integer constant expressions'")
    (* Not dealing with an integer constant expression *)
    | _ ->
        E.fail loc Errors.Desugar_impossible
  end

























val translate_unary_operator: cabs_unary_operator -> unaryOperator
let translate_unary_operator = function
  | CabsAddress     -> Address
  | CabsIndirection -> Indirection
  | CabsPlus        -> Plus
  | CabsMinus       -> Minus
  | CabsBnot        -> Bnot
  (* This case cannot occurs since Not is translated away. *)
  | CabsNot         -> error "[Cabs_to_ail.translate_unary_operator] Not"
end


val translate_arithmetic_operator: cabs_binary_operator -> arithmeticOperator
let translate_arithmetic_operator = function
  | CabsAdd  -> Add
  | CabsSub  -> Sub
  | CabsMul  -> Mul
  | CabsDiv  -> Div
  | CabsMod  -> Mod
  | CabsBand -> Band
  | CabsBxor -> Bxor
  | CabsBor  -> Bor
  | CabsShl  -> Shl
  | CabsShr  -> Shr
  | _ -> error "[Cabs0_to_ail.translate_arithmetic_operator] should only be called on \
                operators allowed for compound assignments [ยง6.5.16#1]."
end


val translate_binary_operator: cabs_binary_operator -> binaryOperator
let translate_binary_operator = function
  | CabsAnd   -> And
  | CabsOr    -> Or
  | CabsEq    -> Eq
  | CabsNe    -> Ne
  | CabsLt    -> Lt
  | CabsGt    -> Gt
  | CabsLe    -> Le
  | CabsGe    -> Ge
  | op      -> Arithmetic (translate_arithmetic_operator op)
end


val translate_assignment_operator: cabs_assignment_operator -> maybe arithmeticOperator
let translate_assignment_operator = function
  | Assign      -> Nothing
  | Assign_Mul  -> Just Mul
  | Assign_Div  -> Just Div
  | Assign_Mod  -> Just Mod
  | Assign_Add  -> Just Add
  | Assign_Sub  -> Just Sub
  | Assign_Shl  -> Just Shl
  | Assign_Shr  -> Just Shr
  | Assign_Band -> Just Band
  | Assign_Bxor -> Just Bxor
  | Assign_Bor  -> Just Bor
end

(* TODO
val translate_storage_class_specifier: C.storage_class_specifier -> 
let translate_storage_class_specifier = function
  | C.SC_typedef
  | C.SC_extern
  | C.SC_static
  | C.SC_Thread_local
  | C.SC_auto
  | C.SC_register
end
*)






val desugar_cabs_constant: Loc.t -> cabs_constant -> E.t constant
let desugar_cabs_constant loc = function
  | CabsInteger_const iCst ->
      E.return (ConstantInteger (translate_integer_constant iCst))
  | CabsFloating_const str ->
      E.return (ConstantFloating str)
  | CabsEnumeration_const ->
      E.fail loc (Errors.Desugar_NotyetSupported "WIP: desugar_cabs_constant, CabsEnumeration_const")
  | CabsCharacter_const cCst ->
      desugar_character_constant cCst >>= fun d_cCst ->
      E.return (ConstantCharacter d_cCst)
end


val translate_cabs_encoding_prefix: cabs_encoding_prefix -> encodingPrefix
let translate_cabs_encoding_prefix = function
  | CabsEncPrefix_u8 ->
      Enc_u8
  | CabsEncPrefix_u ->
      Enc_u
  | CabsEncPrefix_U ->
      Enc_U
  | CabsEncPrefix_L ->
      Enc_L
end

val translate_cabs_string_literal: cabs_string_literal -> stringLiteral
let translate_cabs_string_literal (pref_opt, str) =
   (maybe Nothing (Just -| translate_cabs_encoding_prefix) pref_opt, str)




val is_simple_enumerator: enumerator -> bool
let is_simple_enumerator = function
  | (_, Nothing) ->
      true
  | _ ->
      false
end

val register_simple_enumerators: ATypes.ctype -> list enumerator -> E.t unit
let register_simple_enumerators ty enums =
  if List.all is_simple_enumerator enums then
    let register_simple_enumerator (n, (ident, _ (* Nothing *) (* TODO: wtf ?? *))) =
      (* NOTE: numerote starts counting from 1 *)
      let n = n-1 in
      
      let expr =
        let basis = if n = 0 then Octal else Decimal in
        AilEannot ty (
          AnnotatedExpression () Loc.unknown(* TODO *) (AilEconst (ConstantInteger (IConstant (integerFromNat n) basis Nothing)))
        ) in
      
      E.register_identifier ident E.Namespace_ordinary (E.Kind_member E.Kind_enum) [] >>= fun (_, sym) ->
      E.register_enum_constant sym expr in
    
    E.mapM_ register_simple_enumerator $ numerote enums
  else
    E.fail Loc.unknown (Errors.Desugar_NotyetSupported "enum constants with expressions")







val project_base_type_specifier: cabs_type_specifier -> cabs_base_type_specifier
let project_base_type_specifier = function
  | TSpec_void ->
      BTSpec_void
  | TSpec_char ->
      BTSpec_char
  | TSpec_short ->
      BTSpec_short
  | TSpec_int ->
      BTSpec_int
  | TSpec_long ->
      BTSpec_long
  | TSpec_float ->
      BTSpec_float
  | TSpec_double ->
      BTSpec_double
  | TSpec_signed ->
      BTSpec_signed
  | TSpec_unsigned ->
      BTSpec_unsigned
  | TSpec_Bool ->
      BTSpec_Bool
  | TSpec_Complex ->
      BTSpec_Complex
  | _ ->
      error "Cabs_to_ail.project_base_type_specifier found a non-base specifier"
 end

val unproject_base_type_specifier: cabs_base_type_specifier -> cabs_type_specifier
let unproject_base_type_specifier = function
  | BTSpec_void ->
      TSpec_void
  | BTSpec_char ->
      TSpec_char
  | BTSpec_short ->
      TSpec_short
  | BTSpec_int ->
      TSpec_int
  | BTSpec_long ->
      TSpec_long
  | BTSpec_float ->
      TSpec_float
  | BTSpec_double ->
      TSpec_double
  | BTSpec_signed ->
      TSpec_signed
  | BTSpec_unsigned ->
      TSpec_unsigned
  | BTSpec_Bool ->
      TSpec_Bool
  | BTSpec_Complex ->
      TSpec_Complex
 end



val desugar_basic_type_specifiers: Multiset.t cabs_base_type_specifier -> E.t (ATypes.basicType)
let desugar_basic_type_specifiers specs =
_STD "ยง6.7.2#2, sentence 2 (non `void' case)" $
  if      specs = Multiset.from_list [BTSpec_char] then
    (* STD ยง6.7.2#2, item 2 *)
    E.return $ ATypes.Integer ATypes.Char
  else if specs = Multiset.from_list [BTSpec_signed; BTSpec_char] then
    (* STD ยง6.7.2#2, item 3 *)
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Ichar)
  else if specs = Multiset.from_list [BTSpec_unsigned; BTSpec_char] then
    (* STD ยง6.7.2#2, item 4 *)
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Ichar)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_short];
            Multiset.from_list [BTSpec_signed; BTSpec_short];
            Multiset.from_list [BTSpec_short; BTSpec_int];
            Multiset.from_list [BTSpec_signed; BTSpec_short; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 5 *)
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_unsigned; BTSpec_short];
            Multiset.from_list [BTSpec_unsigned; BTSpec_short; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 6 *)
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_int];
            Multiset.from_list [BTSpec_signed];
            Multiset.from_list [BTSpec_signed; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 7 *)
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_unsigned];
            Multiset.from_list [BTSpec_unsigned; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 8 *)
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_long];
            Multiset.from_list [BTSpec_signed; BTSpec_long];
            Multiset.from_list [BTSpec_long; BTSpec_int];
            Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_int] ]then
    (* STD ยง6.7.2#2, item 9 *)
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_unsigned; BTSpec_long];
            Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 10 *)
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_long; BTSpec_long];
            Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_long];
            Multiset.from_list [BTSpec_long; BTSpec_long; BTSpec_int];
            Multiset.from_list [BTSpec_signed; BTSpec_long; BTSpec_long; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 11 *)
    E.return $ ATypes.Integer (ATypes.Signed ATypes.LongLong)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_long];
            Multiset.from_list [BTSpec_unsigned; BTSpec_long; BTSpec_long; BTSpec_int] ] then
    (* STD ยง6.7.2#2, item 12 *)
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.LongLong)
  else if specs = Multiset.from_list [BTSpec_float] then
    (* STD ยง6.7.2#2, item 13 *)
    E.return $ ATypes.Floating (ATypes.RealFloating ATypes.Float)
  else if specs = Multiset.from_list [BTSpec_double] then
    (* STD ยง6.7.2#2, item 14 *)
    E.return $ ATypes.Floating (ATypes.RealFloating ATypes.Double)
  else if specs = Multiset.from_list [BTSpec_long; BTSpec_double] then
    (* STD ยง6.7.2#2, item 15 *)
    E.return $ ATypes.Floating (ATypes.RealFloating ATypes.LongDouble)
  else if specs = Multiset.from_list [BTSpec_Bool] then
    (* STD ยง6.7.2#2, item 16 *)
    E.return $ ATypes.Integer (ATypes.Bool)
  else if specs = Multiset.from_list [BTSpec_float; BTSpec_Complex] then
    (* STD ยง6.7.2#2, item 17 *)
    E.fail Loc.unknown $ Errors.Desugar_NeverSupported "_Complex types"
  else if specs = Multiset.from_list [BTSpec_double; BTSpec_Complex] then
    (* STD ยง6.7.2#2, item 18 *)
    E.fail Loc.unknown $ Errors.Desugar_NeverSupported "_Complex types"
  else if specs = Multiset.from_list [BTSpec_long; BTSpec_double; BTSpec_Complex] then
    (* STD ยง6.7.2#2, item 19 *)
    E.fail Loc.unknown $ Errors.Desugar_NeverSupported "_Complex types"
  else
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.2#2, 2nd sentence")


val translate_type_qualifiers: list cabs_type_qualifier -> ATypes.qualifiers
let translate_type_qualifiers qs =
_STD "ยง6.7.3#5" $
  ATypes.make_qualifiers
    (List.elem Q_const qs) (List.elem Q_restrict qs)
    (List.elem Q_volatile qs) (List.elem Q_Atomic qs)


val     desugar_type_specifiers : list cabs_type_specifier -> E.t (ATypes.qualifiers * ATypes.ctype)
let rec desugar_type_specifiers specs =
  match specs with
  | [] ->
_STD "ยง6.7.2#2, sentence 1"
      E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.2#2, 1st sentence")
  
  | [TSpec_void] ->
_STD "ยง6.7.2#2, sentence 2 (`void' case)"
      E.return (ATypes.no_qualifiers, ATypes.Void)
  
  | [TSpec_struct Nothing Nothing] ->
      error "WIP: TSpec_struct Nothing, Nothing"
  
  | [TSpec_struct tag_ident_opt sdecls_opt] ->
      (* ยง6.7.2.3#7 *)
      E.register_tag Loc.unknown tag_ident_opt >>= fun tag_sym ->
      
      match sdecls_opt with
        | Just sdecls ->
            E.mapM desugar_struct_declaration sdecls >>= fun xs ->
            (* TODO: hum, a bit silly here *)
            (* TODO: not silly ==> catch redefinitions *)
            E.register_tag_definition Loc.unknown tag_sym (E.Struct_definition $ List.concat xs) >>
            E.return (ATypes.no_qualifiers, ATypes.Struct tag_sym)
(*
            E.resolve_tag_definition tag_sym >>= function
              | E.Struct_definition xs ->
                  (* TODO: qs? *)
                  E.return (ATypes.no_qualifiers, ATypes.Struct tag_sym xs)
              | _ ->
                  error "desugar_type_specifiers: expecting a Struct_declarations"
            end
*)

        | Nothing ->
            (* TODO: bogus? *)
            E.return (ATypes.no_qualifiers, ATypes.Struct tag_sym)
      end
  
  
  | [TSpec_union tag_ident_opt sdecls_opt] ->
      (* ยง6.7.2.3#7 *)
      E.register_tag Loc.unknown tag_ident_opt >>= fun tag_sym ->
      
      match sdecls_opt with
        | Just sdecls ->
            E.mapM desugar_struct_declaration sdecls >>= fun xs ->
            (* TODO: hum, a bit silly here *)
            (* TODO: not silly ==> catch redefinitions *)
            E.register_tag_definition Loc.unknown tag_sym (E.Union_definition $ List.concat xs) >>
            E.return (ATypes.no_qualifiers, ATypes.Union tag_sym)
        | Nothing ->
            (* TODO: bogus? *)
            E.return (ATypes.no_qualifiers, ATypes.Union tag_sym)
      end


  
(*
      (* NOTE: in this case the struct type has already been declared *)
      E.resolve_identifier ident E.Namespace_tag >>= function
        | Just (_, (tag_sym, E.Kind_tag members, _)) ->
            E.return (ATypes.Struct tag_sym members)
        | Nothing ->
            E.fail Loc.unknown (Errors.Desugar_OtherViolation "Couldn't resolve a struct identifier") (* TODO: check if this id the proper quote *)
      end
*)



(*
  | [TSpec_struct Nothing (Just sdecls)] ->
      (* ยง6.7.3.2#5, sentence 2 *)
      E.foldrM (fun z acc ->
        desugar_struct_declaration z >>= fun xs ->
        E.return (xs ++ acc)
      ) sdecls []    >>= fun members ->
      E.fresh_symbol >>= fun tag_sym ->
      E.register_tag_declaration tag_sym (E.Struct_declaration members) >>
      E.return (ATypes.Struct tag_sym members)

  | [TSpec_struct ident_opt (Just sdecls)] ->
      (* TODO: check std *)
      E.foldrM (fun z acc ->
        desugar_struct_declaration z >>= fun xs ->
        E.return (xs ++ acc)
      ) sdecls [] >>= fun members ->
      maybe (E.register_unamed) (fun ident ->
        E.register_identifier ident E.Namespace_tag (E.Kind_tag members) [(* TODO: check *)]
      ) ident_opt >>= fun tag_sym ->
      E.return (ATypes.Struct tag_sym members)
*)


(*
 | Struct of list (identifier * ctype) (* TODO: no bitfields for now *)
*)

(*
TSpec_struct of maybe cabs_identifier * maybe (list struct_declaration)


and struct_declaration =
  | Struct_declaration of list cabs_type_specifier * list cabs_type_qualifier * list struct_declarator
  | Struct_assert      of static_assert_declaration


*)
  
  
  | [TSpec_Atomic tyname] ->
      desugar_type_name tyname >>= fun (qs, ty) ->
      (* STD ยง6.7.2.4#3, the type name shall not refer to a qualified type *)
      if not (AilTypesAux.is_unqualified qs) then
        E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.2.4#3, qualified type")
      else
        (* TODO: qualifiers *)
        E.return (qs, ATypes.Atomic ty)

  (* TODO: partial *)
  | [TSpec_enum (Just ident) enums_opt] ->
      E.register_identifier ident E.Namespace_tag E.Kind_tag [] >>= fun (_, sym) ->
      let ty = ATypes.Basic (ATypes.Integer (ATypes.Enum sym)) in
      maybe (E.return ()) (register_simple_enumerators ty) enums_opt >>
      E.return (ATypes.no_qualifiers, ty)


(*  WIP

  
  | [TSpec_Atomic tyname] -> do E
      (qs, ty) <- desugar_type_name tyname; in
        E.return (ATypes.Atomic ty)
      end

  | [TSpec_struct id_opt sdecls_opt] ->
      error "TODO"
  
  | [TSpec_union id_opt sdecls_opt] ->
      error "TODO"
  
  | [TSpec_enum id_opt enums_opt] ->
      error "TODO"
  
    (* TODO: this break impl-def independance *)
  | [TSpec_name str] ->
      match Builtins.translate_builtin_typenames str with
        | Just ty ->
            E.return ty
        | Nothing ->
            (* TODO [tmp hack] removing the qualifiers *)
            E.get_typedef str >>= fun (qs, ty) ->
            E.return ty
      end
*)  
  
  (* *)
  | [TSpec_name ((CabsIdentifier loc str) as ident)] ->
      E.print_debug 2 ("Cabs_to_ail, TSpec_name ==> " ^ str) >>
      match Builtins.translate_builtin_typenames str with
        | Just ty ->
            E.return (ATypes.no_qualifiers, ty)
        | Nothing ->
            (* TODO: check the namespace *)
            E.resolve_identifier ident E.Namespace_ordinary >>= function
              | Just (_, (sym, E.Kind_typedef, _)) ->
                  E.resolve_typedef sym >>= fun (qs, ty) ->
                  E.return (qs, ty)
              | _ ->
                  E.fail loc (Errors.Desugar_NotyetSupported "WIP: error case 1115")
            end
      end
  | ss ->
      desugar_basic_type_specifiers (Multiset.from_list $ List.map project_base_type_specifier ss) >>= fun bty ->
      E.return (ATypes.no_qualifiers, ATypes.Basic bty)
end












(*
int                                     int
int *                                   pointer to int
int *[3]                                array of three pointers to int
int ( * )[3]                            pointer to an array of three ints
int ( * )[*]                            pointer to a variable length array of an unspecified number of ints,
int *()                                 function with no parameter specification returning a pointer to int
int ( * )(void)                         pointer to function with no parameters returning an int
int ( * const [])(unsigned int, ...)    array of an unspecified number of constant pointers to functions, each with
                                        one parameter that has type unsigned int and an unspecified number of other
                                        parameters, returning an int.



*)













































(* val     desugar_expression: cabs_expression -> E.t (expression unit) *)
and desugar_expression (CabsExpression loc expr) =
  AnnotatedExpression () loc <$>
  match expr with
    | CabsEident ident ->
        let (CabsIdentifier _ str) = ident in (* DEBUG *)
        let _ = Boot.print_debug 2 ("DESUGARING, CabsEident: " ^ str) in (* DEBUG *)
_STD "ยง6.5.1#2" $
        E.resolve_identifier ident E.Namespace_ordinary >>= function
          | Just (_, (id, E.Kind_member E.Kind_enum, _)) ->
              E.resolve_enum_constant id
          | Just (_, (id, kind, _)) ->
              (* I love the fact that it is a footnote that says that undeclared
                 identifiers are syntax errors ... *)
              if not (E.is_object_kind kind || kind = E.Kind_function) then
                E.fail (Loc.locOf ident) (Errors.Desugar_OtherViolation "ยง6.5.1#2")
              else
                E.add_used_identifier id >>
                E.return (AilEident id)
          | Nothing ->
              match Builtins.translate_builtin_varnames ident with
                | Just (d_e, _) ->
                    E.return d_e
                | Nothing ->
                    E.fail (Loc.locOf ident)
                      (Errors.Desugar_OtherViolation ("ยง6.5.1#2, Nothing, Nothing: " ^ str)) (* TODO: check the quote *)
              end
        end
    
    | CabsEconst cst ->
        AilEconst <$> desugar_cabs_constant loc cst
    | CabsEstring lit ->
        E.return (AilEstr $ translate_cabs_string_literal lit)
    | CabsEgeneric e gas ->
        AilEgeneric <$> desugar_expression e
                    <*> E.mapM desugar_generic_association gas
    
    | CabsEsubscript e1 e2 ->
_STD "ยง6.5.2.1#2, sentence 2" $
        AilEunary Indirection <$> (
          AnnotatedExpression () loc <$>
          (AilEbinary <$> desugar_expression e1
                      <*> E.return (Arithmetic Add)
                      <*> desugar_expression e2)
        )
    | CabsEcall e es ->
        (* TODO: STD check + annot *)
        AilEcall <$> desugar_expression e <*> E.mapM desugar_expression es
    | CabsEmemberof e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberof <$> desugar_expression e <*> (E.return ident)
    | CabsEmemberofptr e ident ->
        (* NOTE: we don't desugar the field name here because we need to know the type of [e] ... *)
        AilEmemberofptr <$> desugar_expression e <*> (E.return ident)
    | CabsEpostincr e ->
        AilEunary PostfixIncr <$> desugar_expression e
    | CabsEpostdecr e ->
        AilEunary PostfixDecr <$> desugar_expression e
    | CabsEcompound tyname inits ->
        desugar_type_name tyname >>= fun (qs, ty) ->
        (* TODO: qualifier? *) (* TODO check *)
        (* TODO: the storage duration is wrong here, if we are inside the body of a function, it should be automatic *)
        AilEcompound ty <$> wip_desugar_initializer_ ATypes.Static ty (Init_list inits)
    | CabsEpreincr e ->
_STD "ยง6.5.3.1#2, sentence 3" $
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Add oneAil
    | CabsEpredecr e ->
_STD "ยง6.5.3.1#3" $
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Sub oneAil

      (* (ยง6.5.3.3#5) *)
    | CabsEunary CabsNot e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEbinary zeroAil Eq d_e
    
    | CabsEunary uop e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEunary (translate_unary_operator uop) d_e
    | CabsEsizeof_expr e ->
        AilEsizeof_expr <$> desugar_expression e
    | CabsEsizeof_type tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEsizeof qs ty
    | CabsEalignof tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEalignof qs ty
    | CabsEcast tyname e ->
        (* TODO: check *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        desugar_expression e     >>= fun d_e      ->
        E.return (AilEcast qs ty d_e)
    
    | CabsEbinary bop e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return (translate_binary_operator bop)
                   <*> desugar_expression e2
    | CabsEcond e1 e2 e3 ->
        AilEcond <$> desugar_expression e1
                 <*> desugar_expression e2
                 <*> desugar_expression e3
    | CabsEassign aop e1 e2 ->
        match translate_assignment_operator aop with
          | Nothing  -> AilEassign
          | Just aop -> (fun z -> AilEcompoundAssign z aop)
        end <$> desugar_expression e1
            <*> desugar_expression e2
    | CabsEcomma e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return Comma
                   <*> desugar_expression e2
    | CabsEassert e ->
        AilEassert <$> desugar_expression e
    | CabsEoffsetof tyname ident ->
        (* TODO: do something with the qualifiers? *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return (AilEoffsetof ty ident)
    | CabsEva_start e (CabsIdentifier loc str as ident) ->
        desugar_expression e                                       >>= fun d_e ->
        desugar_expression (CabsExpression loc (CabsEident ident)) >>= function
          | AnnotatedExpression _ _ (AilEident sym) ->
              E.return (AilEva_start d_e sym)
          | _ ->
              E.fail Loc.unknown (Errors.Desugar_TODOCTOR "the second operand of va_start() was not paramN")
        end
    | CabsEva_arg e tyname ->
        (* TODO: do something with the qualifiers? *)
        desugar_expression e     >>= fun d_e      ->
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return (AilEva_arg d_e ty)
  end

and desugar_generic_association gas =
  match gas with
    | GA_type tyname e ->
        desugar_type_name tyname >>= fun (_, ty) ->
        (* TODO: (ยง6.5.1.1#2, sentence 2), ty must be complete and not variably modified *)
        desugar_expression e     >>= fun d_e     ->
        E.return (AilGAtype ty d_e)
    | GA_default e ->
        AilGAdefault <$> desugar_expression e
  end






and desugar_specifiers decl_ctxt scope specifs =
  let scs = specifs.storage_classes in
  if not (List.length scs <= 1 || List.elem SC_Thread_local scs &&
                                  (List.elem SC_static scs || List.elem SC_extern scs))then
_STD "ยง6.7.1#2" $
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.1#2")
  
  else if not (decl_ctxt = Object_decl_context && E.is_block_scope scope &&
               List.elem SC_Thread_local scs -->
                 (List.elem SC_static scs || List.elem SC_extern scs)
              ) then
_STD "ยง6.7.1#3, sentence 1" $
         E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.1#3, 1st sentence")
  
  else if decl_ctxt = Function_decl_context && List.elem SC_Thread_local scs then
_STD "ยง6.7.1#4" $
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.1#4")
  
  else if not (decl_ctxt = Function_decl_context && E.is_block_scope scope -->
               scs = [] || scs = [SC_extern]) then
_STD "ยง6.7.1#7" $
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.1#7")
  else
_STD "ยง6.7.1#8" $ (* TODO *)
    error "WIP 33"

(*
<|
  C.storage_classes:      list storage_class_specifier;
  C.type_specifiers:      list type_specifier;
  C.type_qualifiers:      list type_qualifier;
  C.function_specifiers:  list function_specifier;
  C.alignment_specifiers: list alignment_specifier;
|>
*)

(* TODO: check *)
(* E.t (cabs_identifier * ATypes.qualifiers * ATypes.ctype * maybe (expression unit)) *)
and desugar_init_declarator _ty scs idecltor =
  match idecltor with
    | InitDecl decltor Nothing ->
        desugar_declarator decltor >>= fun (ident, qs, mk_ty) ->
        E.return (ident, qs, mk_ty _ty, Nothing)
    | InitDecl decltor (Just init) ->
        desugar_declarator decltor >>= fun (ident, qs, mk_ty) ->
        let ty = mk_ty _ty in
        
        (* TODO: check that we really never have parameter objects here *)
        let kind = if AilTypesAux.is_function ty then E.Kind_function else E.Kind_object false in
        (* TODO: I don't like the fact that we are using this function directly here *)
        E.determinate_linkage ident E.Namespace_ordinary kind scs >>= fun link ->
        wip_desugar_initializer_ (determinate_storage_duration link scs) ty init  >>= fun d_e ->
        E.return (ident, qs, ty, Just d_e)
  end



(* val desugar_struct_declaration:         struct_declaration -> E.t (list (cabs_identifier * ATypes.ctype)) *)
and desugar_struct_declaration struct_decl =
  match struct_decl with
    | Struct_declaration specs qs sdecltors ->
        (* TODO: qualifiers *)
        desugar_type_specifiers specs >>= fun (_ (* TODO: qs *), ty) ->
        E.mapM (fun sdecltor ->
          desugar_struct_declarator sdecltor >>= fun (ident, qs, mk_type) ->
          E.return (ident, mk_type ty)
        ) sdecltors
    
    | Struct_assert sa_decl ->
        desugar_and_register_static_assert_declaration sa_decl >>
        E.return []
  end

and desugar_struct_declarator struct_decltor =
  match struct_decltor with
    | SDecl_simple decltor ->
        desugar_declarator decltor
    | SDecl_bitfield declor_opt e ->
        E.fail Loc.unknown (Errors.Desugar_NotyetSupported "SDecl_bitfield")
  end

and desugar_enumerator (id, e_opt) =
  error "WIP 39"


and desugar_alignment_specifier align_spec =
  match align_spec with
    | AS_type tyname ->
      error "WIP 40"
    | AS_expr e ->
      error "WIP 41"
  end


(* val desugar_declarator: declarator -> E.t (cabs_identifier * ATypes.qualifiers * (ATypes.ctype -> ATypes.ctype)) *)
and desugar_declarator (Declarator ptr_decltor_opt ddecltor) =
  maybe (E.return (ATypes.no_qualifiers, id))
    desugar_pointer_declarator ptr_decltor_opt >>= fun (ptr_qs, mk_ptr_type) ->
  desugar_direct_declarator ddecltor           >>= fun (ident, mk_type)      ->
  E.return (ident, ptr_qs, fun ty -> mk_type $ mk_ptr_type ty)


and desugar_direct_declarator ddecltor : E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype)) =
  match ddecltor with
    | DDecl_identifier ident ->
        E.return (ident, fun ty -> ty)
    | DDecl_declarator decltor ->
        desugar_declarator decltor >>= fun (id, qs, mk_type) ->
          if not (AilTypesAux.is_unqualified qs) then
            error "TODO: desugar_direct_declarator, DDecl_declarator found qualifiers. Bug ?"
          else
            E.return (id, mk_type)
    
      (* TODO: STD check + annot *)
    | DDecl_array ddecltor a_decltor -> do E
        (ident, mk_type) <- desugar_direct_declarator ddecltor;
        mk_array_type    <- desugar_array_declarator (* TODO: is_under_array *) false a_decltor; in
          E.return (ident, fun ty -> mk_type (mk_array_type ty))
        end
    
    | DDecl_function ddecltor param_tys ->
        (* TODO: check + annotate with STD *)
        desugar_direct_declarator ddecltor    >>= fun (ident, mk_ty)    ->
        desugar_parameter_type_list param_tys >>= fun (xs, is_variadic) ->
        E.with_scope E.Scope_prototype (
          E.mapM_ (function
            | (Just (ident, storage_classes), (qs, ty)) ->
                (* TODO: register the declaration (qs, ty) *)
                E.void $
                  E.register_identifier ident
                    E.Namespace_ordinary (E.Kind_object true) storage_classes
            | (Nothing, _) ->
                E.return ()
          end
          ) xs
        ) >>
        (* TODO: check *)
        let params = match List.map snd xs with
          | [(_, ATypes.Void)] ->
              []
          | qs_tys ->
              qs_tys
        end in
        E.return (ident, fun ty -> mk_ty (ATypes.Function ty params is_variadic))

(*
        E.register_identifier ident
          E.Namespace_ordinary E.Kind_object specifs.storage_classes >>= fun sym            ->
*)




(* WIP
_STD "ยง6.7.6.3#5" $
          E.return (sym, fun ty -> mk_ty (ATypes.Function ty bs is_variadic))
        end
*)
  end

and desugar_array_declarator is_under_array a_decltor =
  match a_decltor with
    | ADecl loc _ _ Nothing ->
        (* E.fail loc (Errors.Desugar_NotyetSupported "array type with no size") *)
        E.return (fun ty -> ATypes.Array ty Nothing) (* TODO: check *)
    
    | ADecl loc _ _ (Just ADeclSize_asterisk) ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              E.fail loc (Errors.Desugar_NotyetSupported "variable length array type")
          | _ ->
              E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.7.6.2#4, 2nd sentence")
        end
    
    (* TODO: hacking the simple case for now *)
    | ADecl loc [] false (Just (ADeclSize_expression (CabsExpression _ (CabsEconst (CabsInteger_const (str,_)))))) ->
        E.return (fun ty -> ATypes.Array ty (Just $ snd (Decode.decode_integer_constant str)))
    
    | ADecl loc [] false (Just (ADeclSize_expression e)) ->
        (* TODO: if e can evaluated at runtime, this is not a VLA *)
        E.fail loc (Errors.Desugar_NotyetSupported "variable length array type")
    
    | ADecl loc qs is_static a_decltor_size_opt ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              if is_under_array then
_STD "ยง6.7.6.2#1, sentence 5" $
                E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.6.2#1, 5th sentence")
              else
                E.return ()
          | _ ->
              if qs <> [] || is_static then
_STD "ยง6.7.6.2#1, sentence 5" $
                E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.7.6.2#1, 5th sentence")
              else
                E.return ()
        end >>
        error "WIP 46"
  end


(* NOTE: this is called for declarators of function parameters *)
and desugar_parameter_array_declarator a_decltor =
  match a_decltor with
    | ADecl loc qs is_static a_decltor_size ->
        error "WIP desugar_parameter_array_declarator"
  end

and desugar_array_declarator_size a_decltor_size =
  match a_decltor_size with
    | ADeclSize_expression e ->
        error "WIP 47"
    | ADeclSize_asterisk ->
        error "WIP 48"
  end

(* val desugar_pointer_declarator: pointer_declarator -> E.t (qualifiers * ctype -> ctype) *)
and desugar_pointer_declarator ptr_decltor =
  match ptr_decltor with
    | PDecl tquals ptr_decltor_opt ->
        (* STD  ยง6.7.6.1#1 *)
        maybe (E.return (ATypes.no_qualifiers, id))
          desugar_pointer_declarator ptr_decltor_opt >>= fun (ref_qs, mk_ty) ->
        let ptr_qs = translate_type_qualifiers tquals in
        E.return (ptr_qs, fun ty -> ATypes.Pointer ref_qs (mk_ty ty))
  end

and desugar_parameter_type_list params =
  match params with
    | Params param_decls is_variadic -> do E
        xs <- E.mapM desugar_parameter_declaration param_decls; in
          E.return (xs, is_variadic)
        end
  end

and desugar_parameter_declaration param_decl =
  match param_decl with
    | PDeclaration_decl specifs decltor ->
        desugar_type_specifiers specifs.type_specifiers >>= fun (_ (* TODO: qs *), _ty) ->
        desugar_declarator decltor                      >>= fun (ident, param_qs, mk_ty) ->
          (* TODO: do something with param_qs *)
        (* STD ยง6.9.1#7, sentence 4 *)
        let ty = AilTypesAux.adjust (mk_ty _ty) in
        E.return (Just (ident, specifs.storage_classes), (translate_type_qualifiers specifs.type_qualifiers, ty))
    
    | PDeclaration_abs_decl specifs abs_decltor_opt ->
        desugar_type_specifiers specifs.type_specifiers                         >>= fun (_ (* TODO: qs *), _ty) ->
        maybe (E.return id) (desugar_abstract_declarator false) abs_decltor_opt >>= fun mk_ty ->
        (* STD ยง6.9.1#7, sentence 4 *)
        let ty = AilTypesAux.adjust (mk_ty _ty) in
        E.return (Nothing, (translate_type_qualifiers specifs.type_qualifiers, ty))
  end









(* STATUS: maybe ok *)
(* val     desugar_type_name: type_name -> E.t (ATypes.qualifiers * ATypes.ctype) *)
and desugar_type_name (Type_name specs tquals abs_decltor_opt) =
  desugar_type_specifiers specs >>= fun (_ (* TODO: qs *), ty) ->
  maybe (E.return id) (desugar_abstract_declarator false) abs_decltor_opt >>= fun mk_ty ->
  E.return (translate_type_qualifiers tquals, mk_ty ty)


(* TODO: yuck *)
(* the bool argument `is_under_array' is true iff we went through array type derivation
   since the last call to desugar_type_name *)
and desugar_abstract_declarator is_under_array abs_decltor =
  match abs_decltor with
    | AbsDecl_pointer ptr_decltor ->
        desugar_pointer_declarator ptr_decltor >>= fun (ptr_qs, mk_ptr_type) ->
        (* TODO: do something with ptr_qs *)
        E.return mk_ptr_type
    | AbsDecl_direct ptr_decltor_opt dabs_decltor ->
        maybe (E.return (ATypes.no_qualifiers, id))
          desugar_pointer_declarator ptr_decltor_opt >>= fun (ptr_qs, mk_ptr_type) ->
          (* TODO: do something with ptr_qs *)
        desugar_direct_abstract_declarator is_under_array dabs_decltor >>= fun mk_ty ->
        E.return (fun ty -> mk_ty (mk_ptr_type ty))
  end


and desugar_direct_abstract_declarator is_under_array dabs_decltor =
  match dabs_decltor with
    | DAbs_abs_declarator abs_decltor ->
        desugar_abstract_declarator is_under_array abs_decltor
    | DAbs_array dabs_decltor_opt a_decltor -> do E
        mk_ty         <- maybe (E.return id) (desugar_direct_abstract_declarator true) dabs_decltor_opt;
        mk_array_type <- desugar_array_declarator is_under_array a_decltor; in
          E.return (fun ty -> mk_ty (mk_array_type ty))
        end
    | DAbs_function dabs_decltor_opt param_tys -> do E
        mk_ty             <- maybe (E.return id) (desugar_direct_abstract_declarator is_under_array) dabs_decltor_opt;
        (_, (tys, is_variadic)) <- E.with_scope E.Scope_prototype (desugar_parameter_type_list param_tys); in
          (* TODO: check *)
          E.return (fun ty -> mk_ty (ATypes.Function ty (List.map snd tys) is_variadic))
        end
  end












(*

DESUGARING (DUH)

2-  No initializer shall attempt to provide a value for an object not contained within the entity being initialized.


STATIC-TYPING

3-  The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.


OTHER

4-  All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.



5-  If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier.


*)




and static_thread_implicit_initializer tagDefs ty =
  let _ = Boot.print_debug 8 ("ENTERING Cabs_to_ail.static_thread_implicit_initializer: " ^ Boot.pp_ail_ctype ty) in

  match ty with
    | ATypes.Pointer _ _ ->
        ConstantNull
    | ATypes.Basic _ ->
        if AilTypesAux.is_arithmetic ty then
          ConstantInteger (IConstant 0 Octal Nothing)
        else
          error ("type error 1: " ^ Boot.pp_ail_ctype ty)
    | ATypes.Array elem_ty n_opt ->
        match n_opt with
          | Just n ->
              ConstantArray (Global.replicate_list (static_thread_implicit_initializer tagDefs elem_ty) (natFromInteger n))
          | Nothing ->
              error "type error, (TODO find quote): subarray with no size"
        end

    | ATypes.Struct tag_sym ->
        match Map.lookup tag_sym tagDefs with
          | Just (E.Struct_definition xs) ->
              ConstantStruct tag_sym $
                List.map (fun (ident, ty) ->
                  (ident, static_thread_implicit_initializer tagDefs ty)
                ) xs
          | _ ->
              error "Cabs_to_ail.static_thread_implicit, Struct, not Struct_definition"
        end

    | _ ->
        error ("type error 2: " ^ Boot.pp_ail_ctype ty)
(*
    | Function ty qs_tys is_variadic ->
        
    | Atomic ty ->
        
    | Struct of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
    | Union of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
    | Builtin of string
*)
  end


(*  wip_desugar_initializer_: storageDuration -> ctype -> initializer_ -> E.t ? *)
and wip_desugar_initializer_ dur current_ty = function
  | Init_expr e ->
      (* we ignore the type here because the type checking will catch
         errors later *)
      match dur with
        | ATypes.Automatic ->
            desugar_expression e
        | ATypes.Allocated ->
            error "not possible"
        (* Static | Thread *)
        | _ ->
            desugar_expression e               >>= fun d_e ->
            is_initializer_constant_expression d_e >>= function
              | true ->
                  E.return d_e
(*
                  evaluate_integer_constant_expression (Loc.locOf e) d_e >>= fun cst ->
                  E.return $
                    AnnotatedExpression () (AilEconst (ConstantInteger cst))
*)
              | false ->
                  E.fail (Loc.locOf e) (Errors.Desugar_ConstraintViolation "ยง6.7.9#4")
            end
      end
  
  | Init_list desigs_opt_inits ->
      E.get_tag_definitions >>= fun tagDefs ->
      match current_ty with
        | ATypes.Array elem_ty (Just n) ->
            (* STD ยง6.7.9#10 *)
            let implicit = AnnotatedExpression () Loc.unknown (* TODO *) $ AilEconst match dur with
              | ATypes.Automatic ->
                  ConstantIndeterminate elem_ty
              | ATypes.Allocated ->
                  error "not possible"
              (* Static | Thread *)
              | _ ->
                  static_thread_implicit_initializer tagDefs elem_ty
            end in
            
            E.foldlM (fun (desigs_opt, init) (i, acc) ->
              match desigs_opt with
                | Just [Desig_array e] ->
                    desugar_expression e               >>= fun d_e ->
                    is_integer_constant_expression d_e >>= function
                      | true ->
                          evaluate_integer_constant_expression (Loc.locOf e) d_e >>= function
                            | IConstant j _ _ ->
                                wip_desugar_initializer_ dur elem_ty init             >>= fun d_e               ->
                                match compare j i with
                                  | LT ->
                                      E.fail (Loc.locOf e) (Errors.Desugar_ConstraintViolation "WIP: find the STD text")
                                  | EQ ->
                                      E.return (i+1, acc)
                                  | GT ->
                                      E.return (j+1, Just d_e :: (Global.replicate_list (Just implicit) (natFromInteger $ j-i)) ++ acc)
                                end
                            | _ ->
                                error "WIP: Cabs_to_ail.wip_desugar_initializer_, Init_list, Desig_array, not IConstant"
                          end
                      
                      | false ->
                          E.fail (Loc.locOf e) (Errors.Desugar_ConstraintViolation "ยง6.7.9#6")
                    end
(*
                | Just [Desig_member id] ->
*)
                | Nothing ->
                    wip_desugar_initializer_ dur elem_ty init >>= fun cst ->
                    E.return (i+1, Just cst :: acc)
                | _ ->
                    (* Multi-array designator *)
                    E.fail Loc.unknown (Errors.Desugar_NotyetSupported "sucks to be you")
              end
            ) desigs_opt_inits (0, []) >>= fun (_, xs) ->
            E.return $
              AnnotatedExpression () Loc.unknown(* TODO *)
                (* TODO: should use ConstantArray when possible *)
                (AilEarray elem_ty (List.reverse (Global.replicate_list (Just implicit) (natFromInteger n - List.length xs) ++ xs)))
            
        | ATypes.Struct tag ->
            (* TODO: check the STD!!!!! *)
(*
            E.resolve_tag_definition tag >>= function
              | E.Struct_definition ident_tys ->
                  let initial_assoc = List.map (fun (z, _) -> (z, Nothing)) ident_tys in
                  E.foldlM (fun (desigs_opt, init) (cursor, assoc) ->
                    match desigs_opt with
                      | Just [Desig_member]
                    end
                  ) desigs_opt_inits (List.map fst ident_tys, initial_assoc)
              | _ ->
                  error "ERROR, todo msg"
            end >>
*)
            E.resolve_tag_definition tag >>= function
              | E.Struct_definition ident_tys ->
                  (* TODO: (for now) only allowing explicit and complete initializer *)
                  if List.all (function
                       | (Just [Desig_member _], Init_expr _) -> true
                       | _                                    -> false
                     end) desigs_opt_inits then
                    E.foldlM (fun desigs_opt_init acc ->
                      match desigs_opt_init with
                        | (Just [Desig_member ident], Init_expr e) ->
                            desugar_expression e >>= fun d_e ->
                            E.return $ (ident, d_e) :: acc
                        | _ ->
                            error "WIP: Cabs_to_ail.wip_desugar_initializer_, Struct, Struct_definition, not Desig_member vs Init_expr"
                      end
                    ) desigs_opt_inits [] >>= fun xs ->
                    
                    E.return $
                      AnnotatedExpression () Loc.unknown(* TODO *) (
                        AilEstruct tag (List.map (fun (ident, _) -> (ident, List.lookup ident xs)) ident_tys)
                      )
                  
                  (* TODO: OR a flat implicit initializer *)
                  else if List.all (function
                            | (Nothing, Init_expr _) -> true
                            | _                      -> false
                          end) desigs_opt_inits then
                    E.foldlM (fun desigs_opt_init acc ->
                      match desigs_opt_init with
                        | ((ident, _), (Nothing, Init_expr e)) ->
                            desugar_expression e >>= fun d_e ->
                            E.return $ (ident, Just d_e) :: acc
                        | _ ->
                            error "WIP: Cabs_to_ail.wip_desugar_initializer_, Struct, Struct_definition, else"
                      end
                    ) (List.zip ident_tys desigs_opt_inits) [] >>= fun xs_rev ->
                    
                    E.return $
                      AnnotatedExpression () Loc.unknown(* TODO *) (
                        AilEstruct tag (List.reverse xs_rev)
                      )
                  
                  else
                    (* TODO: crazy stuff we don't deal with yet *)
                    E.fail Loc.unknown (Errors.Desugar_NotyetSupported "crazy struct initializers")
                  



(*
val foldl : forall 'a 'b. ('a -> 'b -> 'a) -> 'a -> list 'b -> 'a (* originally foldl *)
*)
                  

(*
                    | Init_list desigs_opt_inits ->


  | Init_list of list (maybe (list designator) * initializer_)


and designator =
  | Desig_array of cabs_expression
  | Desig_member of cabs_identifier


*)




(*
WIP


                  E.foldlM (fun (desigs_opt, init) (i, acc) ->
                    match desigs_opt with
                      |
                    end
                  ) desigs_opt_inits (0, []) >>= fun _ ->








*)























              

(*
desigs_opt_inits

  | Init_list of list (maybe (list designator) * initializer_)

and designator =
  | Desig_array of cabs_expression
  | Desig_member of cabs_identifier

*)
                  
                  
                  
                  
                  





              | _ ->
                  E.fail Loc.unknown (Errors.Desugar_OtherViolation "[TODO msg], Struct init thing")
            end


(*
  | AilEstruct of identifier * list (Cabs.cabs_identifier * maybe (expression 'A)) (* tag, pairs of member id, expression *)
*)


            


(*
        | Union of identifier * list (Cabs.cabs_identifier * ctype) (* TODO: no bitfields for now *)
*)
        | ATypes.Array elem_ty Nothing ->
            error "TODO: not allowing array with no size for now"

        (* NOTE: should be a scalar type *)
        | _ ->
            (* STD ยง6.7.9#11, sentence 1 *)
            match desigs_opt_inits with
              (* this the "optionaly enclosed in braces" case from (ยง6.7.9#11, sentence 1) *)
              | [(Nothing, init)] ->
                  wip_desugar_initializer_ dur current_ty init
              | _ ->
                  (* TODO: this (at leat) possible with something like:
                       int a = {1, 2}; *)
                  error "WIP: error message. is that even a possible case?"
            end
(*
(ยง6.7.9#11, sentence 1) The initializer for a scalar shall be a single expression, optionally enclosed in braces.

(ยง6.7.9#11, sentence 2) The initial value of the object is that of the expression (after conversion);

(ยง6.7.9#11, sentence 3) the same type constraints and conversions as for simple assignment apply, taking the type of the scalar to be the unqualified version of its declared type.
*)



      end
end


(*
and desugar_initializer_ init =
  match init with
    | Init_expr e ->
        desugar_expression e
    | Init_list inits ->
        error "WIP 58"
  end

and desugar_designator desig =
  match desig with
    | Desig_array e ->
       error "WIP 59"
    | Desig_member id ->
       error "WIP 60"
  end
*)


and desugar_and_register_static_assert_declaration sa_decl =
  match sa_decl with
   | Static_assert e lit ->
       desugar_expression e >>= fun d_e ->
       E.register_static_assertion d_e (translate_cabs_string_literal lit)
  end


val desugar_declaration_base: specifiers -> list init_declarator -> E.t (list (identifier * expression unit))
let desugar_declaration_base specifs idecltors =
  desugar_type_specifiers specifs.type_specifiers >>= fun (_ (* TODO: qs *), _ty) ->
(*   E.mapM (desugar_init_declarator _ty specifs.storage_classes) idecltors  >>= fun xs  -> *)
  let base_qs = translate_type_qualifiers specifs.type_qualifiers in
  
  (* for each [init_declarator] *)
    E.foldrM (fun idecltor acc ->
      desugar_init_declarator _ty specifs.storage_classes idecltor >>= fun (ident, qs, ty, d_e_opt) ->
      if specifs.storage_classes = [SC_typedef] then
        (* Case of a typedef *)
        E.register_identifier ident
          E.Namespace_ordinary E.Kind_typedef specifs.storage_classes >>= fun (_, sym) ->
        let (qs', ty') = inject_qualifiers base_qs ty in
        if not (AilTypesAux.is_unqualified qs) && not (AilTypesAux.is_unqualified qs') then
          error "TODO: desugar_declaration_base: is this case legal?"
        else
          E.register_typedef sym (AilTypesAux.combine_qualifiers qs qs', ty') >>
          E.return acc
        
      else match ty with
        | ATypes.Function return_ty params is_variadic ->
            E.register_identifier ident
              E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun (_, sym) ->
            E.register_function_declaration (Loc.locOf ident) sym (
              return_ty,
              params,
              is_variadic,
              List.elem FS_inline   specifs.function_specifiers,
              List.elem FS_Noreturn specifs.function_specifiers
            ) >>
            E.return acc
        | _ ->
            E.register_identifier ident
              E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun (link, sym) ->
            let dur = determinate_storage_duration link specifs.storage_classes in
            E.register_internal_object_declaration sym (dur, qs, ty) >>
            match d_e_opt with
              | Just d_e ->
                  E.return ((sym, d_e) :: acc)
              | Nothing ->
                  E.return acc
            end
      end
    ) (List.reverse idecltors) []

(* WIP


  E.mapM (desugar_init_declarator _ty) idecltors  >>= fun xs  ->
  
  (* for each [init_declarator] *)
    E.foldrM (fun (ident, ty, d_e_opt) acc ->
      let qs = translate_type_qualifiers specifs.type_qualifiers in
      
      if specifs.storage_classes = [SC_typedef] then
        (* Case of a typedef *)
        E.register_identifier ident
          E.Namespace_ordinary E.Kind_typedef specifs.storage_classes >>= fun sym ->
        E.register_typedef sym (qs, ty) >>
        E.return acc
        
      else match ty with
        | ATypes.Function return_ty params is_variadic ->
            E.register_identifier ident
              E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun sym ->
            E.register_function_declaration sym (
              return_ty,
              params,
              is_variadic,
              List.elem FS_inline   specifs.function_specifiers,
              List.elem FS_Noreturn specifs.function_specifiers
            ) >>
            E.return acc
        | _ ->
            E.register_identifier ident
              E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun sym ->
            E.register_internal_object_declaration sym (qs, ty) >>
            match d_e_opt with
              | Just d_e ->
                  E.return ((sym, d_e) :: acc)
              | Nothing ->
                  E.return acc
            end
      end
    ) xs []
*)



(* transforms a Cabs do-while loop into a while-loop + stuff to deal with
   break/continue statements *)
(* substitute break/continue statements that are not enclosed in an inner loop/switch, by
   gotos to given labels *)
(* returns Left if no break/continue was found, Right otherwise *)
val     substitute_naked_break_continue: cabs_identifier -> maybe cabs_identifier -> cabs_statement -> either cabs_statement cabs_statement
let rec substitute_naked_break_continue continue_label break_label_opt (CabsStatement loc stmt_) =
  let self z = substitute_naked_break_continue continue_label break_label_opt z in
  match stmt_ with
(*
WIP KKK

    | CabsSlabel id s ->
        either (Left -| CabsSlabel id) (Right -| CabsSlabel id) (self s)
    | CabsScase e s ->
        either (Left -| CabsScase e) (Right -| CabsScase e) (self s)
    | CabsSdefault s ->
        either (Left -| CabsSdefault) (Right -| CabsSdefault) (self s)
    | CabsSblock ss ->
        let ss' = List.map self ss in
        (fun z -> if List.any isRight ss' then Right z else Left z) $
          CabsSblock (List.map (either id id) ss')
    | CabsSif e s1 Nothing ->
        either (fun z -> Left (CabsSif e z Nothing))
               (fun z -> Right (CabsSif e z Nothing)) (self s1)
    | CabsSif e s1 (Just s2) ->
        match (self s1, self s2) with
          | (Left _, Left _) ->
              Left stmt
          | (_s1', _s2') ->
              Right $ CabsSif e (either id id _s1') (Just $ either id id _s2')
        end
    | CabsSswitch e s ->
        (* only look for continue statements, since the break statements are
           enclosed by the switch *)
          either (Left -| CabsSswitch e) (Right -| CabsSswitch e)
            (substitute_naked_break_continue continue_label Nothing stmt)
    | CabsScontinue ->
        Right (CabsSgoto continue_label)
    | CabsSbreak ->
        match break_label_opt with
          | Just break_label ->
              Right (CabsSgoto break_label)
          | Nothing ->
              Left stmt
        end
*)
    | _ ->
        Left (CabsStatement loc stmt_)
  end


val do_while_hack: cabs_expression -> cabs_statement -> E.t cabs_statement
let do_while_hack e (CabsStatement loc smt) =
  error "WIP, Cabs_to_ail.do_while_hack"
(*
WIP KKK
  (* TODO: it would be nice to only generate these names, if they are needed *)
  (* one way would be to have substitute_... generate a function taking label
     names and returning the new statement *)
  E.freshify "continue_" >>= fun continue_label ->
  E.freshify "break_"    >>= fun break_label    ->
  match substitute_naked_break_continue continue_label (Just break_label) s with
    | Left _ ->
        E.return $ CabsSblock [s; CabsSwhile e s]
    | Right s' ->
        E.register_label continue_label >>
        E.register_label break_label    >>
        E.return (
          CabsSblock [s'; CabsSlabel continue_label (CabsSwhile e s); CabsSlabel break_label CabsSnull]
        )
  end
*)

val     desugar_statement: cabs_statement -> E.t (statement unit)
let rec desugar_statement (CabsStatement loc stmt_) =
  AnnotatedStatement loc <$>
    match stmt_ with
      | CabsSlabel ident s ->
	  AilSlabel <$> E.resolve_label ident
                    <*> desugar_statement s
      
      | CabsScase e s ->
          E.is_inside_switch >>= function
            | true ->
                AilScase <$> (desugar_expression e >>= evaluate_integer_constant_expression (Loc.locOf e))
                         <*> desugar_statement s
            | false ->
                E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.1#2")
          end
      
      | CabsSdefault s ->
          E.is_inside_switch >>= function
            | true ->
                AilSdefault <$> desugar_statement s
            | false ->
                E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.1#2")
          end
      
      | CabsSblock ss ->
          (* TODO: STD check + annot *)
          E.fresh_block_scope >>= fun scope ->
          E.with_scope scope (
            E.mapM desugar_statement ss
          ) >>= fun (bs, d_ss) ->
          
          (* this is removing unnecessary blocks introduced by the desugared.
             TODO: check carefully that we don't remove source blocks *)
          let d_ss' =
            List.foldr (fun z acc ->
              match z with
                | (CabsStatement _ (CabsSblock _), AnnotatedStatement _ (AilSblock _ _)) ->
                    (* this is the case of a block already present in the Cabs code. *)
                    snd z :: acc
                | (_, AnnotatedStatement _ (AilSblock [] xs)) ->
                    (* here a block with no local variables was introduced by the desugaring *)
                    xs ++ acc
                | _ ->
                    snd z :: acc
              end
            ) [] (List.zip ss d_ss) in
          
          E.return (AilSblock bs d_ss')
      
      | CabsSdecl (Declaration_base specifs idecltors) ->
          AilSdeclaration <$> desugar_declaration_base specifs idecltors
      
      | CabsSdecl (Declaration_static_assert sa_decl) ->
          desugar_and_register_static_assert_declaration sa_decl >>
          (* TODO: hackish *)
          E.return AilSskip
      
      | CabsSnull ->
          E.return AilSskip
      
      | CabsSexpr e ->
          AilSexpr <$> desugar_expression e
      
      | CabsSif e s1 s2_opt ->
          (* TODO: check *)
          AilSif <$> desugar_expression e
                 <*> desugar_statement s1
                 <*> maybe (E.return $ AnnotatedStatement Loc.unknown AilSskip) desugar_statement s2_opt
      
      | CabsSswitch e s ->
          (* TODO: check *)
          AilSswitch <$> desugar_expression e
                     <*> E.perform_inside_switch (desugar_statement s)
          
      
      | CabsSwhile e s ->
          (* TODO: check *)
          AilSwhile <$> desugar_expression e
                    <*> E.perform_inside_loop (desugar_statement s)
      
      | CabsSdo e s ->
          (* TODO: check *)
          AilSdo <$> E.perform_inside_loop (desugar_statement s)
                 <*> desugar_expression e
(*
          (* TODO: this is a bit hackish *)
          do_while_hack e s    >>= fun s' ->
          desugar_statement s' >>= fun (AnnotatedStatement _ d_s) ->
          E.return d_s
*)
      
      | CabsSfor (Just (FC_decl ((Declaration_base specifs idecltors)))) e2_opt e3_opt s ->
          (* TODO: this is not really a block scope (...) *)
          E.fresh_block_scope >>= fun scope ->
          E.with_scope scope (
            desugar_type_specifiers specifs.type_specifiers >>= fun (_ (* TODO: qs *), _ty) ->
            E.mapM (desugar_init_declarator _ty specifs.storage_classes) idecltors  >>= fun xs ->
            
            (* for each [init_declarator] *)
            E.foldrM (fun (ident, qs, ty, d_e_opt) (acc1, acc2) ->
              (* TODO!!!: do something with qs *)
              let qs = translate_type_qualifiers specifs.type_qualifiers in
              
              if not (specifs.storage_classes = []        ||
                      specifs.storage_classes = [SC_auto] ||
                      specifs.storage_classes = [SC_register]) then
                (* NOTE: amusingly, as it is written, the STD doesn't allow the absence of storage-class ... *)
                E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.5#3")
              
              else match ty with
                | ATypes.Function _ _ _ ->
                    E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.5#3")
                | _ ->
                    E.register_identifier ident
                      E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun (link, sym) ->
                    match d_e_opt with
                      | Just d_e ->
                          let dur = determinate_storage_duration link specifs.storage_classes in
                          E.return ((sym, d_e) :: acc1, (sym, (Just dur, qs, ty)) :: acc2)
                      | Nothing ->
                          E.return (acc1, acc2)
                    end
              end
            ) (List.reverse xs) ([], []) >>= fun (sym_d_es, bs) ->
            
              (* see (ยง6.8.5.3#2, second sentence) for the Nothing case *)
              maybe (E.return oneAil) desugar_expression e2_opt >>= fun d_e2 ->
              E.perform_inside_loop $ desugar_statement s       >>= fun d_s  ->
              
              match e3_opt with
                | Just e3 ->
                    desugar_expression e3 >>= fun d_e3 ->
                    let d_s_e3 = AnnotatedStatement Loc.unknown $ AilSexpr d_e3 in
                    
                    let d_s_body = match d_s with
                      | AnnotatedStatement loc (AilSblock bs d_ss) ->
                          AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                      | _ ->
                          AnnotatedStatement Loc.unknown $
                            AilSblock [] [d_s; d_s_e3]
                    end in
                    E.return (AilSwhile d_e2 d_s_body)
                
                | Nothing ->
                    E.return (AilSwhile d_e2 d_s)
              end >>= fun d_s_for ->
              
              E.return $
                AilSblock bs [
                  AnnotatedStatement Loc.unknown (AilSdeclaration sym_d_es);
                  AnnotatedStatement Loc.unknown d_s_for
                ]
          ) >>= fun (_, ret) ->
          E.return ret
      
      | CabsSfor fc_opt e2_opt e3_opt s ->
          (* see (ยง6.8.5.3#2, second sentence) for the Nothing case *)
          maybe (E.return oneAil) desugar_expression e2_opt >>= fun d_e2 ->
          E.perform_inside_loop $ desugar_statement s       >>= fun d_s  ->
          
          match (fc_opt, e3_opt) with
            (*    for (E1;; E3) S ==> { E1; while(1) {E3; S} }
               or 
                  for (E1; E2; E3) S ==> { E1; while(E2) {E3; S} }
             *)
            | (Just (FC_expr e1), Just e3) ->
                desugar_expression e1 >>= fun d_e1 ->
                desugar_expression e3 >>= fun d_e3 ->
                let d_s_e1 = AnnotatedStatement (Loc.locOf e1) $ AilSexpr d_e1 in
                let d_s_e3 = AnnotatedStatement (Loc.locOf e3) $ AilSexpr d_e3 in
                
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Loc.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSblock [] [d_s_e1; AnnotatedStatement loc $ AilSwhile d_e2 d_s_body])
            
            | (Just (FC_decl (Declaration_base _ _)), Just e3) ->
                E.fail loc Errors.Desugar_impossible
            
            | (Just (FC_decl (Declaration_static_assert sa_decl)), Just e3) ->
                desugar_and_register_static_assert_declaration sa_decl >>
                desugar_expression e3 >>= fun d_e3 ->
                let d_s_e3 = AnnotatedStatement Loc.unknown $ AilSexpr d_e3 in
                
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Loc.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
            
            | (Nothing, Just e3) ->
                desugar_expression e3 >>= fun d_e3 ->
                let d_s_e3 = AnnotatedStatement Loc.unknown $ AilSexpr d_e3 in
                
                let d_s_body = match d_s with
                  | AnnotatedStatement loc (AilSblock bs d_ss) ->
                      AnnotatedStatement loc (AilSblock bs (d_ss ++ [d_s_e3]))
                  | _ ->
                      AnnotatedStatement Loc.unknown $
                        AilSblock [] [d_s; d_s_e3]
                end in
                E.return (AilSwhile d_e2 d_s_body)
            
            | (Nothing, Nothing) ->
                E.return (AilSwhile d_e2 d_s)
            | _ ->
              error "WIP: Cabs_to_ail.desugar_statement, CabsSfor"
          end
      
      | CabsSgoto ident ->
          AilSgoto <$> E.resolve_label ident
      
      | CabsScontinue ->
          E.is_inside_loop >>= function
            | true ->
                E.return AilScontinue
            | false ->
                E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.6.2#1")
          end
      
      | CabsSbreak ->
          E.is_inside_switch >>= fun b1 ->
          E.is_inside_loop   >>= fun b2 ->
          if b1 || b2 then
            E.return AilSbreak
          else
            E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.6.3#1")
      
      | CabsSreturn Nothing ->
          E.get_current_return_type >>= function
            | ATypes.Void ->
                E.return AilSreturnVoid
            | _ ->
                E.fail loc Errors.Desugar_NonvoidReturn
          end
      
      | CabsSreturn (Just e) ->
          E.get_current_return_type >>= function
            | ATypes.Void ->
                E.fail loc (Errors.Desugar_ConstraintViolation "ยง6.8.6.4#1, 1st sentence")
            | _ ->
                AilSreturn <$> desugar_expression e
          end
      
      | CabsSpar ss ->
          AilSpar <$> E.mapM desugar_statement ss
    end


val     register_labels: cabs_statement -> E.t unit
let rec register_labels (CabsStatement _ stmt_) =
  match stmt_ with
    | CabsSlabel ident s ->
        E.register_label ident
    | CabsScase _ s ->
        register_labels s
    | CabsSdefault s ->
        register_labels s
    | CabsSblock ss ->
        E.mapM_ register_labels ss
    | CabsSdecl _ ->
        E.return ()
    | CabsSnull ->
        E.return ()
    | CabsSexpr _ ->
        E.return ()
    | CabsSif _ s1 s2_opt ->
        register_labels s1 >>
        maybe (E.return ()) register_labels s2_opt
    | CabsSswitch _ s ->
        register_labels s
    | CabsSwhile _ s ->
        register_labels s
    | CabsSdo _ s ->
        register_labels s
    | CabsSfor _ _ _ s ->
        register_labels s
    | CabsSgoto _ ->
        E.return ()
    | CabsScontinue ->
        E.return ()
    | CabsSbreak ->
        E.return ()
    | CabsSreturn _ ->
        E.return ()
    | CabsSpar _ ->
        (* TODO: temporary *)
        E.return ()
  end






(* TODO: check + annotate with STD *)
val desugar_and_register_function_definition: function_definition -> E.t unit
let desugar_and_register_function_definition (FunDef specifs (Declarator ptr_decltor_opt ddecltor) s) =
  if List.any (fun sc -> SC_extern <> sc && SC_static <> sc) specifs.storage_classes then
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.9.1#4")
  else
    match ddecltor with
      | DDecl_function ddecltor param_tys ->
          maybe (E.return (ATypes.no_qualifiers, id))
            desugar_pointer_declarator ptr_decltor_opt    >>= fun (ptr_qs, mk_ptr_type)  ->
          desugar_type_specifiers specifs.type_specifiers >>= fun (_ (* TODO: qs *), ty) ->
          desugar_direct_declarator ddecltor              >>= fun (fun_ident, mk_ty)     ->
          desugar_parameter_type_list param_tys           >>= fun (params, is_variadic)  ->
          
          (* TODO!!!!: do something with ptr_qs *)
          
          (* TODO: this is probably wrong *)
          let return_ty = mk_ptr_type ty in
          
          E.register_identifier fun_ident
            E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun (_, fun_sym) ->
          
          E.function_is_defined fun_sym >>= function
            | true  -> E.fail Loc.unknown (Errors.Desugar_FunctionRedefinition fun_sym)
            | false -> E.return ()
          end >>
          
          E.void (E.with_scope E.Scope_function (
            register_labels s >>
            E.fresh_block_scope >>= fun scope ->
            E.void (E.with_scope scope (
              match params with
                | [(x_opt, (qs, ATypes.Void))] ->
                    if isJust x_opt then
                      E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.9.1#5, sentence 1, sub-sentence 4")
                    else if qs <> ATypes.no_qualifiers then
                      E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "TODO: find where the Std forbids this")
                    else
                      E.return []
                | _ ->
                    E.mapM (fun (x_opt, (qs, ty)) ->
                      if ty = ATypes.Void then
                        E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.9.1#5, void not alone")
                      else match x_opt with
                        | Nothing ->
                            E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.9.1#5, sentence 1, sub-sentence 2")
                        | Just (ident, storage_classes) ->
                            E.register_identifier ident E.Namespace_ordinary (E.Kind_object true) storage_classes >>= fun (_, sym) ->
                            E.return (sym, (qs, ty))
                      end
                    ) params
              end >>= fun bindings ->
              
              E.register_function_declaration (Loc.locOf fun_ident) fun_sym (
                return_ty,
                List.map snd bindings,
                is_variadic,
                List.elem FS_inline   specifs.function_specifiers,
                List.elem FS_Noreturn specifs.function_specifiers
               ) >>
              
              E.set_current_return_type return_ty >>
              desugar_statement s                 >>= fun d_s ->
              
              E.register_function_definition fun_sym (List.map fst bindings, d_s)
            ))
          ))
    | _ ->
        E.fail Loc.unknown Errors.Desugar_impossible
  end


(*
(* TODO place somewhere else *)
val     extract_typedef_name: list cabs_type_specifier -> list cabs_type_specifier -> string * list cabs_type_specifier
let rec extract_typedef_name specs acc =
  match specs with
    | [] ->
        error "extract_typedef_name found no TSpec_name"
    | TSpec_name str :: specs' ->
        (str, acc ++ specs')
    | x :: xs ->
        extract_typedef_name xs (x::acc)
  end
*)

val desugar_and_register_external_declaration: external_declaration -> E.t unit
let desugar_and_register_external_declaration edecl =
  let storage_classes =
    maybe [] (fun z -> z.storage_classes) (specifiers_of_external_declaration edecl) in
  
  if List.elem SC_auto storage_classes || List.elem SC_register storage_classes then
    E.fail Loc.unknown (Errors.Desugar_ConstraintViolation "ยง6.9#2")
  else
    match edecl with
      | EDecl_func fdef ->
          let _ = Boot.print_debug 2 "EDecl_func" in (* DEBUG *)
          desugar_and_register_function_definition fdef
      
      (* TODO: check *)
      | EDecl_decl (Declaration_base specifs idecltors) ->
          desugar_type_specifiers specifs.type_specifiers >>= fun (_ (* TODO: qs *), _ty) ->
          E.mapM (desugar_init_declarator _ty specifs.storage_classes) idecltors >>= fun xs  ->
          
          (* for each [init_declarator] *)
          E.mapM_ (fun (ident, qs, ty, d_e_opt) ->
            (* TODO!!!: do something with qs *)
            let base_qs = translate_type_qualifiers specifs.type_qualifiers in
            let _ = Boot.print_debug 2
              (if base_qs.ATypes.const then "FOUND CONST" else "DIDN'T FIND CONST") in (* DEBUG *)
            
            
            let _ = Boot.print_debug 2 $ "BEFORE_INJECT " ^ Boot.pp_ail_ctype ty in
            let (qs', ty') = inject_qualifiers base_qs ty in
            if not (AilTypesAux.is_unqualified qs) && not (AilTypesAux.is_unqualified qs') then
              error "TODO: desugar_declaration_base: is this case legal?"
            else
              let _ = Boot.print_debug 2 ("AA> " ^ Boot.pp_ail_ctype ty) in (* DEBUG *)
              let _ = Boot.print_debug 2 ("BB> " ^ Boot.pp_ail_ctype ty') in (* DEBUG *)
              
              
              if specifs.storage_classes = [SC_typedef] then
                (* Case of a typedef *)
                E.register_identifier ident
                  E.Namespace_ordinary E.Kind_typedef specifs.storage_classes >>= fun (_, sym) ->
                E.register_typedef sym (AilTypesAux.combine_qualifiers qs qs', ty')
                
              else match ty with
                | ATypes.Function return_ty params is_variadic ->
                    E.register_identifier ident
                      E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun (_, sym) ->
                    E.register_function_declaration (Loc.locOf ident) sym (
                      return_ty,
                      params,
                      is_variadic,
                      List.elem FS_inline   specifs.function_specifiers,
                      List.elem FS_Noreturn specifs.function_specifiers
                    )
                | _ ->
                    E.register_identifier ident
                      E.Namespace_ordinary (E.Kind_object false) specifs.storage_classes >>= fun (link, sym) ->
                    let dur = determinate_storage_duration link specifs.storage_classes in
                    E.register_external_object_declaration sym (dur, AilTypesAux.combine_qualifiers qs qs', ty') >>
                    match d_e_opt with
                      | Just d_e ->
                          E.register_external_object_definition sym d_e
                      | Nothing ->
                          E.return ()
                    end
              end
          ) xs
      
      | EDecl_decl (Declaration_static_assert sa_decl) ->
          desugar_and_register_static_assert_declaration sa_decl
    end


val desugar: nat -> string -> translation_unit -> Exception.t (UniqueId.supply Symbol.t * program unit) Errors.t
let desugar sym_counter startup_str (TUnit edecls) =
  E.eval sym_counter (
    E.with_scope E.Scope_file (
      E.mapM_ desugar_and_register_external_declaration edecls >>
      E.extract_program startup_str
    ) >>= fun (_, ret) ->
    E.return ret
  )
