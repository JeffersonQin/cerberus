(* NEW AND FINAL Cabs to Ail translation *)

(* TODO: ignoring locations for now *)

(* TODO: not doing the linkages stuff for now *)



open Global

module C = Cabs0
(* module A = Ail *)
module A      = AilSyntax
module ATypes = AilTypes

module O = Option





(*


val desugar_storages: list C.storage -> E.t (option A.storage_duration)
let desugar_storages = function
  | []               -> E.return None
  | [C.AUTO]         -> E.return (Some A.AUTOMATIC)
  | [C.STATIC]       -> E.return (Some A.STATIC)
  | [C.EXTERN]       -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
  | [C.THREAD_LOCAL] -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class _Thread_local")
  | [C.REGISTER]     -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class register")
  | [C.TYPEDEF]      -> E.return None (* TODO: typedef is not really a storage class, but should be get the class of the aliased type??? *)
  | _                -> E.fail Errors.CABS_TO_AIL_MULTIPLE_STORAGE_CLASS
end
*)

val desugar_unary_operator: C.unary_operator -> A.unaryOperator
let desugar_unary_operator = function
  | C.MINUS   -> A.Minus
  | C.PLUS    -> A.Plus
  | C.BNOT    -> A.Bnot
  | C.MEMOF   -> A.Indirection
  | C.ADDROF  -> A.Address
  | C.POSINCR -> A.PostfixIncr
  | C.POSDECR -> A.PostfixDecr

  (* These cases cannot occurs since these constructors are translated away. *)
  | C.NOT     -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] NOT"
  | C.PREINCR -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] PREINCR"
  | C.PREDECR -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] PREDECR"
end


val desugar_arithmetic_operator: C.binary_operator -> A.arithmeticOperator
let desugar_arithmetic_operator = function
  | C.ADD  -> A.Add
  | C.SUB  -> A.Sub
  | C.MUL  -> A.Mul
  | C.DIV  -> A.Div
  | C.MOD  -> A.Mod
  | C.BAND -> A.Band
  | C.XOR  -> A.Xor
  | C.BOR  -> A.Bor
  | C.SHL  -> A.Shl
  | C.SHR  -> A.Shr
  | _ -> Boot.assert_false "[Cabs0_to_ail.desugar_arithmetic_operator] should only be called on \
                            operators allowed for compound assignments [§6.5.16#1]."
end


val desugar_binary_operator: C.binary_operator -> A.binaryOperator
let desugar_binary_operator = function
  | C.AND   -> A.And
  | C.OR    -> A.Or
  | C.EQ    -> A.Eq
  | C.NE    -> A.Ne
  | C.LT    -> A.Lt
  | C.GT    -> A.Gt
  | C.LE    -> A.Le
  | C.GE    -> A.Ge
  | C.COMMA -> A.Comma
  | op      -> A.Arithmetic (desugar_arithmetic_operator op)
end





module Effect = struct
  
  type state = <|
    symbol_counter: Symbol.counter;
    (* table (with stacked scopes) associating C identifiers to symbols *)
    registered_identifiers: Symbol_table.t string A.identifier;
    (* registered_labels *)
    is_inside_switch: bool;
    
    fun_defs : A.sigma Location.t unit;
    
    
    (* TODO: temporarily not having globals  *)
(*
    id_map : map Symbol.t A.declaration; (* TODO: split off function definition (as in new-Ail) *)
    fn_map : map Symbol.t (list Symbol.t * A.statement Location.t unit); (* functions map       *)
*)
  |>

  type t 'a = State_exception.t 'a state Errors.t

  val return: forall 'a. 'a -> t 'a
  let return = State_exception.return

  val fail: forall 'a. Errors.cause -> t 'a
  let fail err = State_exception.fail (Location.dummy, err)

  let of_option err = State_exception.of_option (Location.dummy, err)

  val make_program: Symbol.t -> t (A.program Location.t unit)
  let make_program startup =
    State_exception.read (fun st ->
      (startup, st.fun_defs)
    )

  val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
  val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
  let mapM = State_exception.mapM
  let mapM_ = State_exception.mapM_
  
  let foldrM = State_exception.foldrM


  val tryWith: forall 'a. Errors.t -> t 'a -> t 'a
  let tryWith = State_exception.tryWith

  module Operators = struct
    let (>>=)    = State_exception.bind
    let (>>) m f = m >>= fun _ -> f

    val (<$>): forall 'a 'b. ('a -> 'b) -> t 'a -> t 'b
    val (<*>): forall 'a 'b. t ('a -> 'b) -> t 'a -> t 'b
    let (<$>) = State_exception.fmap
    let (<*>) = State_exception.app

    val ifElse: forall 'a. t bool -> t 'a -> t 'a -> t 'a
    let ifElse mb m1 m2 =
      mb >>= function
	| true  -> m1
	| false -> m2
      end
  end

  open Operators

  (* given a computation producing the symbolic name of the startup function,
     produce the desugared Ail file *)
  val eval: t Symbol.t -> Exception.t (A.program Location.t unit) Errors.t
  let eval m =
    let initial_state : state = <|
      symbol_counter = Symbol.init;
      registered_identifiers = Symbol_table.create_scope Symbol_table.empty;
      is_inside_switch = false;
      
      fun_defs = []
(*      
      id_map              = Pmap.empty;
      fn_map              = Pmap.empty
*)
    |> in
    State_exception.eval (m >>= make_program) initial_state
  
  val resolve_identifier: string -> t A.identifier
  let resolve_identifier name =
    State_exception.read (fun st -> Symbol_table.find name st.registered_identifiers) >>= function
      | Some x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end
  
  val is_inside_switch: t bool
  let is_inside_switch =
    State_exception.read (fun st -> st.is_inside_switch)
  
  val create_scope: t unit
  let create_scope =
    State_exception.update (fun st ->
      <| st with registered_identifiers= Symbol_table.create_scope st.registered_identifiers |>)
  
  val destroy_scope: t (list A.identifier)
  let destroy_scope =
    State_exception.modify (fun st ->
      (Symbol_table.symbols st.registered_identifiers,
       <| st with registered_identifiers= Symbol_table.destroy_scope st.registered_identifiers |>)
    )

  val fresh : t Symbol.t
  let fresh =
    State_exception.modify (fun st ->
      let (sym, symbol_counter) = Symbol.fresh st.symbol_counter in
      (sym, <| st with symbol_counter = symbol_counter |>)
    )

  val fresh_name : string -> t A.identifier
  let fresh_name name =
    State_exception.modify (fun st ->
      let (sym, symbol_counter) = Symbol.fresh_pretty name st.symbol_counter in
      (sym, <| st with symbol_counter = symbol_counter |>)
    )

  val register_name_translation : string -> A.identifier -> t unit
  let register_name_translation name symbol =
    State_exception.update (fun st ->
      <| st with registered_identifiers = Symbol_table.add name symbol st.registered_identifiers |>
    )

  val name_in_scope : string -> t bool
  let name_in_scope name =
    State_exception.read (fun st ->
      Symbol_table.mem name (Symbol_table.return_scope st.registered_identifiers)
    )

  val register_name : string -> t A.identifier
  let register_name name =
    name_in_scope name >>= function
      | true  ->
          State_exception.fail (Location.dummy, Errors.CABS_TO_AIL_MULTIPLE_REGISTRATION)
      | false ->
          fresh_name name                    >>= fun sym ->
          register_name_translation name sym >>
          State_exception.return sym
      end

  (* TODO: storage_duration *)
  val add_declaration : Symbol.t -> (* ATypes.qualifiers -> *) ATypes.ctype -> t unit
  let add_declaration v (* q *) t =
    Boot.assert_false "HIP: add_declaration"
(*
    State_exception.update (fun st ->
    <| st with id_map = Pmap.add v (q, t) st.id_map |>)
*)
  
  val get_declaration: A.identifier -> t (ATypes.qualifiers * ATypes.ctype)
  let get_declaration id =
    Boot.assert_false "HIP"

  val add_function : A.identifier -> ((ATypes.ctype * A.bindings) * A.statement Location.t unit) -> t unit (* TODO: parameters *)
  let add_function id fun_def =
    State_exception.update (fun st ->
      <| st with fun_defs = (id, fun_def) :: st.fun_defs |>
    )

end


module E = Effect
open E.Operators


val register_label: C.atom -> E.t A.identifier
let register_label l_name =
  Boot.assert_false "HIP: register_label"

val register_labels: C.statement -> E.t unit
let register_labels stmt =
  Boot.assert_false "HIP: register_labels"

val fetch_label: C.atom -> E.t A.identifier
let fetch_label l_name =
  Boot.assert_false "HIP: fetch_label"


(* TODO: better name? *)
type declarationKind =
  | Object
  | Function

(* Scopes of identifiers *)
type scope =
  | FunctionScope
  | FileScope
  | BlockScope
(*  | FunctionPrototypeScope *)

type pre_integer_constant =
  | StrictIntegerConstant of int
  | ImplDefined (* TODO: arg *)

(* ============================================================================================== *)

(* TODO: relook at this with linkage stuff *)

(* (§6.7.1#2) At most, one storage-class specifier may be given in the
   declaration specifiers in a declaration, except that _Thread_local may appear
   with static or extern. 120) *)

(* TODO: (§6.7.1#3) [...] If _Thread_local appears in any declaration of an object, it shall be present in every declaration of that object. *)
(* TODO: (§6.7.1#8) f an aggregate or union object is declared with a storage-class specifier other than typedef, the properties resulting from the storage-class specifier, except with respect to linkage, also apply to the members of the object, and so on recursively for any aggregate or union member objects. *)

val desugar_storages: declarationKind -> scope -> list C.storage -> E.t (option ATypes.storageDuration)
let desugar_storages kind scope ss =
  (* (§6.7.1#7) The declaration of an identifier for a function that has block
     scope shall have no explicit storage-class specifier other than extern. *)
  if kind = Function && scope = BlockScope then
    match ss with
      | [] ->
	  E.return None
      | [C.EXTERN] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
      | _ ->
	  E.fail Errors.CABS_TO_AIL_BLOCK_FUNCTION_STORAGE
    end
  else
    match ss with
      | [C.THREAD_LOCAL] ->
          (* (§6.7.1#3) In the declaration of an object with block scope, if the
             declaration specifiers include _Thread_local, they shall also include
	     either static or extern. [...] *)
          if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else if scope = BlockScope then
	    E.fail Errors.CABS_TO_AIL_BLOCK_THREAD_LOCAL_ALONE
	  else
	    E.return (Some ATypes.Thread)
      | [C.THREAD_LOCAL; C.STATIC] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: THREAD_LOCAL + STATIC")
      | [C.STATIC; C.THREAD_LOCAL] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: STATIC + THREAD_LOCAL")
      | [C.THREAD_LOCAL; C.EXTERN] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: THREAD_LOCAL + EXTERN")
      | [C.EXTERN; C.THREAD_LOCAL] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: EXTERN + THREAD_LOCAL")

      | [] ->
  	  E.return None
      | [C.AUTO] ->
	  E.return (Some ATypes.Automatic)
      | [C.STATIC] ->
	  E.return (Some ATypes.Static)
      | [C.REGISTER] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class register")
      | [C.EXTERN] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
      | [C.TYPEDEF] -> E.return None  (* TODO: typedef is not really a storage class, but should be get the class of the aliased type??? *)

      | _::_::_ -> E.fail Errors.CABS_TO_AIL_MULTIPLE_STORAGE_CLASS
    end

(*
  type C.definition =
  | FUNDEF of list spec_elem * name * statement * cabsloc
  | DECDEF of init_name_group * cabsloc (* global variable(s), or function prototype *)
 | PRAGMA of atom * cabsloc

--------------------

type A.file 'a = <|
  (* the main function name *)
  main:    id;
  id_map:  map id declaration;               (* declared identifiers *)
  globals: list (id * expression_t 'a);      (* *)
  fn_map:  map id (list id * statement_l 'a) (* functions *)
|>
*)

(*
val desugar_program: string -> list C.g_defn_l -> E.t (Ail.file unit)
let desugar_program startup global_defns =
  E.iter (desugar_global_defn initial_desugar_state) global_defns      >>= fun ()   ->
  E.option (Errors.CABS_TO_AIL_NO_STARTUP startup) (E.resolve startup) >>= fun main ->
  E.to_program main
*)

open O.Operators
val     desugar_integer_constant_expression: C.expression -> O.t pre_integer_constant
let rec desugar_integer_constant_expression expr =
  let f x = desugar_integer_constant_expression x in
  match expr with
  | C.UNARY C.MINUS expr ->
      f expr >>= function
| ImplDefined -> Boot.assert_false "TODO"
        (* TODO: promotion *)
        | StrictIntegerConstant n -> O.return $ StrictIntegerConstant (Int.neg n)
      end

  | C.UNARY C.PLUS expr ->
      f expr >>= function
        | ImplDefined -> Boot.assert_false "TODO"
        (* TODO: promotion *)
        | StrictIntegerConstant n -> O.return $ StrictIntegerConstant n
      end

  | C.UNARY C.NOT expr ->
      f expr >>= function
        | ImplDefined -> Boot.assert_false "TODO"
        | StrictIntegerConstant n ->
            O.return $ StrictIntegerConstant
              (if Int.eq n (Int.int 0) then Int.int 1 else Int.int 0)
      end

  | C.UNARY C.BNOT expr ->
      Boot.assert_false "HIP: desugar_integer_constant_expression, UNARY BNOT"


  | C.BINARY bop expr1 expr2 ->
      Boot.assert_false "HIP: desugar_integer_constant_expression, BINARY"

(*
  | C.QUESTION expr1 expr2 expr3 ->
      (* when evaluating the test expression, 0 stands for false and
         any other value for true *)
      f expr1 >>= function
        | 0 -> f expr3
        | _ -> f expr2
      end
      <|>

      (* even if the test expression is not constant, the whole conditional is
         still constant if the two other expressions evaluate to the same value *)
      f expr2 >>= fun n2 ->
      f expr3 >>= fun n3 ->
      if n2 = n3 then
        O.return n2
      else
        O.empty

*)


(*
      | C.CAST of (list spec_elem * decl_type) * init_expression

    (*
      | C.C11_ATOMIC_INIT expr1 expr2 ->

      | C.C11_ATOMIC_STORE expr1 expr2 expr3 ->

      | C.C11_ATOMIC_LOAD expr1 expr2 ->

      | C.C11_ATOMIC_EXCHANGE expr1 expr2 expr3 ->

      | C.C11_ATOMIC_COMPARE_EXCHANGE_STRONG expr1 expr2 expr3 expr4 expr5 ->

      | C.C11_ATOMIC_COMPARE_EXCHANGE_WEAK of expression * expression * expression * expression * expression
      | C.C11_ATOMIC_FETCH_KEY of expression * expression * expression
    *)

  | C.CALL of expression * list expression
  | C.BUILTIN_VA_ARG of expression * (list spec_elem * decl_type)
  | C.CONSTANT of constant
  | C.VARIABLE of atom
  | C.EXPR_SIZEOF of expression
  | C.TYPE_SIZEOF of (list spec_elem * decl_type)
  | C.ALIGNOF of (list spec_elem * decl_type)
  | C.INDEX expr1 expr 2->
  | C.MEMBEROF expr at ->

  | C.MEMBEROFPTR expr at ->

  | C.OFFSETOF of (list spec_elem * decl_type) * atom
*)

    | _ -> None
  end

val desugar_integerConstant: C.atom -> option C.integer_suffix -> A.integerConstant
let desugar_integerConstant str suff_opt =
  let desugar_integerSuffix = function
    | C.SUFFIX_UNSIGNED           -> A.U
    | C.SUFFIX_UNSIGNED_LONG      -> A.UL
    | C.SUFFIX_UNSIGNED_LONG_LONG -> A.ULL
    | C.SUFFIX_LONG               -> A.L
    | C.SUFFIX_LONG_LONG          -> A.LL
  end in
  let (n, basis) = Decode.decode_integer_constant str in
  match suff_opt with
    | Some suff -> (n, (* basis, *) Some (desugar_integerSuffix suff))
    | None      -> (n, (* basis, *) None)
  end

open E.Operators

val     desugar_expression: C.expression -> E.t (A.expression unit)
let rec desugar_expression e =
  A.AnnotatedExpression () <$>
  match e with
  | C.UNARY uop e ->
      A.Unary (desugar_unary_operator uop) <$> desugar_expression e
  | C.BINARY bop e1 e2 ->
      A.Binary <$> desugar_expression e1 <*> E.return (desugar_binary_operator bop) <*> desugar_expression e2


  | C.VARIABLE x -> A.Var <$> E.resolve_identifier x
  | C.CONSTANT (C.CONST_INT n s) -> E.return (A.Constant (A.ConstantInteger (desugar_integerConstant n s)))
  
  | _ -> Boot.assert_false "HIP: desugar_expression"
  end

(*
val desugar_character_constant: option C.character_prefix -> C.atom -> A.character_constant
(* TODO: decoding + impl-def independence (and Ail should store an integer, instead of a string) *) 
  let desugar_character_constant pref_opt str =
  let desugar_character_prefix = function
    | C.PREFIX_L -> A.PREFIX_L
    | C.PREFIX_u -> A.PREFIX_u
    | C.PREFIX_U -> A.PREFIX_U
  end in
  let n = Decode.decode_character_constant str in
  match pref_opt with
    | Some pref -> (Some (desugar_character_prefix pref), n)
    | None      -> (None, n)
  end
*)

val desugar_constant: C.constant -> E.t A.constant
let desugar_constant = function
  | C.CONST_INT str suff_opt ->
      E.return $ A.ConstantInteger (desugar_integerConstant str suff_opt)
  | C.CONST_FLOAT str ->
      E.fail (Errors.CSEM_NOT_SUPPORTED "float constants")
(*
  | C.CONST_CHAR pref_opt str ->
      E.return $ A.CONST_CHAR (desugar_character_constant pref_opt str)
*)
end

(*
type C.constant =
  (* The atom is the textual representation of the constant in
     the source code. It does include quotes. *)
  | CONST_INT of atom * option integer_suffix
  | CONST_FLOAT of atom
  | CONST_CHAR of option character_prefix * atom
  | CONST_STRING of atom (* TODO *)



type A.constant =
  | CONST_INT of integer_constant
  | CONST_FLOAT of string (* the textual representaton *)
  | CONST_CHAR of character_constant
  | CONST_ENUM of string
(* 
(* TODO *)
  | CONST_CHAR of list int64
  | CONST_WCHAR of list int64
*)

*)

val desugar_cvspecs: list C.cvspec -> ATypes.qualifiers
let desugar_cvspecs =
  List.fold_left (fun qs ->
    function
    | C.CV_CONST    -> <| qs with ATypes.const    = true |>
    | C.CV_RESTRICT -> <| qs with ATypes.restrict = true |>
    | C.CV_VOLATILE -> <| qs with ATypes.volatile = true |>
    | C.CV_ATOMIC   -> Boot.assert_false "Cabs_to_ail.desugar_cvspecs [C.CV_ATOMIC]" (* <| qs with ATypes.atomic_q = true |> *)
    end
  ) ATypes.no_qualifiers

val separate_spec_elem_list : list C.spec_elem -> (list C.cvspec) * (list C.typeSpecifier)
let separate_spec_elem_list =
  List.fold_left
    (fun (cs, ts) s ->
      match s with
      | C.SpecCV      c -> (c :: cs, ts)
      | C.SpecAttr    _ -> Boot.assert_false "SpecAttr"
      | C.SpecStorage _ -> Boot.assert_false "SpecStorage"
      | C.SpecInline    -> Boot.assert_false "SpecInline"
      | C.SpecType    t -> (cs, t :: ts)
      end)
    ([], [])




(* We follow the multiset mapping from §6.7.2#2 (except that `void' is matched in [desugar_type]
   instead) *)
(* TODO: structs, enums, etc. *)
val desugar_basic_type_specifiers: Multiset.t C.typeSpecifier -> E.t (ATypes.basicType)
let desugar_basic_type_specifiers specifiers =
  let desugar_map =
    List.fold_left
      (fun m (x, bty) -> Pmap.add x bty m)
      (Ocaml.Pmap.empty Multiset.compare_int)
      (
        (* TODO: maybe move that somewhere else *)
          [(Multiset.from_list [C.Tchar], ATypes.Integer ATypes.Char)]

        @ [(Multiset.from_list [C.Tsigned; C.Tchar], ATypes.Integer (ATypes.Signed ATypes.Ichar))]
        @ [(Multiset.from_list [C.Tunsigned; C.Tchar], ATypes.Integer (ATypes.Unsigned ATypes.Ichar))]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.Short)))
          [ [C.Tshort];
            [C.Tsigned; C.Tshort];
            [C.Tshort; C.Tint];
            [C.Tsigned; C.Tshort; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.Short)))
          [ [C.Tunsigned; C.Tshort];
            [C.Tunsigned; C.Tshort; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.Int_)))
          [ [C.Tint];
            [C.Tsigned];
            [C.Tsigned; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.Int_)))
          [ [C.Tunsigned];
            [C.Tunsigned; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.Long)))
          [ [C.Tlong];
            [C.Tsigned; C.Tlong];
            [C.Tlong; C.Tint];
            [C.Tsigned; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.Long)))
          [ [C.Tunsigned; C.Tlong];
            [C.Tunsigned; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.LongLong)))
          [ [C.Tlong; C.Tlong];
            [C.Tsigned; C.Tlong; C.Tlong];
            [C.Tlong; C.Tlong; C.Tint];
            [C.Tsigned; C.Tlong; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.LongLong)))
          [ [C.Tunsigned; C.Tlong; C.Tlong];
            [C.Tunsigned; C.Tlong; C.Tlong; C.Tint]
          ]
(*
        @ [(Multiset.from_list [C.Tfloat], ATypes.REAL_FLOATING ATypes.FLOAT)]
        @ [(Multiset.from_list [C.Tdouble], ATypes.REAL_FLOATING ATypes.DOUBLE)]
        @ [(Multiset.from_list [C.Tlong; C.Tdouble], ATypes.REAL_FLOATING ATypes.LONG_DOUBLE)]
*)
        @ [(Multiset.from_list [C.T_Bool], ATypes.Integer ATypes.Bool)]
(*
        @ [(Multiset.from_list [C.Tfloat; C.COMPLEX], ATypes.COMPLEX ATypes.FLOAT)]
        @ [(Multiset.from_list [C.Tdouble; C.COMPLEX], ATypes.COMPLEX ATypes.DOUBLE)]
        @ [(Multiset.from_list [C.Tlong; C.Tdouble; C.COMPLEX], ATypes.COMPLEX ATypes.LONG_DOUBLE)]
*)
      ) in
  E.of_option (Errors.OTHER "[Cabs_to_ail.desugar_specifier] found a Cabs type that we don't yet handled.")
              (Map_.find specifiers desugar_map)

(*val desugar_parameter : C.parameter -> E.t (A.identifier * ATypes.qualifiers * ATypes.ctype) *)


val desugar_type_specifiers : list C.typeSpecifier -> E.t (ATypes.ctype)
let desugar_type_specifiers = function
  (* TODO: ignore structs, enums, typedefs, ... *)
(*  | [C.atomic (specs, dt)] ->*)
  | [C.Tvoid] ->
      E.return ATypes.Void
  | ss ->
      ATypes.Basic <$> desugar_basic_type_specifiers (Multiset.from_list ss)
end


val desugar_spec_elem_list : list C.spec_elem -> E.t (ATypes.qualifiers * ATypes.ctype)
let desugar_spec_elem_list specs =
  let (cs, ts) = separate_spec_elem_list specs in
  let q = desugar_cvspecs cs in
  desugar_type_specifiers ts >>= fun t ->
  E.return (q, t)

val     desugar_decl_type : C.decl_type -> E.t (ATypes.ctype -> ATypes.ctype)
let rec desugar_decl_type decl_ty =
  match decl_ty with
  | C.JUSTBASE ->
      E.return $ fun ty -> ty
(*
  | C.ARRAY dt cvs _ None ->
      fun t ->
        (mk_ctype dt)
        (A.Array (desugar_cvspecs cvs) t None)
*)
  | C.ARRAY decl_ty' cvs _ (Some (C.CONSTANT (C.CONST_INT n None))) ->
      desugar_decl_type decl_ty' >>= fun mk_ty ->
      E.return $ fun ty -> mk_ty (ATypes.Array (* (desugar_cvspecs cvs) *) ty (fst (Decode.decode_integer_constant n))) (* TODO: for test purposes only ;) *)
  | C.ARRAY dt cvs _ (Some (C.CONSTANT e)) ->
      Boot.assert_false "Constant expressions other than integer constant not yet supported."
  | C.PTR cvs _ decl_ty' ->
      desugar_decl_type decl_ty' >>= fun mk_ty ->
      E.return $ fun ty -> mk_ty (ATypes.Pointer (desugar_cvspecs cvs) ty)
  (* TODO: ignoring variable length parameters for now *)
  | C.PROTO decl_ty' (params, _) ->
      desugar_decl_type decl_ty' >>= fun mk_ty    ->
      desugar_parameters params  >>= fun d_params ->
      E.return $ fun ty -> mk_ty (ATypes.Function ty $ List.map snd d_params)
  end


(*  desugar_parameters : list C.parameter -> E.t (list (A.identifier * (ATypes.qualifiers * ATypes.ctype))) *)
and desugar_parameters params =
  E.foldrM (fun (C.PARAM param_specs param_name_opt param_decl [] _) acc ->
    desugar_spec_elem_list param_specs >>= fun (param_qs, param_ty) ->
    (* (void) the special case of function with no parameters (§6.7.6.3#10) *)
    if param_ty = ATypes.Void then
      (if List.length params <> 1 then
        E.fail (Errors.OTHER "void' must be the first and only parameter if specified") (* TODO: proper message *)
      else if param_name_opt <> None then
        E.fail (Errors.OTHER "argument may not have 'void' type") (* TODO: proper message *)
      else
        E.return [])
    else
      (* OTHERWISE: the real stuff *)
      O.option 
        (E.fail (Errors.OTHER "parameter name omitted")) (* TODO: proper message *)
        (fun param_name ->
          E.register_name param_name         >>= fun param_id             ->
          desugar_spec_elem_list param_specs >>= fun (param_qs, param_ty) ->
          E.return (param_id, (param_qs, param_ty))
        ) param_name_opt >>= fun d_param ->
      E.return (d_param :: acc)
  ) params []






(* ========================================================================================================================================================= *)
(*
            | PROTO return_decl params ->
                (* the function return type *)
                let d_return_ty = desugar_decl_type return_decl return_base_ty in
(*
                (* () the special case of function with no parameters (§6.7.6.3#14) *)
                if params = [] then
                  E.return (A.FUNCTION d_return_ty [], [])
                else
*)
                  (* for each parameter declaration (TODO: ignoring variable length parameters for now) *)
                  E.foldrM (fun (C.PARAM param_specs param_name_opt param_decl [] _, _) (fun_env_acc, d_params_acc) ->
                    desugar_spec_elem_list param_specs >>= fun (param_qs, param_ty) ->
(*
                    (* (void) the special case of function with no parameters (§6.7.6.3#10) *)
                    if param_ty = ATypes.Void then
                      if List.length params <> 1 then
                        E.fail (Errors.OTHER "void' must be the first and only parameter if specified") (* TODO: proper message *)
                      else if param_name_opt <> None then
                        E.fail (Errors.OTHER "argument may not have 'void' type") (* TODO: proper message *)
                      else
*)
                        (* OTHERWISE: the real stuff *)
                        (* create a symbol for the parameter and add it to the current scope *)
                        register_name param_name >>= fun param_id   ->
                        desugar_type param_ty    >>= fun d_param_ty ->
(*
            desugar_storage sts      >>= function
              | Some _ ->
                  let msg = "Violation of constraint 6.7.6.3#2 Function \
                             declarators (including prototypes), Constraints: \
                             ..The only storage-class that shall occur in a \
                             parameter declaration is register... in\n" in
                  E.fail (Errors.OTHER msg)
              | None ->
                  E.return None
            end >>= fun d_st ->
*)
                        E.return ((param_id, (param_qs, d_param_ty)) :: fun_env_acc, (param_qs, d_param_ty) :: d_params_acc)
                ) params ([], []) >>= fun (fun_env, d_params) ->
                E.return (fun_env, A.Function d_return_ty d_params)
            | _ -> E.fail (Errors.OTHER "Not a function type.")
*)
(* ========================================================================================================================================================= *)





val desugar_definition: C.definition -> E.t unit


val     desugar_statement : C.statement  -> E.t (A.statement Location.t unit)
let rec desugar_statement stmt =
  A.AnnotatedStatement Location.dummy <$>
    match stmt with
      | C.NOP _ ->
          E.return A.Skip
      | C.COMPUTATION expr _ ->
          A.Expression <$> desugar_expression expr
      | C.BLOCK stmts _ ->
          (* TODO: documentation *)
          E.create_scope                          >>
          E.mapM desugar_statement stmts          >>= fun d_stmts ->
          E.destroy_scope                         >>= fun ids     ->
          E.mapM E.get_declaration ids            >>= fun decls   ->
          E.return $ A.Block (List.map2 Product.make ids decls) d_stmts

      | C.If expr stmt1 stmt2_opt _ ->
          (* (§6.8.3#3) allows us to add null operation without changing the
                       semantics of a statement *)
          A.If <$> desugar_expression expr
               <*> desugar_statement stmt1
               <*> Option.option (E.return $ A.AnnotatedStatement Location.dummy A.Skip)
                                 desugar_statement stmt2_opt
      | C.WHILE expr stmt _ ->
          A.While <$> desugar_expression expr
                  <*> desugar_statement stmt
      | C.DOWHILE expr stmt _ ->
          A.Do <$> desugar_statement stmt
               <*> desugar_expression expr
      | C.FOR fc_opt expr1_opt expr2_opt stmt _ ->
          Boot.assert_false "HIP: desugar_statement FOR"
      | C.BREAK _ ->
          E.return A.Break
      | C.CONTINUE _ ->
          E.return A.Continue
      | C.RETURN None _ ->
          E.return A.ReturnVoid
      | C.RETURN (Some expr) _f ->
          A.Return <$> desugar_expression expr
      | C.SWITCH expr stmt _ ->
          Boot.assert_false "HIP: desugar_statement  SWITCH"
      | C.CASE expr stmt _ ->
          (* (§6.8.1#2) "A case label shall appear only in a switch statement." *)
          ifElse E.is_inside_switch begin
          (* TODO: for now we only support impl-independent constant
                   expressions *)
(*
           desugar_integer_constant_expression expr >>= function
             | 
                 A.CASE <$> 

E.fail Errors.CABS_TO_AIL_CASE_NOT_INTEGER_CONSTANT_EXRESSION

*)	    

	    Boot.assert_false "HIP: desugar_statement CASE"
	  end (E.fail Errors.DEFAULT_OUTSIDE_SWITCH)
      | C.DEFAULT stmt _ ->
          (* (§6.8.1#2) "A default label shall appear only in a switch statement." *)
	  ifElse E.is_inside_switch
            (A.Default <$> desugar_statement stmt)
	    (E.fail Errors.DEFAULT_OUTSIDE_SWITCH)
      | C.LABEL lab stmt _ ->
	  A.Label <$> fetch_label lab
	          <*> desugar_statement stmt
      | C.GOTO lab _ ->
          A.Goto <$> fetch_label lab
(*
      | C.DEFINITION (C.DECDEF ing _) -> (*TODO: location*)
      	  A.DECLARATION <$> desugar_declaration ing
      | C.PAR stmts _ ->
          A.PAR <$> E.mapM desugar_statement stmts
*)
  end

and desugar_init_expression ie =
  match ie with
  | C.NO_INIT         -> E.return None
  | C.SINGLE_INIT   e -> Some <$> desugar_expression e
  | C.COMPOUND_INIT _ -> Boot.assert_false "COMPOUND_INIT"
  end

(*  desugar_init_name : C.init_name -> E.t (Symbol.t * (ATypes.ctype -> ATypes.ctype) * option (A.expression unit)) *)
and desugar_init_name iname =
  let C.Init_name (C.Name name decl_ty _ _) ie = iname in
  E.register_name name       >>= fun v     ->
  desugar_init_expression ie >>= fun e_opt ->
  desugar_decl_type decl_ty  >>= fun mk_ty ->
  E.return (v, mk_ty , e_opt)


(*  desugar_declaration: C.init_name_group -> E.t (list (Symbol.t * A.expression unit)) *)
and desugar_declaration (specs, ins) =
  desugar_spec_elem_list specs >>= fun (qs, ty) ->
  E.mapM desugar_init_name ins >>= fun decls    ->
  filter_opt <$> E.mapM (fun (id, mk_ty, e_opt) ->
                   E.add_declaration id (* qs *) (mk_ty ty) >>
                   E.return
                     match e_opt with
                     | Some e -> Some (id, e)
                     | None   -> None
                     end
                 ) decls




(* TODO: to support VLAs we need to extend the scope of parameters ids *)
(*  desugar_defintion: C.definition -> E.t unit *)
and desugar_definition def =
  match def with
    | C.FUNDEF specs (C.Name fun_name fun_decl [] _) stmt _ ->
        desugar_spec_elem_list specs >>= fun (qs, ty) -> (* TODO: q should be A.no_qualifiers; check! *)
        desugar_statement stmt       >>= fun d_stmt   ->
        E.register_name fun_name     >>= fun fun_id   ->
        match fun_decl with
          | C.PROTO _ (params, _) ->
              desugar_parameters params
          | _ ->
              E.fail (Errors.OTHER "Not a function type.")
        end >>= fun d_params ->

        (* TODO: register formals! *)
(*        E.add_declaration fun_id (* qs *) (desugar_decl_type fun_decl ty) >> *)
        E.add_function fun_id ((ty, d_params), d_stmt)
(*
    | C.FUNDEF specs (C.Name fun_name fun_decl [] _) stmt _ ->
        (* TODO: should also get the qualifier and check that it is either extern or static (§6.9.1#4) *)
        (* NOTE: qs should moraly be empty, but it can contain qualifiers (const, ...)
           refering to the return type which however do not make any sense here. *)
        desugar_spec_elem_list specs >>= fun (qs, fun_ty_) ->
        
        (* this function gets applied to `fun_decl` *)
      let process_function_decl = function
          | PROTO return_decl params ->
              





        desugar_statement stmt       >>= fun d_stmt ->
        E.register_name fun_name     >>= fun fun_id ->
        (* TODO: register formals! *)
        E.add_declaration v q (desugar_decl_type decl t) >>
        E.add_function    v s





BEGIN HIP
        (* TODO: should also get the qualifier and check that it is either extern or static (§6.9.1#4) *)
        desugar_spec_elem_list specs >>= fun (fun_qs, return_base_ty) ->
        if not (ATypes.eq_qualifiers fun_qs ATypes.no_qualifiers) then
          E.fail (Errors.OTHER "found a function definition with qualifiers") (* TODO: proper message *)
        else
          (* this function gets applied to `fun_decl` *)
          let process_function_decl = function
            | PROTO return_decl params ->
                (* the function return type *)
                let d_return_ty = desugar_decl_type return_decl return_base_ty in
(*
                (* () the special case of function with no parameters (§6.7.6.3#14) *)
                if params = [] then
                  E.return (A.FUNCTION d_return_ty [], [])
                else
*)
                  (* for each parameter declaration (TODO: ignoring variable length parameters for now) *)
                  E.foldrM (fun (C.PARAM param_specs param_name_opt param_decl [] _, _) (fun_env_acc, d_params_acc) ->
                    desugar_spec_elem_list param_specs >>= fun (param_qs, param_ty) ->
(*
                    (* (void) the special case of function with no parameters (§6.7.6.3#10) *)
                    if param_ty = ATypes.Void then
                      if List.length params <> 1 then
                        E.fail (Errors.OTHER "void' must be the first and only parameter if specified") (* TODO: proper message *)
                      else if param_name_opt <> None then
                        E.fail (Errors.OTHER "argument may not have 'void' type") (* TODO: proper message *)
                      else
*)
                        (* OTHERWISE: the real stuff *)
                        (* create a symbol for the parameter and add it to the current scope *)
                        register_name param_name >>= fun param_id   ->
                        desugar_type param_ty    >>= fun d_param_ty ->
(*
            desugar_storage sts      >>= function
              | Some _ ->
                  let msg = "Violation of constraint 6.7.6.3#2 Function \
                             declarators (including prototypes), Constraints: \
                             ..The only storage-class that shall occur in a \
                             parameter declaration is register... in\n" in
                  E.fail (Errors.OTHER msg)
              | None ->
                  E.return None
            end >>= fun d_st ->
*)
                        E.return ((param_id, (param_qs, d_param_ty)) :: fun_env_acc, (param_qs, d_param_ty) :: d_params_acc)
                ) params ([], []) >>= fun (fun_env, d_params) ->
                E.return (fun_env, A.Function d_return_ty d_params)
            | _ -> E.fail (Errors.OTHER "Not a function type.")


 in
          
          E.register_name fun_name                     >>= fun id     ->
          (* TODO: storage class *)
          (* starts the function scope *)
          E.create_scope >>
          (* desugar the function type and colect the parameters *)
          process_function_decl fun_decl >>= fun (fun_env, d_fun_ty) ->

            KKK


(*
  E.create_scope          >>= fun ()             ->

  desugar_function_type t >>= fun (d_t, formals) ->
  E.return_scope          >>= fun fn_scope       ->
  E.destroy_scope         >>= fun ()             ->
  E.add_id id (d_t, d_st) >>= fun ()             ->
  E.push_table fn_scope   >>= fun ()             ->
  E.return (id, formals)
*)






          desugar_statement stmt                  >>= fun d_stmt ->
          E.add_declaration id (desugar_decl_type decl ty) >>
          E.add_function id d_stmt

END HIP



*)




    (* TODO: I think this correspond to the def of a struct/union (typedef?) *)
  | C.DECDEF (specs, []) loc ->
      Boot.assert_false "HIP: desugar_definition DECDEF (case 1)"
  | C.DECDEF ing loc ->
      Boot.assert_false "HIP: desugar_definition DECDEF (case 2)"
  | C.PRAGMA at loc ->
      E.fail (Errors.CSEM_NOT_SUPPORTED "PRAGMA definitions")
end


val desugar_program : string -> list C.definition -> E.t (Symbol.t)
let desugar_program startup defs =
  E.mapM_ desugar_definition defs >>
  E.tryWith (Location.dummy, Errors.CABS_TO_AIL_NO_STARTUP startup) (E.resolve_identifier startup)


(* desugar "main" defs *)
val desugar: string -> list C.definition -> Exception.t (A.program Location.t unit) Errors.t
let desugar startup defs =
  E.eval $ desugar_program startup defs
