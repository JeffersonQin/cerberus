(* TODO:
     * ignoring locations for now
     * not doing things related to linkages
*)

open Global

module C = Cabs0
module A      = AilSyntax
module ATypes = AilTypes

module O = Option

(*
val desugar_storages: list C.storage -> E.t (option A.storage_duration)
let desugar_storages = function
  | []               -> E.return None
  | [C.AUTO]         -> E.return (Some A.AUTOMATIC)
  | [C.STATIC]       -> E.return (Some A.STATIC)
  | [C.EXTERN]       -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
  | [C.THREAD_LOCAL] -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class _Thread_local")
  | [C.REGISTER]     -> E.fail (Errors.CSEM_NOT_SUPPORTED "storage class register")
  | [C.TYPEDEF]      -> E.return None (* TODO: typedef is not really a storage class, but should be get the class of the aliased type??? *)
  | _                -> E.fail Errors.CABS_TO_AIL_MULTIPLE_STORAGE_CLASS
end
*)


val desugar_unary_operator: C.unary_operator -> A.unaryOperator
let desugar_unary_operator = function
  | C.MINUS   -> A.Minus
  | C.PLUS    -> A.Plus
  | C.BNOT    -> A.Bnot
  | C.MEMOF   -> A.Indirection
  | C.ADDROF  -> A.Address
  | C.POSINCR -> A.PostfixIncr
  | C.POSDECR -> A.PostfixDecr

  (* These cases cannot occurs since these constructors are translated away. *)
  | C.NOT     -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] NOT"
  | C.PREINCR -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] PREINCR"
  | C.PREDECR -> Boot.assert_false "[Cabs_to_ail.desugar_unary_operator] PREDECR"
end


val desugar_arithmetic_operator: C.binary_operator -> A.arithmeticOperator
let desugar_arithmetic_operator = function
  | C.ADD  -> A.Add
  | C.SUB  -> A.Sub
  | C.MUL  -> A.Mul
  | C.DIV  -> A.Div
  | C.MOD  -> A.Mod
  | C.BAND -> A.Band
  | C.XOR  -> A.Xor
  | C.BOR  -> A.Bor
  | C.SHL  -> A.Shl
  | C.SHR  -> A.Shr
  | _ -> Boot.assert_false "[Cabs0_to_ail.desugar_arithmetic_operator] should only be called on \
                            operators allowed for compound assignments [ยง6.5.16#1]."
end


val desugar_binary_operator: C.binary_operator -> A.binaryOperator
let desugar_binary_operator = function
  | C.AND   -> A.And
  | C.OR    -> A.Or
  | C.EQ    -> A.Eq
  | C.NE    -> A.Ne
  | C.LT    -> A.Lt
  | C.GT    -> A.Gt
  | C.LE    -> A.Le
  | C.GE    -> A.Ge
  | C.COMMA -> A.Comma
  | op      -> A.Arithmetic (desugar_arithmetic_operator op)
end


module Effect = struct
  type state = <|
    symbol_counter:         Symbol.counter;
    registered_identifiers: Symbol_table.t string A.identifier; (* table (with stacked scopes) associating C identifiers to symbols *)
    registered_labels:      map string Symbol.t;                (* registered_labels *)
    is_inside_switch:       bool;
    fun_defs:               A.sigma Location.t unit;
    id_map:                 map Symbol.t (ATypes.qualifiers * ATypes.ctype);
    (* TODO: need to bring back globals (add them to newAil) *)
  |>
  
  type t 'a = State_exception.t 'a state Errors.t
  
  val return: forall 'a. 'a -> t 'a
  let return = State_exception.return
  
  val fail: forall 'a. Errors.cause -> t 'a
  let fail err = State_exception.fail (Location.dummy, err)
  
  let of_option err = State_exception.of_option (Location.dummy, err)
  
  val make_program: Symbol.t -> t (A.program Location.t unit)
  let make_program startup =
    State_exception.read (fun st ->
      (startup, st.fun_defs)
    )
  
  val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
  val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
  let mapM = State_exception.mapM
  let mapM_ = State_exception.mapM_
  
  let foldrM = State_exception.foldrM
  
  let iter = State_exception.iter
  
  val tryWith: forall 'a. Errors.t -> t 'a -> t 'a
  let tryWith = State_exception.tryWith

  module Operators = struct
    let (>>=)    = State_exception.bind
    let (>>) m f = m >>= fun _ -> f

    val (<$>): forall 'a 'b. ('a -> 'b) -> t 'a -> t 'b
    val (<*>): forall 'a 'b. t ('a -> 'b) -> t 'a -> t 'b
    let (<$>) = State_exception.fmap
    let (<*>) = State_exception.app

    val ifElse: forall 'a. t bool -> t 'a -> t 'a -> t 'a
    let ifElse mb m1 m2 =
      mb >>= function
	| true  -> m1
	| false -> m2
      end
  end

  open Operators

  (* given a computation producing the symbolic name of the startup function,
     produce the desugared Ail file *)
  val eval: t Symbol.t -> Exception.t (A.program Location.t unit) Errors.t
  let eval m =
    let initial_state : state = <|
      symbol_counter=         Symbol.init;
      registered_identifiers= Symbol_table.create_scope Symbol_table.empty;
      registered_labels=      Pmap.empty;
      is_inside_switch=       false;
      fun_defs=               [];
      id_map=                 Pmap.empty
    |> in
    State_exception.eval (m >>= make_program) initial_state
  
  val resolve_identifier: string -> t A.identifier
  let resolve_identifier name =
    State_exception.read (fun st -> Symbol_table.find name st.registered_identifiers) >>= function
      | Some x  -> return x
      | Nothing -> fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER name)
    end
  
  val is_inside_switch: t bool
  let is_inside_switch =
    State_exception.read (fun st -> st.is_inside_switch)
  
  val create_scope: t unit
  let create_scope =
    State_exception.update (fun st ->
      <| st with registered_identifiers= Symbol_table.create_scope st.registered_identifiers |>)
  
  val destroy_scope: t (list A.identifier)
  let destroy_scope =
    State_exception.modify (fun st ->
      (Symbol_table.symbols st.registered_identifiers,
       <| st with registered_identifiers= Symbol_table.destroy_scope st.registered_identifiers |>)
    )

  val fresh : t Symbol.t
  let fresh =
    State_exception.modify (fun st ->
      let (sym, symbol_counter) = Symbol.fresh st.symbol_counter in
      (sym, <| st with symbol_counter = symbol_counter |>)
    )

  val fresh_name : string -> t A.identifier
  let fresh_name name =
    State_exception.modify (fun st ->
      let (sym, symbol_counter) = Symbol.fresh_pretty name st.symbol_counter in
      (sym, <| st with symbol_counter = symbol_counter |>)
    )

  val register_name_translation : string -> A.identifier -> t unit
  let register_name_translation name symbol =
    State_exception.update (fun st ->
      <| st with registered_identifiers = Symbol_table.add name symbol st.registered_identifiers |>
    )

  val name_in_scope : string -> t bool
  let name_in_scope name =
    State_exception.read (fun st ->
      Symbol_table.mem name (Symbol_table.return_scope st.registered_identifiers)
    )

  val register_name : string -> t A.identifier
  let register_name name =
    name_in_scope name >>= function
      | true  ->
          State_exception.fail (Location.dummy, Errors.CABS_TO_AIL_MULTIPLE_REGISTRATION)
      | false ->
          fresh_name name                    >>= fun sym ->
          register_name_translation name sym >>
          State_exception.return sym
      end

  (* TODO: storage_duration *)
  val add_declaration : Symbol.t -> ATypes.qualifiers -> ATypes.ctype -> t unit
  let add_declaration id qs ty =
    State_exception.update (fun st ->
    <| st with id_map = Pmap.add id (qs, ty) st.id_map |>)
  
  val get_declaration: A.identifier -> t (ATypes.qualifiers * ATypes.ctype)
  let get_declaration id =
    State_exception.read (fun st ->
      Pmap.find id st.id_map
    )

  val add_function : A.identifier -> ((ATypes.ctype * A.bindings) * A.statement Location.t unit) -> t unit (* TODO: parameters *)
  let add_function id fun_def =
    State_exception.update (fun st ->
      <| st with fun_defs = (id, fun_def) :: st.fun_defs |>
    )
  
  (* Labels related functions *)
  val return_registered_labels: t (Pmap.map string Symbol.t)
  let return_registered_labels = fun st ->
    Exception.return (st.registered_labels, st)
  
  let fresh_label name =
    State_exception.modify (fun st ->
      let (symbol, symbol_counter') = Symbol.fresh_pretty name st.symbol_counter in
      (symbol, <| st with  symbol_counter=     symbol_counter';
                           registered_labels=  Pmap.add name symbol st.registered_labels |>)
    )
end


module E = Effect
open E.Operators


val     register_labels: C.statement -> E.t unit
let rec register_labels stmt =
let f name =
  E.return_registered_labels >>= fun labels ->
  if Pmap.mem name labels then E.fail Errors.CABS_TO_AIL_DUPLICATED_LABEL
                          else E.fresh_label name in
  match stmt with
    | C.NOP _ ->
        E.return ()
    | C.COMPUTATION  _ _ ->
        E.return ()
    | C.BLOCK ss _ ->
        E.iter register_labels ss
    | C.If _ s1 s2_opt _ ->
        register_labels s1 >>
        match s2_opt with
          | Some s2 -> register_labels s2
          | None    -> E.return ()
        end
    | C.WHILE _ s _ ->
        register_labels s
    | C.DOWHILE _ s _ ->
        register_labels s
    | C.FOR _ _ _ s _ ->
        register_labels s
    | C.BREAK _ ->
        E.return ()
    | C.CONTINUE _ ->
        E.return ()
    | C.RETURN _ _ ->
        E.return ()
    | C.SWITCH _ s _ ->
        register_labels s
    | C.CASE _ s _ ->
        register_labels s
    | C.DEFAULT s _ ->
        register_labels s
    | C.LABEL l s _ ->
        E.fresh_label l >>
        register_labels s
    | C.GOTO _ _ ->
        E.return ()
    | C.DEFINITION _ ->
        (* TODO: check *)
        E.return ()
(* TODO:    | PAR of list statement * cabsloc *)
 end


val fetch_label: C.atom -> E.t A.identifier
let fetch_label l_name =
  E.return_registered_labels >>= fun labels ->
  if Pmap.mem l_name labels then E.return (Pmap.find l_name labels)
                            else E.fail (Errors.CABS_TO_AIL_UNDECLARED_IDENTIFIER l_name)

(* TODO: better name? *)
type declarationKind =
  | Object
  | Function

(* Scopes of identifiers *)
type scope =
  | FunctionScope
  | FileScope
  | BlockScope
(*  | FunctionPrototypeScope *)

type pre_integer_constant =
  | StrictIntegerConstant of int
  | ImplDefined (* TODO: arg *)

(* ============================================================================================== *)

(* TODO: relook at this with linkage stuff *)

(* (ยง6.7.1#2) At most, one storage-class specifier may be given in the
   declaration specifiers in a declaration, except that _Thread_local may appear
   with static or extern. 120) *)

(* TODO: (ยง6.7.1#3) [...] If _Thread_local appears in any declaration of an object, it shall be present in every declaration of that object. *)
(* TODO: (ยง6.7.1#8) f an aggregate or union object is declared with a storage-class specifier other than typedef, the properties resulting from the storage-class specifier, except with respect to linkage, also apply to the members of the object, and so on recursively for any aggregate or union member objects. *)

val desugar_storages: declarationKind -> scope -> list C.storage -> E.t (option ATypes.storageDuration)
let desugar_storages kind scope ss =
  (* (ยง6.7.1#7) The declaration of an identifier for a function that has block
     scope shall have no explicit storage-class specifier other than extern. *)
  if kind = Function && scope = BlockScope then
    match ss with
      | [] ->
	  E.return None
      | [C.EXTERN] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
      | _ ->
	  E.fail Errors.CABS_TO_AIL_BLOCK_FUNCTION_STORAGE
    end
  else
    match ss with
      | [C.THREAD_LOCAL] ->
          (* (ยง6.7.1#3) In the declaration of an object with block scope, if the
             declaration specifiers include _Thread_local, they shall also include
	     either static or extern. [...] *)
          if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else if scope = BlockScope then
	    E.fail Errors.CABS_TO_AIL_BLOCK_THREAD_LOCAL_ALONE
	  else
	    E.return (Some ATypes.Thread)
      | [C.THREAD_LOCAL; C.STATIC] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: THREAD_LOCAL + STATIC")
      | [C.STATIC; C.THREAD_LOCAL] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: STATIC + THREAD_LOCAL")
      | [C.THREAD_LOCAL; C.EXTERN] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: THREAD_LOCAL + EXTERN")
      | [C.EXTERN; C.THREAD_LOCAL] ->
	  if kind = Function then
	    E.fail Errors.CABS_TO_AIL_THREAD_LOCAL_FUNCTION
	  else
	    E.fail (Errors.CSEM_HIP "desugar_storages: EXTERN + THREAD_LOCAL")

      | [] ->
  	  E.return None
      | [C.AUTO] ->
	  E.return (Some ATypes.Automatic)
      | [C.STATIC] ->
	  E.return (Some ATypes.Static)
      | [C.REGISTER] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class register")
      | [C.EXTERN] ->
	  E.fail (Errors.CSEM_NOT_SUPPORTED "storage class extern")
      | [C.TYPEDEF] -> E.return None  (* TODO: typedef is not really a storage class, but should be get the class of the aliased type??? *)

      | _::_::_ -> E.fail Errors.CABS_TO_AIL_MULTIPLE_STORAGE_CLASS
    end



val desugar_integerConstant: C.atom -> option C.integer_suffix -> A.integerConstant
let desugar_integerConstant str suff_opt =
  let desugar_integerSuffix = function
    | C.SUFFIX_UNSIGNED           -> A.U
    | C.SUFFIX_UNSIGNED_LONG      -> A.UL
    | C.SUFFIX_UNSIGNED_LONG_LONG -> A.ULL
    | C.SUFFIX_LONG               -> A.L
    | C.SUFFIX_LONG_LONG          -> A.LL
  end in
  let (n, basis) = Decode.decode_integer_constant str in
  match suff_opt with
    | Some suff -> (n, (* basis, *) Some (desugar_integerSuffix suff))
    | None      -> (n, (* basis, *) None)
  end

open E.Operators
(*
val desugar_character_constant: option C.character_prefix -> C.atom -> A.character_constant
(* TODO: decoding + impl-def independence (and Ail should store an integer, instead of a string) *) 
  let desugar_character_constant pref_opt str =
  let desugar_character_prefix = function
    | C.PREFIX_L -> A.PREFIX_L
    | C.PREFIX_u -> A.PREFIX_u
    | C.PREFIX_U -> A.PREFIX_U
  end in
  let n = Decode.decode_character_constant str in
  match pref_opt with
    | Some pref -> (Some (desugar_character_prefix pref), n)
    | None      -> (None, n)
  end
*)

val desugar_constant: C.constant -> E.t A.constant
let desugar_constant = function
  | C.CONST_INT str suff_opt ->
      E.return $ A.ConstantInteger (desugar_integerConstant str suff_opt)
  | C.CONST_FLOAT str ->
      E.fail (Errors.CSEM_NOT_SUPPORTED "float constants")
(*
  | C.CONST_CHAR pref_opt str ->
      E.return $ A.CONST_CHAR (desugar_character_constant pref_opt str)
*)
end


val desugar_cvspecs: list C.cvspec -> ATypes.qualifiers
let desugar_cvspecs =
  List.fold_left (fun qs ->
    function
    | C.CV_CONST    -> <| qs with ATypes.const    = true |>
    | C.CV_RESTRICT -> <| qs with ATypes.restrict = true |>
    | C.CV_VOLATILE -> <| qs with ATypes.volatile = true |>
    | C.CV_ATOMIC   -> Boot.assert_false "Cabs_to_ail.desugar_cvspecs [C.CV_ATOMIC]" (* <| qs with ATypes.atomic_q = true |> *)
    end
  ) ATypes.no_qualifiers

val separate_spec_elem_list : list C.spec_elem -> (list C.cvspec) * (list C.typeSpecifier)
let separate_spec_elem_list =
  List.fold_left
    (fun (cs, ts) s ->
      match s with
      | C.SpecCV      c -> (c :: cs, ts)
      | C.SpecAttr    _ -> Boot.assert_false "SpecAttr"
      | C.SpecStorage _ -> Boot.assert_false "SpecStorage"
      | C.SpecInline    -> Boot.assert_false "SpecInline"
      | C.SpecType    t -> (cs, t :: ts)
      end)
    ([], [])


(* We follow the multiset mapping from ยง6.7.2#2 (except that `void' is matched in [desugar_type]
   instead) *)
(* TODO: structs, enums, etc. *)
val desugar_basic_type_specifiers: Multiset.t C.typeSpecifier -> E.t (ATypes.basicType)
let desugar_basic_type_specifiers specifiers =
  let desugar_map =
    List.fold_left
      (fun m (x, bty) -> Pmap.add x bty m)
      (Ocaml.Pmap.empty Multiset.compare_int)
      (
        (* TODO: maybe move that somewhere else *)
          [(Multiset.from_list [C.Tchar], ATypes.Integer ATypes.Char)]

        @ [(Multiset.from_list [C.Tsigned; C.Tchar], ATypes.Integer (ATypes.Signed ATypes.Ichar))]
        @ [(Multiset.from_list [C.Tunsigned; C.Tchar], ATypes.Integer (ATypes.Unsigned ATypes.Ichar))]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.Short)))
          [ [C.Tshort];
            [C.Tsigned; C.Tshort];
            [C.Tshort; C.Tint];
            [C.Tsigned; C.Tshort; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.Short)))
          [ [C.Tunsigned; C.Tshort];
            [C.Tunsigned; C.Tshort; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.Int_)))
          [ [C.Tint];
            [C.Tsigned];
            [C.Tsigned; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.Int_)))
          [ [C.Tunsigned];
            [C.Tunsigned; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.Long)))
          [ [C.Tlong];
            [C.Tsigned; C.Tlong];
            [C.Tlong; C.Tint];
            [C.Tsigned; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.Long)))
          [ [C.Tunsigned; C.Tlong];
            [C.Tunsigned; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Signed ATypes.LongLong)))
          [ [C.Tlong; C.Tlong];
            [C.Tsigned; C.Tlong; C.Tlong];
            [C.Tlong; C.Tlong; C.Tint];
            [C.Tsigned; C.Tlong; C.Tlong; C.Tint]
          ]
        @ List.map (fun s -> (Multiset.from_list s, ATypes.Integer (ATypes.Unsigned ATypes.LongLong)))
          [ [C.Tunsigned; C.Tlong; C.Tlong];
            [C.Tunsigned; C.Tlong; C.Tlong; C.Tint]
          ]
(*
        @ [(Multiset.from_list [C.Tfloat], ATypes.REAL_FLOATING ATypes.FLOAT)]
        @ [(Multiset.from_list [C.Tdouble], ATypes.REAL_FLOATING ATypes.DOUBLE)]
        @ [(Multiset.from_list [C.Tlong; C.Tdouble], ATypes.REAL_FLOATING ATypes.LONG_DOUBLE)]
*)
        @ [(Multiset.from_list [C.T_Bool], ATypes.Integer ATypes.Bool)]
(*
        @ [(Multiset.from_list [C.Tfloat; C.COMPLEX], ATypes.COMPLEX ATypes.FLOAT)]
        @ [(Multiset.from_list [C.Tdouble; C.COMPLEX], ATypes.COMPLEX ATypes.DOUBLE)]
        @ [(Multiset.from_list [C.Tlong; C.Tdouble; C.COMPLEX], ATypes.COMPLEX ATypes.LONG_DOUBLE)]
*)
      ) in
  E.of_option (Errors.OTHER "[Cabs_to_ail.desugar_specifier] found a Cabs type that we don't yet handled.")
              (Map_.find specifiers desugar_map)


val desugar_type_specifiers : list C.typeSpecifier -> E.t (ATypes.ctype)
let desugar_type_specifiers = function
  (* TODO: ignore structs, enums, typedefs, ... *)
(*  | [C.atomic (specs, dt)] ->*)
  | [C.Tvoid] ->
      E.return ATypes.Void
  | ss ->
      ATypes.Basic <$> desugar_basic_type_specifiers (Multiset.from_list ss)
end


val desugar_spec_elem_list : list C.spec_elem -> E.t (ATypes.qualifiers * ATypes.ctype)
let desugar_spec_elem_list specs =
  let (cs, ts) = separate_spec_elem_list specs in
  let q = desugar_cvspecs cs in
  desugar_type_specifiers ts >>= fun t ->
  E.return (q, t)

val     desugar_decl_type : C.decl_type -> E.t (ATypes.ctype -> ATypes.ctype)
let rec desugar_decl_type decl_ty =
  match decl_ty with
  | C.JUSTBASE ->
      E.return $ fun ty -> ty
(*
  | C.ARRAY dt cvs _ None ->
      fun t ->
        (mk_ctype dt)
        (A.Array (desugar_cvspecs cvs) t None)
*)
  | C.ARRAY decl_ty' cvs _ (Some (C.CONSTANT (C.CONST_INT n None))) ->
      desugar_decl_type decl_ty' >>= fun mk_ty ->
      E.return $ fun ty -> mk_ty (ATypes.Array (* (desugar_cvspecs cvs) *) ty (fst (Decode.decode_integer_constant n))) (* TODO: for test purposes only ;) *)
  | C.ARRAY dt cvs _ (Some (C.CONSTANT e)) ->
      Boot.assert_false "Constant expressions other than integer constant not yet supported."
  | C.PTR cvs _ decl_ty' ->
      desugar_decl_type decl_ty' >>= fun mk_ty ->
      E.return $ fun ty -> mk_ty (ATypes.Pointer (desugar_cvspecs cvs) ty)
  (* TODO: ignoring variable length parameters for now *)
  | C.PROTO decl_ty' (params, _) ->
      desugar_decl_type decl_ty' >>= fun mk_ty    ->
      desugar_parameters params  >>= fun d_params ->
      E.return $ fun ty -> mk_ty (ATypes.Function ty $ List.map snd d_params)
  end


(*  desugar_parameters : list C.parameter -> E.t (list (A.identifier * (ATypes.qualifiers * ATypes.ctype))) *)
and desugar_parameters params =
  E.foldrM (fun (C.PARAM param_specs param_name_opt param_decl [] _) acc ->
    desugar_spec_elem_list param_specs >>= fun (param_qs, param_ty) ->
    (* (void) the special case of function with no parameters (ยง6.7.6.3#10) *)
    if param_ty = ATypes.Void then
      (if List.length params <> 1 then
        E.fail (Errors.OTHER "void' must be the first and only parameter if specified") (* TODO: proper message *)
      else if param_name_opt <> None then
        E.fail (Errors.OTHER "argument may not have 'void' type") (* TODO: proper message *)
      else
        E.return [])
    else
      (* OTHERWISE: the real stuff *)
      O.option 
        (E.fail (Errors.OTHER "parameter name omitted")) (* TODO: proper message *)
        (fun param_name ->
          E.register_name param_name         >>= fun param_id             ->
          desugar_spec_elem_list param_specs >>= fun (param_qs, param_ty) ->
          desugar_decl_type param_decl >>= fun mk_ty    ->
          E.return (param_id, (param_qs, mk_ty param_ty))
        ) param_name_opt >>= fun d_param ->
      E.return (d_param :: acc)
  ) params []


val desugar_assign_operator: C.binary_operator -> option A.arithmeticOperator
let desugar_assign_operator = function
  | C.ADD_ASSIGN ->
      Some A.Add
  | C.SUB_ASSIGN ->
      Some A.Sub
  | C.MUL_ASSIGN ->
      Some A.Mul
  | C.DIV_ASSIGN ->
      Some A.Div
  | C.MOD_ASSIGN ->
      Some A.Mod
  | C.BAND_ASSIGN ->
      Some A.Band
  | C.BOR_ASSIGN ->
      Some A.Bor
  | C.XOR_ASSIGN ->
      Some A.Xor
  | C.SHL_ASSIGN ->
      Some A.Shl
  | C.SHR_ASSIGN ->
      Some A.Shr
  | _ ->
      None
end


val     desugar_expression: C.expression -> E.t (A.expression unit)
let rec desugar_expression e =
  A.AnnotatedExpression () <$>
  match e with
  | C.UNARY uop e ->
      A.Unary (desugar_unary_operator uop) <$> desugar_expression e
  | C.BINARY C.ASSIGN e1 e2 ->
      A.Assign <$> desugar_expression e1 <*> desugar_expression e2
  | C.BINARY bop e1 e2 ->
      match desugar_assign_operator bop with
        | Some aop ->
            A.CompoundAssign <$> desugar_expression e1 <*> E.return aop <*> desugar_expression e2
        | None ->
            A.Binary <$> desugar_expression e1 <*> E.return (desugar_binary_operator bop) <*> desugar_expression e2
      end
  | C.QUESTION e1 e2 e3 ->
      A.Conditional <$> desugar_expression e1 <*> desugar_expression e2 <*> desugar_expression e3
  | C.CALL e es ->
      A.Call <$> desugar_expression e <*> E.mapM desugar_expression es
    (* A CAST can actually be a constructor expression *)
  | C.CAST (specs, decl_ty) ie ->
      desugar_spec_elem_list specs >>= fun (qs, ty)   ->
      desugar_decl_type decl_ty    >>= fun mk_ty      ->
      desugar_init_expression ie   >>= fun (Some d_e) ->
      E.return $ A.Cast qs ty d_e

(*
  | C11_ATOMIC_INIT of expression * expression
  | C11_ATOMIC_STORE of expression * expression * expression
  | C11_ATOMIC_LOAD of expression * expression
  | C11_ATOMIC_EXCHANGE of expression * expression * expression
  | C11_ATOMIC_COMPARE_EXCHANGE_STRONG of expression * expression * expression * expression * expression
  | C11_ATOMIC_COMPARE_EXCHANGE_WEAK of expression * expression * expression * expression * expression
  | C11_ATOMIC_FETCH_KEY of expression * expression * expression

  | BUILTIN_VA_ARG of expression * (list spec_elem * decl_type)
*)
  | C.CONSTANT cst ->
      A.Constant <$> desugar_constant cst
  | C.VARIABLE x ->
      A.Var <$> E.resolve_identifier x
  | C.EXPR_SIZEOF e ->
      E.fail (Errors.OTHER "new-Ail does not yet support sizeof(expr)")
  | C.TYPE_SIZEOF (specs, decl_ty) ->
      desugar_spec_elem_list specs >>= fun (qs, ty) ->
      desugar_decl_type decl_ty    >>= fun mk_ty    ->
      E.return $ A.SizeOf qs (mk_ty ty)
  | C.ALIGNOF (specs, decl_ty) ->
      desugar_spec_elem_list specs >>= fun (qs, ty) ->
      desugar_decl_type decl_ty    >>= fun mk_ty    ->
      E.return $ A.AlignOf qs (mk_ty ty)
  | C.INDEX e1 e2 ->
      (* Desugaring as in (ยง6.5.2.1#2) *)
      A.Unary A.Indirection <$> (
        A.AnnotatedExpression () <$>
          (A.Binary <$> desugar_expression e1 <*> E.return (A.Arithmetic A.Add) <*> desugar_expression e2)
      )
(*
  | MEMBEROF of expression * atom
  | MEMBEROFPTR of expression * atom
  | OFFSETOF of (list spec_elem * decl_type) * atom
*)
  | _ -> E.fail (Errors.OTHER "Some expression Ctors are not yet included in newAil")
end


and desugar_init_expression ie =
  match ie with
  | C.NO_INIT         -> E.return None
  | C.SINGLE_INIT   e -> Some <$> desugar_expression e
  | C.COMPOUND_INIT _ -> Boot.assert_false "COMPOUND_INIT"
  end


val     desugar_statement : C.statement  -> E.t (A.statement Location.t unit)
let rec desugar_statement stmt =
  A.AnnotatedStatement Location.dummy <$>
    match stmt with
      | C.NOP _ ->
          E.return A.Skip
      | C.COMPUTATION expr _ ->
          A.Expression <$> desugar_expression expr
      | C.BLOCK stmts _ ->
          (* TODO: documentation *)
          E.create_scope                          >>
          E.mapM desugar_statement stmts          >>= fun d_stmts ->
          E.destroy_scope                         >>= fun ids     ->
          E.mapM E.get_declaration ids            >>= fun decls   ->
          E.return $ A.Block (List.map2 Product.make ids decls) d_stmts

      | C.If expr stmt1 stmt2_opt _ ->
          (* (ยง6.8.3#3) allows us to add null operation without changing the
                       semantics of a statement *)
          A.If <$> desugar_expression expr
               <*> desugar_statement stmt1
               <*> Option.option (E.return $ A.AnnotatedStatement Location.dummy A.Skip)
                                 desugar_statement stmt2_opt
      | C.WHILE expr stmt _ ->
          A.While <$> desugar_expression expr
                  <*> desugar_statement stmt
      | C.DOWHILE expr stmt _ ->
          A.Do <$> desugar_statement stmt
               <*> desugar_expression expr
      | C.FOR fclause_opt e2_opt e3_opt s loc ->
          let are_all_auto_or_register (C.DECDEF (specs, _) _) =
            List.exist (function
(*
TODO: tmp
              | C.SpecStorage C.AUTO -> true
              | C.SpecStorage C.REGISTER -> true
              | _ -> false
*)
              | _ -> true
            end) specs in
          match fclause_opt with
            | None                 -> E.return (C.NOP loc)
            | Some (C.FC_EXP e1)   -> E.return (C.COMPUTATION e1 loc)
            | Some (C.FC_DECL def) ->
                if are_all_auto_or_register def then
                  E.return (C.DEFINITION def)
                else
                  E.fail Errors.CABS_TO_AIL_ITERATION_DECLARATON_WRONG_STORAGE
          end >>= fun s1 ->
          let e2' = match e2_opt with
            | Some e2 -> e2
              (* According to 6.8.5.3#2 (Iteration statements, Semantics - The for
                 statement) an omitted controlling expression is replace by an
                 unspecified non-zero integer constant. We believe that the choice, as
                 long as representable, does not matter with respect to the
                 semantics. Hence, we arbitrarily choose "1" (which can always be
                 represented as an object of type int). *)
            | None -> C.CONSTANT (C.CONST_INT "1" None)
          end in
          let s3 = match e3_opt with
            | Some e3 -> C.COMPUTATION e3 loc
            | None    -> C.NOP loc
          end in
          
          let body = C.BLOCK [s; s3] loc  in
          let loop = C.WHILE e2' body loc in
          desugar_statement (C.BLOCK [s1; loop] loc) >>= fun (A.AnnotatedStatement _ d_s) ->
          E.return d_s
      | C.BREAK _ ->
          E.return A.Break
      | C.CONTINUE _ ->
          E.return A.Continue
      | C.RETURN None _ ->
          E.return A.ReturnVoid
      | C.RETURN (Some expr) _f ->
          A.Return <$> desugar_expression expr
      | C.SWITCH expr stmt _ ->
          Boot.assert_false "HIP: desugar_statement  SWITCH"
      | C.CASE expr stmt _ ->
          (* (ยง6.8.1#2) "A case label shall appear only in a switch statement." *)
          ifElse E.is_inside_switch begin
          (* TODO: for now we only support impl-independent constant
                   expressions *)
(*
           desugar_integer_constant_expression expr >>= function
             | 
                 A.CASE <$> 

E.fail Errors.CABS_TO_AIL_CASE_NOT_INTEGER_CONSTANT_EXRESSION

*)	    

	    Boot.assert_false "HIP: desugar_statement CASE"
	  end (E.fail Errors.DEFAULT_OUTSIDE_SWITCH)
      | C.DEFAULT stmt _ ->
          (* (ยง6.8.1#2) "A default label shall appear only in a switch statement." *)
	  ifElse E.is_inside_switch
            (A.Default <$> desugar_statement stmt)
	    (E.fail Errors.DEFAULT_OUTSIDE_SWITCH)
      | C.LABEL lab stmt _ ->
	  A.Label <$> fetch_label lab
	          <*> desugar_statement stmt
      | C.GOTO lab _ ->
          A.Goto <$> fetch_label lab
      | C.DEFINITION (C.DECDEF ing _) ->
      	  A.Declaration <$> desugar_declaration ing
(*
      | C.PAR stmts _ ->
          A.PAR <$> E.mapM desugar_statement stmts
*)
  end


(*  desugar_init_name : C.init_name -> E.t (Symbol.t * (ATypes.ctype -> ATypes.ctype) * option (A.expression unit)) *)
and desugar_init_name iname =
  let C.Init_name (C.Name name decl_ty _ _) ie = iname in
  E.register_name name       >>= fun v     ->
  desugar_init_expression ie >>= fun e_opt ->
  desugar_decl_type decl_ty  >>= fun mk_ty ->
  E.return (v, mk_ty , e_opt)


(*  desugar_declaration: C.init_name_group -> E.t (list (Symbol.t * A.expression unit)) *)
and desugar_declaration (specs, ins) =
  desugar_spec_elem_list specs >>= fun (qs, ty) ->
  E.mapM desugar_init_name ins >>= fun decls    ->
  filter_opt <$> E.mapM (fun (id, mk_ty, e_opt) ->
                   E.add_declaration id qs (mk_ty ty) >>
                   E.return
                     match e_opt with
                     | Some e -> Some (id, e)
                     | None   -> None
                     end
                 ) decls


(* TODO: to support VLAs we need to extend the scope of parameters ids *)
(*  desugar_definition: C.definition -> E.t unit *)
and desugar_definition def =
  match def with
    | C.FUNDEF specs (C.Name fun_name fun_decl [] _) stmt _ ->
        desugar_spec_elem_list specs >>= fun (qs, ty) -> (* TODO: q should be A.no_qualifiers; check! *)
        E.register_name fun_name     >>= fun fun_id   ->
        register_labels stmt         >>
        (* TODO: storage class *)
        (* starts the function scope *)
        E.create_scope >>
        match fun_decl with
          | C.PROTO _ (params, _) ->
              desugar_parameters params
          | _ ->
              E.fail (Errors.OTHER "Not a function type.")
        end >>= fun d_params ->
        desugar_statement stmt >>= fun d_stmt ->
        E.destroy_scope        >>
        E.add_function fun_id ((ty, d_params), d_stmt)

    (* This should correspond to the def of a struct/union (typedef?) *)
  | C.DECDEF (specs, []) loc ->
      Boot.assert_false "HIP: desugar_definition DECDEF (case 1)"
  | C.DECDEF ing loc ->
      Boot.assert_false "HIP: desugar_definition DECDEF (case 2)"
  | C.PRAGMA at loc ->
      E.fail (Errors.CSEM_NOT_SUPPORTED "PRAGMA definitions")
end


val desugar: C.atom -> C.file -> Exception.t (A.program Location.t unit) Errors.t
let desugar startup defs =
  E.eval (
    E.mapM_ desugar_definition defs >>
    E.tryWith (Location.dummy, Errors.CABS_TO_AIL_NO_STARTUP startup) (E.resolve_identifier startup)
  )
