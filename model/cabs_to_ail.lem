open import Pervasives Cabs AilSyntax Std

open import Cabs_to_ail_aux
import Cabs_to_ail_effect

import Boot Cabs Multiset Decode UniqueId
import AilTypes AilTypesAux Builtins


module ATypes = AilTypes


module E = Cabs_to_ail_effect

let inline (>>=)    = E.bind
let inline (>>) m f = m >>= fun _ -> f
let inline (<$>)    = E.fmap
let inline (<*>)    = E.app



type declaration_context =
  | Object_decl_context
  | Function_decl_context









(*
val determinate_linkage: declaration -> E.linkage
let determinate_linkage = function
  | Declaration_base specifs idecltors ->
      
  | Declaration_static_assert _ ->
      
end
*)






















val determinate_storage_duration: E.linkage -> specifiers -> ATypes.storageDuration
let determinate_storage_duration link specifs =
  let scs = specifs.storage_classes in
  if not (List.elem SC_Thread_local scs) &&
     (link = E.Linkage_external || link = E.Linkage_internal ||
      List.elem SC_static scs) then
_STD "§6.2.4#3, sentence 1"
    ATypes.Static
  
  else if List.elem SC_Thread_local scs then
_STD "§6.2.4#4, sentence 1"
    ATypes.Thread
  
  else if link = E.Linkage_none && not (List.elem SC_static scs) then
_STD "§6.2.4#5, sentence 1"
    ATypes.Automatic
  
  else
    Boot.assert_false "determinate_storage_duration"











val desugar_generic_association:        generic_association -> E.t unit (* TODO *)
val desugar_declaration:                declaration -> E.t (list (sigma_declaration Location.t unit))
val desugar_specifiers:                 declaration_context -> E.scope -> specifiers -> E.t unit (* TODO *)
val desugar_init_declarator:            init_declarator -> E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype) * maybe (expression unit))
val desugar_struct_declaration:         struct_declaration -> E.t unit (* TODO *)
val desugar_struct_declarator:          struct_declarator -> E.t unit (* TODO *)
val desugar_enumerator:                 enumerator -> E.t unit (* TODO *)
val desugar_alignment_specifier:        alignment_specifier -> E.t unit (* TODO *)

(* NOTE: these twos functions do NOT register identifier being declared, this is
         left to the called (who can know the `kind' of the identifier from its
         type *)
val desugar_declarator:                 declarator        -> E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype))
val desugar_direct_declarator:          direct_declarator -> E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype))


val desugar_array_declarator:           bool -> array_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)
val desugar_parameter_array_declarator: array_declarator -> E.t unit (* TODO *)
val desugar_array_declarator_size:      array_declarator_size -> E.t unit (* TODO *)
val desugar_pointer_declarator:         pointer_declarator -> E.t (ATypes.ctype -> ATypes.ctype)
val desugar_parameter_type_list:        parameter_type_list -> E.t (list (maybe (cabs_identifier * list storage_class_specifier) *
                                                                          (ATypes.qualifiers * ATypes.ctype)) * bool)
val desugar_parameter_declaration:      parameter_declaration -> E.t (maybe (cabs_identifier * list storage_class_specifier) *
                                                                      (ATypes.qualifiers * ATypes.ctype))


val desugar_type_name:                  type_name -> E.t (ATypes.qualifiers * AilTypes.ctype)
val desugar_abstract_declarator:        bool -> abstract_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)
val desugar_direct_abstract_declarator: bool -> direct_abstract_declarator -> E.t (AilTypes.ctype -> AilTypes.ctype)


val desugar_initializer_:               initializer_ -> E.t (expression unit) (* TODO *)
val desugar_designator:                 designator -> E.t unit (* TODO *)
val desugar_static_assert_declaration:  static_assert_declaration -> E.t (sigma_declaration Location.t unit)
val desugar_for_clause:                 for_clause -> E.t unit (* TODO *)




































val translate_integer_suffix: cabs_integer_suffix -> integerSuffix
let translate_integer_suffix = function
  | CabsSuffix_U   -> U
  | CabsSuffix_UL  -> UL
  | CabsSuffix_ULL -> ULL
  | CabsSuffix_L   -> L
  | CabsSuffix_LL  -> LL
end


val translate_integer_constant: cabs_integer_constant -> integerConstant
let translate_integer_constant (str, suff_opt) =
  let (basis, n) = Decode.decode_integer_constant str in
  match suff_opt with
    | Just suff -> (n, basis, Just (translate_integer_suffix suff))
    | Nothing   -> (n, basis, Nothing)
  end


val translate_character_constant: cabs_character_prefix -> characterPrefix
let translate_character_constant = function
  | CabsPrefix_L -> Pref_L
  | CabsPrefix_u -> Pref_u
  | CabsPrefix_U -> Pref_U
end


val desugar_character_constant: cabs_character_constant -> E.t characterConstant
let desugar_character_constant (pref_opt, str) =
  Boot.assert_false "WIP 2"






















val translate_unary_operator: cabs_unary_operator -> unaryOperator
let translate_unary_operator = function
  | CabsAddress     -> Address
  | CabsIndirection -> Indirection
  | CabsPlus        -> Plus
  | CabsMinus       -> Minus
  | CabsBnot        -> Bnot
  (* This case cannot occurs since Not is translated away. *)
  | CabsNot         -> Boot.assert_false "[Cabs_to_ail.translate_unary_operator] Not"
end


val translate_arithmetic_operator: cabs_binary_operator -> arithmeticOperator
let translate_arithmetic_operator = function
  | CabsAdd  -> Add
  | CabsSub  -> Sub
  | CabsMul  -> Mul
  | CabsDiv  -> Div
  | CabsMod  -> Mod
  | CabsBand -> Band
  | CabsBxor -> Bxor
  | CabsBor  -> Bor
  | CabsShl  -> Shl
  | CabsShr  -> Shr
  | _ -> Boot.assert_false "[Cabs0_to_ail.translate_arithmetic_operator] should only be called on \
                            operators allowed for compound assignments [§6.5.16#1]."
end


val translate_binary_operator: cabs_binary_operator -> binaryOperator
let translate_binary_operator = function
  | CabsAnd   -> And
  | CabsOr    -> Or
  | CabsEq    -> Eq
  | CabsNe    -> Ne
  | CabsLt    -> Lt
  | CabsGt    -> Gt
  | CabsLe    -> Le
  | CabsGe    -> Ge
  | op      -> Arithmetic (translate_arithmetic_operator op)
end


val translate_assignment_operator: cabs_assignment_operator -> maybe arithmeticOperator
let translate_assignment_operator = function
  | CabsAssign      -> Nothing
  | CabsAssign_Mul  -> Just Mul
  | CabsAssign_Div  -> Just Div
  | CabsAssign_Mod  -> Just Mod
  | CabsAssign_Add  -> Just Add
  | CabsAssign_Sub  -> Just Sub
  | CabsAssign_Shl  -> Just Shl
  | CabsAssign_Shr  -> Just Shr
  | CabsAssign_Band -> Just Band
  | CabsAssign_Bxor -> Just Bxor
  | CabsAssign_Bor  -> Just Bor
end

(* TODO
val translate_storage_class_specifier: C.storage_class_specifier -> 
let translate_storage_class_specifier = function
  | C.SC_typedef
  | C.SC_extern
  | C.SC_static
  | C.SC_Thread_local
  | C.SC_auto
  | C.SC_register
end
*)


val desugar_basic_type_specifiers: Multiset.t cabs_type_specifier -> E.t (ATypes.basicType)
let desugar_basic_type_specifiers specs =
_STD "§6.7.2#2, sentence 2 (non `void' case)" $
  if      specs = Multiset.from_list [TSpec_char] then
    E.return $ ATypes.Integer ATypes.Char
  else if specs = Multiset.from_list [TSpec_signed; TSpec_char] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Ichar)
  else if specs = Multiset.from_list [TSpec_unsigned; TSpec_char] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Ichar)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_short];
            Multiset.from_list [TSpec_signed; TSpec_short];
            Multiset.from_list [TSpec_short; TSpec_int];
            Multiset.from_list [TSpec_signed; TSpec_short; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned; TSpec_short];
            Multiset.from_list [TSpec_unsigned; TSpec_short; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Short)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_int];
            Multiset.from_list [TSpec_signed];
            Multiset.from_list [TSpec_signed; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned];
            Multiset.from_list [TSpec_unsigned; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Int_)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_long];
            Multiset.from_list [TSpec_signed; TSpec_long];
            Multiset.from_list [TSpec_long; TSpec_int];
            Multiset.from_list [TSpec_signed; TSpec_long; TSpec_int] ]then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned; TSpec_long];
            Multiset.from_list [TSpec_unsigned; TSpec_long; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.Long)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_long; TSpec_long];
            Multiset.from_list [TSpec_signed; TSpec_long; TSpec_long];
            Multiset.from_list [TSpec_long; TSpec_long; TSpec_int];
            Multiset.from_list [TSpec_signed; TSpec_long; TSpec_long; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Signed ATypes.LongLong)
  else if List.any (fun z -> specs = z) [
            Multiset.from_list [TSpec_unsigned; TSpec_long; TSpec_long];
            Multiset.from_list [TSpec_unsigned; TSpec_long; TSpec_long; TSpec_int] ] then
    E.return $ ATypes.Integer (ATypes.Unsigned ATypes.LongLong)
  else if specs = Multiset.from_list [TSpec_Bool] then E.return $ ATypes.Integer (ATypes.Bool)
  (* NOTE: real floating not supported *)
  else if    specs = Multiset.from_list [TSpec_float]
          || specs = Multiset.from_list [TSpec_double]
          || specs = Multiset.from_list [TSpec_long; TSpec_double]
          || specs = Multiset.from_list [TSpec_float; TSpec_Complex]
          || specs = Multiset.from_list [TSpec_double; TSpec_Complex]
          || specs = Multiset.from_list [TSpec_long; TSpec_double; TSpec_Complex] then
    E.fail $ Errors.Desugar_NotSupported "real floating types"
  else
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.2#2, 2nd sentence")


val desugar_type_specifiers : list cabs_type_specifier -> E.t (ATypes.ctype)
let desugar_type_specifiers = function
  | [] ->
_STD "§6.7.2#2, sentence 1"
      E.fail (Errors.Desugar_ConstraintViolation "§6.7.2#2, 1st sentence")
  
  | [TSpec_void] ->
_STD "§6.7.2#2, sentence 2 (`void' case)"
      E.return ATypes.Void


(*  WIP

  
  | [TSpec_Atomic tyname] -> do E
      (qs, ty) <- desugar_type_name tyname; in
        E.return (ATypes.Atomic ty)
      end

  | [TSpec_struct id_opt sdecls_opt] ->
      Boot.assert_false "TODO"
  
  | [TSpec_union id_opt sdecls_opt] ->
      Boot.assert_false "TODO"
  
  | [TSpec_enum id_opt enums_opt] ->
      Boot.assert_false "TODO"
  
    (* TODO: this break impl-def independance *)
  | [TSpec_name str] ->
      match Builtins.translate_builtin_typenames str with
        | Just ty ->
            E.return ty
        | Nothing ->
            (* TODO [tmp hack] removing the qualifiers *)
            E.get_typedef str >>= fun (qs, ty) ->
            E.return ty
      end
*)  

  | ss ->
      ATypes.Basic <$> desugar_basic_type_specifiers (Multiset.from_list ss)
end


val translate_type_qualifiers: list cabs_type_qualifier -> ATypes.qualifiers
let translate_type_qualifiers qs =
_STD "§6.7.3#5, sentence 1" $
  ATypes.make_qualifiers
    (List.elem Q_const qs) (List.elem Q_restrict qs)
    (List.elem Q_volatile qs) (List.elem Q_Atomic qs)














(*
int                                     int
int *                                   pointer to int
int *[3]                                array of three pointers to int
int ( * )[3]                            pointer to an array of three ints
int ( * )[*]                            pointer to a variable length array of an unspecified number of ints,
int *()                                 function with no parameter specification returning a pointer to int
int ( * )(void)                         pointer to function with no parameters returning an int
int ( * const [])(unsigned int, ...)    array of an unspecified number of constant pointers to functions, each with
                                        one parameter that has type unsigned int and an unspecified number of other
                                        parameters, returning an int.



*)











































val desugar_cabs_constant: forall 'a. cabs_constant -> E.t constant
let desugar_cabs_constant = function
  | CabsInteger_const iCst ->
      E.return (ConstantInteger (translate_integer_constant iCst))
  | CabsFloating_const str ->
      Boot.assert_false "CabsFloating_const"
  | CabsEnumeration_const ->
      Boot.assert_false "CabsEnumeration_const"
  | CabsCharacter_const cCst ->
      Boot.assert_false "CabsCharacter_const"
end




val desugar_cabs_string_literal: forall 'a. cabs_string_literal -> E.t 'a (* TODO *)
let desugar_cabs_string_literal lit =
  Boot.assert_false "WIP 7"


val     desugar_expression: cabs_expression -> E.t (expression unit)
let rec desugar_expression expr =
  AnnotatedExpression () <$>
  match expr with
    | CabsEident ident ->
        let _ = Boot.output_string ("desugar_expression: " ^ ident) in
_STD "§6.5.1#2" $
        E.resolve_identifier ident E.Namespace_ordinary >>= function
          | Just (_, (id, kind, _)) ->
              (* I love the fact that it is a footnote that says that undeclared
                 identifiers are syntax errors ... *)
              if not (E.is_object_kind kind || kind = E.Kind_function) then
                E.fail (Errors.Desugar_OtherViolation "§6.5.1#2")
              else
                E.return (AilEident id)
          | Nothing ->
              E.fail (Errors.Desugar_OtherViolation "§6.5.1#2")
        end
    
    | CabsEconst cst ->
        AilEconst <$> desugar_cabs_constant cst
    | CabsEstring lit ->
        Boot.assert_false "WIP 10"
    | CabsEgeneric e gas ->
        Boot.assert_false "WIP 11"
    | CabsEsubscript e1 e2 ->
_STD "§6.5.2.1#2, sentence 2" $
        AilEunary Indirection <$> (
          AnnotatedExpression () <$>
          (AilEbinary <$> desugar_expression e1
                      <*> E.return (Arithmetic Add)
                      <*> desugar_expression e2)
        )
    | CabsEcall e es ->
        (* TODO: STD check + annot *)
        AilEcall <$> desugar_expression e <*> E.mapM desugar_expression es
    | CabsEmemberof e id ->
        Boot.assert_false "WIP 14"
    | CabsEmemberofptr e id ->
        Boot.assert_false "WIP 15"
    | CabsEpostincr e ->
        AilEunary PostfixIncr <$> desugar_expression e
    | CabsEpostdecr e ->
        AilEunary PostfixDecr <$> desugar_expression e
    | CabsEcompound tyname inits ->
        Boot.assert_false "WIP 18"
    | CabsEpreincr e ->
_STD "§6.5.3.1#2, sentence 3" $
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Add (AnnotatedExpression () (AilEconst (ConstantInteger (1, Decimal, Nothing))))
    | CabsEpredecr e ->
_STD "§6.5.3.1#3" $
        desugar_expression e >>= fun d_e ->
        E.return $ AilEcompoundAssign d_e Sub (AnnotatedExpression () (AilEconst (ConstantInteger (1, Decimal, Nothing))))
    | CabsEunary uop e ->
        desugar_expression e >>= fun d_e ->
        E.return $ AilEunary (translate_unary_operator uop) d_e
    | CabsEsizeof_expr e ->
        Boot.assert_false "WIP 22"
    | CabsEsizeof_type tyname ->
        (* TODO: STD check + annot *)
        desugar_type_name tyname >>= fun (qs, ty) ->
        E.return $ AilEsizeof qs ty
    | CabsEalignof tyname ->
        Boot.assert_false "WIP 24"
    | CabsEcast tyname e ->
        Boot.assert_false "WIP 25"

    | CabsEbinary bop e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return (translate_binary_operator bop)
                   <*> desugar_expression e2
    | CabsEcond e1 e2 e3 ->
        AilEcond <$> desugar_expression e1
                 <*> desugar_expression e2
                 <*> desugar_expression e3
    | CabsEassign aop e1 e2 ->
        match translate_assignment_operator aop with
          | Nothing  -> AilEassign
          | Just aop -> (fun z -> AilEcompoundAssign z aop)
        end <$> desugar_expression e1
            <*> desugar_expression e2
    | CabsEcomma e1 e2 ->
        AilEbinary <$> desugar_expression e1
                   <*> E.return Comma
                   <*> desugar_expression e2
  end

and desugar_generic_association gas =
  match gas with
    | GA_type tyname e ->
        Boot.assert_false "WIP 30"
    | GA_default e ->
        Boot.assert_false "WIP 31"
  end




(* val desugar_declaration: declaration -> sigma_declaration *)
(* TODO: STD check + annot *)
and desugar_declaration (decl: declaration) : E.t (list (sigma_declaration Location.t unit)) =
  match decl with
    | Declaration_base specifs idecltors -> do E
        ty' <- desugar_type_specifiers specifs.type_specifiers;
        xs  <- E.mapM desugar_init_declarator idecltors; in
          E.mapM (fun (ident, mk_ty, d_e_opt) ->
            let ty = mk_ty ty' in
            let qs = translate_type_qualifiers specifs.type_qualifiers in
            E.register_identifier ident E.Namespace_ordinary
              (if AilTypesAux.is_function ty then E.Kind_function else E.Kind_object false qs ty) specifs.storage_classes >>= fun id ->
            E.return $ SDecl_global id (qs, ty, d_e_opt)
          ) xs
        end

(*
do E
        ty <- desugar_type_specifiers specifs.type_specifiers;
        xs <- E.mapM desugar_init_declarator idecltors; in
          E.return $ map (fun (ident, mk_ty, Nothing) ->
              match mk_ty ty with

(* TODO: this is wrong
                | ATypes.Function return_ty params is_variadic ->
                    SDecl_fun sym <| fun_return_ty=   return_ty;
                                     fun_bindings=    [] (* TODO *);
                                     fun_is_variadic= is_variadic;
                                     fun_is_inline=   List.elem FS_inline   specifs.function_specifiers;
                                     fun_is_Noreturn= List.elem FS_Noreturn specifs.function_specifiers;
                                     fun_body=        Nothing (* TODO *);
                                  |>
*)

                | ty' ->
                    SDecl_global sym (translate_type_qualifiers specifs.type_qualifiers, ty', Nothing)
              end
            ) xs
        end
*)
    | Declaration_static_assert sa_decl -> do E
        z <- desugar_static_assert_declaration sa_decl; in
          E.return [z]
        end
  end


and desugar_specifiers decl_ctxt scope specifs =
  let scs = specifs.storage_classes in
  if not (List.length scs <= 1 || List.elem SC_Thread_local scs &&
                                  (List.elem SC_static scs || List.elem SC_extern scs))then
_STD "§6.7.1#2" $
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#2")
  
  else if not (decl_ctxt = Object_decl_context && scope = E.Scope_block &&
               List.elem SC_Thread_local scs -->
                 (List.elem SC_static scs || List.elem SC_extern scs)
              ) then
_STD "§6.7.1#3, sentence 1" $
         E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#3, 1st sentence")
  
  else if decl_ctxt = Function_decl_context && List.elem SC_Thread_local scs then
_STD "§6.7.1#4" $
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#4")
  
  else if not (decl_ctxt = Function_decl_context && scope = E.Scope_block -->
               scs = [] || scs = [SC_extern]) then
_STD "§6.7.1#7" $
    E.fail (Errors.Desugar_ConstraintViolation "§6.7.1#7")
  else
_STD "§6.7.1#8" $ (* TODO *)
    Boot.assert_false "WIP 33"

(*
<|
  C.storage_classes:      list storage_class_specifier;
  C.type_specifiers:      list type_specifier;
  C.type_qualifiers:      list type_qualifier;
  C.function_specifiers:  list function_specifier;
  C.alignment_specifiers: list alignment_specifier;
|>
*)

(* TODO: check *)
and desugar_init_declarator idecltor : E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype) * maybe (expression unit)) =
  match idecltor with
    | InitDecl decltor Nothing ->
        desugar_declarator decltor >>= fun (ident, mk_ty) ->
        E.return (ident, mk_ty, Nothing)
    | InitDecl decltor (Just init) ->
        desugar_declarator decltor >>= fun (ident, mk_ty) ->
        desugar_initializer_ init  >>= fun d_e            ->
        E.return (ident, mk_ty, Just d_e)
  end



and desugar_struct_declaration struct_decl =
  match struct_decl with
    | Struct_declaration specs qs struct_decltor ->
        Boot.assert_false "WIP 35"
    | Struct_assert sa_decl ->
        Boot.assert_false "WIP 36"
  end

and desugar_struct_declarator struct_decltor =
  match struct_decltor with
    | SDecl_simple decltor ->
        Boot.assert_false "WIP 37"
    | SDecl_bitfield declor_opt e ->
        Boot.assert_false "WIP 38"
  end

and desugar_enumerator (id, e_opt) =
  Boot.assert_false "WIP 39"


and desugar_alignment_specifier align_spec =
  match align_spec with
    | AS_type tyname ->
      Boot.assert_false "WIP 40"
    | AS_expr e ->
      Boot.assert_false "WIP 41"
  end


(* val desugar_declarator: declarator -> E.t (identifier * ATypes.ctype -> ATypes.ctype) *)
and desugar_declarator (Declarator ptr_decltor_opt ddecltor) : E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype)) = do E
  mk_ptr_type      <- maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt;
  (ident, mk_type) <- desugar_direct_declarator ddecltor; in
    E.return (ident, fun ty -> mk_type $ mk_ptr_type ty)
end


and desugar_direct_declarator ddecltor : E.t (cabs_identifier * (ATypes.ctype -> ATypes.ctype)) =
  match ddecltor with
    | DDecl_identifier ident ->
        E.return (ident, fun ty -> ty)
    | DDecl_declarator decltor ->
        desugar_declarator decltor
    
      (* TODO: STD check + annot *)
    | DDecl_array ddecltor a_decltor -> do E
        (ident, mk_type) <- desugar_direct_declarator ddecltor;
        mk_array_type    <- desugar_array_declarator (* TODO: is_under_array *) false a_decltor; in
          E.return (ident, fun ty -> mk_type (mk_array_type ty))
        end
    
    | DDecl_function ddecltor param_tys ->
        (* TODO: check + annotate with STD *)
        desugar_direct_declarator ddecltor    >>= fun (ident, mk_ty)    ->
        desugar_parameter_type_list param_tys >>= fun (xs, is_variadic) ->
        E.with_scope E.Scope_prototype (
          E.mapM_ (function
            | (Just (ident, storage_classes), (qs, ty)) ->
                E.void $
                  E.register_identifier ident
                    E.Namespace_ordinary (E.Kind_object true qs ty) storage_classes
            | (Nothing, _) ->
                E.return ()
          end
          ) xs
        ) >>
        (* TODO: check *)
        E.return (ident, fun ty -> mk_ty (ATypes.Function ty (List.map snd xs) is_variadic))

(*
        E.register_identifier ident
          E.Namespace_ordinary E.Kind_object specifs.storage_classes >>= fun sym            ->
*)




(* WIP
_STD "§6.7.6.3#5" $
          E.return (sym, fun ty -> mk_ty (ATypes.Function ty bs is_variadic))
        end
*)
  end

and desugar_array_declarator is_under_array a_decltor =
  match a_decltor with
    | ADecl _ _ Nothing ->
        E.fail (Errors.Desugar_NotSupported "array type with no size")
    
    | ADecl _ _ (Just ADeclSize_asterisk) ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              E.fail (Errors.Desugar_NotSupported "variable length array type")
          | _ ->
              E.fail (Errors.Desugar_ConstraintViolation "§6.7.6.2#4, 2nd sentence")
        end
    
    (* TODO: hacking the simple case for now *)
    | ADecl [] false (Just (ADeclSize_expression (CabsEconst (CabsInteger_const (str,_))))) ->
        E.return (fun ty -> ATypes.Array ty (snd $ Decode.decode_integer_constant str))
    
    | ADecl [] false (Just (ADeclSize_expression e)) ->
        E.return (fun ty -> ATypes.Array ty 42) (* TODO: constant *)
    
    | ADecl qs is_static a_decltor_size_opt ->
        E.get_scope >>= function
          | E.Scope_prototype ->
              if is_under_array then
_STD "§6.7.6.2#1, sentence 5" $
                E.fail (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, 5th sentence")
              else
                E.return ()
          | _ ->
              if qs <> [] || is_static then
_STD "§6.7.6.2#1, sentence 5" $
                E.fail (Errors.Desugar_ConstraintViolation "§6.7.6.2#1, 5th sentence")
              else
                E.return ()
        end >>
        Boot.assert_false "WIP 46"
  end


(* NOTE: this is called for declarators of function parameters *)
and desugar_parameter_array_declarator a_decltor =
  match a_decltor with
    | ADecl qs is_static a_decltor_size ->
        Boot.assert_false "WIP desugar_parameter_array_declarator"
  end

and desugar_array_declarator_size a_decltor_size =
  match a_decltor_size with
    | ADeclSize_expression e ->
        Boot.assert_false "WIP 47"
    | ADeclSize_asterisk ->
        Boot.assert_false "WIP 48"
  end

(* val desugar_pointer_declarator: pointer_declarator -> E.t (ctype -> ctype) *)
and desugar_pointer_declarator ptr_decltor =
  match ptr_decltor with
    | PDecl tquals ptr_decltor_opt ->
_STD "§6.7.6.1#1" do E
        mk_ty <- maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt; in
          let ptr_qs = translate_type_qualifiers tquals in
          E.return $
            fun ty -> ATypes.Pointer ptr_qs ty
        end
  end

and desugar_parameter_type_list params =
  match params with
    | Params param_decls is_variadic -> do E
        xs <- E.mapM desugar_parameter_declaration param_decls; in
          E.return (xs, is_variadic)
        end
  end

and desugar_parameter_declaration param_decl =
  match param_decl with
    | PDeclaration_decl specifs decltor ->
        desugar_type_specifiers specifs.type_specifiers >>= fun ty             ->
        desugar_declarator decltor                      >>= fun (ident, mk_ty) ->
        E.return (Just (ident, specifs.storage_classes), (translate_type_qualifiers specifs.type_qualifiers, mk_ty ty))
    
    | PDeclaration_abs_decl specifs abs_decltor_opt ->
        desugar_type_specifiers specifs.type_specifiers                         >>= fun ty    ->
        maybe (E.return id) (desugar_abstract_declarator false) abs_decltor_opt >>= fun mk_ty ->
        E.return (Nothing, (translate_type_qualifiers specifs.type_qualifiers, mk_ty ty))
  end









(* STATUS: maybe ok *)
(* val     desugar_type_name: type_name -> E.t (ATypes.qualifiers * ATypes.ctype) *)
and desugar_type_name (Type_name specs tquals abs_decltor_opt) = do E
  ty    <- desugar_type_specifiers specs;
  mk_ty <- maybe (E.return id) (desugar_abstract_declarator false) abs_decltor_opt; in
    E.return (translate_type_qualifiers tquals, mk_ty ty)
  end


(* TODO: yuck *)
(* the bool argument `is_under_array' is true iff we went through array type derivation
   since the last call to desugar_type_name *)
and desugar_abstract_declarator is_under_array abs_decltor =
  match abs_decltor with
    | AbsDecl_pointer ptr_decltor ->
        desugar_pointer_declarator ptr_decltor
    | AbsDecl_direct ptr_decltor_opt dabs_decltor -> do E
        mk_ptr_type <- maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt;
        mk_ty       <- desugar_direct_abstract_declarator is_under_array dabs_decltor; in
          E.return (fun ty -> mk_ty (mk_ptr_type ty))
        end
  end


and desugar_direct_abstract_declarator is_under_array dabs_decltor =
  match dabs_decltor with
    | DAbs_abs_declarator abs_decltor ->
        desugar_abstract_declarator is_under_array abs_decltor
    | DAbs_array dabs_decltor_opt a_decltor -> do E
        mk_ty         <- maybe (E.return id) (desugar_direct_abstract_declarator true) dabs_decltor_opt;
        mk_array_type <- desugar_array_declarator is_under_array a_decltor; in
          E.return (fun ty -> mk_ty (mk_array_type ty))
        end
    | DAbs_function dabs_decltor_opt param_tys -> do E
        mk_ty             <- maybe (E.return id) (desugar_direct_abstract_declarator is_under_array) dabs_decltor_opt;
        (_, (tys, is_variadic)) <- E.with_scope E.Scope_prototype (desugar_parameter_type_list param_tys); in
          (* TODO: check *)
          E.return (fun ty -> mk_ty (ATypes.Function ty (List.map snd tys) is_variadic))
        end
  end

























and desugar_initializer_ init =
  match init with
    | Init_expr e ->
        desugar_expression e
    | Init_list inits ->
        Boot.assert_false "WIP 58"
  end

and desugar_designator desig =
  match desig with
    | Desig_array e ->
       Boot.assert_false "WIP 59"
    | Desig_member id ->
       Boot.assert_false "WIP 60"
  end


and desugar_static_assert_declaration sa_decl =
  match sa_decl with
   | Static_assert e str ->
       Boot.assert_false "WIP 61"
  end


val     desugar_statement: cabs_statement -> E.t (statement Location.t unit)
let rec desugar_statement stmt =
  AnnotatedStatement Location.dummy <$>
    match stmt with
      | CabsSlabel id s ->
	  AilSlabel <$> E.resolve_label id
                    <*> desugar_statement s
      | CabsScase e s -> do E
          b <- E.is_switch_body; in
            if b then do E
(* WIP              d_e <- desugar_expression e; *)
              d_s <- desugar_statement s; in
                Boot.assert_false "WIP 62"
              end
            else
_STD "§6.8.1#2" $
              E.fail (Errors.Desugar_ConstraintViolation "§6.8.1#2")
          end
      | CabsSdefault s ->
          Boot.assert_false "WIP 63"
      | CabsSblock ss ->
          (* TODO: STD check + annot *)
          E.with_scope E.Scope_block (
            E.mapM desugar_statement ss
          ) >>= fun (bs, d_ss) ->
          E.return (AilSblock bs d_ss)
      | CabsSdecl decl -> do E
          (* TODO: STD check + annot *)
          sdecls <- desugar_declaration decl; in

          let _ = Boot.output_string ("CabsSdecl> " ^ string_of_natural (naturalFromNat (List.length sdecls))) in

          (* TODO need to move the binding information up to the enclosing CabsSblock *)
            AilSdeclaration <$> E.foldrM (fun sdecl acc ->
              match sdecl with
                | SDecl_fun id fdecl ->
                    E.return acc (* TODO ? *)
                | SDecl_global id (qs, ty, e_opt) ->
                    match e_opt with
                      | Just e  -> E.return $ (id, e) :: acc
                      | Nothing -> E.return acc
                    end
                | SDecl_static_assert e strCst ->
                    Boot.assert_false "CabsSdecl, SDecl_static_assert"
              end) sdecls []
          end

      | CabsSnull ->
          E.return AilSskip

      | CabsSexpr e ->
          AilSexpr <$> desugar_expression e

      | CabsSif e s1 s2_opt ->
          Boot.assert_false "WIP 66"
      | CabsSswitch e s ->
          Boot.assert_false "WIP 67"
      | CabsSwhile e s ->
          (* TODO: check *)
          AilSwhile <$> desugar_expression e
                    <*> (E.perform_inside_loop $ desugar_statement s)
      | CabsSdo e s ->
          Boot.assert_false "WIP 69"
      | CabsSfor fc_opt e1_opt e2_opt s ->
          Boot.assert_false "WIP 70"
      | CabsSgoto id ->
          AilSgoto <$> E.resolve_label id
      | CabsScontinue -> do E
          b <- E.is_loop_body; in
            if b then
              E.return AilScontinue
            else
_STD "§6.8.6.2#1" $
              E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.2#1")
          end
      | CabsSbreak -> do E
          b1 <- E.is_switch_body;
          b2 <- E.is_loop_body; in
            if b1 || b2 then
              E.return AilSbreak
            else
_STD "§6.8.6.3#1" $
              E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.3#1")
          end
      | CabsSreturn Nothing -> do E
          ty <- E.get_current_return_type; in
            match ty with
              | ATypes.Void ->
                   E.return AilSreturnVoid
              | _ ->
_STD "§6.8.6.4#1, sentence 2" $
                  E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.4#1, 2nd sentence")
            end
          end
         
      | CabsSreturn (Just e) -> do E
          ty <- E.get_current_return_type; in
            match ty with
              | ATypes.Void ->
_STD "§6.8.6.4#1, sentence 1" $
                  E.fail (Errors.Desugar_ConstraintViolation "§6.8.6.4#1, 1st sentence")
              | _ ->
                  AilSreturn <$> desugar_expression e
            end
          end
    end

and desugar_for_clause fc =
  match fc with
   | FC_expr e ->
       Boot.assert_false "WIP 71"
   | FC_decl decl ->
       Boot.assert_false "WIP 72"
  end





val     register_labels: cabs_statement -> E.t unit
let rec register_labels stmt =
  match stmt with
    | CabsSlabel ident s ->
        E.register_label ident
    | CabsScase _ s ->
        register_labels s
    | CabsSdefault s ->
        register_labels s
    | CabsSblock ss ->
        E.mapM_ register_labels ss
    | CabsSdecl _ ->
        E.return ()
    | CabsSnull ->
        E.return ()
    | CabsSexpr _ ->
        E.return ()
    | CabsSif _ s1 s2_opt ->
        register_labels s1 >>
        maybe (E.return ()) register_labels s2_opt
    | CabsSswitch _ s ->
        register_labels s
    | CabsSwhile _ s ->
        register_labels s
    | CabsSdo _ s ->
        register_labels s
    | CabsSfor _ _ _ s ->
        register_labels s
    | CabsSgoto _ ->
        E.return ()
    | CabsScontinue ->
        E.return ()
    | CabsSbreak ->
        E.return ()
    | CabsSreturn _ ->
        E.return ()
  end






(* TODO: check + annotate with STD *)
val desugar_function_definition: function_definition -> E.t (sigma_declaration Location.t unit)
let desugar_function_definition (FunDef specifs (Declarator ptr_decltor_opt ddecltor) s) =
  if List.any (fun sc -> SC_extern <> sc && SC_static <> sc) specifs.storage_classes then
    E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#4")
  else
    match ddecltor with
      | DDecl_function ddecltor param_tys ->
          maybe (E.return id) desugar_pointer_declarator ptr_decltor_opt >>= fun mk_ptr_type        ->
          desugar_type_specifiers specifs.type_specifiers                >>= fun ty                 ->
          desugar_direct_declarator ddecltor                             >>= fun (fun_ident, mk_ty) ->
          desugar_parameter_type_list param_tys                          >>= fun (params, is_variadic)  ->
          
          (* TODO: this is probably wrong *)
          let return_ty = mk_ptr_type ty in
          
          E.register_identifier fun_ident
            E.Namespace_ordinary E.Kind_function specifs.storage_classes >>= fun fun_sym ->
          
          E.with_scope E.Scope_function (
            register_labels s >>
            E.with_scope E.Scope_block (
              match params with
                | [(x_opt, (qs, ATypes.Void))] ->
                    if isJust x_opt then
                      E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#5, sentence 1, sub-sentence 4")
                    else if qs <> ATypes.no_qualifiers then
                      E.fail (Errors.Desugar_ConstraintViolation "TODO: find where the Std forbids this")
                    else
                      E.return []
                | _ ->
                    E.mapM (fun (x_opt, (qs, ty)) ->
                      if ty = ATypes.Void then
                        E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#5, void not alone")
                      else match x_opt with
                        | Nothing ->
                            E.fail (Errors.Desugar_ConstraintViolation "§6.9.1#5, sentence 1, sub-sentence 2")
                        | Just (ident, storage_classes) ->
                            E.register_identifier ident E.Namespace_ordinary (E.Kind_object true qs ty) storage_classes >>= fun sym ->
                            E.return (sym, (qs, ty))
                      end
                    ) params
              end >>= fun bindings ->
              E.set_current_return_type return_ty >>
              desugar_statement s                 >>= fun d_s ->
              E.return $
                SDecl_fun fun_sym <|
                  fun_return_ty=   return_ty;
                  fun_bindings=    bindings;
                  fun_is_variadic= is_variadic;
                  fun_is_inline=   List.elem FS_inline   specifs.function_specifiers;
                  fun_is_Noreturn= List.elem FS_Noreturn specifs.function_specifiers;
                  fun_body=        Just d_s;
                |>
            ) >>= fun (_, ret) ->
            E.return ret
          ) >>= fun (_, ret) ->
          E.return ret
    | _ ->
        Boot.assert_false "desugar_function_definition: impossible case"
  end


val desugar_and_register_external_declaration: external_declaration -> E.t unit
let desugar_and_register_external_declaration edecl =
  let storage_classes =
    maybe [] (fun z -> z.storage_classes) (specifiers_of_external_declaration edecl) in
  
  if List.elem SC_auto storage_classes || List.elem SC_register storage_classes then
    E.fail (Errors.Desugar_ConstraintViolation "§6.9#2")
  else
    match edecl with
      | EDecl_func fdef ->
          desugar_function_definition fdef >>= E.register_declaration
      | EDecl_decl decl ->
          desugar_declaration decl >>= E.mapM_ E.register_declaration
    end


val desugar: cabs_identifier -> translation_unit -> Exception.t (UniqueId.supply Symbol.t * program Location.t unit) Errors.t
let desugar startup_ident (TUnit edecls) =
  E.eval (
    E.with_scope E.Scope_file (
      E.mapM_ desugar_and_register_external_declaration edecls >>
      E.resolve_identifier startup_ident E.Namespace_ordinary  >>= function
        | Just (_, (sym, _, _)) ->
            E.resolve_declarations >>= fun decls ->
            E.return (sym, decls)
        | Nothing ->
            E.fail (Errors.Desugar_NoStartup startup_ident)
      end
    ) >>= fun (_, ret) ->
    E.return ret
  )
