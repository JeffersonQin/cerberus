open import Pervasives Global Core
import Boot Product Symbolic New_memory

module Memory = New_memory


val initial_stack: forall 'a. stack 'a
let initial_stack = []








val sizeof: expr zero -> expr zero
let sizeof e = Ecall (Impl Implementation_.Sizeof) [e]

val alignof: expr zero -> expr zero
let alignof e = Ecall (Impl Implementation_.Alignof) [e]

val ctype_min: expr zero -> expr zero
let ctype_min e = Ecall (Impl Implementation_.Ctype_min) [e]

val ctype_max: expr zero -> expr zero
let ctype_max e = Ecall (Impl Implementation_.Ctype_max) [e]

val bitwise_complement: expr zero -> expr zero
let bitwise_complement e = Ecall (Impl Implementation_.Bitwise_complement) [e]

val integer_encode: expr zero -> expr zero -> expr zero
let integer_encode e1 e2 =
  Ecall (Impl Implementation_.Integer__encode) [e1; e2]

val integer_decode: expr zero -> expr zero -> expr zero
let integer_decode e1 e2 =
  Ecall (Impl Implementation_.Integer__decode) [e1; e2]




(* Some aliases for positive actions *)
let pcreate al ty pref = Eaction (Paction Pos (Action {} (Create al ty pref )))
let palloc al e pref   = Eaction (Paction Pos (Action {} (Alloc al e pref   )))
let pkill x            = Eaction (Paction Pos (Action {} (Kill x         )))
let pstore ty x n mo   = Eaction (Paction Pos (Action {} (Store ty x n mo)))
let pload ty x mo      = Eaction (Paction Pos (Action {} (Load ty x mo   )))


(* NOTE: without the type annotations, the generated ocaml doesn't typecheck *)
let zero : expr zero = Econst (Memory.MV_integer (Symbolic.constant 0))
let one  : expr zero = Econst (Memory.MV_integer (Symbolic.constant 1))
declare {coq} rename function zero = zero_ (* workaround for Lem issue #87 *)

val integer_const: integer -> expr zero
let integer_const n =
  Econst (Memory.MV_integer (Symbolic.constant n))

val cfunction_const: Symbol.t -> expr zero
let cfunction_const fsym =
  Econst (Memory.MV_pointer (Memory.Pointer_function fsym))

val array_const: list Memory.mem_value -> expr zero
let array_const vs =
  Econst (Memory.MV_array vs)



(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core_ctype.ctype
let rec proj_ctype ty =
  Boot.assert_false "WIP: proj_ctype (need to the alignment stuff, this is now going to be Translation.lem effectfull)"
(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | AilTypes.Void             -> Core_ctype.Void
    | AilTypes.Basic bt         -> Core_ctype.Basic bt
    | AilTypes.Array ty n       -> Core_ctype.Array (proj_ctype ty) n
    | AilTypes.Function ty ps b -> Core_ctype.Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | AilTypes.Pointer _ ty    -> Core_ctype.Pointer (proj_ctype ty)
    | AilTypes.Atomic ty        -> Core_ctype.Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> Boot.assert_false "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  Boot.assert_false "WIP: unproj_ctype"

(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Core_ctype.Void              -> AilTypes.Void
    | Core_ctype.Basic bt          -> AilTypes.Basic bt
    | Core_ctype.Array ty n        -> AilTypes.Array (unproj_ctype ty) n
    | Core_ctype.Function ty tys b -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys) b
    | Core_ctype.Pointer ty        -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
    | Core_ctype.Atomic ty         -> AilTypes.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)

val mk_ctype: forall 'a. AilTypes.ctype -> expr 'a
let mk_ctype ty = Ectype (proj_ctype ty)

let rec mk_wseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Ewseq a_opts e (mk_wseq es')
end

let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end



let rec concat_sseq e e' =
   match e with
     | Esseq _as e1 e2 -> Esseq _as e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq [] e e'
  end

let is_negative = function
  | Eaction (Paction Neg _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Paction Neg _) -> true
  | _ -> false
end


(*
let rec free_syms e =
  match e with
  | Etuple es ->
      foldl (fun acc e -> free_syms e union acc) {} es
  | Eunit ->
      {}
  | Enull ->
      {}
  | Eskip ->
      {}
  | Econst _ ->
      {}
  | Eaddr _ ->
      {}
  | Esym a ->
      {a}
  | Eimpl _ ->
      {}
  | Eop _ e1 e2 ->
      free_syms e1 union free_syms e2
  | Etrue ->
      {}
  | Efalse ->
      {}
  | Enot e ->
      free_syms e
  | Ectype _ ->
      {}
  | Elet a e1 e2 ->
      free_syms e1 union (free_syms e2 \ {a})
  | Eif e1 e2 e3 ->
      free_syms e1 union free_syms e2 union free_syms e3
  | Eproc _ _ es ->
      foldl (fun acc e -> free_syms e union acc) {} es
  | Ecall _ es ->
      foldl (fun acc e -> free_syms e union acc) {} es
  | Eoutput _ ->
      {}
  | Esame e1 e2 ->
      free_syms e1 union free_syms e2
  | Eundef _ ->
      {}
  | Eerror ->
      {}
  | Eaction (Paction _ act) ->
      free_syms_action act
  | Eunseq es ->
      foldl (fun acc e -> free_syms e union acc) {} es
  | Ewseq _as e1 e2 ->
      free_syms e1 union (free_syms e2 \ (set_from_options _as))
  | Esseq _as e1 e2 ->
      free_syms e1 union (free_syms e2 \ (set_from_options _as))
  | Easeq a_opt act1 (Paction _ act2) ->
      free_syms_action act1 union (free_syms_action act2 \ (match a_opt with Just a -> {a} | Nothing -> {} end))
  | Esave _ _ e ->
      free_syms e
  | Erun _ _ _ ->
      {}
  | Eret e ->
      free_syms e
  | Epar es ->
      foldl (fun acc e -> free_syms e union acc) {} es
  | End es ->
      foldl (fun acc e -> free_syms e union acc) {} es
  | Eindet e ->
      free_syms e
  | Ebound _ e ->
      free_syms e

(* TODO: temporary *)
  | Eis_scalar e ->
      free_syms e
  | Eis_integer e ->
      free_syms e
  | Eis_signed e ->
      free_syms e
  | Eis_unsigned e ->
      free_syms e
end

and free_syms_action a =
  match a with (Action _ act_) ->
    match act_ with
      | Create ty _ ->
          free_syms ty
      | Alloc n _ ->
          free_syms n
      | Kill o ->
          free_syms o
      | Store ty o n _ ->
          free_syms ty union free_syms o union free_syms n
      | Load ty o _ ->
          free_syms ty union free_syms o
      | CompareExchangeStrong e1 e2 e3 e4 _ _ ->
          free_syms e1 union free_syms e2 union free_syms e3 union free_syms e4
      | CompareExchangeWeak e1 e2 e3 e4 _ _ ->
          free_syms e1 union free_syms e2 union free_syms e3 union free_syms e4
  end
end
*)


(* check if a symbolic names is part of a pattern *)
val in_pattern: sym -> list (maybe sym) -> bool
let rec in_pattern a p =
  match p with
    | []             -> false
    | Nothing  :: xs -> in_pattern a xs
    | Just a'  :: xs -> if a = a' then true else in_pattern a xs
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym: forall 'a. sym -> expr 'a -> expr 'a -> expr 'a
let rec subst_sym a v e =
  match e with
    | Eunit ->
        Eunit
    | Etrue ->
        Etrue
    | Efalse ->
        Efalse
    | Econst n ->
        Econst n
    | Elist es ->
        Elist $ List.map (subst_sym a v) es
    | Ectype ty ->
        Ectype ty
    | Esym a' ->
        if a = a' then v else e
    | Eimpl i ->
        Eimpl i
    | Etuple es ->
        Etuple $ List.map (subst_sym a v) es
    | Enot e ->
        Enot (subst_sym a v e)
    | Eop binop e1 e2 ->
        Eop binop (subst_sym a v e1) (subst_sym a v e2)
    | Ecall f args ->
        Ecall f (List.map (subst_sym a v) args)
    | Eoutput str ->
        Eoutput str
    | Eundef u ->
        Eundef u
    | Eerror ->
        Eerror
    | Eskip ->
        Eskip
    | Elet _a e1 e2 ->
        Elet _a (subst_sym a v e1) (if a = _a then e2 else subst_sym a v e2)
    | Eif e1 e2 e3 ->
        Eif (subst_sym a v e1) (subst_sym a v e2) (subst_sym a v e3)
    | Eproc bs f args ->
        Eproc bs f (List.map (subst_sym a v) args)
    | Eaction p ->
        Eaction (subst_sym_paction a v p)
    | Eunseq es ->
        Eunseq (List.map (subst_sym a v) es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Esseq _as e1 e2 ->
        Esseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Easeq _a act p  ->
        Easeq _a (subst_sym_action a v act) (if Just a = _a then p else subst_sym_paction a v p)
    | Eindet (* i *) _ -> (* Eindet (* i *) (subst_sym a v e) *)
        Boot.assert_false "[Core_aux.subst_sym] #Eindet"
    | Ebound _ _ -> (* Ebound i (subst_sym a v e) *)
        Boot.assert_false "[Core_aux.subst_sym] #Ebound"
    | Esave k a_tys e ->
        Esave k a_tys (subst_sym a v e)
    | Erun bs k a_vs ->
        Erun bs k (* ((a,v) :: a_vs) *) $ list_update a v a_vs
    | Eret e ->
        Eret (subst_sym a v e)
    | End es ->
        End $ List.map (subst_sym a v) es
    | Epar es ->
        Epar $ List.map (subst_sym a v) es

(* TODO: temporary *)
  | Eis_scalar e ->
      Eis_scalar (subst_sym a v e)
  | Eis_integer e ->
      Eis_integer (subst_sym a v e)
  | Eis_signed e ->
      Eis_signed (subst_sym a v e)
  | Eis_unsigned e ->
      Eis_unsigned (subst_sym a v e)
  end

and subst_sym_action_ a v act =
  match act with
    | Create al e_ty pref   -> Create (subst_sym a v al) (subst_sym a v e_ty) pref
    | Alloc al e_n pref     -> Alloc (subst_sym a v al) (subst_sym a v e_n) pref
    | Kill e_o              -> Kill (subst_sym a v e_o)
    | Store e_ty e_o e_v mo -> Store (subst_sym a v e_ty) (subst_sym a v e_o) (subst_sym a v e_v) mo
    | Load e_ty e_o mo      -> Load (subst_sym a v e_ty) (subst_sym a v e_o) mo
    | CompareExchangeStrong e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeStrong (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
    | CompareExchangeWeak e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeWeak (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
  end
and subst_sym_action a v act =
  match act with
    | Action bs act_ -> Action bs (subst_sym_action_ a v act_)
  end
and subst_sym_paction a v pa =
  match pa with
    | Paction p act -> Paction p (subst_sym_action  a v act)
  end



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val subst_syms: forall 'a. list (maybe sym) -> expr 'a -> expr 'a -> expr 'a
let subst_syms _as v e =
  match (_as, v) with
    | ([]       , _        ) -> e
    | ([Nothing], _        ) -> e
    | ([Just _a], _        ) -> subst_sym _a v e

    | (_        , Etuple vs) -> Global.foldl2 (fun acc _a_opt v -> match _a_opt with Just _a -> subst_sym _a v acc | Nothing -> acc end) e _as vs

(*
    | (_        , Eunseq vs) -> List.fold_left2 (fun acc _a_opt v -> match _a_opt with Just _a -> subst_sym _a v acc | Nothing -> acc end) e _as vs
*)
    | _ -> Boot.assert_false "[Core_aux.subst_syms] impossible case"
  end 

(* Asuming well typed expressions *)
let rec is_pure e =
  match e with
   | Eunit ->
       true
   | Etrue ->
       true
   | Efalse ->
       true
   | Econst _ ->
       true
   | Elist _ ->
       true
   | Ectype _ ->
       true
   | Esym _ ->
       true
   | Eimpl _ ->
       true
   | Etuple _ ->
       true
   | Enot _ ->
       true
   | Eop _ _ _ ->
       true
   | Ecall _ _ ->
       true
   | Eoutput _ ->
       false
   | Eundef _ ->
       true
   | Eerror ->
       true
   | Eskip ->
       false
   | Elet _ _ e2 ->
       is_pure e2
   | Eif _ e2 e3 ->
       is_pure e2 && is_pure e3
   | Eproc _ _ _ ->
       false
   | Eaction _ ->
       false
   | Eunseq es ->
       false
(* TODO: making a change from Core_run to Core_run2
       all is_pure es
*)
   | Epar _ ->
       false (* all is_pure es *)
   | Ewseq _ _ _ ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Esseq _ _ _ ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Easeq _ _ _ ->
       false
   | Eindet _ ->
       false
   | Ebound _ _ ->
       false
   | Esave _ _ _ ->
       false
   | Erun _ _ _ ->
       false
   | Eret _ ->
       false
   | End _ ->
       false

(* TODO: temporary *)
  | Eis_scalar _ ->
      true
  | Eis_integer _ ->
      true
  | Eis_signed _ ->
      true
  | Eis_unsigned _ ->
      true
end


let rec is_value e =
  match e with
    | Eunit ->
        true
    | Etrue ->
        true
    | Efalse ->
        true
    | Econst _ ->
        true
    | Elist pes ->
        all is_value pes
    | Ectype _ ->
        true
    | Esym  _ ->
        false
    | Eimpl _ ->
        false
    | Etuple pes ->
        all is_value pes
    | Enot _ ->
        false
    | Eop _ _ _ ->
        false
    | Ecall _ _ ->
        false
    | Eoutput _ ->
        false
    | Eundef _ ->
        false
    | Eerror ->
        false
    | Eskip ->
        false
    | Elet _ _ _ ->
        false
    | Eif _ _ _->
        false
    | Eproc _ _ _ ->
        false
    | Eaction _ ->
        false
    | Eunseq _ ->
        false
    | Ewseq _ _ _ ->
        false
    | Esseq _ _ _ ->
        false
    | Easeq _ _ _ ->
        false
    | Eindet _ ->
        false
    | Ebound _ _ ->
        false
    | Esave _ _ _->
        false
    | Erun _ _ _->
        false
    | Eret _ ->
        false
    | End _ ->
        false
    | Epar _ ->
        false
    | Eis_scalar _ ->
        false
    | Eis_integer _ ->
        false
    | Eis_signed _ ->
        false
    | Eis_unsigned _ ->
        false
end


let rec get_labeled_continuation k expr =
  match expr with
    | Eunit ->
        Nothing
    | Etrue ->
        Nothing
    | Efalse ->
        Nothing
    | Econst _ ->
        Nothing
    | Elist _ ->
        Nothing
    | Ectype _ ->
        Nothing
    | Esym _ ->
        Nothing
    | Eimpl _ ->
        Nothing
    | Etuple _ ->
        Nothing
    | Enot _ ->
        Nothing
    | Eop _ _ _ ->
        Nothing
    | Ecall _ _ ->
        Nothing
    | Eoutput _ ->
        Nothing
    | Eundef _ ->
        Nothing
    | Eerror ->
        Nothing
    | Eskip ->
        Nothing
    | Elet _ _ e2 ->
        get_labeled_continuation k e2
    | Eif _ e2 e3 ->
        match get_labeled_continuation k e2 with
          | Just cont ->
              Just cont
          | Nothing ->
              get_labeled_continuation k e3
        end
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq _ ->
        Nothing
    | Ewseq _ _ e2 ->
        get_labeled_continuation k e2
    | Esseq _ _ e2 ->
        get_labeled_continuation k e2
    | Easeq _ _ _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Eindet _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Ebound _ _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Esave k' a_tys e ->
        if k = k' then
          Just (a_tys, e)
        else
          get_labeled_continuation k e
    | Erun _ _ _ ->
        Nothing
    | Eret _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Boot.assert_false "TODO: think about this Ctor"
    | Eis_scalar _ ->
        Nothing
    | Eis_integer _ ->
        Nothing
    | Eis_signed _ ->
        Nothing
    | Eis_unsigned _ ->
        Nothing
  end




(*
type _continuation 'a =
  | Kunseq of list (expr 'a) * list (expr 'a)
  | Kpar   of list (expr 'a) * list (expr 'a)
  | Kwseq  of list (maybe sym) * expr 'a
  | Ksseq  of list (maybe sym) * expr 'a

type continuation 'a = list (_continuation 'a)


type labeled_continuation 'a = list (sym * ctype) * expr 'a


type stack 'a = list (continuation 'a)
*)

val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont expr =
    match _cont with
      | Kwseq _as e2 ->
          Ewseq _as expr e2
      | Ksseq _as e2 ->
          Esseq _as expr e2
      | Kpar es1 es2 ->
          Epar $ es1 ++ (expr :: es2)
      | Kunseq es1 es2 ->
          Eunseq $ es1 ++ (expr :: es2)
    end in
  foldl (fun acc x -> f x acc) expr cont











(* TODO: here I'm annotating all actions instead (this may reduce the number of
         epsilon transitions) *)
(* [annotate b e] add on each sb-minimal action of [e] an annotation meaning
                  that this action is sequenced-after [act]
  
  in the rules comments, this function is noted: <b> e
 *)
val     annotate_expr: forall 'a. SetType 'a => polarity * 'a -> expr 'a -> expr 'a
let rec annotate_expr annot = function
  | Eunit ->
      (* no change *)
      Eunit
  | Etrue ->
      (* no change *)
      Etrue
  | Efalse ->
      (* no change *)
      Efalse
  | Econst cts ->
      (* no change *)
      Econst cts
  | Elist pes ->
      (* no change *)
      Elist pes
  | Ectype ty ->
      (* no change *)
      Ectype ty
  | Esym a ->
      (* no change *)
      Esym a
  | Eimpl i ->
      (* no change *)
      Eimpl i
  | Etuple pes ->
      (* no change *)
      Etuple pes
  | Enot pe ->
      (* no change *)
      Enot pe
  | Eop bop pe1 pe2 ->
      (* no change *)
      Eop bop pe1 pe2
  | Ecall nm pes ->
      (* no change *)
      Ecall nm pes
  | Eoutput str ->
      (* no change *)
      Eoutput str
  | Eundef ub ->
      (* no change *)
      Eundef ub
  | Eerror ->
      (* no change *)
      Eerror
  | Eskip ->
      (* no change *)
      Eskip
  | Elet a pe1 e2 ->
      Elet a pe1 (annotate_expr annot e2)
  | Eif pe1 e2 e3 ->
      Eif pe1 (annotate_expr annot e2) (annotate_expr annot e3)
  | Eproc annots nm pes ->
      Eproc ({snd annot} union annots) nm pes
  | Eaction (Paction p (Action bs a)) ->
      Eaction (Paction p (Action ({snd annot} union bs) a))
  | Eunseq es ->
      Eunseq (List.map (annotate_expr annot) es)
  | Ewseq _as e1 e2 ->
      Ewseq _as (annotate_expr annot e1) (match fst annot with
                                            | Pos -> annotate_expr annot e2
                                            | Neg -> e2
                                          end)
  | Esseq _as e1 e2 ->
      Esseq _as (annotate_expr annot e1) (annotate_expr annot e2)
(*
  | Easeq  of maybe sym * action 'a * paction 'a (* this ctor doesn't exist at runtine *)
  | Eindet of expr 'a (* TODO: add unique indices *) (* this ctor doesn't exist at runtine *)
  | Ebound of natural * expr 'a (* this ctor doesn't exist at runtine *)
*)
  | Esave k a_tys e ->
      Esave k a_tys (annotate_expr annot e)
  | Erun annots k a_vs ->
      Erun ({snd annot} union annots) k a_vs
  | Eret pe ->
      (* no change *)
      Eret pe
  | End es ->
      End (List.map (annotate_expr annot) es)
  | Epar es ->
      Epar (List.map (annotate_expr annot) es)
  | Eis_scalar pe ->
      (* no change *)
      Eis_scalar pe
  | Eis_integer pe ->
      (* no change *)
      Eis_integer pe
  | Eis_signed pe ->
      (* no change *)
      Eis_signed pe
  | Eis_unsigned pe ->
      (* no change *)
      Eis_unsigned pe
end



(* TODO: doesn't do what it should *)
val annotate: forall 'a. SetType 'a => polarity * 'a -> list (continuation 'a) -> list (continuation 'a)

let rec _annotate annot = function
  | [] ->
      []
  | Kpar es1 es2 :: k' ->
      Kpar (List.map (annotate_expr annot) es1) (List.map (annotate_expr annot) es2) :: _annotate annot k'
  | Kunseq es1 es2 :: k' ->
      Kunseq es1 es2 :: _annotate annot k'
  | Kwseq _as e2 :: k' ->
      Kwseq _as (match fst annot with
                   | Pos -> annotate_expr annot e2
                   | Neg -> e2
                 end) :: _annotate annot k'
  | Ksseq _as e2 :: k' ->
      Ksseq _as (annotate_expr annot e2) :: _annotate annot k'
end
let annotate annot ks = List.map (_annotate annot) ks
