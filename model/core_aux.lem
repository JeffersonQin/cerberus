open import Pervasives Global Show Core
import Boot Product Symbolic Exception Naive_memory

open import Thread Core_run_aux

module Mem = Naive_memory


val sizeof: forall 'a. expr 'a -> expr 'a
let sizeof e = Ecall (Impl Implementation_.Sizeof) [e]

val alignof: forall 'a. expr 'a -> expr 'a
let alignof e = Ecall (Impl Implementation_.Alignof) [e]

val ctype_min: forall 'a. expr 'a -> expr 'a
let ctype_min e = Ecall (Impl Implementation_.Ctype_min) [e]

val ctype_max: forall 'a. expr 'a -> expr 'a
let ctype_max e = Ecall (Impl Implementation_.Ctype_max) [e]

val bitwise_complement: forall 'a. expr 'a -> expr 'a -> expr 'a
let bitwise_complement e1 e2 = Ecall (Impl Implementation_.Bitwise_complement) [e1; e2]

val integer_encode: forall 'a. expr 'a -> expr 'a -> expr 'a
let integer_encode e1 e2 =
  Ecall (Impl Implementation_.Integer__encode) [e1; e2]

val integer_decode: forall 'a. expr 'a -> expr 'a -> expr 'a
let integer_decode e1 e2 =
  Ecall (Impl Implementation_.Integer__decode) [e1; e2]




(* Some aliases for positive actions *)
let pcreate al ty pref = Eaction (Paction Pos (Action default (Create al ty pref )))
let palloc al e pref   = Eaction (Paction Pos (Action default (Alloc al e pref   )))
let pkill x            = Eaction (Paction Pos (Action default (Kill x         )))
let pstore ty x n mo   = Eaction (Paction Pos (Action default (Store ty x n mo)))
let pload ty x mo      = Eaction (Paction Pos (Action default (Load ty x mo   )))


(* NOTE: without the type annotations, the generated ocaml doesn't typecheck *)
val zero: forall 'a. expr 'a
let zero =
  Econst (Mem.mk_integer 0)
val one: forall 'a. expr 'a
let one =
  Econst (Mem.mk_integer 1)
declare {coq} rename function zero = zero_ (* workaround for Lem issue #87 *)


val cfunction_const: forall 'a. Symbol.t -> expr 'a
let cfunction_const fsym =
  Econst (Mem.mk_pointer (Mem.function_pointer fsym))




(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core_ctype.ctype
let rec proj_ctype ty =
  match ty with
    | AilTypes.Void ->
        Core_ctype.Void
    | AilTypes.Basic bty ->
        Core_ctype.Basic bty
    | AilTypes.Array ty n_opt ->
        Core_ctype.Array (proj_ctype ty) n_opt
    | AilTypes.Function ty qs_tys is_variadic ->
        Core_ctype.Function (proj_ctype ty) (List.map (fun (qs,ty) -> (qs, proj_ctype ty)) qs_tys) is_variadic
    | AilTypes.Pointer qs ty ->
        Core_ctype.Pointer qs (proj_ctype ty)
    | AilTypes.Atomic ty ->
        Core_ctype.Atomic (proj_ctype ty)
    | AilTypes.Builtin str ->
        Core_ctype.Builtin str
(* TOO
 | AilTypes.Struct of list (identifier * ctype) (* TODO: no bitfields for now *)
 | AilTypes.Union of list (identifier * ctype) (* TODO: no bitfields for now *)
 | AilTypes.Builtin of string
*)
  end




(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | AilTypes.Void             -> Core_ctype.Void
    | AilTypes.Basic bt         -> Core_ctype.Basic bt
    | AilTypes.Array ty n       -> Core_ctype.Array (proj_ctype ty) n
    | AilTypes.Function ty ps b -> Core_ctype.Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | AilTypes.Pointer _ ty    -> Core_ctype.Pointer (proj_ctype ty)
    | AilTypes.Atomic ty        -> Core_ctype.Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> Boot.assert_false "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  match ty with
    | Core_ctype.Void ->
        AilTypes.Void
    | Core_ctype.Basic bty ->
        AilTypes.Basic bty
    | Core_ctype.Array ty n_opt ->
        AilTypes.Array (unproj_ctype ty) n_opt
    | Core_ctype.Function ty qs_tys is_variadic ->
        AilTypes.Function (unproj_ctype ty) (List.map (fun (qs,ty) -> (qs, unproj_ctype ty)) qs_tys) is_variadic
    | Core_ctype.Pointer qs ty ->
        AilTypes.Pointer qs (unproj_ctype ty)
    | Core_ctype.Atomic ty ->
        AilTypes.Atomic (unproj_ctype ty)
    | Core_ctype.Builtin str ->
        AilTypes.Builtin str
(*
    | Struct of struct_tag * list (member_id * modifiable * ctype)
    | Union  of union_tag * list (member_id * modifiable * ctype)
*)
  end


(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Core_ctype.Void              -> AilTypes.Void
    | Core_ctype.Basic bt          -> AilTypes.Basic bt
    | Core_ctype.Array ty n        -> AilTypes.Array (unproj_ctype ty) n
    | Core_ctype.Function ty tys b -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys) b
    | Core_ctype.Pointer ty        -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
    | Core_ctype.Atomic ty         -> AilTypes.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)

val mk_ctype: forall 'a. AilTypes.ctype -> expr 'a
let mk_ctype ty = Ectype (proj_ctype ty)

let rec mk_wseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Ewseq a_opts e (mk_wseq es')
end

let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end



let rec concat_sseq e e' =
   match e with
     | Esseq _as e1 e2 -> Esseq _as e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq [] e e'
  end

let is_negative = function
  | Eaction (Paction Neg _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Paction Neg _) -> true
  | _ -> false
end


(* check if a symbolic names is part of a pattern *)
val in_pattern: sym -> list (maybe sym) -> bool
let rec in_pattern a p =
  match p with
    | []             -> false
    | Nothing  :: xs -> in_pattern a xs
    | Just a'  :: xs -> if a = a' then true else in_pattern a xs
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym: forall 'a. sym -> expr 'a -> expr 'a -> expr 'a
let rec subst_sym a v expr =
  match expr with
    | Eunit ->
        Eunit
    | Etrue ->
        Etrue
    | Efalse ->
        Efalse
    | Econst n ->
        Econst n
    | Elist es ->
        Elist $ List.map (subst_sym a v) es
    | Ectype ty ->
        Ectype ty
    | Esym a' ->
        if a = a' then v else expr
    | Eimpl i ->
        Eimpl i
    | Etuple es ->
        Etuple $ List.map (subst_sym a v) es
    | Enot e ->
        Enot (subst_sym a v e)
    | Eop binop e1 e2 ->
        Eop binop (subst_sym a v e1) (subst_sym a v e2)
    | Ecall f args ->
        Ecall f (List.map (subst_sym a v) args)
    | Eoutput str ->
        Eoutput str
    | Eundef u ->
        Eundef u
    | Eerror str ->
        Eerror str
    | Eraise str ->
        Eraise str
(*
    | Etry e str_es ->
        Etry e str_es
*)
    | Eregister str nm ->
        Eregister str nm
    | Eskip ->
        Eskip
    | Elet _a e1 e2 ->
        Elet _a (subst_sym a v e1) (if a = _a then e2 else subst_sym a v e2)
    | Eif e1 e2 e3 ->
        Eif (subst_sym a v e1) (subst_sym a v e2) (subst_sym a v e3)
    | Eproc bs f args ->
        Eproc bs f (List.map (subst_sym a v) args)
    | Eaction p ->
        Eaction (subst_sym_paction a v p)
    | Eunseq es ->
        Eunseq (List.map (subst_sym a v) es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Esseq _as e1 e2 ->
        Esseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Easeq _a act p  ->
        Easeq _a (subst_sym_action a v act) (if Just a = _a then p else subst_sym_paction a v p)
    | Eindet e ->
        Eindet (subst_sym a v e)
    | Ebound i e ->
        Ebound i (subst_sym a v e)
    | Esave k a_tys e ->
        Esave k a_tys (subst_sym a v e)
    | Erun bs k a_vs ->
        Erun bs k (* ((a,v) :: a_vs) *) $ list_update a v a_vs
    | Eret e ->
        Eret (subst_sym a v e)
    | End es ->
        End $ List.map (subst_sym a v) es
    | Epar es ->
        Epar $ List.map (subst_sym a v) es
    | Ewait tids ->
        Ewait tids

  | Eis_scalar e ->
      Eis_scalar (subst_sym a v e)
  | Eis_integer e ->
      Eis_integer (subst_sym a v e)
  | Eis_signed e ->
      Eis_signed (subst_sym a v e)
  | Eis_unsigned e ->
      Eis_unsigned (subst_sym a v e)
  end

and subst_sym_action_ a v act =
  match act with
    | Create al e_ty pref   -> Create (subst_sym a v al) (subst_sym a v e_ty) pref
    | Alloc al e_n pref     -> Alloc (subst_sym a v al) (subst_sym a v e_n) pref
    | Kill e_o              -> Kill (subst_sym a v e_o)
    | Store e_ty e_o e_v mo -> Store (subst_sym a v e_ty) (subst_sym a v e_o) (subst_sym a v e_v) mo
    | Load e_ty e_o mo      -> Load (subst_sym a v e_ty) (subst_sym a v e_o) mo
    | CompareExchangeStrong e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeStrong (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
    | CompareExchangeWeak e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeWeak (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
  | Ptr ptr_act pes ->
      Ptr ptr_act (List.map (subst_sym a v) pes)
  end
and subst_sym_action a v act =
  match act with
    | Action bs act_ -> Action bs (subst_sym_action_ a v act_)
  end
and subst_sym_paction a v pa =
  match pa with
    | Paction p act -> Paction p (subst_sym_action  a v act)
  end



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val subst_syms: forall 'a. list (maybe sym) -> expr 'a -> expr 'a -> expr 'a
let subst_syms _as v e =
  match (_as, v) with
    | ([]       , _        ) -> e
    | ([Nothing], _        ) -> e
    | ([Just _a], _        ) -> subst_sym _a v e

    | (_        , Etuple vs) -> Global.foldl2 (fun acc _a_opt v -> match _a_opt with Just _a -> subst_sym _a v acc | Nothing -> acc end) e _as vs


    | _ -> Boot.assert_false "[Core_aux.subst_syms] impossible case"
  end 





val subst_wait: forall 'a. thread_id -> expr 'a -> expr 'a -> expr 'a
let rec subst_wait tid v = function
   | Eunit ->
       Eunit
   | Etrue ->
       Etrue
   | Efalse ->
       Efalse
   | Econst cst ->
       Econst cst
   | Elist pes ->
       Elist pes
   | Ectype ty ->
       Ectype ty
   | Esym sym ->
       Esym sym
   | Eimpl i ->
       Eimpl i
   | Etuple pes ->
       Etuple pes
   | Enot pe ->
       Enot pe
   | Eop bop pe1 pe2 ->
       Eop bop pe1 pe2
   | Ecall nm pes ->
       Ecall nm pes
   | Eoutput str ->
       Eoutput str
   | Eundef ub ->
       Eundef ub
   | Eerror str ->
       Eerror str
   | Eraise str ->
       Eraise str
(*
   | Etry e str_es ->
       Etry e str_es
*)
   | Eregister evnt nm ->
       Eregister evnt nm
   | Eskip ->
       Eskip
   | Elet sym pe1 e2 ->
       Elet sym pe1 (subst_wait tid v e2)
   | Eif pe1 e2 e3 ->
       Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
   | Eproc annots nm pes ->
       Eproc annots nm pes
   | Eaction pact ->
       Eaction pact
   | Eunseq es ->
       Eunseq (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         v
       else
         Ewait tid'
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Easeq sym_opt act1 pact2 ->
       Easeq sym_opt act1 pact2
   | Eindet e ->
       Eindet (subst_wait tid v e)
   | Ebound j e ->
       Ebound j (subst_wait tid v e)
   | Esave k a_tys e ->
       Esave k a_tys (subst_wait tid v e)
   | Erun annots k a_vs ->
       Erun annots k a_vs
   | Eret pe ->
       Eret pe
   | End es ->
       End (List.map (subst_wait tid v) es)
  | Eis_scalar pe ->
      Eis_scalar pe
  | Eis_integer pe ->
      Eis_integer pe
  | Eis_signed pe ->
      Eis_signed pe
  | Eis_unsigned pe ->
      Eis_unsigned pe
end


let subst_wait_continuation_element tid v = function
  | Kunseq es1 es2 ->
      Kunseq (List.map (subst_wait tid v) es1) (List.map (subst_wait tid v) es2)
  | Kwseq syms_opt e2 ->
      Kwseq syms_opt (subst_wait tid v e2)
  | Ksseq syms_opt e2 ->
      Ksseq syms_opt (subst_wait tid v e2)

(*
  | Ktry str_es ->
      Ktry (List.map (fun (str, e) -> (str, subst_wait tid v e)) str_es)
*)
end

let subst_wait_continuation tid v cont =
  List.map (subst_wait_continuation_element tid v) cont

let rec subst_wait_stack tid v = function
  | Stack_empty ->
      Stack_empty
  | Stack_cons cont sk ->
      Stack_cons (subst_wait_continuation tid v cont) (subst_wait_stack tid v sk)
end


(* Asuming well typed expressions *)
let rec is_pure e =
  match e with
   | Eunit ->
       true
   | Etrue ->
       true
   | Efalse ->
       true
   | Econst _ ->
       true
   | Elist _ ->
       true
   | Ectype _ ->
       true
   | Esym _ ->
       true
   | Eimpl _ ->
       true
   | Etuple _ ->
       true
   | Enot _ ->
       true
   | Eop _ _ _ ->
       true
   | Ecall _ _ ->
       true
   | Eoutput _ ->
       false
   | Eundef _ ->
       true
   | Eerror _ ->
       true
   | Eraise _ ->
       false
(*
   | Etry _ _ ->
       false
*)
   | Eregister _ _ ->
       false
   | Eskip ->
       false
   | Elet _ _ e2 ->
       is_pure e2
   | Eif _ e2 e3 ->
       is_pure e2 && is_pure e3
   | Eproc _ _ _ ->
       false
   | Eaction _ ->
       false
   | Eunseq _ ->
       false

   | Epar _ ->
       false (* all is_pure es *)
   | Ewait _ ->
       false
   | Ewseq _ _ _ ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Esseq _ _ _ ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Easeq _ _ _ ->
       false
   | Eindet _ ->
       false
   | Ebound _ _ ->
       false
   | Esave _ _ _ ->
       false
   | Erun _ _ _ ->
       false
   | Eret _ ->
       false
   | End _ ->
       false

  | Eis_scalar _ ->
      true
  | Eis_integer _ ->
      true
  | Eis_signed _ ->
      true
  | Eis_unsigned _ ->
      true
end


let rec is_value e =
  match e with
    | Eunit ->
        true
    | Etrue ->
        true
    | Efalse ->
        true
    | Econst _ ->
        true
    | Elist pes ->
        all is_value pes
    | Ectype _ ->
        true
    | Esym  _ ->
        false
    | Eimpl _ ->
        false
    | Etuple pes ->
        all is_value pes
    | Enot _ ->
        false
    | Eop _ _ _ ->
        false
    | Ecall _ _ ->
        false
    | Eoutput _ ->
        false
    | Eundef _ ->
        false
    | Eerror _ ->
        false
    | Eraise str ->
        false
(*
    | Etry e str_es ->
        false
*)
    | Eregister _ _ ->
        false
    | Eskip ->
        false
    | Elet _ _ _ ->
        false
    | Eif _ _ _->
        false
    | Eproc _ _ _ ->
        false
    | Eaction _ ->
        false
    | Eunseq _ ->
        false
    | Ewseq _ _ _ ->
        false
    | Esseq _ _ _ ->
        false
    | Easeq _ _ _ ->
        false
    | Eindet _ ->
        false
    | Ebound _ _ ->
        false
    | Esave _ _ _->
        false
    | Erun _ _ _->
        false
    | Eret _ ->
        false
    | End _ ->
        false
    | Epar _ ->
        false
    | Ewait _ ->
        false
    | Eis_scalar _ ->
        false
    | Eis_integer _ ->
        false
    | Eis_signed _ ->
        false
    | Eis_unsigned _ ->
        false
end


let rec find_labeled_continuation k expr =
  match expr with
    | Eunit ->
        Nothing
    | Etrue ->
        Nothing
    | Efalse ->
        Nothing
    | Econst _ ->
        Nothing
    | Elist _ ->
        Nothing
    | Ectype _ ->
        Nothing
    | Esym _ ->
        Nothing
    | Eimpl _ ->
        Nothing
    | Etuple _ ->
        Nothing
    | Enot _ ->
        Nothing
    | Eop _ _ _ ->
        Nothing
    | Ecall _ _ ->
        Nothing
    | Eoutput _ ->
        Nothing
    | Eundef _ ->
        Nothing
    | Eerror _ ->
        Nothing
    | Eraise _ ->
       Nothing
(*
    | Etry e str_es ->
       Nothing (* TODO *)
*)
    | Eregister _ _ ->
        Nothing
    | Eskip ->
        Nothing
    | Elet _ _ e2 ->
        find_labeled_continuation k e2
    | Eif _ e2 e3 ->
        match find_labeled_continuation k e2 with
          | Just cont ->
              Just cont
          | Nothing ->
              find_labeled_continuation k e3
        end
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq _ ->
        Nothing
    | Ewseq _as e1 e2 ->
        match find_labeled_continuation k e1 with
          | Just (a_tys, cont_e) ->
              Just (a_tys, Ewseq _as cont_e e2)
          | Nothing ->
              find_labeled_continuation k e2
        end
    | Esseq _as e1 e2 ->
        match find_labeled_continuation k e1 with
          | Just (a_tys, cont_e) ->
              Just (a_tys, Esseq _as cont_e e2)
          | Nothing ->
              find_labeled_continuation k e2
        end
    | Easeq _ _ _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Eindet _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Ebound _ _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Esave k' a_tys e ->
        if k = k' then
          Just (a_tys, e)
        else
          find_labeled_continuation k e
    | Erun _ _ _ ->
        Nothing
    | Eret _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Boot.assert_false "TODO: think about this Ctor"
    | Ewait _ ->
        Nothing
    | Eis_scalar _ ->
        Nothing
    | Eis_integer _ ->
        Nothing
    | Eis_signed _ ->
        Nothing
    | Eis_unsigned _ ->
        Nothing
  end





val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont expr =
    match _cont with
      | Kwseq _as e2 ->
          Ewseq _as expr e2
      | Ksseq _as e2 ->
          Esseq _as expr e2
      | Kunseq es1 es2 ->
          Eunseq $ es1 ++ (expr :: es2)
(*
      | Ktry str_es ->
          Etry expr str_es
*)
    end in
  foldl (fun acc x -> f x acc) expr cont


(* Functions on continuation and stacks *)
val empty_stack: forall 'a. stack 'a
let empty_stack =
  Stack_empty

val is_empty_stack: forall 'a. stack 'a -> bool
let is_empty_stack = function
  | Stack_empty ->
      true
  | _ ->
      false
end



val push_empty_continuation: forall 'a. stack 'a -> stack 'a
let push_empty_continuation sk =
  Stack_cons [] sk

val pop_stack: forall 'a. stack 'a -> Exception.t (continuation 'a * stack 'a) core_run_error
let pop_stack = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_stack")
  | Stack_cons cont sk ->
      Exception.return (cont, sk)
end

val pop_continuation_element: forall 'a. stack 'a -> Exception.t (continuation_element 'a * stack 'a) core_run_error
let pop_continuation_element = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_continuation_element")
  | Stack_cons [] _ ->
      Exception.fail Reached_end_of_proc
  | Stack_cons (cont_elem :: cont) sk ->
      Exception.return (cont_elem, Stack_cons cont sk)
end


val push_continuation_element: forall 'a. continuation_element 'a -> stack 'a -> Exception.t (stack 'a) core_run_error
let push_continuation_element cont_elem = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "push_continuation_element")
  | Stack_cons cont sk ->
      Exception.return (Stack_cons (cont_elem :: cont) sk)
end



val append_to_current_continuation: forall 'a. continuation_element 'a -> stack 'a -> Exception.t (stack 'a) core_run_error
let append_to_current_continuation cont = function
  | Stack_empty ->
      (* A procedure need to currently be running to append *)
      Exception.fail (Found_empty_stack "append_to_current_continuation")
  | Stack_cons ccont sk ->
      Exception.return $ Stack_cons (cont :: ccont) sk
end


val subst_sym_fun_map: forall 'a. sym -> expr 'a -> fun_map 'a -> fun_map 'a
let subst_sym_fun_map sym v funs =
  Map.map (fun (cTy, params, e) ->
    (cTy, params, subst_sym sym v e)
  ) funs




val     collect_labeled_continuations: forall 'a. expr 'a -> map ksym (list (sym * Core_ctype.ctype) * expr 'a)
let rec collect_labeled_continuations expr =
  match expr with
    | Eunit ->
        Map.empty
    | Etrue ->
        Map.empty
    | Efalse ->
        Map.empty
    | Econst _ ->
        Map.empty
    | Elist _ ->
        Map.empty
    | Ectype _ ->
        Map.empty
    | Esym _ ->
        Map.empty
    | Eimpl _ ->
        Map.empty
    | Etuple _ ->
        Map.empty
    | Enot _ ->
        Map.empty
    | Eop _ _ _ ->
        Map.empty
    | Ecall _ _ ->
        Map.empty
    | Eoutput _ ->
        Map.empty
    | Eundef _ ->
        Map.empty
    | Eerror _ ->
        Map.empty
    | Eraise _ ->
        Map.empty
    | Eregister _ _ ->
        Map.empty
    | Eskip ->
        Map.empty
    | Elet _ _ e2 ->
        collect_labeled_continuations e2
    | Eif pe1 e2 e3 ->
        Map.(union) (collect_labeled_continuations e2) (collect_labeled_continuations e3)
    | Eproc _ _ _ ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Ewseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Ewseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Esseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Esseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Easeq _ _ _ ->
        Map.empty
    | Eindet _ ->
        Map.empty
    | Ebound _ _ ->
        Map.empty
    | Esave k a_tys e ->
        Map.insert k (a_tys, e) $ collect_labeled_continuations e
    | Erun _ _ _ ->
        Map.empty
    | Eret _ ->
        Map.empty
    | End _ ->
        (* TODO: check *)
        Map.empty
    | Epar _ ->
        (* TODO: check *)
        Map.empty
    | Ewait _ ->
        Map.empty
    | Eis_scalar _->
        Map.empty
    | Eis_integer _->
        Map.empty
    | Eis_signed _->
        Map.empty
    | Eis_unsigned _->
        Map.empty
  end
