open import Pervasives Global Show Core Core_ctype
import AilSyntax AilTypes
import Product Symbolic Exception Mem Mem_aux

open import Cthread Errors

open import{hol} `pp_coreTheory`

import Debug Pp


val strip: forall 'ty 'sym. generic_pexpr 'ty 'sym -> pexpr_ 'ty 'sym
let strip (Pexpr _ pexpr_) =
  pexpr_



val     core_object_type_of_ctype: ctype -> core_object_type
let rec core_object_type_of_ctype ty =
  match ty with
   | Void ->
       error "Caux.object_type_of_ctype Void"
   | Basic (AilTypes.Integer _) ->
       OTy_integer
   | Basic (AilTypes.Floating _) ->
       OTy_floating
   | Array ty _ ->
       OTy_array (core_object_type_of_ctype ty)
   | Function ty xs _ ->
       OTy_cfunction (*ty (List.map snd xs)*)
   | Pointer _ _ ->
       OTy_pointer
   | Atomic ty ->
       core_object_type_of_ctype ty
   | Struct tag_sym ->
       OTy_struct tag_sym
   | Union tag_sym ->
       OTy_union tag_sym
   | Builtin _ ->
       error "TODO: Caux.object_type_of_ctype Builtin"
  end


val     objectValueFromMemValue: Mem.mem_value -> core_object_type * object_value
let rec objectValueFromMemValue mem_val =
  Mem.case_mem_value mem_val
    (fun ty                -> error"[Core_aux.objectValueFromMemValue] FOUND AN UNSPECIFIED MVAL")
    (fun _ ival            -> (OTy_integer, OVinteger ival))
    (fun _ fval            -> (OTy_floating, OVfloating fval))
    (fun _ ptr_val         -> (OTy_pointer, OVpointer ptr_val))
    (fun mem_vals          -> error "[Core_aux.objectValueFromMemValue] Vspecified (OVarray (List.map objectValueFromMemValue mem_vals))")
    (fun sym xs            -> (OTy_struct sym, OVstruct sym xs))
    (fun sym ident mem_val -> (OTy_union sym, OVunion sym ident mem_val))

val     valueFromMemValue: Mem.mem_value -> core_object_type * value
let rec valueFromMemValue mem_val =
  Mem.case_mem_value mem_val
    (fun ty                -> (core_object_type_of_ctype ty, Vunspecified ty))
    (fun _ ival            -> (OTy_integer, Vspecified (OVinteger ival)))
    (fun _ fval            -> (OTy_floating, Vspecified (OVfloating fval)))
    (fun _ ptr_val         -> (OTy_pointer, Vspecified (OVpointer ptr_val)))
    (fun mem_vals          -> error "[Core_aux.objectValueFromMemValue] Vspecified (OVarray (List.map objectValueFromMemValue mem_vals))")
    (fun sym xs            -> (OTy_struct sym, Vspecified (OVstruct sym xs)))
    (fun sym ident mem_val -> (OTy_union sym, Vspecified (OVunion sym ident mem_val)))


val     memValueFromValue: ctype -> value -> maybe Mem.mem_value
let rec memValueFromValue ty cval =
  match (ty, cval) with
    | (_, Vunit) ->
        Nothing
    | (_, Vtrue) ->
        Nothing
    | (_, Vfalse) ->
        Nothing
    | (_, Vlist _ _) ->
        Nothing
    | (_, Vtuple _) ->
        Nothing
    | (_, Vctype _) ->
        Nothing
    | (_, Vunspecified ty') ->
        Just (Mem.unspecified_mval ty') (* TODO: check ty = ty'? *)
    | (Basic (AilTypes.Integer ity), Vspecified (OVinteger ival)) ->
        Just (Mem.integer_value_mval ity ival)
    | (Basic (AilTypes.Floating fty), Vspecified (OVfloating fval)) ->
        Just (Mem.floating_value_mval fty fval)
    | (Pointer _ ref_ty, Vspecified (OVpointer ptr_val)) ->
        Just (Mem.pointer_mval ref_ty ptr_val)
    | (Array elem_ty _, Vspecified (OVarray ovals)) ->
        (* TODO: check that the sizes match? *)
        maybe Nothing (fun z -> Just (Mem.array_mval z)) $
          List.foldr (fun oval acc_opt ->
            match (memValueFromValue elem_ty (Vspecified oval), acc_opt) with
              | (Just mem_val, Just acc) ->
                  Just (mem_val :: acc)
              | _ ->
                  Nothing
            end
          ) (Just []) ovals
    | (Struct tag_sym1, Vspecified (OVstruct tag_sym2 xs)) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.struct_mval tag_sym1 xs)
        else
          Nothing
    | (Union tag_sym1, Vspecified (OVunion tag_sym2 ident mem_val)) ->
        if tag_sym1 = tag_sym2 then
          Just (Mem.union_mval tag_sym1 ident mem_val)
        else
          Nothing
    | _ ->
        Nothing
  end





(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core_ctype.ctype
let rec proj_ctype ty =
  match ty with
    | AilTypes.Void ->
        Core_ctype.Void
    | AilTypes.Basic bty ->
        Core_ctype.Basic bty
    | AilTypes.Array ty n_opt ->
        Core_ctype.Array (proj_ctype ty) n_opt
    | AilTypes.Function _ ty qs_tys is_variadic ->
        Core_ctype.Function (proj_ctype ty) (List.map (fun (qs,ty) -> (qs, proj_ctype ty)) qs_tys) is_variadic
    | AilTypes.Pointer qs ty ->
        Core_ctype.Pointer qs (proj_ctype ty)
    | AilTypes.Atomic ty ->
        Core_ctype.Atomic (proj_ctype ty)
    | AilTypes.Struct tag_sym ->
        Core_ctype.Struct tag_sym
    | AilTypes.Union tag_sym ->
        Core_ctype.Union tag_sym
(*
    | AilTypes.Struct tag_sym ident_tys ->
        Core_ctype.Struct tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
    | AilTypes.Union tag_sym ident_tys ->
        Core_ctype.Union tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
*)
    | AilTypes.Builtin str ->
        Core_ctype.Builtin str
  end




(* Core pattern builders **************************************************** *)

val mk_empty_pat: pattern
let mk_empty_pat =
  CaseBase Nothing

val mk_sym_pat: Symbol.sym -> core_base_type -> pattern
let mk_sym_pat sym bTy =
  CaseBase (Just (sym, bTy))

val mk_tuple_pat: list pattern -> pattern
let mk_tuple_pat = function
  | [] ->
      error "[Core_aux.mk_tuple_pat] called with |pats| = 0"
  | [pat] ->
      pat
  | pats ->
      CaseCtor Ctuple pats
end

val mk_specified_pat: pattern -> pattern
let mk_specified_pat pat =
  CaseCtor Cspecified [pat]




(* Core pexpr builders  ***************************************************** *)
val mk_sym_pe: core_base_type -> Symbol.sym -> pexpr (* TODO: remove the bTy *)
let mk_sym_pe bTy sym =
  Pexpr () (PEsym sym)

(* TODO: mk_impl_pe *)

(* TODO: PEval Vconstrained, Vobject *)

val mk_integer_pe: integer -> pexpr
let mk_integer_pe n =
  Pexpr () (PEval (Vobject (OVinteger (Mem.integer_ival n))))

val mk_floating_value_pe: Mem.floating_value -> pexpr
let mk_floating_value_pe fval =
  Pexpr () (PEval (Vobject (OVfloating fval)))

val mk_nullptr_pe: Core_ctype.ctype -> pexpr
let mk_nullptr_pe ref_ty =
  Pexpr () (PEval (Vobject (OVpointer (Mem.null_ptrval ref_ty))))

val mk_cfunction_pe: Symbol.sym -> pexpr
let mk_cfunction_pe fsym =
  Pexpr () (PEval (Vobject (OVcfunction (Sym fsym))))

val mk_specified_pe: pexpr -> pexpr
let mk_specified_pe pe =
    Pexpr () (PEctor Cspecified [pe])

val mk_unspecified_pe: Core_ctype.ctype -> pexpr
let mk_unspecified_pe ty =
  Pexpr () (PEval (Vunspecified ty))

val mk_unit_pe: pexpr
let mk_unit_pe =
  Pexpr () (PEval Vunit)

val mk_boolean_pe: bool -> pexpr
let mk_boolean_pe b =
  Pexpr () (PEval (if b then Vtrue else Vfalse))

(* TODO: PEval Vtrue, Vfalse *)

val mk_ail_ctype_pe: AilTypes.ctype -> pexpr
let mk_ail_ctype_pe ty =
  Pexpr () (PEval (Vctype (proj_ctype ty)))

val mk_ctype_pe: ctype -> pexpr
let mk_ctype_pe ty =
  Pexpr () (PEval (Vctype ty))

val     mk_list_pe: list pexpr -> pexpr
let rec mk_list_pe pes =
  Pexpr () match pes with
    | [] ->
        PEctor (Cnil ()) []
    | pe :: pes' ->
        PEctor Ccons [pe; mk_list_pe pes']
  end

val mk_tuple_pe: list pexpr -> pexpr
let mk_tuple_pe pes =
  Pexpr () (PEctor Ctuple pes)

val mk_ivmax_pe: pexpr -> pexpr
let mk_ivmax_pe pe =
  Pexpr () (PEctor Civmax [pe])

val mk_ivmin_pe: pexpr -> pexpr
let mk_ivmin_pe pe =
  Pexpr () (PEctor Civmin [pe])

val mk_sizeof_pe: pexpr -> pexpr
let mk_sizeof_pe pe =
  Pexpr () (PEctor Civsizeof [pe])

val mk_alignof_pe: pexpr -> pexpr
let mk_alignof_pe pe =
  Pexpr () (PEctor Civalignof [pe])

(* TODO: PEconstrained *)

val mk_undef_pe: Undefined.undefined_behaviour -> pexpr
let mk_undef_pe ub =
  Pexpr () (PEundef ub)

val mk_error_pe: string -> pexpr -> pexpr
let mk_error_pe str pe =
  Pexpr () (PEerror str pe)

val mk_not_pe: pexpr -> pexpr
let mk_not_pe pe =
  Pexpr () (PEnot pe)

val mk_op_pe: binop -> pexpr -> pexpr -> pexpr
let mk_op_pe bop pe1 pe2 =
  Pexpr () (PEop bop pe1 pe2)

val mk_let_pe: pattern -> pexpr -> pexpr -> pexpr
let mk_let_pe pat pe1 pe2 =
  Pexpr () (PElet pat pe1 pe2)

val mk_if_pe: pexpr -> pexpr -> pexpr -> pexpr
let mk_if_pe pe1 pe2 pe3 =
  Pexpr () (PEif pe1 pe2 pe3)
































val bitwise_complement_pe: pexpr -> pexpr -> pexpr
val integer_encode_pe:     pexpr -> pexpr -> pexpr
val integer_decode_pe:     pexpr -> pexpr -> pexpr

let bitwise_complement_pe pe1 pe2 =
  Pexpr () (PEcall (Impl Implementation_.Bitwise_complement) [pe1; pe2])
let integer_encode_pe pe1 pe2 =
  Pexpr () (PEcall (Impl Implementation_.Integer__encode) [pe1; pe2])
let integer_decode_pe pe1 pe2 =
  Pexpr () (PEcall (Impl Implementation_.Integer__decode) [pe1; pe2])

(* Some aliases for positive actions *)
let pcreate loc al ty pref = Eaction (Paction Pos (Action loc default (Create al ty pref )))
let palloc loc al e pref   = Eaction (Paction Pos (Action loc default (Alloc al e pref   )))
let pkill loc x            = Eaction (Paction Pos (Action loc default (Kill x         )))
let pstore loc ty x n mo   = Eaction (Paction Pos (Action loc default (Store ty x n mo)))
let pload loc ty x mo      = Eaction (Paction Pos (Action loc default (Load ty x mo   )))
let prmw loc ty x n1 n2 mo1 mo2 = Eaction (Paction Pos (Action loc default (RMW ty x n1 n2 mo1 mo2)))






(* for a given Ctype returns the corresponding "zero" value *)
(*val     zeros: AilSyntax.tag_definition -> Core_ctype.ctype -> pexpr *)
(* see ยง6.7.9#10 *)
let rec zeros_aux ty =
  let zero_ival = Mem.integer_ival 0 in
  match ty with
    | Core_ctype.Basic (AilTypes.Integer ity) ->
        Mem.integer_value_mval ity zero_ival
    | Core_ctype.Basic (AilTypes.Floating fty) ->
        Mem.floating_value_mval fty Mem.zero_fval
    | Core_ctype.Array elem_ty (Just n) ->
        Mem.array_mval (List.replicate (natFromInteger n) (zeros_aux elem_ty))
(*
  Mem.array_mval (List.replicate (natFromInteger n) (Mem.integer_value_mval zero_ival))
*)
    | Core_ctype.Pointer _ ref_ty ->
        Mem.pointer_mval ref_ty (Mem.null_ptrval ref_ty)
    | Core_ctype.Atomic ty' ->
        zeros_aux ty'
    | Core_ctype.Struct tag ->
        match Map.lookup tag (Core_ctype_aux.tagDefs ()) with
          | Just ident_tys ->
              Mem.struct_mval tag (List.map (fun (ident, ty) -> (ident, zeros_aux ty)) ident_tys)
          | _ ->
              error "Core_aux.zeros_aux, not StructDef"
        end
    | Core_ctype.Union tag ->
        match Map.lookup tag (Core_ctype_aux.tagDefs ()) with
          | Just ((ident, ty')::_) ->
              Mem.union_mval tag ident (zeros_aux ty')
          | _ ->
              error "Core_aux.zeros_aux, not UnionDef"
        end

(*
 | Builtin of string
*)
   | _ ->
       error "Core_aux.zeros should only be called on complete types"
  end

val zeros: ctype -> pexpr
let zeros ty =
  (* TODO: yucky *)
  Pexpr ()
(*
    (PEval (Vobject (snd $ objectValueFromMemValue (zeros_aux ty))))
*)
    (PEval (snd $ valueFromMemValue (zeros_aux ty)))


(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | AilTypes.Void             -> Core_ctype.Void
    | AilTypes.Basic bt         -> Core_ctype.Basic bt
    | AilTypes.Array ty n       -> Core_ctype.Array (proj_ctype ty) n
    | AilTypes.Function ty ps b -> Core_ctype.Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | AilTypes.Pointer _ ty    -> Core_ctype.Pointer (proj_ctype ty)
    | AilTypes.Atomic ty        -> Core_ctype.Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> error "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  match ty with
    | Core_ctype.Void ->
        AilTypes.Void
    | Core_ctype.Basic bty ->
        AilTypes.Basic bty
    | Core_ctype.Array ty n_opt ->
        AilTypes.Array (unproj_ctype ty) n_opt
    | Core_ctype.Function ty qs_tys is_variadic ->
        AilTypes.Function (* TODO!!!! proto *) false (unproj_ctype ty) (List.map (fun (qs,ty) -> (qs, unproj_ctype ty)) qs_tys) is_variadic
    | Core_ctype.Pointer qs ty ->
        AilTypes.Pointer qs (unproj_ctype ty)
    | Core_ctype.Atomic ty ->
        AilTypes.Atomic (unproj_ctype ty)
    | Core_ctype.Struct tag ->
        AilTypes.Struct tag
    | Core_ctype.Union tag ->
        AilTypes.Union tag
    | Core_ctype.Builtin str ->
        AilTypes.Builtin str
  end


(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Core_ctype.Void              -> AilTypes.Void
    | Core_ctype.Basic bt          -> AilTypes.Basic bt
    | Core_ctype.Array ty n        -> AilTypes.Array (unproj_ctype ty) n
    | Core_ctype.Function ty tys b -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys) b
    | Core_ctype.Pointer ty        -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
    | Core_ctype.Atomic ty         -> AilTypes.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)





let rec mk_wseqs_aux end_e pat_es =
  match pat_es with
    | []               -> end_e
    | (pat, e) :: pat_es' -> Ewseq pat e (mk_wseqs_aux end_e pat_es')
end

val mk_wseqs: expr unit -> list (pattern * expr unit) -> expr unit
let mk_wseqs end_e = function
  | [] ->
      end_e
  | [(_, e)] ->
      e
  | pat_es ->
      mk_wseqs_aux end_e pat_es
end

(* val     mk_sseq: forall 'a. list (pattern * expr 'a) -> expr 'a *)
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

(* val     mk_sseq': forall 'a. list (pattern * expr 'a) -> expr 'a -> expr 'a *)
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end



let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end

val     mk_unit_sseq: list (expr unit) -> expr unit
let rec mk_unit_sseq es =
  match es with
    | [] ->
        Eskip
    | e::es' ->
        Esseq mk_empty_pat e (mk_unit_sseq es')
  end




let rec concat_sseq e e' =
   match e with
     | Esseq pat e1 e2 -> Esseq pat e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq (CaseBase Nothing) e e'
  end

let is_negative = function
  | Eaction (Paction Neg _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Paction Neg _) -> true
  | _ -> false
end


val valueFromPexpr: pexpr -> maybe value
let valueFromPexpr = function
  | Pexpr () (PEval cval) ->
      Just cval
  | _ ->
      Nothing
  end

val     valueFromPexprs: list pexpr -> maybe (list value)
let rec valueFromPexprs pes =
  List.foldr (fun pe acc_opt ->
    match (valueFromPexpr pe, acc_opt) with
      | (Just cval, Just acc) ->
          Just (cval :: acc)
      | _ ->
          Nothing
    end) (Just []) pes


val to_integer: pexpr -> maybe integer
let to_integer pe =
  match valueFromPexpr pe with
    | Just (Vobject (OVinteger ival)) ->
        Mem_aux.integerFromIntegerValue ival
    | _ ->
        Nothing
  end










(* check if a symbolic names is part of a pattern *)
val in_pattern: Symbol.sym -> pattern -> bool
let rec in_pattern sym pat =
  match pat with
    | CaseBase sym_bTy_opt ->
        maybe false (fun (sym', _) -> sym = sym') sym_bTy_opt
    | CaseCtor _ pats' ->
        List.any (in_pattern sym) pats'
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym_pexpr: Symbol.sym -> pexpr -> pexpr -> pexpr
let rec subst_sym_pexpr sym (Pexpr annot pe_' as pe') (Pexpr _ pe_) =
  Pexpr annot match pe_ with
    | PEsym sym' ->
        if sym = sym' then pe_' else pe_
    | PEimpl _ ->
        pe_
    | PEval _ ->
        pe_
    | PEconstrained xs ->
        PEconstrained $
          List.map (fun (constrs, pe) -> (constrs, subst_sym_pexpr sym pe' pe)) xs
    | PEundef _ ->
        pe_
    | PEerror str pe ->
        PEerror str (subst_sym_pexpr sym pe' pe)
    | PEctor ctor pes ->
        PEctor ctor (List.map (subst_sym_pexpr sym pe') pes)
    | PEcase pe xs ->
        PEcase (subst_sym_pexpr sym pe' pe) (List.map (fun (pat, pe) ->
          (pat, if in_pattern sym pat then pe else subst_sym_pexpr sym pe' pe)
        ) xs)
    | PEarray_shift pe1 ty pe2 ->
        PEarray_shift (subst_sym_pexpr sym pe' pe1) ty (subst_sym_pexpr sym pe' pe2)
    | PEmember_shift pe tag_sym memb_ident ->
        PEmember_shift (subst_sym_pexpr sym pe' pe) tag_sym memb_ident
    | PEnot pe ->
        PEnot (subst_sym_pexpr sym pe' pe)
    | PEop bop pe1 pe2 ->
        PEop bop (subst_sym_pexpr sym pe' pe1) (subst_sym_pexpr sym pe' pe2)
    | PEstruct tag_sym xs ->
        PEstruct tag_sym (List.map (fun (ident, pe) -> (ident, subst_sym_pexpr sym pe' pe)) xs)
    | PEunion tag_sym ident pe ->
        PEunion tag_sym ident (subst_sym_pexpr sym pe' pe)
    | PEcall nm pes ->
        PEcall nm (List.map (subst_sym_pexpr sym pe') pes)
    | PElet pat pe1 pe2 ->
        PElet pat (subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then pe2 else subst_sym_pexpr sym pe' pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (subst_sym_pexpr sym pe' pe1) (subst_sym_pexpr sym pe' pe2) (subst_sym_pexpr sym pe' pe3)
    | PEis_scalar pe ->
        PEis_scalar (subst_sym_pexpr sym pe' pe)
    | PEis_integer pe ->
        PEis_integer (subst_sym_pexpr sym pe' pe)
    | PEis_signed pe ->
        PEis_signed (subst_sym_pexpr sym pe' pe)
    | PEis_unsigned pe ->
        PEis_unsigned (subst_sym_pexpr sym pe' pe)
end


val     subst_sym_expr: forall 'a. Symbol.sym -> pexpr -> expr 'a -> expr 'a
let rec subst_sym_expr sym pe' = function
(*
  let () =
    (* TODO: debug *)
    match valueFromPexpr pe' with
      | Just _ ->
          ()
      | Nothing ->
          error ("DEBUG [Caux.subst_sym_expr]: called on a non-value: " ^ Pp.stringFromCore_expr (Epure pe'))
    end
  in
  match _pe with
*)
  | Epure pe ->
      Epure (subst_sym_pexpr sym pe' pe)
  | Ememop memop pes ->
      Ememop memop (List.map (subst_sym_pexpr sym pe') pes)
  | (Eskip as expr) ->
      expr
  | Elet pat pe1 e2 ->
      Elet pat (subst_sym_pexpr sym pe' pe1) (if in_pattern sym pat then e2 else subst_sym_expr sym pe' e2)
  | Eif pe1 e2 e3 ->
      Eif (subst_sym_pexpr sym pe' pe1) (subst_sym_expr sym pe' e2) (subst_sym_expr sym pe' e3)
  | Ecase pe pat_es ->
      Ecase (subst_sym_pexpr sym pe' pe) (List.map (fun (pat, e) ->
        (pat, if in_pattern sym pat then e else subst_sym_expr sym pe' e)
      ) pat_es)
  | Eproc annot pe pes ->
      Eproc annot (subst_sym_pexpr sym pe' pe) (List.map (subst_sym_pexpr sym pe') pes)
  | Eaction pact ->
      Eaction (subst_sym_paction sym pe' pact)
  | Eunseq es ->
      Eunseq (List.map (subst_sym_expr sym pe') es)
  | Ewseq pat e1 e2 ->
      Ewseq pat (subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else subst_sym_expr sym pe' e2)
  | Esseq pat e1 e2 ->
      Esseq pat (subst_sym_expr sym pe' e1) (if in_pattern sym pat then e2 else subst_sym_expr sym pe' e2)
  | Easeq pat act1 pact2 ->
      Easeq pat (subst_sym_action sym pe' act1) (
        match pat with
          | Just (sym, _) ->
              pact2
          | Nothing ->
              subst_sym_paction sym pe' pact2
        end
      )
  | Eindet i e ->
      Eindet i (subst_sym_expr sym pe' e)
  | Ebound i e ->
      Ebound i (subst_sym_expr sym pe' e)
  | Esave ksym sym_tys e ->
      Esave ksym sym_tys (subst_sym_expr sym pe' e)
  | Erun annot ksym sym_pes ->
      Erun annot ksym (list_update sym pe' sym_pes)
  | Ereturn pe ->
      Ereturn (subst_sym_pexpr sym pe' pe)
  | End es ->
      End (List.map (subst_sym_expr sym pe') es)
  | Epar es ->
      Epar (List.map (subst_sym_expr sym pe') es)
  | (Ewait _ as expr) ->
      expr
  | Eloc loc e ->
      Eloc loc (subst_sym_expr sym pe' e)
end



and subst_sym_action_ a pe' = function
  | Create pe1 pe2 pref ->
      Create (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) pref
  | Alloc pe1 pe2 pref ->
      Alloc (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) pref
  | Kill pe ->
      Kill (subst_sym_pexpr a pe' pe)
  | Store pe1 pe2 pe3 mo ->
      Store (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) mo
  | Load pe1 pe2 mo ->
      Load (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) mo
  | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      RMW (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) (subst_sym_pexpr a pe' pe4) mo1 mo2
  | Fence mo ->
      Fence mo
(*
  | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeStrong (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) (subst_sym_pexpr a pe' pe4) mo1 mo2
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (subst_sym_pexpr a pe' pe1) (subst_sym_pexpr a pe' pe2) (subst_sym_pexpr a pe' pe3) (subst_sym_pexpr a pe' pe4) mo1 mo2
*)
  end
and subst_sym_action a pe' (Action loc bs act_) =
  Action loc bs (subst_sym_action_ a pe' act_)
and subst_sym_paction a pe' (Paction p act) =
  Paction p (subst_sym_action  a pe' act)



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val     subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> expr 'a
let rec subst_pattern pat pe' expr =
  
  match (pat, pe') with
    | (CaseBase Nothing, _) ->
        expr
    | (CaseBase (Just (sym, _)), _) ->
        subst_sym_expr sym pe' expr
    | (CaseCtor (Cnil ()) [], Pexpr _ (PEval (Vlist _ []))) ->
        (* empty list (value) *)
        expr
    | (CaseCtor (Cnil _) [], Pexpr _ (PEctor (Cnil _) [])) ->
        (* empty list (pure expr) *)
        expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr () (PEval (Vlist bTy_elem (v::vs)))) ->
        (* populated list (value) *)
        subst_pattern pat1 (Pexpr () (PEval v)) $
          subst_pattern pat2 (Pexpr () (PEval (Vlist bTy_elem vs))) expr
    | (CaseCtor Ccons [pat1; pat2], Pexpr _ (PEctor Ccons [pe1; pe2])) ->
        (* populated list (pure expr) *)
        subst_pattern pat1 pe1 $
          subst_pattern pat2 pe2 expr
    | (CaseCtor Ctuple pats', Pexpr () (PEval (Vtuple vs))) ->
        let pes = List.map (fun v ->
          Pexpr () (PEval v)
        ) vs in
        List.foldr (fun (pat', pe) acc ->
          subst_pattern pat' pe acc
        ) expr (List.zip pats' pes)
    | (CaseCtor Ctuple pats', Pexpr _ (PEctor Ctuple pes)) ->
        List.foldr (fun (pat', pe) acc ->
          subst_pattern pat' pe acc
        ) expr (List.zip pats' pes)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor Cloaded [pat'], Pexpr () (PEval (Vspecified oval))) ->
        subst_pattern pat' (Pexpr () (PEval (Vobject oval))) expr
    | (CaseCtor Cspecified [pat'], Pexpr () (PEctor Cspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | (CaseCtor Cunspecified [pat'], Pexpr () (PEval (Vunspecified ty))) ->
        subst_pattern pat' (Pexpr () (PEval (Vctype ty))) expr
    | (CaseCtor Cunspecified [pat'], Pexpr () (PEctor Cunspecified [pe''])) ->
        subst_pattern pat' pe'' expr
    | _ ->
        error "WIP: Core_aux.subst_pattern"
  end


val     to_pure: forall 'a. expr 'a -> maybe pexpr
let rec to_pure (expr : expr 'a) =
  match expr with
    | Epure pe ->
        Just pe
    | Ememop _ _ ->
        Nothing
    | Eskip ->
        Nothing
    | Elet pat pe1 e2 ->
        match to_pure e2 with
          | Just (Pexpr bTy _ as pe2) ->
              Just (Pexpr bTy (PElet pat pe1 pe2))
          | _ ->
              Nothing
        end
    | Eif pe1 e2 e3 ->
        match (to_pure e2, to_pure e3) with
          | (Just (Pexpr bTy _ as pe2), Just pe3) ->
              Just (Pexpr bTy (PEif pe1 pe2 pe3))
          | _ ->
              Nothing
        end
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq es ->
        match to_pures es with
          | Just pes ->
              Just (Pexpr () (PEctor Ctuple pes))
          | Nothing ->
              Nothing
        end
    | Ewseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure (subst_pattern pat pe1 e2)
          | Nothing ->
              Nothing
        end
    | Esseq pat e1 e2 ->
        match to_pure e1 with
          | Just pe1 ->
              to_pure (subst_pattern pat pe1 e2)
          | Nothing ->
              Nothing
        end
    | Easeq _ _ _ ->
      Nothing
    | Eindet _ _ ->
        Nothing
    | Ebound _ e ->
        (* TODO: checl *)
        to_pure e
    | Esave _ _ _ ->
        Nothing
    | Erun _ _ _ ->
        Nothing
    | Ereturn _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Nothing
    | Ewait _ ->
        Nothing
    | Eloc _ e ->
        to_pure e
    | Ecase pe pat_es ->
       let (pats, es) = List.unzip pat_es in
        match to_pures es with
          | Just ((Pexpr bTy _ :: _) as pes) ->
              Just (Pexpr bTy (PEcase pe (List.zip pats pes)))
          | _ ->
            Nothing
        end
end

(* val     to_pures: forall 'a. list (expr 'a) -> maybe (list pexpr)*)
and to_pures (es: list (expr 'a)) =
  List.foldr (fun e acc_opt ->
    match (to_pure e, acc_opt) with
      | (Just pe, Just acc) ->
          Just (pe :: acc)
      | _ ->
          Nothing
    end) (Just []) es



val subst_wait: forall 'a. thread_id -> value -> expr 'a -> expr 'a
let rec subst_wait tid v = function
  | (Epure _ as expr) ->
      expr
  | (Ememop _ _ as expr) ->
      expr
  | (Eskip as expr) ->
      expr
  | Elet sym pe1 e2 ->
      Elet sym pe1 (subst_wait tid v e2)
  | Eif pe1 e2 e3 ->
      Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
  | Ecase pe pat_es ->
      Ecase pe (List.map (fun (pat, e) -> (pat, subst_wait tid v e)) pat_es)
  | (Eproc _ _ _ as expr) ->
      expr
  | (Eaction _ as expr) ->
      expr
  | Eunseq es ->
      Eunseq (List.map (subst_wait tid v) es)
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | (Easeq _ _ _ as expr) ->
       expr
   | Eindet i e ->
       Eindet i (subst_wait tid v e)
   | Ebound i e ->
       Ebound i (subst_wait tid v e)
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
   | (Ereturn _ as expr) ->
       expr
   | End es ->
       End (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         if v <> Vunit then
(*           error "TODO CONCUR: Core_aux.subst_wait ==> v <> Vunit" *)
           Epure (Pexpr () (PEval v))
         else
           Epure (Pexpr () (PEval Vunit))
       else
         Ewait tid'
   | Eloc loc e ->
       Eloc loc (subst_wait tid v e)
end



let subst_wait_continuation_element tid v = function
  | Kunseq es1 es2 ->
      Kunseq (List.map (subst_wait tid v) es1) (List.map (subst_wait tid v) es2)
  | Kwseq syms_opt e2 ->
      Kwseq syms_opt (subst_wait tid v e2)
  | Ksseq syms_opt e2 ->
      Ksseq syms_opt (subst_wait tid v e2)
(*
  | Ktry str_es ->
      Ktry (List.map (fun (str, e) -> (str, subst_wait tid v e)) str_es)
*)
end

let subst_wait_continuation tid v cont =
  List.map (subst_wait_continuation_element tid v) cont

let rec subst_wait_stack tid v = function
  | Stack_empty ->
      Stack_empty
  | Stack_cons cont sk ->
      Stack_cons (subst_wait_continuation tid v cont) (subst_wait_stack tid v sk)
end



let rec find_labeled_continuation ksym expr =
let () = Debug.print_debug 3 ("Core_aux.find_labeled_continuation: " ^ show ksym ^ " ==> " ^ Pp.stringFromCore_expr expr) in
match expr with
  | Epure _ ->
      Nothing
  | Ememop _ _ ->
      Nothing
  | Eskip ->
      Nothing
  | Elet _ _ e2 ->
      find_labeled_continuation ksym e2
  | Eif _ e2 e3 ->
      match find_labeled_continuation ksym e2 with
        | Just cont ->
            Just cont
        | Nothing ->
            find_labeled_continuation ksym e3
      end
  | Eproc _ _ _ ->
      Nothing
  | Eaction _ ->
      Nothing
  | Eunseq _ ->
      Nothing
  | Ewseq _as e1 e2 ->
      match find_labeled_continuation ksym e1 with
        | Just (sym_tys, cont_e) ->
            Just (sym_tys, Ewseq _as cont_e e2)
        | Nothing ->
            find_labeled_continuation ksym e2
      end
  | Esseq _as e1 e2 ->
      match find_labeled_continuation ksym e1 with
        | Just (sym_tys, cont_e) ->
            Just (sym_tys, Esseq _as cont_e e2)
        | Nothing ->
            find_labeled_continuation ksym e2
      end
  | Easeq _ _ _ ->
      error "Core_aux.find_labeled_continuation: Easeq shouldn't exists at this point"
  | Eindet _ _ ->
      error "Core_aux.find_labeled_continuation: Eindet shouldn't exists at this point"
  | Ebound _ _ ->
      error "Core_aux.find_labeled_continuation: Ebound shouldn't exists at this point"
  | Esave ksym' sym_tys e ->
      if ksym = ksym' then
        Just (sym_tys, e)
      else
        find_labeled_continuation ksym e
  | Erun _ _ _ ->
      Nothing
(*
  | Ereturn _ ->
      Nothing
*)
  | End _ ->
      Nothing
  | Epar _ ->
      error "Core_aux.find_labeled_continuation:  think about this Ctor (Epar)"
  | Ewait _ ->
      Nothing
  | Eloc _ e ->
      find_labeled_continuation ksym e
  end



val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont expr =
    match _cont with
      | Kwseq pat e2 ->
          Ewseq pat expr e2
      | Ksseq pat e2 ->
          Esseq pat expr e2
      | Kunseq es1 es2 ->
          Eunseq $ es1 ++ (expr :: es2)
(*
      | Ktry str_es ->
          Etry expr str_es
*)
    end in
  foldl (fun acc x -> f x acc) expr cont


(* Functions on continuation and stacks *)
val empty_stack: forall 'a. stack 'a
let empty_stack =
  Stack_empty

val is_empty_stack: forall 'a. stack 'a -> bool
let is_empty_stack = function
  | Stack_empty ->
      true
  | _ ->
      false
end



val push_empty_continuation: forall 'a. stack 'a -> stack 'a
let push_empty_continuation sk =
  Stack_cons [] sk

val pop_stack: forall 'a. stack 'a -> Exception.exceptM (continuation 'a * stack 'a) core_run_error
let pop_stack = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_stack")
  | Stack_cons cont sk ->
      Exception.return (cont, sk)
end

val pop_continuation_element: forall 'a. stack 'a -> Exception.exceptM (continuation_element 'a * stack 'a) core_run_error
let pop_continuation_element = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_continuation_element")
  | Stack_cons [] _ ->
      Exception.fail Reached_end_of_proc
  | Stack_cons (cont_elem :: cont) sk ->
      Exception.return (cont_elem, Stack_cons cont sk)
end


val push_continuation_element: forall 'a. continuation_element 'a -> stack 'a -> Exception.exceptM (stack 'a) core_run_error
let push_continuation_element cont_elem = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "push_continuation_element")
  | Stack_cons cont sk ->
      Exception.return (Stack_cons (cont_elem :: cont) sk)
end



val append_to_current_continuation: forall 'a. continuation_element 'a -> stack 'a -> Exception.exceptM (stack 'a) core_run_error
let append_to_current_continuation cont = function
  | Stack_empty ->
      (* A procedure need to currently be running to append *)
      Exception.fail (Found_empty_stack "append_to_current_continuation")
  | Stack_cons ccont sk ->
      Exception.return $ Stack_cons (cont :: ccont) sk
end


val subst_sym_fun_map: forall 'a. Symbol.sym -> pexpr -> fun_map 'a -> fun_map 'a
let subst_sym_fun_map sym pe' funs =
  Map.map (function
    | Fun ty params pe ->
        Fun ty params (subst_sym_pexpr sym pe' pe)
    | Proc ty params e ->
        Proc ty params (subst_sym_expr sym pe' e)
  end) funs


val     collect_labeled_continuations: forall 'a. expr 'a -> map Symbol.sym (list (Symbol.sym * Core_ctype.ctype) * expr 'a)
let rec collect_labeled_continuations expr =
  match expr with
    | Epure _ ->
        Map.empty
    | Ememop _ _ ->
        Map.empty
    | Eskip ->
        Map.empty
    | Elet _ _ e2 ->
        collect_labeled_continuations e2
    | Eif pe1 e2 e3 ->
        Map.(union) (collect_labeled_continuations e2) (collect_labeled_continuations e3)
    | Ecase pe pat_es ->
        Map.empty (* TODO THIS IS WRONG!!!!! *)
    | Eproc _ _ _ ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Ewseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Ewseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Esseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Esseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Easeq _ _ _ ->
        Map.empty
    | Eindet _ _ ->
        Map.empty
    | Ebound _ _ ->
        Map.empty
    | Esave k a_tys e ->
        Map.insert k (a_tys, e) $ collect_labeled_continuations e
    | Erun _ _ _ ->
        Map.empty
    | Ereturn _ ->
        Map.empty
    | End _ ->
        (* TODO: check *)
        Map.empty
    | Epar _ ->
        (* TODO: check *)
        Map.empty
    | Ewait _ ->
        Map.empty
    | Eloc loc e ->
        collect_labeled_continuations e
  end



val is_unseq_with_negative: forall 'a. expr 'a -> bool
let is_unseq_with_negative expr =
  match expr with
    | Eunseq es ->
        List.any is_negative es
    | _ ->
        false
  end


val     has_sseqs: forall 'a. expr 'a -> bool
let rec has_sseqs expr =
  match expr with
    | Epure _ ->
        false
    | Ememop _ _ ->
        false
    | Eskip ->
        false
    | Elet _ _ e2 ->
        has_sseqs e2
    | Eif _ e2 e3 ->
        has_sseqs e2 || has_sseqs e3
    | Eproc _ _ _ ->
        (* TODO *)
        false
    | Eaction p ->
        false
    | Eunseq es ->
        List.any has_sseqs es
    | Ewseq _ e1 e2 ->
        has_sseqs e1 || has_sseqs e2
    | Esseq _ _ _ ->
        true
    | Easeq _ _ _  ->
        error "has_sseqs found an Easeq"
    | Eindet _ e ->
        has_sseqs e
    | Ebound _ e ->
        has_sseqs e
    | Esave _ _ e ->
        has_sseqs e
    | Erun _ _ _ ->
        false
(*
    | Ereturn _ ->
        false
*)
    | End es ->
        List.any has_sseqs es
    | Epar _ ->
        (* TODO: I think *)
        false
    | Ewait _ ->
        false
    | Eloc _ e ->
        has_sseqs e
  end




val     match_pattern: pattern -> pexpr -> maybe (list (sym * pexpr))
let rec match_pattern pat ((Pexpr () pe_) as pexpr) =
  match (pat, pe_) with
    | (CaseBase Nothing, _) ->
        Just []
    | (CaseBase (Just (sym, _)), _) ->
        Just [(sym, pexpr)]
(*      | Vobject of (generic_object_value 'sym) *)
    | (CaseCtor Cspecified [pat'], PEval (Vspecified oval)) ->
        match_pattern pat' (Pexpr () (PEval (Vobject oval)))
    | (CaseCtor Cunspecified [pat'], PEval (Vunspecified ty)) ->
        match_pattern pat' (mk_ctype_pe ty)
(*      | Vlist of core_base_type * list (generic_value 'sym) *)
    | (CaseCtor Ctuple pats', PEval (Vtuple cvals')) -> 
        List.foldr (fun (pat', cval') acc ->
          Maybe.bind acc (fun xs ->
            Maybe.bind (match_pattern pat' (Pexpr () (PEval cval'))) (fun x ->
              Just (x++xs)
            )
          )
        ) (Just []) (List.zip pats' cvals')
    | _ ->
        Nothing
  end

val     select_case: forall 'a. (Symbol.sym -> pexpr -> 'a -> 'a) -> pexpr -> list (pattern * 'a) -> maybe 'a
let rec select_case subst_sym pexpr = function
  | [] ->
      Nothing
  | (pat, pe) :: pat_pes' ->
      match match_pattern pat pexpr with
        | Nothing ->
            (* trying the next branch *)
            select_case subst_sym pexpr pat_pes'
        | Just (sym_pes) ->
            Just $ List.foldr (fun (sym, pe') acc ->
              subst_sym sym pe' acc
            ) pe sym_pes
      end
end
