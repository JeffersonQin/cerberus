open import Pervasives Global Show Core
import Boot Product Symbolic Exception Naive_memory

open import Thread Core_run_aux

module Mem = Naive_memory



val toMemValue: value -> maybe Mem.mem_value
let toMemValue cval =
  match cval with
    | Vunit ->
        Nothing
    | Vtrue ->
        Nothing
    | Vfalse ->
        Nothing
    | Vlist _ ->
        Nothing
    | Vtuple _ ->
        Nothing
    | Vctype _ ->
        Nothing
    | Vinteger symb ->
        Just (Mem.MVinteger symb)
    | Vfloating str ->
        Just (Mem.mk_floating str)
    | Vpointer ptr_val ->
        Just (Mem.mk_pointer ptr_val)
  end



val sizeof: pexpr -> pexpr
let sizeof pe =
  PEcall (Impl Implementation_.Sizeof) [pe]

val alignof: pexpr -> pexpr
let alignof pe =
  PEcall (Impl Implementation_.Alignof) [pe]

val ctype_min: pexpr -> pexpr
let ctype_min pe =
  PEcall (Impl Implementation_.Ctype_min) [pe]

val ctype_max: pexpr -> pexpr
let ctype_max pe =
  PEcall (Impl Implementation_.Ctype_max) [pe]

val bitwise_complement: pexpr -> pexpr -> pexpr
let bitwise_complement pe1 pe2 =
  PEcall (Impl Implementation_.Bitwise_complement) [pe1; pe2]

val integer_encode: pexpr -> pexpr -> pexpr
let integer_encode pe1 pe2 =
  PEcall (Impl Implementation_.Integer__encode) [pe1; pe2]

val integer_decode: pexpr -> pexpr -> pexpr
let integer_decode pe1 pe2 =
  PEcall (Impl Implementation_.Integer__decode) [pe1; pe2]




(* Some aliases for positive actions *)
let pcreate al ty pref = Eaction (Paction Pos (Action default (Create al ty pref )))
let palloc al e pref   = Eaction (Paction Pos (Action default (Alloc al e pref   )))
let pkill x            = Eaction (Paction Pos (Action default (Kill x         )))
let pstore ty x n mo   = Eaction (Paction Pos (Action default (Store ty x n mo)))
let pload ty x mo      = Eaction (Paction Pos (Action default (Load ty x mo   )))


let zero =
  PEval (Vinteger (Symbolic.SYMBconst 0))

let one =
  PEval (Vinteger (Symbolic.SYMBconst 1))
declare {coq} rename function zero = zero_ (* workaround for Lem issue #87 *)


val cfunction_const: Symbol.t -> pexpr
let cfunction_const fsym =
  PEval (Vpointer (Mem.function_pointer fsym))




(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core_ctype.ctype
let rec proj_ctype ty =
  match ty with
    | AilTypes.Void ->
        Core_ctype.Void
    | AilTypes.Basic bty ->
        Core_ctype.Basic bty
    | AilTypes.Array ty n_opt ->
        Core_ctype.Array (proj_ctype ty) n_opt
    | AilTypes.Function ty qs_tys is_variadic ->
        Core_ctype.Function (proj_ctype ty) (List.map (fun (qs,ty) -> (qs, proj_ctype ty)) qs_tys) is_variadic
    | AilTypes.Pointer qs ty ->
        Core_ctype.Pointer qs (proj_ctype ty)
    | AilTypes.Atomic ty ->
        Core_ctype.Atomic (proj_ctype ty)
    | AilTypes.Struct tag_sym ->
        Core_ctype.Struct tag_sym
    | AilTypes.Union tag_sym ->
        Core_ctype.Union tag_sym
(*
    | AilTypes.Struct tag_sym ident_tys ->
        Core_ctype.Struct tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
    | AilTypes.Union tag_sym ident_tys ->
        Core_ctype.Union tag_sym
          (List.map (fun (ident, ty) -> (ident, proj_ctype ty)) ident_tys)
*)
    | AilTypes.Builtin str ->
        Core_ctype.Builtin str
  end




(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | AilTypes.Void             -> Core_ctype.Void
    | AilTypes.Basic bt         -> Core_ctype.Basic bt
    | AilTypes.Array ty n       -> Core_ctype.Array (proj_ctype ty) n
    | AilTypes.Function ty ps b -> Core_ctype.Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | AilTypes.Pointer _ ty    -> Core_ctype.Pointer (proj_ctype ty)
    | AilTypes.Atomic ty        -> Core_ctype.Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> Boot.assert_false "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  match ty with
    | Core_ctype.Void ->
        AilTypes.Void
    | Core_ctype.Basic bty ->
        AilTypes.Basic bty
    | Core_ctype.Array ty n_opt ->
        AilTypes.Array (unproj_ctype ty) n_opt
    | Core_ctype.Function ty qs_tys is_variadic ->
        AilTypes.Function (unproj_ctype ty) (List.map (fun (qs,ty) -> (qs, unproj_ctype ty)) qs_tys) is_variadic
    | Core_ctype.Pointer qs ty ->
        AilTypes.Pointer qs (unproj_ctype ty)
    | Core_ctype.Atomic ty ->
        AilTypes.Atomic (unproj_ctype ty)
    | Core_ctype.Struct tag ->
        AilTypes.Struct tag
    | Core_ctype.Union tag ->
        AilTypes.Union tag
    | Core_ctype.Builtin str ->
        AilTypes.Builtin str
  end


(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Core_ctype.Void              -> AilTypes.Void
    | Core_ctype.Basic bt          -> AilTypes.Basic bt
    | Core_ctype.Array ty n        -> AilTypes.Array (unproj_ctype ty) n
    | Core_ctype.Function ty tys b -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys) b
    | Core_ctype.Pointer ty        -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
    | Core_ctype.Atomic ty         -> AilTypes.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)

val mk_ctype: forall 'a. AilTypes.ctype -> pexpr
let mk_ctype ty = PEval (Vctype (proj_ctype ty))

let rec mk_wseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Ewseq a_opts e (mk_wseq es')
end

val     mk_sseq: forall 'a. list (list (maybe Core.sym) * expr 'a) -> expr 'a
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

val     mk_sseq': forall 'a. list (list (maybe Core.sym) * expr 'a) -> expr 'a -> expr 'a
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end



let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end



let rec concat_sseq e e' =
   match e with
     | Esseq _as e1 e2 -> Esseq _as e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq [] e e'
  end

let is_negative = function
  | Eaction (Paction Neg _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Paction Neg _) -> true
  | _ -> false
end


val     to_value: pexr -> maybe value
let rec to_value pexpr =
  match pexpr with
    | PEval cval ->
        Just cval
    | PEsym _ ->
        Nothing
    | PEimpl _ ->
        Nothing
    | PEcons pe1 pe2 ->
        match (to_value pe1, to_value pe2) with
          | (Just cval1, Just (Vlist cvals)) ->
              Just (Vlist (cval1 :: cvals))
          |  _ ->
              Nothing
        end
    | PEcase_list of pexpr * name * name
    | PEcase_ctype of pexpr * name * name * name * name * name * name * name * name * name
    | PEshift of pexpr * shift_path
    | PEnot of pexpr
    | PEop of binop * pexpr * pexpr
    | PEtuple of list pexpr
    | PEarray xs ->
        Varray
        List.foldr (fun acc_opt x ->
          match (acc_opt, x) with
            | (Just acc, Left mem_val) ->
                Just (mem_val :: acc)
          | _ ->
              Nothing
        end) xs
    | PEcall _ _ ->
         (* TODO: maybe do some eval? *)
        Nothing
    | PEif (PEval Vtrue) pe2 _ ->
        to_value pe2
    | PEif (PEval Vfalse) _ pe3 ->
        to_value pe3
  end

val     to_pure: forall 'a. expr 'a -> pexpr
let rec to_pure expr =
  match expr with
    | Epure pe ->
        Just pe
    | Eundef _ ->
        Nothing
    | Eerror _ ->
        Nothing
    | Eraise _ ->
        Nothing
    | Eregister _ _ ->
        Nothing
    | Eskip ->
        Nothing
    | Elet sym pe1 e2 ->
        match to_pure e2 with
          | Just pe2 ->
              Just (PElet sym pe1 pe2)
          | Nothing
        end
    | Eif pe1 e2 e3 ->
        match (to_pure e2, to_pure e3) with
          | (Just pe2, Just pe3) ->
              Just (PEif pe1 pe2 pe3)
          | _ ->
              Nothing
        end
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq _ ->
        Nothing
    | Ewseq _ _ _ ->
        Nothing
    | Esseq _ _ _ ->
        Nothing
    | Easeq _ _ _ ->
      Nothing
    | Eindet _ ->
        Nothing
    | Ebound _ _ ->
        Nothing
    | Esave _ _ _ ->
        Nothing
    | Erun _ _ _ ->
        Nothing
    | Eret _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Nothing
    | Ewait _ ->
        Nothing
end







(* check if a symbolic names is part of a pattern *)
val in_pattern: sym -> list (maybe sym) -> bool
let rec in_pattern a p =
  match p with
    | []             -> false
    | Nothing  :: xs -> in_pattern a xs
    | Just a'  :: xs -> if a = a' then true else in_pattern a xs
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym_pexpr: sym -> value -> pexpr -> pexpr
let rec subst_sym_pexpr sym v = function
  | (PEval _ as pe) ->
      pe
  | (PEsym sym' as pe) ->
      if sym = sym' then PEval v else pe
  | (PEimpl _ as pe) ->
      pe
  | PEcons pe1 pe2 ->
      PEcons (subst_sym_pexpr sym v pe1) (subst_sym_pexpr sym v pe2)
  | PEcase_list pe nm1 nm2 ->
      PEcase_list (subst_sym_pexpr sym v pe) nm1 nm2
  | PEcase_ctype pe nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8 nm9 ->
      PEcase_ctype (subst_sym_pexpr sym v pe) nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8 nm9
  | PEshift pe sh ->
      PEshift (subst_sym_pexpr sym v pe) (List.map (fun (ty, pe) -> (ty, subst_sym_pexpr sym v pe)) sh)
  | PEnot pe ->
      PEnot (subst_sym_pexpr sym v pe)
  | PEop bop pe1 pe2 ->
      PEop bop (subst_sym_pexpr sym v pe1) (subst_sym_pexpr sym v pe2)
  | PEtuple pes ->
      PEtuple (List.map (subst_sym_pexpr sym v) pes)
  | PEarray xs ->
      match toMemValue v with
        | Just mem_val ->
            PEarray $ List.map (function
              | (Right sym' as x) ->
                  if sym = sym' then Left mem_val else x
              | x ->
                  x
            end) xs
        | Nothing ->
            (* TODO: this case is a Core type error *)
            Boot.assert_false "subst_sym_pexpr: the value should be memory storable"
      end
  | PEcall nm pes ->
      PEcall nm (List.map (subst_sym_pexpr sym v) pes)
  | PElet sym' pe1 pe2 ->
      PElet sym' (subst_sym_pexpr sym v pe1) (if sym = sym' then pe2 else subst_sym_pexpr sym v pe2)
  | PEif pe1 pe2 pe3 ->
      PEif (subst_sym_pexpr sym v pe1) (subst_sym_pexpr sym v pe2) (subst_sym_pexpr sym v pe3)
  | PEis_scalar pe ->
      PEis_scalar (subst_sym_pexpr sym v pe)
  | PEis_integer pe ->
      PEis_integer (subst_sym_pexpr sym v pe)
  | PEis_signed pe ->
      PEis_signed (subst_sym_pexpr sym v pe)
  | PEis_unsigned pe ->
      PEis_unsigned (subst_sym_pexpr sym v pe)
end


val     subst_sym: forall 'a. sym -> value -> expr 'a -> expr 'a
let rec subst_sym sym v = function
  | Epure pe ->
      Epure (subst_sym_pexpr sym v pe)
  | (Eundef _ as expr) ->
      expr
  | (Eerror _ as expr) ->
      expr
  | (Eraise _ as expr) ->
      expr
  | (Eregister _ _ as expr) ->
      expr
  | (Eskip as expr) ->
      expr
  | Elet sym' pe1 e2 ->
      Elet sym (subst_sym_pexpr sym v pe1) (if sym = sym' then e2 else subst_sym sym v e2)
  | Eif pe1 e2 e3 ->
      Eif (subst_sym_pexpr sym v pe1) (subst_sym sym v e2) (subst_sym sym v e3)
  | Eproc annot nm pes ->
      Eproc annot nm (List.map (subst_sym_pexpr sym v) pes)
  | Eaction pact ->
      Eaction (subst_sym_paction sym v pact)
  | Eunseq es ->
      Eunseq (List.map (subst_sym sym v) es)
  | Ewseq _as e1 e2 ->
      Ewseq _as (subst_sym sym v e1) (if in_pattern sym _as then e2 else subst_sym sym v e2)
  | Esseq _as e1 e2 ->
      Esseq _as (subst_sym sym v e1) (if in_pattern sym _as then e2 else subst_sym sym v e2)
  | Easeq sym_opt act1 pact2 ->
      Easeq sym_opt (subst_sym_action sym v act1) (if Just sym = sym_opt then pact2 else subst_sym_paction sym v pact2)
  | Eindet e ->
      Eindet (subst_sym sym v e)
  | Ebound k e ->
      Ebound k (subst_sym sym v e)
  | Esave ksym sym_tys e ->
      Esave ksym sym_tys (subst_sym sym v e)
  | Erun annot ksym sym_pes ->
      Erun annot ksym (list_update sym (PEval v) sym_pes)
  | Eret pe ->
      Eret (subst_sym_pexpr sym v pe)
  | End es ->
      End (List.map (subst_sym sym v) es)
  | Epar es ->
      Epar (List.map (subst_sym sym v) es)
  | (Ewait _ as expr) ->
      expr
end



and subst_sym_action_ a v = function
  | Create pe1 pe2 pref ->
      Create (subst_sym_pexpr a v pe1) (subst_sym_pexpr a v pe2) pref
  | Alloc pe1 pe2 pref ->
      Alloc (subst_sym_pexpr a v pe1) (subst_sym_pexpr a v pe2) pref
  | Kill pe ->
      Kill (subst_sym_pexpr a v pe)
  | Store pe1 pe2 pe3 mo ->
      Store (subst_sym_pexpr a v pe1) (subst_sym_pexpr a v pe2) (subst_sym_pexpr a v pe3) mo
  | Load pe1 pe2 mo ->
      Load (subst_sym_pexpr a v pe1) (subst_sym_pexpr a v pe2) mo
  | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      CompareExchangeStrong (subst_sym_pexpr a v pe1) (subst_sym_pexpr a v pe2) (subst_sym_pexpr a v pe3) (subst_sym_pexpr a v pe4) mo1 mo2
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (subst_sym_pexpr a v pe1) (subst_sym_pexpr a v pe2) (subst_sym_pexpr a v pe3) (subst_sym_pexpr a v pe4) mo1 mo2
  | Ptr ptr_act pes ->
      Ptr ptr_act (List.map (subst_sym_pexpr a v) pes)
  end
and subst_sym_action a v (Action bs act_) =
  Action bs (subst_sym_action_ a v act_)
and subst_sym_paction a v (Paction p act) =
  Paction p (subst_sym_action  a v act)



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val subst_syms: forall 'a. list (maybe sym) -> value -> expr 'a -> expr 'a
let subst_syms _as v expr =
  match (_as, v) with
    | ([], _) ->
        expr
    | ([Nothing], _) ->
        expr
    | ([Just sym], _) ->
        subst_sym sym v expr
    | (_, Vtuple vs) ->
        Global.foldl2 (fun acc _a_opt v ->
          match _a_opt with
            | Just sym ->
                subst_sym sym v acc
            | Nothing ->
                acc
          end) expr _as vs
    | _ ->
        Boot.assert_false "[Core_aux.subst_syms] impossible case"
  end



val subst_wait: forall 'a. thread_id -> value -> expr 'a -> expr 'a
let rec subst_wait tid v = function
  | (Epure _ as expr) ->
      expr
  | (Eundef _ as expr) ->
      expr
  | (Eerror _ as expr) ->
      expr
  | (Eraise _ as expr) ->
      expr
  | (Eregister _ _ as expr) ->
      expr
  | (Eskip as expr) ->
      expr
  | Elet sym pe1 e2 ->
      Elet sym pe1 (subst_wait tid v e2)
   | Eif pe1 e2 e3 ->
       Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
  | (Eproc _ _ _ as expr) ->
      expr
  | (Eaction _ as expr) ->
      expr
  | Eunseq es ->
      Eunseq (List.map (subst_wait tid v) es)
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | (Easeq _ _ _ as expr) ->
       expr
   | Eindet e ->
       Eindet (subst_wait tid v e)
   | Ebound k e ->
       Ebound k (subst_wait tid v e)
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
   | (Eret _ as expr) ->
       expr
   | End es ->
       End (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         Epure (PEval v)
       else
         Ewait tid'
end



let subst_wait_continuation_element tid v = function
  | Kunseq es1 es2 ->
      Kunseq (List.map (subst_wait tid v) es1) (List.map (subst_wait tid v) es2)
  | Kwseq syms_opt e2 ->
      Kwseq syms_opt (subst_wait tid v e2)
  | Ksseq syms_opt e2 ->
      Ksseq syms_opt (subst_wait tid v e2)
(*
  | Ktry str_es ->
      Ktry (List.map (fun (str, e) -> (str, subst_wait tid v e)) str_es)
*)
end

let subst_wait_continuation tid v cont =
  List.map (subst_wait_continuation_element tid v) cont

let rec subst_wait_stack tid v = function
  | Stack_empty ->
      Stack_empty
  | Stack_cons cont sk ->
      Stack_cons (subst_wait_continuation tid v cont) (subst_wait_stack tid v sk)
end



let rec find_labeled_continuation ksym = function
  | Epure _ ->
      Nothing
  | Eundef _ ->
      Nothing
  | Eerror _ ->
      Nothing
  | Eraise _ ->
      Nothing
  | Eregister _ _ ->
      Nothing
  | Eskip ->
      Nothing
  | Elet _ _ e2 ->
      find_labeled_continuation ksym e2
  | Eif _ e2 e3 ->
      match find_labeled_continuation ksym e2 with
        | Just cont ->
            Just cont
        | Nothing ->
            find_labeled_continuation ksym e3
      end
  | Eproc _ _ _ ->
      Nothing
  | Eaction _ ->
      Nothing
  | Eunseq _ ->
      Nothing
  | Ewseq _as e1 e2 ->
      match find_labeled_continuation ksym e1 with
        | Just (sym_tys, cont_e) ->
            Just (sym_tys, Ewseq _as cont_e e2)
        | Nothing ->
            find_labeled_continuation ksym e2
      end
  | Esseq _as e1 e2 ->
      match find_labeled_continuation ksym e1 with
        | Just (sym_tys, cont_e) ->
            Just (sym_tys, Esseq _as cont_e e2)
        | Nothing ->
            find_labeled_continuation ksym e2
      end
  | Easeq _ _ _ ->
      Boot.assert_false "Core_aux.find_labeled_continuation: Easeq shouldn't exists at this point"
  | Eindet _ ->
      Boot.assert_false "Core_aux.find_labeled_continuation: Eindet shouldn't exists at this point"
  | Ebound _ _ ->
      Boot.assert_false "Core_aux.find_labeled_continuation: Ebound shouldn't exists at this point"
  | Esave ksym' sym_tys e ->
      if ksym = ksym' then
        Just (sym_tys, e)
      else
        find_labeled_continuation ksym e
  | Erun _ _ _ ->
      Nothing
  | Eret _ ->
      Nothing
  | End _ ->
      Nothing
  | Epar _ ->
      Boot.assert_false "Core_aux.find_labeled_continuation:  think about this Ctor (Epar)"
  | Ewait _ ->
      Nothing
  end



val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont expr =
    match _cont with
      | Kwseq _as e2 ->
          Ewseq _as expr e2
      | Ksseq _as e2 ->
          Esseq _as expr e2
      | Kunseq es1 es2 ->
          Eunseq $ es1 ++ (expr :: es2)
(*
      | Ktry str_es ->
          Etry expr str_es
*)
    end in
  foldl (fun acc x -> f x acc) expr cont


(* Functions on continuation and stacks *)
val empty_stack: forall 'a. stack 'a
let empty_stack =
  Stack_empty

val is_empty_stack: forall 'a. stack 'a -> bool
let is_empty_stack = function
  | Stack_empty ->
      true
  | _ ->
      false
end



val push_empty_continuation: forall 'a. stack 'a -> stack 'a
let push_empty_continuation sk =
  Stack_cons [] sk

val pop_stack: forall 'a. stack 'a -> Exception.t (continuation 'a * stack 'a) core_run_error
let pop_stack = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_stack")
  | Stack_cons cont sk ->
      Exception.return (cont, sk)
end

val pop_continuation_element: forall 'a. stack 'a -> Exception.t (continuation_element 'a * stack 'a) core_run_error
let pop_continuation_element = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "pop_continuation_element")
  | Stack_cons [] _ ->
      Exception.fail Reached_end_of_proc
  | Stack_cons (cont_elem :: cont) sk ->
      Exception.return (cont_elem, Stack_cons cont sk)
end


val push_continuation_element: forall 'a. continuation_element 'a -> stack 'a -> Exception.t (stack 'a) core_run_error
let push_continuation_element cont_elem = function
  | Stack_empty ->
      Exception.fail (Found_empty_stack "push_continuation_element")
  | Stack_cons cont sk ->
      Exception.return (Stack_cons (cont_elem :: cont) sk)
end



val append_to_current_continuation: forall 'a. continuation_element 'a -> stack 'a -> Exception.t (stack 'a) core_run_error
let append_to_current_continuation cont = function
  | Stack_empty ->
      (* A procedure need to currently be running to append *)
      Exception.fail (Found_empty_stack "append_to_current_continuation")
  | Stack_cons ccont sk ->
      Exception.return $ Stack_cons (cont :: ccont) sk
end


val subst_sym_fun_map: forall 'a. sym -> value -> fun_map 'a -> fun_map 'a
let subst_sym_fun_map sym v funs =
  Map.map (fun (cTy, params, e) ->
    (cTy, params, subst_sym sym v e)
  ) funs



val     collect_labeled_continuations: forall 'a. expr 'a -> map ksym (list (sym * Core_ctype.ctype) * expr 'a)
let rec collect_labeled_continuations expr =
  match expr with
    | Epure _ ->
        Map.empty
    | Eundef _ ->
        Map.empty
    | Eerror _ ->
        Map.empty
    | Eraise _ ->
        Map.empty
    | Eregister _ _ ->
        Map.empty
    | Eskip ->
        Map.empty
    | Elet _ _ e2 ->
        collect_labeled_continuations e2
    | Eif pe1 e2 e3 ->
        Map.(union) (collect_labeled_continuations e2) (collect_labeled_continuations e3)
    | Eproc _ _ _ ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Ewseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Ewseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Esseq _as e1 e2 ->
        Map.(union) (Map.map (fun (a_tys, e) -> (a_tys, Esseq _as e e2)) $ collect_labeled_continuations e1)
                    (collect_labeled_continuations e2)
    | Easeq _ _ _ ->
        Map.empty
    | Eindet _ ->
        Map.empty
    | Ebound _ _ ->
        Map.empty
    | Esave k a_tys e ->
        Map.insert k (a_tys, e) $ collect_labeled_continuations e
    | Erun _ _ _ ->
        Map.empty
    | Eret _ ->
        Map.empty
    | End _ ->
        (* TODO: check *)
        Map.empty
    | Epar _ ->
        (* TODO: check *)
        Map.empty
    | Ewait _ ->
        Map.empty
  end



val is_unseq_with_negative: forall 'a. expr 'a -> bool
let is_unseq_with_negative expr =
  match expr with
    | Eunseq es ->
        List.any is_negative es
    | _ ->
        false
  end


val     has_sseqs: forall 'a. expr 'a -> bool
let rec has_sseqs expr =
  match expr with
    | Epure _ ->
        false
    | Eundef _ ->
        false
    | Eerror _ ->
        false
    | Eraise _ ->
        false
    | Eregister _ _ ->
        false
    | Eskip ->
        false
    | Elet _ _ e2 ->
        has_sseqs e2
    | Eif _ e2 e3 ->
        has_sseqs e2 || has_sseqs e3
    | Eproc _ _ _ ->
        (* TODO *)
        false
    | Eaction p ->
        false
    | Eunseq es ->
        List.any has_sseqs es
    | Ewseq _ e1 e2 ->
        has_sseqs e1 || has_sseqs e2
    | Esseq _ _ _ ->
        true
    | Easeq _ _ _  ->
        Boot.assert_false "has_sseqs found an Easeq"
    | Eindet e ->
        has_sseqs e
    | Ebound _ e ->
        has_sseqs e
    | Esave _ _ e ->
        has_sseqs e
    | Erun _ _ _ ->
        false
    | Eret _ ->
        false
    | End es ->
        List.any has_sseqs es
    | Epar _ ->
        (* TODO: I think *)
        false
    | Ewait _ ->
        false
  end


(* val rewind_upto_sseq: forall 'a. stack 'a -> expr 'a -> (expr 'a * stack 'a) *)


val is_concrete: value -> bool
let is_concrete = function
  | Vinteger symb ->
      Symbolic.is_concrete_symbolic symb
  | _ ->
      true
end

(* assumes a value expression *)
val     symbolify_mem_value: Mem.mem_value -> Symbolic.symbolic
let rec symbolify_mem_value mem_val =
  match mem_val with
    | Mem.MVpointer ptr_val ->
        Boot.assert_false "TODO: Core_aux.symbolify_mem_value: MVpointer"
(*
        Symbolic.SYMBptr ptr_val
*)
    | Mem.MVinteger symb ->
        symb
    | Mem.MVarray mem_vals ->
        Boot.assert_false "TODO: Core_aux.symbolify_mem_value: MVarray"
(*
        Symbolic.SYMBarray (List.map symbolic_mem_value mem_vals)
*)
  end

val symbolify: value -> Symbolic.symbolic
let symbolify expr =
  match expr with
    | Vunit ->
        Boot.assert_false "TODO: Core_aux.symbolify: Vunit"
(*
        Symbolic.SYMBunit
*)
    | Vtrue ->
        Symbolic.SYMBtrue
    | Vfalse ->
        Symbolic.SYMBfalse
(*
TODO
    | Econst mem_val ->
       symbolify_mem_value mem_val
*)
    | Vlist pes ->
        Boot.assert_false "TODO: Core_aux.symbolify: Elist"
    | Vctype ty ->
        Symbolic.SYMBctype ty
    | Vtuple vs ->
        Boot.assert_false "TODO: Core_aux.symbolify: Etuple"
  end

val     unsymbolify: Symbolic.symbolic -> pexpr
let rec unsymbolify symb =
  let convert_operator = function
    | Symbolic.Add ->
        OpAdd
    | Symbolic.Sub ->
        OpSub
    | Symbolic.Mul ->
        OpMul
    | Symbolic.Div ->
        OpDiv
    | Symbolic.Mod ->
        OpMod
    | Symbolic.Exp ->
        OpExp
    | Symbolic.Eq ->
        OpEq
    | Symbolic.Lt ->
        OpLt
    | Symbolic.And ->
        OpAnd
    | Symbolic.Or ->
        OpOr
  end in
  let convert_name = function
    | Symbolic.SYMBfsym sym ->
        Sym sym
    | Symbolic.SYMBimpl i ->
        Impl i
  end in
  match symb with
    | Symbolic.SYMBtrue ->
        PEval Vtrue
    | Symbolic.SYMBfalse ->
        PEval Vfalse
    | Symbolic.SYMBconst _ ->
        PEval (Vinteger symb)
    | Symbolic.SYMBctype ty ->
        PEval (Vctype ty)
    | Symbolic.SYMBsym _ sym ->
        PEsym sym
    | Symbolic.SYMBop Symbolic.Neq symb1 symb2 ->
        PEnot (PEop OpEq (unsymbolify symb1) (unsymbolify symb2))
    | Symbolic.SYMBop symb_op symb1 symb2 ->
        PEop (convert_operator symb_op) (unsymbolify symb1) (unsymbolify symb2)
    | Symbolic.SYMBite symb1 symb2 symb3 ->
        PEif (unsymbolify symb1) (unsymbolify symb2) (unsymbolify symb3)
    | Symbolic.SYMBcall symb_nm symbs ->
        PEcall (convert_name symb_nm) (List.map unsymbolify symbs)
  end
