open Global
open Core

(* Some aliases for positive actions *)
let pcreate ty pref  = Eaction (Pos, ({}, Create ty pref ))
let palloc e pref    = Eaction (Pos, ({}, Alloc e pref   ))
let pkill x          = Eaction (Pos, ({}, Kill x         ))
let pstore ty x n mo = Eaction (Pos, ({}, Store ty x n mo))
let pload ty x mo    = Eaction (Pos, ({}, Load ty x mo   ))


let zero : expr zero = Econst (Cint (Int.int 0))
let one  : expr zero = Econst (Cint (Int.int 1))


(* Project an AilTypes.ctype into a Core.ctype *)
val     proj_ctype: AilTypes.ctype -> Core.ctype
let rec proj_ctype ty =
  match ty with
    | AilTypes.Void           -> Void
    | AilTypes.Basic bt       -> Basic bt
    | AilTypes.Array ty n     -> Array (proj_ctype ty) n
    | AilTypes.Function ty ps -> Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps)
    | AilTypes.Pointer qs ty  -> Pointer (proj_ctype ty)
end

(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  match ty with
    | Void            -> AilTypes.Void
    | Basic bt        -> AilTypes.Basic bt
    | Array ty n      -> AilTypes.Array (unproj_ctype ty) n
    | Function ty tys -> AilTypes.Function (unproj_ctype ty) (List.map (Product.make AilTypes.no_qualifiers -| unproj_ctype) tys)
    | Pointer ty      -> AilTypes.Pointer AilTypes.no_qualifiers (unproj_ctype ty)
end

val mk_ctype: forall 'a. AilTypes.ctype -> expr 'a
let mk_ctype ty = Ectype (proj_ctype ty)

let rec mk_wseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Ewseq a_opts e (mk_wseq es')
end

let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end



let rec concat_sseq e e' =
   match e with
     | Esseq _as e1 e2 -> Esseq _as e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq [] e e'
  end

let is_negative = function
  | Eaction (Neg, _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Neg, _) -> true
  | _ -> false
end


let rec free_syms e =
  match e with
  | Etuple es ->
      List.fold_left (fun acc e -> free_syms e union acc) {} es
  | Enull ->
      {}
  | Eskip ->
      {}
  | Econst _ ->
      {}
  | Eaddr _ ->
      {}
  | Esym a ->
      {a}
  | Eop _ e1 e2 ->
      free_syms e1 union free_syms e2
  | Etrue ->
      {}
  | Efalse ->
      {}
  | Enot e ->
      free_syms e
  | Ectype _ ->
      {}
  | Elet a e1 e2 ->
      free_syms e1 union (free_syms e2 \ {a})
  | Eif e1 e2 e3 ->
      free_syms e1 union free_syms e2 union free_syms e3
  | Eproc _ _ es ->
      List.fold_left (fun acc e -> free_syms e union acc) {} es
  | Ecall _ es ->
      List.fold_left (fun acc e -> free_syms e union acc) {} es
  | Esame e1 e2 ->
      free_syms e1 union free_syms e2
  | Eundef _ ->
      {}
  | Eerror ->
      {}
  | Eaction (_, act) ->
      free_syms_action act
  | Eunseq es ->
      List.fold_left (fun acc e -> free_syms e union acc) {} es
  | Ewseq _as e1 e2 ->
      free_syms e1 union (free_syms e2 \ (set_from_options _as))
  | Esseq _as e1 e2 ->
      free_syms e1 union (free_syms e2 \ (set_from_options _as))
  | Easeq a_opt act1 (_, act2) ->
      free_syms_action act1 union (free_syms_action act2 \ (match a_opt with Some a -> {a} | None -> {} end))
  | Esave _ _ e ->
      free_syms e
  | Erun _ _ _ ->
      {}
  | Eret e ->
      free_syms e
  | Epar es ->
      List.fold_left (fun acc e -> free_syms e union acc) {} es
  | End es ->
      List.fold_left (fun acc e -> free_syms e union acc) {} es
  | Eindet e ->
      free_syms e
  | Ebound _ e ->
      free_syms e
  | Eshift a e ->
      free_syms e

(* TODO: temporary *)
  | Eis_scalar e ->
      free_syms e
  | Eis_integer e ->
      free_syms e
  | Eis_signed e ->
      free_syms e
  | Eis_unsigned e ->
      free_syms e
end

and free_syms_action (_, act_) =
  match act_ with
    | Create ty _ ->
        free_syms ty
    | Alloc n _ ->
        free_syms n
    | Kill o ->
        free_syms o
    | Store ty o n _ ->
        free_syms ty union free_syms o union free_syms n
    | Load ty o _ ->
        free_syms ty union free_syms o
end


(* check if a symbolic names is part of a pattern *)
val in_pattern: sym -> list (option sym) -> bool
let rec in_pattern a p =
  match p with
    | []             -> false
    | Nothing  :: xs -> in_pattern a xs
    | Some a'  :: xs -> if a = a' then true else in_pattern a xs
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym: forall 'a. sym -> expr 'a -> expr 'a -> expr 'a
let rec subst_sym a v e =
  match e with
    | Etuple es ->
        Etuple $ List.map (subst_sym a v) es
    | Enull ->
        Enull
    | Eskip ->
        Eskip
    | Econst n ->
        Econst n
    | Eaddr o ->
        Eaddr o
    | Esym a' ->
        if a = a' then v else e
    | Eop binop e1 e2 ->
        Eop binop (subst_sym a v e1) (subst_sym a v e2)
    | Etrue ->
        Etrue
    | Efalse ->
      Efalse
    | Enot e ->
        Enot (subst_sym a v e)
    | Ectype ty ->
        Ectype ty
    | Elet _a e1 e2 ->
        Elet _a (subst_sym a v e1) (if a = _a then e2 else subst_sym a v e2)
    | Eif e1 e2 e3 ->
        Eif (subst_sym a v e1) (subst_sym a v e2) (subst_sym a v e3)
    | Eproc bs f args ->
        Eproc bs f (List.map (subst_sym a v) args)
    | Ecall f args ->
        Ecall f (List.map (subst_sym a v) args)
    | Esame e1 e2 ->
        Esame (subst_sym a v e1) (subst_sym a v e2)
    | Eundef u ->
        Eundef u
    | Eerror ->
        Eerror
    | Eaction p ->
        Eaction (subst_sym_paction a v p)
    | Eunseq es ->
        Eunseq (List.map (subst_sym a v) es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Esseq _as e1 e2 ->
        Esseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Easeq _a act p  ->
        Easeq _a (subst_sym_action a v act) (if Some a = _a then p else subst_sym_paction a v p)
    | Eindet (* i *) e -> (* Eindet (* i *) (subst_sym a v e) *)
        Boot.assert_false "[Core_aux.subst_sym] #Eindet"
    | Ebound i e -> (* Ebound i (subst_sym a v e) *)
        Boot.assert_false "[Core_aux.subst_sym] #Ebound"
    | Erun bs k a_vs ->
        Erun bs k (* ((a,v) :: a_vs) *) $ list_update a v a_vs
    | Esave k a_tys e ->
        Esave k a_tys (subst_sym a v e)
    | Eret e ->
        Eret (subst_sym a v e)
    | Epar es ->
        Epar $ List.map (subst_sym a v) es
    | End es ->
        End $ List.map (subst_sym a v) es
    | Eshift a' e ->
        Eshift a' (subst_sym a v e)

(* TODO: temporary *)
  | Eis_scalar e ->
      Eis_scalar (subst_sym a v e)
  | Eis_integer e ->
      Eis_integer (subst_sym a v e)
  | Eis_signed e ->
      Eis_signed (subst_sym a v e)
  | Eis_unsigned e ->
      Eis_unsigned (subst_sym a v e)
  end

and subst_sym_action_ a v act =
  match act with
    | Create e_ty pref      -> Create (subst_sym a v e_ty) pref
    | Alloc e_n   pref      -> Alloc (subst_sym a v e_n) pref
    | Kill e_o              -> Kill (subst_sym a v e_o)
    | Store e_ty e_o e_v mo -> Store (subst_sym a v e_ty) (subst_sym a v e_o) (subst_sym a v e_v) mo
    | Load e_ty e_o mo      -> Load (subst_sym a v e_ty) (subst_sym a v e_o) mo
    | CompareExchangeStrong e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeStrong (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
    | CompareExchangeWeak e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeWeak (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
  end
and subst_sym_action a  v (bs, act) = (bs, subst_sym_action_ a v act)
and subst_sym_paction a v (p,  act) = (p,  subst_sym_action  a v act)



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val subst_syms: forall 'a. list (option sym) -> expr 'a -> expr 'a -> expr 'a
let subst_syms _as v e =
  match (_as, v) with
    | ([]       , _        ) -> e
    | ([None], _           ) -> e
    | ([Some _a], _        ) -> subst_sym _a v e

    | (_        , Etuple vs) -> List.fold_left2 (fun acc _a_opt v -> match _a_opt with Some _a -> subst_sym _a v acc | None -> acc end) e _as vs
  end 

(* Asuming well typed expressions *)
let rec is_pure e =
  match e with
   | Enull ->
       true
   | Etrue ->
       true
   | Efalse ->
       true
   | Econst _ ->
       true
   | Ectype _ ->
       true
   | Eaddr _ ->
       true
   | Esym _ ->
       true
   | Eimpl _ ->
       true
   | Etuple _ ->
       true
   | Enot _ ->
       true
   | Eop _ _ _ ->
       true
   | Ecall _ _ ->
       true
   | Eundef _ ->
       true
   | Eerror ->
       true
   | Eskip ->
       false
   | Elet _ _ e2 ->
       is_pure e2
   | Eif _ e2 e3 ->
       is_pure e2 && is_pure e3
   | Eproc _ _ _ ->
       false
   | Esame _ _ ->
       false
   | Eaction _ ->
       false
   | Eunseq es ->
       List.for_all is_pure es
   | Epar es ->
       false (* List.for_all is_pure es *)
   | Ewseq _ e1 e2 ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Esseq _ e1 e2 ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Easeq _ _ _ ->
       false
   | Eindet _ ->
       false
   | Ebound _ _ ->
       false
   | Esave _ _ _ ->
       false
   | Erun _ _ _ ->
       false
   | Eret _ ->
       false
   | End es ->
       false
   | Eshift a e ->
       false

(* TODO: temporary *)
  | Eis_scalar _ ->
      true
  | Eis_integer _ ->
      true
  | Eis_signed _ ->
      true
  | Eis_unsigned _ ->
      true
end


let rec is_value e =
  match e with
   | Etuple pes ->
       List.for_all is_value pes
   | Enull ->
       true
   | Econst _ ->
       true
   | Eaddr _ ->
       true
   | Etrue ->
       true
   | Efalse ->
       true
   | Ectype _ ->
       true
(*
   | Eundef _ ->
       true
   | Eerror ->
       true
*)
   
   | _ -> false
end



val is_atomic_type: ctype -> bool
let is_atomic_type t = 
  match t with
    | Atomic _ -> true
    | _         -> false
  end







