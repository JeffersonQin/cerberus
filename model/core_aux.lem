open import Pervasives Global Core
import Boot Product Symbolic Exception Naive_memory

open import Thread Core_run2_aux

module Mem = Naive_memory


val sizeof: forall 'a. expr 'a -> expr 'a
let sizeof e = Ecall (Impl Implementation_.Sizeof) [e]

val alignof: forall 'a. expr 'a -> expr 'a
let alignof e = Ecall (Impl Implementation_.Alignof) [e]

val ctype_min: forall 'a. expr 'a -> expr 'a
let ctype_min e = Ecall (Impl Implementation_.Ctype_min) [e]

val ctype_max: forall 'a. expr 'a -> expr 'a
let ctype_max e = Ecall (Impl Implementation_.Ctype_max) [e]

val bitwise_complement: forall 'a. expr 'a -> expr 'a
let bitwise_complement e = Ecall (Impl Implementation_.Bitwise_complement) [e]

val integer_encode: forall 'a. expr 'a -> expr 'a -> expr 'a
let integer_encode e1 e2 =
  Ecall (Impl Implementation_.Integer__encode) [e1; e2]

val integer_decode: forall 'a. expr 'a -> expr 'a -> expr 'a
let integer_decode e1 e2 =
  Ecall (Impl Implementation_.Integer__decode) [e1; e2]




(* Some aliases for positive actions *)
let pcreate al ty pref = Eaction (Paction Pos (Action default (Create al ty pref )))
let palloc al e pref   = Eaction (Paction Pos (Action default (Alloc al e pref   )))
let pkill x            = Eaction (Paction Pos (Action default (Kill x         )))
let pstore ty x n mo   = Eaction (Paction Pos (Action default (Store ty x n mo)))
let pload ty x mo      = Eaction (Paction Pos (Action default (Load ty x mo   )))


(* NOTE: without the type annotations, the generated ocaml doesn't typecheck *)
val zero: forall 'a. expr 'a
let zero =
  Econst (Mem.MV_integer (Symbolic.constant 0))
val one: forall 'a. expr 'a
let one =
  Econst (Mem.MV_integer (Symbolic.constant 1))
declare {coq} rename function zero = zero_ (* workaround for Lem issue #87 *)

val integer_const: forall 'a. integer -> expr 'a
let integer_const n =
  Econst (Mem.MV_integer (Symbolic.constant n))

val cfunction_const: forall 'a. Symbol.t -> expr 'a
let cfunction_const fsym =
  Econst (Mem.MV_pointer (Mem.function_pointer fsym))




let rec mk_wseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Ewseq a_opts e (mk_wseq es')
end

let mk_unseq = function
  | []  -> Eskip
  | [e] -> e
  | es  -> Eunseq es
end



let rec concat_sseq e e' =
   match e with
     | Esseq _as e1 e2 -> Esseq _as e1 (concat_sseq e2 e')
     | Eskip           -> e'
     | _               -> Esseq [] e e'
  end

let is_negative = function
  | Eaction (Paction Neg _) -> true
  | _ -> false
end

let is_negative_action = function
  | (Paction Neg _) -> true
  | _ -> false
end


(* check if a symbolic names is part of a pattern *)
val in_pattern: sym -> list (maybe sym) -> bool
let rec in_pattern a p =
  match p with
    | []             -> false
    | Nothing  :: xs -> in_pattern a xs
    | Just a'  :: xs -> if a = a' then true else in_pattern a xs
  end

(* substitute in an expression a symbolic name with a (pure) expression *)
val     subst_sym: forall 'a. sym -> expr 'a -> expr 'a -> expr 'a
let rec subst_sym a v e =
  match e with
    | Eunit ->
        Eunit
    | Etrue ->
        Etrue
    | Efalse ->
        Efalse
    | Econst n ->
        Econst n
    | Elist es ->
        Elist $ List.map (subst_sym a v) es
    | Ectype ty ->
        Ectype ty
    | Esym a' ->
        if a = a' then v else e
    | Eimpl i ->
        Eimpl i
    | Etuple es ->
        Etuple $ List.map (subst_sym a v) es
    | Enot e ->
        Enot (subst_sym a v e)
    | Eop binop e1 e2 ->
        Eop binop (subst_sym a v e1) (subst_sym a v e2)
    | Ecall f args ->
        Ecall f (List.map (subst_sym a v) args)
    | Eoutput str ->
        Eoutput str
    | Eundef u ->
        Eundef u
    | Eerror ->
        Eerror
    | Eskip ->
        Eskip
    | Elet _a e1 e2 ->
        Elet _a (subst_sym a v e1) (if a = _a then e2 else subst_sym a v e2)
    | Eif e1 e2 e3 ->
        Eif (subst_sym a v e1) (subst_sym a v e2) (subst_sym a v e3)
    | Eproc bs f args ->
        Eproc bs f (List.map (subst_sym a v) args)
    | Eaction p ->
        Eaction (subst_sym_paction a v p)
    | Eunseq es ->
        Eunseq (List.map (subst_sym a v) es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Esseq _as e1 e2 ->
        Esseq _as (subst_sym a v e1) (if in_pattern a _as then e2 else subst_sym a v e2)
    | Easeq _a act p  ->
        Easeq _a (subst_sym_action a v act) (if Just a = _a then p else subst_sym_paction a v p)
    | Eindet (* i *) _ -> (* Eindet (* i *) (subst_sym a v e) *)
        Boot.assert_false "[Core_aux.subst_sym] #Eindet"
    | Ebound _ _ -> (* Ebound i (subst_sym a v e) *)
        Boot.assert_false "[Core_aux.subst_sym] #Ebound"
    | Esave k a_tys e ->
        Esave k a_tys (subst_sym a v e)
    | Erun bs k a_vs ->
        Erun bs k (* ((a,v) :: a_vs) *) $ list_update a v a_vs
    | Eret e ->
        Eret (subst_sym a v e)
    | End es ->
        End $ List.map (subst_sym a v) es
    | Epar es ->
        Epar $ List.map (subst_sym a v) es
    | Ewait tids ->
        Ewait tids

  | Eis_scalar e ->
      Eis_scalar (subst_sym a v e)
  | Eis_integer e ->
      Eis_integer (subst_sym a v e)
  | Eis_signed e ->
      Eis_signed (subst_sym a v e)
  | Eis_unsigned e ->
      Eis_unsigned (subst_sym a v e)
  end

and subst_sym_action_ a v act =
  match act with
    | Create al e_ty pref   -> Create (subst_sym a v al) (subst_sym a v e_ty) pref
    | Alloc al e_n pref     -> Alloc (subst_sym a v al) (subst_sym a v e_n) pref
    | Kill e_o              -> Kill (subst_sym a v e_o)
    | Store e_ty e_o e_v mo -> Store (subst_sym a v e_ty) (subst_sym a v e_o) (subst_sym a v e_v) mo
    | Load e_ty e_o mo      -> Load (subst_sym a v e_ty) (subst_sym a v e_o) mo
    | CompareExchangeStrong e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeStrong (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
    | CompareExchangeWeak e_ty e_obj e_expected e_desired mo1 mo2 ->
        CompareExchangeWeak (subst_sym a v e_ty) (subst_sym a v e_obj) (subst_sym a v e_expected) (subst_sym a v e_desired) mo1 mo2
  end
and subst_sym_action a v act =
  match act with
    | Action bs act_ -> Action bs (subst_sym_action_ a v act_)
  end
and subst_sym_paction a v pa =
  match pa with
    | Paction p act -> Paction p (subst_sym_action  a v act)
  end



(* TODO: [subst_syms _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
val subst_syms: forall 'a. list (maybe sym) -> expr 'a -> expr 'a -> expr 'a
let subst_syms _as v e =
  match (_as, v) with
    | ([]       , _        ) -> e
    | ([Nothing], _        ) -> e
    | ([Just _a], _        ) -> subst_sym _a v e

    | (_        , Etuple vs) -> Global.foldl2 (fun acc _a_opt v -> match _a_opt with Just _a -> subst_sym _a v acc | Nothing -> acc end) e _as vs


    | _ -> Boot.assert_false "[Core_aux.subst_syms] impossible case"
  end 





val subst_wait: forall 'a. thread_id -> expr 'a -> expr 'a -> expr 'a
let rec subst_wait tid v = function
   | Eunit ->
       Eunit
   | Etrue ->
       Etrue
   | Efalse ->
       Efalse
   | Econst cst ->
       Econst cst
   | Elist pes ->
       Elist pes
   | Ectype ty ->
       Ectype ty
   | Esym sym ->
       Esym sym
   | Eimpl i ->
       Eimpl i
   | Etuple pes ->
       Etuple pes
   | Enot pe ->
       Enot pe
   | Eop bop pe1 pe2 ->
       Eop bop pe1 pe2
   | Ecall nm pes ->
       Ecall nm pes
   | Eoutput str ->
       Eoutput str
   | Eundef ub ->
       Eundef ub
   | Eerror ->
       Eerror
   | Eskip ->
       Eskip
   | Elet sym pe1 e2 ->
       Elet sym pe1 (subst_wait tid v e2)
   | Eif pe1 e2 e3 ->
       Eif pe1 (subst_wait tid v e2) (subst_wait tid v e3)
   | Eproc annots nm pes ->
       Eproc annots nm pes
   | Eaction pact ->
       Eaction pact
   | Eunseq es ->
       Eunseq (List.map (subst_wait tid v) es)
   | Epar es ->
       Epar (List.map (subst_wait tid v) es)
   | Ewait tid' ->
       if tid = tid' then
         v
       else
         Ewait tid'
   | Ewseq _as e1 e2 ->
       Ewseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Esseq _as e1 e2 ->
       Esseq _as (subst_wait tid v e1) (subst_wait tid v e2)
   | Easeq sym_opt act1 pact2 ->
       Easeq sym_opt act1 pact2
   | Eindet e ->
       Eindet (subst_wait tid v e)
   | Ebound j e ->
       Ebound j (subst_wait tid v e)
   | Esave k a_tys e ->
       Esave k a_tys (subst_wait tid v e)
   | Erun annots k a_vs ->
       Erun annots k a_vs
   | Eret pe ->
       Eret pe
   | End es ->
       End (List.map (subst_wait tid v) es)
  | Eis_scalar pe ->
      Eis_scalar pe
  | Eis_integer pe ->
      Eis_integer pe
  | Eis_signed pe ->
      Eis_signed pe
  | Eis_unsigned pe ->
      Eis_unsigned pe
end


let subst_wait_continuation_element tid v = function
  | Kunseq es1 es2 ->
      Kunseq (List.map (subst_wait tid v) es1) (List.map (subst_wait tid v) es2)
  | Kwseq syms_opt e2 ->
      Kwseq syms_opt (subst_wait tid v e2)
  | Ksseq syms_opt e2 ->
      Ksseq syms_opt (subst_wait tid v e2)
end

let subst_wait_continuation tid v cont =
  List.map (subst_wait_continuation_element tid v) cont

let rec subst_wait_stack tid v = function
  | Stack_empty ->
      Stack_empty
  | Stack_cons cont sk ->
      Stack_cons (subst_wait_continuation tid v cont) (subst_wait_stack tid v sk)
end


(* Asuming well typed expressions *)
let rec is_pure e =
  match e with
   | Eunit ->
       true
   | Etrue ->
       true
   | Efalse ->
       true
   | Econst _ ->
       true
   | Elist _ ->
       true
   | Ectype _ ->
       true
   | Esym _ ->
       true
   | Eimpl _ ->
       true
   | Etuple _ ->
       true
   | Enot _ ->
       true
   | Eop _ _ _ ->
       true
   | Ecall _ _ ->
       true
   | Eoutput _ ->
       false
   | Eundef _ ->
       true
   | Eerror ->
       true
   | Eskip ->
       false
   | Elet _ _ e2 ->
       is_pure e2
   | Eif _ e2 e3 ->
       is_pure e2 && is_pure e3
   | Eproc _ _ _ ->
       false
   | Eaction _ ->
       false
   | Eunseq _ ->
       false

   | Epar _ ->
       false (* all is_pure es *)
   | Ewait _ ->
       false
   | Ewseq _ _ _ ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Esseq _ _ _ ->
       false
       (* is_pure e1 && is_pure e2 *)
   | Easeq _ _ _ ->
       false
   | Eindet _ ->
       false
   | Ebound _ _ ->
       false
   | Esave _ _ _ ->
       false
   | Erun _ _ _ ->
       false
   | Eret _ ->
       false
   | End _ ->
       false

  | Eis_scalar _ ->
      true
  | Eis_integer _ ->
      true
  | Eis_signed _ ->
      true
  | Eis_unsigned _ ->
      true
end


let rec is_value e =
  match e with
    | Eunit ->
        true
    | Etrue ->
        true
    | Efalse ->
        true
    | Econst _ ->
        true
    | Elist pes ->
        all is_value pes
    | Ectype _ ->
        true
    | Esym  _ ->
        false
    | Eimpl _ ->
        false
    | Etuple pes ->
        all is_value pes
    | Enot _ ->
        false
    | Eop _ _ _ ->
        false
    | Ecall _ _ ->
        false
    | Eoutput _ ->
        false
    | Eundef _ ->
        false
    | Eerror ->
        false
    | Eskip ->
        false
    | Elet _ _ _ ->
        false
    | Eif _ _ _->
        false
    | Eproc _ _ _ ->
        false
    | Eaction _ ->
        false
    | Eunseq _ ->
        false
    | Ewseq _ _ _ ->
        false
    | Esseq _ _ _ ->
        false
    | Easeq _ _ _ ->
        false
    | Eindet _ ->
        false
    | Ebound _ _ ->
        false
    | Esave _ _ _->
        false
    | Erun _ _ _->
        false
    | Eret _ ->
        false
    | End _ ->
        false
    | Epar _ ->
        false
    | Ewait _ ->
        false
    | Eis_scalar _ ->
        false
    | Eis_integer _ ->
        false
    | Eis_signed _ ->
        false
    | Eis_unsigned _ ->
        false
end


let rec find_labeled_continuation k expr =
  match expr with
    | Eunit ->
        Nothing
    | Etrue ->
        Nothing
    | Efalse ->
        Nothing
    | Econst _ ->
        Nothing
    | Elist _ ->
        Nothing
    | Ectype _ ->
        Nothing
    | Esym _ ->
        Nothing
    | Eimpl _ ->
        Nothing
    | Etuple _ ->
        Nothing
    | Enot _ ->
        Nothing
    | Eop _ _ _ ->
        Nothing
    | Ecall _ _ ->
        Nothing
    | Eoutput _ ->
        Nothing
    | Eundef _ ->
        Nothing
    | Eerror ->
        Nothing
    | Eskip ->
        Nothing
    | Elet _ _ e2 ->
        find_labeled_continuation k e2
    | Eif _ e2 e3 ->
        match find_labeled_continuation k e2 with
          | Just cont ->
              Just cont
          | Nothing ->
              find_labeled_continuation k e3
        end
    | Eproc _ _ _ ->
        Nothing
    | Eaction _ ->
        Nothing
    | Eunseq _ ->
        Nothing
    | Ewseq _ _ e2 ->
        find_labeled_continuation k e2
    | Esseq _ _ e2 ->
        find_labeled_continuation k e2
    | Easeq _ _ _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Eindet _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Ebound _ _ ->
        Boot.assert_false "This ctor shouldn't exists at this point"
    | Esave k' a_tys e ->
        if k = k' then
          Just (a_tys, e)
        else
          find_labeled_continuation k e
    | Erun _ _ _ ->
        Nothing
    | Eret _ ->
        Nothing
    | End _ ->
        Nothing
    | Epar _ ->
        Boot.assert_false "TODO: think about this Ctor"
    | Ewait _ ->
        Nothing
    | Eis_scalar _ ->
        Nothing
    | Eis_integer _ ->
        Nothing
    | Eis_signed _ ->
        Nothing
    | Eis_unsigned _ ->
        Nothing
  end





val apply_continuation: forall 'a. continuation 'a -> expr 'a -> expr 'a
let apply_continuation cont expr =
  let f _cont expr =
    match _cont with
      | Kwseq _as e2 ->
          Ewseq _as expr e2
      | Ksseq _as e2 ->
          Esseq _as expr e2
      | Kunseq es1 es2 ->
          Eunseq $ es1 ++ (expr :: es2)
    end in
  foldl (fun acc x -> f x acc) expr cont


(* Functions on continuation and stacks *)
val empty_stack: forall 'a. stack 'a
let empty_stack =
  Stack_empty

val is_empty_stack: forall 'a. stack 'a -> bool
let is_empty_stack = function
  | Stack_empty ->
      true
  | _ ->
      false
end



val push_empty_continuation: forall 'a. stack 'a -> stack 'a
let push_empty_continuation sk =
  Stack_cons [] sk

val pop_stack: forall 'a. stack 'a -> Exception.t (continuation 'a * stack 'a) core_run_error
let pop_stack = function
  | Stack_empty ->
      Exception.fail Found_empty_stack
  | Stack_cons cont sk ->
      Exception.return (cont, sk)
end

val pop_continuation_element: forall 'a. stack 'a -> Exception.t (continuation_element 'a * stack 'a) core_run_error
let pop_continuation_element = function
  | Stack_empty ->
      Exception.fail Found_empty_stack
  | Stack_cons [] _ ->
      Exception.fail Reached_end_of_proc
  | Stack_cons (cont_elem :: cont) sk ->
      Exception.return (cont_elem, Stack_cons cont sk)
end


val push_continuation_element: forall 'a. continuation_element 'a -> stack 'a -> Exception.t (stack 'a) core_run_error
let push_continuation_element cont_elem = function
  | Stack_empty ->
      Exception.fail Found_empty_stack
  | Stack_cons cont sk ->
      Exception.return (Stack_cons (cont_elem :: cont) sk)
end



val append_to_current_continuation: forall 'a. continuation_element 'a -> stack 'a -> Exception.t (stack 'a) core_run_error
let append_to_current_continuation cont = function
  | Stack_empty ->
      (* A procedure need to currently be running to append *)
      Exception.fail Found_empty_stack
  | Stack_cons ccont sk ->
      Exception.return $ Stack_cons (cont :: ccont) sk
end
