open import Pervasives Global
import Set_extra Set_helpers Core_run
import Cmm_csem Cmm_aux

module Cmm = Cmm_csem

(* This file is commented out, becuase the state (Core_effect.state)
   does not contain the Cmm.relations anymore (sb, asw, rf, mo, sc,
   lo, hb). *)

(*

(* Temporary hack *)
type graph' = <|
  actions' : Map.map Core_run_effect.taction_id Core_run_effect.trace_action;
  sb'      : Map.map Core_run_effect.taction_id (list Core_run_effect.taction_id);
  asw'     : Map.map Core_run_effect.taction_id (list Core_run_effect.taction_id);
  rf'      : Map.map Core_run_effect.taction_id (list Core_run_effect.taction_id);
  mo'      : Map.map Core_run_effect.taction_id (list Core_run_effect.taction_id);
  sc'      : Map.map Core_run_effect.taction_id (list Core_run_effect.taction_id);
  hb'      : Map.map Core_run_effect.taction_id (list Core_run_effect.taction_id);
|>


type graph = <|
  actions : Map.map Core_run_effect.taction_id Core_run_effect.trace_action;
  sb      : list (Core_run_effect.taction_id * Core_run_effect.taction_id);
  asw     : list (Core_run_effect.taction_id * Core_run_effect.taction_id);
  rf      : list (Core_run_effect.taction_id * Core_run_effect.taction_id);
  mo      : list (Core_run_effect.taction_id * Core_run_effect.taction_id);
  sc      : list (Core_run_effect.taction_id * Core_run_effect.taction_id);
  hb      : list (Core_run_effect.taction_id * Core_run_effect.taction_id)
|>



(* NOTE: will crash on ill-formed traces *)
(* TODO: I don't like it *)
val extract: (Map.map Core_run_effect.taction_id Core_run_effect.trace_action * Core_run_effect.trace) -> graph'
let extract (tact_map, t) =
  let es =
    foldl (fun edges (r, bs_act) ->
    match bs_act with
      | Nothing ->
          edges
      | Just (bs, aid) ->
          (* add a n sb-edge from each action in bs to aid *)
          Set_helpers.fold (fun b edges ->
            Map.insert b
              match Map.lookup b edges with
                | Just z  -> {aid} union z
                | Nothing -> {}
              end
              edges
          ) bs edges
(*        Pmap.add aid (bs union (if Pmap.mem aid edges then Pmap.find aid edges else {})) edges *)
    end) Map.empty t
  in <| actions'= tact_map; sb'= Map.map Set_extra.toList es;
        asw'= Map.empty; rf'= Map.empty; mo'= Map.empty; sc'= Map.empty; hb'= Map.empty
      |>





(*

        (<| _sb with actions'= Pmap.add i a _sb.actions';
                     edges'=   List.fold_left (fun es b ->
                                 let ib = Pmap.find b is in
                                 Pmap.add ib (i :: (if Pmap.mem ib es then Pmap.find ib es else [])) es
                               ) _sb.edges' (Set.to_list bs)
          |>, i+1, Pmap.add a i is)
    end
  ) (Pmap.empty, 0, Pmap.empty) t
  in sb
*)

(*
  List.fold_left (fun (_sb, i, is) (r, bs_a) ->
    match bs_a with
      | Nothing              -> (_sb, i, is)
      | Just (bs, aid) ->
        let a = Pmap.find aid tact_map in
        (<| _sb with actions'= Pmap.add i a _sb.actions';
                     edges'=   List.fold_left (fun es b ->
                                 let ib = Pmap.find b is in
                                 Pmap.add ib (i :: (if Pmap.mem ib es then Pmap.find ib es else [])) es
                               ) _sb.edges' (Set.to_list bs)
          |>, i+1, Pmap.add a i is)
    end
  ) (<| actions'= Pmap.empty; edges'= Pmap.empty |>, 0, Pmap.empty) t
  in sb
*)








val extract2: Core_run_effect.state -> graph'
let extract2 st =
  let f rel =
    Set_helpers.fold (fun (x,y) acc ->
      Map.insert x (y ::
        match Map.lookup x acc with
          | Just z  -> z
          | Nothing -> []
        end)
        acc
    ) rel Map.empty in
  
  let g rel = Set_helpers.fold (fun (x_,y_) acc ->
    let x = Boot.nat_of_string $ Cmm.aid_of x_ in
    let y = Boot.nat_of_string $ Cmm.aid_of y_ in
    Map.insert x (y ::
        match Map.lookup x acc with
          | Just z  -> z
          | Nothing -> []
        end) acc
  ) rel Map.empty in
  <|
      actions'= st.Core_run_effect.tact_map;
      sb'=  f (st.Core_run_effect.sb);
      asw'= f (st.Core_run_effect.asw);
      rf'=  f (st.Core_run_effect.rf);
      mo'=  g (snd $ Core_run.to_observable_execution st).Cmm.mo;
      sc'=  g (snd $ Core_run.to_observable_execution st).Cmm.sc;
      hb'=  g (Core_run.to_happens_before $ Core_run.to_observable_execution st)
   |>

(*
type sb' = <|
  actions': Pmap.map Core_run.taction_id Core_run.trace_action;
  edges':   Pmap.map Core_run.taction_id (list Core_run.taction_id)
|>
*)


(*
  let es =
    List.fold_left (fun edges (r, bs_act) ->
    match bs_act with
      | Nothing ->
          edges
      | Just (bs, aid) ->
          (* add a n sb-edge from each action in bs to aid *)
          Set.fold (fun b edges -> Pmap.add b ({aid} union if Pmap.mem b edges then Pmap.find b edges else {}) edges) bs edges
(*        Pmap.add aid (bs union (if Pmap.mem aid edges then Pmap.find aid edges else {})) edges *)
    end) Pmap.empty t
  in <| actions'= tact_map; edges'= Pmap.map Set.to_list es |>
*)





(* TODO: this should be in the stdlib *)
val     assocs: forall 'a 'b. Eq 'a => 'a -> list ('a * 'b) -> list 'b
let rec assocs_ z l acc =
  match l with
    | []           -> acc
    | (x,y) :: xys -> if x = z then assocs_ x xys (y :: acc) else assocs_ z xys acc
  end
let assocs z l = assocs_ z l []

val     exists_path: forall 'a. Eq 'a => 'a -> 'a -> list ('a * 'a) -> bool
let rec exists_path_ a b es =
  any (fun b' ->
    b = b' || exists_path_ b' b es
  ) es
let exists_path a b es = exists_path_ a b (assocs a es)



(* remove the edges implied by transitivity *)
val simplify: graph' -> graph
let simplify g =
  let f rel = concat (map (fun (a, bs) -> map (fun b -> (a,b)) bs) $ Set_extra.toList (Map.toSet rel)) in
  let sb_  = f g.sb'  in
  let asw_ = f g.asw' in
  let rf_  = f g.rf'  in
  let mo_  = f g.mo'  in
  let sc_  = f g.sc'  in
  let hb_  = f g.hb'  in
  <| actions= g.actions';
     sb=  (* List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) sb_)) *)  try_to_transitive_reduce sb_;
     asw= (* List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) asw_)) *) try_to_transitive_reduce asw_;
     rf=  (* List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) rf_)) *)  try_to_transitive_reduce rf_;
     mo=  (* List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) mo_)) *)  try_to_transitive_reduce mo_;
     sc=  (* List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) sc_)) *)  try_to_transitive_reduce sc_;
     hb=  (* List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) hb_)) *)  try_to_transitive_reduce hb_
  |>

(*
  let edges' = List.concat (List.map (fun (a, bs) -> List.map (fun b -> (a,b)) bs) $ Pmap.bindings sb.edges') in
  <| actions= sb.actions'; edges= List.filter (fun (x,y) -> not $ exists_path x y (delete (=) (x,y) edges')) edges' |>
*)

*)