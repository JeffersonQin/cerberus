open import Pervasives
import Map


(* empty type *)
type zero


val     numerote_: forall 'a. nat -> list 'a -> list (nat * 'a)
let rec numerote_ n l =
  match l with
    | []    -> []
    | x::xs -> (n,x) :: numerote_ (n+1) xs
  end
let numerote l = numerote_ 1 l



let inline (-|) f g x = f (g x)
let inline (|-) g f x = f (g x)
(* TODO: ask change in lem to be able to have
         the traditional |> *)
let inline (>|>) x f = f x
let inline (>?>) x b f g = if b then f x else g x


(* TODO: move into Lem's libary *)
let rec nub' l acc =
  match l with
    | []    -> []
    | x::xs -> if List.elem x acc then nub' xs acc
                                  else x :: nub' xs (x::acc)
  end
let nub l = nub' l []


let rec or_list l =
  match l with
    | []    -> false
    | x::xs -> x || or_list xs
  end


(*
TODO
let list_diff eq = List.fold_left (fun x y -> delete eq y x)
*)


(* TODO: move into Lem's libary *)
val     zip3: forall 'a 'b 'c. list 'a -> list 'b -> list 'c -> list ('a * 'b * 'c)
let rec zip3 xs ys zs =
  match (xs, ys, zs) with
    | (x::xs', y::ys', z::zs') -> (x,y,z) :: zip3 xs' ys' zs'
    | _                        -> []
  end

(* TODO: move into Lem's libary *)
val     zip4: forall 'a 'b 'c 'd. list 'a -> list 'b -> list 'c -> list 'd -> list ('a * 'b * 'c * 'd)
let rec zip4 xs ys zs us =
  match (xs, ys, zs, us) with
    | (x::xs', y::ys', z::zs', u::us') -> (x,y,z,u) :: zip4 xs' ys' zs' us'
    | _                                -> []
  end

(* TODO: move into Lem's libary *)
val unzip3: forall 'a 'b 'c. list ('a * 'b * 'c) -> (list 'a * list 'b * list 'c)
let unzip3 xyzs = foldr (fun (x,y,z) (xs,ys,zs) -> (x :: xs, y :: ys, z :: zs)) ([],[],[]) xyzs



(* TODO: move into Lem's libary *)
val foldl2: forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> list 'b -> list 'c -> 'a
let rec foldl2 f z xs ys =
  match (xs, ys) with
    | ([],[]) ->
        z
    | (a::xs', b::ys') ->
        foldl2 f (f z a b) xs' ys'
  end


(* TODO: get rid of this for the Coq backend *)
val     map2: forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c
let rec map2_ f xs ys acc =
  match (xs, ys) with
    | (x::xs', y::ys') ->
        map2_ f xs' ys' (f x y :: acc)
    | ([],[]) ->
        acc
  end
let map2 f xs ys = map2_ f xs ys []

let fromJust = function
  | Just x -> x
(*  | Nothing   -> Boot.assert_false "[Global.fromJust] found a Nothing" *)
end




let rec filter_opt l = 
  match l with
    | [] -> []
    | (Just z) :: xs -> z :: filter_opt xs
    | Nothing  :: xs ->      filter_opt xs
  end

let rec set_from_options xs =
  match xs with
    | []            -> {}
    | Just x  :: xs' -> {x} union set_from_options xs'
    | Nothing :: xs' -> set_from_options xs'
end



(* TODO: user List.update instead *)
let rec list_update a v xs =
  match xs with
    | []         -> []
    | (x,xv)::xs' -> (if x = a then (a,v) :: xs' else (x,xv) :: list_update a v xs' )
  end


(* 'optimised' implementation of [\f -> unzip . map f] *)
val mapUnzip: forall 'a 'b 'c. ('a -> 'b * 'c) -> list 'a -> list 'b * list 'c
let rec mapUnzip_ f (xs, ys) = function
  | []      -> (xs, ys)
  | (l::ls) -> let (x,y) = f l in mapUnzip_ f (x::xs, y::ys) ls
end
let mapUnzip f l =
  let (xs, ys) = mapUnzip_ f ([],[]) l in
  (reverse xs, reverse ys)



(* BEGIN: stolen from cpp *)
val     map_option: forall 'a 'b. ('a -> maybe 'b) -> list 'a -> list 'b
let rec map_option f xs = 
  match xs with 
    | [] ->
        []
    | x::xs ->
        match f x with 
          | Nothing -> map_option f xs 
          | Just x  -> x :: (map_option f xs)
        end
  end

(* needs to be applied to a acyclic transitive relation *)
val transitive_reduction: forall 'a. Eq 'a => list ('a * 'a) -> maybe (list ('a * 'a))
let transitive_reduction r =
  let transitive_pairs =
    concat $
      List.map (fun (a1,a2) -> 
        map_option (fun (a1',a2') -> if a2 = a1' then Just (a1,a2') else Nothing) r
      ) r in
  (* a partial check for cycles *)
  if any (fun (a1,a2) -> a1=a2) (r ++ transitive_pairs) then 
    Nothing
  else Just $ List.filter (fun (a1,a2) -> not (elem (a1,a2) transitive_pairs)) r 

val is_transitive: forall 'a. Eq 'a => list ('a * 'a) -> bool
let is_transitive r =
  let two_step_edges =
    concat $
      List.map (fun (n,n') -> 
        map_option (fun (n'',n''') -> if n'=n'' then Just (n,n''') else Nothing) r
      ) r in
  all (fun (n,n''') -> elem (n,n''') r) two_step_edges


let try_to_transitive_reduce rel =
  if is_transitive rel then
    match transitive_reduction rel with
      | Just rel' -> rel'
      | Nothing   -> rel
    end
  else
    rel
(* END: stolen from cpp *)

(* this will blow up on cyclic relations *)
let step s rel =
  foldl (fun acc (a,b) ->
    if elem a s && not (elem b acc) then
      b :: acc
    else
      acc
  ) s rel

let rec accessible_ s rel =
  let s' = step s rel in
  if s = s' then
    s
  else
    accessible_ s' rel

let accessible a b rel =
  elem b $ accessible_ [a] rel


let rec replicate_list_ x (n: integer) acc =
  if n > 0 then
    replicate_list_ x (n-1) (x :: acc)
  else
    acc

val replicate_list: forall 'a. 'a -> integer -> list 'a
let replicate_list x n =
  replicate_list_ x n []
  
