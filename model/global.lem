type map 'a 'b = Pmap.map 'a 'b
type multiset 'a = Multiset.t 'a

(* empty type *)
type zero


let rec numerote_ n l =
  match l with
    | []    -> []
    | x::xs -> (n,x) :: numerote_ (n+1) xs
  end
let numerote l = numerote_ 1 l



let (-|) f g x = f (g x)
let (|-) g f x = f (g x)
(* TODO: ask change in lem to be able to have
         the traditional |> *)
let (>|>) x f = f x
let (>?>) x b f g = if b then f x else g x

let ($) f x = f x
let comp f g = fun x -> f (g x)

let rec nub' l acc =
  match l with
    | []    -> []
    | x::xs -> if List.mem x acc then nub' xs acc
                                 else x :: nub' xs (x::acc)
  end
let nub l = nub' l []


let rec or_list l =
  match l with
    | []    -> false
    | x::xs -> x || or_list xs
  end

let rec delete eq x = function
  | []    -> []
  | y::ys -> if eq x y then ys else y :: delete eq x ys
end

let list_diff eq = List.fold_left (fun x y -> delete eq y x)


val zip3: forall 'a 'b 'c. list 'a -> list 'b -> list 'c -> list ('a * 'b * 'c)
let rec zip3 xs ys zs =
  match (xs, ys, zs) with
    | (x::xs, y::ys, z::zs) -> (x,y,z) :: zip3 xs ys zs
    | _                     -> []
  end

val unzip: forall 'a 'b. list ('a * 'b) -> (list 'a * list 'b)
let unzip xys = List.fold_right (fun (x,y) (xs,ys) -> (x :: xs, y :: ys)) xys ([],[])

val unzip3: forall 'a 'b 'c. list ('a * 'b * 'c) -> (list 'a * list 'b * list 'c)
let unzip3 xyzs = List.fold_right (fun (x,y,z) (xs,ys,zs) -> (x :: xs, y :: ys, z :: zs)) xyzs ([],[],[])



let rec all p = function
  | []    -> true
  | x::xs -> p x  && all p xs
end


let is_Some = function
  | Some _ -> true
  | None   -> false
end


let rec filter_opt l = 
  match l with
    | (Some z) :: xs -> z :: filter_opt xs
    | None     :: xs ->      filter_opt xs
  end
