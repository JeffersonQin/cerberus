open import Pervasives
import Core Core_ctype AilTypes

(*
val debug_level: nat
declare ocaml target_rep function debug_level = `Boot_ocaml.debug_level`
declare coq   target_rep function debug_level = `0`
*)

val debug: forall 'a. string -> 'a


(*
val print_debug: forall 'a. string -> 'a -> 'a
declare ocaml target_rep function print_debug = `Debug.print_debug`
let inline {coq} print_debug x z = let _ = x in z (* I love lem so very much *)
*)

type char
declare hol  target_rep type char = `char`

val is_digit: char -> bool

val is_quote: char -> bool

val span_string: (char -> bool) -> string -> string * string

val unquote_string: string -> string

val splitAt_string: nat -> string -> string * string

val length_string: string -> nat

(* HACK for testing *)
val pickList: forall 'a. list 'a -> list 'a * 'a * list 'a
declare ocaml target_rep function pickList = `Boot_ocaml.pickList`
declare hol   target_rep function pickList = `util$pickList`


val output_string: string -> unit
declare ocaml target_rep function output_string = `Debug.output_string2`
declare hol   target_rep function output_string = `util$output_string`

val print_debug: nat -> string -> unit
declare ocaml target_rep function print_debug = `Debug.print_debug`
declare hol   target_rep function print_debug = `util$print_debug`

val print_debug_located: nat -> Loc.t -> string -> unit
declare ocaml target_rep function print_debug_located = `Debug.print_debug_located`
declare hol   target_rep function print_debug_located = `util$print_debug_located`

val warn: string -> unit
declare ocaml target_rep function warn = `Debug.warn`
declare hol target_rep function warn = `util$output_string`

(* Pretty printing (HACK: mind your mind) *)
val pp_ail_ctype: AilTypes.ctype -> string
declare ocaml target_rep function pp_ail_ctype = `String_ail.string_of_ctype_raw`
declare hol   target_rep function pp_ail_ctype = `pp_ail$pp_ail_ctype`

val pp_ail_expr: forall 'a. 'a (* Ail.expression_l *) -> string
declare ocaml target_rep function pp_ail_expr = `String_ail.string_of_expr`
declare hol   target_rep function pp_ail_expr a = ""

val pp_core_ctype: Core_ctype.ctype -> string
declare ocaml target_rep function pp_core_ctype = `String_core_ctype.string_of_ctype`
declare hol   target_rep function pp_core_ctype = `pp_core$pp_core_ctype`

val pp_core_expr: forall 'a. Core.expr 'a -> string
declare ocaml target_rep function pp_core_expr = `String_core.string_of_expr`
declare hol   target_rep function pp_core_expr = `pp_core$pp_core_expr`

val pp_core_pexpr: Core.pexpr -> string
declare ocaml target_rep function pp_core_pexpr = `String_core.string_of_pexpr`
declare hol   target_rep function pp_core_pexpr = `pp_core$pp_core_pexpr`

val pp_core_value: Core.value -> string
declare ocaml target_rep function pp_core_value = `String_core.string_of_value`
declare hol   target_rep function pp_core_value = `pp_core$pp_core_value`

val pp_prefix: Symbol.prefix -> string
declare ocaml target_rep function pp_prefix = `String_symbol.string_of_prefix`
declare hol   target_rep function pp_prefix = `pp_core$pp_prefix`

let inline {coq} pp_core_expr x = let _ = x in ""

val nat_of_string: string -> natural
declare ocaml target_rep function nat_of_string = `Nat_big_int.of_string`
declare hol   target_rep function nat_of_string = `util$nat_of_string`



(*
val pp_cabs0_definition: forall 'a. 'a -> string
declare ocaml target_rep function pp_cabs0_definition = `String_cabs.string_of_cabs0_definition`
*)

val pp_core_file: forall 'a. Core.file 'a -> string
declare ocaml target_rep function pp_core_file = `String_core.string_of_core_file`
declare hol   target_rep function pp_core_file = `pp_core$pp_core_file`


val pp_core_params: forall 'a. list (Symbol.t * Core.core_base_type) -> string
declare ocaml target_rep function pp_core_params = `String_core.string_of_core_params`
declare hol   target_rep function pp_core_params = `pp_core$pp_core_params`



val begin_timing: string -> unit
declare ocaml target_rep function begin_timing = `Debug.begin_timing`
declare hol   target_rep function begin_timing = `util$output_string`
val end_timing: unit -> unit
declare ocaml target_rep function end_timing = `Debug.end_timing`
declare hol   target_rep function end_timing = `util$unitId`


