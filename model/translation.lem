open Global

module A    = Ail
module C    = Core
module Caux = Core_aux
module T    = Ail_typing_aux




let rec mapWithLast f g = function
  | []      -> []
  | [x]     -> [g x]
  | (x::xs) -> f x :: mapWithLast f g xs
end


(* -------------------------------------------------------------------------- *)

module Effect = struct
  type env = <|
    (* symbol counter for Core's symbolic names (including functions and labels) *)
    symbol_set: Symbol.sset;
    (* stack of enclosing loop labels *)
    loop_labels: list Symbol.t;
    (* HACK? environment remembering if atomic names "should be" pure or effectful *)
(*    purity_map: map Symbol.t bool; *)
    (* map of functions generated while processing the current Ail function *)
    fun_map: map Symbol.t (C.core_type * list (Symbol.t * C.core_base_type) * C.expr zero);
    stdlib: C.fun_map zero;
    
    (* visible C objects with scoping *)
    visible_objects: list (list Symbol.t);
(*    cont_freevars_map: map Symbol.t (list Symbol.t) *)
  |>
  
  type t 'a = State.t 'a env
  
  
  val return: forall 'a. 'a -> t 'a
  let return = State.return
  
  val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
  let bind = State.bind
  
  val map: forall 'a 'b. ('a -> 'b) -> t 'a -> t 'b
  let map = State.map
  
  module Operators = struct
    let (>>=) = bind
    val (>>): forall 'a 'b. t 'a -> t 'b -> t 'b
    let (>>) m f = m >>= fun _ -> f
  end
  
  val init: C.fun_map zero -> env
  let init stdlib = <|
    symbol_set=        Symbol.init;
    loop_labels=       [];
    fun_map=           Pmap.empty;
    stdlib=            stdlib;
    visible_objects=   [[]];
  |>
  
  
  val     foldlM: forall 'a 'b. ('a -> 'b -> t 'a) -> 'a -> list 'b -> t 'a
  let rec foldlM f z0 xs =
    match xs with
      | []    -> return z0
      | x::xs' -> bind (f z0 x) (fun z -> foldlM f z xs')
    end
  
  val foldl1M: forall 'a. ('a -> 'a -> t 'a) -> list 'a -> t 'a
  let foldl1M f = function
     | []    -> Boot.outOfHomeomorphism "[Translation.E.foldl1M] called on an empty list"
    | x::xs -> foldlM f x xs
    end

  
  open Operators
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)
  let mapWithLastM f g xs = sequence (mapWithLast f g xs)

  let sequence_ ms = List.fold_right (>>) ms (return ())
  val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
  let mapM_ f _as = sequence_ (List.map f _as)
  
  
  val replicateM: forall 'a. num -> t 'a -> t (list 'a)
  let replicateM n x = sequence (replicate n x)

  
(*  (C.sym, C.core_type * (C.sym * C.core_base_type) list * C.expr) *)

(*
  val fresh: Symbol.t t
  let fresh (s, funcs) = ((s, None), (s + 1, funcs))
*)
  
  
  
  
  val fresh_symbol: t Symbol.t
  let fresh_symbol =
    fun (<| symbol_set= x |> as env) -> ((x, None), <| env with symbol_set= x+1 |>)

  val fresh_named_symbol: string -> t Symbol.t
  let fresh_named_symbol name =
    fun (<| symbol_set= x |> as env) -> ((x, Some $ name ^ "_" ^ string_of_num x), <| env with symbol_set= x+1 |>)
  
  val fresh_fname: string -> t Symbol.t
  let fresh_fname name =
    fun (<| symbol_set= x |> as env) -> ((x, Some $ name ^ "_" ^ string_of_num x), <| env with symbol_set= x+1 |>)
  
  (* create a new Core function *)
  val add_function: Symbol.t -> C.core_type -> list (Symbol.t * C.core_base_type) -> C.expr zero -> t unit
  let add_function fname typ args body =
    fun (<| fun_map= fun_map |> as env) -> ((), <| env with fun_map= Pmap.add fname (typ, args, body) fun_map |>)


(* Fancy Core expressions builders (dealing nicelly with pure expressions) *)

(* TODO: crappy names *)

(*
val get_purity: Symbol.t -> t bool
let get_purity x = fun (<| purity_map= m |> as env) -> (Pmap.find x m, env)

val put_purity: Symbol.t -> bool -> t unit
let put_purity x y = fun (<| purity_map= m |> as env) -> ((), <| env with purity_map= Pmap.add x y m |>)
*)


  val push_block_objects: list Symbol.t -> t unit
  let push_block_objects _as =
    fun env -> ((), <| env with visible_objects= _as :: env.visible_objects |>)
  
  val pop_block_objects: t unit
  let pop_block_objects =
    fun env -> ((), <| env with visible_objects= match env.visible_objects with _ :: xs -> xs end |>)
  
  val get_visible_objects: t (list Symbol.t)
  let get_visible_objects =
    fun env -> (List.fold_left (@) [] env.visible_objects, env)
  
  
(*
  val register_cont_freevars: Symbol.t -> list Symbol.t -> t unit
  let register_cont_freevars l ids =
    fun env -> ((), <| env with cont_freevars_map= Pmap.add l ids env.cont_freevars_map |>)
  
  (* give the free symbol for a continuation corresponding to a C label *)
  val get_cont_freevars: Symbol.t -> t (list Symbol.t)
  let get_cont_freevars l =
    fun env -> (Pmap.find l env.cont_freevars_map, env)
  
  val clear_cont_freevars: t unit
  let clear_cont_freevars =
    fun env -> ((), <| env with cont_freevars_map= Pmap.empty |>)
*)

end

(* -------------------------------------------------------------------------- *)
module E = Effect
open E.Operators

let exp_type    = Annotate.exp_type_of
let lvalue_type = Annotate.lvalue_type_of






(* 'optimised' implementation of [\f -> unzip . map f] *)
val mapUnzip: forall 'a 'b 'c. ('a -> 'b * 'c) -> list 'a -> list 'b * list 'c
let rec mapUnzip_ f (xs, ys) = function
  | []      -> (xs, ys)
  | (l::ls) -> let (x,y) = f l in mapUnzip_ f (x::xs, y::ys) ls
end
let mapUnzip f l =
  let (xs, ys) = mapUnzip_ f ([],[]) l in
  (List.rev xs, List.rev ys)















(*
val     reduce_pure: Core.expr zero -> Core.expr zero
let rec reduce_pure e =
  let reduce_op e1 e2 = function
    | OpAdd -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> C.Econst (n1 + n2)
                 | _                          -> C.Eop op e1 e2
               end
    | OpSub -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> C.Econst (n1 - n2)
                 | _                          -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpSub] found an ill-typed subexpression"
               end
    | OpMul -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> C.Econst (n1 * n2)
                 | _                          -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpMul] found an ill-typed subexpression"
               end
    | OpDiv -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> C.Econst (n1 / n2)
                 | _                          -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpDiv] found an ill-typed subexpression"
               end
    | OpMod -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> C.Econst (n1 % n2)
                 | _                          -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpMod] found an ill-typed subexpression"
               end
    | OpEq -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> if n1 = n2 then C.Etrue else C.Efalse
                 | _                          -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpEq] found an ill-typed subexpression"
               end
    | OpLt -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Econst n1, C.Econst n2) -> if n1 < n2 then C.Etrue else C.Efalse
                 | _                          -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpLt] found an ill-typed subexpression"
               end
    | OpAnd -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Etrue,  C.Etrue ) -> C.Etrue
                 | (C.Etrue,  C.Efalse) -> C.Efalse
                 | (C.Efalse, C.Etrue ) -> C.Efalse
                 | (C.Efalse, C.Efalse) -> C.Efalse
                 | _                    -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpAnd] found an ill-typed subexpression"
               end
    | OpOr -> match (reduce_pure e1, reduce_pure e2) with 
                 | (C.Etrue,  C.Etrue ) -> C.Etrue
                 | (C.Etrue,  C.Efalse) -> C.Etrue
                 | (C.Efalse, C.Etrue ) -> C.Etrue
                 | (C.Efalse, C.Efalse) -> C.Efalse
                 | _                    -> Boot.outOfHomeomorphism "[Translation.reduce_pure, OpOr] found an ill-typed subexpression"
               end
  end

  match e with
  | C.Eskip     -> C.Eskip
  | C.Econst n  -> C.Econst n
  | C.Eaddr x   -> C.Eaddr x
  | C.Esym a    -> C.Esym a (* K: we don't want to reduce, because a pure
                                  symbolic name must come from a let, which
                                  exists because we don't want to reduce (?) *)
  | C.Eop op e1 e2 -> reduce_op op e1 e2
  | C.Etrue     -> C.Etrue
  | C.Efalse    -> C.Efalse
  | C.Enot e    -> match reduce_pure e with
                     | C.Etrue  -> C.Efalse
                     | C.Efalse -> C.Etrue
                     | _                    -> Boot.outOfHomeomorphism "[Translation.reduce_pure, Knot] found an ill-typed subexpression"
                   end
  | C.Ectype ty  -> C.Ectype ty
  | C.Elet a e1 e2 -> 
  | C.Eif e1 e2 e3  -> match reduce_pure e1 with
                         | C.Etrue  -> reduce_pure e2
                         | C.Efalse -> reduce_pure e3
                         | _                    -> Boot.outOfHomeomorphism "[Translation.reduce_pure, Kif] found an ill-typed subexpression"
  | C.Ecall _ _ -> E.return true
  | C.Esame _ _ -> E.return true
  | C.Eundef -> E.return true
  | C.Eerror -> E.return true
  
  | C.Eaction _ -> E.return false
  
  | C.Eunseq _    -> E.return false
  | C.Ewseq _ _ _ -> E.return false
  | C.Esseq _ _ _ -> E.return false
  | C.Easeq _ _ _ -> E.return false
  
  | C.Eindet _ -> E.return false (* TODO: maybe not *)
  | C.Ebound _ _ -> E.return false
*)



(*
(* TODO: I shouldn't need this horror anymore *)
(* [seems_pure tenv e] tells wether e is pure, assuming it is well-typed *)
val     seems_pure: Core.expr zero -> E.t bool
let rec seems_pure e =
  match e with
    | C.Eskip     -> E.return true
    | C.Econst _  -> E.return true
    | C.Eaddr _   -> E.return true
    | C.Esym _    -> E.return true
    | C.Eop _ _ _ -> E.return true
    | C.Etrue     -> E.return true
    | C.Efalse    -> E.return true
    | C.Enot _    -> E.return true
    | C.Ectype _  -> E.return true
  
    | C.Elet a _ e2 -> E.put_purity a true >> seems_pure e2
    | C.Eif _ e2 _  -> seems_pure e2
    | C.Ecall _ _ -> E.return true
    | C.Eproc _ _ -> E.return false
    | C.Esame _ _ -> E.return true
    | C.Eundef -> E.return true
    | C.Eerror -> E.return true
  
    | C.Eaction _ -> E.return false
  
    | C.Eunseq _    -> E.return false
    | C.Ewseq _ _ _ -> E.return false
    | C.Esseq _ _ _ -> E.return false
    | C.Easeq _ _ _ -> E.return false
  
    | C.Eindet _ -> E.return false (* TODO: maybe not *)
    | C.Ebound _ _ -> E.return false
  
  (* Continuation operators (TODO: check these) *)
  | C.Esave _ _ _ e -> seems_pure e
  | C.Erun _ _ _ -> E.return false


  | C.Eret _ -> E.return false


  | _ -> Boot.outOfHomeomorphism (Boot.pp_core_expr e)
(*  | Krun _ -> 
*)
  
(*
  | Knd of list (expr 'a)
*)
end
*)

(*
let rec _mkUnseq core_es (xs, ys) =
  match core_es with
    | []    -> E.return (List.rev xs, List.rev ys)
    | e::es -> seems_pure e >>= fun b ->
               _mkUnseq es (if b then (e :: xs, ys) else (xs, e :: ys))
  end


val     mkUnseq: list (Core.expr zero) -> E.t (Core.expr zero * list (Core.expr zero))
let rec mkUnseq core_es =
  match core_es with
    | [] -> Boot.outOfHomeomorphism "[Translation.mkUnseq] given an empty list of expressions"
    | es -> _mkUnseq es ([],[]) >>= fun (xs, ys) ->
            E.return (C.Eunseq ys, xs)
  end
*)


(* TMP *)
val     findL: forall 'a. ('a -> bool) -> list 'a -> option 'a
let rec findL pred xs =
  match xs with
    | []     -> None
    | x::xs' ->  if pred x then Some x else findL pred xs'
  end

(* hackish *)
val mk_stdcall: string -> E.t (list (Core.expr zero) -> Core.expr zero)
let mk_stdcall fname =
  fun env ->
    match findL (function ((_, Some z), _) -> z = fname | _ -> false end) (Pmap.bindings env.E.stdlib) with
      | Some (f, _) -> (Core.Ecall f, env)
      | None        -> Boot.assert_false $ "mk_stdcall: not a std function: " ^ fname
   end

















let conv ty1 ty2 exp =
  if Ail_typing_aux.eq ty1 ty2 then exp
                      else E.fresh_symbol    >>= fun a_exp  ->
                           exp               >>= fun core_e ->
                           mk_stdcall "conv" >>= fun conv   ->
                           E.return $ C.Ewseq [Some a_exp] core_e (conv [C.Ectype ty1; C.Ectype ty2; C.Esym a_exp])
(*
                           seems_pure core_e >>= function
                             | true  -> E.return $ conv [C.Ectype ty1; C.Ectype ty2; core_e]
                             | false -> E.return $ C.Ewseq [Some a_exp] core_e (conv [C.Ectype ty1; C.Ectype ty2; C.Esym a_exp])
                           end
*)
(*
    | true  -> E.return $ C.Elet a_conv (C.Ecall C.conv [C.Ectype ty1; C.Ectype ty2; core_e]) (C.Esym a_conv)
    | false -> E.return $ C.Ewseq [Some a_exp] core_e (C.Elet a_conv (C.Ecall C.conv [C.Ectype ty1; C.Ectype ty2; C.Esym a_exp]) (C.Esym a_conv))
*)


val get_function_id: A.file (Location.t * A.type_class) -> A.expression_l (Location.t * A.type_class) -> option (A.id * list A.id * A.statement_l (Location.t * A.type_class))
let get_function_id file e =
  match Annotate.exp_of e with
  | A.VARIABLE fid ->
      let (ids, body) = Pmap.find fid file.A.fn_map in
      Some (fid, ids , body)
  | _ -> None
  end






(* (integer) promotion for values. (cf. §6.3.1.1#2) *)
(* this should be a function from pure Core expr to pure Core expr (I think ...) *)
let promote_value (e: C.expr 'b ) : C.expr 'b = e (* TODO !!!! *)








(* TODO: see if this right
     usual_arithmetic_conv e ty1 ty2 == performed the value conversion on the expression of type ty1 following the usual arith of ty1 and ty2
 *)
let usual_arithmetic_conv (e: C.expr zero) (ty1: Ail.ctype) (ty2: Ail.ctype) : E.t (C.expr zero) =
  mk_stdcall "usual_arithmetic" >>= fun usual_arithmetic ->
  mk_stdcall "conv"             >>= fun conv             ->
  E.return $ conv [C.Ectype ty1; usual_arithmetic [C.Ectype ty1; C.Ectype ty2]; e]











(*
let conv_int_lifted t (a, m) =
  Tc.conv_int t a >>= fun (v, c) ->
  E.return (v, m +& c)
*)

(* -------------------------------------------------------------------------- *)
(* -------------------------------------------------------------------------- *)

let rec translate_lvalue file exp =
  let f = translate_exp file in
  match Annotate.exp_of exp with

    (* TODO: may be temporary *)
    | A.NULL -> E.return C.Enull


    | A.VARIABLE id -> E.return (C.Esym id)
    
    | A.UNARY A.INDIRECTION e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        (* TODO: the checks *)
        E.return core_e
(*
    | A.UNARY A.INDIRECTION e ->
        f e >>= fun (a, m) ->
        let t = T.base_of_pointer (T.pointer_convert (exp_type e)) in
        let ill_aligned = C.neg (Tc.is_aligned t a) in
        let null = C.eq a C.null in
        let c = C.implies (C.disj null ill_aligned) C.undef in
        E.return (a, m +& c)


    | _ ->
        C.fresh >>= fun a ->
        E.return (a, Me.null)
*)

   (* ------------------------------------------------------------------------------------------- *)
    | _ -> E.return (C.DEBUG "Translation.translate_lvalue, _ case")
  end

(* ---------------------------------------------------------------------------------------------- *)

and translate_exp file exp =
  let ty = Annotate.ctype_of exp in
  match Annotate.exp_of exp with
    | A.NULL -> E.return C.Enull
    
    (* (6.5.3.3#2) The result of the unary + operator is the value of its (promoted) operand. The
                   integer promotions are performed on the operand, and the result has the promoted
                   type. *)
    | A.UNARY A.PLUS e ->
        translate_exp file e >>= fun core_e ->
        E.return (promote_value core_e)
    
    
    (* (6.5.3.3#3) The result of the unary - operator is the negative of its (promoted) operand. The
                   integer promotions are performed on the operand, and the result has the promoted
                   type. *)
    | A.UNARY A.MINUS e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        E.return $ C.Ewseq [Some a_e] core_e
                     (C.Eop C.OpSub (C.Econst (Int.int 0)) (promote_value $ C.Esym a_e))
    
    
    (* (6.5.3.3#4) The result of the ~ operator is the bitwise complement of its (promoted) operand
                   (that is, each bit in the result is set if and only if the corresponding bit in
                   the converted operand is not set). The integer promotions are performed on the
                   operand, and the result has the promoted type. If the promoted type is an
                   unsigned type, the expression ~E is equivalent to the maximum value representable
                   in that type minus E. *)
    | A.UNARY A.BNOT e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        mk_stdcall "max"     >>= fun max    ->
          if Ail_typing_aux.is_unsigned_integer_type ty then
            E.return $ C.Ewseq [Some a_e] core_e
                         (C.Eop C.OpSub (max [C.Ectype ty]) (promote_value $ C.Esym a_e))
          else
            Boot.debug "TODO: the bitwise complement is implementation-defined (sort of) when the promoted type is signed."
    
    
    (* (6.5.3.2#3) The unary & operator yields the address of its operand. [...] If the operand is
                   the result of a unary * operator, neither that operator nor the & operator is
       evaluated and the result is as if both were omitted, [...] Similarly, if the
                   operand is the result of a [] operator, neither the & operator nor the unary *
                   that is implied by the [] is evaluated and the result is as if the & operator
                   were removed and the [] operator were changed to a + operator. *)
    | A.UNARY A.ADDRESS (_, (A.UNARY A.INDIRECTION e)) ->
        
        translate_exp file e (* DONE *)
    
    
    (* (6.5.3.2#3) Otherwise, the result is a pointer to the object or function designated by its
                   operand. *)
    | A.UNARY A.ADDRESS e ->
        translate_lvalue file e (* TODO *)
    
    
    (* (6.5.3.2#4) The unary * operator denotes indirection. If the operand points to a function,
                   the result is a function designator; if it points to an object, the result is an
                   lvalue designating the object. If the operand has type ‘‘pointer to type’’, the
                   result has type ‘‘type’’. If an invalid value has been assigned to the pointer,
                   the behavior of the unary * operator is undefined. *)
    | A.UNARY A.INDIRECTION e ->
        (* TODO: temporary hack  *)

        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        (* shouldn't be a real load ? *)
        E.return $ C.Ewseq [Some a_e] core_e
                     (Caux.pload (C.Ectype ty) (C.Esym a_e))
    
    
    (* (6.5.2.4#2) The result of the postfix ++ operator is the value of the operand. As a
                   side effect, the value of the operand object is incremented (that is, the value 1
                   of the appropriate type is added to it). See the discussions of additive
                   operators and compound assignment for information on constraints, types, and
                   conversions and the effects of operations on pointers. The value computation of
                   the result is sequenced before the side effect of updating the stored value of
                   the operand. With respect to an indeterminately-sequenced function call, the
                   operation of postfix ++ is a single evaluation. Postfix ++ on an object with
                   atomic type is a read-modify-write operation with memory_order_seq_cst memory
                   order semantics. *)
    (* TODO: "atomicity" of the load-store pair *)
    (* CHECK *)
    | A.UNARY A.POSTFIX_INCR e ->
        E.fresh_symbol          >>= fun a_lvalue ->
        E.fresh_symbol          >>= fun a_load   ->
        translate_lvalue file e >>= fun core_e   ->
        mk_stdcall "conv_int"   >>= fun conv_int ->
        E.return $
          C.Ewseq [Some a_lvalue] core_e
            (C.Easeq (Some a_load) ({}, C.Load (C.Ectype (lvalue_type e)) (C.Esym a_lvalue))
                                   (C.Neg, ({}, C.Store (C.Ectype (lvalue_type e))
                                      (C.Esym a_lvalue)
                                      (conv_int [C.Ectype (exp_type e); (C.Eop C.OpAdd (C.Esym a_load) (C.Econst (Int.int 1)))])
                                    ))
            )









(*
          C.Ewseq [Some a_lvalue] core_e
            (C.Ewseq [Some a_load] (Caux.pload (C.Ectype (lvalue_type e)) (C.Esym a_lvalue))
               (C.Ewseq [] (C.store (C.Ectype (lvalue_type e))
                                   (C.Esym a_lvalue)
                                   (C.Ecall C.conv_int
                                            [C.Ectype (exp_type e);
                                            (C.Eop C.OpAdd (C.Esym a_load) (C.Econst 1))]))
                  (C.Esym a_load)
               )
            )
*)
    
    
   (* (6.5.2.4#3) The postfix -- operator is analogous to the postfix ++ operator, except that the
                  value of the operand is decremented (that is, the value 1 of the appropriate type
                  is subtracted from it). *)
    (* TODO: "atomicity" of the load-store pair *)
    | A.UNARY A.POSTFIX_DECR e ->
        E.fresh_symbol          >>= fun a_lvalue ->
        E.fresh_symbol          >>= fun a_load   ->
        translate_lvalue file e >>= fun core_e   ->
        mk_stdcall "conv_int"   >>= fun conv_int ->
        E.return $
          C.Ewseq [Some a_lvalue] core_e
            (C.Ewseq [Some a_load] (Caux.pload (C.Ectype (lvalue_type e)) (C.Esym a_lvalue))
               (C.Ewseq [] (Caux.pstore (C.Ectype (lvalue_type e))
                                        (C.Esym a_lvalue)
                                        (conv_int [C.Ectype (exp_type e); (C.Eop C.OpSub (C.Esym a_load) (C.Econst (Int.int 1)))]))
                  (C.Esym a_load)
               )
            )
    
    
    (* (6.5.5#3) The usual arithmetic conversions are performed on the operands.
       (6.5.5#4) The result of the binary * operator is the product of the operands. *)
    (* TODO: check *)
    | A.BINARY (A.ARITHMETIC A.MUL) e1 e2 ->
        E.fresh_symbol        >>= fun a_e1     ->
        E.fresh_symbol        >>= fun a_e2     ->
        translate_exp file e1 >>= fun core_e1  ->
        translate_exp file e2 >>= fun core_e2  ->
        E.fresh_symbol        >>= fun a_mul    ->
        mk_stdcall "overflow" >>= fun overflow ->
        mk_stdcall "conv_int" >>= fun conv_int ->
        let mul_ctx x =
          C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
            (C.Elet a_mul (C.Eop C.OpMul (C.Esym a_e1) (C.Esym a_e2))
               x) in
        if T.is_signed_integer_type (exp_type exp) then
          E.return $ mul_ctx (overflow [C.Ectype (exp_type exp); C.Esym a_mul])
        else
          E.return $ mul_ctx (conv_int [C.Ectype (exp_type exp); C.Esym a_mul])
    
    
    (* (6.5.5#3) The usual arithmetic conversions are performed on the operands.
       (6.5.5#5) The result of the / operator is the quotient from the division of the first operand
                 by the second; the result of the % operator is the remainder. In both operations,
                 if the value of the second operand is zero, the behavior is undefined. *)
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.DIV) e1 e2 ->
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        (* TODO[check] usual arithmetic conversions *)
        usual_arithmetic_conv (C.Esym a_e1) (exp_type e1) (exp_type e2) >>= fun core_e1' ->
        usual_arithmetic_conv (C.Esym a_e2) (exp_type e1) (exp_type e2) >>= fun core_e2' ->
        
        (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                        quotient with any fractional part discarded.105) If the quotient a/b is
                        representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                        behavior of both a/b and a%b is undefined. *)
        E.return $
          C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
            (* if the value of the second operand is zero, the behavior is undefined. *)
            (C.Eif (C.Eop C.OpEq (C.Esym a_e2) (C.Econst (Int.int 0)))
               (C.Eundef Undefined.Division_by_zero)
               (C.Eop C.OpDiv core_e1' core_e2')
            )
    
    
    (* (6.5.5#3) The usual arithmetic conversions are performed on the operands.
       (6.5.5#5) [...] the result of the % operator is the remainder [from the division of the first
                 operand by the second]. [...], if the value of the second operand is zero, the
                 behavior is undefined. *)
    (* (6.5.5#6) When integers are divided, the result of the / operator is the algebraic quotient
                 with any fractional part discarded. If the quotient a/b is representable, the
                 expression (a/b)*b + a%b shall equal a; otherwise, the behavior of both a/b and a%b
                 is undefined. *)
    (* TODO: check *)
    | A.BINARY (A.ARITHMETIC A.MOD) e1 e2 ->
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        (* TODO[check] usual arithmetic conversions *)
        usual_arithmetic_conv (C.Esym a_e1) (exp_type e1) (exp_type e2) >>= fun core_e1' ->
        usual_arithmetic_conv (C.Esym a_e2) (exp_type e1) (exp_type e2) >>= fun core_e2' ->
        
        (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                        quotient with any fractional part discarded.105) If the quotient a/b is
                        representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                        behavior of both a/b and a%b is undefined. *)
        E.return $
          C.Ewseq [Some a_e1; Some a_e2] (Caux.mk_unseq [core_e1; core_e2])
            (* if the value of the second operand is zero, the behavior is undefined. *)
            (C.Eif (C.Eop C.OpEq (C.Esym a_e2) (C.Econst (Int.int 0)))
               (C.Eundef Undefined.Modulo_by_zero)
               (C.Eop C.OpMod core_e1' core_e2')
            )

(*
        fresh_symbol          >>= fun a_e1    ->
        fresh_symbol          >>= fun a_e2    ->
        fresh_symbol          >>= fun a_e1'   ->
        fresh_symbol          >>= fun a_e2'   ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        fresh_symbol          >>= fun a_mod   ->
        C.Eseq C.SOpSeq [a_e1; a_e2] (C.Eunseq [core_e1; core_e2])
          (C.Elet a_res_ty (C.Ecall C.usual_arithmetic [C.Ectype exp_type e1; C.Ectype exp_type e2])
             (C.Elet a_e1' (usual_arithmetic_conv (C.Esym a_e1))
                (C.Elet a_e2' (usual_arithmetic_conv (C.Esym a_e2))
                   (C.Eif (C.Eop C.OpEq (C.Esym a_e2') (C.Econst 0))
                      (C.Eundef)
                      ((C.Elet a_mod (C.Eop C.OpMod (C.Esym a_e1') (C.Esym a_e2')))
                          (C.Eif (C.Enot (C.Ecall C.representable []))
        
        
        let mod_ctx x =
          C.Eseq C.SOpSeq [a_e1; a_e2] (C.Eunseq [core_e1; core_e2])
            (C.Elet a_mod (C.Eop C.OpMod (C.Esym a_e1)
                                           (C.Ecall C.guard_zero [C.Esym a_e2]))
               x) in
        if T.is_signed_integer(exp_type exp) then
          E.return $ mod_ctx (C.Ecall C.overflow [C.Ectype (exp_type exp); C.Esym a_mod])
        else
          E.return $ mod_ctx (C.Ecall C.conv_int [C.Ectype (exp_type exp); C.Esym a_mod])
*)
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    (* 
       (6.5.6#5) The result of the binary + operator is the sum of the operands.
       (6.5.6#7) For the purposes of these operators, a pointer to an object that is not an element
                 of an array behaves the same as a pointer to the first element of an array of
                 length one with the type of the object as its element type.
       (6.5.6#8) When an expression that has integer type is added to [...] a pointer, the result
                 has the type of the pointer operand. If the pointer operand points to an element of
                 an array object, and the array is large enough, the result points to an element
                 offset from the original element such that the difference of the subscripts of the
                 resulting and original array elements equals the integer expression. In other
                 words, if the expression P points to the i-th element of an array object, the
                 expressions (P)+N (equivalently, N+(P)) [...] (where N has the value n) point to,
                 respectively, the i+n-th and i−n-th elements of the array object, provided they
                 exist.
                 Moreover, if the expression P points to the last element of an array object, the
                 expression (P)+1 points one past the last element of the array object [...].
                 If both the pointer operand and the result point to elements of the same array
                 object, or one past the last element of the array object, the evaluation shall not
                 produce an overflow; otherwise, the behavior is undefined.
                 If the result points one past the last element of the array object, it shall not be
                 used as the operand of a unary * operator that is evaluated.
*)
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.ADD) e1 e2 ->
        let ctype_e1 = exp_type e1 in
        let ctype_e2 = exp_type e2 in
        if T.is_arithmetic_type ctype_e1 && T.is_arithmetic_type ctype_e2 then
          (* (6.5.6#4) If both operands have arithmetic type, the usual arithmetic conversions are
                       performed on them. *)
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->

(*          
          seems_pure core_e1 >>= fun b1 ->
          seems_pure core_e2 >>= fun b2 ->
*)
          
          mk_stdcall "overflow" >>= fun overflow ->
          mk_stdcall "conv_int" >>= fun conv_int ->
  
(*        
          if b1 && b2 then E.return (if T.is_signed_integer_type (exp_type exp) then
                                       overflow [C.Ectype (exp_type exp); C.Eop C.OpAdd core_e1 core_e2]
                                     else
                                       conv_int [C.Ectype (exp_type exp); C.Eop C.OpAdd core_e1 core_e2])
          else if b1 then E.return
            (C.Ewseq [Some a_e2] core_e2
               (if T.is_signed_integer_type (exp_type exp) then
                  overflow [C.Ectype (exp_type exp); C.Eop C.OpAdd core_e1 (C.Esym a_e2)]
                else
                  conv_int [C.Ectype (exp_type exp); C.Eop C.OpAdd core_e1 (C.Esym a_e2)]))
          else if b2 then E.return
            (C.Ewseq [Some a_e1] core_e1
               (if T.is_signed_integer_type (exp_type exp) then
                  overflow [C.Ectype (exp_type exp); C.Eop C.OpAdd (C.Esym a_e1) core_e2]
                else
                  conv_int [C.Ectype (exp_type exp); C.Eop C.OpAdd (C.Esym a_e1) core_e2]))

          else 
*)
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (* The 'usual arithmetic conversion' *)
            (if T.is_signed_integer_type (exp_type exp) then
                  (* if the return type is signed, then there is an undefined behaviour
                     in the presence of an arithmetic overflow *)
                overflow [C.Ectype (exp_type exp); C.Eop C.OpAdd (C.Esym a_e1) (C.Esym a_e2)]
             else
                 (* otherwise, TODO: doc *)
                conv_int [C.Ectype (exp_type exp); C.Eop C.OpAdd (C.Esym a_e1) (C.Esym a_e2)]
              )




(*
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (* The 'usual arithmetic conversion' *)
              (if T.is_signed_integer (exp_type exp) then
                  (* if the return type is signed, then there is an undefined behaviour
                     in the presence of an arithmetic overflow *)
                  C.Ecall C.overflow [C.Ectype (exp_type exp); C.Eop C.OpAdd (C.Esym a_e1) (C.Esym a_e2)]
               else
                 (* otherwise, TODO: doc *)
                 C.Ecall C.conv_int [C.Ectype (exp_type exp); C.Eop C.OpAdd (C.Esym a_e1) (C.Esym a_e2)]
              )
*)




(*

(*
          C.Eseq C.SOpSeq [a_e1; a_e2] (C.Eunseq [core_e1; core_e2])
            (usual_arithmetic_conv (C.Eop C.OpAdd (C.Esym a_e1) (C.Esym a_e2))
                                   () () KKK
            )

 (ty1: Ail.ctype) (ty2: Ail.ctype) : C.expr

*)

          (* Prepare the expression composing the evaluation of the operands which
             are unsequenced with respect to each other *)
          (* If we are ok with passing "complexe" expressions of type 'value' to
             functions, then we can get rid of the Klet *)
          let add_ctx x =
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Elet a_add (C.Eop C.OpAdd (C.Esym a_e1) (C.Esym a_e2))
                 x) in
          
          (* The 'usual arithmetic conversion' *)
          if T.is_signed_integer_type (exp_type exp) then
            (* if the return type is signed, then there is an undefined behaviour
               in the presence of an arithmetic overflow *)
            E.return $ add_ctx (C.Ecall C.overflow [C.Ectype (exp_type exp); C.Esym a_add])
          else
            (* otherwise, TODO: doc *)
            E.return $ add_ctx (C.Ecall C.conv_int [C.Ectype (exp_type exp); C.Esym a_add])
            
*)
        else
          (* otherwise, we have some pointer arithmetic *)
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          E.fresh_symbol        >>= fun a_shift ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          if T.is_pointer_type (exp_type e1) then
            E.return $ C.DEBUG "A.ARITHMETIC A.ADD e1 e2 <pointer case>"

(*
            C.Eseq C.SOpSeq [a_e1; a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Elet a_offset (C.Eshift a_e1 a_e2 (C.Esizeof (exp_type e1)))
                (C.Eseq C.SOpSeq [] (C.Esame a_e1 a_shift)
                  (C.Esym a_shift)))
*)
          else
            E.return $ C.DEBUG "A.ARITHMETIC A.ADD e1 e2 <pointer case>"
(*        
      else
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        if T.is_pointer_type (exp_type e1) then
          let size = Tc.size (T.base_of_pointer (exp_type e1)) in
          let a = C.offset a1 a2 size in
          Action.same a1 a >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
        else
          let size = Tc.size (T.base_of_pointer (exp_type e2)) in
          let a = C.offset a2 a1 size in
          Action.same a a1 >>= fun same ->
          E.return (a, (m1 -&- m2) -@> same)
*)
    
    
     
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   
    
    (* TODO: e1 - e2 *)
    
    
    
    
   (* (6.5.7#3) The integer promotions are performed on each of the operands. [...] If the value of
                the right operand is negative or is greater than or equal to the width of the
                promoted left operand, the behavior is undefined.
      (6.5.7#4) The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled
                with zeros. If E1 has an unsigned type, the value of the result is E1 × 2^E2,
                reduced modulo one more than the maximum value representable in the result type. If
                E1 has a signed type and nonnegative value, and E1 × 2^E2 is representable in the
                result type, then that is the resulting value; otherwise, the behavior is undefined. *)
    | A.BINARY (A.ARITHMETIC A.SHL) e1 e2 -> (* DONE (check) *)
        E.fresh_symbol             >>= fun a_e1          ->
        E.fresh_symbol             >>= fun a_e2          ->
        E.fresh_symbol             >>= fun a_res         ->
        translate_exp file e1      >>= fun core_e1       ->
        translate_exp file e2      >>= fun core_e2       ->
        mk_stdcall "ctype_width"   >>= fun ctype_width   ->
        mk_stdcall "exp"           >>= fun exp           ->
        mk_stdcall "max"           >>= fun max           ->
        mk_stdcall "representable" >>= fun representable ->
        
        E.return $
          C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
          (* if a_e2 < 0 then undef *)
          (C.Eif (C.Eop C.OpLt (C.Esym a_e2) (C.Econst (Int.int 0)))
             (C.Eundef Undefined.Negative_shift)
          
          (* if width{ty} <= a_e2 then undef *)
          (* TODO: [ty] should be the promoted type of [e1] *)
          (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (ctype_width [C.Ectype ty]) (C.Esym a_e2))
                               (C.Eop C.OpEq (ctype_width [C.Ectype ty]) (C.Esym a_e2))) (* TODO: check the test about the width *)
             (C.Eundef Undefined.Shift_too_large)
          
          (* else [...] *)
             (if Ail_typing_aux.is_unsigned_integer_type (Annotate.ctype_of e1) then
                (* mod (a_e1 * exp(2, a_e2)) (max{ty}+1) *)
                 C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (exp [C.Econst (Int.int 2); C.Esym a_e2]))
                               (C.Eop C.OpAdd (max [C.Ectype ty]) (C.Econst (Int.int 1)))
              else (* e1 has a signed type *)
                (* if a_e2 < 0 then undef *)
                (C.Eif (C.Eop C.OpLt (C.Esym a_e2) (C.Econst (Int.int 0)))
                   (C.Eundef Undefined.Negative_left_shift)
                   (* let a_res = mod (a_e1 * exp(2, a_e2)) (max{ty}+1) in [...] *)
                   (C.Elet a_res (C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (exp [C.Econst (Int.int 2); C.Esym a_e2]))
                                                (C.Eop C.OpAdd (max [C.Ectype ty]) (C.Econst (Int.int 1))))
                      (* not representable(ty, a_res) then undef *)
                      (C.Eif (C.Enot (representable [C.Ectype ty; C.Esym a_res]))
                         (C.Eundef Undefined.Negative_left_shift)
                      (* else  *)
                         (C.Esym a_res)
                      )
                   )
                )
             )
          )
          )


   (* (6.5.7#3) The integer promotions are performed on each of the operands. [...] If the value of
                the right operand is negative or is greater than or equal to the width of the
                promoted left operand, the behavior is undefined.
      (6.5.7#5) The result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned
                type or if E1 has a signed type and a nonnegative value, the value of the result is
                the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a
                negative value, the resulting value is implementation-defined. *)
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.SHR) e1 e2 -> 
        E.return $ C.DEBUG "A.ARITHMETIC A.SHR e1 e2 <TODO (has an implementation defined case)>"
    
    
   (* (6.5.10#3) The usual arithmetic conversions are performed on the operands.
      (6.5.10#4) The result of the binary & operator is the bitwise AND of the operands (that is,
                 each bit in the result is set if and only if each of the corresponding bits in the
                 converted operands is set). *)
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.BAND) e1 e2 ->
        E.return (C.DEBUG "A.BINARY (A.ARITHMETIC A.BAND) e1 e2  <implementation defined>")
    
    
   (* (6.5.11#3) The usual arithmetic conversions are performed on the operands.
      (6.5.11#4) The result of the ^ operator is the bitwise exclusive OR of the operands (that is,
                 each bit in the result is set if and only if exactly one of the corresponding bits
                 in the converted operands is set). *)
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.XOR) e1 e2 ->
        E.return (C.DEBUG "A.BINARY (A.ARITHMETIC A.XOR) e1 e2  <implementation defined>")
    
    
   (* (6.5.12#3) The usual arithmetic conversions are performed on the operands.
      (6.5.12#4) The result of the | operator is the bitwise inclusive OR of the operands (that is,
                 each bit in the result is set if and only if at least one of the corresponding bits
                 in the converted operands is set). *)
    (* TODO *)
    | A.BINARY (A.ARITHMETIC A.BOR) e1 e2 ->
        E.return (C.DEBUG "A.BINARY (A.ARITHMETIC A.BOR) e1 e2  <implementation defined>")
    
    
    (* (6.5.17#2) The left operand of a comma operator is evaluated as a void expression; there is
                  a sequence point between its evaluation and that of the right operand. Then the
                  right operand is evaluated; the result has its type and value. *)
    | A.BINARY A.COMMA e1 e2 -> (* DONE (maybe not, be careful when mixing with assignments) *)
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        E.return $ C.Ewseq [] core_e1 core_e2
    
    
    (* (6.5.13#3) The && operator shall yield 1 if both of its operands compare unequal to 0;
                  otherwise, it yields 0. The result has type int.
       (6.5.13#4) Unlike the bitwise binary & operator, the && operator guarantees left-to-right
                  evaluation; if the second operand is evaluated, there is a sequence point between
                  the evaluations of the first and second operands. If the first operand compares
                  equal to 0, the second operand is not evaluated. *)
    | A.BINARY A.AND e1 e2 -> (* DONE *)
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        E.return $
          C.Ewseq [Some a_e1] core_e1
            (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Econst (Int.int 0)))
                   (C.Econst (Int.int 0))
                   (C.Ewseq [Some a_e2] core_e2
                     (C.Eif (C.Eop C.OpEq (C.Esym a_e2) (C.Econst (Int.int 0)))
                            (C.Econst (Int.int 0))
                            (C.Econst (Int.int 1))
                     )
                   )
            )
    
    
    (* (6.5.14#3) The || operator shall yield 1 if either of its operands compare unequal to 0;
                  otherwise, it yields 0. The result has type int.
       (6.5.14#4) Unlike the bitwise | operator, the || operator guarantees left-to-right
                  evaluation; if the second operand is evaluated, there is a sequence point between
                  the evaluations of the first and second operands. If the first operand compares
                  unequal to 0, the second operand is not evaluated. *)
    | A.BINARY A.OR e1 e2 -> (* DONE *)
        E.fresh_symbol        >>= fun a_e1    ->
        E.fresh_symbol        >>= fun a_e2    ->
        translate_exp file e1 >>= fun core_e1 ->
        translate_exp file e2 >>= fun core_e2 ->
        E.return $
          C.Ewseq [Some a_e1] core_e1
            (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e1) (C.Econst (Int.int 0))))
                   (C.Econst (Int.int 1))
                   (C.Ewseq [Some a_e2] core_e2
                     (C.Eif (C.Eop C.OpEq (C.Esym a_e2) (C.Econst (Int.int 0)))
                            (C.Econst (Int.int 0))
                            (C.Econst (Int.int 1))
                     )
                   )
            )
    
    
    (* (6.5.8#3) If both of the operands have arithmetic type, the usual arithmetic conversions are
                 performed.
       (6.5.8#4) For the purposes of these operators, a pointer to an object that is not an element
                 of an array behaves the same as a pointer to the first element of an array of
                 length one with the type of the object as its element type.
       (6.5.8#5) When two pointers are compared, the result depends on the relative locations in the
                 address space of the objects pointed to. If two pointers to object types both point
                 to the same object, or both point one past the last element of the same array
                 object, they compare equal. If the objects pointed to are members of the same
                 aggregate object, pointers to structure members declared later compare greater than
                 pointers to members declared earlier in the structure, and pointers to array
                 elements with larger subscript values compare greater than pointers to elements of
                 the same array with lower subscript values. All pointers to members of the same
                 union object compare equal. If the expression P points to an element of an array
                 object and the expression Q points to the last element of the same array object,
                 the pointer expression Q+1 compares greater than P. In all other cases, the
                 behavior is undefined.
       (6.5.8#6) Each of the operators < (less than), > (greater than), <= (less than or equal to),
                 and >= (greater than or equal to) shall yield 1 if the specified relation is true
                 and 0 if it is false. The result has type int. *)
    (* TODO *)
    | A.BINARY A.LT e1 e2 -> E.return (C.DEBUG "TODO: A.BINARY A.LT e1 e2")
    
    
    (* TODO *)
    | A.BINARY A.GT e1 e2 ->
        if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Enot (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))))
                 (C.Econst (Int.int 1))
                 (C.Econst (Int.int 0))
              )
        else
          E.return (C.DEBUG "TODO: A.BINARY A.GT e1 e2")
    
    
    (* TODO *)
    | A.BINARY A.LE e1 e2 ->
        if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)))
                     (C.Econst (Int.int 1))
                     (C.Econst (Int.int 0))
              )
        else (* MUST BE: both operands are pointers to qualified or unqualified versions of compatible object types. *)
          E.return (C.DEBUG "A.BINARY A.LE e1 e2 <when e1 and e2 are pointers>")
    
    
    (* TODO: not doing the typing stuff for now *)
    | A.BINARY A.GE e1 e2 ->
        if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpLt (C.Esym a_e2) (C.Esym a_e1))
                     (C.Econst (Int.int 1))
                     (C.Econst (Int.int 0))
              )
        else
          E.return (C.DEBUG "TODO: A.BINARY A.GE e1 e2")
    
    
   (* (6.5.9#3) The == (equal to) and != (not equal to) operators are analogous to the relational
                operators [...]. Each of the operators yields 1 if the specified relation is true
                and 0 if it is false. [...] For any pair of operands, exactly one of the relations
                is true.
      (6.5.9#4) If both of the operands have arithmetic type, the usual arithmetic conversions are
                performed.
                Values of complex types are equal if and only if both their real parts are equal and
                also their imaginary parts are equal.
                Any two values of arithmetic types from different type domains are equal if and only
                if the results of their conversions to the (complex) result type determined by the
                usual arithmetic conversions are equal.
      (6.5.9#5) Otherwise, at least one operand is a pointer. If one operand is a pointer and the
                other is a null pointer constant, the null pointer constant is converted to the type
                of the pointer. If one operand is a pointer to an object type and the other is a
                pointer to a qualified or unqualified version of void, the former is converted to
                the type of the latter.
      (6.5.9#6) Two pointers compare equal if and only if both are null pointers, both are pointers
                to the same object (including a pointer to an object and a subobject at its
                beginning) or function, both are pointers to one past the last element of the same
                array object, or one is a pointer to one past the end of one array object and the
                other is a pointer to the start of a different array object that happens to
                immediately follow the first array object in the address space.
      (6.5.9#7) For the purposes of these operators, a pointer to an object that is not an element
                of an array behaves the same as a pointer to the first element of an array of length
                one with the type of the object as its element type. *)
    | A.BINARY A.EQ e1 e2 ->
        if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))
                     (C.Econst (Int.int 1))
                     (C.Econst (Int.int 0))
              )
        else if T.is_pointer_type (exp_type e1) && T.is_pointer_type (exp_type e2) then
          E.return (C.DEBUG "A.BINARY A.EQ e1 e2 <when e1 and e2 are pointers>")
        else if Ail_typing.is_null_pointer_constant e1 then
          E.return (C.DEBUG "A.BINARY A.EQ e1 e2 <when e1 and e2 are pointers, and e1 is a \
                             null constant")
        else
          E.return (C.DEBUG "A.BINARY A.EQ e1 e2 <when e1 and e2 are pointers, and e1 is NOT \
                             a null constant")
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.BINARY A.NE e1 e2 ->
        if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          E.return $
            C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))
                     (C.Econst (Int.int 0))
                     (C.Econst (Int.int 1))
              )
        else
          E.return (C.DEBUG "A.BINARY A.NE e1 e2 <when e1 and e2 not both of arithmetic type>")
    
    
    (* *** ASSIGN operators *** *)
    
    
    
   (* (6.5.15#4) The first operand is evaluated; there is a sequence point between its evaluation
                 and the evaluation of the second or third operand (whichever is evaluated). The
                 second operand is evaluated only if the first compares unequal to 0; the third
                 operand is evaluated only if the first compares equal to 0; the result is the value
                 of the second or third operand (whichever is evaluated), converted to the type
                 described below.
      (6.5.15#6) If both the second and third operands are pointers or one is a null pointer constant and the other is a pointer, the result type is a pointer to a type qualified with all the type qualifiers of the types referenced by both operands. Furthermore, if both operands are pointers to compatible types or to differently qualified versions of compatible types, the result type is a pointer to an appropriately qualified version of the composite type; if one operand is a null pointer constant, the result has the type of the other operand; otherwise, one operand is a pointer to void or a qualified version of void, in which case the result type is a pointer to an appropriately qualified version of void.

 *)
    (* TODO: conv_int on e2 and e2 !!!!!!! *)
    | A.CONDITIONAL e1 e2 e3 ->
        if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
          E.fresh_symbol        >>= fun a_e1    ->
          E.fresh_symbol        >>= fun a_e2    ->
          E.fresh_symbol        >>= fun a_e3    ->
          translate_exp file e1 >>= fun core_e1 ->
          translate_exp file e2 >>= fun core_e2 ->
          translate_exp file e3 >>= fun core_e3 ->
          E.return $
            C.Ewseq [Some a_e1] core_e1
              (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Econst (Int.int 0)))
                     core_e2
                     core_e3)
        else
          E.return (C.DEBUG "A.CONDITIONAL e1 e2 e3 <pointer>")
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.CAST ty e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        mk_stdcall "conv"    >>= fun conv   ->
        E.return $
          C.Ewseq [Some a_e] core_e
            (conv [C.Ectype ty; C.Ectype (exp_type e); C.Esym a_e])
    
    
   (* ------------------------------------------------------------------------------------------- *)
    (* TODO: this is very partial for now: the first operand of a call must directly be a function
             identifier (see the defintiino of [get_function_id]) *)
    | A.CALL e es ->
        match get_function_id file e with
          | Some (fid, ids, s) ->
              (* if there are no arguments, we don't need all the temporary object creation stuff *)
              match es with
                | [] -> E.return $ C.Eproc {} fid []
                | _  ->
    	            match fst $ Pmap.find fid file.A.id_map with
	              | A.FUNCTION retTy Tys ->
                          let n = List.length ids in
                          
                          (* symbolic names for the temporary objects and init value *)
                          E.replicateM n E.fresh_symbol >>= fun as_tmp  ->
                          
                          (* create actions for the temporary objects *)
                          let core_creates =
                            List.map (fun ty -> Caux.pcreate (C.Ectype ty) []) Tys in
                          
                          (* their initialisations *)
                          E.mapM (fun (a, ty, e) ->
                            E.fresh_symbol       >>= fun a_init ->
                            translate_exp file e >>= fun core_e ->
			    E.return $
                              C.Ewseq [Some a_init] core_e
			        (Caux.pstore (C.Ectype ty) (C.Esym a) (C.Esym a_init))
                          ) (zip3 as_tmp Tys es) >>= fun core_inits ->
                          
                          (* their kill actions *)
                          let core_kills = List.map (Caux.pkill -| C.Esym) as_tmp in
                          
                          (* symbolic name for the call result *)
                          E.fresh_symbol >>= fun a_call ->

                          E.return $
                            C.Ewseq (List.map Some as_tmp) (Caux.mk_unseq core_creates)
                              (C.Ewseq [] (Caux.mk_unseq core_inits)
                                 (C.Ewseq [Some a_call] (C.Eindet $ C.Eproc {} fid (List.map C.Esym as_tmp))
                                    (C.Ewseq [] (Caux.mk_unseq core_kills)
                                       (C.Esym a_call)
                                    )
                                 )
                              )
	                end
	    | _ -> Boot.outOfHomeomorphism "[Translation.translate_exp, A.CALL e es] a function id is declared with a non-function type"
	  end


	  
(*          E.return (C.Eindet (C.COMMENT "TODO: function call" C.Eerror)) *)

(*
      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
      (* retrieve the declarations of these variables *)
      let decls = [(Pmap.find id env', lookup_type id)| forall (id MEM ids) | true] in
      let n     = List.length decls                                                 in
      
      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx = let (syms, xs) = mapUnzip (fun (a, ty) -> (a, C.create ty)) (List.rev decls) in
                        match n with
                          | 0 -> fun x -> x
                          | 1 -> C.Eseq C.SOpSeq syms (List.hd xs)
                          | _ -> C.Eseq C.SOpSeq syms (C.Eunseq xs)
                        end in


translate_exp env file e >>= fun core_e ->
C.seq [a_id] (C.create ty)
  (C.store ty a_id (C.Ecall C.conv [C.Ectype (Ail_typing_aux.unqualify ty); C.Ectype (exp_type e); core_e]))

(*
            let f_create (l, t, e) m' =
              conv (T.unqualify t) (exp_type e) (f e) >>= fun (a, m) ->
              Action.create   t l                     >>= fun create ->
              Action.fn_store t l a                   >>= fun store  ->
              E.return ((m' -&- m) +@ create -@> store) in
*)
      

      (* prepare the code killing the objects. *)
      let kills = let xs = List.map (fun (a, _) -> C.Kill a) decls in
                        match n with
                          | 0 -> C.Eskip
                          | 1 -> List.hd xs
                          | _ -> C.Eunseq xs
                        end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt env' file current_function s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt env' file current_function s >>= fun core_s ->
                               E.return ([a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) -> C.Eseq C.SOpSeq _as stmt acc)
                    (C.Eseq C.SOpSeq [] kills (C.Esym a_last))
                    (List.rev core_ss))

        (*
            update_env env ids >>= fun env' ->

            let args =
              let f id e = (Pmap.find id env', lookup_type id, e) in
              List.map2 f ids es in

            let f_create (l, t, e) m' =
              conv (T.unqualify t) (exp_type e) (f e) >>= fun (a, m) ->
              Action.create   t l                     >>= fun create ->
              Action.fn_store t l a                   >>= fun store  ->
              E.return ((m' -&- m) +@ create -@> store) in

            let f_kill (l, _, _) m =
              Action.kill l >>= fun kill ->
              E.return (m +@ kill) in

            E.foldlM f_create args Me.unit     >>= fun m_create ->
            E.foldlM f_kill   args Me.unit     >>= fun m_kill   ->
            C.fresh                            >>= fun a        ->
	    reduce_stmt n b env' file fid a s >>= fun ml       ->
            Action.call                        >>= fun call     ->
            let m_body = Ms.exit_function call ml in
            E.return (a, m_create -&> m_body -&> m_kill)
        *)
*)




      | None ->
        (* TODO: looks like we need a "null" constant of type address in Core *)
        E.return (C.DEBUG "A.CALL e es <function pointer>")
      end
    
    
    
    (* *** MEMBEROF *** *)
    | A.MEMBEROF e x -> E.return (C.DEBUG "TODO: A.MEMBEROF e x")
    
    
    
    (* *** MEMBEROFPTR *** *)
    | A.MEMBEROFPTR e x -> E.return (C.DEBUG "TODO: A.MEMBEROFPTR e x")
    
    
    
    (* ------------------------------------------------------------------------------------------ *)
    | A.CONSTANT (A.CONST_INT (i, _)) -> (* DONE *)
          E.return (C.Econst i)
    
    
    | A.CONSTANT _ -> E.return (C.DEBUG "TODO: A.CONSTANT _")
    
    
    (* WARNING: this is not enought (DEBUG FOR NOW) *)
    | A.VARIABLE id ->
        E.return $ Caux.pload (C.Ectype (lvalue_type exp)) (C.Esym id)
    
    
   (* ------------------------------------------------------------------------------------------- *)
    (* [§6.5.3.4#4] When sizeof is applied to an operand that has type char, unsigned char, or
                    signed char, (or a qualified version thereof) the result is 1. *)
    | A.SIZEOF (A.BASIC _ A.CHAR)                           -> E.return (C.Econst (Int.int 1))
    | A.SIZEOF (A.BASIC _ (A.INTEGER (A.SIGNED A.ICHAR)))   -> E.return (C.Econst (Int.int 1))
    | A.SIZEOF (A.BASIC _ (A.INTEGER (A.UNSIGNED A.ICHAR))) -> E.return (C.Econst (Int.int 1))
    
    | A.SIZEOF  ty -> mk_stdcall "sizeof" >>= fun sizeof -> E.return $ sizeof [C.Ectype ty]
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.ALIGNOF ty -> mk_stdcall "alignof" >>= fun alignof -> E.return $ alignof [C.Ectype ty]
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    (* ------------------------------------------------------------------------------------------ *)
(*
      if T.is_arithmetic (exp_type e1) && T.is_arithmetic (exp_type e2) then
        conv_exp e1 >>= fun (a1, m1) ->
        conv_exp e2 >>= fun (a2, m2) ->
        let diff = C.minus a1 a2 in
        if T.is_signed_integer (exp_type exp) then
          let c = overflow (exp_type exp) diff in
          E.return (diff, (m1 -&- m2) +& c)
        else
          Tc.conv_int (exp_type exp) (C.minus a1 a2) >>= fun (a, c) ->
          E.return (a, m1 -&- m2 +& c)
      else (*if T.is_integer (exp_type e2) then*)
        (* Pointer arithmetic. *)
        f e1 >>= fun (a1, m1) ->
        f e2 >>= fun (a2, m2) ->
        let size = Tc.size (T.base_of_pointer (exp_type e1)) in
        let a = C.offset a1 (C.minus C.zero a2) size in
        Action.same a1 a >>= fun same ->
        E.return (a, (m1 -&- m2) -@> same)
*)
      | A.BINARY (A.ARITHMETIC A.SUB) e1 e2 ->
          if T.is_arithmetic_type (exp_type e1) && T.is_arithmetic_type (exp_type e2) then
            E.fresh_symbol        >>= fun a_e1     ->
            E.fresh_symbol        >>= fun a_e2     ->
            translate_exp file e1 >>= fun core_e1  ->
            translate_exp file e2 >>= fun core_e2  ->
            E.fresh_symbol        >>= fun a_sub    ->
            mk_stdcall "overflow" >>= fun overflow ->
            mk_stdcall "conv_int" >>= fun conv_int ->
            let sub_ctx x =
              C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Elet a_sub (C.Eop C.OpSub (C.Esym a_e1) (C.Esym a_e2))
                   x) in
            if T.is_signed_integer_type (exp_type exp) then
              E.return $ sub_ctx (overflow [C.Ectype (exp_type exp); C.Esym a_sub])
            else
              E.return $ sub_ctx (conv_int [C.Ectype (exp_type exp); C.Esym a_sub])
          
          else (*if T.is_integer_type (exp_type e2) then*)
            (* Pointer arithmetic. *)
            (* TODO: pointer arith *)
            E.return $ C.DEBUG "A.ARITHMETIC A.SUB e1 e2 <pointer case>"
      
    
    
    
    
    
    
    
    
    
    
    
    
    
    
   (* ------------------------------------------------------------------------------------------- *)
    | A.ASSIGN None e1 e2 ->
        E.fresh_symbol           >>= fun a_e1    ->
        E.fresh_symbol           >>= fun a_e2    ->
        translate_lvalue file e1 >>= fun core_e1 ->
        translate_exp    file e2 >>= fun core_e2 ->
        mk_stdcall "conv"         >>= fun conv   ->
        E.return $
          C.Ewseq [Some a_e1; Some a_e2] (C.Eunseq [core_e1; core_e2])
            (C.Ewseq [] (C.Eaction (C.Pos, ({}, C.Store (C.Ectype (lvalue_type e1))
                                              (C.Esym a_e1)
                                              (conv [C.Ectype (exp_type e1); C.Ectype (exp_type e2); C.Esym a_e2]))
                                   )
                        )
                       (C.Esym a_e2))
    
    
    (* TODO: yes this is morally reprehensible.

(std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
      expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
       to an indeterminately-sequenced function call, the operation of a compound) *)
    | A.ASSIGN (Some op) e1 e2 ->
      translate_exp file ((Annotate.loc_of exp, Annotate.type_of exp), A.ASSIGN None e1 ((Location.dummy, Annotate.type_of e2), A.BINARY (A.ARITHMETIC op) e1 e2))
      (* E.return (C.DEBUG "TODO: A.ASSIGN (Some _) e1 e2") *)
    
    
    
    
    
    | A.MALLOC e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        E.return $ C.Ewseq [Some a_e] core_e (Caux.palloc (C.Esym a_e) [])
    
    
    | A.FREE e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        E.return $ C.Ewseq [Some a_e] core_e (Caux.pkill (C.Esym a_e))
    
    | A.MEMCMP e1 e2 e3 -> E.return (C.DEBUG "TODO: A.MEMCMP e1 e2 e3")
    
    
    
    
    | A.ASSERT e ->
        E.fresh_symbol       >>= fun a_e    ->
        translate_exp file e >>= fun core_e ->
        E.return $ C.Ewseq [Some a_e] core_e
          (C.Eif (C.Eop C.OpEq (C.Esym a_e) (C.Econst (Int.int 0)))
                 C.Eerror
                 C.Eskip
          )
    
    
   (* ------------------------------------------------------------------------------------------- *)
(*    | _ -> E.return (C.DEBUG "translate_exp, _ case") *)
  end















(* -------------------------------------------------------------------------- *)

(* translate_stmt Pmap.empty file file.A.main C.Constants.return s *)

(* TODO[über HACK] `lasts' is the last of symbolic names saving the last statement for each block we are in
                   we need to remember them to annotate Erun/Esave coming from a C label/goto because these symbols
                   MAY (the fact it is a may is pretty disgusting) be in the continuations of the generated Esave (...)

RAAAAAAAAHHH: this doesn't work when the label is in a block the goto doesn't belong to ......
*)

module St = State
open St.Operators

type collect_cases_state = <|
  found_default: bool;
  cases: list Ail.integer_constant
|>

let rec collect_cases_ (_, stmt) : St.t unit collect_cases_state =
  let register_case n =
    St.update (fun s -> <| s with cases= n :: s.cases |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.SKIP ->
        St.return ()
    | A.EXPRESSION _ ->
        St.return ()
    | A.BLOCK _ ss ->
        St.mapM_ collect_cases_ ss
    | A.IF _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.WHILE _ s ->
        collect_cases_ s
    | A.DO _ s ->
        collect_cases_ s
    | A.BREAK ->
        St.return ()
    | A.CONTINUE ->
        St.return ()
    | A.RETURN_VOID ->
        St.return ()
    | A.RETURN_EXPRESSION _ ->
        St.return ()
    | A.SWITCH _ _ ->
        St.return ()
    | A.CASE n s ->
        register_case n >> collect_cases_ s
    | A.DEFAULT s ->
        register_default >> collect_cases_ s
    | A.LABEL _ s ->
        collect_cases_ s
    | A.GOTO _ ->
        St.return ()
    | A.DECLARATION _ ->
        St.return ()
(*    | PAR of list (statement_l 'a) *)
  end


let collect_cases s =
  snd $ St.run_impl (collect_cases_ s) <| found_default= false; cases= [] |>

let rec translate_stmt file f d_default d_cases d_loop d_break (_, stmt) : E.t (C.expr zero) =
  let translate_stmt_ s = translate_stmt file f d_default d_cases d_loop d_break s in
  
  (* return the type of a given identifier. (TODO: why is this a local function?) *)
  let lookup_type id = fst (Pmap.find id file.A.id_map) in
  
  match stmt with
  | A.SKIP ->
      E.return C.Eskip
  
  | A.EXPRESSION e ->
      translate_exp file e
  
  | A.BLOCK ids ss ->
      (* retrieve the declarations of these variables *)
      let decls = [(id, lookup_type id) | forall (id MEM ids) | true] in
      
      (* the symbolic names and create actions for the local variables *)
      let (a_ids, core_creates) =
        mapUnzip (fun (a, ty) -> (Some a, Caux.pcreate (C.Ectype ty) [f; a])) decls in
      
      E.push_block_objects ids >>
      
      (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
               but it may be nasty to the check.
               For non-void function however we know (?) that the must be these returns ?? so we could drop the kills here *)
      (* the kill actions for the local variables *)
      let (core_kills) =
        List.map (Caux.pkill -| C.Esym -| fst) decls in
      
(*
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt file f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               E.return ([], core_s))
                     (* TODO: adding the a_last here is pretty disgusting *)
                     (fun s -> translate_stmt file f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               E.return ([Some a_last], core_s))
                     ss >>= fun a_opts_core_ss ->
*)
      E.mapM (fun s -> translate_stmt_ s >>= fun core_s -> E.return core_s) ss >>= fun core_ss ->
      
      E.pop_block_objects >>
      
      E.return
        (C.Ewseq a_ids (Caux.mk_unseq core_creates)
           (List.fold_right (fun core_s acc -> C.Ewseq [] core_s acc) core_ss (Caux.mk_unseq core_kills))
        )

(*

(*      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
*)
      let n     = List.length decls in

      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx: C.expr zero -> C.expr zero =
        let (syms, xs) = mapUnzip (fun (a, ty) -> (Some a, Caux.pcreate (C.Ectype ty) [])) (List.rev decls) in
        match n with
          | 0 -> fun x -> x
          | 1 -> C.Ewseq syms (List.hd xs)
          | _ -> C.Ewseq syms (C.Eunseq xs)
        end in
      
      (* prepare the code killing the objects. *)
      let kills_ctx = let xs = List.map (fun (a, _) -> Caux.pkill (C.Esym a)) decls in
                      match n with
                        | 0 -> fun x -> x
                        | 1 -> C.Ewseq [] (List.hd xs)
                        | _ -> C.Ewseq [] (C.Eunseq xs)
                      end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt_ s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt_ s >>= fun core_s ->
                               E.return ([Some a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) ->
                   if Caux.is_pure stmt then (match _as with
                                | [Some a] -> C.Elet a stmt acc
                                | []       -> acc
                                | _  -> Boot.outOfHomeomorphism "BOOM" end)
                   else C.Ewseq _as stmt acc)
                    (kills_ctx (if List.length ss = 0 then C.Eskip else C.Esym a_last))
                    (List.rev core_ss))

*)  

  | A.IF e s1 s2 ->
      E.fresh_symbol       >>= fun a_test  ->
      translate_exp file e >>= fun core_e  ->
      translate_stmt_ s1   >>= fun core_s1 ->
      translate_stmt_ s2   >>= fun core_s2 ->
      E.return $ C.Ewseq [Some a_test] core_e
                   (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_test) (C.Econst (Int.int 0)))) core_s1 core_s2)
  
  | A.WHILE e s ->
      E.fresh_symbol                                                         >>= fun a_e     ->
      E.fresh_named_symbol "loop"                                            >>= fun d_loop  ->
      E.fresh_named_symbol "break"                                           >>= fun d_break ->
      translate_exp file e                                                   >>= fun core_e  ->
      translate_stmt file f d_default d_cases (Some d_loop) (Some d_break) s >>= fun core_s  ->
      E.get_visible_objects                                                  >>= fun _as     ->
      E.return $
        C.Esave d_loop [(* TODO *)]
          (C.Ewseq [Some a_e] core_e
             (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e) (C.Econst (Int.int 0))))
                (C.Ewseq [] core_s (C.Erun {} d_loop [(* TODO *)]))
                (C.Esave d_break [(* TODO *)] C.Eskip)
             )
          )

(*
      let free_as = Set.to_list $ Caux.free_syms core_s in
      E.get_current_block_objects >>= fun _as ->
      E.return $
        C.Esave d_loop free_as [(* TODO *)]
          (C.Ewseq [Some a_e] core_e
             (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e) (C.Econst 0)))
                (C.Ewseq [] core_s (C.Erun d_loop (List.map C.Esym free_as) []))
                (C.Esave d_break _as [(* TODO *)] C.Eskip)
             )
          )
*)
  
  | A.DO e s ->
      E.fresh_symbol                                                         >>= fun d_loop  ->
      E.fresh_symbol                                                         >>= fun d_break ->
      translate_stmt file f d_default d_cases (Some d_loop) (Some d_break) s >>= fun core_s  ->
      translate_exp file e                                                   >>= fun core_e  ->
      E.fresh_symbol                                                         >>= fun a       ->
      E.return $
        C.Esave d_loop [(* TODO *)]
          (C.Ewseq [] core_s
             (C.Ewseq [Some a] core_e
                (C.Eif (C.Eop C.OpEq (C.Esym a) (C.Econst (Int.int 0)))
                   C.Eskip
                   (C.Erun {} d_loop [(* TODO *)])
                )
             )
          )
  
  | A.BREAK ->
      E.get_visible_objects >>= fun _as ->
      E.return (C.Erun {} (from_Some d_break) [ (a, C.Esym a) | forall (a MEM _as) | true ])
  
  | A.CONTINUE ->
      E.return (C.Erun {} (from_Some d_loop) [(* TODO *)])
  
  
  | A.RETURN_VOID ->
      E.get_visible_objects >>= fun _as ->
      let (core_kills) =
        List.map (Caux.pkill -| C.Esym) _as in
      E.return $
        C.Esseq [] (Caux.mk_unseq core_kills) (C.Eret C.Eskip)
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.RETURN_EXPRESSION e ->
      conv (exp_type e) (T.function_return $ lookup_type f)
           ((translate_exp file e)) >>= fun core_e ->
      E.fresh_symbol                >>= fun a_e    ->
      E.get_visible_objects         >>= fun _as ->
      let (core_kills) =
        List.map (Caux.pkill -| C.Esym) _as in
      E.return $
        C.Esseq [Some a_e] core_e
          (C.Esseq [] (Caux.mk_unseq core_kills)
             (C.Eret (C.Esym a_e))
          )
  
  
  (* TODO: the promotions *)
  | A.SWITCH e s ->
      translate_exp file e >>= fun core_e ->
      E.fresh_symbol       >>= fun a_e    ->
      (* TODO: should properly interpret the integer constants *)
      let (found_default, ns) =
        let x = collect_cases s in
        (x.found_default, List.map fst x.cases) in
      E.replicateM (List.length ns) (E.fresh_named_symbol "case") >>= fun ds ->
      let d_cases' = List.fold_left (fun acc (n, d) ->
        Pmap.add n d acc) Pmap.empty (List.combine ns ds) in
      E.fresh_named_symbol "default"                         >>= fun d_default' ->
      (if found_default then
        E.fresh_named_symbol "break"
      else
        E.return d_default')                                 >>= fun d_break'   ->
      E.get_visible_objects                                  >>= fun _as        ->
      let run_as = [ (a, C.Esym a) | forall (a MEM _as) | true ] in
      translate_stmt file f (Some d_default') (Some d_cases') d_loop (Some d_break') s >>= fun core_s ->

      E.return $
        C.Ewseq [Some a_e] core_e
          (List.fold_left (fun acc (n, d) ->
            C.Eif (C.Eop C.OpEq (C.Esym a_e) (C.Econst n))
              (C.Erun {} d run_as)
              acc
           )
             (C.Ewseq [] (C.Erun {} d_default' run_as)
                (C.Ewseq [] core_s
                   (C.Esave d_break' [ (a, lookup_type a) | forall (a MEM _as) | true ] C.Eskip)
                )
             )
             $ Pmap.bindings d_cases')
  
  
  (* TODO: the promotions *)
  | A.CASE n s ->
      translate_stmt_ s     >>= fun core_s ->
      E.get_visible_objects >>= fun _as    ->
      (* TODO: should properly interpret the integer constant *)
      E.return (C.Esave (Pmap.find (fst n) (from_Some d_cases)) [ (a, lookup_type a) | forall (a MEM _as) | true ] core_s)
  
  (* TODO *)
  | A.DEFAULT s ->
      translate_stmt_ s     >>= fun core_s ->
      E.get_visible_objects >>= fun _as    ->
      E.return (C.Esave (from_Some d_default) [ (a, lookup_type a) | forall (a MEM _as) | true ] core_s)

  
  
  (* TODO *)
  | A.LABEL l s ->
      translate_stmt_ s     >>= fun core_s ->
      E.get_visible_objects >>= fun _as    ->
      E.return (C.Esave l [ (a, lookup_type a) | forall (a MEM _as) | true ] core_s)
  
  
  (* TODO *)
  | A.GOTO l ->
      E.get_visible_objects >>= fun _as ->
      E.return (C.Erun {} l [ (a, C.Esym a) | forall (a MEM _as) | true ])
  
  
  (* ------------------------------------------------------------------------------------------------------ *)
  | A.DECLARATION []    -> E.return C.Eskip
  | A.DECLARATION defns ->
      (* This pass translate the declarations *)
      E.mapM (fun (id, e) ->
        E.fresh_symbol                                            >>= fun a      ->
        conv (exp_type e) (lookup_type id) (translate_exp file e) >>= fun core_e ->
        E.return $ C.Ewseq [Some a] core_e
                     (Caux.pstore (C.Ectype (lookup_type id)) (C.Esym id) (C.Esym a)) (* TODO: the id is probably wrong *)
      ) defns >>=
      
      (* This pass combine the translated declerations *)
      E.foldl1M (fun x y -> E.return  $ Caux.concat_wseq x y)
  
  
  | A.PAR ss ->
      E.mapM (translate_stmt_) ss >>= fun core_ss ->
      E.return $ C.Eunseq core_ss
  end


(* TODO: this a temporary hack *)
(* [hack1] collect a map associating ksyms to their list of free syms *)
let rec hack1 e =
  match e with
    | C.Etuple _ -> Pmap.empty
    | C.Enull -> Pmap.empty
    | C.Eskip -> Pmap.empty
    | C.Econst _ -> Pmap.empty
    | C.Eaddr _ -> Pmap.empty
    | C.Esym _ -> Pmap.empty
    | C.Eop _ _ _ -> Pmap.empty
    | C.Etrue -> Pmap.empty
    | C.Efalse -> Pmap.empty
    | C.Enot _ -> Pmap.empty
    | C.Ectype _ -> Pmap.empty
    | C.Elet _ _ e2 -> hack1 e2
    | C.Eif _ e2 e3 -> Ocaml.Pmap.fold (fun k v acc -> Pmap.add k v acc) (hack1 e2) (hack1 e3)
    | C.Eproc _ _ _ -> Pmap.empty
    | C.Ecall _ _ -> Pmap.empty
    | C.Esame _ _ -> Pmap.empty
    | C.Eundef _ -> Pmap.empty
    | C.Eerror -> Pmap.empty
    | C.Eaction _ -> Pmap.empty
    | C.Eunseq es -> List.fold_left (Ocaml.Pmap.fold (fun k v acc -> Pmap.add k v acc)) Pmap.empty (List.map hack1 es)
    | C.Ewseq _ e1 e2 -> Ocaml.Pmap.fold (fun k v acc -> Pmap.add k v acc) (hack1 e1) (hack1 e2)
    | C.Esseq _ e1 e2 -> Ocaml.Pmap.fold (fun k v acc -> Pmap.add k v acc) (hack1 e1) (hack1 e2)
    | C.Easeq _ _ _ -> Pmap.empty
    | C.Eindet e -> hack1 e
    | C.Ebound _ e -> hack1 e
    | C.Esave d _as e -> Pmap.add d _as (hack1 e)
    | C.Erun _ _ _ -> Pmap.empty
    | C.Eret _ -> Pmap.empty
(*    | End of list (expr 'a) *)
    | _ -> Pmap.empty
  end

(*
(* [hack2] updates the free syms annotation of the Eruns using a map (that we get from hack1)  *)
let rec hack2 m e =
  let hack2 e = hack2 m e in
  match e with
    | C.Elet a pe1 e2 -> C.Elet a pe1 (hack2 e2)
    | C.Eif pe1 e2 e3 -> C.Eif pe1 (hack2 e2) (hack2 e3)
    | C.Eunseq es -> C.Eunseq (List.map hack2 es)
    | C.Ewseq _as_opt e1 e2 -> C.Ewseq _as_opt (hack2 e1) (hack2 e2)
    | C.Esseq _as_opt e1 e2 -> C.Esseq _as_opt (hack2 e1) (hack2 e2)
    | C.Eindet e -> C.Eindet (hack2 e)
    | C.Ebound j e -> C.Ebound j (hack2 e)
    | C.Esave d _atys e -> C.Esave d _atys (hack2 e)
    | C.Erun d _ -> C.Erun d (List.map C.Esym $ Pmap.find d m)
(*    | End of list (expr 'a) *)
    | e -> e
  end
*)

(*
let rec _register_freevars ids (_, stmt) : E.t unit =
  match stmt with
    | A.SKIP ->
        E.return ()
    | A.EXPRESSION _ ->
        E.return ()
    | A.BLOCK ids' stmts ->
        E.mapM_ (_register_freevars (ids @ ids')) stmts
    | A.IF _ stmt1 stmt2 ->
        _register_freevars ids stmt1 >>
        _register_freevars ids stmt2
    | A.WHILE _ stmt ->
        _register_freevars ids stmt
    | A.DO _ stmt ->
        _register_freevars ids stmt
    | A.BREAK ->
        E.return ()
    | A.CONTINUE ->
        E.return ()
    | A.RETURN_VOID ->
        E.return ()
    | A.RETURN_EXPRESSION _ ->
        E.return ()
    | A.SWITCH _ stmt ->
        _register_freevars ids stmt
    | A.CASE _ stmt ->
        _register_freevars ids stmt
    | A.DEFAULT stmt ->
       _register_freevars ids stmt
    | A.LABEL l stmt ->
        E.register_cont_freevars l ids >>
        _register_freevars ids stmt
    | A.GOTO _ ->
        E.return ()
    | A.DECLARATION defs ->
        (* TODO: this is a HACK for now, because we don't have anything in these that isn't in the inclosing BLOCK *)
        E.return ()
    | A.PAR stmts ->
        Boot.assert_false "[Translation._register_freevars] #PAR: TODO"
  end
let register_freevars body : E.t unit =
  _register_freevars [] body >>
  E.return ()
*)


(* Run the translator on different functions *)
let translate_file stdlib (file: A.file _) : E.t (C.file zero) =
  E.foldlM
    (fun acc (name, (args, body)) ->
       (* translate the body to Core *)
(*       register_freevars body >> *)
       translate_stmt file name None None None None body >>= fun core_body ->
      
      (* HACK !!!!!!! *)
(*      let core_body = hack2 (hack1 core_body) core_body in *)
      
      
(*       E.clear_cont_freevars >> *)
       (E.return $ Pmap.add name (C.TyEffect C.Integer (* TODO: address for pointer type? *),
                                 List.map (fun arg -> (arg, C.Address (* TODO: check *))) args,
                                 core_body) acc))
    stdlib (* Pmap.empty *)
    (Pmap.bindings file.A.fn_map)
  >>= fun core_funcs ->
  E.return <| C.main= file.A.main; C.fun_map= core_funcs |>


(* This is the entry function (called from main.ml) *)
let translate stdlib (file: A.file _) : C.file zero =
let (cfile, <| E.fun_map= funs |>) = (translate_file stdlib file) (E.init stdlib) in
  <| C.main= cfile.C.main; C.fun_map= Ocaml.Pmap.fold (fun k v acc -> Pmap.add k v acc) funs cfile.C.fun_map |>


(* E.init (translate_file file) *)
(* C.test2 *)









(* ********** HACK ********** *)


let rec str_concat l =
  match l with
    | []      -> ""
    | (x::xs) -> x ^ str_concat xs
  end




let rec bar (l: list (option A.integer_constant * A.statement_l _)) : list (option A.integer_constant * A.statement_l _) =
  match l with
    | [] -> []
    | (c, (d, x)) :: xs -> (c, (d, A.BLOCK [] ((d,x) :: List.map snd xs))) :: bar xs
  end


let rec bar2 l =
  match l with
    | [] -> []
    | x::xs -> x::xs (* List.map (fun (c,z) -> (c,z @ List.map (fun z -> snd (List.head z)))) x *)
  end


let rec _suffixes l acc =
  match l with
    | []    -> []
    | x::xs -> _suffixes xs ((x::xs) :: acc)
  end
let suffixes l = _suffixes l []




(* the argument of decode_switch is the body of a switch *)
let rec decode_switch (d, stmt) =
(*
  match stmt with
  | A.SKIP -> []
  | A.EXPRESSION e -> []
  | A.BLOCK _ ss -> List.concat (List.map decode_switch file ss)
  | A.IF e s1 s2 -> []
  | A.WHILE e s -> []
  | A.DO e s -> decode_switch file s
  | A.BREAK -> []
  | A.CONTINUE -> []
  | A.RETURN_VOID -> []
  | A.RETURN_EXPRESSION e -> []
  | A.SWITCH e s -> []
  | A.CASE n s -> (Some n, s) :: decode_switch file s
  | A.DEFAULT s -> (None, s) :: decode_switch file s
  | A.LABEL label s -> decode_switch file s
  | A.GOTO label -> []
  | A.DECLARATION defs -> []
  end
*)
(*
  match stmt with
  | A.SKIP -> ""
  | A.EXPRESSION e -> ""
  | A.BLOCK _ ss -> str_concat (List.map (decode_switch file) ss)
  | A.IF e s1 s2 -> decode_switch file s1 ^ decode_switch file s2
  | A.WHILE e s -> decode_switch file s
  | A.DO e s -> decode_switch file s
  | A.BREAK -> ""
  | A.CONTINUE -> ""
  | A.RETURN_VOID -> ""
  | A.RETURN_EXPRESSION e -> ""
  | A.SWITCH e s -> decode_switch file s
  | A.CASE n s -> (Document.to_plain_string (A.Print.pp_int_const n)) ^ " ==> " ^ (Document.to_plain_string (A.Print.pp_stmt file s)) ^ "\n" ^
                  decode_switch file s
  | A.DEFAULT s -> "default ==> " ^ (Document.to_plain_string (A.Print.pp_stmt file s)) ^ "\n" ^ decode_switch file s
  | A.LABEL label s -> decode_switch file s
  | A.GOTO label -> ""
  | A.DECLARATION defs -> ""
  end
*)

  match stmt with
  | A.SKIP -> []
  | A.EXPRESSION e -> []
  | A.BLOCK _ _ -> []
(*  | A.BLOCK _ ss -> List.map (fun x -> A.BLOCK [] x) $ suffixes (List.concat (bar2 (List.map decode_switch ss))) *)
  | A.IF e s1 s2 -> decode_switch s1 @ decode_switch s2
  | A.WHILE e s -> decode_switch s
  | A.DO e s -> decode_switch s
  | A.BREAK -> []
  | A.CONTINUE -> []
  | A.RETURN_VOID -> []
  | A.RETURN_EXPRESSION e -> []
  | A.SWITCH e s -> decode_switch s
  | A.CASE n s -> (Some n, s) :: decode_switch s
  | A.DEFAULT s -> (None, s) :: decode_switch s
  | A.LABEL label s -> decode_switch s
  | A.GOTO label -> []
  | A.DECLARATION defs -> []
  end


(*
let pp_decode file (x, s) =
  match x with
    | Some n -> Document.to_plain_string (A.Print.pp_int_const n) ^ " ==> " ^ Document.to_plain_string (A.Print.pp_stmt file s)
    | None   -> "default ==> " ^ Document.to_plain_string (A.Print.pp_stmt file s)
  end

let rec string_concat z l =
  match l with
    | []    -> ""
    | x::xs -> x ^ z ^ string_concat z xs
  end
*)

(*
let foo (file: A.file _) =
  let [a;_] =
    List.map(fun (_, (args, body)) ->
      string_concat "\n" (List.map (pp_decode file) (decode_switch body))
(*      Document.to_plain_string (Ail.Print.pp_stmt file body) *)
    ) (Pmap.bindings file.A.fn_map)
  in
  a
*)
(*
  E.foldlM
    (fun (name, (args, body)) acc ->
       (* translate the body to Core *)
       translate_stmt file name body >>= fun core_body ->
       E.return $ Pmap.add name (C.TyBase C.value (* TODO: address for pointer type? *),
                                 List.map (fun arg -> (arg,C.address (* TODO: check *))) args,
                                 core_body) acc)
    (Pmap.bindings file.A.fn_map)
    Pmap.empty
  >>= fun core_funcs ->
  E.return <| C.main= file.A.main; C.fun_map= core_funcs |>
*)
