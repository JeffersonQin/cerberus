(* TODO: for now everything is mapped to nonatomics. The translation to atomics
         still needs to be defined *)

open import Pervasives Global Implementation_ Loc
import State State_operators Translation_effect
open import Translation_aux
import Cmm_master Naive_memory

import Decode

module Mem = Naive_memory (* New_memory *)

import AilSyntax AilSyntaxAux AilTypes
import Core Core_aux Undefined

module A    = AilSyntax
module Aaux = AilSyntaxAux
module Aty  = AilTypes

module C    = Core
module Cty  = Core_ctype
module Caux = Core_aux
module U    = Undefined

module Cmm = Cmm_master


module E = Translation_effect
module Operators = struct
  let inline (>>=)    = E.bind
  let inline (>>) m f = E.bind m (fun _ -> f)
end

open Operators



val translate_lvalue:
  C.fun_map unit -> A.program GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory                           ->
  E.t (C.expr unit)

val translate_function_designator:
  A.expression GenTypes.genTypeCategory ->
  E.t (C.expr unit)

val translate_expression:
  C.fun_map unit -> A.program GenTypes.genTypeCategory ->
  A.expression GenTypes.genTypeCategory                           ->
  E.t (C.expr unit)

(* val collect_cases *)

val translate_stmt:
  C.fun_map unit -> A.program GenTypes.genTypeCategory -> A.identifier    ->
  maybe Symbol.t -> maybe (map integer Symbol.t) -> maybe Symbol.t -> maybe Symbol.t ->
  A.statement GenTypes.genTypeCategory                                    ->
  E.t (C.expr unit)

val translate_program:
  C.fun_map unit -> A.program GenTypes.genTypeCategory ->
  E.t (list (C.sym * C.core_type * C.expr unit) * C.fun_map unit)

val translate:
    C.fun_map unit -> C.impl unit -> (UniqueId.supply Symbol.t) * A.program GenTypes.genTypeCategory ->
    (UniqueId.supply Symbol.t * C.file unit)


(* ========================================================================== *)

let rec translate_lvalue stdlib program a_exp =
  let translate_expression = translate_expression stdlib program in
  if Aaux.is_null_pointer_constant a_exp then
    E.return $ (C.Econst (Mem.mk_pointer (Mem.null_pointer (Caux.proj_ctype (ctype_of a_exp)))))
  else
    let A.AnnotatedExpression _ exp = a_exp in
    match exp with
      | A.AilEident id ->
          E.return (C.Esym id)
      
      | A.AilEunary A.Indirection e -> do E
          a_e    <- E.fresh_symbol;
          core_e <- translate_expression e; in
            (* TODO: the checks *)
            E.return core_e
          end
      
(*
    | A.UNARY A.INDIRECTION e ->
        translate_expression e >>= fun (a, m) ->
        let t = T.base_of_pointer (T.pointer_convert (Annotate.exp_type_of e)) in
        let ill_aligned = C.neg (Tc.is_aligned t a) in
        let null = C.eq a C.null in
        let c = C.implies (C.disj null ill_aligned) C.undef in
        E.return (a, m +& c)


    | _ -> do E
        a <- C.fresh; in
          E.return (a, Me.null)
        end
*)
  | _ -> Boot.assert_false "[Translation.translate_lvalue] wildcard case"
end


and translate_function_designator (A.AnnotatedExpression _ expr) =
  match expr with
    | A.AilEident fid ->
        E.return (Caux.cfunction_const fid)
    | _ ->
        Boot.assert_false "[Translation.translate_function_designator] wildcard case"
  end


and translate_expression stdlib program a_expr =
  let translate_expression e = translate_expression stdlib program e in
  let mk_stdcall fname = mk_stdcall stdlib fname in
  let bitwise_AND      = mk_stdcall "bitwise_AND"      in
  let bitwise_XOR      = mk_stdcall "bitwise_XOR"      in
  let bitwise_OR       = mk_stdcall "bitwise_OR"       in
  
  let conv             = mk_stdcall "conv"             in
  let conv_int         = mk_stdcall "conv_int"         in
  let overflow         = mk_stdcall "overflow"         in
  let ctype_width      = mk_stdcall "ctype_width"      in
(*  let quot             = mk_stdcall "quot"             in *)
  let is_representable = mk_stdcall "is_representable" in
  let usual_arithmetic = mk_stdcall "usual_arithmetic" in
  let usual_arithmetic_conv e ty1 ty2 =
    conv [Caux.mk_ctype ty1; usual_arithmetic [Caux.mk_ctype ty1; Caux.mk_ctype ty2]; e] in
  
  
  (* TODO: we do a match instead of a let, because of a bug in Lem *)
  let result_ty = ctype_of a_expr in
  
  if AilTypesAux.is_pointer result_ty && Aaux.is_null_pointer_constant a_expr then
    E.return $ C.Econst (Mem.mk_pointer (Mem.null_pointer (Caux.proj_ctype result_ty)))
  else
    let A.AnnotatedExpression annot expr = a_expr in
    match expr with
      (* TODO: integer promotion *)
      | A.AilEunary A.Plus e -> do E
          core_e <- translate_expression e; in
            E.return $ promote_value core_e
          end
      
      (* TODO: integer promotion *)
      | A.AilEunary A.Minus e -> do E
          a_e    <- E.fresh_symbol;
          core_e <- translate_expression e; in
            E.return $
              C.Ewseq [Just a_e] core_e
                (C.Eop C.OpSub Caux.zero (promote_value $ C.Esym a_e))
          end
      
      (* TODO: integer promotion *)
      | A.AilEunary A.Bnot e -> do E
          a_e    <- E.fresh_symbol;
          core_e <- translate_expression e; in
            E.return $
              C.Ewseq [Just a_e] core_e (
                if is_unsigned_integer_type result_ty then
                  C.Eop C.OpSub (Caux.ctype_max $ Caux.mk_ctype result_ty) (promote_value $ C.Esym a_e)
                else
                  Caux.bitwise_complement (Caux.mk_ctype $ exp_type_of e) (promote_value $ C.Esym a_e)
              )
          end
      
      (* TODO: promotion? + atomicity *)
      | A.AilEunary A.PostfixIncr e -> do E
          a_lvalue <- E.fresh_symbol;
          a_load   <- E.fresh_symbol;
          core_e   <- translate_lvalue stdlib program e; in
            (* TODO: qualifiers temporarily not dealt with *)
            let core_ty_e = Caux.mk_ctype $ AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
            E.return $
              C.Ewseq [Just a_lvalue] core_e
                (C.Easeq (Just a_load)
                   (C.Action default (C.Load core_ty_e (C.Esym a_lvalue) Cmm.NA))
                   (C.Paction C.Neg (C.Action default (C.Store core_ty_e
                                          (C.Esym a_lvalue)
                                          (conv_int [Caux.mk_ctype (exp_type_of e); (C.Eop C.OpAdd (C.Esym a_load) Caux.one)])
                                          Cmm.NA)
                                        )
                   )
                )
          end
      
      (* TODO: promotion? + atomicity *)
      | A.AilEunary A.PostfixDecr e -> do E
          a_lvalue <- E.fresh_symbol;
          a_load   <- E.fresh_symbol;
          core_e   <- translate_lvalue stdlib program e; in
            let core_ty_e = Caux.mk_ctype $ AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
            E.return $
              C.Ewseq [Just a_lvalue] core_e
                (C.Ewseq [Just a_load] (Caux.pload core_ty_e (C.Esym a_lvalue) Cmm.NA)
                   (C.Ewseq [] (Caux.pstore core_ty_e
                                            (C.Esym a_lvalue)
                                            (conv_int [Caux.mk_ctype (exp_type_of e); (C.Eop C.OpSub (C.Esym a_load) Caux.one)])
                                            Cmm.NA
                               )
                      (C.Esym a_load)
                   )
                )
          end
      
      (* TODO: check conversion *)
      | A.AilEbinary e1 (A.Arithmetic A.Mul) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2;
          a_mul   <- E.fresh_symbol; in
            let mul_ctx x =
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Elet a_mul (C.Eop C.OpMul (C.Esym a_e1) (C.Esym a_e2))
                   x) in
            if AilTypesAux.is_signed_integer_type (exp_type_of a_expr) then
              E.return $ mul_ctx (overflow [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_mul])
            else
              E.return $ mul_ctx (conv_int [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_mul])
          end
      
      | A.AilEbinary e1 (A.Arithmetic A.Div) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            (* TODO[check] usual arithmetic conversions *)
            let core_e1' = usual_arithmetic_conv (C.Esym a_e1) (exp_type_of e1) (exp_type_of e2) in
            let core_e2' = usual_arithmetic_conv (C.Esym a_e2) (exp_type_of e2) (exp_type_of e1) in
            
            (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                            quotient with any fractional part discarded.105) If the quotient a/b is
                            representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                            behavior of both a/b and a%b is undefined. *)
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (Caux.mk_unseq [core_e1; core_e2])
                (* if the value of the second operand is zero, the behavior is undefined. *)
                (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero)
                   (C.Eundef Undefined.Division_by_zero)
                   (C.Eop C.OpDiv core_e1' core_e2')
                )
          end
      
      | A.AilEbinary e1 (A.Arithmetic A.Mod) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            (* TODO[check] usual arithmetic conversions *)
            let core_e1' = usual_arithmetic_conv (C.Esym a_e1) (exp_type_of e1) (exp_type_of e2) in
            let core_e2' = usual_arithmetic_conv (C.Esym a_e2) (exp_type_of e2) (exp_type_of e1) in
            
            (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                            quotient with any fractional part discarded.105) If the quotient a/b is
                            representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                            behavior of both a/b and a%b is undefined. *)
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (Caux.mk_unseq [core_e1; core_e2])
                (* if the value of the second operand is zero, the behavior is undefined. *)
                (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero)
                   (C.Eundef Undefined.Modulo_by_zero)
                   (C.Eop C.OpMod core_e1' core_e2')
                )
          end
      
      (* DONE (check promotion stuff) *)
      | A.AilEbinary e1 (A.Arithmetic A.Shl) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          a_res   <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
              (* (§6.5.7#2) if a_e2 < 0 then undef *)
              (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
                 (C.Eundef Undefined.Negative_shift)
              
              (* if width{ty} <= a_e2 then undef *)
              (* TODO: [ty] should be the promoted type of [e1] *)
              (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (ctype_width [Caux.mk_ctype result_ty]) (C.Esym a_e2))
                                   (C.Eop C.OpEq (ctype_width [Caux.mk_ctype result_ty]) (C.Esym a_e2))) (* TODO: check the test about the width *)
                 (C.Eundef Undefined.Shift_too_large)
              
              (* else [...] *)
                 (if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                    (* mod (a_e1 * exp(2, a_e2)) (max{ty}+1) *)
                     C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (C.Eop C.OpExp (C.Econst $ Mem.mk_integer 2) (C.Esym a_e2)))
                                   (C.Eop C.OpAdd (Caux.ctype_max $ Caux.mk_ctype result_ty) Caux.one)
                  else (* e1 has a signed type *)
                    (* if a_e2 < 0 then undef *)
                    (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
                       (C.Eundef Undefined.Negative_left_shift)
                       (* let a_res = mod (a_e1 * exp(2, a_e2)) (max{ty}+1) in [...] *)
                       (C.Elet a_res (C.Eop C.OpMod (C.Eop C.OpMul (C.Esym a_e1) (C.Eop C.OpExp (C.Econst $ Mem.mk_integer 2) (C.Esym a_e2)))
                                                    (C.Eop C.OpAdd (Caux.ctype_max $ Caux.mk_ctype result_ty) Caux.one))
                          (* not representable(ty, a_res) then undef *)
                          (C.Eif (C.Enot (is_representable [C.Esym a_res; Caux.mk_ctype result_ty]))
                             (C.Eundef Undefined.Negative_left_shift)
                          (* else  *)
                             (C.Esym a_res)
                          )
                       )
                    )
                 )
              )
              )
          end
      
      (* DONE (check promotion stuff) *)
      (* see §6.5.7#5 *)
      | A.AilEbinary e1 (A.Arithmetic A.Shr) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
              (* (§6.5.7#2) if a_e2 < 0 then undef *)
              (C.Eif (C.Eop C.OpLt (C.Esym a_e2) Caux.zero)
                 (C.Eundef Undefined.Negative_shift)
              
              (* if width{ty} <= a_e2 then undef *)
              (* TODO: [ty] should be the promoted type of [e1], so result_ty should be fine *)
              (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (ctype_width [Caux.mk_ctype result_ty]) (C.Esym a_e2))
                                   (C.Eop C.OpEq (ctype_width [Caux.mk_ctype result_ty]) (C.Esym a_e2))) (* TODO: check the test about the width *)
                 (C.Eundef Undefined.Shift_too_large)
              
              (* else [...] *)
              (let expr = C.Eop C.OpDiv (C.Esym a_e1) (C.Eop C.OpExp (C.Econst $ Mem.mk_integer 2) (C.Esym a_e2)) in
               if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                 (* If E1 has an unsigned type *)
                 expr
               else
                 (* or if E1 has a signed type and a nonnegative value [...]
                    If E1 has a signed type and a negative value, the resulting
                   value is implementation-defined. *)
                 C.Eif (C.Eop C.OpLt (C.Esym a_e1) Caux.zero)
                   (C.Ecall (C.Impl Implementation_.SHR_signed_negative) [Caux.mk_ctype (ctype_of e1) ; C.Esym a_e1; C.Esym a_e2])
                   expr)
              ))
          end
      
      (* DONE (check promotion stuff) *)
      | A.AilEbinary e1 (A.Arithmetic A.Band) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
              (bitwise_AND [Caux.mk_ctype result_ty; C.Esym a_e1; C.Esym a_e2])
                        end
      
      (* DONE (check promotion stuff) *)
      | A.AilEbinary e1 (A.Arithmetic A.Bxor) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
              (bitwise_XOR [Caux.mk_ctype result_ty; C.Esym a_e1; C.Esym a_e2])
          end
      
      (* DONE (check promotion stuff) *)
      | A.AilEbinary e1 (A.Arithmetic A.Bor) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
              (bitwise_OR [Caux.mk_ctype result_ty; C.Esym a_e1; C.Esym a_e2])
          end







(* ============= CLEAN up to here ============= *)


        (* NOTE: this is not enought *)
      | A.AilEident id ->
          if AilTypesAux.is_function result_ty then
            E.return (Caux.cfunction_const id)
          else
            E.return $ Caux.pload (Caux.mk_ctype result_ty) (C.Esym id) Cmm.NA
      
      
      
      
      | A.AilEunary A.Address (A.AnnotatedExpression _ (A.AilEunary A.Indirection e)) ->
          translate_expression e
      
      | A.AilEunary A.Address e ->
          if AilTypesAux.is_object result_ty then
            translate_lvalue stdlib program e
          else
            translate_function_designator e
      
      | A.AilEunary A.Indirection e -> do E
          (* TODO: temporary  *)
          a_e    <- E.fresh_symbol;
          core_e <- translate_expression e; in
            (* shouldn't be a real load ? *)
            E.return $ C.Ewseq [Just a_e] core_e
                       (Caux.pload (Caux.mk_ctype result_ty) (C.Esym a_e) Cmm.NA)
          end

      
      | A.AilEbinary e1 (A.Arithmetic A.Add) e2 ->
          let ty1 = exp_type_of e1 in
          let ty2 = exp_type_of e2 in
          E.fresh_symbol          >>= fun a_e1    ->
          E.fresh_symbol          >>= fun a_e2    ->
          if AilTypesAux.is_arithmetic ty1 && AilTypesAux.is_arithmetic ty2 then
            (* (§6.5.6#4) If both operands have arithmetic type, the usual arithmetic conversions are
                          performed on them. *)
            translate_expression e1 >>= fun core_e1 ->
            translate_expression e2 >>= fun core_e2 ->
            let common_ty = fromJust $ AilTypesAux.usual_arithmetic tmp_implementation (exp_type_of e1) (exp_type_of e2) in
            let conv_e1 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e1] in
            let conv_e2 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e2] in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (Caux.mk_unseq [core_e1; core_e2])
                (if AilTypesAux.is_signed_integer_type (exp_type_of a_expr) then
                   (* if the E.return type is signed, then there is an undefined behaviour
                      in the presence of an arithmetic overflow *)
                   overflow [Caux.mk_ctype (exp_type_of a_expr); C.Eop C.OpAdd conv_e1 conv_e2]
                 else
                   (* otherwise, bring back the value from Z to the result type *)
                   conv_int [Caux.mk_ctype (exp_type_of a_expr); C.Eop C.OpAdd conv_e1 conv_e2])
          else
            (* otherwise, we have some pointer arithmetic *)
            (if AilTypesAux.is_arithmetic ty1 then translate_expression e1 else translate_lvalue stdlib program e1) >>= fun core_e1 ->
            (if AilTypesAux.is_arithmetic ty2 then translate_expression e2 else translate_lvalue stdlib program e2) >>= fun core_e2 ->
            (* TODO: check *)
            E.fresh_symbol >>= fun _ (* TODO: a_shift *) ->
            match (AilTypesAux.lvalue_coercion ty1, AilTypesAux.lvalue_coercion ty2) with
              | (Right (AilTypes.Pointer _ ptr_ty (* TODO: ty1' *)), _) ->
                  E.return $
                    C.Ewseq [Just a_e1; Just a_e2] (Caux.mk_unseq [core_e1; core_e2])
                      (C.Eaction (C.Paction C.Pos (C.Action default (C.Ptr C.PtrShift [Caux.mk_ctype ptr_ty; C.Esym a_e1; C.Esym a_e2]))))
(*
                        (Boot.assert_false $ "pointer_shift (left)> " ^
                           Boot.pp_ail_ctype ty1 ^ " + " ^ Boot.pp_ail_ctype ty2)
*)
              | (_, Right (AilTypes.Pointer _ ptr_ty (* TODO: ty2' *))) ->
                  E.return $
                      (C.Eaction (C.Paction C.Pos (C.Action default (C.Ptr C.PtrShift [Caux.mk_ctype ptr_ty; C.Esym a_e2; C.Esym a_e1]))))
(*
                      C.Ewseq [Just a_e1; Just a_e2] (Caux.mk_unseq [core_e1; core_e2])
                        (Boot.assert_false $ "pointer_shift (right)> " ^
                           Boot.pp_ail_ctype ty1 ^ " + " ^ Boot.pp_ail_ctype ty2)
*)
              | (_, _) ->
                  Boot.assert_false "WTF" (* "this case implies the expression was ill-typed." *)
            end
            

(*
              if AilTypesAux.pointer (exp_type_of e1) then
                (* TODO: temporary hack *)
                E.return $
                  C.Esseq [Just a_e1; Just a_e2] (Caux.mk_unseq [core_e1; core_e2])
                    (C.Elet a_shift (C.Eshift a_e1 (C.Eop C.OpMul (C.Esym a_e2) (C.sizeof $ Caux.mk_ctype (exp_type_of e1))))
                       (C.Esseq [] (C.Esame (C.Esym a_e1) (C.Esym a_shift))
                          (C.Esym a_shift)))
              else
              
 *)

              
(*              Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.ADD) e1 e2 <pointer case>: TODO" *)
      
      | A.AilEbinary e1 (A.Arithmetic A.Sub) e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2;
          a_sub   <- E.fresh_symbol; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              let sub_ctx x =
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Elet a_sub (C.Eop C.OpSub (C.Esym a_e1) (C.Esym a_e2))
                     x) in
              if AilTypesAux.is_signed_integer_type (exp_type_of a_expr) then
                E.return $ sub_ctx (overflow [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_sub])
              else
                E.return $ sub_ctx (conv_int [Caux.mk_ctype (exp_type_of a_expr); C.Esym a_sub])
            
            else (*if T.is_integer_type (Annotate.exp_type_of e2) then*)
              (* Pointer arithmetic. *)
              (* TODO: pointer arith *)
              Boot.assert_false "[Translation.translate_expression] #A.BINARY (A.ARITHMETIC A.SUB) e1 e2 <pointer case>: TODO"
          end
      
      | A.AilEbinary e1 A.Comma e2 -> do E
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $ C.Esseq [] core_e1 core_e2
          end
      
      | A.AilEbinary e1 A.And e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1] core_e1
                (C.Eif (C.Eop C.OpEq (C.Esym a_e1) Caux.zero)
                       Caux.zero
                       (C.Ewseq [Just a_e2] core_e2
                         (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero) Caux.zero Caux.one)
                       )
                )
          end
      
      | A.AilEbinary e1 A.Or e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            E.return $
              C.Ewseq [Just a_e1] core_e1
                (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e1) Caux.zero))
                       Caux.one
                       (C.Ewseq [Just a_e2] core_e2
                         (C.Eif (C.Eop C.OpEq (C.Esym a_e2) Caux.zero) Caux.zero Caux.one)
                       )
                )
          end
      
      | A.AilEbinary e1 A.Lt e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              let common_ty = fromJust $ AilTypesAux.usual_arithmetic tmp_implementation (exp_type_of e1) (exp_type_of e2) in
              let conv_e1 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e1] in
              let conv_e2 = conv_int [Caux.mk_ctype common_ty; C.Esym a_e2] in
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Eif (C.Eop C.OpLt conv_e1 conv_e2) Caux.one Caux.zero)
            else
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.LT e1 e2 <pointers case>: TODO"
          end
      
      | A.AilEbinary e1 A.Gt e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Eif (C.Enot (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2))))
                     Caux.one
                     Caux.zero
                  )
            else
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.LT e1 e2 <pointers case>: TODO"
          end
      
      | A.AilEbinary e1 A.Le e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Eif (C.Eop C.OpOr (C.Eop C.OpLt (C.Esym a_e1) (C.Esym a_e2)) (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)))
                         Caux.one
                         Caux.zero
                  )
            else (* MUST BE: both operands are pointers to qualified or unqualified versions of compatible object types. *)
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.LE e1 e2 <pointers case>: TODO"
          end
      
      (* TODO: not doing the typing stuff for now *)
      | A.AilEbinary e1 A.Ge e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Eif (C.Eop C.OpLt (C.Esym a_e2) (C.Esym a_e1))
                         Caux.one
                         Caux.zero
                  )
            else
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.GE e1 e2 <pointers case>: TODO"
          end
      
      | A.AilEbinary e1 A.Eq e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)) Caux.one Caux.zero)
            else if AilTypesAux.is_pointer (exp_type_of e1) && AilTypesAux.is_pointer (exp_type_of e2) then
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.EQ e1 e2 <both pointers case>: TODO"
            else if Aaux.is_null_pointer_constant e1 then
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.EQ e1 e2 <both pointers case, and e1 null constant>: TODO"
            else
              Boot.assert_false "[Translation.translate_expression] #A.BINARY A.EQ e1 e2 <both pointers case, and e1 NOT null constant>: TODO"
          end
      
      | A.AilEbinary e1 A.Ne e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          a_cmp   <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Eif (C.Eop C.OpEq (C.Esym a_e1) (C.Esym a_e2)) Caux.zero Caux.one)
            else
              E.return $
                C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                  (C.Ewseq [Just a_cmp] (
                    C.Eaction (C.Paction C.Pos (C.Action default (C.Ptr C.PtrEq [C.Esym a_e1; C.Esym a_e2])))
                  )
                    (C.Eif (C.Esym a_cmp) Caux.zero Caux.one))
          end
      
      | A.AilEassign e1 e2 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          core_e1 <- translate_lvalue stdlib program e1;
          core_e2 <- translate_expression e2; in
            let core_ty_e1 = Caux.mk_ctype $ AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1)) in
            E.return $
              C.Ewseq [Just a_e1; Just a_e2] (C.Eunseq [core_e1; core_e2])
                (C.Ewseq [] (C.Eaction (C.Paction C.Pos (C.Action default (C.Store core_ty_e1
                                                  (C.Esym a_e1)
                                                  (conv [Caux.mk_ctype (exp_type_of e2); Caux.mk_ctype (exp_type_of e1); C.Esym a_e2])
                                                  Cmm.NA)
                                               )
                                       )
                            )
                           (C.Esym a_e2))
          end
      
      (*
         (std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
         expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
         to an indeterminately-sequenced function call, the operation of a compound) *)
      | A.AilEcompoundAssign e1 aop e2 ->
(*          Boot.assert_false $ "TODO: compound assign: " ^ (Boot.pp_ail_expr a_expr) *)
          (* TODO: this is a TEMPORARY HACK *)
          let A.AnnotatedExpression annot2 _ = e2 in
          translate_expression $ A.AnnotatedExpression annot (A.AilEassign e1 (A.AnnotatedExpression annot2 (A.AilEbinary e1 (A.Arithmetic aop) e2)))
      
      (* TODO: conv_int on e2 and e2 !!!!!!! *)
      | A.AilEcond e1 e2 e3 -> do E
          a_e1    <- E.fresh_symbol;
          a_e2    <- E.fresh_symbol;
          a_e3    <- E.fresh_symbol;
          core_e1 <- translate_expression e1;
          core_e2 <- translate_expression e2;
          core_e3 <- translate_expression e3; in
            if AilTypesAux.is_arithmetic (exp_type_of e1) && AilTypesAux.is_arithmetic (exp_type_of e2) then
              E.return $
                C.Ewseq [Just a_e1] core_e1
                  (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e1) Caux.zero))
                         core_e2
                         core_e3)
            else
              Boot.assert_false "[Translation.translate_expression] #A.CONDTIONAL e1 e2 e3 <pointers case>: TODO"
          end
      
      | A.AilEcast _ ty e -> do E
          a_e    <- E.fresh_symbol;
          core_e <- translate_expression e; in
            E.return $
              C.Ewseq [Just a_e] core_e
                (conv [Caux.mk_ctype (exp_type_of e); Caux.mk_ctype ty; C.Esym a_e])
          end
      
      
(*
      (* TODO: a bit hackish *)
      | A.AilEcall (A.AnnotatedExpression _ (A.AilEbuiltin str)) es ->
          match (str, es) with
            | ("atomic_load_explicit", [object_e; order_e]) ->
                (* TODO: for now we don't allow complicated expressions for order_e *)
                E.return $
                  E.fresh_symbol >>= fun a_object ->
                  translate_expression e
                  C.
          end
*)
      
      
      
      (* TODO:
           * (§6.5.2.2#6) since we don't support prototype-less functions, we don't do
                          "default argument promotions"
       *)
      | A.AilEcall e es -> do E
          a_e    <- E.fresh_symbol;
          core_e <- translate_expression e; in
            match e with
              | A.AnnotatedExpression _ (A.AilEident fid) ->
                  (* If the function is just declared in a prototype but not defined,
                     assume it is provided by the implementation. *)
                  let fname =
                    if is_defined_ail_function fid program then
                      C.Sym fid
                    (* TODO: this is dirty *)
                    else match fid with
                      | Symbol.Symbol _ Nothing ->
                          Boot.assert_false "TODO: error"
                      | Symbol.Symbol _ (Just str) ->
                          C.Impl (Implementation_.StdFunction str)
                    end in
                  
                  if List.length es = 0 then
                    (* if there are no arguments, we don't need all the temporary object creation stuff *)
                    E.return $ C.Eproc default fname []
                  else
                    (* TODO: variadic case *)
                    let (return_ty, params, is_variadic) =
                      match Context.lookup (=) (snd program).A.declarations fid with
                        | Just (A.Decl_function return_ty params is_variadic is_inline is_Noreturn) ->
                            (return_ty, params, is_variadic)
                        | _ ->
                           Boot.assert_false "[Translate] impossible error: TODO move to Exception.t"
                      end in
                    let n = List.length es in
                    
                    (* symbolic names for the temporary objects and init value *)
                    E.replicateM n E.fresh_symbol >>= fun as_tmp  ->
                    
                    (* create actions for the temporary objects *)
                    let core_creates =
                      if is_variadic then
                        (* TODO: check the std *)
                        List.map (fun e ->
                          let c_ty = Caux.mk_ctype (ctype_of e) in
                          Caux.pcreate (Caux.alignof c_ty) c_ty []
                        ) es
                      else
                        List.map (fun (_, ty) ->
                          let c_ty = Caux.mk_ctype ty in
                          Caux.pcreate (Caux.alignof c_ty) c_ty []) params in
                    
                    (* the list of "Nothing" is empty if the function is not variadic *)
                    let params =
                      List.map (fun z -> Just z) params ++ (List.replicate (n - List.length params) Nothing) in
                    
                    
                    (* their initialisations *)
                    E.mapM (fun (a, param_opt, e) ->
                      let _ = Boot.output_string "BOOM" in
                      
                      E.fresh_symbol         >>= fun a_init ->
                      translate_expression e >>= fun core_e ->
                      let ty = match param_opt with
                        | Just (_, ty) -> ty
                        | Nothing      -> ctype_of e (* TODO: check the std *)
                      end in
                      E.return $
                        C.Ewseq [Just a_init] core_e
                          (Caux.pstore (Caux.mk_ctype ty) (C.Esym a) (C.Esym a_init) Cmm.NA)
                    ) (zip3 as_tmp params es) >>= fun core_inits ->
                    
                    (* their kill actions *)
                    let core_kills = List.map (Caux.pkill -| C.Esym) as_tmp in
                    
                    (* symbolic name for the call result *)
                    E.fresh_symbol >>= fun a_call ->
                    E.return $
                      C.Ewseq (List.map (fun z -> Just z) as_tmp) (Caux.mk_unseq core_creates)
                        (C.Ewseq [] (Caux.mk_unseq core_inits)
                          (C.Ewseq [Just a_call] (C.Eindet $ C.Eproc default fname (List.map C.Esym as_tmp))
                            (C.Ewseq [] (Caux.mk_unseq core_kills)
                              (C.Esym a_call)
                            )
                          )
                        )
              | _ -> Boot.assert_false "[Translation.translate_exp, A.CALL e es] a function id is declared with a non-function type"
	    end
          end
      
      | A.AilEconst (A.ConstantInteger (A.IntegerConstant i _ _)) ->
          E.return (C.Econst $ Mem.mk_integer i)

      (* TODO *)
      | A.AilEconst (A.ConstantCharacter (_, str)) ->
          (* TODO: making an implementation fix here (ASCII) *)
          E.return (C.Econst $ Mem.mk_integer (Decode.decode_character_constant str))
      
      | A.AilEbuiltin str ->
          let mk_ctype_min ty = C.Ecall (C.Impl Implementation_.Ctype_min) [C.Ectype ty] in
          let mk_ctype_max ty = C.Ecall (C.Impl Implementation_.Ctype_max) [C.Ectype ty] in
          E.return $match str with
            | "INT8_MIN" ->
                mk_ctype_min (Cty.builtin_signed_integer_type "int8_t")
            | "INT16_MIN" ->
                mk_ctype_min (Cty.builtin_signed_integer_type "int16_t")
            | "INT32_MIN" ->
                mk_ctype_min (Cty.builtin_signed_integer_type "int32_t")
            | "INT64_MIN" ->
                mk_ctype_min (Cty.builtin_signed_integer_type "int64_t")
            | "INT8_MAX" ->
                mk_ctype_max (Cty.builtin_signed_integer_type "int8_t")
            | "INT16_MAX" ->
                mk_ctype_max (Cty.builtin_signed_integer_type "int16_t")
            | "INT32_MAX" ->
                mk_ctype_max (Cty.builtin_signed_integer_type "int32_t")
            | "INT64_MAX" ->
                mk_ctype_max (Cty.builtin_signed_integer_type "int64_t")
            | "UINT8_MAX" ->
                mk_ctype_max (Cty.builtin_unsigned_integer_type "int8_t")
            | "UINT16_MAX" ->
                mk_ctype_max (Cty.builtin_unsigned_integer_type "int16_t")
            | "UINT32_MAX" ->
                mk_ctype_max (Cty.builtin_unsigned_integer_type "int32_t")
            | "UINT64_MAX" ->
                mk_ctype_max (Cty.builtin_unsigned_integer_type "int64_t")
          end
      
        (* TODO: prefix + check, §6.4.5#6 *)
      | A.AilEstr (pref_opt, strs) ->
          let elem_ty = match pref_opt with
            | Nothing ->
                (* STD §6.4.5#6, sentence 3 *)
                Cty.Basic (Aty.Integer Aty.Char)
            | Just A.Enc_u8 ->
                (* STD §6.4.5#6, sentence 4 *)
                Cty.Basic (Aty.Integer Aty.Char)
            | Just A.Enc_u ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char16_t
            | Just A.Enc_U ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char32_t
            | Just A.Enc_L ->
                (* STD §6.4.5#6, sentence 5 *)
                Cty.Builtin "whcar_t"
          end in

          E.fresh_symbol >>= fun a ->
          (* TODO: making an implementation fix here (ASCII), not doing prefix properly *)
          let elems = (List.map (fun c_str ->
            Mem.mk_integer (Decode.decode_character_constant c_str)
          ) strs) ++ [Mem.mk_integer 0] in
          E.register_string_literal a (Cty.Array elem_ty (Just (integerFromNat $ List.length elems))) (C.Econst $ Mem.mk_array elems) >>
          E.return (C.Esym a)

(*

n := | str |

let strong a  = create("char[n+1]", <alignof>("char[n+1]")) in
store("char[n+1]", a, array(...)) ;
a


          E.return (C.Econst $ C.Cstring (String.toCharList str)) (* TODO: this is a hack, this should be a pointer to a global char pointer *)
*)
      
      
      | A.AilEsizeof _ (Aty.Basic (Aty.Integer Aty.Char))                 -> E.return Caux.one
      | A.AilEsizeof _ (Aty.Basic (Aty.Integer (Aty.Signed Aty.Ichar)))   -> E.return Caux.one
      | A.AilEsizeof _ (Aty.Basic (Aty.Integer (Aty.Unsigned Aty.Ichar))) -> E.return Caux.one
      | A.AilEsizeof _ ty ->
          E.return (Caux.sizeof $ Caux.mk_ctype ty)
      
      | A.AilEalignof _ ty ->
          E.return (Caux.alignof $ Caux.mk_ctype ty)

(*
  TODO: need to bring them back to the new Ail
      | A.MEMBEROF e x ->
      | A.MEMBEROFPTR e x ->

      | A.EXPR_SIZEOF e ->
          E.return (C.sizeof $ Caux.mk_ctype (Annotate.ctype_of e))

    | A.StringLiteral lit ->

    | A.Malloc e -> do E
        a_e    <- E.fresh_symbol;
        core_e <- translate_expression e; in
          E.return $ C.Ewseq [Just a_e] core_e (Caux.palloc (C.Esym a_e) [])
        end
    
    | A.Free e -> do E
        a_e    <- E.fresh_symbol;
        core_e <- translate_expression e; in
          E.return $ C.Ewseq [Just a_e] core_e (Caux.pkill (C.Esym a_e))
        end
    
    | A.Memcmp e1 e2 e3 ->
    | A.Memcpy e1 e2 e3 ->
    
    | A.Assert e -> do E
        a_e    <- E.fresh_symbol;
        core_e <- translate_expression e; in
          E.return $
            C.Ewseq [Just a_e] core_e
              (C.Eif (C.Eop C.OpEq (C.Esym a_e) Caux.zero) C.Eerror C.Eskip)
        end
    
    | A.ConstArray es ->
    | A.ConstStructUnion field_es ->
    | A.Offsetof ty x ->
*)
    end








(* translate_stmt Pmap.empty program program.A.main C.Constants.return s *)

(* TODO[über HACK] `lasts' is the last of symbolic names saving the last statement for each block we are in
                   we need to remember them to annotate Erun/Esave coming from a C label/goto because these symbols
                   MAY (the fact it is a may is pretty disgusting) be in the continuations of the generated Esave (...)

RAAAAAAAAHHH: this doesn't work when the label is in a block the goto doesn't belong to ......
*)

module St = State
open State_operators

type collect_cases_state = <|
  found_default: bool;
  cases: list A.integerConstant
|>

val     collect_cases_: A.statement GenTypes.genTypeCategory -> St.t unit collect_cases_state
let rec collect_cases_ (A.AnnotatedStatement _ stmt) =
  let register_case n =
    St.update (fun s -> <| s with cases= n :: s.cases |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock _ ss ->
        St.mapM_ collect_cases_ ss
    | A.AilSif _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.AilSwhile _ s ->
        collect_cases_ s
    | A.AilSdo s _ ->
        collect_cases_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ _ ->
        St.return ()
    | A.AilScase n s ->
        register_case n >> collect_cases_ s
    | A.AilSdefault s ->
        register_default >> collect_cases_ s
    | A.AilSlabel _ s ->
        collect_cases_ s
    | A.AilSgoto _ ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
(*    | PAR of list (statement_l 'a) *)
  end
let collect_cases s =
  snd $ St.run (collect_cases_ s) <| found_default= false; cases= [] |>


open Operators

let rec translate_stmt stdlib program f d_default d_cases d_loop d_break (A.AnnotatedStatement _ stmt) =
  let translate_expression e = translate_expression stdlib program e                              in
  let translate_stmt_ s      = translate_stmt stdlib program f d_default d_cases d_loop d_break s in
  let mk_stdcall fname       = mk_stdcall stdlib fname                                            in
  let conv_int               = mk_stdcall "conv_int"                                              in
  match stmt with
    | A.AilSskip ->
        E.return C.Eskip
    
    | A.AilSexpr e ->
        translate_expression e
    
    | A.AilSblock binds ss ->
        let ids = [id | forall ((id, _) MEM binds) | true] in
        let decls = [(id,ty) | forall ((id, (qs, ty)) MEM binds) | true] in
        
        (* the symbolic names and create actions for the local variables *)
        let (a_ids, core_creates) =
          mapUnzip (fun (a, ty) ->
            let c_ty = Caux.mk_ctype ty in
            (Just a, Caux.pcreate (Caux.alignof c_ty) c_ty [f; a])
          ) decls in
        
        E.push_block_objects ids >>
        
        (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
                 but it may be nasty to the check.
                 For non-void function however we know (?) that the must be these returns ?? so we could drop the kills here *)
        (* the kill actions for the local variables *)
        let (core_kills) =
          List.map (Caux.pkill -| C.Esym -| fst) decls in
        
(*
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt program f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               E.return ([], core_s))
                     (* TODO: adding the a_last here is pretty disgusting *)
                     (fun s -> translate_stmt program f d_loop d_break (a_last :: lasts) s >>= fun core_s ->
                               E.return ([Just a_last], core_s))
                     ss >>= fun a_opts_core_ss ->
*)
        E.mapM (fun s -> translate_stmt_ s >>= fun core_s -> E.return core_s) ss >>= fun core_ss ->
        
        E.pop_block_objects >>
        
        E.return
          (C.Esseq a_ids (Caux.mk_unseq core_creates)
             (foldr (fun core_s acc -> C.Esseq [] core_s acc) (Caux.mk_unseq core_kills) core_ss)
          )
(*

(*      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
*)
      let n     = List.length decls in

      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx: C.expr zero -> C.expr zero =
        let (syms, xs) = mapUnzip (fun (a, ty) -> (Just a, Caux.pcreate (Caux.mk_ctype ty) [])) (List.rev decls) in
        match n with
          | 0 -> fun x -> x
          | 1 -> C.Ewseq syms (List.hd xs)
          | _ -> C.Ewseq syms (C.Eunseq xs)
        end in
      
      (* prepare the code killing the objects. *)
      let kills_ctx = let xs = List.map (fun (a, _) -> Caux.pkill (C.Esym a)) decls in
                      match n with
                        | 0 -> fun x -> x
                        | 1 -> C.Ewseq [] (List.hd xs)
                        | _ -> C.Ewseq [] (C.Eunseq xs)
                      end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt_ s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt_ s >>= fun core_s ->
                               E.return ([Just a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) ->
                   if Caux.is_pure stmt then (match _as with
                                | [Just a] -> C.Elet a stmt acc
                                | []       -> acc
                                | _  -> Boot.outOfHomeomorphism "BOOM" end)
                   else C.Ewseq _as stmt acc)
                    (kills_ctx (if List.length ss = 0 then C.Eskip else C.Esym a_last))
                    (List.rev core_ss))

*)  
    
    | A.AilSif e s1 s2 -> do E
        a_test  <- E.fresh_symbol;
        core_e  <- translate_expression e;
        core_s1 <- translate_stmt_ s1;
        core_s2 <- translate_stmt_ s2; in
          E.return $ C.Ewseq [Just a_test] core_e
                       (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_test) Caux.zero)) core_s1 core_s2)
        end
    
    | A.AilSwhile e s -> do E
        a_e        <- E.fresh_symbol;
        d_loop     <- E.fresh_named_symbol "loop";
        d_break    <- E.fresh_named_symbol "break";
        core_e     <- translate_expression e;
        core_s     <- translate_stmt stdlib program f d_default d_cases (Just d_loop) (Just d_break) s;
        visible_as <- E.get_visible_objects; in
          (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
          E.return $
            C.Esave d_loop [ (a, Cty.Void)  | forall (a MEM visible_as) | true ]
              (C.Esseq [Just a_e] core_e
                 (C.Eif (C.Enot (C.Eop C.OpEq (C.Esym a_e) Caux.zero))
                    (C.Esseq [] core_s (C.Erun default d_loop [ (a, C.Esym a) | forall (a MEM visible_as) | true ]))
                    (C.Esave d_break [ (a, Cty.Void)  | forall (a MEM visible_as) | true ] C.Eskip)
                 )
              )
        end
    
    | A.AilSdo s e -> do E
        d_loop     <- E.fresh_symbol;
        d_break    <- E.fresh_symbol;
        core_s     <- translate_stmt stdlib program f d_default d_cases (Just d_loop) (Just d_break) s;
        core_e     <- translate_expression e;
        a          <- E.fresh_symbol;
        visible_as <- E.get_visible_objects; in
          (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
          E.return $
            C.Esave d_loop [ (a, Cty.Void)  | forall (a MEM visible_as) | true ]
              (C.Esseq [] core_s
                 (C.Esseq [Just a] core_e
                    (C.Eif (C.Eop C.OpEq (C.Esym a) Caux.zero)
                       (C.Esave d_break [ (a, Cty.Void)  | forall (a MEM visible_as) | true ] C.Eskip)
                       (C.Erun default d_loop [ (a, C.Esym a) | forall (a MEM visible_as) | true ])
                    )
                 )
              )
        end
    
    | A.AilSbreak -> do E
        visible_as <- E.get_visible_objects; in
          E.return $ C.Erun default (fromJust d_break) [ (a, C.Esym a) | forall (a MEM visible_as) | true ]
        end
    
    | A.AilScontinue -> do E
        visible_as <- E.get_visible_objects; in
          E.return $ C.Erun default (fromJust d_loop) [ (a, C.Esym a) | forall (a MEM visible_as) | true ]
        end
    
    | A.AilSreturnVoid -> do E
        visible_as <- E.get_visible_objects; in
          E.return (C.Esseq [] (Caux.mk_unseq $ List.map (Caux.pkill -| C.Esym) visible_as) (C.Eret C.Eunit))
        end
    
    | A.AilSreturn e -> do E
        core_e     <- translate_expression e;
        a_e        <- E.fresh_symbol;
        visible_as <- E.get_visible_objects; in
          let A.AnnotatedExpression ty _ = e in
          let return_ty = match Context.lookup (=) (snd program).A.declarations f with
            | Just (A.Decl_function return_ty _ _ _ _) ->
                return_ty
            | _ ->
                Boot.assert_false "[Translation.translate_expression A.Return] impossible error: TODO move to Exception.t"
          end in
          E.return $
            C.Esseq [Just a_e] core_e
              (C.Esseq [] (Caux.mk_unseq $ List.map (Caux.pkill -| C.Esym) visible_as)
                 (C.Eret (conv_int [Caux.mk_ctype return_ty; C.Esym a_e]))
              )
        end
    
    (* Need to do the promotions *)
    (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
    | A.AilSswitch e s ->
        translate_expression e >>= fun core_e ->
        E.fresh_symbol                        >>= fun a_e    ->
        (* TODO: should properly interpret the integer constants *)
        let ((found_default, ns) : bool * list integer) =
          let x = collect_cases s in
          (x.found_default, List.map (fun (A.IntegerConstant z _ _) -> z) x.cases) in
        E.replicateM (List.length ns) (E.fresh_named_symbol "case") >>= fun (ds : list C.ksym) ->
        let d_cases' = foldl (fun acc (n, d) ->
          Map.insert n d acc) Map.empty (zip ns ds) in
        E.fresh_named_symbol "default" >>= fun d_default' ->
        (if found_default then
          E.fresh_named_symbol "break"
        else
            E.return d_default') >>= fun d_break' ->
        E.get_visible_objects  >>= fun visible_as      ->
        let run_as = [ (a, C.Esym a) | forall (a MEM visible_as) | true ] in
        translate_stmt stdlib program f (Just d_default') (Just d_cases') d_loop (Just d_break') s >>= fun core_s ->
        E.return $
          C.Ewseq [Just a_e] core_e
            (foldl (fun acc (n, d) ->
              C.Eif (C.Eop C.OpEq (C.Esym a_e) (C.Econst $ Mem.mk_integer n))
                (C.Erun default d run_as)
                acc
             )
               (C.Ewseq [] (C.Erun default d_default' run_as)
                  (C.Ewseq [] core_s
                     (C.Esave d_break' [ (a, Cty.Void) | forall (a MEM visible_as) | true ] C.Eskip)
                  )
               )
               $ Map_extra.toList d_cases')
    
    (* Need to do the promotions *)
    | A.AilScase n s -> do E
        core_s     <- translate_stmt_ s;
        visible_as <- E.get_visible_objects; in
          (* TODO: should properly interpret the integer constant *)
          E.return $ C.Esave (fromJust $ Map.lookup ((fun (A.IntegerConstant z _ _) -> z) n) (fromJust d_cases)) [ (a, Cty.Void) | forall (a MEM visible_as) | true ] core_s
        end
    
    | A.AilSdefault s -> do E
        core_s     <- translate_stmt_ s;
        visible_as <- E.get_visible_objects; in
          E.return $ C.Esave (fromJust d_default) [ (a, Cty.Void)  | forall (a MEM visible_as) | true ] core_s
        end
    
    | A.AilSlabel l s -> do E
        core_s     <- translate_stmt_ s;
        visible_as <- E.get_visible_objects; in
          (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
          E.return $ C.Esave l [ (a, Cty.Void)  | forall (a MEM visible_as) | true ] core_s
        end
    
    | A.AilSgoto l -> do E
        visible_as <- E.get_visible_objects; in
          E.return $ C.Erun default l [ (a, C.Esym a) | forall (a MEM visible_as) | true ]
        end
    
    | A.AilSdeclaration [] ->
        E.return C.Eskip
    
    | A.AilSdeclaration defns ->
        (* This pass translate the declarations *)
        E.mapM (fun (id, e) -> do E
          a      <- E.fresh_symbol;
          core_e <- translate_expression e; in
          let ty = exp_type_of e in
          let expr = if AilTypesAux.is_pointer ty then C.Esym a else conv_int [Caux.mk_ctype ty; C.Esym a] in
            E.return $ C.Esseq [Just a] core_e
                         (Caux.pstore (Caux.mk_ctype ty) (C.Esym id) expr Cmm.NA) end


(*
          E.fresh_symbol                        >>= fun a      ->
          translate_expression stdlib program e >>= fun core_e ->
          E.return $ C.Esseq [Just a] core_e
                       (Caux.pstore (Caux.mk_ctype (exp_type_of e)) (C.Esym id) (conv_int [Caux.mk_ctype (exp_type_of e); C.Esym a]) Cmm.NA)
 *)
        ) defns >>=
        
        (* This pass combine the translated declarations *)
        E.foldl1M (fun x y -> E.return $ Caux.concat_sseq x y)
  

(*
  TODO: need to bring them back to the new Ail

  | A.PAR ss ->
      E.mapM (translate_stmt_) ss >>= fun core_ss ->
      E.return $ C.Eunseq core_ss
*)

  end




(*
val translate_program:
  C.fun_map unit -> A.program GenTypes.genTypeCategory ->
  E.t (list (C.sym * C.core_base_type * C.expr unit) * C.fun_map unit)
*)

let translate_program stdlib ((startup_sym, sigm) as program) =
  let conv_int = mk_stdcall stdlib "conv_int" in
  
  E.foldlM (fun (gacc, facc) (sym, decl) ->
    match decl with
      | A.Decl_object _ qs ty ->
          (* generate the initialisation code for global variables *)
          let core_ty     = Caux.mk_ctype ty in
          let core_create = Caux.pcreate (Caux.alignof core_ty) core_ty [sym] in
          E.fresh_symbol >>= fun a_global ->
          
          match Context.lookup (=) sigm.A.object_definitions sym with
            | Just expr ->
                (* if the global has an initialisation *)
                E.fresh_symbol                           >>= fun a_e      ->
                translate_expression stdlib program expr >>= fun core_e   ->
                let core_init_e =
                  if AilTypesAux.is_pointer ty then
                    (* TODO: check, might need some pointer to pointer conversion *)
                    C.Esym a_e
                  else
                    conv_int [core_ty; C.Esym a_e] in
                E.return
                  ((sym,
                    C.TyEffect C.BTy_pointer,
                    C.Esseq [Just a_global] core_create
                      (C.Esseq [Just a_e] core_e
                         (* TODO: proper memory order *)
                         (C.Esseq [] (Caux.pstore core_ty (C.Esym a_global) core_init_e Cmm.NA)
                            (C.Eret $ C.Esym a_global)
                         )
                      )
                   ) :: gacc, facc)
            | Nothing ->
                (* otherwise *)
                E.return
                  ((sym,
                    C.TyEffect C.BTy_pointer,
                    C.Esseq [Just a_global] core_create
                      (* TODO: proper memory order *)
                      (C.Esseq [] (Caux.pstore core_ty (C.Esym a_global) Caux.zero Cmm.NA)
                         (C.Eret $ C.Esym a_global)
                      )
                    ) :: gacc, facc)
          end
      
      | A.Decl_function return_ty params is_variadic is_inline is_Noreturn ->
          (* generate the code for the defined Ail functions *)
          match Context.lookup (=) sigm.A.function_definitions sym with
            | Just (param_syms, stmt) ->
                (* making the argument variables visible *)
(* TODO: WIP                E.with_block_objects param_syms *) (
                  translate_stmt stdlib program sym Nothing Nothing Nothing Nothing stmt
                ) >>= fun core_body ->
                
                let core_return =
                  if startup_sym = sym then
                    (* §5.1.2.2.3#1 first sentence *)
                    (* TODO: "If the return type is not compatible with int" *)
                    C.Eret Caux.zero
                  else if return_ty = Aty.Void then
                    C.Eret C.Eunit
                  else
                    (* §6.9.1#12 *)
                    C.Eundef Undefined.Reached_end_of_function in
                
                E.return
                  (gacc,
                   Map.insert sym
                     (C.TyEffect C.BTy_integer (* TODO: this should de address for pointer type *),
                      List.map (fun sym -> (sym, C.BTy_pointer (* TODO: check *))) param_syms,
                      (C.Esseq [] core_body core_return)
                     ) facc)
            | Nothing ->
                E.return (gacc, facc)
          end
    end
  ) ([], Map.empty) (List.reverse sigm.A.declarations) >>= fun (globs, cfuns) ->
  
  (* adding string literals *)
  E.get_string_literals >>= fun xs ->
  E.foldlM (fun acc (sym, ty, e_init) ->
    E.fresh_symbol >>= fun a_lit ->
    let expr =
      C.Esseq [Just a_lit] (Caux.pcreate (Caux.alignof (C.Ectype ty)) (C.Ectype ty) [])
        (C.Esseq [] (Caux.pstore (C.Ectype ty) (C.Esym a_lit) e_init Cmm.NA)
          (C.Eret $ C.Esym a_lit)) in
    E.return $ (sym, C.TyEffect C.BTy_pointer, expr) :: acc
  ) (List.reverse globs) xs >>= fun globs' ->
  E.return (List.reverse globs', cfuns)
(*

  E.foldlM (fun acc (fun_sym, <| A.fun_return_ty=   ret_ty;
                                A.fun_bindings=    fun_args;
                                A.fun_is_variadic= is_variadic;
                                A.fun_body=        fun_body_opt |>) ->
    match fun_body_opt with
      | Just fun_body ->
          (* making the argument variables visible *)
          E.push_block_objects (List.map fst fun_args) >>
          
          (* translate the body to Core *)
          translate_stmt stdlib program fun_sym Nothing Nothing Nothing Nothing fun_body >>= fun core_body ->
          (* removing the argument variables from the "visibles" *)
          E.pop_block_objects >>
          
          (* If we are elaborating the startup function, then we add at the beginning of the body
             the allocations/initialisations of the global variables *)
          
          let e_ret =
            if startup_sym = fun_sym then
              (* §5.1.2.2.3#1 first sentence *)
              (* TODO: "If the return type is not compatible with int" *)
              C.Eret Caux.zero
            
            else if ret_ty = Aty.Void then
              C.Eret C.Eunit
            else
              (* §6.9.1#12 *)
              C.Eundef Undefined.Reached_end_of_function in
          
          (E.return $ Map.insert fun_sym (
                                        C.TyEffect C.BTy_integer (* TODO: this should de address for pointer type *),
                                        List.map (fun (arg, _) -> (arg, C.BTy_pointer (* TODO: check *))) fun_args,
                                        (C.Esseq [] core_body e_ret)
                                      ) acc)
      | Nothing ->
          (* TODO: this corresponds to an Ail function a prototype but no implementation ==> std lib function *)
          E.return acc
    end
  ) Map.empty funs >>= fun cfuns ->
  E.return (cglobs, cfuns)
*)










(* This is the entry function (called from main.ml) *)
let translate stdlib impl (symbol_counter, prog) =
  (* TODO: this is ugly, we shouldn't expose the internals and properly use the Undefined *)
  match (translate_program stdlib prog) (E.init symbol_counter) with
    | U.Defined ((cglobs, cfuns), st) ->
        (st.E.symbol_supply, <| C.main= fst prog; C.stdlib= stdlib; C.impl= impl; C.globs= cglobs; C.funs= cfuns |>)
    | _ ->
        Boot.assert_false "[Translation.translate #_] error in the elaboration"
  end
