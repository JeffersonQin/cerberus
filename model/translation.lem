(* TODO: for now everything is mapped to nonatomics. The translation to atomics
         still needs to be defined *)

open import Pervasives Global Implementation_ Loc String_extra
import State State_operators Translation_effect Loc
open import Translation_aux
import Cmm_csem Mem

import Decode
import Core_typing

import AilSyntax AilSyntaxAux AilTypes AilTypesAux
import GenTypes
import Core Core_aux Undefined

module A    = AilSyntax
module Aaux = AilSyntaxAux
module Aty  = AilTypes


module C    = Core
module Cty  = struct 
  include import Core_ctype
  include import Core_ctype_aux
end
module Caux = Core_aux
module U    = Undefined

module Cmm = Cmm_csem


module E = Translation_effect
module Operators = struct
  let inline (>>=)      = E.bind
  let inline (>>) m f   = E.bind m (fun _ -> f)
  let inline (<$>) f ma = E.bind ma (fun a -> E.return (f a))
  let inline (<*>) mf m = E.bind mf (fun f -> f <$> m)
end

open Operators





(* STD §6.5.13#3, first sentence *)
(* STD §6.5.14#3, first sentence *)
(* STD §6.5.15#4, second sentence *)
(* STD §6.7.10#2 *)
(* STD §6.8.4.1#2, first sentence; second sentence *)
(* STD §6.8.5#4, first sentence *)
(* Some C constructs perform tests on scalar expression, with dynamic semantics
   varying on wether its value "compares equal to 0". The semantics of the quoted
   sentence implicitly refers to that of the C binary equality operator.
   This function turns a [e] scalar expression into a [e == 0], so that elaboration
   of the equality operator can be reused *)
val mkTestExpression: A.expression GenTypes.genTypeCategory -> A.expression GenTypes.genTypeCategory
let mkTestExpression (A.AnnotatedExpression gty _ _ as a_expr) =
  let loc = locOf a_expr in
  let result_gty =
    (* STD §6.5.9#3, third sentence *)
    GenTypes.GenRValueType (GenTypes.GenBasic (GenTypes.GenInteger (GenTypes.Concrete (Aty.Signed Aty.Int_)))) in
  
  let zero_const =
    if AilTypesAux.is_integer (ctype_of a_expr) then
      A.ConstantInteger (A.IConstant 0 A.Octal Nothing)
    else if AilTypesAux.is_floating (ctype_of a_expr) then
      A.ConstantFloating "0.0"
    else if AilTypesAux.is_pointer (ctype_of a_expr) then
      A.ConstantNull
    else
      error "[Translation.mkTestExpression] must be called on scalar expression" in
  A.AnnotatedExpression result_gty loc
    (A.AilEbinary a_expr A.Eq (A.AnnotatedExpression gty loc (A.AilEconst zero_const)))



val translate_program:
  bool -> C.fun_map unit -> A.program GenTypes.genTypeCategory ->
  E.t (list (C.sym * C.core_base_type * C.expr unit) * C.fun_map unit)

val translate:
    bool -> C.fun_map unit -> C.impl -> (UniqueId.supply Symbol.sym) * A.program GenTypes.genTypeCategory ->
    (UniqueId.supply Symbol.sym * C.file unit)


(* ========================================================================== *)


(*
val shiftPathFromMember: A.program GenTypes.genTypeCategory -> Symbol.sym -> Cabs.cabs_identifier -> C.shift_path
let shiftPathFromMember program tag ident =
  match List.lookup tag (snd program).A.tag_definitions with
    | Just (A.StructDef ident_tys) ->
        let sh = fromRight $ List.foldl (fun acc_ (ident', ty) ->
          match acc_ with
            | Left acc ->
                if ident = ident' then
                  if List.null acc then
                    Right [(Caux.proj_ctype ty, Caux.mk_integer_pe 0)]
                  else
                    Right acc
                else
                  Left ((Caux.proj_ctype ty, Caux.mk_integer_pe 1) :: acc)
            | Right acc ->
                Right acc
          end
        ) (Left []) ident_tys in
        sh
    | Just (A.UnionDef ident_tys) ->
        [(Caux.proj_ctype (fromJust "Translation.shiftPathFromMember" $ List.lookup ident ident_tys), Caux.mk_integer_pe 0)]
    
    | Nothing ->
        error ("Translation.shiftPathFromMember: couldn't find a definition for `" ^ show tag ^ "'")
  end
*)


(*
val translate_integerConstant: A.integerConstant -> C.pexpr
let translate_integerConstant iCst =
  C.Pexpr () (C.PEval (C.Vobject (C.OVinteger (
    match iCst with
      | A.IConstant n _ _ ->
          Mem.integer_ival n
      | A.IConstantMax ity ->
          Mem.max_ival ity
      | A.IConstantMin ity ->
          Mem.min_ival ity
    end
  ))))
*)


let translate_memory_order (A.AnnotatedExpression _ _ expr as a_expr) =
  match expr with
    | A.AilEconst (A.ConstantInteger (A.IConstant n _ _)) ->
        match natFromInteger n with
          | 0 -> Cmm.Relaxed
          | 1 -> Cmm.Consume
          | 2 -> Cmm.Acquire
          | 3 -> Cmm.Release
          | 4 -> Cmm.Acq_rel
          | 5 -> Cmm.Seq_cst
          | _ ->
              error ("Translation.translate_memory_order: " ^ show n)
        end
    | _ ->
        error ("Translation.translate_memory_order: " ^ Pp.stringFromAil_expression a_expr)
  end










let rec translate_function_designator stdlib (A.AnnotatedExpression _ (* TODO: loc *) _ expr as a_expr) =
  match (ctype_of a_expr, expr) with
    | (Aty.Pointer _ (Aty.Function has_proto _ params is_variadic), A.AilEident fid) ->
        let fid_pe = match fid with
          | Symbol.Symbol _ (Just "printf") ->
              (* TODO: do this the clean way *)
              match mk_stdcall_aux (function ((Symbol.Symbol _ (Just z)), _) -> z = "printf_proxy" | _ -> false end) (Map_extra.toList stdlib) with
                | Just (f, C.Proc bTy params _) ->
                    C.Pexpr () (C.PEval (C.Vobject (C.OVcfunction (C.Sym f))))
                | Nothing ->
                    error "Translaion.translate_function_designator: couldn't find printf_proxy"
              end
          | _ ->
              Caux.mk_cfunction_pe fid
        end in

        (* TODO: check the std regarding prototype stuff *)
        E.return $
          C.Epure (
            Caux.mk_tuple_pe
              [ fid_pe
              ; Caux.mk_integer_pe (integerFromNat $ List.length params)
              ; Caux.mk_boolean_pe is_variadic ]
          )
    | _ ->
        error "[Translation.translate_function_designator] wildcard case"
  end








(*val prepare_cproc_call: Core.program -> AilSyntax.identifier -> list (Ail.Syntax  *)
and prepare_cproc_call program fid es =
  match fromJust "Translation.prepare_cproc_call" (Context.lookup (=) (snd program).A.declarations fid) with
    | A.Decl_function has_proto return_ty params is_variadic is_inline is_Noreturn ->
        if List.length es <> List.length params then
          (* STD §6.5.2.2#6, sentence 3 *)
          error "WIP: Translation.prepare_cproc_call ==> 'If the number of arguments does not equal the number of parameters, the behavior is undefined'"
        else
          error "WIP: Translation.prepare_cproc_call"
    | _ ->
        error "Translation.prepare_cproc_call, not a Decl_function"
  end





(* STD §6.5.5 Multiplicative operators *)
and translate_div_mod_operator
      translate_rvalue usual_arithmetic_conversion catch_exceptional_condition wrapI
      result_ty aop e1 e2 =
  translate_rvalue e1 >>= fun core_e1   ->
  translate_rvalue e2 >>= fun core_e2   ->
  E.fresh_symbol      >>= fun e1_sym    ->
  E.fresh_symbol      >>= fun e2_sym    ->
  E.fresh_symbol      >>= fun obj1_sym  ->
  E.fresh_symbol      >>= fun obj2_sym  ->
  E.fresh_symbol      >>= fun conv1_sym ->
  E.fresh_symbol      >>= fun conv2_sym ->
  let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let e1_sym_pe    = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym    in
  let e2_sym_pe    = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym    in
  let obj1_sym_pe  = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym  in
  let obj2_sym_pe  = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym  in
  let conv1_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) conv1_sym in
  let conv2_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) conv2_sym in
  let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
  let (ub, core_pe) = match aop with
    | A.Div ->
        (Undefined.UB045a_division_by_zero,
         Caux.mk_op_pe C.OpDiv promoted1_pe conv2_sym_pe)
    | A.Mod ->
        (Undefined.UB045b_modulo_by_zero,
         Caux.mk_if_pe (Caux.mk_op_pe C.OpLt conv1_sym_pe (Caux.mk_integer_pe 0))
           (Caux.mk_op_pe C.OpRem_t conv1_sym_pe conv2_sym_pe)
           (Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpAdd conv1_sym_pe conv2_sym_pe) conv2_sym_pe))
  end in
  (* TODO[check]: When integers are divided, the result of the / operator is the algebraic
                  quotient with any fractional part discarded.105) If the quotient a/b is
                  representable, the expression (a/b)*b + a%b shall equal a; otherwise, the
                  behavior of both a/b and a%b is undefined. *)
    E.return $
      C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                 ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq [core_e1; core_e2]) (
        C.Epure (
          C.Pexpr () (
            C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
              [ (Caux.mk_tuple_pat [ Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype)
                                   ; Caux.mk_empty_pat (C.BTy_loaded oTy) ],
if AilTypesAux.is_signed_integer_type result_ty then
                 Caux.mk_undef_pe Undefined.UB036_exceptional_condition
else
                 Caux.mk_unspecified_pe (Caux.proj_ctype result_ty))
              ; (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded oTy)
                                   ; Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype) ],
                 Caux.mk_undef_pe ub)
              ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                   ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                 Caux.mk_let_pe (Caux.mk_sym_pat conv1_sym (C.BTy_object oTy))
                   promoted1_pe
                 (Caux.mk_let_pe (Caux.mk_sym_pat conv2_sym (C.BTy_object oTy))
                   promoted2_pe
                   (Caux.mk_if_pe (Caux.mk_op_pe C.OpEq conv2_sym_pe (Caux.mk_integer_pe 0))
                      (Caux.mk_undef_pe ub)
                      (Caux.mk_specified_pe $
if AilTypesAux.is_signed_integer_type result_ty then
                         catch_exceptional_condition [Caux.mk_ail_ctype_pe result_ty; core_pe]
else
                         wrapI [Caux.mk_ail_ctype_pe result_ty; core_pe] )))) ]
          )
        )
      )


(* STD §6.5.8 Relational operators *)
and translate_relational_operator translate_rvalue usual_arithmetic_conversion result_ty bop e1 e2 =
  translate_rvalue e1 >>= fun core_e1       ->
  translate_rvalue e2 >>= fun core_e2       ->
  E.fresh_symbol      >>= fun e1_sym        ->
  E.fresh_symbol      >>= fun e2_sym        ->
  E.fresh_symbol      >>= fun obj1_sym      ->
  E.fresh_symbol      >>= fun obj2_sym      ->
  (* The object type on which the Core operator is going to work on. *)
  (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
  let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let real_bop = match bop with
    | A.Lt -> C.OpLt
    | A.Gt -> C.OpGt
    | A.Le -> C.OpLe
    | A.Ge -> C.OpGe
  end in
  
  let e1_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym        in
  let e2_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym        in
  let obj1_sym_pe      = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym      in
  let obj2_sym_pe      = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym      in
  E.return $
    C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                               ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq [core_e1; core_e2]) (
      C.Epure (
        C.Pexpr () (
          C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                 ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
(if AilTypesAux.is_real (ctype_of e1) then
               let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
               Caux.mk_if_pe (Caux.mk_op_pe real_bop promoted1_pe promoted2_pe)
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
else
                       error "WIP: translation of relational operator, pointer cases"))
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
               (* TODO: check with Peter *)
               Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )
            )


(* STD §6.5.9 Equality operators *)
and translate_equality_operator translate_rvalue usual_arithmetic_conversion result_ty bop e1 e2 =
  translate_rvalue e1 >>= fun core_e1       ->
  translate_rvalue e2 >>= fun core_e2       ->
  E.fresh_symbol      >>= fun e1_sym        ->
  E.fresh_symbol      >>= fun e2_sym        ->
  E.fresh_symbol      >>= fun obj1_sym      ->
  E.fresh_symbol      >>= fun obj2_sym      ->
  (* The object type on which the Core operator is going to work on. *)
  (* By typing it is enough to look at the type of one of the operand (see STD §6.5.9#2) *)
  let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
  let mk_op_pe = match bop with
    | A.Eq -> Caux.mk_op_pe C.OpEq
    | A.Ne -> fun x y -> Caux.mk_not_pe (Caux.mk_op_pe C.OpEq x y)
  end in
  let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym   in
  let e2_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym   in
  let obj1_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym in
  let obj2_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym in
  E.return $
    C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                               ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq [core_e1; core_e2]) (
      C.Epure (
        C.Pexpr () (
          C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
            [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                 ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
(if AilTypesAux.is_arithmetic (ctype_of e1) then
               let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
               Caux.mk_if_pe (mk_op_pe promoted1_pe promoted2_pe)
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 1))
                 (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
else
                       error "WIP: translation of equality operator, pointer cases"))
            ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
               (* TODO: check with Peter *)
               Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )
            )


(* STD §6.5.10  Bitwise AND operator          *)
(* STD §6.5.11  Bitwise exclusive OR operator *)
(* STD §6.5.12  Bitwise inclusive OR operator *)
and translate_bitwise_operator translate_rvalue usual_arithmetic_conversion mk_stdcall result_ty aop e1 e2 =
          E.fresh_symbol      >>= fun e1_sym    ->
          E.fresh_symbol      >>= fun e2_sym    ->
          E.fresh_symbol      >>= fun obj1_sym  ->
          E.fresh_symbol      >>= fun obj2_sym  ->
          E.fresh_symbol      >>= fun sym_conv1 ->
          E.fresh_symbol      >>= fun sym_conv2 ->
          translate_rvalue e1 >>= fun core_e1   ->
          translate_rvalue e2 >>= fun core_e2   ->
          let oTy = C.OTy_integer in
          let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym   in
          let e2_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym   in
          let obj1_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym in
          let obj2_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym in
          let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                       ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (C.Eunseq [core_e1; core_e2]) (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                         ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                       (* Both operand are specified *)
                       Caux.mk_specified_pe (
                         let fname = match aop with
                           | A.Band -> "bitwise_AND"
                           | A.Bxor -> "bitwise_XOR"
                           | A.Bor  -> "bitwise_OR"
                         end in
                         mk_stdcall fname [Caux.mk_ail_ctype_pe result_ty; promoted1_pe; promoted2_pe])
                       )
                    ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )
            )










and translate_expression stdlib program is_lvalue a_expr =
  let sigm = snd program in
  let translate_lvalue = translate_expression stdlib program true      in
  let translate_rvalue = translate_expression stdlib program false     in
  let translate_expr   = translate_expression stdlib program is_lvalue in
  
  let mk_stdcall fname = mk_stdcall stdlib fname in
  let bitwise_AND      = mk_stdcall "bitwise_AND"      in
  let bitwise_XOR      = mk_stdcall "bitwise_XOR"      in
  let bitwise_OR       = mk_stdcall "bitwise_OR"       in
  
(*  let conv             = mk_stdcall "conv"             in *)
  let conv_int         = mk_stdcall "conv_int"         in
  let conv_loaded_int  = mk_stdcall "conv_loaded_int"         in
  let wrapI            = mk_stdcall "wrapI"            in
  let ctype_width      = mk_stdcall "ctype_width"      in
(*  let quot             = mk_stdcall "quot"             in *)
  let is_representable = mk_stdcall "is_representable" in
(*
  let usual_arithmetic = mk_stdcall "usual_arithmetic" in
  let usual_arithmetic_conv e ty1 ty2 =
    conv [Caux._pe ty1; usual_arithmetic [Caux.mk_ctype_pe ty1; Caux.mk_ctype_pe ty2]; e] in
*)
  
  let catch_exceptional_condition =
    mk_stdcall "catch_exceptional_condition" in



  (* TODO !!!! *)
  let integer_promotion (ty: Aty.ctype) (e: C.pexpr) : C.pexpr =
    let promoted_ty = fromJust "Translation_aux.integer_promotion" (AilTypesAux.promotion tmp_implementation ty) in
(*    conv [Caux.mk_ail_ctype_pe ty; Caux.mk_ail_ctype_pe promoted_ty; e] in *)
    conv_int [Caux.mk_ail_ctype_pe promoted_ty; e] in
  
  (* STD §6.3.1.8 *)
  let usual_arithmetic_conversion (ty1: Aty.ctype) (ty2: Aty.ctype) (e1: C.pexpr) (e2: C.pexpr) : C.pexpr * C.pexpr =
    match (AilTypesAux.corresponding_real_type ty1, AilTypesAux.corresponding_real_type ty2) with
      | (Just _, _) ->
          error "TODO: §6.3.1.8, floating 1"
      | (_, Just _) ->
          error "TODO: §6.3.1.8, floating 2"
      | (Nothing, Nothing) ->
          (* TODO: this is so readable ... *)
          match (AilTypesAux.promotion tmp_implementation ty1, AilTypesAux.promotion tmp_implementation ty2) with
            | (Just (Aty.Basic (Aty.Integer ity1') as ty1'), Just (Aty.Basic (Aty.Integer ity2') as ty2')) ->
                if ty1' = ty2' then
(*
                  (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty1'; e1],
                   conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty2'; e2])
*)
                  (conv_int [Caux.mk_ail_ctype_pe ty1'; e1],
                   conv_int [Caux.mk_ail_ctype_pe ty2'; e2])

                
                else if   AilTypesAux.is_signed_integer_type ty1' && AilTypesAux.is_signed_integer_type ty2'
                       || AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.is_unsigned_integer_type ty2' then
                  if AilTypesAux.lt_integer_rank ity1' ity2' then
(*
                    (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty2'; e1],
                     conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty2'; e2])
*)
                    (conv_int [Caux.mk_ail_ctype_pe ty2'; e1],
                     conv_int [Caux.mk_ail_ctype_pe ty2'; e2])
                  else
(*
                    (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty1'; e1],
                     conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty1'; e2])
*)
                    (conv_int [Caux.mk_ail_ctype_pe ty1'; e1],
                     conv_int [Caux.mk_ail_ctype_pe ty1'; e2])
                
                else if AilTypesAux.is_unsigned_integer_type ty1' && AilTypesAux.ge_integer_rank ity1' ity2' then
(*
                  (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty1'; e1],
                   conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty1'; e2])
*)
                  (conv_int [Caux.mk_ail_ctype_pe ty1'; e1],
                   conv_int [Caux.mk_ail_ctype_pe ty1'; e2])
                
                else if AilTypesAux.is_unsigned_integer_type ty2' && AilTypesAux.ge_integer_rank ity2' ity1' then
(*
                  (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty2'; e1],
                   conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty2'; e2])
*)
                  (conv_int [Caux.mk_ail_ctype_pe ty2'; e1],
                   conv_int [Caux.mk_ail_ctype_pe ty2'; e2])
                
                else if AilTypesAux.is_signed_integer_type ty1' then
                  (Caux.mk_if_pe (is_representable [e2; Caux.mk_ail_ctype_pe ty1'])
(*
                     (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty1'; e1])
                     (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1'))); e1])
*)
                     (conv_int [Caux.mk_ail_ctype_pe ty1'; e1])
                     (conv_int [Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1'))); e1])
                  ,
                  Caux.mk_if_pe (is_representable [e2; Caux.mk_ail_ctype_pe ty1'])
(*
                     (conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty1'; e2])
                     (conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1'))); e2])
*)
                     (conv_int [Caux.mk_ail_ctype_pe ty1'; e2])
                     (conv_int [Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity1'))); e2])
                  )
                
                else (* if AilTypesAux.is_signed_integer_type ty2' then *)
                  (Caux.mk_if_pe (is_representable [e2; Caux.mk_ail_ctype_pe ty2'])
(*
                     (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe ty2'; e1])
                     (conv [Caux.mk_ail_ctype_pe ty1; Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2'))); e1])
*)
                     (conv_int [Caux.mk_ail_ctype_pe ty2'; e1])
                     (conv_int [Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2'))); e1])
                  ,
                  Caux.mk_if_pe (is_representable [e2; Caux.mk_ail_ctype_pe ty2'])
(*
                     (conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe ty2'; e2])
                     (conv [Caux.mk_ail_ctype_pe ty2; Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2'))); e2])
*)
                     (conv_int [Caux.mk_ail_ctype_pe ty2'; e2])
                     (conv_int [Caux.mk_ail_ctype_pe (Aty.Basic (Aty.Integer (AilTypesAux.make_corresponding_unsigned ity2'))); e2])
                  )
            | _ ->
                error ("Translation.usual_arithmetic_conversion ==> ty1= " ^
                       Pp.stringFromAil_ctype ty1 ^ ", ty2= " ^ Pp.stringFromAil_ctype ty2 ^
                       ", e1= " ^ Pp.stringFromCore_pexpr e1 ^ ", e2= " ^ Pp.stringFromCore_pexpr e2)
          end
(* Aty.make_corresponding_unsigned ity *)
      end in


  
  (* TODO: we do a match instead of a let, because of a bug in Lem *)
  let result_ty = ctype_of a_expr in
  
  if AilTypesAux.is_pointer result_ty && Aaux.is_null_pointer_constant a_expr then
    E.return $ C.Epure (Caux.mk_nullptr_pe (Caux.proj_ctype result_ty))
  else
    let A.AnnotatedExpression annot loc expr = a_expr in
    C.Eloc loc <$> match expr with
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Plus e ->
          (* STD §6.5.3.3#2 *)
          let oTy =
            if AilTypesAux.is_integer result_ty then C.OTy_integer else C.OTy_floating in
          E.fresh_symbol     >>= fun obj_sym ->
          E.fresh_symbol     >>= fun e_sym   ->
          translate_rvalue e >>= fun core_e  ->
          E.return $
            C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_sym_pe (C.BTy_loaded oTy) e_sym)
                    [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy)),
                       Caux.mk_specified_pe (integer_promotion (ctype_of e) (Caux.mk_sym_pe (C.BTy_object oTy) obj_sym)))
                    ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                       (* TODO: check that result_ty = promoted (ctype_of e) *)
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )
            )
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Minus e ->
          (* STD §6.5.3.3#3 *)
          let (oTy, zero_pe) =
            if AilTypesAux.is_integer result_ty then
              (C.OTy_integer, Caux.mk_integer_pe 0)
            else
              (C.OTy_floating, Caux.mk_floating_value_pe Mem.zero_fval) in
          E.fresh_symbol     >>= fun obj_sym ->
          E.fresh_symbol     >>= fun e_sym   ->
          translate_rvalue e >>= fun core_e  ->
          E.return $
            C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_sym_pe (C.BTy_loaded oTy) e_sym)
                    [ (C.CaseCtor C.Cspecified [Caux.mk_sym_pat obj_sym (C.BTy_object oTy)],
                       let expr =
                         Caux.mk_op_pe C.OpSub zero_pe (integer_promotion (ctype_of e) (Caux.mk_sym_pe (C.BTy_object oTy) obj_sym)) in
                       Caux.mk_specified_pe (if AilTypesAux.is_signed_integer_type result_ty then
                         catch_exceptional_condition [Caux.mk_ail_ctype_pe result_ty; expr]
                       else
                         wrapI [Caux.mk_ail_ctype_pe result_ty; expr]))
                    ; (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype],
                       (* TODO: check that result_ty = promoted (ctype_of e) *)
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )
            )
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Bnot e ->
          (* STD §6.5.3.3#4 *)
          E.fresh_symbol     >>= fun obj_sym ->
          E.fresh_symbol     >>= fun e_sym   ->
          translate_rvalue e >>= fun core_e  ->
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
          E.return $
            C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_sym_pe (C.BTy_loaded oTy) e_sym)
                    [ (C.CaseCtor C.Cspecified [Caux.mk_sym_pat obj_sym (C.BTy_object oTy)],
                       let promoted_e = integer_promotion (ctype_of e) (Caux.mk_sym_pe (C.BTy_object oTy) obj_sym) in
                       (* NOTE: result_ty == promoted type of e *)
                       Caux.mk_specified_pe (if AilTypesAux.is_unsigned_integer_type result_ty then
                         (* STD §6.5.3.3#4, sentence 3 *)
                         Caux.mk_op_pe C.OpSub (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) promoted_e
                       else
                         Caux.bitwise_complement_pe (Caux.mk_ail_ctype_pe result_ty) promoted_e))
                    ; (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype],
                       (* TODO: check that result_ty = promoted (ctype_of e) *)
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                )
              )
            )
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Address (A.AnnotatedExpression _ _ (A.AilEunary A.Indirection e)) ->
          (* STD §6.5.3.2#3, sentence 3 *)
          (* NOTE: footnote 102 makes it clear that this is valid even if 'e' evaluates to a null pointer *)
          translate_rvalue e
      
      (* CHECKED IN APR2016 *)
      | A.AilEunary A.Address e ->
          (* STD §6.5.3.2#3, sentence 5 *)
          if AilTypesAux.is_object result_ty then
             E.fresh_symbol     >>= fun sym    ->
             translate_lvalue e >>= fun core_e ->
             let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
             E.return $
               C.Ewseq (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) core_e
                 (C.Epure (Caux.mk_specified_pe (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)))
          else
            translate_function_designator stdlib e
      
      (* TODO: promotion? + atomicity *)
      | A.AilEunary A.PostfixIncr e ->
          let () = if AilTypesAux.is_atomic (ctype_of e) then
            Debug.warn "TODO: elaboration is wrong for atomic types"
          else
            () in
          (* TODO: qualifiers temporarily not dealt with *)
(*          E.fresh_symbol     >>= fun lvalue_sym ->
          E.fresh_symbol     >>= fun load_sym   -> *)
          E.fresh_symbol     >>= fun lvalue_sym ->
          E.fresh_symbol     >>= fun load_sym   ->
          E.fresh_symbol     >>= fun obj_sym    ->
          translate_lvalue e >>= fun core_e     ->
          let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype ty)    in
          let core_ty_e = Caux.mk_ail_ctype_pe ty in
          
          let lvalue_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) lvalue_sym in
          let load_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) load_sym             in
          let obj_sym_pe    = Caux.mk_sym_pe (C.BTy_object oTy) obj_sym              in
          
          E.return $
            C.Ewseq (Caux.mk_sym_pat lvalue_sym (C.BTy_object C.OTy_pointer)) core_e
              (C.Easeq (Just (load_sym, C.BTy_loaded oTy))
                 (C.Action loc default (C.Load core_ty_e lvalue_sym_pe Cmm.NA))
                 (C.Paction C.Neg (C.Action loc default (C.Store core_ty_e
                    lvalue_sym_pe
                    (C.Pexpr () begin
                      C.PEcase load_sym_pe
                        [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy)),
                           Caux.mk_specified_pe
match AilTypesAux.unatomic ty with
  | Aty.Basic (Aty.Integer _) ->
                           conv_int [Caux.mk_ail_ctype_pe (ctype_of e); (Caux.mk_op_pe C.OpAdd obj_sym_pe (Caux.mk_integer_pe 1))]
  | Aty.Basic (Aty.Floating (Aty.RealFloating _)) ->
                           error "AilEunary PostfixIncr, floating type"
  | Aty.Pointer _ ref_ty ->
                           Caux.mk_array_shift obj_sym_pe (Caux.proj_ctype ref_ty) (Caux.mk_integer_pe 1)
  | _ ->
      error "[Translate.translate_expression, AilEunary PostfixIncr] the Ail expression was ill-typed"
end
                           )
                        ; (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype],
                          Caux.mk_unspecified_pe (Caux.proj_ctype ty)(*TODO:check*))
                        ]
                    end)
                    Cmm.NA))
                 )
              )
      
      (* TODO: promotion? + atomicity *)
      (* TODO: factorise with PostfixIncr !!! *)
      | A.AilEunary A.PostfixDecr e ->
          let () = if AilTypesAux.is_atomic (ctype_of e) then
            Debug.warn "TODO: elaboration is wrong for atomic types"
          else
            () in
          (* TODO: qualifiers temporarily not dealt with *)
(*          E.fresh_symbol     >>= fun lvalue_sym ->
          E.fresh_symbol     >>= fun load_sym   -> *)
          E.fresh_symbol     >>= fun lvalue_sym ->
          E.fresh_symbol     >>= fun load_sym   ->
          E.fresh_symbol     >>= fun obj_sym    ->
          translate_lvalue e >>= fun core_e     ->
          let ty  = AilTypesAux.rvalue_coercion (snd (from_lvalue_type e)) in
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype ty)    in
          let core_ty_e = Caux.mk_ail_ctype_pe ty in
          
          let lvalue_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) lvalue_sym in
          let load_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) load_sym             in
          let obj_sym_pe    = Caux.mk_sym_pe (C.BTy_object oTy) obj_sym              in
          
          E.return $
            C.Ewseq (Caux.mk_sym_pat lvalue_sym (C.BTy_object C.OTy_pointer)) core_e
              (C.Easeq (Just (load_sym, C.BTy_loaded oTy))
                 (C.Action loc default (C.Load core_ty_e lvalue_sym_pe Cmm.NA))
                 (C.Paction C.Neg (C.Action loc default (C.Store core_ty_e
                    lvalue_sym_pe
                    (C.Pexpr () begin
                      C.PEcase load_sym_pe
                        [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object oTy)),
                           Caux.mk_specified_pe
match AilTypesAux.unatomic ty with
  | Aty.Basic (Aty.Integer _) ->
                           conv_int [Caux.mk_ail_ctype_pe (ctype_of e); (Caux.mk_op_pe C.OpSub obj_sym_pe (Caux.mk_integer_pe 1))]
  | Aty.Basic (Aty.Floating (Aty.RealFloating _)) ->
                           error "AilEunary PostfixDecr, floating type"
  | Aty.Pointer _ ref_ty ->
                           error "AilEunary PostfixDecr, pointer type"
(*                           Caux.mk_array_shift obj_sym_pe (Caux.proj_ctype ref_ty) (Caux.mk_integer_pe 1) *)
  | _ ->
      error "[Translate.translate_expression, AilEunary PostfixIncr] the Ail expression was ill-typed"
end
                           )
                        ; (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype],
                          Caux.mk_unspecified_pe (Caux.proj_ctype ty)(*TODO:check*))
                        ]
                    end)
                    Cmm.NA))
                 )
              )      
      | A.AilEunary A.Indirection e ->
          (* TODO: if e is a pointer to a function *)
if AilTypesAux.is_pointer_to_function (ctype_of e) then
          error "WIP: Elaboration, A.Indirection, function designator"
else
          E.fresh_symbol      >>= fun e_sym    ->
          E.fresh_symbol      >>= fun obj_sym  ->
          E.fresh_symbol      >>= fun test_sym -> (* symbol for the PtrValidForDeref test *)
          translate_rvalue e  >>= fun core_e   ->
          E.return $
            C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded C.OTy_pointer)) core_e
              (C.Ecase (Caux.mk_sym_pe (C.BTy_loaded C.OTy_pointer) e_sym)
                 [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj_sym (C.BTy_object C.OTy_pointer)),
                    C.Ewseq (Caux.mk_sym_pat test_sym C.BTy_boolean)
                      (C.Ememop Mem.PtrValidForDeref [Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) obj_sym])
                      (C.Eif (Caux.mk_sym_pe C.BTy_boolean test_sym)
                         begin
                           let obj_sym_pe = 
                             Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) obj_sym in
                           if is_lvalue then
                             C.Epure obj_sym_pe
                           else
                             Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) obj_sym_pe Cmm.NA
                         end
                         (C.Epure (Caux.mk_undef_pe Undefined.UB043_indirection_invalid_value)))
                     )
                 ; (C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype],
                    C.Epure (Caux.mk_undef_pe Undefined.UB043_indirection_invalid_value(*TODO:check*)))
                 ])
(*
The unary * operator denotes indirection.

If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object.

If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’.

If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.
*)

      
      | A.AilEbinary e1 (A.Arithmetic A.Shl) e2 ->
          translate_rvalue e1 >>= fun core_e1       ->
          translate_rvalue e2 >>= fun core_e2       ->
          E.fresh_symbol      >>= fun e1_sym        ->
          E.fresh_symbol      >>= fun e2_sym        ->
          E.fresh_symbol      >>= fun obj1_sym      ->
          E.fresh_symbol      >>= fun obj2_sym      ->
          E.fresh_symbol      >>= fun promoted1_sym ->
          E.fresh_symbol      >>= fun promoted2_sym ->
          E.fresh_symbol      >>= fun res_sym       ->
          let e1_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) obj2_sym      in
          let promoted1_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) promoted1_sym in
          let promoted2_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) promoted2_sym in
          let res_sym_pe       = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) res_sym       in
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded C.OTy_integer)
                                       ; Caux.mk_sym_pat e2_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [core_e1; core_e2]) (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                         ; C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype ] ],
                       Caux.mk_undef_pe Undefined.UB036_exceptional_condition)
                    ; (Caux.mk_tuple_pat [ C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype]
                                         ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ],
(if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
else
                       Caux.mk_undef_pe Undefined.UB036_exceptional_condition))
                    ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object C.OTy_integer))
                                         ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object C.OTy_integer)) ],
                       Caux.mk_let_pe (Caux.mk_sym_pat promoted1_sym (C.BTy_object C.OTy_integer))
                         (integer_promotion (ctype_of e1) obj1_sym_pe)
                       (Caux.mk_let_pe (Caux.mk_sym_pat promoted2_sym (C.BTy_object C.OTy_integer))
                         (integer_promotion (ctype_of e2) obj2_sym_pe)
                       (* (§6.5.7#2) if promoted2 < 0 then undef *)
                       (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted2_sym_pe (Caux.mk_integer_pe 0))
                         (Caux.mk_undef_pe Undefined.UB051a_negative_shift)
                       
                       (* ctype_width(result_ty) <= promoted2 *)
                       (Caux.mk_if_pe (Caux.mk_op_pe C.OpOr (Caux.mk_op_pe C.OpLt (ctype_width [Caux.mk_ail_ctype_pe result_ty]) promoted2_sym_pe)
                                                            (Caux.mk_op_pe C.OpEq (ctype_width [Caux.mk_ail_ctype_pe result_ty]) promoted2_sym_pe))
                          (Caux.mk_undef_pe Undefined.UB51b_shift_too_large)
(if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                       (Caux.mk_specified_pe (
                          Caux.mk_op_pe C.OpRem_t (Caux.mk_op_pe C.OpMul promoted1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe))
                                                  (Caux.mk_op_pe C.OpAdd (Caux.mk_ivmax_pe (Caux.mk_ail_ctype_pe result_ty)) (Caux.mk_integer_pe 1))
                        ))
else
                       (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted1_sym_pe (Caux.mk_integer_pe 0))
                         (Caux.mk_undef_pe Undefined.UB036_exceptional_condition)
                       (Caux.mk_let_pe (Caux.mk_sym_pat res_sym (C.BTy_object C.OTy_integer))
                         (Caux.mk_op_pe C.OpMul promoted1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe))
                       (Caux.mk_if_pe (is_representable [res_sym_pe; Caux.mk_ail_ctype_pe result_ty])
                          (Caux.mk_specified_pe res_sym_pe)
                         (Caux.mk_undef_pe Undefined.UB036_exceptional_condition))))
)
                       )))) ]
                )
              )
            )
      
      | A.AilEbinary e1 (A.Arithmetic A.Shr) e2 ->
          translate_rvalue e1 >>= fun core_e1       ->
          translate_rvalue e2 >>= fun core_e2       ->
          E.fresh_symbol      >>= fun e1_sym        ->
          E.fresh_symbol      >>= fun e2_sym        ->
          E.fresh_symbol      >>= fun obj1_sym      ->
          E.fresh_symbol      >>= fun obj2_sym      ->
          E.fresh_symbol      >>= fun promoted1_sym ->
          E.fresh_symbol      >>= fun promoted2_sym ->
          E.fresh_symbol      >>= fun res_sym       ->
          let e1_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) obj2_sym      in
          let promoted1_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) promoted1_sym in
          let promoted2_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) promoted2_sym in
          let res_sym_pe       = Caux.mk_sym_pe (C.BTy_object C.OTy_integer) res_sym       in
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded C.OTy_integer)
                                       ; Caux.mk_sym_pat e2_sym (C.BTy_loaded C.OTy_integer) ]) (Caux.mk_unseq [core_e1; core_e2]) (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ (Caux.mk_tuple_pat [ Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer)
                                         ; C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype ] ],
                       Caux.mk_undef_pe Undefined.UB036_exceptional_condition)
                    ; (Caux.mk_tuple_pat [ C.CaseCtor C.Cunspecified [Caux.mk_empty_pat C.BTy_ctype]
                                         ; Caux.mk_empty_pat (C.BTy_loaded C.OTy_integer) ],
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty))
                    ; (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object C.OTy_integer))
                                         ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object C.OTy_integer)) ],
                       Caux.mk_let_pe (Caux.mk_sym_pat promoted1_sym (C.BTy_object C.OTy_integer))
                         (integer_promotion (ctype_of e1) obj1_sym_pe)
                       (Caux.mk_let_pe (Caux.mk_sym_pat promoted2_sym (C.BTy_object C.OTy_integer))
                         (integer_promotion (ctype_of e2) obj2_sym_pe)
                       (* (§6.5.7#2) if promoted2 < 0 then undef *)
                       (Caux.mk_if_pe (Caux.mk_op_pe C.OpLt promoted2_sym_pe (Caux.mk_integer_pe 0))
                         (Caux.mk_undef_pe Undefined.UB051a_negative_shift)
                       
                       (* ctype_width(result_ty) <= promoted2 *)
                       (Caux.mk_if_pe (Caux.mk_op_pe C.OpOr (Caux.mk_op_pe C.OpLt (ctype_width [Caux.mk_ail_ctype_pe result_ty]) promoted2_sym_pe)
                                                            (Caux.mk_op_pe C.OpEq (ctype_width [Caux.mk_ail_ctype_pe result_ty]) promoted2_sym_pe))
                          (Caux.mk_undef_pe Undefined.UB51b_shift_too_large)
                          (let expr = Caux.mk_op_pe C.OpDiv obj1_sym_pe (Caux.mk_op_pe C.OpExp (Caux.mk_integer_pe 2) promoted2_sym_pe) in
                           Caux.mk_specified_pe $
if AilTypesAux.is_unsigned_integer_type (ctype_of e1) then
                           expr
else
                           Caux.mk_if_pe (Caux.mk_op_pe C.OpGe promoted1_sym_pe (Caux.mk_integer_pe 0))
                             expr
                             (C.Pexpr () (
                                C.PEcall (C.Impl Implementation_.SHR_signed_negative) [Caux.mk_ail_ctype_pe (ctype_of e1) ; promoted1_sym_pe; promoted2_sym_pe]
                             ))))))) ]
                )
              )
            )





        (* NOTE: this is not enough *)
      | A.AilEident id ->
          if AilTypesAux.is_pointer_to_function result_ty then
            translate_function_designator stdlib a_expr
(*            E.return (C.Epure $ Caux.mk_cfunction_pe id) *)
          else
            let id_sym_pe =
              Caux.mk_sym_pe (C.BTy_object (Caux.core_object_type_of_ctype (Caux.proj_ctype result_ty))) id in
            E.return $
              if is_lvalue then
(*
                if AilTypesAux.is_array result_ty then
                  (* STD §6.3.2.1# *)
                else
*)
                C.Epure ((*Caux.mk_specified_pe*)id_sym_pe)
              else
                Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) id_sym_pe Cmm.NA



(*
              let (sym_ty =
                match E.core_object_type_of_ctype result_ty with
                  | Just objTy ->
                      C.PEsym (id, Core.BTy_object objTy) (* TODO: check *)
                  | Nothing ->
                      error "Translation_effect.fresh_typed_symbol"
                end in
              if is_lvalue then
(*
                if AilTypesAux.is_array result_ty then
                  (* STD §6.3.2.1# *)
                else
*)
                Caux.mk_sym_pe C.Epure sym_ty
              else
                Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) sym_ty Cmm.NA
            )
      *)
      
      
      
      | A.AilEcast _ ty e ->
          let () = Debug.warn "TODO[elab] check AilEcast" in
          E.fresh_symbol >>= fun e_sym   ->
          E.fresh_symbol >>= fun obj_sym ->
          (if AilTypesAux.is_pointer (ctype_of e) then translate_lvalue else translate_rvalue) e >>= fun core_e ->
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
          let e_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e_sym in
          let obj_sym_pe = Caux.mk_sym_pe (C.BTy_loaded oTy) obj_sym in
          E.return $
if AilTypesAux.is_pointer ty && Aaux.is_null_pointer_constant e then
            match ty with
              | Aty.Pointer _ ref_ty ->
                  C.Epure (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype ref_ty)))
            end
else
            C.Ewseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
if AilTypesAux.is_arithmetic ty && AilTypesAux.is_arithmetic (ctype_of e) then
  if AilTypesAux.is_integer ty && AilTypesAux.is_integer (ctype_of e) then
              (* TODO: check *)
              C.Epure (conv_loaded_int [Caux.mk_ail_ctype_pe ty; e_sym_pe])
  else
              error "WIP elaboration of casts involving a non-integer arithmetic type"
else
              begin
                let e_ty = ctype_of e in
                error "WIP elaboration of casts involving a pointer type"
(*                
                else if AilTypesAux.is_pointer ty && AilTypesAux.is_arithmetic e_ty then
                  (* making a pointer from an integer *)
                  let ref_ty = fromJust "Translation.translate_expression, AilEcast 1" $ AilTypesAux.referenced_type ty in
                  C.Ememop Mem.PtrFromInt [Caux.mk_ail_ctype_pe e_ty; Caux.mk_ail_ctype_pe ref_ty; C.PEsym sym_ty_e]
                  
                else if AilTypesAux.is_arithmetic ty && AilTypesAux.is_pointer e_ty then
                  (* making an integer from a pointer *)
                  let ref_ty = fromJust "Translation.translate_expression, AilEcast 2" $ AilTypesAux.referenced_type e_ty in
                  C.Ememop Mem.IntFromPtr [Caux.mk_ail_ctype_pe ref_ty; Caux.mk_ail_ctype_pe ty; C.PEsym sym_ty_e]
                else
                  (* TODO: check *)
                  C.Epure (conv [Caux.mk_ail_ctype_pe (ctype_of e); Caux.mk_ail_ctype_pe ty; C.PEsym sym_ty_e])
*)
              end
            )
      
      | A.AilEbinary e1 (A.Arithmetic A.Mul) e2 ->
          translate_rvalue e1 >>= fun core_e1  ->
          translate_rvalue e2 >>= fun core_e2  ->
          E.fresh_symbol      >>= fun e1_sym   ->
          E.fresh_symbol      >>= fun e2_sym   ->
          E.fresh_symbol      >>= fun obj1_sym ->
          E.fresh_symbol      >>= fun obj2_sym ->
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym   in
          let e2_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym   in
          let obj1_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym in
          let obj2_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym in
          let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                       ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq [core_e1; core_e2]) (
              C.Epure (
                C.Pexpr () (
                  C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                    [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                         ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                       (* Both operand are specified *)
                       let core_mul = Caux.mk_op_pe C.OpMul promoted1_pe promoted2_pe in
                       Caux.mk_specified_pe $
if AilTypesAux.is_signed_integer_type result_ty then
                         catch_exceptional_condition [Caux.mk_ail_ctype_pe result_ty; core_mul]
else
                         wrapI [Caux.mk_ail_ctype_pe result_ty; core_mul] )
                    
                    ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
                       (* If either operand is unspecified, the result is also unspecified is the
                          result type of unsigned. Otherwise it is undef, since the multiplication
                          may overflow *)
if AilTypesAux.is_unsigned_integer_type result_ty then
                       Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
else
                       Caux.mk_undef_pe Undefined.UB036_exceptional_condition) ]
                )
              )
            )
      
      | A.AilEbinary e1 (A.Arithmetic (A.Div as aop)) e2 ->
          translate_div_mod_operator
            translate_rvalue usual_arithmetic_conversion catch_exceptional_condition wrapI
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Mod as aop)) e2 ->
          translate_div_mod_operator
            translate_rvalue usual_arithmetic_conversion catch_exceptional_condition wrapI
            result_ty aop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic A.Add) e2 ->
          translate_rvalue e1 >>= fun core_e1       ->
          translate_rvalue e2 >>= fun core_e2       ->
          E.fresh_symbol      >>= fun e1_sym        ->
          E.fresh_symbol      >>= fun e2_sym        ->
          E.fresh_symbol      >>= fun obj1_sym      ->
          E.fresh_symbol      >>= fun obj2_sym      ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e1) then
            let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
            let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym   in
            let e2_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym   in
            let obj1_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym in
            let obj2_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym in
            let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
            E.return $
              C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq [core_e1; core_e2]) (
                C.Epure (
                  C.Pexpr () (
                    C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                      [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                           ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                         (* Both operand are specified *)
                         let core_add = Caux.mk_op_pe C.OpAdd promoted1_pe promoted2_pe in
                         Caux.mk_specified_pe $
  if AilTypesAux.is_signed_integer_type result_ty then
                           catch_exceptional_condition [Caux.mk_ail_ctype_pe result_ty; core_add]
  else
                           wrapI [Caux.mk_ail_ctype_pe result_ty; core_add] )
                      
                      ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
                         (* If either operand is unspecified, the result is also unspecified is the
                            result type of unsigned. Otherwise it is undef, since the addition
                            may overflow *)
  if AilTypesAux.is_unsigned_integer_type result_ty then
                         Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
  else
                         Caux.mk_undef_pe Undefined.UB036_exceptional_condition) ]
                  )
                )
              )
else
            (* Here one of the operand is pointer *)
            let (ptr_e, integer_e) =
              if AilTypesAux.is_arithmetic (ctype_of e1) then
                (e2, e1)
              else
                (e1, e2) in
            
            error "WIP: elaboration of pointer + integer"
      
      (* TODO: check + try to factorise with A.Add *)
      | A.AilEbinary e1 (A.Arithmetic A.Sub) e2 ->
          translate_rvalue e1 >>= fun core_e1       ->
          translate_rvalue e2 >>= fun core_e2       ->
          E.fresh_symbol      >>= fun e1_sym        ->
          E.fresh_symbol      >>= fun e2_sym        ->
          E.fresh_symbol      >>= fun obj1_sym      ->
          E.fresh_symbol      >>= fun obj2_sym      ->
if AilTypesAux.is_arithmetic (ctype_of e1) && AilTypesAux.is_arithmetic (ctype_of e1) then
            let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
            let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym   in
            let e2_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym   in
            let obj1_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym in
            let obj2_sym_pe = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym in
            let (promoted1_pe, promoted2_pe) = usual_arithmetic_conversion (ctype_of e1) (ctype_of e2) obj1_sym_pe obj2_sym_pe in
            E.return $
              C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)
                                         ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy) ]) (Caux.mk_unseq [core_e1; core_e2]) (
                C.Epure (
                  C.Pexpr () (
                    C.PEcase (Caux.mk_tuple_pe [e1_sym_pe; e2_sym_pe])
                      [ (Caux.mk_tuple_pat [ Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy))
                                           ; Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)) ],
                         (* Both operand are specified *)
                         let core_sub = Caux.mk_op_pe C.OpSub promoted1_pe promoted2_pe in
                         Caux.mk_specified_pe $
  if AilTypesAux.is_signed_integer_type result_ty then
                           catch_exceptional_condition [Caux.mk_ail_ctype_pe result_ty; core_sub]
  else
                           wrapI [Caux.mk_ail_ctype_pe result_ty; core_sub] )
                      
                      ; (Caux.mk_empty_pat (C.BTy_tuple [C.BTy_loaded oTy; C.BTy_loaded oTy]),
                         (* If either operand is unspecified, the result is also unspecified is the
                            result type of unsigned. Otherwise it is undef, since the addition
                            may overflow *)
  if AilTypesAux.is_unsigned_integer_type result_ty then
                         Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)
  else
                         Caux.mk_undef_pe Undefined.UB036_exceptional_condition) ]
                  )
                )
              )
else
            error "WIP: elaboration of Sub involving pointers"











      | A.AilEbinary e1 (A.Lt as bop) e2 ->
          translate_relational_operator
            translate_rvalue usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Gt as bop) e2 ->
          translate_relational_operator
            translate_rvalue usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Le as bop) e2 ->
          translate_relational_operator
            translate_rvalue usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ge as bop) e2 ->
          translate_relational_operator
            translate_rvalue usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Eq as bop) e2 ->
          translate_equality_operator
            translate_rvalue usual_arithmetic_conversion
            result_ty bop e1 e2
      | A.AilEbinary e1 (A.Ne as bop) e2 ->
          translate_equality_operator
            translate_rvalue usual_arithmetic_conversion
            result_ty bop e1 e2
      
      | A.AilEbinary e1 (A.Arithmetic (A.Band as aop)) e2 ->
          translate_bitwise_operator
            translate_rvalue usual_arithmetic_conversion mk_stdcall
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bxor as aop)) e2 ->
          translate_bitwise_operator
            translate_rvalue usual_arithmetic_conversion mk_stdcall
            result_ty aop e1 e2
      | A.AilEbinary e1 (A.Arithmetic (A.Bor as aop)) e2 ->
          translate_bitwise_operator
            translate_rvalue usual_arithmetic_conversion mk_stdcall
            result_ty aop e1 e2
      
      | A.AilEbinary e1 A.And e2 ->
          let () = Debug.warn "TODO: make the elab of A.And use mkTestExpression" in
          translate_rvalue e1 >>= fun core_e1       ->
          translate_rvalue e2 >>= fun core_e2       ->
          E.fresh_symbol      >>= fun e1_sym        ->
          E.fresh_symbol      >>= fun e2_sym        ->
          E.fresh_symbol      >>= fun obj1_sym      ->
          E.fresh_symbol      >>= fun obj2_sym      ->
          (* The object type on which the Core operator is going to work on. *)
          (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym      in
          E.return $
            C.Ewseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)) core_e1 (
              C.Ecase e1_sym_pe
                [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy)),
                   C.Eif (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0))
                         (C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 0)))
                         (C.Ewseq (Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy)) core_e2 (
                            C.Epure (
                              C.Pexpr () (
                                C.PEcase e2_sym_pe
                                  [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)),
                                     Caux.mk_specified_pe (
                                       Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj2_sym_pe (Caux.mk_integer_pe 0))
                                         (Caux.mk_integer_pe 0) (Caux.mk_integer_pe 1)
                                     ))
                                  ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                                     (* TODO: check with Peter *)
                                     Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                              )
                            )
                         )))
                ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                       (* TODO: check with Peter *)
                       C.Epure (Caux.mk_unspecified_pe (Caux.proj_ctype result_ty))) ]
            )
      
      | A.AilEbinary e1 A.Or e2 ->
          let () = Debug.warn "TODO: make the elab of A.Or use mkTestExpression" in
          translate_rvalue e1 >>= fun core_e1       ->
          translate_rvalue e2 >>= fun core_e2       ->
          E.fresh_symbol      >>= fun e1_sym        ->
          E.fresh_symbol      >>= fun e2_sym        ->
          E.fresh_symbol      >>= fun obj1_sym      ->
          E.fresh_symbol      >>= fun obj2_sym      ->
          (* The object type on which the Core operator is going to work on. *)
          (* By typing it is enough to look at the type of one of the operand (see STD §6.5.8#2) *)
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          let e1_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded oTy) e1_sym        in
          let e2_sym_pe        = Caux.mk_sym_pe (C.BTy_loaded oTy) e2_sym        in
          let obj1_sym_pe      = Caux.mk_sym_pe (C.BTy_object oTy) obj1_sym      in
          let obj2_sym_pe      = Caux.mk_sym_pe (C.BTy_object oTy) obj2_sym      in
          E.return $
            C.Ewseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded oTy)) core_e1 (
              C.Ecase e1_sym_pe
                [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object oTy)),
                   C.Eif (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0)))
                         (C.Epure (Caux.mk_specified_pe (Caux.mk_integer_pe 1)))
                         (C.Ewseq (Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy)) core_e2 (
                            C.Epure (
                              C.Pexpr () (
                                C.PEcase e2_sym_pe
                                  [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj2_sym (C.BTy_object oTy)),
                                     Caux.mk_specified_pe (
                                       Caux.mk_if_pe (Caux.mk_op_pe C.OpEq obj2_sym_pe (Caux.mk_integer_pe 0))
                                         (Caux.mk_integer_pe 0) (Caux.mk_integer_pe 1)
                                     ))
                                  ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                                     (* TODO: check with Peter *)
                                     Caux.mk_unspecified_pe (Caux.proj_ctype result_ty)) ]
                              )
                            )
                         )))
                ; (Caux.mk_empty_pat (C.BTy_loaded oTy),
                       (* TODO: check with Peter *)
                       C.Epure (Caux.mk_unspecified_pe (Caux.proj_ctype result_ty))) ]
            )
      
      | A.AilEcond e1 e2 e3 ->
          let () = Debug.warn "TODO: make the elab of AilEcond use mkTestExpression" in
          E.fresh_symbol      >>= fun e1_sym   ->
          E.fresh_symbol      >>= fun obj1_sym ->
          translate_rvalue e1 >>= fun core_e1  ->
          translate_rvalue e2 >>= fun core_e2  ->
          translate_rvalue e3 >>= fun core_e3  ->
          let e1_oTy =
            (* NOTE: [e1] must be a scalar *)
            Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          
          let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded e1_oTy) e1_sym   in
          let obj1_sym_pe = Caux.mk_sym_pe (C.BTy_object e1_oTy) obj1_sym in
          
          E.return $
            (* STD (§6.5.15#4, second sentence) says there is a sequenced point between the
               evaluation of e1 and the e2/e3. Hence the strong sequencing *)
            C.Esseq (Caux.mk_sym_pat e1_sym (C.BTy_loaded e1_oTy)) core_e1
            begin
              let () = Debug.warn "Translation, AilEcond ==> TODO: the conversions for e2 and e3" in
              C.Ecase e1_sym_pe
                [ (Caux.mk_specified_pat (Caux.mk_sym_pat obj1_sym (C.BTy_object e1_oTy)),
                   let core_test =
                     if AilTypesAux.is_integer (ctype_of e1) then
                       Caux.mk_not_pe (Caux.mk_op_pe C.OpEq obj1_sym_pe (Caux.mk_integer_pe 0))
                     else
                       error "WIP: AilEcond, pointer e1" in
                   C.Eif core_test
                     (* TODO: conversions *)
                     core_e2
                     core_e3)
                  (* non-deterministic branching if the test expression had unspecified value *)
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                   (* TODO: conversions *)
                   C.End [core_e2; core_e3]) ]
            end
      
      | A.AilEassign e1 e2 ->
          E.fresh_symbol      >>= fun e1_sym  ->
          E.fresh_symbol      >>= fun e2_sym  ->
          translate_lvalue e1 >>= fun core_e1 ->
          let oTy2        = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e2))                 in
          let e1_sym_pe   = Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) e1_sym                             in
          let e2_sym_pe   = Caux.mk_sym_pe (C.BTy_loaded oTy2)          e2_sym                             in
          let core_ty_pe1 = Caux.mk_ail_ctype_pe $ AilTypesAux.rvalue_coercion (snd (from_lvalue_type e1)) in
          
          begin
if AilTypesAux.is_arithmetic (ctype_of e1) then
            translate_rvalue e2 >>= fun core_e ->
            E.return (core_e, conv_loaded_int [Caux.mk_ail_ctype_pe (ctype_of e1); e2_sym_pe])
else if AilTypesAux.is_struct_or_union (ctype_of e1) then
            error "struct/union assign"
else if AilTypesAux.is_pointer (ctype_of e1) then
  match ctype_of e1 with
    | Aty.Pointer _ ref_ty ->
        if Aaux.is_null_pointer_constant e2 then
            E.return (C.Epure (Caux.mk_specified_pe (Caux.mk_nullptr_pe (Caux.proj_ctype ref_ty))), e2_sym_pe)
        else
            translate_rvalue e2 >>= fun core_e ->
            E.return (core_e, e2_sym_pe)
  end
else (* By Ail typing, e1 must have type _Bool and e2 must be a pointer *)
            error "_Bool vs pointer assign"
          end >>= fun (core_e2, stored_pe) ->
          
          E.return $
            C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat e1_sym (C.BTy_object C.OTy_pointer)
                                       ; Caux.mk_sym_pat e2_sym (C.BTy_loaded oTy2) ]) (C.Eunseq [core_e1; core_e2])
              (C.Ewseq (Caux.mk_empty_pat C.BTy_unit)
                 (C.Eaction (C.Paction C.Neg (C.Action loc default (C.Store core_ty_pe1 e1_sym_pe stored_pe Cmm.NA))))
                 (C.Epure e2_sym_pe))




      
      | A.AilEbinary e1 A.Comma e2 ->
          translate_rvalue e1 >>= fun core_e1 ->
          translate_rvalue e2 >>= fun core_e2 ->
          let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e1)) in
          (* STD (§6.5.17, second sentence) says there is a sequence point between the
             evaluation of the two operand. Hence the strong sequencing *)
          E.return $
            C.Esseq (Caux.mk_empty_pat (C.BTy_loaded oTy)) core_e1 core_e2






(*
(*      
      (*
         (std: A compound assignment of the form E1 op = E2 is equivalent to the simple assignment
         expression E1 = E1 op (E2), except that the lvalue E1 is evaluated only once, and with respect
         to an indeterminately-sequenced function call, the operation of a compound) *)
      | A.AilEcompoundAssign e1 aop e2 ->
          (* TODO: this is a TEMPORARY HACK *)
          let A.AnnotatedExpression annot2 loc' _ = e2 in
          translate_rvalue $
            A.AnnotatedExpression annot loc (A.AilEassign e1 (A.AnnotatedExpression annot2 loc' (A.AilEbinary e1 (A.Arithmetic aop) e2)))
*)
      | A.AilEcompoundAssign e1 aop e2 ->
          error "TEMPORARY ==> compound assign are not supported by the elaboration and should desugared in Cabs_to_ail"
      
      (* TODO: conv_int on e2 and e2 !!!!!!! *)
      
*)




      






      
(*
      (* TODO: a bit hackish *)
      | A.AilEcall (A.AnnotatedExpression _ (A.AilEbuiltin str)) es ->
          match (str, es) with
            | ("atomic_load_explicit", [object_e; order_e]) ->
                (* TODO: for now we don't allow complicated expressions for order_e *)
                E.return $
                  E.fresh_symbol >>= fun a_object ->
                  translate_expression e
                  C.
          end
*)

     | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEbuiltin "atomic_store_explicit")) [object_e; desired_e; order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         let ref_ty = match ctype_of object_e with
           | Aty.Pointer _ ref_ty ->
               ref_ty
           | _ ->
               error "Translation.translate_expression, AilEcall atomic_store_explicit: Ail type error"
         end in
         E.fresh_symbol             >>= fun object_sym     ->
         E.fresh_symbol             >>= fun desired_sym    ->
         translate_rvalue object_e  >>= fun object_core_e  ->
         translate_rvalue desired_e >>= fun desired_core_e ->
         E.return $
           (* TODO: or strong seq? *)
           (* TODO: unspec for object_e *)
           C.Ewseq (Caux.mk_tuple_pat [ Caux.mk_sym_pat object_sym  (C.BTy_object C.OTy_pointer)
                                      ; Caux.mk_sym_pat desired_sym (C.BTy_loaded C.OTy_pointer) ]) (C.Eunseq [object_core_e; desired_core_e])
             (C.Eaction (C.Paction C.Pos (C.Action loc () (C.Store (Caux.mk_ail_ctype_pe ref_ty)
               (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) object_sym)
               (Caux.mk_sym_pe (C.BTy_loaded C.OTy_pointer) desired_sym) mo)))
             )
     
     | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEbuiltin "atomic_load_explicit")) [object_e; order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         let ref_ty = match ctype_of object_e with
           | Aty.Pointer _ ref_ty ->
               ref_ty
           | _ ->
               error "Translation.translate_expression, AilEcall atomic_load_explicit: Ail type error"
         end in
         E.fresh_symbol             >>= fun object_sym     ->
         translate_rvalue object_e  >>= fun object_core_e  ->
         E.return $
           (* TODO: or strong seq? *)
           (* TODO: unspec for object_e *)
           C.Ewseq (Caux.mk_sym_pat object_sym (C.BTy_object C.OTy_pointer)) object_core_e
             (C.Eaction (C.Paction C.Pos (C.Action loc ()
                (C.Load (Caux.mk_ail_ctype_pe ref_ty) (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) object_sym) mo))))
     
     (* TODO: allow non trivial call to atomic_thread_fence() ... *)
     | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEident (Symbol.Symbol _ (Just "atomic_thread_fence")))) [order_e] ->
         (* TODO: be more permissive for the memory order *)
         let mo = translate_memory_order order_e in
         E.return $
           (C.Eaction (C.Paction C.Pos (C.Action loc () (C.Fence mo))))






      
(*
     | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEbuiltin "atomic_compare_exchange_strong_explicit")) [object_e; expected_e; desired_e; order_success_e; order_failure_e] ->
         let mo_success = translate_memory_order order_success_e in
         let mo_failure = translate_memory_order order_failure_e in
         let ty = match ctype_of object_e with
           | Aty.Pointer _ ty ->
               ty
           | _ ->
               error "Translation.translate_expression, AilEcall atomic_compare_exchange_strong_explicit: Ail type error"
         end in
         
         error "WIP: atomic_compare_exchange_strong_explicit"
(*
         E.fresh_symbol              >>= fun sym_object       ->
         E.fresh_symbol              >>= fun sym_expected_ptr ->
         E.fresh_symbol              >>= fun sym_expected_val ->
         E.fresh_symbol              >>= fun sym_desired      ->
         translate_rvalue object_e   >>= fun core_object_e    ->
         translate_rvalue expected_e >>= fun core_expected_e  ->
         translate_rvalue desired_e  >>= fun core_desired_e   ->
         E.return $
           (* TODO: weak or strong seq? *)
           C.Esseq [Just sym_object; Just sym_expected_ptr; Just sym_desired] (C.Eunseq [core_object_e; core_expected_e; core_desired_e])
             (C.Esseq [Just sym_expected_val] (Caux.pload loc (Caux.mk_ail_ctype_pe (AilTypesAux.unatomic ty)) (C.PEsym sym_expected_ptr) Cmm.NA)
                (Caux.prmw loc (Caux.mk_ail_ctype_pe (AilTypesAux.unatomic ty)) (C.PEsym sym_object) (C.PEsym sym_expected_val) (C.PEsym sym_desired)
                   mo_success mo_failure)
             )
*)

(*
             (C.Eaction (C.Paction C.Pos (C.Action loc ()
               (C.CompareExchangeStrong (Caux.mk_ail_ctype_pe ty) (C.PEsym sym_object) (C.PEsym sym_expected) (C.PEsym sym_desired) mo_success mo_failure))))
*)


      (* TODO:
           * (§6.5.2.2#6) since we don't support prototype-less functions, we don't do
                          "default argument promotions"
       *)

      | A.AilEcall (A.AnnotatedExpression _ _ (A.AilEident (Symbol.Symbol _ (Just "malloc")))) [e] ->
          translate_rvalue e >>= fun core_e ->
          E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
          E.return $
            C.Esseq [Just sym_ty_e] core_e
              (C.Eaction (C.Paction C.Pos (C.Action loc () (
                C.Alloc (C.PEval (C.Vobject (C.OVinteger (Mem.alignof_ival Cty.unsigned_char)))) (C.PEsym sym_ty_e) (Symbol.PrefOther "malloc")
              ))))

*)

(* TODO ==> FUNCTION CALLS

  §6.5.2.2#6 is very stange, in particular this bit:
    
    "If the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, ...) or the types of the arguments after promotion are not compatible with the types of the parameters, the behavior is undefined."
    
    apparently this has to do with old-style function declaration which we don't
    support (doesn't even parse). So the elab doesn't need to do anything here ? (CHECK !!!)


TODO: check the prototype vs no prototype stufff (ARGGGGGG)

TODO: #9
*)
      | A.AilEcall e [] ->
          translate_rvalue e >>= fun core_e ->
          E.fresh_symbol     >>= fun fun_sym         ->
          E.fresh_symbol     >>= fun nparams_sym     ->
          E.fresh_symbol     >>= fun is_variadic_sym ->
          let fun_sym_pe     = Caux.mk_sym_pe (C.BTy_object C.OTy_cfunction) fun_sym     in
          let nparams_sym_pe = Caux.mk_sym_pe (C.BTy_object C.OTy_integer)   nparams_sym in
          (* if there are no arguments, we don't need all the temporary object creation stuff *)
          E.return $
            (* TODO: indet + check that wseq is right *)
            C.Ewseq
              (Caux.mk_tuple_pat [ Caux.mk_sym_pat fun_sym         (C.BTy_object C.OTy_cfunction)
                                 ; Caux.mk_sym_pat nparams_sym     (C.BTy_object C.OTy_integer)
                                 ; Caux.mk_sym_pat is_variadic_sym C.BTy_boolean ])
              core_e
              begin
                C.Eif (Caux.mk_op_pe C.OpEq nparams_sym_pe (Caux.mk_integer_pe 0))
                  (C.Eproc default fun_sym_pe [])
                  (C.Epure (Caux.mk_undef_pe Undefined.UB039))
              end
      | A.AilEcall e es ->
          let (params, isVariadic) = match ctype_of e with
            | Aty.Pointer _ (Aty.Function _ _ xs b) ->
                (xs, b)
            | ty ->
                error ("Translation, AilEcall - (ctype_of e = " ^ Pp.stringFromAil_ctype ty ^ ") <> Function")
          end in
          
          let numberOfArguments = List.length es in
          translate_rvalue e >>= fun core_e          ->
          E.fresh_symbol     >>= fun fun_sym         ->
          E.fresh_symbol     >>= fun nparams_sym     ->
          E.fresh_symbol     >>= fun is_variadic_sym ->
          E.fresh_symbol     >>= fun call_sym        ->
          let fun_sym_pe         = Caux.mk_sym_pe (C.BTy_object C.OTy_cfunction) fun_sym         in
          let nparams_sym_pe     = Caux.mk_sym_pe (C.BTy_object C.OTy_integer)   nparams_sym     in
          let is_variadic_sym_pe = Caux.mk_sym_pe C.BTy_boolean                  is_variadic_sym in
          let call_sym_bTy =
            match Caux.proj_ctype result_ty with
              | Core_ctype.Void ->
                C.BTy_unit
              | ty ->
                  C.BTy_loaded (Caux.core_object_type_of_ctype ty)
             end in
          let call_sym_pe = Caux.mk_sym_pe call_sym_bTy call_sym in
          
          (* symbolic names for the arguments temporary objects *)
          E.replicateM numberOfArguments E.fresh_symbol >>= fun arg_ptr_syms ->
          
          (* Core code of the evaluation of the argument, with creation and initialisation of the
             associated temporary objects *)
          (* NOTE: combine_params_args does the argument promotion for variadic functions *)
          E.mapM (fun (arg_ty, arg_e) ->
            translate_rvalue arg_e >>= fun core_arg_e  ->
            E.fresh_symbol         >>= fun arg_val_sym ->
            E.fresh_symbol         >>= fun arg_ptr_sym ->
            let arg_sym_bTy =
              C.BTy_loaded (Caux.core_object_type_of_ctype (Caux.proj_ctype arg_ty)) in
            let arg_ctype_pe = Caux.mk_ail_ctype_pe arg_ty in
            let arg_val_sym_pe = Caux.mk_sym_pe arg_sym_bTy arg_val_sym in
            E.return (
              C.Ewseq (Caux.mk_sym_pat arg_val_sym arg_sym_bTy)
                core_arg_e
              (C.Ewseq (Caux.mk_sym_pat arg_ptr_sym (C.BTy_object C.OTy_pointer))
                (Caux.pcreate loc (Caux.mk_alignof_pe arg_ctype_pe) arg_ctype_pe (Symbol.PrefOther "translation, AilEcall temp"))
                (C.Ewseq (Caux.mk_empty_pat C.BTy_unit)
                   begin
                     let conved_init =
                       if AilTypesAux.is_integer arg_ty then
                         conv_loaded_int [(* Caux.mk_ail_ctype_pe (ctype_of e); *) arg_ctype_pe; arg_val_sym_pe]
                       else if arg_ty = Aty.Basic (Aty.Floating (Aty.RealFloating Aty.Float)) then
                         (* TODO: convert to double *)
                         arg_val_sym_pe
                       else
                         arg_val_sym_pe in
                     (Caux.pstore loc arg_ctype_pe
                        (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) arg_ptr_sym) conved_init Cmm.NA)
                   end
                   (C.Epure (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) arg_ptr_sym))))
            )
          ) (combine_params_args params es) >>= fun core_creates ->
          
          (* STD (§6.5.2.2#10, first sentence) says there is sequence point "after the
             evaluations of the function designator and the actual arguments but before
             the actual call." *)
          C.Esseq
            begin
             Caux.mk_tuple_pat $
               (Caux.mk_tuple_pat [ Caux.mk_sym_pat fun_sym         (C.BTy_object C.OTy_cfunction)
                                  ; Caux.mk_sym_pat nparams_sym     (C.BTy_object C.OTy_integer)
                                  ; Caux.mk_sym_pat is_variadic_sym C.BTy_boolean ]) ::
               List.map (fun sym -> Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) arg_ptr_syms
            end
              (Caux.mk_unseq (core_e :: core_creates))
              <$> begin
                      (* not (if is_variadic then nparams <= args else nparams = args) *)
                C.Eif (Caux.mk_not_pe
                         (Caux.mk_if_pe is_variadic_sym_pe
                            (Caux.mk_op_pe C.OpLe nparams_sym_pe (Caux.mk_integer_pe (integerFromNat numberOfArguments)))
                            (Caux.mk_op_pe C.OpEq nparams_sym_pe (Caux.mk_integer_pe (integerFromNat numberOfArguments)))))
                  (C.Epure (Caux.mk_undef_pe Undefined.UB039))
                  <$> begin
                    if numberOfArguments = 0 then
                      (* If there are no arguments, we don't need all the temporary object creation stuff *)
                      E.return (C.Eproc default fun_sym_pe [])
                    else
                      (* TODO: WIP *)
                      E.return (
                        C.Esseq (Caux.mk_sym_pat call_sym call_sym_bTy)
                          (* the actual call *)
                          begin
                            (* merging the additional arguments of a variadic function into a list *)
                            let arg_ptr_syms_pes =
(*
                              let (xs, ys) = List.splitAt (List.length params)
                                               (List.map (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer)) arg_ptr_syms) in
*)
                              let (xs_syms, ys_syms) = List.splitAt (List.length params) arg_ptr_syms  in
                              (* these are the arguments corresponding to declared parameters *)
                              let xs = List.map (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer)) xs_syms in
                              
                              if isVariadic then
                                 let ys = List.map (fun (e, sym) ->
                                   Caux.mk_tuple_pe
                                     [ Caux.mk_ail_ctype_pe (ctype_of e)
                                     ; Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym ]
                                 ) (List.zip (List.drop (List.length params) es) ys_syms) in
                                 xs ++ [Caux.mk_list_pe ys]
                              else
                                 xs in
                            C.Eproc default fun_sym_pe arg_ptr_syms_pes
                          end
                          begin
                            let bTy =
                              if List.length arg_ptr_syms < 2 then
                                C.BTy_unit
                              else
                                C.BTy_tuple (List.replicate (List.length arg_ptr_syms) C.BTy_unit) in
                            C.Esseq (Caux.mk_empty_pat bTy)
                              (* killing of the temporary objects *)
                              (Caux.mk_unseq (List.map (fun sym -> Caux.pkill loc (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)) arg_ptr_syms))
                              (* forwarding the value of call *)
                              (C.Epure call_sym_pe)
                          end
                      )








(*
                      (C.Ewseq [] (Caux.mk_unseq core_inits)
                        (C.Ewseq [Just (a_call, C.BTy_any (* TODO *))] (C.Eindet $ C.Eproc default (C.PEval (C.Vobject (C.OVcfunction fname)))
                                                  (if is_variadic then syms1 ++ [Caux.mk_cons syms_reminder] else syms1))
                          (C.Ewseq [] (Caux.mk_unseq core_kills)
                            (C.Epure (C.PEsym (a_call, C.BTy_any (* TODO *))))
                          )
                        )
                      )
*)



                  end
              end
(*
      
      | A.AilEcall e es ->
          translate_rvalue e >>= fun core_e ->
          E.fresh_symbol     >>= fun sym_e  ->
          let sym_ty_e = (sym_e, C.BTy_object C.OTy_cfunction) in
          error "AilEcall WIP"
(*
          match e with
            | A.AnnotatedExpression _ _ (A.AilEident fid) ->
                (* If the function is just declared in a prototype but not defined,
                   assume it is provided by the implementation. *)
                let fname =
                  if is_defined_ail_function fid program then
                    C.Sym fid
                  (* TODO: this is dirty *)
                  else match fid with
                    | Symbol.Symbol _ Nothing ->
                        error "TODO: error"
                    
                    | Symbol.Symbol _ (Just "printf") ->
                        (* TODO: temporary hack *)
                        let is_printf_proxy = function
                          | ((Symbol.Symbol _ (Just z)), _) ->
                              z = "printf_proxy"
                          | _ -> false
                        end in
                        match mk_stdcall_aux is_printf_proxy (Map_extra.toList stdlib) with
                          | Just (f, _) -> Core.Sym f
                          | Nothing -> error "Translation.translate_expression, AilEcall printf"
                        end

                    | Symbol.Symbol _ (Just "malloc") ->
                        error "Translation.malloc"
(*
                          (* TODO: temporary hack *)
                        match mk_stdcall_aux (function ((Symbol.Symbol _ (Just z)), _) -> z = "malloc_proxy" | _ -> false end) (Map_extra.toList stdlib) with
                          | Just (f, _) -> Core.Sym f
                          | Nothing -> error "Translation.translate_expression, AilEcall malloc"
                        end
*)

                    | Symbol.Symbol _ (Just str) ->
                        C.Impl (Implementation_.StdFunction str)
                  end in
                
                if List.length es = 0 then
                  (* if there are no arguments, we don't need all the temporary object creation stuff *)
                  E.return $ C.Eproc default (C.PEval (C.Vobject (C.OVcfunction fname))) []
                else
                  (* TODO: variadic case *)
                  let (has_proto, (* TODO: return_ty *) _, params, is_variadic) =
                    match Context.lookup (=) (snd program).A.declarations fid with
                      | Just (A.Decl_function has_proto return_ty params is_variadic (* TODO: is_inline is_Noreturn *) _ _) ->
                          (has_proto, return_ty, params, is_variadic)
                      | _ ->
                         error "[Translate] impossible error: TODO move to Exception.t"
                    end in
                  let n = List.length es in
                  
                  (* symbolic names for the temporary objects and init value *)
                  E.replicateM n E.fresh_symbol >>= fun as_tmp  ->
                  
                  (* create actions for the temporary objects *)
                  let core_creates =
                    if is_variadic then
                      (* TODO: check the std *)
                      List.map (fun e ->
                        let c_ty = Caux.mk_ail_ctype_pe (AilTypesAux.rvalue_coercion (ctype_of e)) in
                        Caux.pcreate loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefOther "translation, AilEcall temp")
                      ) es
                    else
                      List.map (fun (_, ty) ->
                        let c_ty = Caux.mk_ail_ctype_pe ty in
                        Caux.pcreate loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefOther "translation, AilEcall temp")) params in
                  
                  (* the list of "Nothing" is empty if the function is not variadic *)
                  let params' =
                    List.map (fun z -> Just z) params ++ (List.replicate (n - List.length params) Nothing) in
                  
                  
                  (* their initialisations *)
                  E.mapM (fun (sym, param_opt, e) ->
                    let param_ty = match param_opt with
                      | Just (_, ty) -> ty
                      | Nothing      -> AilTypesAux.rvalue_coercion (ctype_of e) (* TODO: check the std *)
                    end in

(* TODO !!!!! shouldn't do this here *)
                if AilTypesAux.is_pointer param_ty && Aaux.is_null_pointer_constant e then
                    match param_ty with
                      | Aty.Pointer _ ref_ty ->
                          E.return $
                          (Caux.pstore loc (Caux.mk_ail_ctype_pe param_ty) (C.PEsym sym) (Caux.nullptr_pexpr (Caux.proj_ctype ref_ty)) Cmm.NA)

                          
                    end
             else

                    E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_init ->
                    translate_rvalue e >>= fun core_e ->
                    let conved_init = conv [Caux.mk_ail_ctype_pe (ctype_of e); Caux.mk_ail_ctype_pe param_ty; C.PEsym sym_ty_init] in
                    E.return $
                      C.Ewseq [Just sym_ty_init] core_e
                        (Caux.pstore loc (Caux.mk_ail_ctype_pe param_ty) (C.PEsym sym) conved_init Cmm.NA)
                  ) (zip3 as_tmp params' es) >>= fun core_inits ->
                  
                  (* their kill actions *)
                  let core_kills = List.map (Caux.pkill loc -| C.PEsym) as_tmp in
                  
                  (* TODO: doc (merging the additional params of a variadic function into a Core list of pointer) *)
                  let (syms1, syms_reminder) =
                    if is_variadic then
                      List.splitAt (List.length params) $ List.map C.PEsym as_tmp
                    else
                      (List.map C.PEsym as_tmp, []) in
                  
                  (* TODO: factorise ... *)
                  let syms_reminder =
                    match fid with
                      | Symbol.Symbol _ (Just "printf") ->
                          (* NOTE: for printf we add the inferred types of of the arguments... *)
                          let (_, _es) = List.splitAt (List.length params) es in
                          let tys = List.map (fun z -> AilTypesAux.rvalue_coercion (ctype_of z)) es in
                          List.map (fun (ty, z) -> C.PEtuple [Caux.mk_ail_ctype_pe ty; z]) (zip (List.drop 1 tys) syms_reminder)
                      | _ ->
                          syms_reminder
                    end in
                  
                  (* symbolic name for the call result *)
                  E.fresh_symbol >>= fun a_call ->


        E.print_debug 2 "ENDING AilEcall" >> (* DEBUG *)

(
                  E.return $
                    C.Ewseq (List.map (fun z -> Just z) as_tmp) (Caux.mk_unseq core_creates)
                      (C.Ewseq [] (Caux.mk_unseq core_inits)
                        (C.Ewseq [Just (a_call, C.BTy_any (* TODO *))] (C.Eindet $ C.Eproc default (C.PEval (C.Vobject (C.OVcfunction fname)))
                                                  (if is_variadic then syms1 ++ [Caux.mk_cons syms_reminder] else syms1))
                          (C.Ewseq [] (Caux.mk_unseq core_kills)
                            (C.Epure (C.PEsym (a_call, C.BTy_any (* TODO *))))
                          )
                        )
                      )
)
            | _ -> error ("[Translation.translate_exp, A.CALL e es] a function id is declared with a non-function type ==> " ^ Boot.pp_ail_expr e)
          end
*)

      
      | A.AilEassert e ->
          E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
          translate_rvalue e >>= fun core_e   ->
          E.return $
            C.Esseq [Just sym_ty_e] core_e 
              (C.Epure (C.PEif (Caux.mk_op_pe C.OpEq (C.PEsym sym_ty_e) (Caux.mk_integer_pe 0))
                          (C.PEerror "assert() failure" (C.PEval C.Vunit))
                          (C.PEval C.Vunit)
                       )
              )
      
      | A.AilEoffsetof ty membr_ident ->
          let tag_sym = match ty with
            | Aty.Struct x ->
                x
            | Aty.Union x ->
                x
            | _ ->
                error "[Translation.translate_expression, A.AilEoffsetof] found an Ail type error]"
          end in
          E.return $
            C.Epure (C.PEval (C.Vobject (C.OVinteger (Mem.offsetof_ival tag_sym membr_ident))))
      
      | A.AilEgeneric _ _ ->
          error "WIP: Translation.translate_expression, AilEgeneric"
      
*)
      | A.AilEarray _ e_opts ->
          let elem_ty = match result_ty with
            | Aty.Array ty _ ->
                ty
            | _ ->
                error "Translation.translate_expression, AilEarray: Ail type error"
          end in
          E.foldlM (fun (acc, mk_expr) e_opt ->
             match e_opt with
               | Just e ->
                   E.fresh_symbol     >>= fun e_sym  ->
                   translate_rvalue e >>= fun core_e ->
                   let bTy =
                     C.BTy_loaded (Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e))) in
                   E.return
                     (Caux.mk_sym_pe bTy e_sym :: acc, (C.Ewseq (Caux.mk_sym_pat e_sym bTy) core_e) -| mk_expr)
               | Nothing ->
                   E.return
                     (Caux.mk_unspecified_pe (Caux.proj_ctype elem_ty) :: acc, mk_expr)
             end
          ) ([], id) e_opts >>= fun (rev_pes, mk_expr) ->
          E.return $
             mk_expr (C.Epure (C.Pexpr () (C.PEctor C.Carray (List.reverse rev_pes))))

(*
          E.foldlM (fun (acc, mk_core) e_opt ->
            match e_opt with
              | Just e ->
                  E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
                  (if AilTypesAux.is_pointer elem_ty && Aaux.is_null_pointer_constant e then
                    match elem_ty with
                      | Aty.Pointer _ ref_ty ->
                          E.return (C.Epure (Caux.nullptr_pexpr (Caux.proj_ctype ref_ty)))
                    end
                  else
                    translate_rvalue e)
                  >>= fun core_e ->
                  E.return (C.PEsym sym_ty_e :: acc, fun z -> C.Esseq [Just sym_ty_e] core_e (mk_core z))
              | Nothing ->
                  E.return (C.PEval (C.Vunspecified $ Caux.proj_ctype elem_ty) :: acc, mk_core)
            end
          ) ([], fun z -> z) (List.reverse e_opts) >>= fun (pes, mk_core) ->
          E.return $
            mk_core (C.Epure (C.PEctor C.Carray pes))
*)
(*
      
      | A.AilEstruct tag_sym ident_e_opts ->
          let ident_tys = fromJust "Translation.translate_expression, AilEstruct 1" $ Map.lookup tag_sym (Cty.tagDefs ()) in
          E.foldlM (fun (acc, mk_core) (ident, e_opt) ->
            match e_opt with
              | Just e ->
                  let memb_ty = fromJust "Translation.translate_expression, AilEstruct 2" $ List.lookup ident ident_tys in
                    E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
                  (if AilTypesAux.is_pointer (Caux.unproj_ctype memb_ty) && Aaux.is_null_pointer_constant e then
                    match memb_ty with
                      | Cty.Pointer _ ref_ty ->
                          E.return (C.Epure (Caux.nullptr_pexpr ref_ty))
                    end
                  else
                    E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
                    translate_rvalue e >>= fun core_e ->
                    E.return (
                      C.Esseq [Just sym_ty_e] core_e
                        (C.Epure (conv [Caux.mk_ail_ctype_pe (ctype_of e); C.PEval (C.Vctype memb_ty); C.PEsym sym_ty_e]))
                    )
                  ) >>= fun core_e ->
                  E.return (
                    (ident, C.PEsym sym_ty_e) :: acc,
                    fun z -> C.Esseq [Just sym_ty_e] core_e (mk_core z)
                  )
              | Nothing ->
                  let ty = fromJust "Translation.translate_expression, AilEstruct 3" $ List.lookup ident ident_tys in
                  E.return (
                    (ident, C.PEval (C.Vunspecified ty)) :: acc,
                    mk_core
                  )
            end
          ) ([], fun z -> z) ident_e_opts >>= fun (core_xs_rev, mk_core) ->
          E.return $
            mk_core (C.Epure (C.PEstruct tag_sym (List.reverse core_xs_rev)))
      
      | A.AilEcompound _ _ ->
          error "WIP: Translation.translate_expression, AilEcompound"




(* TODO: atomic undef *)
      | A.AilEmemberof e ident ->
          let tag_sym = match ctype_of e with
            | Aty.Struct tag_sym ->
                tag_sym
            | Aty.Union tag_sym ->
                tag_sym
            | _ ->
                error "Translation.translate_expression, AilEmemberof: Ail type error"
          end in
          E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
          translate_lvalue e >>= fun core_e -> (* TODO: not sure about always using _lvalue here *)
          if is_lvalue then
            E.return $
              C.Esseq [Just sym_ty_e] core_e
                (C.Epure (C.PEmember_shift (C.PEsym sym_ty_e) tag_sym ident))
          else
            E.return $
              C.Esseq [Just sym_ty_e] core_e
                (Caux.pload loc (Caux.mk_ail_ctype_pe result_ty) (C.PEmember_shift (C.PEsym sym_ty_e) tag_sym ident) Cmm.NA) (* TODO: check MO *)
(*
            E.fresh_symbol >>= fun sym_lvalue ->
            E.return $
              C.Esseq [Just sym_e] core_e (
                C.Esseq [Just sym_lvalue]  (C.Epure (C.PEshift (C.PEsym sym_e) (shiftPathFromMember program tag_sym ident)))
                  (Caux.pload (Caux.mk_ail_ctype_pe result_ty) (C.PEsym sym_lvalue) Cmm.NA) (* TODO: check MO *)
              )
*)

      | A.AilEmemberofptr e ident ->
          let tag_sym = match ctype_of e with
            | Aty.Pointer _ (Aty.Struct tag_sym) ->
                tag_sym
            | Aty.Pointer _ (Aty.Union tag_sym) ->
                tag_sym
            | _ ->
                error "Translation.translate_expression, AilEmemberofptr: Ail type error"
          end in

          (* TODO: check *)
          E.fresh_typed_symbol true (ctype_of e) >>= fun sym_ty_e ->
          translate_rvalue e >>= fun core_e ->
          E.return $
            C.Esseq [Just sym_ty_e] core_e
              ((fun z ->
                if is_lvalue then
                  C.Epure z
                else
                  let memb_ty = fromJust "Translation.translate_expression, AilEmemberofptr" (List.lookup ident (Cty.get_membersDefs tag_sym)) in
                  Caux.pload loc (C.PEval (C.Vctype memb_ty)) z Cmm.NA (* TODO: check MO *)
              ) (C.PEmember_shift (C.PEsym sym_ty_e) tag_sym ident))
(*
              (C.Epure (C.PEshift (C.PEsym sym_e) (shiftPathFromMember program tag_sym ident)))
*)

(*
      | A.AilEmemberof e ident ->
          let (Aty.Struct tag_sym) = ctype_of e in
          E.fresh_symbol                    >>= fun a_e    ->
          translate_lvalue stdlib program e >>= fun core_e ->
          E.return $
            C.Esseq [Just a_e] core_e
              (C.Eshift (C.PEsym a_e) (shiftPathFromMember program tag_sym ident))
*)

*)

      | A.AilEconst cst ->
          E.return $ C.Epure (
            C.Pexpr () match cst with
              | A.ConstantIndeterminate ty ->
                  (* NOTE: we assume the lack of trap representation *)
                  C.PEval (C.Vunspecified (Caux.proj_ctype ty))
              | A.ConstantNull ->
                  (* TODO: should make the Ail ctor take a ctype? *)
                  Caux.strip $ Caux.mk_nullptr_pe Cty.Void
              | A.ConstantInteger (A.IConstant n _ _) ->
                  (* TODO: suffix/basis? + check *)
                  C.PEval (C.Vspecified (C.OVinteger (Mem.integer_ival n)))
              | A.ConstantInteger (A.IConstantMax ity) ->
                  C.PEval (C.Vspecified (C.OVinteger (Mem.max_ival ity)))
              | A.ConstantInteger (A.IConstantMin ity) ->
                  C.PEval (C.Vspecified (C.OVinteger (Mem.min_ival ity)))
              | A.ConstantFloating str ->
                  C.PEval (C.Vspecified (C.OVfloating (Mem.str_fval str)))
              | A.ConstantCharacter (_, str) ->
                  (* TODO: prefix? *)
                  (* TODO: making an implementation fix here (ASCII) *)
                  C.PEval (C.Vspecified (C.OVinteger (Mem.integer_ival (Decode.decode_character_constant str))))
              | A.ConstantArray (* TODO: csts *) _ ->
                  error "WIP: Translation AilEconst, ConstantArray"
              | A.ConstantStruct (* TODO: tag_sym xs *) _ _ ->
                  error "WIP: Translation AilEconst, ConstantStruct"
            end
          )
(*
      | A.AilEbuiltin str ->
          (* TODO: the redundance with Builtins.lem is wrong *)
          E.return $ C.Epure match str with
            | "INT8_MIN" ->
                Caux.ivmin_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 8))))))
            | "INT16_MIN" ->
                Caux.ivmin_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 16))))))
            | "INT32_MIN" ->
                Caux.ivmin_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 32))))))
            | "INT64_MIN" ->
                Caux.ivmin_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 64))))))
            | "INT8_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 8))))))
            | "INT16_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 16))))))
            | "INT32_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 32))))))
            | "INT64_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Signed (Aty.IntN_t 64))))))
            | "UINT8_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 8))))))
            | "UINT16_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 16))))))
            | "UINT32_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 32))))))
            | "UINT64_MAX" ->
                Caux.mk_ivmax_pe (C.PEval (C.Vctype (Cty.Basic (Aty.Integer (Aty.Unsigned (Aty.IntN_t 64))))))
            | "CHAR_BIT" ->
                C.PEimpl Implementation_.Characters__bits_in_byte
            | _ ->
                error ( "Translation AilEbuiltin> " ^ str)
          end
      
*)
      (* TODO: prefix + check, §6.4.5#6 *)
      | A.AilEstr (pref_opt, strs) ->
          let elem_ty = match pref_opt with
            | Nothing ->
                (* STD §6.4.5#6, sentence 3 *)
                Cty.Basic (Aty.Integer Aty.Char)
            | Just A.Enc_u8 ->
                (* STD §6.4.5#6, sentence 4 *)
                Cty.Basic (Aty.Integer Aty.Char)
            | Just A.Enc_u ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char16_t
            | Just A.Enc_U ->
                (* STD §6.4.5#6, sentence 6 *)
                Cty.char32_t
            | Just A.Enc_L ->
                (* STD §6.4.5#6, sentence 5 *)
                Cty.Builtin "whcar_t"
          end in
          
          E.fresh_symbol >>= fun sym ->
          (* TODO: making an implementation fix here (ASCII), not doing prefix properly *)
          let elems = List.map (fun c_str ->
            C.OVinteger (Mem.integer_ival (Decode.decode_character_constant c_str))
          ) strs ++ [C.OVinteger (Mem.integer_ival 0)] in
          E.register_string_literal loc sym (Cty.Array elem_ty (Just (integerFromNat $ List.length elems)))
             (Caux.mk_specified_pe (C.Pexpr () (C.PEval (C.Vobject (C.OVarray elems))))) >>
          E.return (
            C.Epure (Caux.mk_specified_pe (Caux.mk_sym_pe (C.BTy_loaded C.OTy_pointer) sym))
          )

(*

(*

n := | str |

let strong a  = create("char[n+1]", <alignof>("char[n+1]")) in
store("char[n+1]", a, array(...)) ;
a


          E.return (C.Econst $ C.Cstring (String.toCharList str)) (* TODO: this is a hack, this should be a pointer to a global char pointer *)
*)
      
      
      | A.AilEsizeof _ (Aty.Basic (Aty.Integer Aty.Char))                 -> E.return $ C.Epure (Caux.mk_integer_pe 1)
      | A.AilEsizeof _ (Aty.Basic (Aty.Integer (Aty.Signed Aty.Ichar)))   -> E.return $ C.Epure (Caux.mk_integer_pe 1)
      | A.AilEsizeof _ (Aty.Basic (Aty.Integer (Aty.Unsigned Aty.Ichar))) -> E.return $ C.Epure (Caux.mk_integer_pe 1)
      | A.AilEsizeof _ ty ->
          E.return $
            C.Epure (Caux.sizeof $ Caux.mk_ail_ctype_pe ty)
      
      | A.AilEsizeof_expr e ->
          (* TODO: check qualifiers *)
          translate_rvalue (A.AnnotatedExpression annot loc (A.AilEsizeof Aty.no_qualifiers (ctype_of e)))
      
      | A.AilEalignof _ ty ->
          E.return $
            C.Epure (Caux.mk_alignof_pe $ Caux.mk_ail_ctype_pe ty)

(*
  TODO: need to bring them back to the new Ail
      | A.MEMBEROF e x ->
      | A.MEMBEROFPTR e x ->

      | A.EXPR_SIZEOF e ->
          E.return (C.sizeof $ Caux.mk_ail_ctype_pe (Annotate.ctype_of e))

    | A.StringLiteral lit ->

    | A.Malloc e -> do E
        a_e    <- E.fresh_symbol;
        core_e <- translate_expression e; in
          E.return $ C.Ewseq [Just a_e] core_e (Caux.palloc (C.PEsym a_e) [])
        end
    
    | A.Free e -> do E
        a_e    <- E.fresh_symbol;
        core_e <- translate_expression e; in
          E.return $ C.Ewseq [Just a_e] core_e (Caux.pkill (C.PEsym a_e))
        end
    
    | A.Memcmp e1 e2 e3 ->
    | A.Memcpy e1 e2 e3 ->
    
    | A.Assert e -> do E
        a_e    <- E.fresh_symbol;
        core_e <- translate_expression e; in
          E.return $
            C.Ewseq [Just a_e] core_e
              (C.Eif (Caux.mk_op_pe C.OpEq (C.PEsym a_e) (Caux.mk_integer_pe 0)) C.Eerror C.Eskip)
        end
    
    | A.ConstArray es ->
    | A.ConstStructUnion field_es ->
    | A.Offsetof ty x ->
*)
      | A.AilEannot _ e ->
          translate_expr e
      | A.AilEva_start e sym ->
          error "WIP: Translation.translate_expr, AilEva_start"
      | A.AilEva_arg e ty ->
          error "WIP: Translation.translate_expr, AilEva_arg"
*)

      | e ->
          match e with
            | A.AilEunary _ _ ->
                error "AilEunary"
            | A.AilEbinary _ bop _ ->
                let str = match bop with
                  | A.Arithmetic A.Mul ->
                      "Mul"
                  | A.Arithmetic A.Div ->
                      "Div"
                  | A.Arithmetic A.Mod ->
                      "Mod"
                  | A.Arithmetic A.Add ->
                      "Add"
                  | A.Arithmetic A.Sub ->
                      "Sub"
                  | A.Arithmetic A.Shl ->
                      "Shl"
                  | A.Arithmetic A.Shr ->
                      "Shr"
                  | A.Arithmetic A.Band ->
                      "Band"
                  | A.Arithmetic A.Bxor ->
                      "Bxor"
                  | A.Arithmetic A.Bor ->
                      "Bor"
                  | A.Comma ->
                      "Comma"
                  | A.And ->
                      "And"
                  | A.Or ->
                      "Or"
                  | A.Lt ->
                      "Lt"
                  | A.Gt ->
                      "Gt"
                  | A.Le ->
                      "Le"
                  | A.Ge ->
                      "Ge"
                  | A.Eq ->
                      "Eq"
                  | A.Ne ->
                      "Ne"
                end in
                error ("AilEbinary " ^ str)
            | A.AilEassign _ _ ->
                error "AilEassign"
            | A.AilEcompoundAssign _ _ _ ->
                error "AilEcompoundAssign"
            | A.AilEcond _ _ _ ->
                error "AilEcond"
            | A.AilEcast _ _ _ ->
                error "AilEcast"
            | A.AilEcall _ _ ->
                error "AilEcall"
            | A.AilEassert _ ->
                error "AilEassert"
            | A.AilEoffsetof _ _ ->
                error "AilEoffsetof"
            | A.AilEgeneric _ _ ->
                error "AilEgeneric"
            | A.AilEarray _ _ ->
                error "AilEarray"
            | A.AilEstruct _ _ ->
                error "AilEstruct"
            | A.AilEcompound _ _ ->
                error "AilEcompound"
            | A.AilEmemberof _ _ ->
                error "AilEmemberof"
            | A.AilEmemberofptr _ _ ->
                error "AilEmemberofptr"
            | A.AilEbuiltin _ ->
                error "AilEbuiltin"
            | A.AilEstr _ ->
                error "AilEstr"
            | A.AilEconst _ ->
                error "AilEconst"
            | A.AilEident _ ->
                error "AilEident"
            | A.AilEsizeof _ _ ->
                error "AilEsizeof"
            | A.AilEsizeof_expr _ ->
                error "AilEsizeof_expr"
            | A.AilEalignof _ _ ->
                error "AilEalignof"
            | A.AilEannot _ _ ->
                error "AilEannot"
            | A.AilEva_start _ _ ->
                error "AilEva_start"
            | A.AilEva_arg _ _ ->
                error "AilEva_arg"
          end
    end







(* translate_stmt Pmap.empty program program.A.main C.Constants.return s *)

(* TODO[über HACK] `lasts' is the last of symbolic names saving the last statement for each block we are in
                   we need to remember them to annotate Erun/Esave coming from a C label/goto because these symbols
                   MAY (the fact it is a may is pretty disgusting) be in the continuations of the generated Esave (...)

RAAAAAAAAHHH: this doesn't work when the label is in a block the goto doesn't belong to ......
*)

module St = State
open State_operators

type collect_cases_state = <|
  found_default: bool;
  case_csts: list A.integerConstant
|>

val     collect_cases_: A.statement GenTypes.genTypeCategory -> St.t unit collect_cases_state
let rec collect_cases_ (A.AnnotatedStatement loc stmt) =
  let register_case n =
    St.update (fun s -> <| s with case_csts= n :: s.case_csts |>) in
  let register_default =
    St.update (fun s -> <| s with found_default= true |>) in
  match stmt with
    | A.AilSskip ->
        St.return ()
    | A.AilSexpr _ ->
        St.return ()
    | A.AilSblock _ ss ->
        St.mapM_ collect_cases_ ss
    | A.AilSif _ s1 s2 ->
        collect_cases_ s1 >> collect_cases_ s2
    | A.AilSwhile _ s ->
        collect_cases_ s
    | A.AilSdo s _ ->
        collect_cases_ s
    | A.AilSbreak ->
        St.return ()
    | A.AilScontinue ->
        St.return ()
    | A.AilSreturnVoid ->
        St.return ()
    | A.AilSreturn _ ->
        St.return ()
    | A.AilSswitch _ _ ->
        St.return ()
    | A.AilScase n s ->
        register_case n >> collect_cases_ s
    | A.AilSdefault s ->
        register_default >> collect_cases_ s
    | A.AilSlabel _ s ->
        collect_cases_ s
    | A.AilSgoto _ ->
        St.return ()
    | A.AilSdeclaration _ ->
        St.return ()
    | A.AilSpar ss ->
        (* TODO: check *)
        St.mapM_ collect_cases_ ss
  end
let collect_cases s =
  snd $ St.run (collect_cases_ s) <| found_default= false; case_csts= [] |>


open Operators

type translate_stmt_labels = <|
  default : maybe C.ksym;
  cases   : list (C.sym * C.ksym); (* the syms are bound to the pexprs corresponding to the integer constants *)
  loop    : maybe C.ksym;
  break   : maybe C.ksym;
  return  : C.ksym;
|>


val translate_stmt:
  C.fun_map unit -> A.program GenTypes.genTypeCategory -> A.identifier    ->
(*  maybe Symbol.sym -> maybe (map integer Symbol.sym) -> maybe Symbol.sym -> maybe Symbol.sym -> *)
  translate_stmt_labels ->
  A.statement GenTypes.genTypeCategory                                    ->
  E.t (C.core_base_type * C.expr unit)


let rec translate_stmt stdlib program f labs (A.AnnotatedStatement loc stmt) =
  let translate_lvalue e = translate_expression stdlib program true e  in
  let translate_rvalue e = translate_expression stdlib program false e in
  let translate_stmt_ s  = translate_stmt stdlib program f labs s      in
  let mk_stdcall fname   = mk_stdcall stdlib fname                     in
  let conv_int           = mk_stdcall "conv_int"                       in
  let conv_loaded_int    = mk_stdcall "conv_loaded_int"                in
  second (C.Eloc loc) <$> match stmt with
    | A.AilSskip ->
        E.return (C.BTy_unit, C.Eskip)
    
    | A.AilSexpr e ->
        (* TODO: the index *)
        translate_rvalue e >>= fun core_e ->
        E.return (C.BTy_unit, C.Ebound 0 core_e)
    
(*
    | A.AilSblock [] ss ->
        E.mapM translate_stmt_ ss >>= fun core_ss ->
        E.return $
          List.foldr (fun (bTy, core_s) acc ->
            C.Esseq (Caux.mk_empty_pat bTy) core_s acc
          ) C.Eskip core_ss
    
    | A.AilSblock [(sym, (dur_opt, qs, ty))] ss ->
        let c_ty = Caux.mk_ail_ctype_pe ty in
        E.push_block_objects [(sym, ty)] >>
        E.mapM (fun s -> translate_stmt_ s >>= fun core_s -> E.return core_s) ss >>= fun core_ss ->
        E.pop_block_objects >>
        E.return (
          C.Esseq (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer)) (Caux.pcreate loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefSource [f; sym])) (
            List.foldr (fun core_s acc ->
              C.Esseq (Caux.mk_empty_pat C.BTy_unit) core_s acc
            ) (Caux.pkill loc (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)) core_ss
          )
        )
    
    | A.AilSblock binds ss ->
        let decls = [ (sym, ty) | forall ((sym, (dur, qs, ty)) MEM binds ) | true ] in
        (* the symbolic names and create actions for the local variables *)
        let (pats, core_creates) =
          mapUnzip (fun (sym, ty) ->
            let c_ty = Caux.mk_ail_ctype_pe ty in
            (Caux.mk_sym_pat sym (C.BTy_object C.OTy_pointer), Caux.pcreate loc (Caux.mk_alignof_pe c_ty) c_ty (Symbol.PrefSource [f; sym]))
          ) decls in
        E.push_block_objects decls >>
        (* TODO: doing the kills here is now redundant if there is are returns before all exit point.
                 but it may be nasty to the check.
                 For non-void function however we know (?) that the must be these returns ?? so we could drop the kills here *)
        (* the kill actions for the local variables *)
        let (core_kills) =
          List.map (Caux.pkill loc -| (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer)) -| fst) decls in
        E.mapM (fun s -> translate_stmt_ s >>= fun core_s -> E.return core_s) ss >>= fun core_ss ->
        E.pop_block_objects >>
        E.return (
          let () = Debug.warn "Translation, AilSblock: sequencing the creates and kills" in
(*        C.Esseq (Caux.mk_tuple_pat pats) (Caux.mk_unseq core_creates)
            (foldr (fun core_s acc -> C.Esseq (C.CaseBase Nothing) core_s acc) (Caux.mk_unseq core_kills) core_ss)
        ) *)
          Caux.mk_wseqs (
            List.foldr (fun core_s acc ->
              C.Esseq (Caux.mk_empty_pat C.BTy_unit) core_s acc
            ) (Caux.mk_unit_sseq core_kills) core_ss
          )
          (List.zip pats core_creates)
        )
(*

(*      (* add the block local variables to the environment (fresh symbolic names are assigned) *)
      update_env env ids >>= fun env' ->
*)
      let n     = List.length decls in

      (* prepare the code creating the objects for the block local variables. *)
      let creates_ctx: C.expr zero -> C.expr zero =
        let (syms, xs) = mapUnzip (fun (a, ty) -> (Just a, Caux.pcreate (Caux.mk_ail_ctype_pe ty) [])) (List.rev decls) in
        match n with
          | 0 -> fun x -> x
          | 1 -> C.Ewseq syms (List.hd xs)
          | _ -> C.Ewseq syms (C.Eunseq xs)
        end in
      
      (* prepare the code killing the objects. *)
      let kills_ctx = let xs = List.map (fun (a, _) -> Caux.pkill (C.PEsym a)) decls in
                      match n with
                        | 0 -> fun x -> x
                        | 1 -> C.Ewseq [] (List.hd xs)
                        | _ -> C.Ewseq [] (C.Eunseq xs)
                      end in
      
      (* translate the statements with a symbolic name bound to the result of the last statement *)
      E.fresh_symbol >>= fun a_last ->
      E.mapWithLastM (fun s -> translate_stmt_ s >>= fun core_s ->
                               E.return ([], core_s))
                     (fun s -> translate_stmt_ s >>= fun core_s ->
                               E.return ([Just a_last], core_s))
                     ss >>= fun core_ss ->
      
      (* connecting everything an returning that symbolic name bounded to the result of last statement *)
      E.return $ creates_ctx
                 (List.fold_left (fun acc (_as, stmt) ->
                   if Caux.is_pure stmt then (match _as with
                                | [Just a] -> C.Elet a stmt acc
                                | []       -> acc
                                | _  -> Boot.outOfHomeomorphism "BOOM" end)
                   else C.Ewseq _as stmt acc)
                    (kills_ctx (if List.length ss = 0 then C.Eskip else C.PEsym a_last))
                    (List.rev core_ss))

*)  
    
    | A.AilSif e s1 s2 ->
      (* CHECKED IN APR2016 *)
        E.fresh_symbol      >>= fun sym     ->
        E.fresh_symbol      >>= fun sym_e   ->
(*        translate_rvalue e  >>= fun core_e  -> *)
        translate_rvalue (mkTestExpression e) >>= fun core_test ->
        translate_stmt_ s1  >>= fun core_s1 ->
        translate_stmt_ s2  >>= fun core_s2 ->
        let oTy =
          (* Since [e] must have scalar type, oTy will always be one
             of these: OTy_integer, OTy_floating, OTy_pointer *)
          Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
        E.return $
          (* NOTE: here we fix the strictness of unspecified values *)
          C.Ewseq (Caux.mk_sym_pat sym_e (C.BTy_loaded oTy)) core_test (
            C.Ecase (Caux.mk_sym_pe (C.BTy_loaded oTy) sym_e)
              [ (C.CaseCtor C.Cspecified [Caux.mk_sym_pat sym (C.BTy_object oTy)],
                 C.Eif (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (Caux.mk_sym_pe (C.BTy_object oTy) sym) (Caux.mk_integer_pe 1)))
                   core_s1 core_s2)
                (* non-deterministic branching if the test expression had unspecified value *)
              ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                 C.End [core_s1; core_s2]) ]
          )
    
    (* CHECKED IN MAR2016 *)
    | A.AilSwhile e s ->
        let () = Debug.warn "TODO: make the elab of AilSwhile use mkTestExpression" in
        E.fresh_named_symbol "loop"  >>= fun sym_loop  ->
        E.fresh_named_symbol "break" >>= fun sym_break ->
        E.fresh_symbol               >>= fun sym_case  ->
        E.fresh_symbol               >>= fun sym_e     ->
        translate_rvalue e           >>= fun core_e    ->
        translate_stmt stdlib program f
            <| labs with loop= Just sym_loop; break= Just sym_break |> s >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        let core_s_loop =
          C.Esseq (Caux.mk_empty_pat C.BTy_unit)
            core_s
            (C.Erun default sym_loop [ (sym, Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym) | forall (sym MEM visible_syms) | true ]) in
        let core_s_exit =
          C.Esave sym_break [ (sym, Cty.Void) | forall (sym MEM visible_syms) | true ] C.Eskip in
        E.return $
          C.Esave sym_loop [ (sym, Cty.Void) | forall (sym MEM visible_syms) | true ] (
            C.Esseq (Caux.mk_sym_pat sym_e (C.BTy_loaded C.OTy_integer)) core_e (
              C.Ecase (Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) sym_e)
                [ (Caux.mk_specified_pat (Caux.mk_sym_pat sym_case (C.BTy_object C.OTy_integer)),
                   C.Eif (Caux.mk_not_pe (Caux.mk_op_pe C.OpEq (Caux.mk_sym_pe (C.BTy_object C.OTy_integer) sym_case) (Caux.mk_integer_pe 0)))
                     core_s_loop core_s_exit)
                  (* non-deterministic branching if the test expression had unspecified value *)
                ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                   C.End [core_s_loop; core_s_exit]) ]
               )
            )
    
    (* CHECKED IN MAR2016 *)
    | A.AilSdo s e ->
        let () = Debug.warn "TODO: make the elab of AilSdo use mkTestExpression" in
        E.fresh_symbol               >>= fun sym_case  ->
        E.fresh_symbol               >>= fun sym_e     ->
        E.fresh_named_symbol "loop"  >>= fun sym_loop  ->
        E.fresh_named_symbol "break" >>= fun sym_break ->
        translate_rvalue e           >>= fun core_e    ->
        translate_stmt stdlib program f
            <| labs with loop= Just sym_loop; break= Just sym_break |> s >>= fun core_s ->
        E.get_visible_objects >>= fun visible_syms ->
        (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
        let core_s_loop =
          C.Esave sym_break [ (sym, Cty.Void)  | forall (sym MEM visible_syms) | true ] C.Eskip in
        let core_s_exit =
          C.Erun default sym_loop [ (sym, Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym) | forall (sym MEM visible_syms) | true ] in
        E.return $
          C.Esave sym_loop [ (sym, Cty.Void)  | forall (sym MEM visible_syms) | true ] (
            C.Esseq (Caux.mk_empty_pat C.BTy_unit) core_s (
              C.Esseq (Caux.mk_sym_pat sym_e (C.BTy_loaded C.OTy_integer)) core_e (
                C.Ecase (Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) sym_e)
                  [ (C.CaseCtor C.Cspecified [Caux.mk_sym_pat sym_case (C.BTy_object C.OTy_integer)],
                     C.Eif (Caux.mk_op_pe C.OpEq (Caux.mk_sym_pe (C.BTy_object C.OTy_integer) sym_case) (Caux.mk_integer_pe 0))
                       core_s_loop core_s_exit)
                    (* non-deterministic branching if the test expression had unspecified value *)
                  ; (Caux.mk_unspecified_pat (Caux.mk_empty_pat C.BTy_ctype),
                     C.End [core_s_loop; core_s_exit]) ]
              )
            )
          )
    
    | A.AilSbreak ->
        E.get_visible_objects >>= fun visible_syms ->
        E.return $
          C.Erun default (fromJust "Translation.translate_statement, AilSbreak" labs.break)
            [ (sym, Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym) | forall (sym MEM visible_syms) | true ]

    
    | A.AilScontinue ->
        E.get_visible_objects >>= fun visible_syms ->
        E.return $
          C.Erun default (fromJust "Translation.translate_statement, AilScontinue" labs.loop)
            [ (sym, Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym) | forall (sym MEM visible_syms) | true ]
    
    | A.AilSreturnVoid ->
        E.get_visible_objects >>= fun visible_syms ->
        E.return $
          let bTy =
             if List.length visible_syms < 2 then
               C.BTy_unit
             else
               C.BTy_tuple (List.replicate (List.length visible_syms) C.BTy_unit) in
          C.Esseq (Caux.mk_empty_pat bTy)
            (Caux.mk_unseq $ List.map (fun sym -> Caux.pkill loc (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)) visible_syms)
            (* TODO: check the symbols *)
            (C.Erun () labs.return [])
(* OLD Ereturn
          C.Esseq (C.CaseBase Nothing)
            (Caux.mk_unseq $ List.map (fun sym -> Caux.pkill loc (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)) visible_syms)
            (C.Ereturn Caux.mk_unit_pe)
*)
    
    | A.AilSreturn e ->
        (* TODO UNSPEC *)
        translate_rvalue e    >>= fun core_e         ->
        E.fresh_symbol        >>= fun e_sym          ->
        E.get_visible_objects >>= fun visible_syms   ->
        let return_ty = match Context.lookup (=) (snd program).A.declarations f with
          | Just (A.Decl_function _ return_ty _ _ _ _) ->
              return_ty
          | _ ->
              error "[Translation.translate_rvalue A.Return] impossible error: TODO move to Exception.t"
        end in
        let oTy = Caux.core_object_type_of_ctype (Caux.proj_ctype (ctype_of e)) in
        E.return $
          let bTy =
             if List.length visible_syms < 2 then
               C.BTy_unit
             else
               C.BTy_tuple (List.replicate (List.length visible_syms) C.BTy_unit) in
            C.Esseq (Caux.mk_sym_pat e_sym (C.BTy_loaded oTy)) core_e (
              C.Esseq (Caux.mk_empty_pat bTy) (
                Caux.mk_unseq $ List.map (fun sym ->
                  Caux.pkill loc (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)
                ) visible_syms)
                begin
                  C.Ereturn $
                    if AilTypesAux.is_integer return_ty then
                      conv_loaded_int [ Caux.mk_ail_ctype_pe return_ty
                                      ; Caux.mk_sym_pe (C.BTy_loaded C.OTy_integer) e_sym ]
                    else
                      Caux.mk_sym_pe (C.BTy_loaded oTy) e_sym
                end
            )
    
    (* Need to do the promotions *)
    (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
    | A.AilSswitch e s ->
          


(*
        E.fresh_symbol         >>= fun sym_e  ->
        translate_rvalue e >>= fun core_e ->
        (* TODO: should properly interpret the integer constants *)
        let ((found_default, ns) : bool * list integer) =
          let x = collect_cases s in
          (x.found_default, List.map (fun (A.IConstant z _ _) -> z) x.case_csts) in
        E.replicateM (List.length ns) (E.fresh_named_symbol "case") >>= fun (ds : list C.ksym) ->
        let syms_case' = foldl (fun acc (n, d) ->
          Map.insert n d acc) Map.empty (zip ns ds) in
        E.fresh_named_symbol "default" >>= fun sym_default' ->
        (if found_default then
          E.fresh_named_symbol "break"
        else
            E.return sym_default') >>= fun sym_break' ->
        E.get_visible_objects  >>= fun visible_as      ->
        let run_as = [ (a, C.PEsym a) | forall (a MEM visible_as) | true ] in
        translate_stmt tagDefs stdlib program f
          <| labs with default= Just sym_default'; cases= Just syms_cases; break= sym_break' |>  s >>= fun core_s ->
        E.return $
          C.Ewseq [Just a_e] core_e
            (foldl (fun acc (n, d) ->
              C.Eif (Caux.mk_op_pe C.OpEq (C.PEsym a_e) (C.PEval (C.Vinteger (Mem.integer_ival n))))
                (C.Erun default d run_as)
                acc
             )
               (C.Ewseq [] (C.Erun default sym_default' run_as)
                  (C.Ewseq [] core_s
                     (C.Esave sym_break' [ (a, Cty.Void) | forall (a MEM visible_as) | true ] C.Eskip)
                  )
               )
               $ Map_extra.toList syms_cases')
*)

        error "WIP: switch elab"

    
    (* Need to do the promotions *)
    | A.AilScase iCst s ->
(*
        translate_stmt_ s     >>= fun core_s       ->
        E.get_visible_objects >>= fun visible_syms ->
        let iCst_pe = translate_integerConstant iCst in
        
          (* TODO: should properly interpret the integer constant *)
          E.return $ C.Esave (fromJust $ Map.lookup ((fun (A.IConstant z _ _) -> z) n) (fromJust labs.cases)) [ (sym, Cty.Void) | forall (sym MEM visible_syms) | true ] core_s
*)
        error "WIP elab of AilScase"

    
    | A.AilSdefault s -> do E
        core_s     <- translate_stmt_ s;
        visible_as <- E.get_visible_objects; in
          E.return $ C.Esave (fromJust "Translation.translate_statement, AilSdefault" labs.default) [ (a, Cty.Void)  | forall (a MEM visible_as) | true ] core_s
        end
    
    | A.AilSlabel l s -> do E
        core_s     <- translate_stmt_ s;
        visible_as <- E.get_visible_objects; in
          (* TODO: the types of the annotations in Esave are dummy, but this is not observable for now *)
          E.return $ C.Esave l [ (a, Cty.Void)  | forall (a MEM visible_as) | true ] core_s
        end
    
    | A.AilSgoto l ->
        E.get_visible_objects >>= fun visible_syms ->
        E.return $ C.Erun default l [ (sym, Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym) | forall (sym MEM visible_syms) | true ]
    
    | A.AilSdeclaration [] ->
        E.return C.Eskip
    
    | A.AilSdeclaration defns ->
        (* This pass translate the declarations *)
        E.mapM (fun (ptr_sym, e) ->
          E.resolve_object_type ptr_sym >>= fun ty ->
          if AilTypesAux.is_pointer ty then
(*
            (* TODO this is probably already done right by translate_expression *)
            if Aaux.is_null_pointer_constant e then
              match ty with
                | Aty.Pointer _ ref_ty ->
                    E.return (
                      Caux.pstore loc (Caux.mk_ail_ctype_pe ty) (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym)
                        (Caux.nullptr_pe (Caux.proj_ctype ref_ty)) Cmm.NA
                    )
              end
            else
*)
              E.fresh_typed_symbol true (ctype_of e) >>= fun (e_sym, e_bTy) ->
              translate_lvalue e                     >>= fun core_e         ->
              let e_sym_pe = Caux.mk_sym_pe e_bTy e_sym in
              E.return (
                C.Esseq (Caux.mk_sym_pat e_sym e_bTy) core_e
                  (Caux.pstore loc (Caux.mk_ail_ctype_pe ty) (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) ptr_sym) e_sym_pe Cmm.NA)
              )
          
          else
            (* we are not dealing with a pointer initialisation *)
            E.fresh_typed_symbol true (ctype_of e) >>= fun (e_sym, e_bTy) ->
            translate_rvalue e                     >>= fun core_e         ->
            let e_sym_pe = Caux.mk_sym_pe e_bTy e_sym in
            E.return $ C.Esseq (Caux.mk_sym_pat e_sym e_bTy) core_e
                         (Caux.pstore loc (Caux.mk_ail_ctype_pe ty) (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) ptr_sym)
                            (if AilTypesAux.is_integer ty then conv_loaded_int [Caux.mk_ail_ctype_pe ty; e_sym_pe] else e_sym_pe) Cmm.NA)
        ) defns >>=
        
        (* This pass combine the translated declarations *)
        E.foldl1M (fun x y -> E.return $ Caux.concat_sseq x y)
    
    | A.AilSpar ss ->
        E.mapM translate_stmt_ ss >>= fun core_ss ->
        let core_ss' = List.map (fun core_s ->
          C.Esseq (Caux.mk_empty_pat C.BTy_unit) core_s (C.Ereturn Caux.mk_unit_pe)
        ) core_ss in
        E.return $ C.Epar core_ss'
(*    
(* TODO DEBUG *)
    | s ->
        match s with
          | A.AilSskip ->
              error "AilSskip"
          | A.AilSexpr _ ->
              error "AilSexpr"
          | A.AilSblock _ _ ->
              error "AilSblock"
          | A.AilSif _ _ _ ->
              error "AilSif"
          | A.AilSwhile _ _ ->
              error "AilSwhile"
          | A.AilSdo _ _ ->
              error "AilSdo"
          | A.AilSbreak ->
              error "AilSbreak"
          | A.AilScontinue ->
              error "AilScontinue"
          | A.AilSreturnVoid ->
              error "AilSreturnvoid"
          | A.AilSreturn _ ->
              error "AilSreturn"
          | A.AilSswitch _ _ ->
              error "AilSswitch"
          | A.AilScase _ _ ->
              error "AilScase"
          | A.AilSdefault _ ->
              error "AilSdefault"
          | A.AilSlabel _ _ ->
              error "AilSlabel"
          | A.AilSgoto _ ->
              error "AilSgoto"
          | A.AilSdeclaration _ ->
              error "AilSdeclaration"
          | A.AilSpar _ ->
              error "AilSpar"
        end
*)
*)
  end




(*
val translate_program:
  C.fun_map unit -> A.program GenTypes.genTypeCategory ->
  E.t (list (C.sym * C.core_base_type * C.expr unit) * C.fun_map unit)
*)


let translate_program sequentialise stdlib ((startup_sym, sigm) as program) =
  let conv_loaded_int = mk_stdcall stdlib "conv_loaded_int" in
  E.foldlM (fun (gacc, facc) (sym, decl) ->
    match decl with
      | A.Decl_object _ qs ty ->
          (* generate the initialisation code for global variables *)
          let core_ty     = Caux.mk_ail_ctype_pe ty in
          let core_create = Caux.pcreate Loc.unknown (Caux.mk_alignof_pe core_ty) core_ty (Symbol.PrefSource [sym]) in
          E.fresh_symbol >>= fun sym_global ->
          
          E.print_debug 2 ("(translate_program) CREATE for " ^ show sym_global) >> (* DEBUG *)
          
          match Context.lookup (=) sigm.A.object_definitions sym with
            | Just expr ->
                (* if the global has an initialisation *)
                E.fresh_typed_symbol true (ctype_of expr) >>= fun (sym_e, bTy_e) ->
                begin
                  if AilTypesAux.is_pointer ty && Aaux.is_null_pointer_constant expr then
                    E.return (C.Epure (Caux.mk_nullptr_pe (Caux.proj_ctype ty)))
                  else
                    translate_expression stdlib program false expr
                end >>= fun core_e ->
                let core_init_e =
                  if AilTypesAux.is_integer ty then
                    conv_loaded_int [core_ty; Caux.mk_sym_pe bTy_e sym_e]
                  else
                    (* TODO: check, might need some pointer to pointer conversion *)
                    Caux.mk_sym_pe bTy_e sym_e in
                E.return
                  ((sym,
                    C.BTy_object C.OTy_pointer,
                    C.Esseq (Caux.mk_sym_pat sym_global (C.BTy_object C.OTy_pointer)) core_create
                      (C.Esseq (Caux.mk_sym_pat sym_e bTy_e) core_e
                         (* TODO: proper memory order *)
                         (C.Esseq (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore Loc.unknown core_ty (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym_global) core_init_e Cmm.NA)
                            (C.Ereturn (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym_global))
                         )
                      )
                   ) :: gacc, facc)
            | Nothing ->
                (* otherwise *)
                E.return
                  ((sym,
                    C.BTy_object C.OTy_pointer,
                    C.Esseq (Caux.mk_sym_pat sym_global (C.BTy_object C.OTy_pointer)) core_create
                      (* TODO: proper memory order *)
                      (C.Esseq (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore Loc.unknown core_ty (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym_global) (Caux.zeros (Caux.proj_ctype ty)) Cmm.NA)
                         (C.Ereturn (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym_global))
                      )
                    ) :: gacc, facc)
          end
      
      | A.Decl_function has_proto return_ty params is_variadic is_inline is_Noreturn ->
          (* generate the code for the defined Ail functions *)
          match Context.lookup (=) sigm.A.function_definitions sym with
            | Just (param_syms, stmt) ->
                (* making the argument variables visible *)
(* TODO: WIP                E.with_block_objects param_syms *) (

                  E.fresh_named_symbol "return" >>= fun sym_return ->
                  snd <$> translate_stmt stdlib program sym <| return= sym_return; default= Nothing; cases= []; loop= Nothing; break= Nothing |> stmt
                ) >>= fun core_body ->
                
                let core_return =
                  if startup_sym = sym then
                    (* §5.1.2.2.3#1 first sentence *)
                    (* TODO: "If the return type is not compatible with int" *)
                    C.Ereturn (Caux.mk_specified_pe (Caux.mk_integer_pe 0))
                  else if return_ty = Aty.Void then
                    C.Ereturn Caux.mk_unit_pe
                  else
                    (* §6.9.1#12 *)
                    C.Epure (Caux.mk_undef_pe Undefined.UB088_reached_end_of_function) in
                
                E.return
                  (gacc,
                   Map.insert sym
                     (C.Proc (C.BTy_loaded (if AilTypesAux.is_pointer return_ty then C.OTy_pointer else C.OTy_integer))
                             (List.map (fun sym -> (sym, C.BTy_object C.OTy_pointer)) param_syms)
                             (C.Esseq (Caux.mk_empty_pat C.BTy_unit) core_body core_return)
                     ) facc)
            | Nothing ->
                E.return (gacc, facc)
          end
    end
  ) ([], Map.empty) (List.reverse sigm.A.declarations) >>= fun (globs, cfuns) ->
  
  (* adding string literals *)
  E.get_string_literals >>= fun xs ->
  E.foldlM (fun acc (loc, sym, ty, e_init) ->
  E.fresh_symbol >>= fun sym_lit ->
    let expr =
      C.Esseq (Caux.mk_sym_pat sym_lit (C.BTy_object C.OTy_pointer)) (Caux.pcreate loc (Caux.mk_alignof_pe (Caux.mk_ctype_pe ty)) (Caux.mk_ctype_pe ty) (Symbol.PrefOther "string literal"))
        (C.Esseq (Caux.mk_empty_pat C.BTy_unit) (Caux.pstore loc (Caux.mk_ctype_pe ty) (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym_lit) e_init Cmm.NA)
          (C.Ereturn (Caux.mk_sym_pe (C.BTy_object C.OTy_pointer) sym_lit))) in
    E.return $ (sym, C.BTy_object C.OTy_pointer, expr) :: acc
  ) (List.reverse globs) xs >>= fun globs' ->
  E.return (List.reverse globs', cfuns)
(*

  E.foldlM (fun acc (fun_sym, <| A.fun_return_ty=   ret_ty;
                                A.fun_bindings=    fun_args;
                                A.fun_is_variadic= is_variadic;
                                A.fun_body=        fun_body_opt |>) ->
    match fun_body_opt with
      | Just fun_body ->
          (* making the argument variables visible *)
          E.push_block_objects (List.map fst fun_args) >>
          
          (* translate the body to Core *)
          translate_stmt stdlib program fun_sym Nothing Nothing Nothing Nothing fun_body >>= fun core_body ->
          (* removing the argument variables from the "visibles" *)
          E.pop_block_objects >>
          
          (* If we are elaborating the startup function, then we add at the beginning of the body
             the allocations/initialisations of the global variables *)
          
          let e_ret =
            if startup_sym = fun_sym then
              (* §5.1.2.2.3#1 first sentence *)
              (* TODO: "If the return type is not compatible with int" *)
              C.Ereturn (Caux.mk_integer_pe_pe 0)
            
            else if ret_ty = Aty.Void then
              C.Ereturn (C.PEval (C.Vunit))
            else
              (* §6.9.1#12 *)
              C.PEundef Undefined.Reached_end_of_function in
          
          (E.return $ Map.insert fun_sym (
                                        C.TyEffect C.BTy_integer (* TODO: this should de address for pointer type *),
                                        List.map (fun (arg, _) -> (arg, C.BTy_pointer (* TODO: check *))) fun_args,
                                        (C.Esseq [] core_body e_ret)
                                      ) acc)
      | Nothing ->
          (* TODO: this corresponds to an Ail function a prototype but no implementation ==> std lib function *)
          E.return acc
    end
  ) Map.empty funs >>= fun cfuns ->
  E.return (cglobs, cfuns)
*)





(* TODO: skipping unions for now *)
val translate_tag_definitions: Context.context A.identifier A.tag_definition -> map Symbol.sym (list (Cabs.cabs_identifier * Cty.ctype))
let translate_tag_definitions ctx =
  let ctxWithoutUnions = List.filter (function
    | (_, A.StructDef _) ->
        true
    | _ ->
        false
  end ) ctx in
  Map.fromList $ List.map (function
    | (sym, A.StructDef ident_tys) ->
        (sym, List.map (fun (ident, ty) -> (ident, Caux.proj_ctype ty)) ident_tys)
    | (sym, A.UnionDef ident_tys) ->
        error "WIP: Translation.translate_tag_definitions, UnionDef"
  end) ctxWithoutUnions


(* This is the entry function (called from main.ml) *)
let translate sequentialise stdlib impl (symbol_counter, prog) =
  (* TODO: this is ugly, we shouldn't expose the internals and properly use the Undefined *)
  let () = Cty.set_tagDefs (translate_tag_definitions (snd prog).A.tag_definitions) in
  
  let ((cglobs, cfuns), st) = (translate_program sequentialise stdlib prog) (E.init symbol_counter) in
  (st.E.symbol_supply, <| C.main= fst prog; C.stdlib= stdlib; C.impl= impl; C.globs= cglobs; C.funs= cfuns |>)
