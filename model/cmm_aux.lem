open import Pervasives
import Symbol

type aid = string

type program = int

(* == Thread id ============================================================= *)
type tid =
  | Tzero
  | Tpar of nat * tid
  | Tseq of tid

val     tid_eq: tid -> tid -> bool
let rec tid_eq tid1 tid2 =
  match (tid1, tid2) with
    | (Tzero, Tzero) ->
        true
    | (Tpar n1 tid1', Tpar n2 tid2') ->
        n1 = n2 && tid_eq tid1' tid2'
    | (Tseq tid1', _) ->
        tid_eq tid1' tid2
    | (_, Tseq tid2') ->
        tid_eq tid1 tid2'
    | (_, _) ->
        false
end

instance (Eq tid)
  let (=)  tid1 tid2 = tid_eq tid1 tid2
  let (<>) tid1 tid2 = not $ tid_eq tid1 tid2
end

val     setElemCompare_tid: tid -> tid -> ordering
let rec setElemCompare_tid tid1 tid2 =
  match (tid1, tid2) with
    | (Tseq tid1', _) -> setElemCompare tid1' tid2
    | (_, Tseq tid2') -> setElemCompare tid1 tid2'
    | (Tzero, Tzero) -> EQ
    | (Tpar n1 tid1', Tpar n2 tid2') -> setElemCompare (n1, tid1') (n2, tid2')
    | (Tzero, _) -> LT
    | (_, Tzero) -> GT
  end

instance (SetType tid)
  let setElemCompare = setElemCompare_tid
end

val     canonize_tid: tid -> tid
let rec canonize_tid tid =
  match tid with
    | Tzero       -> Tzero
    | Tpar n tid' -> Tpar n (canonize_tid tid')
    | Tseq tid'   -> (canonize_tid tid')
end







(* == Memory location ======================================================= *)
type location_ =
  | Lbase of natural
  | Lshift of location_ * integer

let rec location_Equal l1 l2 =
  match (l1, l2) with
    | (Lbase n1, Lbase n2) ->
        n1 = n2
    | (Lshift l1' n1, Lshift l2' n2) ->
        location_Equal l1' l2' && n1 = n2
    | _ ->
        false
  end


instance (Eq location_)
  let (=)  l1 l2 = location_Equal l1 l2
  let (<>) l1 l2 = not $ location_Equal l1 l2
end

let rec location_Compare l1 l2 =
  match (l1, l2) with
    | (Lbase n1, Lbase n2) ->
        setElemCompare n1 n2
    | (Lshift l1' n1, Lshift l2' n2) ->
        match location_Compare l1' l2' with
          | EQ -> setElemCompare n1 n2
          | z  -> z
        end
    | (Lbase _   , Lshift _ _) -> LT
    | (Lshift _ _, Lbase _   ) -> GT
  end


instance (SetType location_)
  let setElemCompare = location_Compare
end

type location =
    list Symbol.t * location_





(* Duplicate of Core.constant (needed to avoid cyclic deps) *)
type constant =
  | Cint of integer
  | Carray of list constant
  | Cfunction of Symbol.t
  | Cstring of string (* TODO: temporary hack *)

let rec setElemCompare_constant c1 c2 =
  match (c1, c2) with
    | (Cint n1     , Cint n2     ) -> setElemCompare n1 n2
    | (Cfunction f1, Cfunction f2) -> setElemCompare f1 f2
    | (Carray cs1  , Carray cs2  ) -> setElemCompare cs1 cs2
    | (Cstring str1, Cstring str2) -> setElemCompare str1 str2

    | (Cint _      , Carray _    ) -> LT
    | (Cint _      , Cfunction _ ) -> LT
    | (Cint _      , Cstring _   ) -> LT
    | (Carray _    , Cint _      ) -> GT
    | (Carray _    , Cfunction _ ) -> LT
    | (Carray _    , Cstring _   ) -> LT
    | (Cfunction _ , Cint _      ) -> GT
    | (Cfunction _ , Carray _    ) -> GT
    | (Cfunction _ , Cstring _   ) -> LT
    | (Cstring _   , Cint _      ) -> GT
    | (Cstring _   , Carray _    ) -> GT
    | (Cstring _   , Cfunction _ ) -> GT
  end


instance (SetType constant)
  let setElemCompare c1 c2 = setElemCompare_constant c1 c2
end

(* Memory value *)
type cvalue =
  | Muninit    (* TODO: Kayvan has to check whether we can remove this constructor 
                  and use the empty list in mem_state to denote a created, but 
                  uninitialized variable. *) 
  | Mbase of constant
  | Mobj of location (* (list Symbol.t * natural) *)
  | Marray of list cvalue
  | Mnull

let rec setElemCompare_cvalue v1 v2 =
  match (v1, v2) with
    | (Muninit     , Muninit     ) -> EQ
    | (Mbase c1    , Mbase c2    ) -> setElemCompare c1 c2
    | (Mobj loc1   , Mobj loc2   ) -> setElemCompare loc1 loc2
    | (Marray vs1  , Marray vs2  ) -> setElemCompare vs1 vs2
    | (Mnull       , Mnull       ) -> EQ
    
    | (Muninit     , _           ) -> LT
    
    | (Mbase _     , Muninit     ) -> GT
    | (Mbase _     , _           ) -> LT
    
    | (Mobj _      , Muninit     ) -> GT
    | (Mobj _      , Mbase _     ) -> GT
    | (Mobj _      , _           ) -> LT
    
    | (Marray _    , Mnull       ) -> LT
    | (Marray _    , _           ) -> GT
    | (Mnull       , _           ) -> GT
  end


instance (SetType cvalue)
  let setElemCompare = setElemCompare_cvalue
end


type mem_value = cvalue
