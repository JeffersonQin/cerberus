open import Pervasives
import Symbol

type aid = string

type program = int

(* == Thread id ============================================================= *)
type tid =
  | Tzero
  | Tpar of nat * tid
  | Tseq of tid

val     tid_eq: tid -> tid -> bool
let rec tid_eq tid1 tid2 =
  match (tid1, tid2) with
    | (Tzero, Tzero) ->
        true
    | (Tpar n1 tid1', Tpar n2 tid2') ->
        n1 = n2 && tid_eq tid1' tid2'
    | (Tseq tid1', _) ->
        tid_eq tid1' tid2
    | (_, Tseq tid2') ->
        tid_eq tid1 tid2'
    | (_, _) ->
        false
end

instance (Eq tid)
  let (=)  tid1 tid2 = tid_eq tid1 tid2
  let (<>) tid1 tid2 = not $ tid_eq tid1 tid2
end

val     canonize_tid: tid -> tid
let rec canonize_tid tid =
  match tid with
    | Tzero       -> Tzero
    | Tpar n tid' -> Tpar n (canonize_tid tid')
    | Tseq tid'   -> (canonize_tid tid')
end







(* == Memory location ======================================================= *)
type location_ =
  | Lbase of natural
  | Lshift of location_ * integer

(*
let location_eq l1 l2 =
    match (l1, l2) with
      | Lbase n -> 
      | Lshift l1' n ->
    end


instance (Eq location_)

  let (<>) l1 l2 = 
end
 *)

instance (Eq location_)
  let (=) l1 l2 = true
  let (<>) l1 l2 = false
end

type location =
    list Symbol.t * location_





(* Duplicate of Core.constant (needed to avoid cyclic deps) *)
type constant =
  | Cint of integer
(*  | Carray of list constant *)
  | Cfunction of Symbol.t

(* Memory value *)
type cvalue =
  | Muninit    (* TODO: Kayvan has to check whether we can remove this constructor 
                  and use the empty list in mem_state to denote a created, but 
                  uninitialized variable. *) 
  | Mbase of constant
  | Mobj of location (* (list Symbol.t * natural) *)
  | Marray of list cvalue
  | Mnull

(*
instance (Eq cvalue)
  let (=) v1 v2 =
    match (v1, v2) with
      | (Muninit, Munint



  let (<>) v1 v2
end
 *)


type mem_value = cvalue
