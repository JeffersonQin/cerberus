open import Pervasives

open import Global Core Core_aux Core_ctype
import Symbol Symbolic AilTypes
module Mem = Naive_memory

module ATypes = AilTypes


val pp_pexpr: pexpr -> string
declare ocaml target_rep function pp_pexpr = `String_core.string_of_pexpr`


(*
type rewriter = <|
  unit_rwter:                                                      expr unit;
  false_rwter:                                                     expr unit;
  const_rwter:       Mem.mem_value                              -> expr unit;
  list_rwter:        list (expr unit)                           -> expr unit;
  ctype_rwter:       ctype                                      -> expr unit;
  sym_rwter:         sym                                        -> expr unit;
  impl_rwter:        Implementation_.implementation_constant    -> expr unit;
  tuple_rwter:       list (expr unit)                           -> expr unit;
  not_rwter:         expr unit                                  -> expr unit;
  op_rwter:          binop -> expr unit -> expr unit            -> expr unit;
  call_rwter:        name -> list (expr unit)                   -> expr unit;
  output_rwter:      string                                     -> expr unit;
  undef_rwter:       Undefined.undefined_behaviour              -> expr unit;
  error_rwter:                                                     expr unit;
  skip_rwter:                                                      expr unit;
  let_rwter:         sym -> expr unit -> expr unit              -> expr unit;
  if_rwter:          expr unit -> expr unit -> expr unit        -> expr unit;
  proc_rwter:        name -> list (expr unit)                   -> expr unit;
  action_rwter:      paction unit                               -> expr unit;
  unseq_rwter:       list (expr unit)                           -> expr unit;
  wseq_rwter:        list (maybe sym) -> expr unit -> expr unit -> expr unit;
  sseq_rwter:        list (maybe sym) -> expr unit -> expr unit -> expr unit;
  aseq_rwter:        maybe sym -> action unit -> paction unit   -> expr unit;
  indet_rwter:       expr unit                                  -> expr unit;
  bound_rwter:       nat -> expr unit                           -> expr unit;
  save_rwter:        ksym -> list (sym * ctype) -> expr unit    -> expr unit;
  run_rwter:         ksym -> list (sym * expr unit)             -> expr unit;
  ret_rwter:         expr unit                                  -> expr unit;
  nd_rwter:          list (expr unit)                           -> expr unit;
  par_rwter:         list (expr unit)                           -> expr unit;
  wait_rwter:        Thread.thread_id                           -> expr unit;
  is_scalar_rwter:   expr unit                                  -> expr unit;
  is_integer_rwter:  expr unit                                  -> expr unit;
  is_signed_rwter:   expr unit                                  -> expr unit;
  is_unsigned_rwter: expr unit                                  -> expr unit;
|>


(* TODO: check if lem now translates properly partially applied ctors *)
val rwter_identity: rewriter
let rwter_identity = <|
  unit_rwter=        Eunit;
  false_rwter=       Efalse;
  const_rwter=       fun cst -> Econst cst;
  list_rwter=        fun pes -> Elist pes;
  ctype_rwter=       fun ty -> Ectype ty;
  sym_rwter=         fun a -> Esym a;
  impl_rwter=        fun impl -> Eimpl impl;
  tuple_rwter=       fun pes -> Etuple pes;
  not_rwter=         fun pe -> Enot pe;
  op_rwter=          fun bop e1 e2 -> Eop bop e1 e2;
  call_rwter=        fun nm pes -> Ecall nm pes;
  output_rwter=      fun str -> Eoutput str;
  undef_rwter=       fun ubs -> Eundef ubs;
  error_rwter=       Eerror;
  skip_rwter=        Eskip;
  let_rwter=         fun a pe1 e2 -> Elet a pe1 e2;
  if_rwter=          fun pe1 e2 e3 -> Eif pe1 e2 e3;
  proc_rwter=        fun nm pes -> Eproc () nm pes;
  action_rwter=      fun pact -> Eaction pact;
  unseq_rwter=       fun es -> Eunseq es;
  wseq_rwter=        fun _as e1 e2 -> Ewseq _as e1 e2;
  sseq_rwter=        fun _as e1 e2 -> Esseq _as e1 e2;
  aseq_rwter=        fun a_opt act1 pact2 -> Easeq a_opt act1 pact2;
  indet_rwter=       fun e -> Eindet e;
  bound_rwter=       fun n e -> Ebound n e;
  save_rwter=        fun k a_tys e -> Esave k a_tys e;
  run_rwter=         fun k a_es -> Erun () k a_es;
  ret_rwter=         fun pe -> Eret pe;
  nd_rwter=          fun es -> End es;
  par_rwter=         fun es -> Epar es;
  wait_rwter=        fun tid -> Ewait tid;
  is_scalar_rwter=   fun pe -> Eis_scalar pe;
  is_integer_rwter=  fun pe -> Eis_integer pe;
  is_signed_rwter=   fun pe -> Eis_signed pe;
  is_unsigned_rwter= fun pe -> Eis_unsigned pe
|>

type only_effectful_rewriter = <|
  skip_erwter:                                                 expr unit;
  let_erwter:    sym -> expr unit -> expr unit              -> expr unit;
  if_erwter:     expr unit -> expr unit -> expr unit        -> expr unit;
  proc_erwter:   name -> list (expr unit)                   -> expr unit;
  action_erwter: paction unit                               -> expr unit;
  unseq_erwter:  list (expr unit)                           -> expr unit;
  wseq_erwter:   list (maybe sym) -> expr unit -> expr unit -> expr unit;
  sseq_erwter:   list (maybe sym) -> expr unit -> expr unit -> expr unit;
  aseq_erwter:   maybe sym -> action unit -> paction unit   -> expr unit;
  indet_erwter:  expr unit                                  -> expr unit;
  bound_erwter:  nat -> expr unit                           -> expr unit;
  save_erwter:   ksym -> list (sym * ctype) -> expr unit    -> expr unit;
  run_erwter:    ksym -> list (sym * expr unit)             -> expr unit;
  ret_erwter:    expr unit                                  -> expr unit;
  nd_erwter:     list (expr unit)                           -> expr unit;
  par_erwter:    list (expr unit)                           -> expr unit;
  wait_erwter:   Thread.thread_id                           -> expr unit;
|>

val rwter_only_effectful: only_effectful_rewriter -> rewriter
let rwter_only_effectful r = <| rwter_identity with
  skip_rwter=   r.skip_erwter;
  let_rwter=    fun a pe1 e2 -> if is_pure e2 then Elet a pe1 e2 else r.let_erwter a pe1 e2;
  if_rwter=     fun pe1 e2 e3 -> if is_pure e2 && is_pure e3 then Eif pe1 e2 e3 else r.if_erwter pe1 e2 e3;
  proc_rwter=   r.proc_erwter;
  action_rwter= r.action_erwter;
  unseq_rwter=  r.unseq_erwter;
  wseq_rwter=   r.wseq_erwter;
  sseq_rwter=   r.sseq_erwter;
  aseq_rwter=   r.aseq_erwter;
  indet_rwter=  r.indet_erwter;
  bound_rwter=  r.bound_erwter;
  save_rwter=   r.save_erwter;
  run_rwter=    r.run_erwter;
  ret_rwter=    r.ret_erwter;
  nd_rwter=     r.nd_erwter;
  par_rwter=    r.par_erwter;
  wait_rwter=   r.wait_erwter
|>
*)



















let rec remove_skips expr =
  match expr with
  | Elet sym e1 e2 ->
      Elet sym e1 (remove_skips e2)

  | Eif pe1 e2 e3 ->
      Eif pe1 (remove_skips e2) (remove_skips e3)

  | Eunseq es ->
      Eunseq (List.map remove_skips es)

  | Ewseq _ Eskip e2 ->
      remove_skips e2
  
  | Ewseq _ e1 Eskip ->
      remove_skips e1
  
  | Ewseq _as e1 e2 ->
      match remove_skips e1 with
        | Eskip ->
            remove_skips e2
        | e1' ->
            Ewseq _as e1' (remove_skips e2)
      end
  
  | Esseq _ Eskip e2 ->
      remove_skips e2
  
  | Esseq _ e1 Eskip ->
      remove_skips e1
  
  | Esseq _as e1 e2 ->
      match remove_skips e1 with
        | Eskip ->
            remove_skips e2
        | e1' ->
            Esseq _as e1' (remove_skips e2)
      end
  
(*
  | Etry e str_es ->
      Etry (remove_skips e) (List.map (fun (str, e) -> (str, remove_skips e)) str_es)
*)
  | Eindet e ->
      Eindet (remove_skips e)
  | Ebound n e ->
      Ebound n (remove_skips e)
  | Esave k sym_tys e ->
      Esave k sym_tys (remove_skips e)
  | End es ->
      End (List.map remove_skips es)
  | Epar es ->
      Epar (List.map remove_skips es)
  | _ ->
      expr
  end


let rec remove_unseqs expr =
  match expr with
  | Elet sym e1 e2 ->
      Elet sym e1 (remove_unseqs e2)

  | Eif pe1 e2 e3 ->
      Eif pe1 (remove_unseqs e2) (remove_unseqs e3)

  | Eunseq es ->
      let pes_opt = List.foldr (fun e acc_opt ->
        match (acc_opt, to_pure e) with
          | (Just acc, Just pe) ->
              Just (pe :: acc)
          | _ ->
              Nothing
        end) (Just []) es in
      maybe (Eunseq (List.map remove_unseqs es)) (fun pes -> Epure (PEtuple pes)) pes_opt
  
  | Ewseq _as (Eunseq es) e2 ->
      (* ys is the assoc list of symbolic names, values that can be substituted away *)
      let (rev_xs, rev_ys) = List.foldl (fun (acc1, acc2) (sym_opt, e) ->
        match to_pure e with
          | Just cval ->
              (acc1, (sym_opt, cval) :: acc2)
          | Nothing ->
              ((sym_opt, remove_unseqs e) :: acc1, acc2)
        end) ([], []) (List.zip _as es) in
      
      let e2' =
        remove_unseqs $ List.foldl (fun acc (sym_opt, cval) ->
          maybe acc (fun sym -> subst_sym sym cval acc) sym_opt
        ) e2 rev_ys in
      
      match rev_xs with
        | [] ->
            e2'
        | [(a_opt, e')] ->
            Ewseq [a_opt] e' e2'
        | _ ->
            let (_as', es') = List.unzip $ List.reverse rev_xs in
            Ewseq _as' (Eunseq es') e2'
      end

  | Ewseq _as e1 e2 ->
      Ewseq _as (remove_unseqs e1) (remove_unseqs e2)
  
  | Esseq _as (Eunseq es) e2 ->
      let (rev_xs, rev_ys) = List.foldl (fun (acc1, acc2) (sym_opt, e) ->
        match to_pure e with
          | Just pe ->
              (acc1, (sym_opt, pe) :: acc2)
          | Nothing ->
              ((sym_opt, remove_unseqs e) :: acc1, acc2)
        end) ([], []) (List.zip _as es) in
      
      let e2' =
        remove_unseqs $ List.foldl (fun acc (sym_opt, pe) ->
          maybe acc (fun sym -> subst_sym sym pe acc) sym_opt
        ) e2 rev_ys in
      
      match rev_xs with
        | [] ->
            e2'
        | [(sym_opt, e')] ->
            Esseq [sym_opt] e' e2'
        | _ ->
            let (_as', es') = List.unzip $ List.reverse rev_xs in
            Esseq _as' (Eunseq es') e2'
      end
  
  | Esseq _as e1 e2 ->
      Esseq _as (remove_unseqs e1) (remove_unseqs e2)
  
(*
  | Etry e str_es ->
      Etry (remove_unseqs e) (List.map (fun (str, e) -> (str, remove_unseqs e)) str_es)
*)
  | Eindet e ->
      Eindet (remove_unseqs e)
  | Ebound n e ->
      Ebound n (remove_unseqs e)
  | Esave k sym_tys e ->
      Esave k sym_tys (remove_unseqs e)
  | End es ->
      End (List.map remove_unseqs es)
  | Epar es ->
      Epar (List.map remove_unseqs es)
  | _ ->
      expr
  end


(*
let rec remove_seqs expr =
  match expr with
  | Elet sym e1 e2 ->
      Elet sym e1 (remove_seqs e2)

  | Eif pe1 e2 e3 ->
      Eif pe1 (remove_seqs e2) (remove_seqs e3)

  | Eunseq es ->
      Eunseq (List.map remove_seqs es)
  
  | Ewseq _as e1 e2 ->
      let e1' = remove_seqs e1 in
      let e2' = remove_seqs e2 in
      match _as with
        | [Just a] ->
            if is_pure e1' then
              subst_sym a e1' e2'
            else
              Ewseq _as e1' e2'
        | _ ->
            if is_value e1' then
              subst_syms _as e1' e2'
            else
              Ewseq _as e1' e2'
      end
  
  | Esseq _as e1 e2 ->
      let e1' = remove_seqs e1 in
      let e2' = remove_seqs e2 in
      match _as with
        | [Just a] ->
            if is_pure e1' then
              subst_sym a e1' e2'
            else
              Esseq _as e1' e2'
        | _ ->
            if is_value e1' then
              subst_syms _as e1' e2'
            else
              Esseq _as e1' e2'
      end
  
(*
  | Etry e str_es ->
      Etry (remove_seqs e) (List.map (fun (str, e) -> (str, remove_seqs e)) str_es)
*)
  | Eindet e ->
      Eindet (remove_seqs e)
  | Ebound n e ->
      Ebound n (remove_seqs e)
  | Esave k sym_tys e ->
      Esave k sym_tys (remove_seqs e)
  | End es ->
      End (List.map remove_seqs es)
  | Epar es ->
      Epar (List.map remove_seqs es)
  | _ ->
      expr
  end
*)

(* returns a Right iff the expression always ends with a return() *)
let rec remove_dead_aux expr =
  let extract = function
    | Left z ->
        z
    | Right z ->
        z
  end in
  match expr with
    | Elet sym pe1 e2 ->
        match remove_dead_aux e2 with
          | Left e2' ->
              Left (Elet sym pe1 e2')
          | Right e2' ->
              Right (Elet sym pe1 e2')
        end
    | Eif pe1 e2 e3 ->
        match (remove_dead_aux e2, remove_dead_aux e3) with
          | (Right e2', Right e3') ->
              Right (Eif pe1 e2' e3')
          | (Left e2', Right e3') ->
              Left (Eif pe1 e2' e3')
          | (Right e2', Left e3') ->
              Left (Eif pe1 e2' e3')
          | (Left e2', Left e3') ->
              Left (Eif pe1 e2' e3')
        end
    | Eunseq es ->
        let _es' = List.map remove_dead_aux es in
        if all isRight _es' then
          Right (Eunseq $ List.map extract _es')
        else
          Left (Eunseq $ List.map extract _es')
    | Ewseq _as e1 e2 ->
        match remove_dead_aux e1 with
          | Left e1' ->
              match remove_dead_aux e2 with
                | Left e2' ->
                    Left (Ewseq _as e1' e2')
                | Right e2' ->
                    Right (Ewseq _as e1' e2')
              end
          | Right e1' ->
              Right e1'
        end
    | Esseq _as e1 e2 ->
        match remove_dead_aux e1 with
          | Left e1' ->
              match remove_dead_aux e2 with
                | Left e2' ->
                    Left (Esseq _as e1' e2')
                | Right e2' ->
                    Right (Esseq _as e1' e2')
              end
          | Right e1' ->
              Right e1'
        end
    | Eindet e ->
        match remove_dead_aux e with
          | Left e' ->
              Left (Eindet e')
          | Right e' ->
              Right (Eindet e')
        end
    | Ebound i e ->
        match remove_dead_aux e with
          | Left e' ->
              Left (Ebound i e')
          | Right e' ->
              Right (Ebound i e')
        end
(*
    | Esave of ksym * list (sym * ctype) * expr 'a
    | Erun of 'a * ksym * list (sym * expr 'a)
*)
    | Eret _ ->
        Right expr
    | _ ->
        Left expr
  end

let remove_dead expr =
  match remove_dead_aux expr with
    | Left expr' ->
        expr'
    | Right expr' ->
        expr'
  end


let rec flatten_seqs expr =
  match expr with
    | Elet a pe1 e2 ->
        Elet a pe1 (flatten_seqs e2)
    | Eif pe1 e2 e3 ->
        Eif pe1 (flatten_seqs e2) (flatten_seqs e3)
    | Eunseq es ->
        Eunseq (List.map flatten_seqs es)
    | Ewseq _as e1 e2 ->
        match (flatten_seqs e1, flatten_seqs e2) with
          | (Ewseq _bs e1' e2', e3') ->
              Ewseq _bs e1' (Ewseq _as e2' e3')
          | (Esseq _bs e1' e2', e3') ->
              Esseq _bs e1' (Ewseq _as e2' e3')
          | (e1', e2') ->
              Ewseq _as e1' e2'
        end
    | Esseq _as e1 e2 ->
        match (flatten_seqs e1, flatten_seqs e2) with
          | (Ewseq _bs e1' e2', e3') ->
              Ewseq _bs e1' (Esseq _as e2' e3')
          | (Esseq _bs e1' e2', e3') ->
              Esseq _bs e1' (Esseq _as e2' e3')
          | (e1', e2') ->
              Esseq _as e1' e2'
        end
    | Eindet e ->
        Eindet (flatten_seqs e)
    | Ebound n e ->
        Ebound n (flatten_seqs e)
    | Esave k a_tys e ->
        Esave k a_tys (flatten_seqs e)
    | End es ->
        End (List.map flatten_seqs es)
    | Epar es ->
        Epar (List.map flatten_seqs es)
    | _ ->
        expr
  end


(* TODO: very quick'n'dirty *)
(* remove call to conv_int obviously not doing anything (using §5.2.4.2.1) *)
val in_minimal_range: ctype -> integer -> bool
let in_minimal_range ty n =
  match ty with
    | Basic (ATypes.Integer ATypes.Char) ->
        false (* TODO: because we don't use char is signed or unsigned *)
    | Basic (ATypes.Integer ATypes.Bool) ->
        n = 0 && n = 1
    | Basic (ATypes.Integer (ATypes.Signed ATypes.Ichar)) ->
        (0-127) <= n && n <= 127
    | Basic (ATypes.Integer (ATypes.Signed ATypes.Short)) ->
        (0-32767) <= n && n <= 32767
    | Basic (ATypes.Integer (ATypes.Signed ATypes.Int_)) ->
        (0-32767) <= n && n <= 32767
    | Basic (ATypes.Integer (ATypes.Signed ATypes.Long)) ->
        (0-2147483647) <= n && n <= 2147483647
    | Basic (ATypes.Integer (ATypes.Signed ATypes.LongLong)) ->
        let k = 2 ** 63 - 1 in
        (0 - k) <= n && n <= k
    | Basic (ATypes.Integer (ATypes.Unsigned ATypes.Ichar)) ->
        0 <= n && n <= 255
    | Basic (ATypes.Integer (ATypes.Unsigned ATypes.Short)) ->
        0 <= n && n <= 65535
    | Basic (ATypes.Integer (ATypes.Unsigned ATypes.Int_)) ->
        0 <= n && n <= 65535
    | Basic (ATypes.Integer (ATypes.Unsigned ATypes.Long)) ->
        0 <= n && n <= 4294967295
    | Basic (ATypes.Integer (ATypes.Unsigned ATypes.LongLong)) ->
        let k = 2 ** 64 - 1 in
        0 <= n && n <= k
    | _ ->
        false (* others are impl-def are should be given at conv_int as argument *)
  end


let rec remove_conv_int_pexpr pexpr =
  match pexpr with
    | PEundef _ ->
        pexpr
    | PEerror _ ->
        pexpr
    | PEval _ ->
        pexpr
    | PEsym _ ->
        pexpr
    | PEimpl _ ->
        pexpr
    | PEcons pe1 pe2 ->
        PEcons (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2)
    | PEcase_list pe nm1 nm2 ->
        PEcase_list (remove_conv_int_pexpr pe) nm1 nm2
    | PEcase_ctype pe nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8 nm9 ->
        PEcase_ctype (remove_conv_int_pexpr pe) nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8 nm9
    | PEshift pe sh ->
        PEshift (remove_conv_int_pexpr pe) sh
    | PEnot pe ->
        PEnot (remove_conv_int_pexpr pe)
    | PEop bop pe1 pe2 ->
        PEop bop (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2)
    | PEtuple pes ->
        PEtuple (List.map remove_conv_int_pexpr pes)
    | PEarray _ ->
        pexpr
    | PEcall nm pes ->
        let pes' = List.map remove_conv_int_pexpr pes in
        match (nm, pes') with
          (* TODO: hack !!!!!!!!! *)
          | (Sym (Symbol.Symbol _ (Just "conv_int")), [pe_ty; pe_n]) ->
              match (to_value pe_ty, to_value pe_n) with
                | (Just (Vctype ty), Just ((Vinteger (Mem.IVinteger n)) as cval)) ->
                    if in_minimal_range ty n then
                      PEval cval
                    else
                      PEcall nm pes'
                | _ ->
                    PEcall nm pes'
(*                    assert_false ("remove_conv_int_pexpr: Core type error? ==> " ^ pp_pexpr pexpr ^ " <==> " ^ pp_pexpr (PEval cval)) *)
              end
          | _ ->
              PEcall nm pes'
        end
    | PElet sym pe1 pe2 ->
        PElet sym (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2)
    | PEif pe1 pe2 pe3 ->
        PEif (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) (remove_conv_int_pexpr pe3)
    | PEis_scalar pe ->
        PEis_scalar (remove_conv_int_pexpr pe)
    | PEis_integer pe ->
        PEis_integer (remove_conv_int_pexpr pe)
    | PEis_signed pe ->
        PEis_signed (remove_conv_int_pexpr pe)
    | PEis_unsigned pe ->
        PEis_unsigned (remove_conv_int_pexpr pe)
  end

let rec remove_conv_int expr =
  match expr with
    | Epure pe ->
        Epure (remove_conv_int_pexpr pe)
    | Eraise _ ->
        expr
    | Eregister _ _ ->
        expr
    | Eskip ->
        expr
    | Elet sym pe1 e2 ->
        Elet sym (remove_conv_int_pexpr pe1) (remove_conv_int e2)
    | Eif pe1 e2 e3 ->
        Eif (remove_conv_int_pexpr pe1) (remove_conv_int e2) (remove_conv_int e3)
    | Eproc () nm pes ->
        Eproc () nm (List.map remove_conv_int_pexpr pes)
    | Eaction pact ->
        Eaction (remove_conv_int_paction pact)
    | Eunseq es ->
        Eunseq (List.map remove_conv_int es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (remove_conv_int e1) (remove_conv_int e2)
    | Esseq _as e1 e2 ->
        Esseq _as (remove_conv_int e1) (remove_conv_int e2)
    | Easeq a_opt act1 pact2 ->
        Easeq a_opt (remove_conv_int_action act1) (remove_conv_int_paction pact2)
    | Eindet e ->
        Eindet (remove_conv_int e)
    | Ebound i e ->
        Ebound i (remove_conv_int e)
    | Esave ksym sym_tys e ->
        Esave ksym sym_tys (remove_conv_int e)
    | Erun () ksym sym_pes ->
        Erun () ksym (List.map (fun (sym, pe) -> (sym, remove_conv_int_pexpr pe)) sym_pes)
    | Eret pe ->
        Eret (remove_conv_int_pexpr pe)
    | End es ->
        End (List.map remove_conv_int es)
    | Epar es ->
        Epar (List.map remove_conv_int es)
    | Ewait _ ->
        expr
  end

and remove_conv_int_action_ act_ =
  match act_ with
    | Create pe1 pe2 pref ->
        Create (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) pref
    | Alloc pe1 pe2 pref ->
        Alloc (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) pref
    | Kill pe ->
        Kill (remove_conv_int_pexpr pe)
    | Store pe1 pe2 pe3 mo ->
        Store (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) (remove_conv_int_pexpr pe3) mo
    | Load pe1 pe2 mo ->
        Load (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) mo
    | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeStrong (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) (remove_conv_int_pexpr pe3) (remove_conv_int_pexpr pe4) mo1 mo2
    | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (remove_conv_int_pexpr pe1) (remove_conv_int_pexpr pe2) (remove_conv_int_pexpr pe3) (remove_conv_int_pexpr pe4) mo1 mo2
  end

and remove_conv_int_action (Action () act_) = Action () (remove_conv_int_action_ act_)
and remove_conv_int_paction (Paction p act) = Paction p (remove_conv_int_action act)



let is_create = function
  | Eaction (Paction _ (Action _ (Create _ _ _))) ->
      true
  | _ ->
      false
end

let is_kill = function
  | Eaction (Paction _ (Action _ (Kill _))) ->
      true
  | _ ->
      false
end

(* TODO: not sure if this in general a sound optimisation, but it violently reduces ND *)
let rec sequentialise_creates_kills expr =
  match expr with
    | Elet sym pe1 e2 ->
        Elet sym pe1 (sequentialise_creates_kills e2)
    | Eif pe1 e2 e3 ->
        Eif pe1 (sequentialise_creates_kills e2) (sequentialise_creates_kills e3)
    | Eunseq es ->
        if List.all is_kill es then
          List.foldr (fun e acc ->
            Esseq [] e acc
          ) Eskip es
        else
          Eunseq (List.map sequentialise_creates_kills es)
    
    | Ewseq _as ((Eunseq es1) as e1) e2 ->
        if List.all is_create es1 then
          List.foldr (fun (sym_opt, e) acc ->
            Ewseq [sym_opt] e acc
          ) (sequentialise_creates_kills e2) (zip _as es1)
        else
          Ewseq _as (sequentialise_creates_kills e1) (sequentialise_creates_kills e2)
    
    | Ewseq _as e1 e2 ->
        Ewseq _as (sequentialise_creates_kills e1) (sequentialise_creates_kills e2)
    
    | Esseq _as ((Eunseq es1) as e1) e2 ->
        if List.all is_create es1 then
          List.foldr (fun (sym_opt, e) acc ->
            Esseq [sym_opt] e acc
          ) (sequentialise_creates_kills e2) (zip _as es1)
        else
          Esseq _as (sequentialise_creates_kills e1) (sequentialise_creates_kills e2)
    | Esseq _as e1 e2 ->
        Esseq _as (sequentialise_creates_kills e1) (sequentialise_creates_kills e2)
    
    | Eindet e ->
        Eindet (sequentialise_creates_kills e)
    | Ebound i e ->
        Ebound i (sequentialise_creates_kills e)
    | Esave k a_tys e ->
        Esave k a_tys (sequentialise_creates_kills e)
    | End es ->
        End (List.map sequentialise_creates_kills es)
    | Epar es ->
        Epar (List.map sequentialise_creates_kills es)
    
    | _ ->
        expr
  end


(* TODO: check the soundness ... *)
(* sequentialise unseq with independant  *)



let rec pure_propagation expr =
  match expr with
    | Elet sym pe1 e2 ->
        let e2' = pure_propagation e2 in
        match to_pure e2' with
          | Just pe2 ->
              Epure (PElet sym pe1 pe2)
          | Nothing ->
              Elet sym pe1 e2'
        end
    | Eif pe1 e2 e3 ->
        let e2' = pure_propagation e2 in
        let e3' = pure_propagation e3 in
        match (to_pure e2', to_pure e3') with
          | (Just pe2, Just pe3) ->
              Epure (PEif pe1 pe2 pe3)
          | (Just pe2, Nothing) ->
              Eif pe1 (Epure pe2) e3'
          | (Nothing, Just pe3) ->
              Eif pe1 e2' (Epure pe3)
        end
    | Eunseq es ->
        (* TODO: do better *)
        let es' = List.map pure_propagation es in
        match to_pures es' with
          | Just pes ->
              Epure (PEtuple pes)
          | Nothing ->
              Eunseq es'
        end
    | Ewseq _as e1 e2 ->
        let e1' = pure_propagation e1 in
        match to_pure e1' with
          | Just pe1 ->
              pure_propagation (subst_syms _as pe1 e2)
          | Nothing ->
              Ewseq _as e1' (pure_propagation e2)
       end
    | Esseq _as e1 e2 ->
        let e1' = pure_propagation e1 in
        match to_pure e1' with
          | Just pe1 ->
              pure_propagation (subst_syms _as pe1 e2)
          | Nothing ->
              Esseq _as e1' (pure_propagation e2)
       end
    | Eindet e ->
        Eindet (pure_propagation e)
    | Ebound n e ->
        Ebound n (pure_propagation e)
    | Esave sym sym_tys e ->
        Esave sym sym_tys (pure_propagation e)
    | End es ->
        End (List.map pure_propagation es)
    | Epar es ->
        Epar (List.map pure_propagation es)
    | _ ->
        expr
  end










(* ========================================================================== *)

let rewrite_pexpr pexpr =
  remove_conv_int_pexpr pexpr

let rewrite_expr expr =
  (pure_propagation -| remove_conv_int -|
   (* remove_dead -| remove_seqs -| remove_unseqs -| flatten_seqs -| *) remove_skips -|
   sequentialise_creates_kills) expr

let rewrite_fun_map fun_map =
  Map.map (function
    | Fun ty params pe ->
        Fun ty params (rewrite_pexpr pe)
    | Proc ty params e ->
        Proc ty params (rewrite_expr e)
  end) fun_map




(* TODO *)
let rewrite_file file =
  <| file with funs=  rewrite_fun_map file.funs;
               globs= List.map (fun (sym, cTy, e) -> (sym, cTy, rewrite_expr e)) file.globs |>
