open import Pervasives
import Map_extra

open import Global Errors
import Exception Loc

open import Core Core_aux
import Core_ctype Core_ctype_aux

module Cty = struct
  include Core_ctype
  include Core_ctype_aux
end

module E = struct
  type eff 'a = Exception.exceptM 'a Errors.core_typing_cause
  include Exception

  val mapMapM: forall 'k 'a 'b. MapKeyType 'k, SetType 'k, SetType 'a => ('a -> eff 'b) -> map 'k 'a -> eff (map 'k 'b)
  let mapMapM f xs =
    Map_extra.fold (fun k a acc ->
      bind (f a) (fun b ->
        bind acc (fun bs ->
          return (Map.insert k b bs)
        )
      )
    ) xs (return Map.empty)

  val runM: forall 'a. eff 'a -> Exception.exceptM 'a Errors.core_typing_cause
  let runM m = m
end

let inline (>>=)      = E.bind
let inline (>>) m1 m2 = m1 >>= fun _ -> m2
let inline (<$>)      = E.fmap
let inline (<*>)      = E.app

type typing_env =
    map Symbol.sym (either core_base_type (core_base_type * list core_base_type))

val     annotate_pattern: core_base_type -> pattern -> E.eff (typing_env * typed_pattern)
let rec annotate_pattern bTy = function
  | CaseBase Nothing ->
      E.return (Map.empty, CaseBase Nothing)
  | CaseBase (Just (sym, bTy')) ->
      E.guard (bTy = bTy') (CoreTyping_TODO "annotate CaseBase") >>
      E.return (Map.singleton sym (Left bTy'), CaseBase (Just (sym, bTy')))
  | CaseCtor ctor pats ->
      match (ctor, bTy, pats) with
        | (Cnil (), BTy_list elem_bTy, []) ->
            E.return (Map.empty, CaseCtor (Cnil elem_bTy) [])
        | (Cnil (), _, []) ->
            E.fail (CoreTyping_TODO "annotate Cnil, illtyped 1")
        | (Cnil (), _, _) ->
            E.fail (CoreTyping_TODO "annotate Cnil, illtyped 2")

        | (Ccons, BTy_list elem_bTy, [pat1; pat2]) ->
            annotate_pattern elem_bTy pat1 >>= fun (env1, tpat1) ->
            annotate_pattern bTy      pat2 >>= fun (env2, tpat2) ->
            E.return (Map.(union) env1 env2, CaseCtor Ccons [tpat1; tpat2])
        | (Ccons, _, []) ->
            E.fail (CoreTyping_TODO "annotate Ccons, illtyped 1")
        | (Ccons, _, _) ->
            E.fail (CoreTyping_TODO "annotate Ccons, illtyped 2")

        | (Ctuple, BTy_tuple bTys, _) ->
            List.unzip <$> E.mapM (fun (bTy, pat) ->
              annotate_pattern bTy pat
            ) (List.zip bTys pats) >>= fun (envs, tpats) ->
            E.return (List.foldl (Map.(union)) Map.empty envs, CaseCtor Ctuple tpats)
        | (Ctuple, _, _) ->
            E.fail (CoreTyping_TODO "annotate Ctuple, illtyped")

        | (Carray, _, _) ->
            error "Core_typing.Carray: WIP, Carray"

        | (Civmax, BTy_object OTy_integer, [pat']) ->
            annotate_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, CaseCtor Civmax [tpat'])
        | (Civmax, _, [_]) ->
            E.fail (CoreTyping_TODO "annotate Civmax, illtyped 1")
        | (Civmax, _, _) ->
            E.fail (CoreTyping_TODO "annotate Civmax, illtyped 2")

        | (Civmin, BTy_object OTy_integer, [pat']) ->
            annotate_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, CaseCtor Civmin [tpat'])
        | (Civmin, _, [_]) ->
            E.fail (CoreTyping_TODO "annotate Civmin, illtyped 1")
        | (Civmin, _, _) ->
            E.fail (CoreTyping_TODO "annotate Civmin, illtyped 2")

        | (Civsizeof, BTy_object OTy_integer, [pat']) ->
            annotate_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, CaseCtor Civsizeof [tpat'])
        | (Civsizeof, _, [_]) ->
            E.fail (CoreTyping_TODO "annotate Civsizeof, illtyped 1")
        | (Civsizeof, _, _) ->
            E.fail (CoreTyping_TODO "annotate Civsizeof, illtyped 2")

        | (Civalignof, BTy_object OTy_integer, [pat']) ->
            annotate_pattern (BTy_ctype) pat' >>= fun (env, tpat') ->
            E.return (env, CaseCtor Civalignof [tpat'])
        | (Civalignof, _, [_]) ->
            E.fail (CoreTyping_TODO "annotate Civalignof, illtyped 1")
        | (Civalignof, _, _) ->
            E.fail (CoreTyping_TODO "annotate Civalignof, illtyped 2")

        | (Cspecified, BTy_loaded oTy, [pat']) ->
            annotate_pattern (BTy_object oTy) pat' >>= fun (env, tpat') ->
            E.return (env, CaseCtor Cspecified [tpat'])
        | (Cspecified, _, [_]) ->
            E.fail (CoreTyping_TODO "annotate Cspecified, illtyped 1")
        | (Cspecified, _, _) ->
            E.fail (CoreTyping_TODO "annotate Cspecified, illtyped 2")

        | (Cunspecified, BTy_loaded oTy, [pat']) ->
            (* TODO: dependent types here .... *)
            annotate_pattern BTy_ctype pat' >>= fun (env, tpat') ->
            E.return (env, CaseCtor Cunspecified [tpat'])
        | (Cunspecified, _, [_]) ->
            E.fail (CoreTyping_TODO "annotate Cunspecified, illtyped 1")
        | (Cunspecified, _, _) ->
            E.fail (CoreTyping_TODO "annotate Cunspecified, illtyped 2")
      end
end

val     typeof_object_value: object_value -> E.eff core_object_type
let rec typeof_object_value oval =
  match oval with
   | OVinteger _ ->
       E.return OTy_integer
   | OVfloating _ ->
       E.return OTy_floating
   | OVpointer _ ->
       E.return OTy_pointer
   | OVcfunction _ ->
       E.return OTy_cfunction
   | OVarray [] ->
       E.fail EmptyArray
   | OVarray (oval'::ovals') ->
       typeof_object_value oval' >>= fun oTy ->
       E.mapM (fun oval ->
         typeof_object_value oval >>= fun oTy' ->
         if oTy <> oTy' then
           E.fail (HeterogenousArray oTy oTy')
         else
           E.return ()
       ) ovals' >>
       E.return (OTy_array oTy)
   | OVstruct tag_sym _ ->
       E.return (OTy_struct tag_sym)
(*
       E.foldlM (fun ((found_ident, mval), (expected_ident, expected_ty)) () ->
         if found_ident <> expected_ident then
           E.fail (InvalidMember tag_sym found_ident)
         else
           TODO
       ) () (List.zip xs (Cty.get_membersDefs tag_sym)) >>
       E.return (OTy_struct tag_sym)
*)
   | OVunion tag_sym _ _ ->
       E.return (OTy_union tag_sym)
  end


val     typeof_value: Core.value -> E.eff core_base_type
let rec typeof_value cval =
  match cval with
    | Vobject oval ->
        BTy_object <$> typeof_object_value oval
    | Vspecified oval ->
        BTy_loaded <$> typeof_object_value oval
    | Vunspecified ty ->
        E.return (BTy_loaded $ core_object_type_of_ctype ty)
    | Vunit ->
        E.return BTy_unit
    | Vtrue ->
        E.return BTy_boolean
    | Vfalse ->
        E.return BTy_boolean
    | Vctype _ ->
        E.return BTy_ctype
    | Vlist bTy cvals' ->
       E.mapM (fun cval ->
         typeof_value cval >>= fun bTy' ->
         if bTy <> bTy' then
           E.fail (HeterogenousList bTy bTy')
         else
           E.return ()
       ) cvals' >>
       E.return (BTy_list bTy)
    | Vtuple cvals ->
        BTy_tuple <$> E.mapM typeof_value cvals
  end


val annotate_pexpr: typing_env -> pexpr -> E.eff typed_pexpr
let rec annotate_pexpr env (Pexpr () pexpr_) =
  match pexpr_ with
    | PEsym sym ->
        match Map.lookup sym env with
          | Just (Left bTy) ->
              E.return (Pexpr bTy (PEsym sym))
          | Just (Right _) ->
              E.fail (CoreTyping_TODO "found a fun/proc symbolic in a PEsym")
          | Nothing ->
              E.fail (CoreTyping_TODO "unresolved PEsym")
        end
    (* FIXME: match type for each impl constant??? *)
    | PEimpl impl ->
        E.return (Pexpr (BTy_object OTy_integer) (PEimpl impl))
    | PEval cval ->
        typeof_value cval >>= fun bTy -> E.return (Pexpr bTy (PEval cval))
    | PEconstrained cs -> error "peconstrained"
(*
    | PEconstrained of list (list Mem.mem_constraint2 * (generic_pexpr 'ty 'sym)) (* constrained value *)
*)
    | PEundef ub -> error "annotate peundef"
    | PEerror str pe -> error "annotate peerror"

    | PEctor ctor pes ->
        let ret_ctor bTy ctor pe = E.return (Pexpr bTy (PEctor ctor [pe])) in
        match (ctor, pes) with
          | (Cnil (), []) ->
              error "annotate cnil: list of ????"
          | (Cnil _, _) ->
              E.fail (CoreTyping_TODO "illtyped list")
          | (Ccons, [pe]) ->
              annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
              ret_ctor (BTy_list bTy) Ccons pe'
          | (Ccons, [pe1; pe2]) ->
              annotate_pexpr env pe1 >>= fun (Pexpr bTy1 _ as pe1') ->
              annotate_pexpr env pe2 >>= fun (Pexpr bTy2 _ as pe2') ->
              E.guard (BTy_list bTy1 = bTy2)
                (CoreTyping_TODO "annotate Ccons: illtyped list") >>
              E.return (Pexpr bTy2 (PEctor Ccons [pe1'; pe2']))
          | (Ccons, _) ->
              E.fail (CoreTyping_TODO "illtyped list")
          | (Ctuple, _) ->
            E.mapM (annotate_pexpr env) pes >>= fun pes' ->
            let (bTys, pes') = List.unzip (
                List.map (fun (Pexpr bTy _ as pe') -> (bTy, pe')) pes'
            ) in E.return (Pexpr (BTy_tuple bTys) (PEctor Ctuple pes'))
          | (Civmax, [pe]) ->
              annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
              E.guard (bTy = BTy_ctype) (CoreTyping_TODO "illtyped Civmax") >>
              ret_ctor (BTy_object OTy_integer) Civmax pe'
          | (Civmax, _) ->
              E.fail (CoreTyping_TODO "illtyped Civmax")
          | (Civmin, [pe]) ->
              annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
              E.guard (bTy = BTy_ctype) (CoreTyping_TODO "illtyped Civmin") >>
              ret_ctor (BTy_object OTy_integer) Civmax pe'
          | (Civsizeof, [pe]) ->
              annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
              E.guard (bTy = BTy_ctype) (CoreTyping_TODO "illtyped Civsizeof") >>
              ret_ctor (BTy_object OTy_integer) Civmax pe'
          | (Civsizeof, _) ->
              E.fail (CoreTyping_TODO "illtyped Civsizeof")
          | (Civalignof, [pe]) ->
              annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
              E.guard (bTy = BTy_ctype) (CoreTyping_TODO "illtyped Civalignof") >>
              ret_ctor (BTy_object OTy_integer) Civmax pe'
          | (Civalignof, _) ->
              E.fail (CoreTyping_TODO "illtyped Civalignof")
          | (Cspecified, [pe]) ->
              annotate_pexpr env pe >>= fun (Pexpr (BTy_object oTy) _ as pe') ->
              ret_ctor (BTy_loaded oTy) Cspecified pe'
          | (Cspecified, _) ->
              E.fail (CoreTyping_TODO "illtyped Cspecified")
          | (Cunspecified, [pe]) ->
              error "cunspecified type ????"
              (*
              annotate_pexpr env pe >>= fun (Pexpr (BTy_ctype) _ as pe') ->
              ret_ctor (BTy_loaded oTy) Cunspecified pe'
                 *)
          | (Cunspecified, _) ->
              E.fail (CoreTyping_TODO "illtyped Cunspecified")
        end
    | PEcase pe cases ->
        annotate_pexpr env pe >>= fun (Pexpr mbTy _ as pe') ->
        E.mapM (fun (pat, pe) -> annotate_pattern mbTy pat >>=
                 fun (env', pat') -> annotate_pexpr (Map.(union) env env') pe >>=
                 fun pe' -> E.return (pat', pe')
               ) cases >>= fun cases' ->
        E.return (Pexpr mbTy (PEcase pe' cases'))
    | PEarray_shift pe1 cty pe2 ->
        (*FIXME: this is probably wrong *)
        annotate_pexpr env pe1 >>= fun pe1' ->
        annotate_pexpr env pe2 >>= fun (Pexpr bTy _ as pe2') ->
        E.return (Pexpr bTy (PEarray_shift pe1' cty pe2'))
    | PEmember_shift _ _ _ -> error "pemember shift 1"
    | PEnot pe ->
        Pexpr BTy_boolean <$> (PEnot <$> typecheck_pexpr env BTy_boolean pe)
    | PEop bop pe1 pe2 ->
        E.trysM (CoreTyping_TODO "PEop") (fun (bTy, bTy1, bTy2) ->
          Pexpr bTy <$> (PEop bop <$> typecheck_pexpr env bTy1 pe1
                                  <*> typecheck_pexpr env bTy2 pe2)
        ) match bop with
          | OpAdd ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpSub ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpMul ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpDiv ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpRem_t ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpRem_f ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpExp ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpEq ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating)
              ; (BTy_boolean, BTy_ctype, BTy_ctype) ]
          | OpGt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpGe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpAnd ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
          | OpOr ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
        end
    (* FIXME: fields in struct and union should be checked *)
    | PEstruct sym fields ->
        let (ids, pes) = List.unzip fields in
        Pexpr (BTy_object (OTy_struct sym)) <$>
          (PEstruct sym <$> (List.zip ids <$> E.mapM (annotate_pexpr env) pes))
    | PEunion sym id pe ->
        Pexpr (BTy_object (OTy_union sym)) <$>
          (PEunion sym id <$> annotate_pexpr env pe)
    | PEcall (Sym sym) pes ->
        match Map.lookup sym env with
          | Just (Left _) ->
              E.fail (CoreTyping_TODO "illtyped a fun/proc symbolic")
          | Just (Right (ret_bTy, bTys)) ->
              Pexpr ret_bTy <$> (PEcall (Sym sym) <$> E.mapM (fun (bTy, pe) ->
                typecheck_pexpr env bTy pe) (List.zip bTys pes))
          | Nothing ->
              E.fail (CoreTyping_TODO "unresolved PEcall")
        end
    | PEcall (Impl impl) pes ->
        annotate_pexpr env (Pexpr () (PEimpl impl)) >>= fun (Pexpr impl_bTy _) ->
        Pexpr impl_bTy <$> (PEcall (Impl impl) <$> E.mapM (annotate_pexpr env) pes)
    | PElet pat pe1 pe2 ->
        annotate_pexpr env pe1 >>= fun (Pexpr bTy1 _ as pe1') ->
        annotate_pattern bTy1 pat >>= fun (env', pat') ->
        annotate_pexpr (Map.(union) env env') pe2 >>= fun (Pexpr bTy2 _ as pe2') ->
        E.return (Pexpr bTy2 (PElet pat' pe1' pe2'))
    | PEif pe1 pe2 pe3 ->
        annotate_pexpr env pe3 >>= fun (Pexpr bTy _ as pe3') ->
        Pexpr bTy <$> (PEif <$> typecheck_pexpr env BTy_boolean pe1
             <*> typecheck_pexpr env bTy pe2
             <*> E.return pe3')
    | PEis_scalar pe ->
        Pexpr BTy_boolean <$> (PEis_scalar <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_integer pe ->
        Pexpr BTy_boolean <$> (PEis_integer <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_signed pe ->
        Pexpr BTy_boolean <$> (PEis_signed <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_unsigned pe ->
        Pexpr BTy_boolean <$> (PEis_unsigned <$> typecheck_pexpr env BTy_ctype pe)
  end
(*
val     typecheck_pexpr: typing_env -> core_base_type -> pexpr -> E.eff
typed_pexpr*)
and typecheck_pexpr env bTy (Pexpr () pexpr_) =
(*
  let expect bTy env pe =
    typecheck_pexpr env pe >>= fun (Pexpr bTy' _ as tpe) ->
    E.guard (bTy = bTy') (CoreTyping_TODO "mismatch") >>
    E.return tpe in
*)
  Pexpr bTy <$> match pexpr_ with
    | PEsym sym ->
        match Map.lookup sym env with
          | Just (Left bTy') ->
              E.guard (bTy = bTy') (CoreTyping_TODO "illtyped PEsym") >>
              E.return (PEsym sym)
          | Just (Right _) ->
              E.fail (CoreTyping_TODO "found a fun/proc symbolic in a PEsym")
          | Nothing ->
              E.fail (CoreTyping_TODO "unresolved PEsym")
        end
    (* FIXME: check type per implementation constant ?*)
    | PEimpl impl -> E.return (PEimpl impl)
    | PEval cval ->
        typeof_value cval >>= fun bTy' ->
        E.guard (bTy = bTy') (CoreTyping_TODO "illtyped value") >>
        E.return (PEval cval)

    | PEconstrained cs -> error "peconstrained"
(*
    | PEconstrained of list (list Mem.mem_constraint2 * (generic_pexpr 'ty 'sym)) (* constrained value *)
*)
    | PEundef ub ->
        E.return (PEundef ub)

    (* TODO need to check pe somehow ... *)
    | PEerror str pe ->
        PEerror str <$> annotate_pexpr env pe

    | PEctor ctor pes ->
        let ret_ctor ctor pe = PEctor ctor [pe] in
        match (ctor, bTy, pes) with
          | (Cnil (), BTy_list elem_bTy, []) ->
              E.return (PEctor (Cnil elem_bTy) [])
          | (Cnil _, _, _) ->
              E.fail (CoreTyping_TODO "illtyped list")
          | (Ccons, BTy_list elem_bTy, [pe]) ->
              ret_ctor Ccons <$> typecheck_pexpr env elem_bTy pe
          | (Ccons, BTy_list elem_bTy, [pe1; pe2]) ->
              typecheck_pexpr env elem_bTy pe1 >>=
              fun pe1' -> typecheck_pexpr env bTy pe2 >>=
              fun pe2' -> E.return (PEctor Ccons [pe1'; pe2'])
          | (Ccons, _, _) ->
              E.fail (CoreTyping_TODO "illtyped list")
          | (Ctuple, BTy_tuple bTys, _) ->
              E.mapM (fun (bTy, pe) -> typecheck_pexpr env bTy pe)
                (List.zip bTys pes) >>=
              (fun pes' -> E.return (PEctor Ctuple pes'))
          | (Ctuple, _, _) ->
              E.fail (CoreTyping_TODO "illtyped tuple")
          | (Civmax, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civmax <$> typecheck_pexpr env (BTy_ctype) pe
          | (Civmax, _, _) ->
              E.fail (CoreTyping_TODO "illtyped Civmax")
          | (Civmin, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civmin <$> typecheck_pexpr env (BTy_ctype) pe
          | (Civmin, _, _) ->
              E.fail (CoreTyping_TODO "illtyped Civmin")
          | (Civsizeof, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civsizeof <$> typecheck_pexpr env (BTy_ctype) pe
          | (Civsizeof, _, _) ->
              E.fail (CoreTyping_TODO "illtyped Civsizeof")
          | (Civalignof, BTy_object OTy_integer, [pe]) ->
              ret_ctor Civalignof <$> typecheck_pexpr env (BTy_ctype) pe
          | (Civalignof, _, _) ->
              E.fail (CoreTyping_TODO "illtyped Civalignof")
          | (Cspecified, BTy_loaded oTy, [pe]) ->
              ret_ctor Cspecified <$> typecheck_pexpr env (BTy_object oTy) pe
          | (Cspecified, _, _) ->
              E.fail (CoreTyping_TODO "illtyped Cspecified")
          | (Cunspecified, BTy_loaded _, [pe]) ->
              ret_ctor Cunspecified <$> typecheck_pexpr env BTy_ctype pe
          | (Cunspecified, _, _) ->
              E.fail (CoreTyping_TODO "illtyped Cunspecified")
        end

    | PEcase pe cases ->
        annotate_pexpr env pe >>= fun (Pexpr mbTy _ as pe') ->
        E.mapM (fun (pat, pe) -> annotate_pattern mbTy pat >>=
                 fun (env', pat') -> typecheck_pexpr (Map.(union) env env') bTy pe >>=
                 fun pe' -> E.return (pat', pe')
               ) cases >>= fun cases' -> E.return (PEcase pe' cases')
    | PEarray_shift pe1 cTy pe2 -> error "pearray_shift"
    | PEmember_shift pe1 sym id -> error "pemember_shift"
(*
    | PEarray_shift of (generic_pexpr 'ty 'sym) * ctype * (generic_pexpr 'ty 'sym) (* pointer array shift *)
    | PEmember_shift of (generic_pexpr 'ty 'sym) * Symbol.sym * Cabs.cabs_identifier (* pointer struct/union member shift *)
*)
    | PEnot pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEnot") >>
        (PEnot <$> typecheck_pexpr env BTy_boolean pe)
    | PEop bop pe1 pe2 ->
        (* TODO: this is going to give horrible error messages ... *)
        E.trysM (CoreTyping_TODO "PEop") (fun (bTy', bTy1, bTy2) ->
          E.guard (bTy = bTy') (CoreTyping_TODO "PEop bTy") >>
          (PEop bop <$> typecheck_pexpr env bTy1 pe1
                    <*> typecheck_pexpr env bTy2 pe2)
        ) match bop with
          | OpAdd ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpSub ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpMul ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpDiv ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpRem_t ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpRem_f ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpExp ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpEq ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating)
              ; (BTy_boolean, BTy_ctype, BTy_ctype) ]
          | OpGt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpGe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpAnd ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
          | OpOr ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
        end
    | PEstruct sym fields ->
        E.guard (bTy = BTy_object (OTy_struct sym))
          (CoreTyping_TODO "PEstruct illtyped") >>
        let (ids, pes) = List.unzip fields in
        PEstruct sym <$> (List.zip ids <$> E.mapM (annotate_pexpr env) pes)
    | PEunion sym id pe ->
        E.guard (bTy = BTy_object (OTy_union sym))
          (CoreTyping_TODO "PEunion illtyped") >>
        (PEunion sym id <$> annotate_pexpr env pe)
    | PEcall (Sym sym) pes ->
        match Map.lookup sym env with
          | Just (Left _) ->
              E.fail (CoreTyping_TODO "illtyped a fun/proc symbolic")
          | Just (Right (ret_bTy, bTys)) ->
            PEcall (Sym sym) <$> E.mapM (fun (bTy, pe) ->
                typecheck_pexpr env bTy pe) (List.zip bTys pes)
          | Nothing ->
              E.fail (CoreTyping_TODO "unresolved PEcall")
        end
    | PEcall (Impl impl) pes ->
        PEcall (Impl impl) <$> E.mapM (annotate_pexpr env) pes
    | PElet pat pe1 pe2 ->
        annotate_pexpr env pe1 >>= fun ((Pexpr bTy1 _) as pe1') ->
        annotate_pattern bTy1 pat >>= fun (env', pat') ->
        typecheck_pexpr (Map.(union) env env') bTy pe2 >>= fun pe2' ->
        E.return (PElet pat' pe1' pe2')
    | PEif pe1 pe2 pe3 ->
        PEif <$> typecheck_pexpr env BTy_boolean pe1
             <*> typecheck_pexpr env bTy pe2
             <*> typecheck_pexpr env bTy pe3
    | PEis_scalar pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_scalar") >>
        (PEis_scalar <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_integer pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_integer") >>
        (PEis_integer <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_signed pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_signed") >>
        (PEis_signed <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_unsigned pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_unsigned") >>
        (PEis_unsigned <$> typecheck_pexpr env BTy_ctype pe)
  end

val     annotate_action: typing_env -> generic_action unit unit Symbol.sym ->
          E.eff (generic_action unit core_base_type Symbol.sym)
let rec annotate_action env (Action loc x act) =
  Action loc x <$> match act with
    | Create pe1 pe2 pre ->
        Create <$> annotate_pexpr env pe1
               <*> annotate_pexpr env pe2
               <*> E.return pre
    | Alloc pe1 pe2 pre ->
        Alloc <$> annotate_pexpr env pe1
              <*> annotate_pexpr env pe2
              <*> E.return pre
    | Kill pe ->
        Kill <$> annotate_pexpr env pe
    | Store pe1 pe2 pe3 mo ->
        Store <$> annotate_pexpr env pe1
              <*> annotate_pexpr env pe2
              <*> annotate_pexpr env pe3
              <*> E.return mo
    | Load pe1 pe2 mo ->
        Load <$> annotate_pexpr env pe1
             <*> annotate_pexpr env pe2
             <*> E.return mo
    | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
        RMW <$> annotate_pexpr env pe1
            <*> annotate_pexpr env pe2
            <*> annotate_pexpr env pe3
            <*> annotate_pexpr env pe4
            <*> E.return mo1
            <*> E.return mo2
    | Fence mo ->
        E.return (Fence mo)
  end

val annotate_paction: typing_env -> generic_paction unit unit Symbol.sym ->
      E.eff (generic_paction unit core_base_type Symbol.sym)
let rec annotate_paction env (Paction p act) =
  Paction p <$> annotate_action env act

val annotate_expr: typing_env -> Core.expr unit ->
      E.eff (core_base_type * Core.typed_expr unit)
let rec annotate_expr env = function
  | Epure pe ->
     annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
     E.return (bTy, Epure pe')
  (* FIXME: are ememop and eaction of type unit? *)
  | Ememop memop pes ->
      E.mapM (annotate_pexpr env) pes >>= fun pes' ->
      E.return (BTy_unit, Ememop memop pes')
  | Eaction pact ->
      annotate_paction env pact >>= fun pact' ->
      E.return (BTy_unit, Eaction pact')
  | Ecase pe cases ->
      annotate_pexpr env pe >>= fun (Pexpr mbTy _ as pe') ->
      E.mapM (fun (pat, e) -> annotate_pattern mbTy pat >>=
              fun (env', pat') -> annotate_expr (Map.(union) env env') e >>=
              fun (_, e') -> E.return (pat', e')
             ) cases >>= fun cases' -> E.return (mbTy, Ecase pe' cases')
  | Elet pat pe1 e2 ->
      annotate_pexpr env pe1 >>= fun ((Pexpr bTy1 _) as pe1') ->
      annotate_pattern bTy1 pat >>= fun (env', pat') ->
      annotate_expr (Map.(union) env env') e2 >>= fun (bTy, e2') ->
      E.return (bTy, Elet pat' pe1' e2')
  | Eif pe1 e2 e3 ->
      typecheck_pexpr env BTy_boolean pe1 >>= fun pe1' ->
      annotate_expr env e2 >>= fun (bTy2, e2') ->
      annotate_expr env e3 >>= fun (bTy3, e3') ->
      E.guard (bTy2 = bTy3) (CoreTyping_TODO "Eif illtyped") >>
      E.return (bTy2, Eif pe1' e2' e3')
  | Eskip ->
      E.return (BTy_unit, Eskip)
  | Eproc () pe pes ->
      annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
      E.mapM (annotate_pexpr env) pes >>= fun pes' ->
      E.return (bTy, Eproc () pe' pes')
  | Ereturn pe ->
      annotate_pexpr env pe >>= fun (Pexpr bTy _ as pe') ->
      E.return (bTy, Ereturn pe')
  | Eunseq []  ->
      E.fail (CoreTyping_TODO "UNSEQ must have at least two arguments (seen 0)")
  | Eunseq [e] ->
      E.fail (CoreTyping_TODO "UNSEQ must have at least two arguments (seen 1)")
  | Eunseq es ->
      (List.unzip <$> E.mapM (annotate_expr env) es) >>= fun (bTys, es') ->
      E.return (BTy_tuple bTys, Eunseq es')
  | Ewseq pat e1 e2 ->
      annotate_expr env e1 >>= fun (bTy1, e1') ->
      annotate_pattern bTy1 pat >>= fun (env', pat') ->
      annotate_expr (Map.(union) env env') e2 >>= fun (bTy2, e2') ->
      E.return (bTy2, Ewseq pat' e1' e2')
  | Esseq pat e1 e2 ->
      annotate_expr env e1 >>= fun (bTy1, e1') ->
      annotate_pattern bTy1 pat >>= fun (env', pat') ->
      annotate_expr (Map.(union) env env') e2 >>= fun (bTy2, e2') ->
      E.return (bTy2, Esseq pat' e1' e2')
  | Easeq m act pact -> error "annotate easeq"
  | Eindet n e -> error "annotate eindet"
  | Ebound n e -> error "annotate ebound"
  | End es -> error "annotate end"
  | Esave _ _ _  -> error "annotate esave"
  | Erun _ _ _ -> error "annotate erun"
  | Epar e -> error "annotate epar"
  | Ewait id -> error "annotate ewait"
  | Eloc _ e -> error "annotate eloc"
end

val typecheck_expr: typing_env -> core_base_type -> Core.expr unit ->
      E.eff (Core.typed_expr unit)
let rec typecheck_expr env bTy = function
  | Epure pe ->
      Epure <$> typecheck_pexpr env bTy pe
  | Ememop memop pes ->
      E.guard (bTy = BTy_unit) (CoreTyping_TODO "Ememop illtyped") >>
      (Ememop memop <$> E.mapM (annotate_pexpr env) pes)
  | Eaction pact ->
      E.guard (bTy = BTy_unit) (CoreTyping_TODO "Eaction illtyped") >>
      (Eaction <$> annotate_paction env pact)
  | Ecase pe cases ->
      annotate_pexpr env pe >>= fun (Pexpr mbTy _ as pe') ->
      E.mapM (fun (pat, e) -> annotate_pattern mbTy pat >>=
              fun (env', pat') -> typecheck_expr (Map.(union) env env') bTy e >>=
              fun e' -> E.return (pat', e')
             ) cases >>= fun cases' -> E.return (Ecase pe' cases')
  | Elet pat pe1 e2 ->
      annotate_pexpr env pe1 >>= fun ((Pexpr bTy1 _) as pe1') ->
      annotate_pattern bTy1 pat >>= fun (env', pat') ->
      Elet pat' pe1' <$> typecheck_expr (Map.(union) env env') bTy e2
  | Eif pe1 e2 e3 ->
      Eif <$> typecheck_pexpr env BTy_boolean pe1
          <*> typecheck_expr env bTy e2
          <*> typecheck_expr env bTy e3
  | Eskip ->
      E.guard (bTy = BTy_unit) (CoreTyping_TODO "Eskip") >>
      E.return Eskip
  | Eproc () pe pes ->
      Eproc () <$> typecheck_pexpr env bTy pe
               <*> E.mapM (annotate_pexpr env) pes
  | Ereturn pe ->
      Ereturn <$> typecheck_pexpr env bTy pe
  | Eunseq []  ->
      E.fail (CoreTyping_TODO "UNSEQ must have at least two arguments (seen 0)")
  | Eunseq [e] ->
      E.fail (CoreTyping_TODO "UNSEQ must have at least two arguments (seen 1)")
  | Eunseq es ->
      match bTy with
        | BTy_tuple bTys ->
            Eunseq <$> E.mapM (fun (bTy, e) -> typecheck_expr env bTy e)
                        (List.zip bTys es)
        | _ -> E.fail (CoreTyping_TODO "UNSEQ illtyped")
      end
  | Ewseq pat e1 e2 ->
      annotate_expr env e1 >>= fun (bTy1, e1') ->
      annotate_pattern bTy1 pat >>= fun (env', pat') ->
      Ewseq pat' e1' <$> typecheck_expr (Map.(union) env env') bTy e2
  | Esseq pat e1 e2 ->
      annotate_expr env e1 >>= fun (bTy1, e1') ->
      annotate_pattern bTy1 pat >>= fun (env', pat') ->
      Esseq pat' e1' <$> typecheck_expr (Map.(union) env env') bTy e2
  | Easeq m act pact -> error "easeq"
  | Eindet n e -> error "eindet"
  | Ebound n e -> error "ebound"
  | End es -> error "end"
  | Esave _ _ _  -> error "esave"
  | Erun _ _ _ -> error "erun"
  | Epar e -> error "epar"
  | Ewait id -> error "ewait"
  | Eloc _ e ->
      typecheck_expr env bTy e
end

(* TODO: add a check for the existence of main *)
val typecheck_program: Core.file unit -> Exception.exceptM (Core.typed_file unit) Errors.error
let typecheck_program file =
  let aux =
    (* The startup function/procedure must be defined *)
    E.guard (Map.member file.main file.funs) (Undefined_startup file.main) >>

    (* Register the functions/procedures from the stdlib *)
    let env = (*TODO*)(Map.empty : map Symbol.sym (either core_base_type (core_base_type * (list core_base_type)))) in
    E.mapMapM (function
      | Fun bTy sym_bTys pe ->
          let env' = List.foldr (fun (sym, bTy) acc -> Map.insert sym (Left bTy) acc) env sym_bTys in
          Fun bTy sym_bTys <$> typecheck_pexpr env' bTy pe
      | Proc bTy sym_bTys e ->
          let env' = List.foldr (fun (sym, bTy) acc -> Map.insert sym (Left bTy) acc) env sym_bTys in
          Proc bTy sym_bTys <$> typecheck_expr env' bTy e
    end) file.stdlib >>= fun stdlib' ->

    E.mapM (fun (sym, bTy, e) ->
      typecheck_expr env bTy e >>= fun te ->
      E.return (sym, bTy, te)
    ) file.globs >>= fun globs' ->

    let impl' = Map.empty in
    let funs' = Map.empty in

    E.return <| main= file.main; stdlib= stdlib'; impl= impl'; globs= globs'; funs= funs' |>
  in
  match E.runM aux with
    | Exception.Result file' ->
        Exception.return file'
    | Exception.Exception cause ->
        Exception.Exception (Loc.unknown, Errors.Core_typing_cause cause)
  end
(*
 type file 'a = <|
   main   : Symbol.sym;
   stdlib : fun_map 'a;
   impl   : impl;
   globs  : list (Symbol.sym * core_type * expr 'a);
   funs   : fun_map 'a;
 |>
*)
