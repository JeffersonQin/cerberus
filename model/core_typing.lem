open import Pervasives
import Map_extra

open import Global Errors
import Exception Loc

open import Core Core_aux
import Core_ctype Core_ctype_aux
module Cty = struct
  include Core_ctype
  include Core_ctype_aux
end


module E = struct
  type eff 'a = Exception.exceptM 'a Errors.core_typing_cause
  include Exception
  
  val mapMapM: forall 'k 'a 'b. MapKeyType 'k, SetType 'k, SetType 'a => ('a -> eff 'b) -> map 'k 'a -> eff (map 'k 'b)
  let mapMapM f xs =
    Map_extra.fold (fun k a acc ->
      bind (f a) (fun b ->
        bind acc (fun bs ->
          return (Map.insert k b bs)
        )
      )
    ) xs (return Map.empty)
  
  val runM: forall 'a. eff 'a -> Exception.exceptM 'a Errors.core_typing_cause
  let runM m = m
end

let inline (>>=)      = E.bind
let inline (>>) m1 m2 = m1 >>= fun _ -> m2
let inline (<$>)      = E.fmap
let inline (<*>)      = E.app




type typing_env =
    map Symbol.sym (either core_base_type (core_base_type * list core_base_type))



val     typeof_object_value: object_value -> E.eff core_object_type
let rec typeof_object_value oval =
  match oval with
   | OVinteger _ ->
       E.return OTy_integer
   | OVfloating _ ->
       E.return OTy_floating
   | OVpointer _ ->
       E.return OTy_pointer
   | OVcfunction _ ->
       E.return OTy_cfunction
   | OVarray [] ->
       E.fail EmptyArray
   | OVarray (oval'::ovals') ->
       typeof_object_value oval' >>= fun oTy ->
       E.mapM (fun oval ->
         typeof_object_value oval >>= fun oTy' ->
         if oTy <> oTy' then
           E.fail (HeterogenousArray oTy oTy')
         else
           E.return ()
       ) ovals' >>
       E.return (OTy_array oTy)
   | OVstruct tag_sym _ ->
       E.return (OTy_struct tag_sym)
(*
       E.foldlM (fun ((found_ident, mval), (expected_ident, expected_ty)) () ->
         if found_ident <> expected_ident then
           E.fail (InvalidMember tag_sym found_ident)
         else
           TODO
       ) () (List.zip xs (Cty.get_membersDefs tag_sym)) >>
       E.return (OTy_struct tag_sym)
*)
   | OVunion tag_sym _ _ ->
       E.return (OTy_union tag_sym)
  end


val     typeof_value: Core.value -> E.eff core_base_type
let rec typeof_value cval =
  match cval with
    | Vobject oval ->
        BTy_object <$> typeof_object_value oval
    | Vspecified oval ->
        BTy_loaded <$> typeof_object_value oval
    | Vunspecified ty ->
        E.return (BTy_loaded $ core_object_type_of_ctype ty)
    | Vunit ->
        E.return BTy_unit
    | Vtrue ->
        E.return BTy_boolean
    | Vfalse ->
        E.return BTy_boolean
    | Vctype _ ->
        E.return BTy_ctype
    | Vlist bTy cvals' ->
       E.mapM (fun cval ->
         typeof_value cval >>= fun bTy' ->
         if bTy <> bTy' then
           E.fail (HeterogenousList bTy bTy')
         else
           E.return ()
       ) cvals' >>
       E.return (BTy_list bTy)
    | Vtuple cvals ->
        BTy_tuple <$> E.mapM typeof_value cvals
  end



val     typecheck_pexpr: typing_env -> core_base_type -> pexpr -> E.eff typed_pexpr
let rec typecheck_pexpr env bTy (Pexpr () pexpr_) =
(*
  let expect bTy env pe =
    typecheck_pexpr env pe >>= fun (Pexpr bTy' _ as tpe) ->
    E.guard (bTy = bTy') (CoreTyping_TODO "mismatch") >>
    E.return tpe in
*)
  Pexpr bTy <$> match pexpr_ with
    | PEsym sym ->
        match Map.lookup sym env with
          | Just (Left bTy') ->
              E.guard (bTy = bTy') (CoreTyping_TODO "illtyped PEsym") >>
              E.return (PEsym sym)
          | Just (Right _) ->
              E.fail (CoreTyping_TODO "found a fun/proc symbolic in a PEsym")
          | Nothing ->
              E.fail (CoreTyping_TODO "unresolved PEsym")
        end
(*
    | PEimpl of Implementation_.implementation_constant (* implementation-defined constant *)
*)
    | PEval cval ->
        typeof_value cval >>= fun bTy' ->
        E.guard (bTy = bTy') (CoreTyping_TODO "illtyped value") >>
        E.return (PEval cval)
(*
    | PEconstrained of list (list Mem.mem_constraint2 * (generic_pexpr 'ty 'sym)) (* constrained value *)
*)
    | PEundef ub ->
        E.return (PEundef ub)
(*
    | PEerror str pe ->
        (* TODO need to check pe somehow ... *)
*)
(*
    | PEctor of (generic_ctor 'ty) * list (generic_pexpr 'ty 'sym) (* constructor application *)
    | PEcase of (generic_pexpr 'ty 'sym) * list ((generic_pattern 'ty 'sym) * (generic_pexpr 'ty 'sym)) (* pattern matching *)
    | PEarray_shift of (generic_pexpr 'ty 'sym) * ctype * (generic_pexpr 'ty 'sym) (* pointer array shift *)
    | PEmember_shift of (generic_pexpr 'ty 'sym) * Symbol.sym * Cabs.cabs_identifier (* pointer struct/union member shift *)
*)
    | PEnot pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEnot") >>
        (PEnot <$> typecheck_pexpr env BTy_boolean pe)
    | PEop bop pe1 pe2 ->
        (* TODO: this is going to give horrible error messages ... *)
        E.trysM (CoreTyping_TODO "PEop") (fun (bTy', bTy1, bTy2) ->
          E.guard (bTy = bTy') (CoreTyping_TODO "PEop bTy") >>
          (PEop bop <$> typecheck_pexpr env bTy1 pe1
                    <*> typecheck_pexpr env bTy2 pe2)
        ) match bop with
          | OpAdd ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpSub ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpMul ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpDiv ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_object OTy_floating, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpRem_t ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpRem_f ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpExp ->
              [ (BTy_object OTy_integer, BTy_object OTy_integer, BTy_object OTy_integer) ]
          | OpEq ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating)
              ; (BTy_boolean, BTy_ctype, BTy_ctype) ]
          | OpGt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLt ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpGe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpLe ->
              [ (BTy_boolean, BTy_object OTy_integer, BTy_object OTy_integer)
              ; (BTy_boolean, BTy_object OTy_floating, BTy_object OTy_floating) ]
          | OpAnd ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
          | OpOr ->
              [ (BTy_boolean, BTy_boolean, BTy_boolean) ]
        end

(*
    | PEstruct of Symbol.sym * list (Cabs.cabs_identifier * (generic_pexpr 'ty 'sym)) (* C struct expression *)
    | PEunion of Symbol.sym * Cabs.cabs_identifier * (generic_pexpr 'ty 'sym) (* C union expression *)
    | PEcall of (generic_name 'sym) * list (generic_pexpr 'ty 'sym) (* pure Core function call *)
    | PElet of (generic_pattern 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) (* pure Core let *)
*)
    | PEif pe1 pe2 pe3 ->
        PEif <$> typecheck_pexpr env BTy_boolean pe1
             <*> typecheck_pexpr env bTy pe2
             <*> typecheck_pexpr env bTy pe3
    | PEis_scalar pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_scalar") >>
        (PEis_scalar <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_integer pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_integer") >>
        (PEis_integer <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_signed pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_signed") >>
        (PEis_signed <$> typecheck_pexpr env BTy_ctype pe)
    | PEis_unsigned pe ->
        E.guard (bTy = BTy_boolean) (CoreTyping_TODO "PEis_unsigned") >>
        (PEis_unsigned <$> typecheck_pexpr env BTy_ctype pe)
  end

val     typecheck_expr: typing_env -> core_base_type -> Core.expr unit -> E.eff (Core.typed_expr unit)
let rec typecheck_expr env bTy = function
 | Epure pe ->
     Epure <$> typecheck_pexpr env bTy pe
(*
 | Ememop of Mem_common.memop * list (generic_pexpr 'ty 'sym) (* pointer op involving memory *)
 | Eaction of (generic_paction 'a 'ty 'sym) (* memory action *)
 | Ecase of (generic_pexpr 'ty 'sym) * list ((generic_pattern 'ty 'sym) * (generic_expr 'a 'ty 'sym)) (* pattern matching *)
 | Elet of (generic_pattern 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_expr 'a 'ty 'sym) (* Core let *)
*)
 | Eif pe1 e2 e3 ->
     Eif <$> typecheck_pexpr env BTy_boolean pe1
         <*> typecheck_expr env bTy e2
         <*> typecheck_expr env bTy e3
 | Eskip ->
     E.guard (bTy = BTy_unit) (CoreTyping_TODO "Eskip") >>
     E.return Eskip
(*
 | Eproc of 'a * (generic_pexpr 'ty 'sym) * list (generic_pexpr 'ty 'sym) (* Core procedure call *)
*)
 | Ereturn pe ->
     Ereturn <$> typecheck_pexpr env bTy pe

(*
 | Eunseq of list (generic_expr 'a 'ty 'sym) (* unsequenced expressions *)
 | Ewseq of (generic_pattern 'ty 'sym) * (generic_expr 'a 'ty 'sym) * (generic_expr 'a 'ty 'sym) (* weak sequencing *)
 | Esseq of (generic_pattern 'ty 'sym) * (generic_expr 'a 'ty 'sym) * (generic_expr 'a 'ty 'sym) (* strong sequencing *)
 | Easeq of maybe ('sym * core_base_type) * (generic_action 'a 'ty 'sym) * (generic_paction 'a 'ty 'sym) (* atomic sequencing *)
 | Eindet of nat * (generic_expr 'a 'ty 'sym) (* indeterminately sequenced expr *)
 | Ebound of nat * (generic_expr 'a 'ty 'sym) (* $\ldots$and boundary *)
 | End of list (generic_expr 'a 'ty 'sym) (* nondeterministic sequencing *)
 | Esave of Symbol.sym * list (Symbol.sym * ctype) * (generic_expr 'a 'ty 'sym) (* save label *)
 | Erun of 'a * Symbol.sym * list (Symbol.sym * (generic_pexpr 'ty 'sym)) (* run from label *)
 | Epar of list (generic_expr 'a 'ty 'sym) (* cppmem thread creation *)
 | Ewait of Thread.thread_id (* wait for thread termination *)
*)
  | Eloc _ e ->
      typecheck_expr env bTy e
end





(*
val fold : forall 'k 'v 'r. MapKeyType 'k, SetType 'k, SetType 'v => ('k -> 'v -> 'r -> 'r) -> map 'k 'v -> 'r -> 'r
*)


(* TODO: add a check for the existence of main *)
val typecheck_program: Core.file unit -> Exception.exceptM (Core.typed_file unit) Errors.t
let typecheck_program file =
  let aux =
    (* The startup function/procedure must be defined *)
    E.guard (Map.member file.main file.funs) (Undefined_startup file.main) >>
    
    (* Register the functions/procedures from the stdlib *)
    let env = (*TODO*)Map.empty in
    
    E.mapMapM (function
      | Fun bTy sym_bTys pe ->
          let env' = List.foldr (fun (sym, bTy) acc -> Map.insert sym (Left bTy) acc) env sym_bTys in
          Fun bTy sym_bTys <$> typecheck_pexpr env' bTy pe
      | Proc bTy sym_bTys e ->
          let env' = List.foldr (fun (sym, bTy) acc -> Map.insert sym (Left bTy) acc) env sym_bTys in
          Proc bTy sym_bTys <$> typecheck_expr env' bTy e
    end) file.stdlib >>= fun stdlib' ->

    
    E.mapM (fun (sym, bTy, e) ->
      typecheck_expr env bTy e >>= fun te ->
      E.return (sym, bTy, te)
    ) file.globs >>= fun globs' ->
    
    
    let impl' = Map.empty in
    let funs' = Map.empty in
    
    E.return <| main= file.main; stdlib= stdlib'; impl= impl'; globs= globs'; funs= funs' |>
  in
  match E.runM aux with
    | Exception.Result file' ->
        Exception.return file'
    | Exception.Exception cause ->
        Exception.Exception (Loc.unknown, Errors.Core_typing_cause cause)
  end
(*
 type file 'a = <|
   main   : Symbol.sym;
   stdlib : fun_map 'a;
   impl   : impl;
   globs  : list (Symbol.sym * core_type * expr 'a);
   funs   : fun_map 'a;
 |>
*)
