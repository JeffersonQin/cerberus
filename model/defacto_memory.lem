(* De-facto C11 memory model *)
open import Core_ctype


(* Semantic switches *)
type mode =
  | Mode_ISO
    (* the bools are: "-no-strict-aliasing", multiple-provenance,
       pointer-lifetime-zap *)
  | Mode_Defacto of bool * bool * bool


(* Basic representation: 
   
     assuming 8-bit bytes and two's complement arithmetic.
 *)



type provenance_id = allocation_id

type provenance =
  | Prov_wildcard
  | Prov_none
  | Prov_some of set provenance_id (* INVARIANT: non empty set *)


type address = Symbolic.symbolic (* a normal symbolic expression that will resolve to a number, maybe with disjointness and adjacency constraints (kept elsewhere) *)

(* we don't flatten out nested structs/unions in shift_path's; they just appear as SPE_member with the struct/union type. *)
type shift_path_element = 
  | SPE_member of ctype * integer (*TODO: bring back symbolic *)
  | SPE_post_padding of Symbol.t (*struct/union tag*) * Cabs.cabs_identifier (*member*) 

type shift_path = list shift_path_element


type pointer_value_aux =
  | PVnull of ctype  
     (* the lvalue type of the pointer object we stored a NULL to *) 
     (*always with Prov_none *)
  | PVbase of allocation_id  
     (* the result of a dynamic or automatic/static/thread-local allocation *)
     (* generated (and perhaps always?) with Prov_some with the singleton set of its allocation_id  *)
  | PVshift of pointer_value_aux * shift_path
     (* shift_path used to be a list of (ctype,int) pairs.  
        now the int should be the naive_memory.lem integer_value 
*)
  | PVfromint of integer_value (* never a null pointer *)

(* in memory-value, kayvan wants byte-n-of-memory-value too *)

type pointer_value =
  provenance * pointer_value_aux


type integer_value_aux =
  | IVconcrete of Symbolic.symbolic
  | IVfromptr of pointer_value_aux
  | IVop of ivop * list integer_value_aux

type integer_value =
  provenance * integer_value_aux



(* TODO: split it *)
type allocation = <|
  is_dynamic: bool;
  allocated_type: maybe ctype; (* only for static *)
  address: address_id;
|>


type memory_state = <|
  allocations: map allocation_id allocation;
  allocation_constaints: something; (* might need to be in driver_state *)
  
|>


(* API *)
val ptr_eq: pointer_value -> pointer_value -> memM bool
val ptr_add: pointer_value -> integer_value -> memM pointer_value
val ptr_diff: pointer_value -> pointer_value -> memM integer_value
val ptr_fromint: integer_value -> memM pointer_value (* cast from scalar to pointer value *)


(* TODO: is it unclear how to decide if ptr_diff in intra or inter object *)






(*

int *p, *q;

*(unsigned char* )&q = *((unsigned char* )&p);
(unsigned char* )q[1] = (unsigned char* )p[1];
(unsigned char* )q[2] = (unsigned char* )p[2];
(unsigned char* )q[3] = (unsigned char* )p[3];







*)


(*

STATIC_ALLOCATION:

  * gen a provenance_id
  * return the singleton of provenance_id
  
 





*)
