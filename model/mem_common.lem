(* Concrete types and functions common to all memory layout models *)
open import Pervasives
import Loc
import Undefined

open import Nondeterminism



type access_kind =
  | LoadAccess
  | StoreAccess

type access_error =
  | NullPtr
  | FunctionPtr
  | DeadPtr
  | OutOfBoundPtr
  | NoProvPtr


let stringFromAccess_error = function
  | NullPtr ->
      "NullPtr"
  | FunctionPtr ->
      "FunctionPtr"
  | DeadPtr ->
      "DeadPtr"
  | OutOfBoundPtr ->
      "OutOfBoundPtr"
  | NoProvPtr ->
      "NoProvPtr"
end

type mem_error =
  | MerrOutsideLifetime of string (* mem_read_request *)
  | MerrInternal of string
  | MerrOther of string
  
  | MerrPtrdiff
  | MerrAccess of Loc.t * access_kind * access_error
  | MerrWriteOnReadOnly of Loc.t
  
  | MerrIntFromPtr
  
  | MerrWIP of string

instance (Show mem_error)
  let show = function
    | MerrOutsideLifetime str ->
        "MerrOutsideLifetime \"" ^  str ^ "\""
    | MerrInternal str ->
        "MerrInternal \"" ^  str ^ "\""
    | MerrOther str ->
        "MerrOther \"" ^  str ^ "\""
    | MerrWIP str ->
        "Memory WIP: " ^ str
    | MerrPtrdiff ->
        "MerrPtrdiff"
    | MerrAccess loc LoadAccess err ->
        "MerrAccess Load [" ^ Loc.stringFromLocation loc ^ "] " ^
        stringFromAccess_error err
    | MerrWriteOnReadOnly loc ->
        "MerrWriteOnReadOnly [" ^ Loc.stringFromLocation loc ^ "]"
    | MerrAccess loc StoreAccess err ->
        "MerrAccess Store [" ^ Loc.stringFromLocation loc ^ "] " ^
        stringFromAccess_error err
    | MerrIntFromPtr ->
        "MerrIntFromPtr"
  end
end


let undefinedFromMem_error = function
  | MerrOutsideLifetime _ ->
      Just [Undefined.UB009_outside_lifetime]
  | MerrPtrdiff ->
      Just [Undefined.UB048_disjoint_array_pointers_substraction]
  | MerrAccess _ _ NullPtr ->
      Just [Undefined.UB019_lvalue_not_an_object]
  | MerrAccess _ _ DeadPtr ->
      Just [Undefined.UB010_pointer_to_dead_object]
  | MerrIntFromPtr ->
      Just [Undefined.UB024_out_of_range_pointer_to_integer_conversion]
  | MerrWriteOnReadOnly _ ->
      (* TODO *)
      Nothing
  | _ ->
      Nothing
end







type integer_operator =
  | IntAdd
  | IntSub
  | IntMul
  | IntDiv
  | IntRem_t (* truncating remainder (this is % of C) *)
  | IntRem_f (* flooring remainder *)
  | IntExp

type floating_operator =
  | FloatAdd
  | FloatSub
  | FloatMul
  | FloatDiv


type pure_memop =
  | PURE_MEMOP_TODO

type memop =
  | PtrEq
  | PtrNe
  | PtrLt
  | PtrGt
  | PtrLe
  | PtrGe
(*  | PtrIsNull *)
  
  | Ptrdiff     (* (address, address) -> eff integer *)
  | IntFromPtr  (* (ctype, ctype, address) -> eff integer *) (* first type is that of the referenced type, second on is type of integer *)
  | PtrFromInt  (* (ctype, ctype, integer) -> eff address *) (* first type is that of integer, second on is type of reference *)
  | PtrValidForDeref (* address -> eff boolean *)
  
  | PtrWellAligned (* (ctype, address) -> eff boolean *)
  
  | Memcpy
  | Memcmp
  | Realloc (* TODO: not sure about this *)


instance (Show memop)
  let show = function
    | PtrEq ->
        "ptreq"
    | PtrNe ->
        "ptrne"
    | PtrLt ->
        "ptrlt"
    | PtrGt ->
        "ptrgt"
    | PtrLe ->
        "ptrle"
    | PtrGe ->
        "ptrge"
    | Ptrdiff ->
        "ptrdiff"
    | IntFromPtr ->
        "intfromptr"
    | PtrFromInt ->
        "ptrfromint"
    | PtrValidForDeref ->
        "ptrvalidforderef"
    | PtrWellAligned ->
        "ptrwellaligned"
    | Memcpy ->
        "memcpy"
    | Memcmp ->
        "memcmp"
    | Realloc ->
        "realloc"
  end
end



let stringFromInteger_operator = function
  | IntAdd ->
      "IntAdd"
  | IntSub ->
      "IntSub"
  | IntMul ->
      "IntMul"
  | IntDiv ->
      "IntDiv"
  | IntRem_t ->
      "IntRem_t"
  | IntRem_f ->
      "IntRem_f"
  | IntExp ->
      "IntExp"
end


let stringFromFloating_operator = function
  | FloatAdd -> "FloatAdd"
  | FloatSub -> "FloatSub"
  | FloatMul -> "FloatMul"
  | FloatDiv -> "FloatDiv"
end


type mem_constraint 'a =
  | MC_empty
  | MC_eq of 'a * 'a
  | MC_le of 'a * 'a
  | MC_lt of 'a * 'a
  
  | MC_in_device of 'a
  
  | MC_or of mem_constraint 'a * mem_constraint 'a
  | MC_conj of list (mem_constraint 'a)
  | MC_not of mem_constraint 'a

instance forall 'a. (Constraints mem_constraint 'a)
  let empty = MC_empty
  let negate cs = MC_not cs
  let concat cs1 cs2 = MC_conj [cs1; cs2]
end




(*


type pointer_shift =
(* TODO: bring back symbols *)
(*  list (Core_ctype.ctype * Symbolic.symbolic) *)
  list (Core_ctype.ctype * integer)


type pointer_value =
  | PVnull of Core_ctype.ctype
  | PVobject of object_id * pointer_shift
  | PVfunction of Symbol.t


type integer_value_operator =
  | IntAdd
  | IntSub
  | IntMul
  | IntDiv
  | IntMod
  | IntExp

type integer_value =
  | IVinteger of integer
  | IVsymbolic of Symbolic.symbolic (* possibly-symbolic integer value *)
  | IVptrdiff of pointer_value * pointer_value
  | IVintptr of pointer_value
  | IVop of integer_value_operator * integer_value * integer_value


type mem_value =
  | MVunspecified of Core_ctype.ctype (* this should only be used for base and union types *)
  | MVinteger of integer_value
  | MVfloating of string
  | MVpointer of pointer_value
  | MVarray of list mem_value (* TODO: list (maybe mem_value) *)
  | MVstruct of Symbol.t * list (Cabs.cabs_identifier * mem_value)
  | MVunion of Symbol.t * Cabs.cabs_identifier * mem_value (* the symbols are respectively the tag and the member *)


*)


type memory_flags = <|
  allow_multi_provenance: bool; (* allow Prov_some aids, where aids is not a singleton *)
  
|>


type memory_flag =
  | Allow_disjoint_alloc_tests (* allow (for example) pointer equality between different objects *)
