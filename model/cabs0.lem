(* AST type used by Jacques-Henri Jourdan's parser *)
open import Pervasives

type atom = string

(* Context information. *)
type cabsloc_ (* TODO(Hack): there should be another way *)
declare ocaml target_rep type cabsloc_ = `Lexing.position`
type cabsloc = cabsloc_ (* Location.t *)

(* ยง6.7.2 #1 *)
type type_specifier = (* Merge all specifiers into one type *)
  | T_void
  | T_char
  | T_short
  | T_int
  | T_long
  | T_float
  | T_double
  | T_signed
  | T_unsigned
  | T_Bool
(*  | T_Complex *)
  | T_atomic of(list spec_elem * decl_type)
  (* each of the following three kinds of specifiers contains a field
   * or list item iff it corresponds to a definition (as opposed to
   * a forward declaration or simple reference to the type).
   * They also have a list of __attribute__s that appeared between the
   * keyword and the type name (definitions only) *)
  | T_struct of maybe atom * maybe (list field_group) * list attribute
  | T_union of maybe atom * maybe (list field_group) * list attribute
  | T_enum of maybe atom * maybe (list (atom * maybe expression * cabsloc)) * list attribute
  
  | T_named of atom

(* ยง6.7.1 #1 *)
and storage_class_specifier =
  | SC_typedef
  | SC_extern
  | SC_static
  | SC_Thread_local
  | SC_auto
  | SC_register

and type_qualifier =
  | Q_const
  | Q_restrict
  | Q_volatile
  | Q_Atomic

(* Type specifier elements. These appear at the start of a declaration *)
(* Everywhere they appear in this file, they appear as a 'list spec_elem', *)
(* which is not interpreted by cabs -- rather, this "word soup" is passed *)
(* on to the compiler.  Thus, we can represent e.g. 'int long float x' even *)
(* though the compiler will of course choke. *)
and spec_elem =
  | SpecQualifier of type_qualifier
  | SpecAttr of attribute
  | SpecStorage of storage_class_specifier
  | SpecInline
  | SpecType of type_specifier

(* Declarator type. They modify the base type given in the specifier. Keep
 * them in the order as they are printed (this means that the top level
 * constructor for ARRAY and PTR is the inner-level in the meaning of the
 * declared type) *)
and decl_type =
 | JUSTBASE
 | ARRAY of decl_type * list type_qualifier * list attribute * maybe expression
 | PTR of list type_qualifier * list attribute * decl_type
(* The bool is true for variable length parameters. *)
 | PROTO of decl_type * (list parameter * bool)

and parameter =
  | PARAM of list spec_elem * maybe atom * decl_type * list attribute * cabsloc

(* The optional expression is the bitfield *)
and field_group =
  | Field_group of list spec_elem * list (maybe name * maybe expression) * cabsloc

(* The decl_type is in the order in which they are printed. Only the name of
 * the declared identifier is pulled out. *)
(* e.g: in "int *x", "*x" is the declarator; "x" will be pulled out as *)
(* the atom, and decl_type will be PTR([], JUSTBASE) *)
and name =
  | Name of atom * decl_type * list attribute * cabsloc

(* A variable declarator ("name") with an initializer *)
and init_name =
  | Init_name of name * init_expression

(*
** Expressions
*)
and binary_operator =
  | Add | Sub | Mul | Div | Mod
  | And | Or
  | Band | Bor | Xor | Shl | Shr
  | Eq | Ne | Lt | Gt | Le | Ge
  | Assign
  | Add_assign | Sub_assign | Mul_assign | Div_assign | Mod_assign
  | Band_assign | Bor_assign | Xor_assign | Shl_assign | Shr_assign
  | Comma

and unary_operator =
  | Minus | Plus | Not | Bnot | Indirection | Address
  | PrefixIncr | PrefixDecr | PostfixIncr | PostfixDecr

and expression =
  | Eunary of unary_operator * expression
  | Ebinary of binary_operator * expression * expression
  | Econditional of expression * expression * expression

    (* A CAST can actually be a constructor expression *)
  | Ecast of (list spec_elem * decl_type) * init_expression

(*
  | C11_ATOMIC_INIT of expression * expression
  | C11_ATOMIC_STORE of expression * expression * expression
  | C11_ATOMIC_LOAD of expression * expression
  | C11_ATOMIC_EXCHANGE of expression * expression * expression
  | C11_ATOMIC_COMPARE_EXCHANGE_STRONG of expression * expression * expression * expression * expression
  | C11_ATOMIC_COMPARE_EXCHANGE_WEAK of expression * expression * expression * expression * expression
  | C11_ATOMIC_FETCH_KEY of expression * expression * expression
*)

  | Ecall of expression * list expression
(*  | BUILTIN_VA_ARG of expression * (list spec_elem * decl_type) *)
  | Econstant of constant
  | Evariable of atom
  | Eexpr_sizeof of expression
  | Etype_sizeof of (list spec_elem * decl_type)
  | Ealignof of (list spec_elem * decl_type)
  | Esubscript of expression * expression
  | Ememberof of expression * atom
  | Ememberofptr of expression * atom
  | Eoffsetof of (list spec_elem * decl_type) * atom

and integer_suffix =
  | SUFFIX_UNSIGNED
  | SUFFIX_UNSIGNED_LONG
  | SUFFIX_UNSIGNED_LONG_LONG
  | SUFFIX_LONG
  | SUFFIX_LONG_LONG

and character_prefix =
  | PREFIX_L
  | PREFIX_u
  | PREFIX_U

and encoding_prefix =
  | ENCODING_u8
  | ENCODING_u
  | ENCODING_U
  | ENCODING_L

and constant =
  (* The atom is the textual representation of the constant in
     the source code. It does include quotes. *)
  | CONST_INT of atom * maybe integer_suffix
  | CONST_FLOAT of atom
  | CONST_CHAR of maybe character_prefix * atom
  | CONST_STRING of atom (* TODO *)

and init_expression =
  | NO_INIT
  | SINGLE_INIT of expression
  | COMPOUND_INIT of list (list initwhat * init_expression)

and initwhat =
  | INFIELD_INIT of atom
  | ATINDEX_INIT of expression

and attribute =
  | ATTR of atom * list expression

(* like name_group, except the declared variables are allowed to have initializers *)
(* e.g.: int x=1, y=2; *)
type init_name_group = (list spec_elem * list init_name)

(* The base type and the storage are common to all names. Each name might
 * contain type or storage modifiers *)
(* e.g.: int x, y; *)
type name_group = (list spec_elem * list name)

(*
** Declaration definition (at toplevel)
*)
type definition =
 | FUNDEF of list spec_elem * name * statement * cabsloc
 | DECDEF of init_name_group * cabsloc  (* global variable(s), or function prototype *)
 | PRAGMA of atom * cabsloc

(*
** statements
*)

and statement =
 | Sskip of cabsloc
 | Sexpression of expression * cabsloc
 | Sblock of list statement * cabsloc
 | Sif of expression * statement * maybe statement * cabsloc
 | Swhile of expression * statement * cabsloc
 | Sdo of expression * statement * cabsloc
 | Sfor of maybe for_clause * maybe expression * maybe expression * statement * cabsloc
 | Sbreak of cabsloc
 | Scontinue of cabsloc
 | Sreturn of maybe expression * cabsloc
 | Sswitch of expression * statement * cabsloc
 | Scase of expression * statement * cabsloc
 | Sdefault of statement * cabsloc
 | Slabel of atom * statement * cabsloc
 | Sgoto of atom * cabsloc
 | Sdefinition of definition (*definition or declaration of a variable or type*)
 | Spar of list statement * cabsloc

and for_clause =
 | FC_EXP of expression
 | FC_DECL of definition


(* list of toplevel definitions *)
type file = list definition
