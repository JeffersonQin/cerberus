(*
open import Pervasives String_extra Show
open import List Function
open import Utils
import Debug Dlist Constraints Symbolic Undefined Loc

import Global

import UniqueId
*)

open import Pervasives
open import Utils Debug
import Undefined



(* Cause of an execution path termination *)
type kill_reason 'err =
  | Undef of Loc.t * list Undefined.undefined_behaviour
  | Error of Loc.t * string
  | Other of 'err


class (Constraints 'a)
  val empty: 'a
  val negate: 'a -> 'a
  val concat: 'a -> 'a -> 'a
end

(* HACK *)
instance (Constraints unit)
  let empty = ()
  let negate x = ()
  let concat x y = ()
end


type nd_action 'a 'st 'err 'cs =
  | NDactive of 'a
  | NDkilled of kill_reason 'err
  | NDnd of string * 'st * list (nd_action 'a 'st 'err 'cs)
  | NDguard of string * 'cs * nd_action 'a 'st 'err 'cs
  | NDbranch of string * 'st * 'cs * nd_action 'a 'st 'err 'cs * nd_action 'a 'st 'err 'cs


val     nd_action_bind: forall 'a 'b 'st 'err 'cs. nd_action 'a 'st 'err 'cs -> ('a -> nd_action 'b 'st 'err 'cs) -> nd_action 'b 'st 'err 'cs
let rec nd_action_bind act f =
  match act with
    | NDactive z ->
        f z
    | NDkilled r ->
        NDkilled r
    | NDnd debug_str st acts ->
        NDnd debug_str st (List.map (fun z -> nd_action_bind z f) acts)
    | NDguard debug_str cs act' ->
        NDguard debug_str cs (nd_action_bind act' f)
    | NDbranch debug_str st cs act1 act2 ->
        NDbranch debug_str st cs (nd_action_bind act1 f) (nd_action_bind act2 f)
  end


type ndM 'a 'err 'cs 'st =
  ND of ('st -> nd_action ('a * 'st) 'st 'err 'cs)


(* Monadic operations *)
val return: forall 'a 'err 'cs 'st. 'a -> ndM 'a 'err 'cs 'st
val bind:   forall 'a 'b 'err 'cs 'st. ndM 'a 'err 'cs 'st -> ('a -> ndM 'b 'err 'cs 'st) -> ndM 'b 'err 'cs 'st

let nd_return a =
  ND (fun st -> NDactive (a, st))
let inline return = nd_return

let bind (ND m) f =
  ND (fun st ->
    nd_action_bind (m st) (fun (a, st') ->
      let ND b = (f a) in b st'
    )
  )







(* State operations *)
val get: forall 'err 'cs 'st. ndM 'st 'err 'cs 'st
val put: forall 'err 'cs 'st. 'st -> ndM unit 'err 'cs 'st
val update: forall 'err 'cs 'st. ('st -> 'st) -> ndM unit 'err 'cs 'st
val read: forall 'a 'err 'cs 'st. ('st -> 'a) -> ndM 'a 'err 'cs 'st

let get =
  ND (fun st -> NDactive (st, st))

let put st =
  ND (fun _ -> NDactive ((), st))

let update f =
  ND (fun st -> NDactive ((), f st))

let read f=
  ND (fun st -> NDactive (f st, st))



let inline (>>=) = bind

val bindExhaustive: forall 'a 'b 'err 'cs 'st. ndM 'a 'err 'cs 'st -> ('a -> ndM 'b 'err 'cs 'st) -> ndM 'b 'err 'cs 'st
let bindExhaustive m f =
  let () = Debug.print_debug 1 [] (fun () ->
    "ND2.bindExhaustive is wrong"
  ) in
  bind m f (* error "ND2.bindExhaustive" *)



val kill: forall 'a 'err 'cs 'st. kill_reason 'err -> ndM 'a 'err 'cs 'st
let kill r =
  ND (fun st -> NDkilled r)

val log: forall 'err 'cs 'st. string -> ndM unit 'err 'cs 'st
let log msg =
  error "ND2.log"


val print_debug: forall 'err 'cs 'st. nat -> list Debug.domain -> (unit -> string) -> ndM unit 'err 'cs 'st
let print_debug level doms msg =
  return (Debug.print_debug level doms msg)



(* MonadPlus operations *)
(* val mzero: forall 'a 'err 'cs 'st. ndM 'a 'err 'cs 'st *)
val mplus: forall 'a 'err 'cs 'st. ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st

(*
let mzero =
  error ""
*)

let mplus m1 m2 =
  error "ND2.mplus"


val msum: forall 'a 'err 'cs 'st. Constraints 'cs => string -> list (ndM 'a 'err 'cs 'st) -> ndM 'a 'err 'cs 'st (* GENERIC MonadPlus *)
let msum debug_str = function
  | [] ->
      error "ND2.msum []"
  | [m] ->
      m
  | ms ->
    let () = Debug.print_debug 1 [] (fun () ->
      "ND2.msum (|ms| = " ^ show (List.length ms) ^ ")"
    ) in
    ND (fun st ->
      NDnd debug_str st (List.map (fun (ND m) -> m st) ms)
    )
end
(*
let msum debug_str = function
  | [] ->
      error "ND2.msum []"
  | (ND m0 :: ms) ->
        List.foldl (fun acc (ND m) ->
          NDbranch empty acc (m st)
        ) (m0 st) ms
      )
end
*)

(* GENERIC Monad *)
let sequence_ ms = foldr (fun m1 m2 -> bind m1 (fun _ -> m2)) (return ()) ms

(* GENERIC Monad *)
val mapM_: forall 'a 'b 'err 'cs 'st. ('a -> ndM 'b 'err 'cs 'st) -> list 'a -> ndM unit 'err 'cs 'st
let mapM_ f _as = sequence_ (List.map f _as)


(* NOTE: this is foldl *)
val     foldM: forall 'a 'b 'err 'cs 'st. ('a -> 'b -> ndM 'a 'err 'cs 'st) -> 'a -> list 'b -> ndM 'a 'err 'cs 'st (* GENERIC Monad *)
let rec foldM f a = function                                                 (* GENERIC Monad *)
  | [] ->                                                                    (* GENERIC Monad *)
      return a                                                               (* GENERIC Monad *)
  | x::xs ->                                                                 (* GENERIC Monad *)
      f a x >>= fun fax -> foldM f fax xs                                    (* GENERIC Monad *)
end




(* Non-deterministically pick from a list *)
val pick: forall 'a 'err 'cs 'st. Constraints 'cs => string -> list 'a -> ndM 'a 'err 'cs 'st
let pick debug_str = function
  | [] ->
      error ("ND2.pick(" ^ debug_str ^ "), empty list")
  | [x] ->
      ND (fun st ->
        NDactive (x, st)
      )
  | x::xs ->
      let () = Debug.print_debug 1 [] (fun () ->
        "ND2.pick (|ms| = " ^ show (List.length (x::xs)) ^ ")"
      ) in
      ND (fun st ->
        let f z = NDactive (z, st) in
        NDnd debug_str st (f x :: List.map f xs)
(*
        List.foldl (fun acc x' -> NDbranch empty acc (NDactive (x', st))) (NDactive (x, st)) xs
*)
      )
end


val ifM: forall 'a 'err 'cs 'st. string -> 'cs -> ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st -> ndM 'a 'err 'cs 'st
let ifM debug_str cs (ND mThen) (ND mElse) =
  ND (fun st ->
    NDbranch debug_str st cs (mThen st) (mElse st)
  )



(* NOTE: this seems to only be used by the concurrency *)
val mem : forall 'a 'err 'cs 'st. Eq 'a => 'a -> ndM 'a 'err 'cs 'st -> bool
let mem x m =
  error "ND2.mem"



val guard: forall 'err 'cs 'st. bool -> kill_reason 'err -> ndM unit 'err 'cs 'st
let guard b reason =
  if b then return () else kill reason



let warns_if_no_active_ex m =
  error "ND2.warns_if_no_active_ex"




val addConstraints: forall 'err 'cs 'st. string -> 'cs -> ndM unit 'err 'cs 'st
let addConstraints debug_str cs =
  ND (fun st ->
    NDguard debug_str cs (NDactive ((), st))
  )



let rec liftAction liftErr mk_st' = function
  | NDactive (a, st) ->
      NDactive (a, mk_st' st)
  | NDkilled r ->
      NDkilled match r with
        | Undef loc ubs ->
            Undef loc ubs
        | Error loc str ->
            Error loc str
        | Other err ->
            Other (liftErr err)
      end
  | NDnd debug_str st acts ->
      NDnd debug_str (mk_st' st) (List.map (liftAction liftErr mk_st') acts)
  | NDguard debug_str cs act ->
      NDguard debug_str cs (liftAction liftErr mk_st' act)
  | NDbranch debug_str st cs act1 act2 ->
      NDbranch debug_str (mk_st' st) cs (liftAction liftErr mk_st' act1) (liftAction liftErr mk_st' act2)
end

val liftND: forall 'a 'err1 'err2 'cs 'st1 'st2.
  ('st2 -> 'st1) ->
  ('st2 -> 'st1 -> 'st2) ->
  ('err1 -> 'err2) ->
  ndM 'a 'err1 'cs 'st1 -> ndM 'a 'err2 'cs 'st2
let liftND get put liftErr (ND m) =
  ND (fun st2 ->
    let act = m (get st2) in
    liftAction liftErr (put st2) act
  )







type nd_status 'a 'err =
  | Active of 'a
  | Killed of kill_reason 'err

(*

used by: wipFrontend, 

*)




(*
open import {hol} `utilTheory`

val stringFromConstraints: Constraints.old_constraints -> string
declare ocaml target_rep function stringFromConstraints = `Pp_constraints.pp_old_constraints`
declare hol   target_rep function stringFromConstraints = `util$emptyString`


type kill_reason 'err =
  | Undef of Loc.t * list Undefined.undefined_behaviour
  | Error of Loc.t * string
  | Other of 'err

instance forall 'err. Show 'err => (Show (kill_reason 'err))
  let show reason = 
    match reason with
    | Undef loc l     -> "Undef ([" ^ Loc.stringFromLocation loc ^ "]" ^ show l ^ ")"
    | Error loc s -> "Error ([" ^ Loc.stringFromLocation loc ^ "] " ^ show s ^ ")"
    | Other err     -> "Other (" ^ show err ^ ")"
    end
end


type nd_status 'err 'a =
  | Active of 'a
  | Killed of kill_reason 'err

type nd_state = <|
  eqs: Constraints.old_constraints;
  log: Dlist.dlist string
|>

val initial_nd_state: nd_state
let initial_nd_state =
  <| eqs= Constraints.empty; log= Dlist.nil |>



type ndM 'err 'st 'a =
  ND of (('st * nd_state) -> list (nd_status 'err 'a * ('st * nd_state)))
*)
