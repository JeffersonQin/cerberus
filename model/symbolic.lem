open import Pervasives
import Symbol

(* TODO: tmp *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`
declare coq   target_rep function assert_false = `DAEMON`



type operator =
  | Add
  | Sub
  | Mul
  | Div
  | Mod
  | Exp
  | Eq
  | Neq
  | Lt
  | And
  | Or

instance (Eq operator)
  let (=) = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

instance (Show operator)
  let show op = 
    match op with
    | Add -> "Add"
    | Sub -> "Sub"
    | Mul -> "Mul"
    | Div -> "Div"
    | Mod -> "Mod"
    | Exp -> "Exp"
    | Eq  -> "Eq"
    | Neq -> "Neq"
    | Lt  -> "Lt"
    | And -> "And"
    | Or  -> "Or"
    end
end

type symbolic_type =
  | SYMBint
  | SYMBbool

type symbolic =
  | SYMBtrue
  | SYMBfalse
  | SYMBconst of integer
  | SYMBsym   of symbolic_type * Symbol.t
  | SYMBop    of operator * symbolic * symbolic
  | SYMBite   of symbolic * symbolic * symbolic




instance (Eq symbolic_type)
  let (=) = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end


let rec symbolicEqual symb1 symb2 =
  let ord = function
    | SYMBtrue ->
        (0 : nat)
    | SYMBfalse ->
        1
    | SYMBconst _ ->
        2
    | SYMBsym _ _ ->
        3
    | SYMBop _ _ _ ->
        4
    | SYMBite _ _ _ ->
        5
  end in
  match (symb1, symb2) with
    | (SYMBconst n1, SYMBconst n2) ->
        n1 = n2
    | (SYMBsym symbty1 sym1, SYMBsym symbty2 sym2) ->
        symbty1 = symbty2 && sym1 = sym2
    | (SYMBop op1 symb11 symb12, SYMBop op2 symb21 symb22) ->
        op1 = op2 && symbolicEqual symb11 symb21 && symbolicEqual symb12 symb22
    | (SYMBite symb11 symb12 symb13, SYMBite symb21 symb22 symb23) ->
        symbolicEqual symb11 symb21 && symbolicEqual symb12 symb22 && symbolicEqual symb13 symb23
    | _ ->
        ord symb1 = ord symb2
  end

instance (Eq symbolic)
  let (=)  = symbolicEqual
  let (<>) = fun symb1 symb2 -> not (symbolicEqual symb1 symb2)
end

val symbolic_to_string: symbolic -> string
let rec symbolic_to_string sym =
  match sym with
  | SYMBconst i -> "Constant (" ^ show i ^ ")" 
  | SYMBsym ty t -> "Symbol (TODO, " ^ show t ^ ")"
  | SYMBop op sym1 sym2 -> 
      "Op (" ^ show op ^ " " ^ symbolic_to_string sym1 ^ " " ^ symbolic_to_string sym2 ^ ")"
  end

instance (Show symbolic)
  let show = symbolic_to_string
end


val     typeof: symbolic -> maybe symbolic_type
let rec typeof symb =
  match symb with
    | SYMBtrue ->
        Just SYMBbool
    | SYMBfalse ->
        Just SYMBbool
    | SYMBconst _ ->
        Just SYMBint
    | SYMBsym ty _ ->
        Just ty
    | SYMBop op symb1 symb2 ->
        match (op, typeof symb1, typeof symb2) with
          | (Add, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Sub, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Mul, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Div, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Mod, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Exp, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Eq, Just SYMBint, Just SYMBint) ->
              Just SYMBbool
          | (Lt, Just SYMBint, Just SYMBint) ->
              Just SYMBbool
          | _ ->
              Nothing
        end
    | SYMBite symb1 symb2 symb3 ->
        match (typeof symb1, typeof symb2, typeof symb3) with
          | (Just SYMBbool, Just SYMBbool, Just SYMBbool) ->
              Just SYMBbool
          | (Just SYMBbool, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | _ ->
              Nothing
        end
  end


val     reduce: symbolic -> symbolic
let rec reduce symb =
  match symb with
    | SYMBconst _ ->
        symb
    | SYMBsym _ _ ->
        symb
    |  SYMBop op symb1 symb2 ->
        match (op, reduce symb1, reduce symb2) with
          | (Add, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 + n2)
          | (Sub, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 - n2)
          | (Mul, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 * n2)
          | (Div, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 / n2)
          | (Mod, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 mod n2)
(*
          | (Exp, Symbolic_constant n1, Symbolic_constant n2) ->
              (* TODO: if the natFromInteger doesn't work, you are far gone anyway *)
              Symbolic_constant (n1 ** natFromInteger n2)
*)
          | (Eq, SYMBconst n1, SYMBconst n2) ->
              if n1 = n2 then SYMBtrue else assert_false "Eq: SYMBfalse"
          | (Lt, SYMBconst n1, SYMBconst n2) ->
              if n1 < n2 then SYMBtrue else assert_false "Lt: SYMBfalse"
          | (And, SYMBtrue, SYMBtrue) ->
              SYMBtrue
          | (And, SYMBfalse, _) ->
              assert_false "And: SYMBfalse"
          | (And, _, SYMBfalse) ->
              assert_false"And2: SYMBfalse"
          | (Or, SYMBfalse, SYMBfalse) ->
              assert_false "Or: SYMBfalse"
          | (Or, SYMBtrue, _) ->
              SYMBtrue
          | (Or, _, SYMBtrue) ->
              SYMBtrue
          | (_, symb1', symb2') ->
              SYMBop op symb1' symb2'
        end
    | SYMBite symb1 symb2 symb3 ->
        match (reduce symb1, reduce symb2, reduce symb3) with
          | (SYMBtrue, symb2', _) ->
              symb2'
          | (SYMBfalse, _, symb3') ->
              symb3'
          | (symb1', symb2', symb3') ->
              SYMBite symb1' symb2' symb3'
        end
  end



val make_op: operator -> symbolic -> symbolic -> symbolic
let make_op op symb1 symb2 =
  reduce (SYMBop op symb1 symb2)


val make_ite: symbolic -> symbolic -> symbolic -> symbolic
let make_ite symb1 symb2 symb3 =
  reduce (SYMBite symb1 symb2 symb3)



(*
val try_eq: symbolic -> symbolic -> either bool (symbolic * symbolic)
let try_eq symb1 symb2 =
  match (reduce symb1, reduce symb2) with
    | (SYMBconst n1, SYMBconst n2) ->
        Left (n1 = n2)
    | symbs' ->
        Right symbs'
  end

val try_lt: symbolic -> symbolic -> either bool (symbolic * symbolic)
let try_lt symb1 symb2 =
  match (reduce symb1, reduce symb2) with
    | (SYMBconst n1, SYMBconst n2) ->
        Left (n1 < n2)
    | symbs' ->
        Right symbs'
  end
*)
