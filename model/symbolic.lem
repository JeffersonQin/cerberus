open import Pervasives
import Symbol

(* TODO: tmp *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`
declare coq   target_rep function assert_false = `DAEMON`



type operator =
  | Add
  | Sub
  | Mul
  | Div
  | Mod
  | Exp
  | Eq
  | Lt
  | And
  | Or

type symbolic_type =
  | SYMBint
  | SYMBbool

type symbolic =
  | SYMBtrue
  | SYMBfalse
  | SYMBconst of integer
  | SYMBsym   of symbolic_type * Symbol.t
  | SYMBop    of operator * symbolic * symbolic
  | SYMBite   of symbolic * symbolic * symbolic


val     typeof: symbolic -> maybe symbolic_type
let rec typeof symb =
  match symb with
    | SYMBtrue ->
        Just SYMBbool
    | SYMBfalse ->
        Just SYMBbool
    | SYMBconst _ ->
        Just SYMBint
    | SYMBsym ty _ ->
        Just ty
    | SYMBop op symb1 symb2 ->
        match (op, typeof symb1, typeof symb2) with
          | (Add, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Sub, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Mul, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Div, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Mod, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Exp, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | (Eq, Just SYMBint, Just SYMBint) ->
              Just SYMBbool
          | (Lt, Just SYMBint, Just SYMBint) ->
              Just SYMBbool
          | _ ->
              Nothing
        end
    | SYMBite symb1 symb2 symb3 ->
        match (typeof symb1, typeof symb2, typeof symb3) with
          | (Just SYMBbool, Just SYMBbool, Just SYMBbool) ->
              Just SYMBbool
          | (Just SYMBbool, Just SYMBint, Just SYMBint) ->
              Just SYMBint
          | _ ->
              Nothing
        end
  end


val     reduce: symbolic -> symbolic
let rec reduce symb =
  match symb with
    | SYMBconst _ ->
        symb
    | SYMBsym _ _ ->
        symb
    |  SYMBop op symb1 symb2 ->
        match (op, reduce symb1, reduce symb2) with
          | (Add, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 + n2)
          | (Sub, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 - n2)
          | (Mul, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 * n2)
          | (Div, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 / n2)
          | (Mod, SYMBconst n1, SYMBconst n2) ->
              SYMBconst (n1 mod n2)
(*
          | (Exp, Symbolic_constant n1, Symbolic_constant n2) ->
              (* TODO: if the natFromInteger doesn't work, you are far gone anyway *)
              Symbolic_constant (n1 ** natFromInteger n2)
*)
          | (Eq, SYMBconst n1, SYMBconst n2) ->
              if n1 = n2 then SYMBtrue else assert_false "Eq: SYMBfalse"
          | (Lt, SYMBconst n1, SYMBconst n2) ->
              if n1 < n2 then SYMBtrue else assert_false "Lt: SYMBfalse"
          | (And, SYMBtrue, SYMBtrue) ->
              SYMBtrue
          | (And, SYMBfalse, _) ->
              assert_false "And: SYMBfalse"
          | (And, _, SYMBfalse) ->
              assert_false"And2: SYMBfalse"
          | (Or, SYMBfalse, SYMBfalse) ->
              assert_false "Or: SYMBfalse"
          | (Or, SYMBtrue, _) ->
              SYMBtrue
          | (Or, _, SYMBtrue) ->
              SYMBtrue
          | (_, symb1', symb2') ->
              SYMBop op symb1' symb2'
        end
    | SYMBite symb1 symb2 symb3 ->
        match (reduce symb1, reduce symb2, reduce symb3) with
          | (SYMBtrue, symb2', _) ->
              symb2'
          | (SYMBfalse, _, symb3') ->
              symb3'
          | (symb1', symb2', symb3') ->
              SYMBite symb1' symb2' symb3'
        end
  end



val make_op: operator -> symbolic -> symbolic -> symbolic
let make_op op symb1 symb2 =
  reduce (SYMBop op symb1 symb2)


val make_ite: symbolic -> symbolic -> symbolic -> symbolic
let make_ite symb1 symb2 symb3 =
  reduce (SYMBite symb1 symb2 symb3)



(*
val try_eq: symbolic -> symbolic -> either bool (symbolic * symbolic)
let try_eq symb1 symb2 =
  match (reduce symb1, reduce symb2) with
    | (SYMBconst n1, SYMBconst n2) ->
        Left (n1 = n2)
    | symbs' ->
        Right symbs'
  end

val try_lt: symbolic -> symbolic -> either bool (symbolic * symbolic)
let try_lt symb1 symb2 =
  match (reduce symb1, reduce symb2) with
    | (SYMBconst n1, SYMBconst n2) ->
        Left (n1 < n2)
    | symbs' ->
        Right symbs'
  end
*)
