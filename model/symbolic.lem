open import Pervasives
import Symbol


type operator =
  | Add
  | Sub
  | Mul
  | Div
  | Mod

type symbolic =
  | Symbolic_constant of integer
  | Symbolic_symbol of Symbol.t
(*  | Symbolic_equal of symbolic * symbolic *)
  | Symbolic_op of operator * symbolic * symbolic


(* syntactic equality *)
let rec symbolic_eq symb1 symb2 =
  match (symb1, symb2) with
    | (Symbolic_constant n1, Symbolic_constant n2) ->
        n1 = n2
    | (Symbolic_symbol sym1, Symbolic_symbol sym2) ->
        sym1 = sym2
(*
    | (Symbolic_equal symb11 symb12, Symbolic_equal symb21 symb22) ->
        symbolic_eq symb11 symb21 && symbolic_eq symb12 symb22
*)
    | (Symbolic_op op1 symb11 symb12, Symbolic_op op2 symb21 symb22) ->
        op1 = op2 && symbolic_eq symb11 symb21 && symbolic_eq symb12 symb22
    | _ ->
        false
  end

instance (Eq symbolic)
  let (=) = symbolic_eq
  let (<>) = fun x y -> not (symbolic_eq x y)
end




type equation =
  | Symbolic_eq  of symbolic * symbolic
  | Symbolic_neq of symbolic * symbolic


type equations = list equation


val empty_equations: equations
let empty_equations =
  []


val combine_equations: equations -> equations -> equations
let combine_equations eqs1 eqs2 =
  eqs1 ++ eqs2




val symbol: Symbol.t -> symbolic
let symbol sym =
  Symbolic_symbol sym





val constant: integer -> symbolic
let constant n =
  Symbolic_constant n




val operator: operator -> symbolic -> symbolic -> symbolic
let operator op sym1 sym2 =
  match (sym1, sym2) with
    | (Symbolic_constant n1, Symbolic_constant n2) ->
        Symbolic_constant
          match op with
            | Add -> n1 + n2
            | Sub -> n1 - n2
            | Mul -> n1 * n2
            | Div -> n1 / n2
            | Mod -> n1 mod n2
          end
    | _ ->
        Symbolic_op op sym1 sym2
  end




(*
type symbolic_constraint

(* symbolic computation producing an 'a *)
type t 'a =
  | Sym_base of 'a
  | Sym_cond of 


val return: forall 'a. 'a -> t 'a
*)
