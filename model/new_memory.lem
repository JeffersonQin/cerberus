open import Pervasives
import New_memory_effect Symbolic State_exception AilTypes

(* TODO: temporary hack *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`


module E = New_memory_effect
module Operators = struct
  let inline (>>=)    = E.bind
  let inline (>>) m f = E.bind m (fun _ -> f)
  let inline tid_of   = E.tid_of
end

open Operators





type address (* =
  | Addr_symbolic of Symbolic.symbolic
  | Addr_con
*)




type lifted_value 'a =
  | Specified of 'a
  | Unspecified of AilTypes.ctype
  | Indeterminate_value of AilTypes.ctype



(* Ids for dynamically allocated regions *)
type mem_region_id = Symbolic.symbol

type mem_object_id = Symbolic.symbol

type mem_object = <|
  obj_effective_type: maybe AilTypes.ctype;
  obj_address:        address;
  (* value ? *)
|>


type memory_write


type memory_state = <|
  mem_object_id_counter: Symbolic.counter;
  
  mem_symbol_counter: Symbolic.counter;

  mem_objects: map mem_object_id mem_object;
  mem_writes:  list memory_write;


|>


type memory_error


(* size of dynamically allocated regions *)
type size


(* Memory effect *)
type t 'a = E.t memory_state 'a



(* TODO: REGIONS !!!!!!!!! *)

type pointer_value =
  | Pointer_null of AilTypes.ctype
  
  



  | Pointer_object of mem_object_id
  | Pointer_cast of AilTypes.ctype * pointer_value
  | Pointer_alloc of address * size
(*  | Pointer_intcast of  *)



(*
type pointer_value2 = <|
null  of ctype
+
(

  (  obj_id: mem_object_id; (* originally pointer to the original whole statically allocated object (eg for &(s.f) the object id of s) *)
  + region_id:             (* pointer to a malloc'd region, similarly the whole one *) 
  + cast_from_integer    (* this case is only here for casts that taint-tracking doesn't discover a good original object for (so it will never be used in standard c *)

 )

plus, in the obj_id case, the original declared type of the object (which will be equal to the effective type of the object, if those are turned on)


the "view type" of the pointer - this will change when you do a cast.  and when you do a shift.


the position in the original object, represented with (possibly symbolic) address arithmetic

the position in the original object, represented as an abstract access path 
)


and we lift all that when stored in an object  (to add unspecified values )



 
|>
*)




val     is_null_pointer: pointer_value -> bool
let rec is_null_pointer ptr =
  match ptr with
    | Pointer_null _ ->
        true
    | Pointer_object _ ->
        false
    | Pointer_cast _ ptr' ->
        (* STD ยง6.3.2.3#4, sentence 1 *)
        is_null_pointer ptr'
    | Pointer_alloc _ _ ->
        false
  end


(* TODO: not sure if we want to use this *)
(* TODO: complete *)
val     normalize_pointer: pointer_value -> pointer_value
let rec normalize_pointer ptr =
  match ptr with
    | Pointer_null ty ->
        Pointer_null ty
    | Pointer_object obj_id ->
        Pointer_object obj_id
    | Pointer_cast ty (Pointer_null _) ->
        (* STD ยง6.3.2.3#4, sentence 1 *)
        Pointer_null ty
    | Pointer_cast ty1 (Pointer_cast _ ptr') ->
        normalize_pointer (Pointer_cast ty1 ptr')
  end










type object_value =
  | Obj_pointer of pointer_value

  | Obj_unspecified of AilTypes.ctype
(*  | Indeterminate_value of AilTypes.ctype *) (* TODO: we don't have trap value, so `Unspecified' is sufficient *)





val initial_memory: memory_state
let initial_memory = <|
  mem_object_id_counter= Symbolic.init;
  mem_symbol_counter=    Symbolic.init;
  mem_objects=           Map.empty;
  mem_writes =           [];
|>





(* The memory layout API *)
val create:        AilTypes.ctype -> t pointer_value
(* val alloc:          *)
val kill:          pointer_value -> t unit
val load:          AilTypes.ctype -> pointer_value -> t object_value
val store:         AilTypes.ctype -> pointer_value -> object_value -> t unit
(* val same: address -> address -> t bool *)
val pointer_shift: pointer_value -> pointer_value -> t pointer_value
val pointer_diff:  pointer_value -> pointer_value -> t object_value
val pointer_lt:    pointer_value -> pointer_value -> t bool
val pointer_gt:    pointer_value -> pointer_value -> t bool
val pointer_le:    pointer_value -> pointer_value -> t bool
val pointer_ge:    pointer_value -> pointer_value -> t bool
val pointer_eq:    pointer_value -> pointer_value -> t bool
val pointer_neq:   pointer_value -> pointer_value -> t bool
(* val pointer_value:  *)




(* ========= *)
(* internal operations *)

val gen_symbolic_address: t address
let gen_symbolic_address =
  assert_false "WIP"
(*
  State_exception.modify (fun st ->
    (st.mem_symbol_counter, <| st with mem_symbol_counter= st.mem_symbol_counter + 1 |>)
  )
*)

val gen_mem_object_id: t mem_object_id
let gen_mem_object_id =
  assert_false "WIP"








let create ty =
  gen_symbolic_address >>= fun addr   ->
  gen_mem_object_id    >>= fun obj_id ->
  State_exception.modify (fun st ->
    let obj = <| obj_effective_type= Just ty; obj_address= addr |> in
    (Pointer_object obj_id, <| st with mem_objects= Map.insert obj_id obj st.mem_objects |>)
  )




let store ty ptr v =
  assert_false "WIP"



(*
let load ty ptr =
  
*)



let pointer_eq ptr1 ptr2 =
  if is_null_pointer ptr1 && is_null_pointer ptr2 then
    (* STD ยง6.3.2.3#4, sentence 2 *)
    E.return true
  else if is_null_pointer ptr1 || is_null_pointer ptr2 then
    (* STD ยง6.3.2.3#3, sentence 2 *)
    E.return false
  else
    assert_false "WIP"
