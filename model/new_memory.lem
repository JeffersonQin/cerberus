

(*
  STUFF WE NEED

  * given two writes Ky wants to know if they overlap
  * the same given a write and a read request
  
  
  * given a list of (address, 




*)




















open import Pervasives
import New_memory_effect Symbolic State_exception AilTypes

(* TODO: temporary hack *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`


module E = New_memory_effect
module Operators = struct
  let inline (>>=)    = E.bind
  let inline (>>) m f = E.bind m (fun _ -> f)
(*  let inline tid_of   = E.tid_of *)
end

open Operators





type address (* =
  | Addr_symbolic of Symbolic.symbolic
  | Addr_con
*)




type lifted_value 'a =
  | Specified of 'a
  | Unspecified of AilTypes.ctype
  | Indeterminate_value of AilTypes.ctype



(* Ids for dynamically allocated regions *)
type mem_region_id = Symbolic.symbol

type mem_object_id = Symbolic.symbol

type mem_object = <|
  obj_original_type: maybe AilTypes.ctype;
  obj_address:       address;
  (* and maybe a size for VLAs and flexible array member (otherwise the size) *)
|>


type memory_write

(*
(* TODO: we may need to allow region sizes and offsets to be symbolic ? *)
type mem_region = <|
  region_size:    nat; (* in bytes *)
  region_objects: list (mem_object_id * nat); (* objects and their offsets from the beginning of the region *)
|>
*)


type memory_state = <|
  mem_object_id_counter: Symbolic.counter;
  mem_symbol_counter: Symbolic.counter;

(*
  mem_regions: map mem_region_id mem_region;
  mem_writes:  list memory_write;
*)

  mem_objects: map mem_object_id mem_object;
|>


type memory_error


(* size of dynamically allocated regions *)
type size


(* Memory effect *)
type t 'a = E.t memory_state 'a






type pointer_value =
  | Pointer_null of AilTypes.ctype
  | Pointer_other of pointer_other


type pointer_provenance =
  (* the `ctype' below is the original declared type of the object (which will
     be equal to the effective type of the object, if those are turned on)  *)
  | Prov_obj of AilTypes.ctype * mem_object_id
  
  (* pointer to a malloc'd region, similarly the whole one *) 
  | Prov_region of mem_region_id
  
  (* this case is only here for casts that taint-tracking doesn't discover a
     good original object for (so it will never be used in standard C *)
  (* the `ctype' saves the original type cast when creating that pointer *)
  | Prov_intcast of AilTypes.ctype * mem_object_value


type pointer_path =
  | Path_base
  | Path_array  of nat * pointer_path
  | Path_member of Symbolic.sym (* struct/union id *) * Symbolic.sym (* member id *) * pointer_path


type pointer_other = <|
  ptr_provenance:      pointer_provenance;
  ptr_view_type:       AilTypes.ctype; (* the "view type" of the pointer - this will change when you do a cast.  and when you do a shift. *)
  ptr_abstract_offset: maybe pointer_abstract_path; (* the position in the original object, represented as an abstract access path  *)
  ptr_numeric_offset:  Symbolic.t;(* the position in the original object, represented with (possibly symbolic) address arithmetic *)
|>






(*
type pointer_value2 = <|
null  of ctype
+
(

  (  obj_id: mem_object_id; (* originally pointer to the original whole statically allocated object (eg for &(s.f) the object id of s) *)
  + region_id:             (* pointer to a malloc'd region, similarly the whole one *) 
  + cast_from_integer    (* this case is only here for casts that taint-tracking doesn't discover a good original object for (so it will never be used in standard c *)

 )

plus, in the obj_id case, the original declared type of the object (which will be equal to the effective type of the object, if those are turned on)


the "view type" of the pointer - this will change when you do a cast.  and when you do a shift.


the position in the original object, represented with (possibly symbolic) address arithmetic

the position in the original object, represented as an abstract access path 
)


and we lift all that when stored in an object  (to add unspecified values )



 
|>
*)











type mem_object_value =
  | Obj_pointer of pointer_value

  | Obj_unspecified of AilTypes.ctype
(*  | Indeterminate_value of AilTypes.ctype *) (* TODO: we don't have trap value, so `Unspecified' is sufficient *)





val initial_memory: memory_state
let initial_memory = <|
  mem_object_id_counter= Symbolic.init;
  mem_symbol_counter=    Symbolic.init;
  mem_regions=           Map.empty;
  mem_objects=           Map.empty;
  mem_writes =           [];
|>





(* The memory layout API *)
val create:        AilTypes.ctype -> t pointer_value
(* val alloc:          *)
val kill:          pointer_value -> t unit
val load:          AilTypes.ctype -> pointer_value -> t object_value
val store:         AilTypes.ctype -> pointer_value -> object_value -> t unit
(* val same: address -> address -> t bool *)
val pointer_shift: pointer_value -> pointer_value -> t pointer_value
val pointer_diff:  pointer_value -> pointer_value -> t object_value
val pointer_lt:    pointer_value -> pointer_value -> t bool
val pointer_gt:    pointer_value -> pointer_value -> t bool
val pointer_le:    pointer_value -> pointer_value -> t bool
val pointer_ge:    pointer_value -> pointer_value -> t bool
val pointer_eq:    pointer_value -> pointer_value -> t bool
val pointer_neq:   pointer_value -> pointer_value -> t bool
(* val pointer_value:  *)




(* ========= *)
(* internal operations *)

val gen_symbolic_address: t address
let gen_symbolic_address =
  assert_false "WIP"
(*
  State_exception.modify (fun st ->
    (st.mem_symbol_counter, <| st with mem_symbol_counter= st.mem_symbol_counter + 1 |>)
  )
*)

val gen_mem_object_id: t mem_object_id
let gen_mem_object_id =
  assert_false "WIP"








let create ty =
  gen_symbolic_address >>= fun addr   ->
  gen_mem_object_id    >>= fun obj_id ->
  State_exception.modify (fun st ->
    let obj = <| obj_effective_type= Just ty; obj_address= addr |> in
    (Pointer_object obj_id, <| st with mem_objects= Map.insert obj_id obj st.mem_objects |>)
  )




let store ty ptr v =
  assert_false "WIP"



(*
let load ty ptr =
  
*)



let pointer_eq ptr1 ptr2 =
  if is_null_pointer ptr1 && is_null_pointer ptr2 then
    (* STD ยง6.3.2.3#4, sentence 2 *)
    E.return true
  else if is_null_pointer ptr1 || is_null_pointer ptr2 then
    (* STD ยง6.3.2.3#3, sentence 2 *)
    E.return false
  else
    assert_false "WIP"
