

(*
  STUFF WE NEED

  * given two writes Ky wants to know if they overlap
  * the same given a write and a read request

*)

open import Pervasives
import New_memory_effect Symbolic State_exception AilTypes

(* TODO: temporary hack *)
val assert_false: forall 'a. string -> 'a
declare ocaml target_rep function assert_false = `Boot_ocaml.assert_false`


(*PS: we only have effects for semantic failures in the result type of the API, yes?  In which case I guess most of this goes away, but I don't know your normal failure plumbing  *)
(* module E = New_memory_effect *)
(* module Operators = struct *)
(*   let inline (>>=)    = E.bind *)
(*   let inline (>>) m f = E.bind m (fun _ -> f) *)
(* (\*  let inline tid_of   = E.tid_of *\) *)
(* end *)

(* open Operators *)

(* (\* Memory effect *\) *)
(* type t 'a = E.t memory_state 'a *)
(* 
type memory_error
*)

type t = Exception.t  (* to represent failure cases *)




type address (* =
  | Addr_symbolic of Symbolic.symbolic
  | Addr_con
*)

type lifted_value 'a =
  | Specified of 'a
  | Unspecified of AilTypes.ctype
  | Indeterminate_value of AilTypes.ctype




type memory_write












type pointer_provenance =
  (* pointer to a statically allocated object *)
  (*the metadata associated with those ids is kept in the driver_state *)
  | Prov_sao of sao_id
  
  (* pointer to a dynamically allocated space (from malloc etc.) *) 
  | Prov_das of das_id

  (* pointer formed by casting from an integer, in the case where the
     integer provenance-tracking machinery doesn't discover a good
     original object for (so this case will never be used in standard
     C. The `ctype' records the type used for the creating cast. *)
  | Prov_intcast of AilTypes.ctype * mem_object_value


type pointer_path_element =
  | Path_array  of Symbolic.symbolic (* the index *) 
  | Path_member of Symbolic.sym (* struct/union id *) * Symbolic.sym (* member id *) 

type pointer_path = list pointer_path_element

type pointer_nonnull = <|
  ptr_provenance:      pointer_provenance;
  ptr_view_type:       AilTypes.ctype; (* the "view type" of the pointer - this will change when you do a cast or a shift. *)
  ptr_abstract_offset: maybe pointer_path; (* the position in the original object, represented as an abstract access path, where that makes sense  *)
  ptr_numeric_offset:  Symbolic.t; (* the position in the original object, represented with (possibly symbolic) address arithmetic (as an offset from the base address determined by the ptr_provenance field) *)
  ptr_numeric_address: Symbolic.t  (* the address in memory *)
|>

type pointer_value =
  | Pointer_null of AilTypes.ctype
  | Pointer_nonnull of pointer_nonnull





(* PS: not sure what this is for - why do we lift *pointer values* rather than general values? *)
type mem_object_value =
  | Obj_pointer of pointer_value

  | Obj_unspecified of AilTypes.ctype
(*  | Indeterminate_value of AilTypes.ctype *) (* TODO: we don't have trap value, so `Unspecified' is sufficient *)








(* The memory layout API *)
val create:        AilTypes.ctype -> t pointer_value
(* val alloc:          *)
val kill:          pointer_value -> t unit
val load:          AilTypes.ctype -> pointer_value -> t object_value
val store:         AilTypes.ctype -> pointer_value -> object_value -> t unit
(* val same: address -> address -> t bool *)
val pointer_arithmetic: pointer_value -> Symbolic.symbolic  -> t pointer_value
val pointer_member_offset: pointer_value -> Symbolic.sym  -> t pointer_value
val cast_pointer_to_pointer:  pointer_value -> ctype -> t pointer_value
val cast_pointer_to_integer: pointer_value -> integerType -> t object_value
val cast_integer_to_pointer: object_value -> ctype -> t pointer_value
val pointer_diff:  pointer_value -> pointer_value -> t object_value

type compare_operator = Lt | Gt | Ge | Le | Eq | Neq
val pointer_compare:  compare_operator->  pointer_value -> pointer_value -> t bool


(* TODO: add overlap and containment checking *)
(* TODO: and functions to assemble a read value from a hb-partial-order of overlapping writes *)
(* TODO: ...including reading representation bytes from an object etc. *)


(*TODO: get Symbolic.sym  and  Symbolic.counter out of the "Symbolic" module *)




(* ========= *)
(* internal operations *)

val gen_symbolic_address: t address
let gen_symbolic_address =
  assert_false "WIP"
(*
  State_exception.modify (fun st ->
    (st.mem_symbol_counter, <| st with mem_symbol_counter= st.mem_symbol_counter + 1 |>)
  )
*)

val gen_mem_object_id: t mem_object_id
let gen_mem_object_id =
  assert_false "WIP"








let create ty =
  gen_symbolic_address >>= fun addr   ->
  gen_mem_object_id    >>= fun obj_id ->
  State_exception.modify (fun st ->
    let obj = <| obj_effective_type= Just ty; obj_address= addr |> in
    (Pointer_object obj_id, <| st with mem_objects= Map.insert obj_id obj st.mem_objects |>)
  )




let store ty ptr v =
  assert_false "WIP"



(*
let load ty ptr =
  
*)



let pointer_eq ptr1 ptr2 =
  if is_null_pointer ptr1 && is_null_pointer ptr2 then
    (* STD ยง6.3.2.3#4, sentence 2 *)
    E.return true
  else if is_null_pointer ptr1 || is_null_pointer ptr2 then
    (* STD ยง6.3.2.3#3, sentence 2 *)
    E.return false
  else
    assert_false "WIP"
