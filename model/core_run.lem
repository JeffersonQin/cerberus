open import Pervasives Global Core Core_ctype Core_aux
import Set_helpers
import State State_operators
import Exception Errors Undefined
import Cmm_csem Cmm_aux
import AilTypesAux

import Core_run_effect

module Cmm = Cmm_csem
module U   = Undefined



(*
TODO: not used anymore

(* Conversions between Core and Cmm_aux constants *)
val     to_core_constant: Cmm_aux.constant -> Core.constant
let rec to_core_constant c =
  match c with
    | Cmm_aux.Cint n      -> Core.Cint n
(*    | Cmm_aux.Carray cs   -> Core.Carray $ map to_core_constant cs *)
    | Cmm_aux.Cfunction a -> Core.Cfunction a
  end

val     from_core_constant: Core.constant -> Cmm_aux.constant
let rec from_core_constant c =
  match c with
    | Core.Cint n      -> Cmm_aux.Cint n
(*    | Core.Carray cs   -> Cmm_aux.Carray $ map from_core_constant cs *)
    | Core.Cfunction a -> Cmm_aux.Cfunction a
  end

*)



(* BEGIN: Core continuation ********************************************************************* *)
type _cont 'a =
  | Kunseq of list (expr 'a) * list (expr 'a)
  | Kpar of list (expr 'a) * list (expr 'a)
  | Kwseq of list (maybe sym) * expr 'a
  | Ksseq of list (maybe sym) * expr 'a

type cont 'a = list (_cont 'a)


(* BEGIN: printing stuff for DEBUG *)

val     sepBy: forall 'a. string -> ('a -> string) -> list 'a -> string
let rec sepBy sep f xs =
  match xs with
    | []     -> ""
    | [x]    -> f x
    | x::xs' -> f x ^ sep ^ sepBy sep f xs'
  end

val string_of_cont: forall 'a. cont 'a -> string
let string_of_cont k =
  let f = function
    | Kunseq [] es2 -> fun x -> "[ " ^ x ^ " || " ^ sepBy " || " Boot.pp_core_expr es2 ^ " ]"
    | Kunseq es1 [] -> fun x -> "[ " ^ sepBy " || " Boot.pp_core_expr es1 ^ " || " ^ x ^ " ]"
    | Kunseq es1 es2 -> fun x -> "[ " ^ sepBy " || " Boot.pp_core_expr es1 ^ " || " ^ x ^ " || " ^ sepBy " || " Boot.pp_core_expr es2 ^ " ]"
    
    | Kpar [] es2 -> fun x -> "[ " ^ x ^ " ; " ^ sepBy " ; " Boot.pp_core_expr es2 ^ " ]"
    | Kpar es1 [] -> fun x -> "[ " ^ sepBy " ; " Boot.pp_core_expr es1 ^ " ; " ^ x ^ " ]"
    | Kpar es1 es2 -> fun x -> "[ " ^ sepBy " ; " Boot.pp_core_expr es1 ^ " ; " ^ x ^ " ; " ^ sepBy " ; " Boot.pp_core_expr es2 ^ " ]"
    
    | Kwseq _as e2   -> fun x -> "wseq _as = (" ^ x ^ ") in " ^ Boot.pp_core_expr e2
    | Ksseq _as e2   -> fun x -> "sseq _as = (" ^ x ^ ") in " ^ Boot.pp_core_expr e2
  end in
  foldl (fun acc x -> f x acc) "\x1b[1;32m[]\x1b[0m" k
(* END: printing stuff for DEBUG *)

val apply_cont: forall 'a. cont 'a -> expr 'a -> expr 'a
let apply_cont k e =
  let f _k e =
    match _k with
      | Kwseq _as e2   -> Ewseq _as e e2
      | Ksseq _as e2   -> Esseq _as e e2
      | Kpar es1 es2   -> Epar $ es1 ++ (e :: es2)
      | Kunseq es1 es2 -> Eunseq $ es1 ++ (e :: es2)
    end in
  foldl (fun acc x -> f x acc) e k


(*
val compose_cont: forall 'a. cont 'a -> cont 'a -> cont 'a
let compose_cont k1 k2 = k1 ++ k2
*)
(* END: Core continuation ********************************************************************* *)


(* TODO: this is part of the "memory model" but need to be before Effect (...) *)
(*
type mem_value =
  | Muninit    (* TODO: Kayvan has to check whether we can remove this constructor 
                  and use the empty list in mem_state to denote a created, but 
                  uninitialized variable. *) 
  | Mbase of constant
  | Mobj of (list Symbol.t * nat)
  | Mnull
declare ocaml target_rep type Cmm.cvalue = mem_value
*)

(* Instantiation of Cmm types *)
(* declare ocaml target_rep type Cmm.location = mem_addr *)

(*
type cmm_tid = Cmm.tid
type cmm_loc = Cmm.location
type cmm_cvalue = Cmm.cvalue
type cmm_action = Cmm.action
type cmm_observable_execution = Cmm.observable_execution
type cmm_complete_execution = Cmm.complete_execution
*)












(* list monad *)
module L = struct
  val return: forall 'a. 'a -> list 'a
  let return x = [x]
  
  val bind: forall 'a 'b. list 'a -> ('a -> list 'b) -> list 'b
  let bind m f = foldr (fun x y -> (f x) ++ y) [] m
end



module E = Core_run_effect
module Operators = struct
  let inline (>>=)    = E.bind
  let inline (>>) m f = E.bind m (fun _ -> f)
  let inline tid_of   = E.tid_of
end

open Operators


(* TODO: here I'm annotating all actions instead (this may reduce the number of
         epsilon transitions) *)
(* [annotate b e] add on each sb-minimal action of [e] an annotation meaning
                  that this action is sequenced-after [act]
  
  in the rules comments, this function is noted: <b> e
 *)
val annotate_expr: polarity * E.taction_id -> expr E.taction_id -> expr E.taction_id
let rec annotate_expr p_aid e =
  match e with
  | Elet a e1 e2         -> Elet a e1 (annotate_expr p_aid e2)
  | Eif e1 e2 e3         -> Eif e1 (annotate_expr p_aid e2) (annotate_expr p_aid e3)
  | Eaction (Paction p (Action bs a)) -> Eaction (Paction p (Action ({snd p_aid} union bs) a))
  | Eunseq es            -> Eunseq (List.map (annotate_expr p_aid) es)
  | Epar es              -> Epar (List.map (annotate_expr p_aid) es)
  | Ewseq _as e1 e2      -> Ewseq _as (annotate_expr p_aid e1) (match fst p_aid with Pos -> annotate_expr p_aid e2 | Neg -> e2 end)
  | Esseq _as e1 e2      -> Esseq _as (annotate_expr p_aid e1) (annotate_expr p_aid e2)
  | Esave k a_tys e      -> Esave k a_tys (annotate_expr p_aid e)
  | End es               -> End (List.map (annotate_expr p_aid) es)
  | Eproc bs f pes       -> Eproc ({snd p_aid} union bs) f pes
  | Erun bs d a_vs       -> Erun ({snd p_aid} union bs) d a_vs
  | _                    -> e
end



(* TODO: doesn't do what it should *)
val annotate: polarity * E.taction_id -> list (cont E.taction_id) -> list (cont E.taction_id)
let rec _annotate (p, aid) k =
  match k with
    | []                   -> []
    | Kpar es1 es2 :: k' -> Kpar (List.map (annotate_expr (p, aid)) es1) (List.map (annotate_expr (p, aid)) es2) :: _annotate (p, aid) k'
    | Kunseq es1 es2 :: k' -> Kunseq es1 es2 :: _annotate (p, aid) k'
    | Kwseq _as e2   :: k' -> Kwseq _as (match p with Pos -> annotate_expr (p, aid) e2 | Neg -> e2 end) :: _annotate (p, aid) k'
    | Ksseq _as e2   :: k' -> Ksseq _as (annotate_expr (p, aid) e2) :: _annotate (p, aid) k'
  end
let annotate aid ks = List.map (_annotate aid) ks
(*
let annotate a ks =
  match ks with
    | []       -> []
    | k :: ks' -> _annotate a k :: ks'
  end
*)





(* -------------------------------------------------------------------------- *)


(* ************************************************************************** *)
(* Translation from states to executions in Cmm *)

val type_to_location_kind: ctype -> Cmm.location_kind
let type_to_location_kind ty = 
  (* There are no fences yet, so the the type is Cmm.Atomic or Cmm.Non_Atomic *)
  if is_atomic_type ty then Cmm.Atomic else Cmm.Non_Atomic

val to_cmm_action: E.taction_id -> E.trace_action -> Cmm.action
let to_cmm_action taid action = 
  let string_taid = Pervasives.string_of_natural taid in 
  match action with
  | E.Tcreate _ o tid     -> Cmm.Create string_taid tid o
  | E.Talloc _ o tid      -> Cmm.Create string_taid tid o
  | E.Tkill o tid         -> Cmm.Kill string_taid tid o
  | E.Tstore _ o v mo tid -> Cmm.Store string_taid tid mo o v
  | E.Tload _ o v mo tid  -> Cmm.Load string_taid tid mo o v
  | E.Trmw _ o e d mo tid -> Cmm.RMW string_taid tid mo o e d
  end

(* Auxilary function for list_to_relation *)
val list_to_relation_aux: forall 'a. SetType 'a => list 'a -> maybe 'a -> set ('a * 'a)
let rec list_to_relation_aux list prev = 
  match list with 
  | [] -> {}
  | h::t -> (match prev with
             | Nothing   -> list_to_relation_aux t (Just h)
             | Just item -> Set.insert (h, item) (list_to_relation_aux t (Just h))
             end)
  end

(* Outputs the total order with h1 > h2 > h3 for input h1::h2::h3::[] *)
val list_to_relation: forall 'a. Eq 'a, SetType 'a => list 'a -> set ('a * 'a)
let list_to_relation list = 
  Relation.transitiveClosure (list_to_relation_aux list Nothing)
  


val to_observable_execution: E.state -> Cmm.observable_execution
let to_observable_execution s = 
  let to_cmm_relation = fun rel -> 
      (Set.map (fun (x, y) -> (fromJust $ Map.lookup x s.E.cmm_tact_map, fromJust $ Map.lookup y s.E.cmm_tact_map)) rel) in
  let pre_execution =
    <|
      Cmm.actions = Map.range s.E.cmm_tact_map;
      Cmm.threads = Set.map tid_of (Map.range s.E.tact_map);
      Cmm.lk      = (fun x -> E.get_location_kind s x);
      Cmm.sb      = to_cmm_relation s.E.sb;
      Cmm.asw     = to_cmm_relation s.E.asw;
      Cmm.dd      = {};
    |> in
  let execution_witness = 
    <|
      Cmm.rf  = to_cmm_relation s.E.rf;
      Cmm.mo  = Set_helpers.fold (fun l acc ->
        (to_cmm_relation $ list_to_relation l) union acc
      ) (Map.range s.E.mo) {};

(*
val fold : forall 'a 'b. ('a -> 'b -> 'b) -> set 'a -> 'b -> 'b


      Cmm.mo  = Pervasives.bigunion { to_cmm_relation $ list_to_relation l
                                    | forall (l IN Map.range s.E.mo) 
                                    | true };
*)
      Cmm.sc  = to_cmm_relation (list_to_relation s.E.sc);
      Cmm.lo  = {};
      Cmm.ao  = {};
      Cmm.tot = {};
    |> in
  (pre_execution, execution_witness)
  
val to_complete_execution: E.state -> Cmm.complete_execution
let to_complete_execution s = 
  let (Xo, Xw) = to_observable_execution s in
  (* TODO: Choose the right memory model *)
  let rl = Cmm.release_acquire_no_locks_relations Xo Xw in
  (Xo, Xw, rl)
  
val to_happens_before: Cmm.observable_execution -> set (Cmm.action * Cmm.action)
let to_happens_before (Xo, Xw) = 
  (* TODO: Choose the right memory model *)
  let sw = Cmm.release_acquire_no_locks_synchronizes_with_set Xo.Cmm.actions Xo.Cmm.sb Xo.Cmm.asw Xw.Cmm.rf in
  Cmm.no_consume_hb Xo.Cmm.sb sw
  
val discard_CoWR_states: E.taction_id -> E.taction_id -> E.t unit
let discard_CoWR_states write_taid read_taid = fun st ->
  let w1 = fromJust $ Map.lookup write_taid st.E.cmm_tact_map in
  let r = fromJust $ Map.lookup read_taid st.E.cmm_tact_map in
  let (Xo, Xw) = to_observable_execution st in
  let hb = to_happens_before (Xo, Xw) in
  if exists (w2 IN Xo.Cmm.actions). (w1, w2) IN Xw.Cmm.mo && (w2, r) IN hb then
    []
  else
    [(U.return (), st)]
  
val discard_CoWW_states: E.taction_id -> E.t unit
let discard_CoWW_states write_taid = fun st ->
  let w1 = fromJust $ Map.lookup write_taid st.E.cmm_tact_map in
  let (Xo, Xw) = to_observable_execution st in
  let hb = to_happens_before (Xo, Xw) in
  if exists (w2 IN Xo.Cmm.actions). (w1, w2) IN Xw.Cmm.mo && (w2, w1) IN hb then
    []
  else
    [(U.return (), st)]

val discard_inconsistent_sc_writes: E.taction_id -> E.t unit
let discard_inconsistent_sc_writes write_taid = fun s ->
  let w1 = fromJust $ Map.lookup write_taid s.E.cmm_tact_map in
  let (Xo, Xw) = to_observable_execution s in
  if exists (w2 IN Xo.Cmm.actions). (w2, w1) IN Xw.Cmm.sc && (w1, w2) IN Xw.Cmm.mo then
    []
  else
    [(U.return (), s)]

val discard_inconsistent_sc_reads: E.taction_id -> E.taction_id -> E.t unit
let discard_inconsistent_sc_reads write_taid read_taid = fun s ->
  let w1 = fromJust $ Map.lookup write_taid s.E.cmm_tact_map in
  let r = fromJust $ Map.lookup read_taid s.E.cmm_tact_map in  
  let (Xo, Xw) = to_observable_execution s in
  if (w1, r) IN Xw.Cmm.sc then
    if exists (w2 IN Xo.Cmm.actions). Cmm.is_write w2 && 
                                      (Cmm.loc_of w1 = Cmm.loc_of w2) &&
                                      (w1,w2) IN Xw.Cmm.sc && (w2,r) IN Xw.Cmm.sc then
      []
    else
      [(U.return (), s)]
  else if Cmm.is_seq_cst r && not (Cmm.is_seq_cst w1) then
    let hb = to_happens_before (Xo, Xw) in
    if exists (w2 IN Xo.Cmm.actions). Cmm.is_write w2 && 
                                      (Cmm.loc_of w1 = Cmm.loc_of w2) &&
                                      (w1,w2) IN hb && (w2,r) IN Xw.Cmm.sc then
      []
    else
      [(U.return (), s)]
  else
    [(U.return (), s)]
  
val check_for_dataraces: E.t unit
let check_for_dataraces = fun st ->
  let (Xo, Xw) = to_observable_execution st in
  let hb = to_happens_before (Xo, Xw) in
  if (Set.null (Cmm.data_races (Xo, Xw, [("hb", hb)]))) then
    [(U.return (), st)]
  else
    [(U.undef [Undefined.Data_race], st)]

(* ************************************************************************** *)
(* TODO: dummy memory model (concrete with isolated objects, ignoring C types) *)
  
(* Reverses the first list, and then appends that list to the second list. *)
val reverse_and_append: forall 'a. list 'a -> list 'a -> list 'a
let rec reverse_and_append left right = 
  match left with 
  | [] -> right
  | h::t -> reverse_and_append t (h::right)
  end

(* Inserts an element in a list. There can be multiple places to insert the element,
   the function returns a list containing all possible resulting lists. 
   The make the function recursive, there is an auxiliary argument (of type list) 
   that will be reversed and appended to the resulting list. *)
val list_insert_aux: forall 'a. 'a -> list 'a -> list 'a -> list (list 'a)
let rec list_insert_aux element aux list = 
  let new_list = reverse_and_append aux (element::list) in
  match list with
  | []   -> [new_list]
  | h::t -> List.append [new_list] (list_insert_aux element (h::aux) t)
  end
  
(* Inserts an element in a list. There can be multiple places to insert the element,
   the function returns a list containing all possible resulting lists. *)
val list_insert: forall 'a. 'a -> list 'a -> list (list 'a)
let list_insert element list = 
  list_insert_aux element [] list

(* Adds a sc actions to the state *)
val push_sc_action: E.taction_id -> E.t unit
let push_sc_action taid = fun (<|E.sc = sc|> as s) ->
  [(U.return (), <| s with E.sc = taid::sc|>)]

(* Adds a trace_action to the modification order *)
val push_mod_order: Memory.mem_addr -> E.taction_id -> E.t unit
let push_mod_order o taid = fun (<|E.mo = mod_order |> as st) ->
  let order_of_o =
    match Map.lookup o mod_order with
      | Just z  -> z
      | Nothing -> []
    end in
  [(U.return (), <| st with E.mo = Map.insert o new_order_of_o mod_order |>)
    | forall (new_order_of_o MEM list_insert taid order_of_o)
    | true]

val insert_after: forall 'a. Eq 'a => 'a -> 'a -> list 'a -> list 'a
let rec insert_after e new_e l =
  (* inserts new_e after e in l *)
  match l with
    | [] -> Boot.assert_false "insert_after failed, because it couldn't find the element in the list"
    | h::t -> if h = e then new_e::l else e::(insert_after e new_e t)
  end

val mod_order_insert_after: Memory.mem_addr -> E.taction_id -> E.taction_id -> E.t unit
let mod_order_insert_after o taid new_taid = fun (<|E.mo = mod_order |> as st) ->
  let order_of_o =
    match Map.lookup o mod_order with
      | Just z  -> z
      | Nothing -> []
    end in
  let new_order_of_o = insert_after taid new_taid order_of_o in
  [(U.return (), <| st with E.mo = Map.insert o new_order_of_o mod_order |>)]

val push_rf: E.taction_id -> E.taction_id -> E.t unit
let push_rf store_taid read_taid = fun (<| E.rf = rf |> as st) -> 
  let new_rf = Set.insert (store_taid, read_taid) rf in
  [(U.return (), <| st with E.rf = new_rf |>)]

(* Returns a taid that has not been used yet *)
val get_new_taid: E.t natural
let get_new_taid = 
  fun (<| E.tact_counter = new_taid |> as st) -> [(U.return new_taid, st)]

(* Adds the trace_action and corresponding Cmm.action to the state *)  
val add_tact: E.taction_id -> E.trace_action -> E.t unit
let add_tact taid tact = 
  fun (<| E.tact_map = tact_map; E.cmm_tact_map = cmm_tact_map; |> as st) ->
    let cmm_tact = to_cmm_action taid tact in
    [(U.return (), <| st with E.tact_counter= taid+1; 
                              E.tact_map= Map.insert taid tact tact_map;
                              E.cmm_tact_map= Map.insert taid cmm_tact cmm_tact_map; |>)]


(* push an element in the trace *)
val push_trace: (E.dyn_rule * maybe (set E.taction_id * E.taction_id)) -> E.t unit
let push_trace (r, tact_opt) =
(* TODO[newLem]  Boot.print_debug ("RULE ==> " ^ string_of_rule r) $ *)
    fun (<| E.trace= t |> as st) ->
       [(U.return (), <| st with E.trace= (r, tact_opt) :: t |>)]


(* get the last element of the trace (crash if none). *)
val get_trace: E.t (E.dyn_rule * maybe (set E.taction_id * E.trace_action))
let get_trace = function
  | <| E.trace= [] |> ->
      Boot.assert_false "[Core_run.get_trace] empty trace"
  | (<| E.tact_map= tact_map; E.trace= (r, tact_opt) :: _ |> as st) ->
      [(U.return (r, match tact_opt with Just (bs, n) ->

(*
        if not $ Map.mem n tact_map then
          Boot.assert_false $ ">>>>>" ^ (string_of_num n)
        else
*)


Just (bs, fromJust $ Map.lookup n tact_map) | Nothing -> Nothing end), st)]
end

val get_fulltrace: E.t (Map.map E.taction_id E.trace_action * E.trace)
let get_fulltrace = fun (<| E.tact_map= tact_map; E.trace= t |> as st) ->
  [(U.return (tact_map, t), st)]





(* static object allocation *)
(* TODO: the array part is some dubious experiment *)
val create: list Symbol.t -> ctype -> E.taction_id -> E.t Memory.mem_addr
let create pref ty taid = fun (<| E.mem_layout= (m, i); E.lk = lk |> as st) ->
  (* DEBUG *)
(* TODO[newLem]  Boot.print_debug ("[Core_run.create] @" ^ (string_of_num i)) $ *)
  (* We update the memory (obviously) and we add information about the location 
     kind to the state *)
  let o = (pref, Cmm_aux.Lbase i) in
  let init = match ty with
    | Array _ n -> Cmm_aux.Marray (replicate_list Cmm_aux.Muninit n)
    | _         -> Cmm_aux.Muninit
  end in
  [(U.return o, <| st with E.mem_layout= (Map.insert o [(init, taid)] m, i+1);
                           E.lk = Map.insert o (type_to_location_kind ty) lk |>)]

(* TODO: doesn't do anything regarding the size *)
(* dynamic object allocation (malloc) *)
val alloc: list Symbol.t -> integer -> E.taction_id -> E.t Memory.mem_addr
let alloc pref _ taid = fun (<| E.mem_layout= (m, i) |> as st) ->
  (* We do not know yet what the type is, so we don't know wether it is atomic
     or nonatomic, so we can't update the location kind in the state. When the 
     location kind is not set, it is assumed to be nonatomic *)
  let o = (pref, Cmm_aux.Lbase i) in
  [(U.return o, <| st with E.mem_layout= (Map.insert o [(Cmm_aux.Muninit, taid)] m, i+1) |>)]

(* static/dynamic object deallocation *)
val kill: Memory.mem_addr -> E.t unit
let kill o = fun (<| E.mem_layout= (m, i) |> as st) ->
  (* DEBUG *)
(* TODO[newLem] Boot.print_debug ("[Core_run.kill] @" ^ (string_of_num $ snd o)) *)
  [(U.return (), <| st with E.mem_layout= (Map.delete o m, i) |> )]

val store: ctype -> Memory.mem_addr -> Cmm.cvalue -> E.taction_id -> E.t unit
let store _ o v taid = fun (<| E.mem_layout= (m, i) |> as st) ->
  (* DEBUG *)
(* TODO[newLem]   Boot.print_debug ("[Core_run.store] @" ^ (string_of_num $ snd o)) $ *)
  let values =
    match Map.lookup o m with
      | Just z  -> z
      | Nothing -> []
    end in
  (* We append the new value to the values already present in the memory *)
  [(U.return (), <| st with E.mem_layout= (Map.insert o ((v, taid)::values) m, i) |>)]

(* Loads a value (and the taction_id of the action that stored that value). When
   the location is atomic, it non-deterministically loads from any of the past 
   values. Otherwise it loads the last value. *)
val load: ctype -> Memory.mem_addr -> E.t (Cmm.cvalue * E.taction_id)
let load ty o = fun (<| E.mem_layout= (m, _) |> as st) ->
  match Map.lookup o m with
    | Just values ->
        (* DEBUG *)
        (* TODO[newLem]     Boot.print_debug ("[Core_run.load] @" ^ (string_of_num $ snd o)) $ *)
        (* Returns the last value stored in memory *)
        if E.get_location_kind st o = Cmm.Atomic then
          (* load any of the past values *)
          let reads = [(U.return (value, taid), st) | forall ((value, taid) MEM values) | value <> Cmm_aux.Muninit] in
          if reads = [] then
            (* TODO: check that this is an automatic object *)
            [(U.undef [U.Use_indeterminate_automatic_object], st)]
          else
            reads
        else
          (* load the last value *)    
          match values with
            | (value, taid)::_ ->
                [(U.return (value, taid), st)]
            | _ ->
                Boot.assert_false "Last value cannot be loaded, because there are no values."
          end
    | Nothing ->
       (* DEBUG *)
       (* TODO[newLem]     Boot.print_debug ("[Core_run.load] Not_found: @" ^ (string_of_num $ snd o)) *)
       [(U.undef [Undefined.Outside_lifetime], st)]
  end

(* ************************************************************************** *)

(* non-deterministically pick an element of a list with its context within the
   list. (e.g. pick_one [1,2,3] = [ ([],1,[2; 3]); ([1],2,[3]); ([1; 2],3,[]) ])
 *)
(* EXHAUSTIVE MODE *)
let rec _pick_one_exhaustive pred acc = function
  | []    -> []
  | x::xs -> (if pred x then fun z -> (reverse acc, x, xs) :: z else fun z -> z) $ _pick_one_exhaustive pred (x::acc) xs
end
let pick_one_exhaustive pred l = E.msum $ map E.return (_pick_one_exhaustive pred [] l)

(* RANDOM MODE *)
let rec _pick_one_random pred = function
  | [] -> Nothing
  | l  -> let (xs, y, zs) = Boot.pickList l in
          if pred y then
            Just (xs, y, zs)
          else
            match _pick_one_random pred (xs ++ zs) with
              | Just (xs', y', zs') ->
                let n  = List.length xs  in
                let n' = List.length xs' in
                if n' < n then
                  let (a, b) = splitAt (n - n' - 1) zs' in
                  Just (xs', y', a ++ (y :: b))
                else
                  let (a, b) = splitAt n xs' in
                  Just (a ++ (y :: b), y', zs')
              | Nothing ->
                  Nothing
            end
end
let pick_one_random pred l = fun s ->
  match _pick_one_random pred l with
    | Just x  -> [(U.return x, s)]
    | Nothing -> []
  end

val pick_one: forall 'a. ('a -> bool) -> list 'a -> E.t (list 'a * 'a * list 'a)
let pick_one pred l =
  E.get_execution_mode >>= function
    | E.Exhaustive -> pick_one_exhaustive pred l
    | E.Random     -> pick_one_random pred l
  end








(* mutate the rule descriptor of the most recent trace element (used by
   inductive rule after application of their premises) *)
(*
val update_rule: (dyn_rule -> dyn_rule) -> E.t unit
let update_rule f = fun (<| E.trace= t |> as s) ->
  match t with
    | []               -> Boot.outOfHomeomorphism "[Core_run.update_rule] empty trace"
    | (r, bs_a) :: ts  -> [((), <| s with E.trace= (f r, bs_a) :: ts |>)]
  end
*)







(*
val put_syms: list (maybe sym) -> expr E.taction_id -> E.t unit
let put_syms _as v =
  match (_as, v) with
    | ([]       , _        ) -> E.return ()
    | ([Nothing], _        ) -> E.return ()
    | ([Just _a], _        ) -> E.put_sym _a v
    | (_        , Etuple vs) -> E.mapM_ (fun (_a_opt, v) -> match _a_opt with Just _a -> E.put_sym _a v| Nothing -> E.return () end) (List.combine _as vs)
    | (_        , Eunseq vs) -> E.mapM_ (fun (_a_opt, v) -> match _a_opt with Just _a -> E.put_sym _a v| Nothing -> E.return () end) (List.combine _as vs)
  end 
*)


(* takes the symbolic names of a function, some pure expressions and produce
   the function body where the arguments have been substituted *)
val call_function: forall 'a. file 'a -> name -> list (expr 'a) -> expr 'a
let call_function file fname args =
  let (_, params, fbody) =
    match fname with
      | Sym  f ->
          match Map.lookup f file.stdlib with
            | Just z  -> z
            | Nothing -> fromJust $ Map.lookup f file.funs
          end
      | Impl f ->
          match Map.lookup f file.impl with
            | Just (IFun bty fargs fbody) ->
                (TyBase bty, fargs, fbody)
            | _ ->
                Boot.assert_false "[Core_run.call_function] found a Def used as an IFun"
          end
    end in
  if List.length params <> List.length args then
    Boot.assert_false $ "[Core_run.call_function] wrong number of args applied to `" (* TODO[newLem] ^
      Boot.pp_core_expr (match fname with Impl f -> Eimpl f | Sym f -> Esym f end) ^ "'" *)
  else
    (Global.foldl2 (fun acc (_a, _) arg -> subst_sym _a arg acc) fbody params args)


val call_proc: sym -> list (expr E.taction_id) -> E.t (expr E.taction_id)
let call_proc psym args =
  E.get_proc psym >>= fun (_, params, fbody) ->
  if List.length params <> List.length args then
    Boot.assert_false $ "[Core_run.call_proc] wrong number of args applied to `" (* TODO[newLem] ^ Boot.pp_core_expr (Esym psym) ^ "'" *)
  else
    E.set_current_proc psym >>
    E.return (Global.foldl2 (fun acc (_a, _) arg -> subst_sym _a arg acc) fbody params args)




let rec collect_values v =
  match v with
    | Etuple vs -> let vss = List.map collect_values vs in
                   List.concat vss
    | _         -> [v]
  end


(* evaluation of pure epxressions (will crash on ill-typed and/or non pure
   expressions) *)
open U
val     eval: forall 'a. file 'a -> expr 'a -> U.t (expr 'a)
let rec eval file pe =
  let eval = eval file in
  match pe with
    | Eundef u -> U.undef [u]
    | Eerror   -> U.error
    | Eop binop pe1 pe2 ->
        eval pe1 >>= fun v1 ->
        eval pe2 >>= fun v2 ->
        U.return
          match (binop, v1, v2) with
            | (OpAdd, Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> Econst (Cmm_aux.Cint $ n1 + n2)
            | (OpSub, Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> Econst (Cmm_aux.Cint $ n1 - n2)
            | (OpMul, Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> Econst (Cmm_aux.Cint $ n1 - n2)
            | (OpDiv, Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> Econst (Cmm_aux.Cint $ n1 div n2)
            | (OpMod, Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> Econst (Cmm_aux.Cint $ n1 mod n2)
            | (OpEq,  Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> if n1  = n2  then Etrue else Efalse
            | (OpEq,  Ectype ty1,       Ectype ty2       ) -> if ty1 = ty2 then Etrue else Efalse
            | (OpLt,  Econst (Cmm_aux.Cint n1), Econst (Cmm_aux.Cint n2) ) -> if n1  < n2  then Etrue else Efalse
            | (OpOr,  Efalse,           Efalse           ) -> Efalse
            | (OpOr,  _,                _                ) -> Etrue
            | (OpAnd, Etrue,            Etrue            ) -> Etrue
            | (OpAnd, _,                _                ) -> Efalse
            | (_,     v1,               v2               ) -> Boot.assert_false $ "[Core_run.eval] unmatched Eop: " (* TODO[newLem] ^ Boot.pp_core_expr (Eop binop v1 v2) *)
          end
    | Enot pe ->
        eval pe >>= function
          | Etrue  -> U.return Efalse
          | Efalse -> U.return Etrue
        end
    | Elet _a pe1 pe2 ->
        eval pe1 >>= fun v1 ->
        eval (subst_sym _a v1 pe2)
    | Eif pe1 pe2 pe3 ->
        eval pe1 >>= function
          | Etrue  -> eval pe2
          | Efalse -> eval pe3
        end
    | Ecall f pes -> eval (call_function file f pes)



(* TODO: this may be very counter-intuitive, but we have it as a hack to remove skips comming from negative actions

==> probably need some trick during typing

*)
    | Eunseq pes ->
        U.mapM eval pes >>= fun vs ->
        U.return
          match (* List.filter (fun (Left v) -> v <> Eskip) $ *) vs with
            | []  -> Etuple [] (* HACK: better had a Eunit ctor *)
            | [v] -> v
            | vs  -> Etuple vs
          end

(*
        match List.filter (function Left _ -> false | Right _ -> true end) vs with
        | [] -> match (* List.filter (fun (Left v) -> v <> Eskip) $ *) vs with
                  | []       -> Left (Etuple []) (* HACK: better had a Eunit ctor *)
                  | [Left v] -> Left v
                  | vs       -> Left (Etuple $ List.map (fun (Left v) -> v) vs)
                end
        | vs' -> Right $ List.fold_left (fun acc (Right us) -> us ++ acc) [] vs'
      end
*)
    
    | Ewseq _as pe1 pe2 ->
        eval pe1 >>= fun v1 ->
        eval (subst_syms _as v1 pe2)
    
    
(* TODO: temporary *)
  | Eis_scalar pe ->
      eval pe >>= fun (Ectype ty) ->
      U.return (if AilTypesAux.scalar (unproj_ctype ty) then Etrue else Efalse)
  | Eis_integer pe ->
      eval pe >>= fun (Ectype ty) ->
      U.return (if AilTypesAux.integer (unproj_ctype ty) then Etrue else Efalse)
  | Eis_signed pe ->
      eval pe >>= fun (Ectype ty) ->
      U.return (if AilTypesAux.is_signed_integer_type (unproj_ctype ty) then Etrue else Efalse)
  | Eis_unsigned pe ->
      eval pe >>= fun (Ectype ty) ->
      U.return (if AilTypesAux.is_unsigned_integer_type (unproj_ctype ty) then Etrue else Efalse)
    
    
    (* If [pe] is not pure this is wrong, we should crash instead *)
    | _ -> if is_value pe then U.return pe else Boot.assert_false $ "[Core_run.eval] found an impure expression or a symbol: " (* TODO[newLem] ^ Boot.pp_core_expr pe *)
  end


val get_address: forall 'a. expr 'a -> E.t Memory.mem_addr
let get_address = function 
  | Eaddr o -> E.return o
  | _       -> E.runU $ U.undef [Undefined.Lvalue_not_an_object]
  end


(* TODO: this function will call the implementation of a given action in a
         particular memory model *)
open Operators

val perform_create: set E.taction_id -> Cmm.tid -> expr E.taction_id -> list Symbol.t ->
                    E.t (E.taction_id * expr E.taction_id)
let perform_create bs tid_ pe pref = 
  E.get_file                            >>= fun file        ->
  let eval = eval file in
  let tid = Cmm_aux.canonize_tid tid_ in
  (* perform the create *)
  E.runU (eval pe)                      >>= fun (Ectype ty) ->
  get_new_taid                          >>= fun new_taid    ->
  create pref ty new_taid               >>= fun o           ->
  (* update the state with the new trace action *)
  add_tact new_taid (E.Tcreate ty o tid)  >>
  E.register_sequencing bs new_taid tid >>
  E.return (new_taid, Eaddr o)

val perform_alloc: set E.taction_id -> Cmm.tid -> expr E.taction_id -> list Symbol.t ->
                   E.t (E.taction_id * expr E.taction_id)
let perform_alloc bs tid_ pe pref = 
  E.get_file                            >>= fun file              ->
  let eval = eval file in
  let tid = Cmm_aux.canonize_tid tid_ in
  (* perform the alloc *)
  E.runU (eval pe)                      >>= fun (Econst (Cmm_aux.Cint n)) ->
  get_new_taid                          >>= fun new_taid          ->
  alloc pref n new_taid                 >>= fun o                 ->
  (* update the state with the new trace action *)
  add_tact new_taid (E.Talloc n o tid)    >>
  E.register_sequencing bs new_taid tid >>
  E.return (new_taid, Eaddr o)

val perform_kill: set E.taction_id -> Cmm.tid -> expr E.taction_id -> E.t (E.taction_id * expr E.taction_id)
let perform_kill bs tid_ pe = 
  E.get_file                            >>= fun file      ->
  let eval = eval file in
  let tid = Cmm_aux.canonize_tid tid_ in
  (* perform the kill *)
  E.runU (eval pe)                      >>= fun (Eaddr o) ->
  kill o                                >>
  (* update the state with the new trace action *)
  get_new_taid                          >>= fun new_taid  ->
  add_tact new_taid (E.Tkill o tid)       >>
  E.register_sequencing bs new_taid tid >>
  E.return (new_taid, Enull)

val perform_store: set E.taction_id -> Cmm.tid -> expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> 
                   Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_store bs tid_ pe1 pe2 pe3 mo = 
  E.get_file                                   >>= fun file        ->
  let eval = eval file in
  let tid = Cmm_aux.canonize_tid tid_ in
  (* perform the store *)
  E.runU (eval pe1)                            >>= fun (Ectype ty) ->
  E.runU (eval pe2)                            >>= fun expr        ->
  get_address expr                             >>= fun o           ->
  E.runU (eval pe3)                            >>= function
   | Econst c -> E.return (Cmm_aux.Mbase c, Enull)
   | Eaddr o' -> E.return (Cmm_aux.Mobj o', Enull)
   | Enull    -> E.return (Cmm_aux.Mnull,   Eskip)
   | v        -> Boot.assert_false $
                 "[Core_run.perform_action, Kstore] " (* TODO[newLem] ^
                 (Boot.pp_core_expr pe3) ^
                 " ==> " ^ (Boot.pp_core_expr v) *)
   end                                         >>= fun (value, e)  ->
  get_new_taid                                 >>= fun new_taid    ->
  store ty o value new_taid                    >>
  (* update the state with the new trace action *)
  add_tact new_taid (E.Tstore ty o value mo tid) >>
  E.register_sequencing bs new_taid tid          >>
  E.is_atomic_location o                         >>= fun is_atomic   ->
  (if is_atomic then
     (if mo = Cmm.Seq_cst then
        push_sc_action new_taid
      else
        E.return ()
      )                                        >>
     push_mod_order o new_taid
   else 
     E.return ()
   )                                           >>
  (* Discard inconsistent states *)
  (if is_atomic then
     discard_CoWW_states new_taid              >>
     discard_inconsistent_sc_writes new_taid
   else 
     E.return ()
   )                                           >>
  (* Check for undefined behaviour *)
  (* TODO: For NA we can check for dataraces more efficiently *)
  check_for_dataraces                          >>
  E.return (new_taid, e)

val perform_load: set E.taction_id -> Cmm.tid -> expr E.taction_id -> expr E.taction_id -> 
                   Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_load bs tid_ pe1 pe2 mo = 
  E.get_file                                  >>= fun file                ->
  let eval = eval file in
  let tid = Cmm_aux.canonize_tid tid_ in
  (* perform the load *)
  E.runU (eval pe1)                           >>= fun (Ectype ty)         ->
  E.runU (eval pe2)                           >>= fun expr                ->
  get_address expr                            >>= fun o                   ->
  load ty o                                   >>= fun (value, store_taid) ->
  (* update the state with the new trace action *)   
  get_new_taid                                >>= fun new_taid            ->
  add_tact new_taid (E.Tload ty o value mo tid) >>  
  E.is_atomic_location o                      >>= fun is_atomic           ->
  (if mo = Cmm.Seq_cst then
     push_sc_action new_taid
   else
     E.return ()
   )                                          >>
  push_rf store_taid new_taid                 >>   
  E.register_sequencing bs new_taid tid       >>          
  (* Discard inconsistent states *)
  (if is_atomic then
     discard_CoWR_states store_taid new_taid  >>
     discard_inconsistent_sc_reads store_taid new_taid
   else
     E.return ()
   )                                          >>
  (* Check for undefined behaviour *)
  (* TODO: For NA we can check for dataraces more efficiently *)
  check_for_dataraces                         >> 
  (* Return *)
  match value with
   | Cmm_aux.Mbase v -> E.return (Econst v)
   | Cmm_aux.Mobj v  -> E.return (Eaddr v)
   | Cmm_aux.Muninit  -> Boot.print_debug "READ AN UNINIT" $
                        E.return (Econst $ Cmm_aux.Cint (~ 10))
  end                                         >>= fun e                   ->
  E.return (new_taid, e)

val perform_compare_exchange: (Cmm.cvalue -> Cmm.cvalue -> E.t bool) ->
               set E.taction_id -> Cmm.tid -> expr E.taction_id ->
               expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> Cmm.memory_order ->
               Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_compare_exchange cmp bs tid_ pe_ty pe_o pe_expected pe_desired mo_succes mo_failure = 
  E.get_file                                                          >>= fun file                       ->
  let eval = eval file in
  let tid = Cmm_aux.canonize_tid tid_ in
  (* We first load (NA) from pe_expected *)
  perform_load bs tid_ pe_ty pe_expected Cmm.NA                       >>= fun (na_load_taid, expected_e) ->
  let expected_v = match expected_e with
   | Econst c -> Cmm_aux.Mbase c
   | Eaddr o' -> Cmm_aux.Mobj o'
   | Enull    -> Cmm_aux.Mnull
  end in
  (* We (atomically load from the object *)
  E.runU (eval pe_ty)                                                 >>= fun (Ectype ty)                ->
  let atomic_ty = Atomic ty in
  E.runU (eval pe_o)                                                  >>= get_address >>= fun o          ->
  E.runU (eval pe_desired)                                            >>= fun desired_e                  ->
  let desired_v = match desired_e with
   | Econst c -> Cmm_aux.Mbase c
   | Eaddr o' -> Cmm_aux.Mobj o'
   | Enull    -> Cmm_aux.Mnull
  end in
  (* The new_taid will be the taid of RMW if it succeeds and of the load otherwise *)
  get_new_taid                                                        >>= fun new_taid                   -> 
  load atomic_ty o                                                    >>= fun (actual_v, store_taid)     ->
  (* We decide whether it is a succes or failure *)
  cmp actual_v expected_v                                             >>= fun is_success                  ->
  if is_success then
     (* Success: we store the desired value *)
     store atomic_ty o desired_v new_taid                             >>
     (* We omit an RMW event (for the store and the previous load *)
     let tact = E.Trmw atomic_ty o actual_v desired_v mo_succes tid in
     add_tact new_taid tact                                           >>  
     E.is_atomic_location o                                           >>= fun is_atomic                  -> 
     (if is_atomic then 
        (if mo_succes = Cmm.Seq_cst then
           push_sc_action new_taid
         else
           E.return ()
         )                                                            >>
        mod_order_insert_after o store_taid new_taid
      else 
        E.return ()
      )                                                               >>
     push_rf store_taid new_taid                                      >>   
     E.register_sequencing {na_load_taid} new_taid tid                >>          
     (* Discard inconsistent states *)
     (if is_atomic then
        discard_CoWW_states new_taid                                  >>
        discard_CoWR_states store_taid new_taid                       >>
        discard_inconsistent_sc_writes new_taid                       >>
        discard_inconsistent_sc_reads store_taid new_taid
      else
        E.return ()
      )                                                               >>
     (* Check for undefined behaviour *)
     check_for_dataraces                                              >> 
     E.return (new_taid, Econst (Cmm_aux.Cint 1))
  else
     (* Failure: we omit a load event for the load we just did *)
     add_tact new_taid (E.Tload atomic_ty o actual_v mo_failure tid)    >>  
     E.is_atomic_location o                                             >>= fun is_atomic                  ->  
     (if mo_failure = Cmm.Seq_cst then
        push_sc_action new_taid
      else
        E.return ()
      )                                                               >>
     push_rf store_taid new_taid                                      >>   
     E.register_sequencing {na_load_taid} new_taid tid                >>          
     (* Discard inconsistent states *)
     (if is_atomic then
        discard_CoWR_states store_taid new_taid                       >>
        discard_inconsistent_sc_reads store_taid new_taid
      else
        E.return ()
      )                                                               >>
     (* Check for undefined behaviour *)
     check_for_dataraces                                              >> 
     (* We store (NA) the actual value back to pe_expected *)
     let actual_e = match actual_v with
      | Cmm_aux.Mbase c -> Econst c
      | Cmm_aux.Mobj o' -> Eaddr o'
      | Cmm_aux.Mnull   -> Enull
     end in
     perform_store {new_taid} tid_ pe_ty pe_expected actual_e  Cmm.NA >>= fun (na_store_aid, _)          ->
     E.return (na_store_aid, Econst (Cmm_aux.Cint 0))

val perform_compare_exchange_strong: set E.taction_id -> Cmm.tid -> expr E.taction_id ->
               expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> Cmm.memory_order ->
               Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_compare_exchange_strong bs tid pe1 pe2 pe3 pe4 mo1 mo2 = 
  let cmp v1 v2 = E.return (v1 = v2) in
  perform_compare_exchange cmp bs tid pe1 pe2 pe3 pe4 mo1 mo2
  
val perform_compare_exchange_weak: set E.taction_id -> Cmm.tid -> expr E.taction_id ->
               expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> Cmm.memory_order ->
               Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_compare_exchange_weak bs tid pe1 pe2 pe3 pe4 mo1 mo2 = 
  let cmp v1 v2 = fun st ->
  if v1 = v2 then
    [(U.return true, st); (U.return false, st)]
  else
    [(U.return false, st)] in
  perform_compare_exchange cmp bs tid pe1 pe2 pe3 pe4 mo1 mo2

val perform_action: set E.taction_id -> action_ E.taction_id -> Cmm.tid -> E.t (E.taction_id * expr E.taction_id)
let perform_action bs act tid =
  match act with
    | Create pe pref                                -> perform_create bs tid pe pref
    | Alloc pe pref                                 -> perform_alloc bs tid pe pref
    | Kill pe                                       -> perform_kill bs tid pe
    | Store pe1 pe2 pe3 mo                          -> perform_store bs tid pe1 pe2 pe3 mo
    | Load pe1 pe2 mo                               -> perform_load bs tid pe1 pe2 mo
    | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 -> 
          perform_compare_exchange_strong bs tid pe1 pe2 pe3 pe4 mo1 mo2
    | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2   -> 
          perform_compare_exchange_weak bs tid pe1 pe2 pe3 pe4 mo1 mo2
  end



(* NOTE: the assumption is made that an Eunseq cannot directly be the
         subexpression of an another Eunseq *)

let red2_pos x =
  match x with
    | (Eaction (Paction Pos (Action bs a)), tid, _KS) ->
        perform_action bs a tid                       >>= fun (aid, v) ->
        push_trace (E.Rule_Pos, Just (bs, aid)) >>
        E.return (v, tid, annotate (Pos, aid) _KS)
    | _ -> E.mzero
  end

let red2_neg x =
  match x with
    | (Eaction (Paction Neg (Action bs a)), tid, _KS) ->
        perform_action bs a tid                       >>= fun (aid, v)   ->
        push_trace (E.Rule_Neg, Just (bs, aid)) >>
        E.return (v, tid, annotate (Neg, aid) _KS)
    | _ -> E.mzero
  end 

let red2_pure x =
  match x with
    | (e, tid, [] :: _KS) ->
        if is_pure e then
          push_trace (E.Rule_Pure_Hole, Nothing) >>
          E.get_file                     >>= fun file ->
          E.runU (eval file e)           >>= fun v    ->
          E.return (v, Cmm_aux.Tzero, _KS)
        else
          E.mzero
    | (e, tid, _K :: _KS) ->
        if is_pure e then
          push_trace (E.Rule_Pure, Nothing) >>
          E.get_file                >>= fun file ->
          E.runU (eval file e)      >>= fun v    ->
          E.return (apply_cont _K v, Cmm_aux.Tzero, [] :: _KS)
        else
          E.mzero
    | _ -> E.mzero
  end

let red2_if x =
  match x with
    | (Eif pe e2 e3, tid, _KS) ->
        E.get_file            >>= fun file ->
        E.runU (eval file pe) >>= function
          | Etrue  -> push_trace (E.Rule_If, Nothing) >> E.return (e2, tid, _KS)
          | Efalse -> push_trace (E.Rule_If, Nothing) >> E.return (e3, tid, _KS)
        end
    | _ -> E.mzero
  end

let red2_let x =
  match x with
    | (Elet _a pe1 e2, tid, _KS) ->
        E.get_file               >>= fun file ->
        E.runU (eval file pe1)   >>= fun v1      ->
        push_trace (E.Rule_Let, Nothing) >> E.return (subst_sym _a v1 e2, tid, _KS)
    | _ -> E.mzero
  end

let red2_ret x =
  match x with
    | (Eret pe, tid, _K :: _KS) ->
          push_trace (E.Rule_Ret, Nothing) >>
          E.get_file               >>= fun file ->
          E.runU (eval file pe)    >>= fun v    ->
          E.return (v, tid, _KS)


(*
        if is_value e then
          eval e                      >>= fun v ->
          push_trace (E.Rule_Ret, Nothing) >>
(*          E.pop_syms >> *)
          E.return (v, _KS)
        else 
          E.mzero
*)
    | _ -> E.mzero
  end

(*
let red2_shift x =
  match x with
    | (Eshift pe1 pe2, tid, _KS) ->
        KKK
*)

let red2_skip x =
  match x with
    | (Eskip, tid, [Kwseq _ e2] :: _KS) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, [] :: _KS)
    | (Eskip, tid, (Kwseq _ e2 :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, _KS1 :: _KS2)

    | (Eskip, tid, [Ksseq _ e2] :: _KS) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, [] :: _KS)
    | (Eskip, tid, (Ksseq _ e2 :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, _KS1 :: _KS2)

    | (Eskip, tid, ((Kunseq es1 es2) :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return
          (match es1 ++ es2 with
             | []  -> Etuple []
             | [e] -> e
             | es  -> Eunseq es
           end, tid, _KS1 :: _KS2)

(*
    | (Eskip, ((Kpar es1 es2) :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return
          (match es1 ++ es2 with
             | []  -> Eskip
             | [e] -> e
             | es  -> Epar es
           end, _KS1 :: _KS2)
*)

(*    | (Eskip, _K :: _KS) -> push_trace (E.Rule_Skip, Nothing) >> E.return (apply_cont _K Eskip, _KS) *)
    | _                       -> E.mzero
  end


let red2_proc x =
  match x with
    | (Eproc bs f es, tid, _KS) ->
        push_trace (E.Rule_Proc, Nothing)   >>
        E.get_file                     >>= fun file    ->
        E.runU (U.mapM (eval file) es) >>= fun vs      ->
        call_proc f vs                 >>= fun f_body  ->
(*
Boot.print_debug (Boot.pp_core_expr (Core.Etuple es)) $
Boot.print_debug (Boot.pp_core_expr f_body) $
*)

(* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
        E.return (Set_helpers.fold (fun b e -> annotate_expr (Pos, b) e) bs f_body, tid, [] :: _KS)
    | _ -> E.mzero
  end


let red2_wseq x =
  match x with
    | (Ewseq _ (Eaction (Paction Neg b)) e2, tid, _KS) ->
        E.mzero (* Leaving it to red2_neg_wseq *)
    | (Ewseq _as e1 e2, tid, _KS) ->
        push_trace (E.Rule_Wseq, Nothing) >>
          if is_pure e1 then
            E.get_file            >>= fun file ->
            E.runU (eval file e1) >>= fun v1      ->
            Boot.print_debug ("IS_PURE: " ^ Boot.pp_core_expr v1) $
            E.return (subst_syms _as v1 e2, Cmm_aux.Tseq tid, _KS)
          else match _KS with
            | _K :: _KS -> E.return (e1, Cmm_aux.Tseq tid, (Kwseq _as e2 :: _K) :: _KS)
            | []        -> E.return (e1, Cmm_aux.Tseq tid, [[Kwseq _as e2]])
          end
    | _ -> E.mzero
  end 

let red2_neg_wseq x =
  match x with
    | (Ewseq _ (Eaction (Paction Neg b)) e2, tid, _KS) ->
        push_trace (E.Rule_Wseq_Neg, Nothing) >>
        E.return match e2 with
          | Eunseq e2's -> (Eunseq $ (Eaction (Paction Neg b)) :: e2's, Cmm_aux.Tseq tid, _KS)
          | _           -> (Eunseq [Eaction (Paction Neg b); e2], Cmm_aux.Tseq tid, _KS)
        end
    | (Ewseq _as (Eunseq es) e2, tid, _KS) ->
        pick_one (is_negative) es >>= function
               (* TODO: there is a hack here: the symbol corresponding to ej should be dropped from ej, instead of adding a skip dans the first unseq (...) *)
          | (es1, Eaction (Paction Neg b), es2) ->
              push_trace (E.Rule_Wseq_Neg, Nothing) >>
              E.return match e2 with
                | Eunseq e2's -> (Ewseq _as (Eunseq $ es1 ++ (Eskip :: es2)) (Eunseq $ Eaction (Paction Neg b) :: e2's), Cmm_aux.Tseq tid, _KS)
                | _           -> (Ewseq _as (Eunseq $ es1 ++ (Eskip :: es2)) (Eunseq [Eaction (Paction Neg b); e2]), Cmm_aux.Tseq tid, _KS)
              end
          | _ -> Boot.assert_false "[Core_run.red2_neg_wseq] impossible"
        end
    | _ -> E.mzero
end


let red2_sseq x =
  match x with
    | (Esseq _as e1 e2, tid, _KS) ->
        push_trace (E.Rule_Sseq, Nothing) >>
          if is_pure e1 then
            E.get_file            >>= fun file ->
            E.runU (eval file e1) >>= fun v1      ->
            Boot.print_debug ("IS_PURE: " ^ Boot.pp_core_expr e1) $
            E.return (subst_syms _as v1 e2, Cmm_aux.Tseq tid, _KS)
          else match _KS with
            | _K :: _KS -> E.return (e1, Cmm_aux.Tseq tid, (Ksseq _as e2 :: _K) :: _KS)
            | []        -> E.return (e1, Cmm_aux.Tseq tid, [[Ksseq _as e2]])
          end
    | _ -> E.mzero
  end

(* TODO: check that rule, nothing fancy should be needed, since we don't allow
         save/run inside unseq expressions *)
let red2_unseq x =
  match x with
    | (Eunseq es, tid, _K :: _KS) ->
        pick_one (not -| is_pure) es >>= fun (es1, ej, es2) ->
          Boot.print_debug ("ej = " ^ Boot.pp_core_expr ej) $ 
          push_trace (E.Rule_Unseq, Nothing) >>
          E.return (ej, tid, (Kunseq es1 es2 :: _K) :: _KS)
    | _ -> E.mzero
  end

let red2_run x =
  match x with
    | (Erun bs d a_vs, tid, _K :: _KS) ->
        E.get_cont d >>= fun (a_tys, e_cont) ->
        push_trace (E.Rule_Run, Nothing) >>
        (* we have to create the objects which are visible at the level of the save but not from the run *)
        let (create_as, create_tys) = unzip $ List.filter (fun (a,_) -> not (any (fun (x,_) -> x = a) a_vs)) a_tys in
        (* symmetrically, we have to kill the objects which are visible at the level of the run but not from the save.*)
        let kill_es = List.map snd $ List.filter (fun (a,_) -> not (any (fun (x,_) -> x = a) a_tys)) a_vs in
        let e =
          Ewseq [] (mk_unseq $ List.map (fun e -> pkill e) kill_es)
            (Ewseq (List.map (fun z -> Just z) create_as) (mk_unseq $ List.map (fun ty -> pcreate (Ectype ty) []) create_tys)
               (foldl (fun acc (a, v) -> subst_sym a v acc) e_cont a_vs)) in
        (* TODO: it seems strange that annotate_expr need to know the polarity *)
        E.return (Set_helpers.fold (fun b e -> annotate_expr (Pos, b) e) bs e, tid, [] :: _KS)
    | _ -> E.mzero
  end

let red2_save x =
  match x with
    | (Esave _ _ e, tid, _KS) ->
        push_trace (E.Rule_Save, Nothing) >>
        E.return (e, tid, _KS)
    | _ -> E.mzero
  end

let red2_par x =
  match x with
    | (Epar es, tid, _K :: _KS) ->
      push_trace (E.Rule_Par, Nothing) >>
      if all is_pure es then
        E.get_file                     >>= fun file ->
        E.runU (U.mapM (eval file) es) >>= fun vs   ->
        E.return (Etuple vs, tid, _K :: _KS)
      else
        pick_one (not -| is_pure) es >>= fun (es1, ej, es2) ->
        Boot.print_debug ("ej = " ^ Boot.pp_core_expr ej) $ 
        E.return (ej, Cmm_aux.Tpar (List.length es1 + 1) tid, (Kpar es1 es2 :: _K) :: _KS)
    | _ -> E.mzero
  end

let red2_nd x =
  match x with
    | (End es, tid, _KS) ->
        pick_one (fun _ -> true) es >>= fun (_, ej, _) ->
        push_trace (E.Rule_ND, Nothing)  >>
        E.return (ej, tid, _KS)
    | _ -> E.mzero
  end

val red2:      expr E.taction_id * Cmm.tid * list (cont E.taction_id) ->
          E.t (expr E.taction_id * Cmm.tid * list (cont E.taction_id))
let red2 e =
  E.dmsum [
    red2_pure e; red2_skip e;
    E.msum [
      red2_pos e; red2_neg e; red2_unseq e;
      red2_if e; red2_let e; red2_ret e;
      red2_proc e;
      red2_wseq e; red2_neg_wseq e;
      red2_sseq e;
      red2_run e; red2_save e;
      red2_par e; red2_nd e
    ]
  ]

val star_red2:       expr E.taction_id * Cmm.tid * list (cont E.taction_id) ->
               E.t ((expr E.taction_id * Cmm.tid * list (cont E.taction_id)) *
                       (Map.map E.taction_id E.trace_action * E.trace))
let rec star_red2 x =
  let continue =
    red2 x >>= fun (e, tid, _K) ->
(* BEGIN: DEBUG *)
    get_trace >>= fun (r, _) ->
    Boot.print_debug (E.string_of_rule r ^ " ==>\nE= " ^
                     (Boot.pp_core_expr e) ^ "\nKS= " ^
                     (foldl (fun acc k -> acc ^ string_of_cont k ^ "\n\n") "" $ _K) ^
                     "\n----------------------------------\n\n")



(* END: DEBUG *)
   star_red2 (e, tid, _K)
in
  match x with
    | (e, tid, []) ->
        if is_pure e then
          get_fulltrace        >>= fun (tact_map, t) ->
          E.get_file           >>= fun file          ->
          E.runU (eval file e) >>= fun v             ->
          E.return ((v, tid, []), (tact_map, t))
        else
          continue
    
    | _ -> continue
  end







(* Dummy function doing nothing, but required to typecheck *)
val     convert_expr: forall 'a. expr 'a -> expr E.taction_id
let rec convert_expr e =
  match e with
    | Eskip               -> Eskip
    | Etuple es           -> Etuple (List.map convert_expr es)
    | Enull               -> Enull
    | Econst c            -> Econst c
    | Eimpl i             -> Eimpl i
    | Eaddr o             -> Eaddr o
    | Esym a              -> Esym a
    | Etrue               -> Etrue
    | Efalse              -> Efalse
    | Ectype ty           -> Ectype ty
    | Eundef u            -> Eundef u
    | Eerror              -> Eerror
    | Eop op e1 e2        -> Eop op (convert_expr e1) (convert_expr e2)
    | Enot e              -> Enot (convert_expr e)
    | Elet a e1 e2        -> Elet a (convert_expr e1) (convert_expr e2)
    | Eif e1 e2 e3        -> Eif (convert_expr e1) (convert_expr e2) (convert_expr e3)
    | Ecall f args        -> Ecall f (List.map convert_expr args)
    | Eproc bs f args     -> Eproc {} f (List.map convert_expr args)
    | Eaction a           -> Eaction (convert_paction a)
    | Eunseq es           -> Eunseq (List.map convert_expr es)
    | Epar es             -> Epar (List.map convert_expr es)
    | End es              -> End (List.map convert_expr es)
    | Ewseq _as e1 e2     -> Ewseq _as (convert_expr e1) (convert_expr e2)
    | Esseq _as e1 e2     -> Esseq _as (convert_expr e1) (convert_expr e2)
    | Easeq a b u         -> Easeq a (convert_action b) (convert_paction u)
    | Eindet e            -> Eindet (convert_expr e)
    | Ebound i e          -> Ebound i (convert_expr e)
    | Esame e1 e2         -> Esame (convert_expr e1) (convert_expr e2)
    | Esave k a_tys e     -> Esave k a_tys (convert_expr e)
    | Erun bs k a_vs      -> Erun {} k (List.map (fun (a,v) -> (a, convert_expr v)) a_vs)
    | Eret e              -> Eret (convert_expr e)
    | Eshift e1 e2        -> Eshift (convert_expr e1) (convert_expr e2)

(* TODO: temporary *)
    | Eis_scalar e   -> Eis_scalar (convert_expr e)
    | Eis_integer e  -> Eis_integer (convert_expr e)
    | Eis_signed e   -> Eis_signed (convert_expr e)
    | Eis_unsigned e -> Eis_unsigned (convert_expr e)
  end

and convert_paction pa =
  match pa with
    | Paction p a -> Paction p (convert_action a)
  end
and convert_action a =
  match a with
    | Action _ a_ -> Action {} (convert_action_ a_)
  end
and convert_action_ a =
  match a with
    | Create ty pref  -> Create (convert_expr ty) pref
    | Alloc n pref    -> Alloc (convert_expr n) pref
    | Kill e          -> Kill (convert_expr e)
    | Store ty o v mo -> Store (convert_expr ty) (convert_expr o) (convert_expr v) mo
    | Load ty o mo    -> Load (convert_expr ty) (convert_expr o) mo
    | CompareExchangeStrong ty obj expected desired mo1 mo2 ->
        CompareExchangeStrong (convert_expr ty) (convert_expr obj) (convert_expr expected) (convert_expr desired) mo1 mo2
    | CompareExchangeWeak ty obj expected desired mo1 mo2 ->
        CompareExchangeWeak (convert_expr ty) (convert_expr obj) (convert_expr expected) (convert_expr desired) mo1 mo2
  end


val convert_file: forall 'a. file 'a -> file E.taction_id
let convert_file file = <|
  main=   file.main;
  stdlib= Map.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) file.stdlib;
  impl=   Map.map (function
            | Def bty e       -> Def bty (convert_expr e)
            | IFun bty args e -> IFun bty args (convert_expr e)
          end) file.impl;
  funs=   Map.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) file.funs
 |>
(* TODO: this version doesn't typecheck (says that 'a should be num), ask the lem people if it is normal *)
(*
<| file with
  impl= Map.map (function
          | Def bty e       -> Def bty (convert_expr e)
          | IFun bty args e -> IFun bty args (convert_expr e)
        end) file.impl;
  funs= Map.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) file.funs
 |>
*)




(* TODO: make sure that labels symbolic names are unique over a whole program, otherwise
         we may jump outside of functions ... *)
(* val     populate_cont_map: sym -> expr E.taction_id -> E.t unit *)

module St = State
open State_operators

type collect_conts_state = <|
  bound_syms: set sym;
  conts: map ksym (list (sym * ctype) * expr E.taction_id)
|>

(* val     collect_cont: expr E.taction_id -> St.t (Map.map ksym (expr E.taction_id * list sym)) (Map.map ksym (expr E.taction_id * list sym)) *)

(*
val     collect_conts: expr E.taction_id -> St.t unit collect_conts_state
let rec collect_conts e =
  let save_cont d k =
    St.update (fun s ->
          <| s with conts= Map.insert d (* (free_syms e \ s.bound_syms *) k s.conts |>
        ) in
(*
  let save_syms _as =
    St.update (fun s ->
          <| s with bound_syms= s.bound_syms union _as |>
        ) in
*)
  match e with
    (* this is the only place where something actually happens *)
    | Esave d a_tys e ->
        save_cont d (a_tys, e) >>
        collect_conts e
    | Elet a _ e2 ->
(*        save_syms {a} >> *)
        collect_conts e2
    | Eif _ e2 e3 ->
        collect_conts e2 >>
        collect_conts e3
    | Ewseq _as e1 e2 ->
(*        save_syms (set_from_options _as) >> *)
        collect_conts e1 >>
        collect_conts e2
    | Esseq _as e1 e2 ->
(*        save_syms (set_from_options _as) >> *)
        collect_conts e1 >>
        collect_conts e2
    | End es ->
        St.mapM_ collect_conts es
    
    (* by syntactic constraints, we know that under these ctors there can be no labeled
       continuations *)
    | Etuple _ ->
        St.return ()
    | Enull ->
        St.return ()
    | Eskip ->
        St.return ()
    | Econst _ ->
        St.return ()
    | Eimpl _ ->
        St.return ()
    | Eaddr _ ->
        St.return ()
    | Esym _ ->
        St.return ()
    | Eop _ _ _ ->
        St.return ()
    | Etrue ->
        St.return ()
    | Efalse ->
        St.return ()
    | Enot _ ->
        St.return ()
    | Ectype _ ->
        St.return ()
    | Ecall _ _ ->
        St.return ()
    | Eproc _ _ _ ->
        St.return ()
    | Esame _ _ ->
        St.return ()
    | Eundef _ ->
        St.return ()
    
    (* TODO: assume that there is name clash among threads *)
    | Epar es ->
        St.mapM_ collect_conts es
    
    | Eerror ->
        St.return ()
    | Eaction _ ->
        St.return ()
    | Easeq _ _ _ ->
        St.return ()
    | Erun _ _ _ ->
        St.return ()
    | Eunseq _ ->
        St.return ()
    | Eret _ ->
        St.return ()
    
    (* these ctors should have been removed by Core_indet *)
    | Eindet _ ->
        Boot.assert_false "Core_run.collect_conts: the ctor `Eindet' should exists at this stage."
    | Ebound _ _ ->
        Boot.assert_false "Core_run.collect_conts: the ctor `Ebound' should exists at this stage."

(* TODO: temporary *)
    | Eis_scalar _ ->
        St.return ()
    | Eis_integer _ ->
        St.return ()
    | Eis_signed _ ->
        St.return ()
    | Eis_unsigned _ ->
        St.return ()
  end
*)










val     collect_conts': expr E.taction_id -> map ksym (list (sym * ctype) * expr E.taction_id)
let rec collect_conts' e =
  match e with
    | Esave d a_tys e ->
        Map.insert d (a_tys, e) (collect_conts' e)
    | Elet _ _ e2 ->
        collect_conts' e2
    | Eif _ e2 e3 ->
        (* Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (collect_conts' e2) (collect_conts' e3) *)
        Map.(union) (collect_conts' e2) (collect_conts' e3)
    | Ewseq _as e1 e2 ->
        let ks1 = collect_conts' e1 in
        (* Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (Pmap.map (fun (a_tys, k) -> (a_tys, Ewseq _as k e2)) ks1) (collect_conts' e2) *)
        Map.(union) (Map.map (fun (a_tys, k) -> (a_tys, Ewseq _as k e2)) ks1) (collect_conts' e2)
    | Esseq _as e1 e2 ->
        let ks1 = collect_conts' e1 in
        (* Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (Pmap.map (fun (a_tys, k) -> (a_tys, Esseq _as k e2)) ks1) (collect_conts' e2) *)
        Map.(union) (Map.map (fun (a_tys, k) -> (a_tys, Esseq _as k e2)) ks1) (collect_conts' e2)
    | End es ->
        (* foldl (fun acc e -> Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (collect_conts' e) acc) Pmap.empty es *)
        Map.unions (List.map collect_conts' es)
    
    (* TODO: assume that there is name clash among threads *)
    | Epar es ->
        (* foldl (fun acc e -> Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (collect_conts' e) acc) Pmap.empty es *)
        Map.unions (List.map collect_conts' es)
    
    (* by syntactic constraints, we know that under these ctors there can be no labeled
       continuations *)
    | Etuple _ ->
        Map.empty
    | Enull ->
        Map.empty
    | Eskip ->
        Map.empty
    | Econst _ ->
        Map.empty
    | Eimpl _ ->
        Map.empty
    | Eaddr _ ->
        Map.empty
    | Esym _ ->
        Map.empty
    | Eop _ _ _ ->
        Map.empty
    | Etrue ->
        Map.empty
    | Efalse ->
        Map.empty
    | Enot _ ->
        Map.empty
    | Ectype _ ->
        Map.empty
    | Ecall _ _ ->
        Map.empty
    | Eproc _ _ _ ->
        Map.empty
    | Esame _ _ ->
        Map.empty
    | Eundef _ ->
        Map.empty
    | Eerror ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Easeq _ _ _ ->
        Map.empty
    | Erun _ _ _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Eret _ ->
        Map.empty

    (* these ctors should have been removed by Core_indet *)
    | Eindet _ ->
        Boot.assert_false "Core_run.collect_conts': the ctor `Eindet' should exists at this stage."
    | Ebound _ _ ->
        Boot.assert_false "Core_run.collect_conts': the ctor `Ebound' should exists at this stage."
    
    | Eshift _ _ ->
        Map.empty

(* TODO: temporary *)
    | Eis_scalar _ ->
        Map.empty
    | Eis_integer _ ->
        Map.empty
    | Eis_signed _ ->
        Map.empty
    | Eis_unsigned _ ->
        Map.empty
  end




open Operators

val runE: E.execution_mode -> file E.taction_id -> E.t (Core.expr E.taction_id * (Map.map E.taction_id E.trace_action * E.trace))
let runE execution_mode file =
  (* collect the continuations in all functions *)
  let cont_map: map sym (map ksym (list (sym * ctype) * expr E.taction_id)) =
    (* TODO[newLem] maybe we should add mapWithKey to lem's Map *)
    Set_helpers.fold (fun (fname, (_, _, fbody)) acc ->
      Map.insert fname (collect_conts' fbody) acc
    ) (Map.toSet file.funs) Map.empty in
(*
    foldl (fun acc (fname, (_, _, fbody)) ->
(*      Pmap.add fname (let (_, s) = St.run_impl (collect_conts fbody) <| bound_syms= {}; conts= Pmap.empty |> in s.conts) acc *)
      Map.insert fname (collect_conts' fbody) acc
    ) Map.empty $ Pmap.bindings file.funs in
*)
  let (_, _, main_body) = fromJust $ Map.lookup file.main file.funs in
  
(*  (_DEBUG 2 (print_cont_map cont_map)) *)
  
  E.set_execution_mode execution_mode    >>
  E.set_current_proc file.main           >>
  E.register_conts cont_map              >>
  star_red2 (main_body, Cmm_aux.Tzero, [(* Khole *)[]]) >>= fun ((value, _, _), (tact_map, trace)) ->
  E.return (value, (tact_map, reverse trace))


val run: E.execution_mode -> file zero ->
         Exception.t (list (U.t ((Core.expr E.taction_id) * (Map.map E.taction_id E.trace_action * E.trace)) * E.state)) Errors.t
let run execution_mode file =
  let file' = convert_file file in
  let execs = runE execution_mode file' $ E.initial_state file' in
  Boot.print_debug "NUMBER OF TRACES= " (*; string_of_num $ List.length execs] *)
    Exception.return execs
