
open import Pervasives String_extra Global Core Core_ctype Core_ctype_aux Core_aux Show Show_extra
import Set_extra (* Set_helpers *)
import State State_operators Loc
import Nondeterminism Exception Errors Undefined Exception_undefined State_exception_undefined Symbolic
import Cmm_csem Mem Mem_common Mem_aux
import AilSyntax AilTypes AilTypesAux
import Dlist

open import Implementation_ Decode

open import Thread Driver_util Core_run_aux Errors
(* import Output *)

(* TODO: tmp*) import Defacto_memory_types

module Cmm = Cmm_csem


module U   = Undefined
(* module ND  = Nondeterminism *)
module EU  = Exception_undefined
module SEU = State_exception_undefined


val stringFromValue: Core.value -> string
val stringFromPexpr: Core.pexpr -> string 
declare ocaml target_rep function stringFromValue = `String_core.string_of_value`
declare ocaml target_rep function stringFromPexpr = `String_core.string_of_pexpr`


open Exception.Operators
(* takes the symbolic names of a function, some pure expressions and produce
   the function body where the arguments have been substituted *)
val call_function: Core.file core_run_annotation -> name -> list Core.value ->
                   Exception.t Core.pexpr core_run_error
let call_function file f_nm arg_cvals =
  match f_nm with
    | Sym f_a ->
        match Map.lookup f_a file.stdlib with
          | Just z ->
              (* callign a function from the Core standard library *)
              Exception.return z
          | Nothing ->
              match Map.lookup f_a file.funs with
                | Just z ->
                    (* calling a user function *)
                    Exception.return z
                | Nothing ->
                    Exception.fail (Illformed_program "calling an unknown function")
              end
        end
    | Impl f ->
        match Map.lookup f file.impl with
          | Just (IFun bty params pe) ->
              Exception.return (Fun bty params pe)
          | _ ->
              Exception.fail (Illformed_program ("calling an unknown impl-function: " ^
                                                 Implementation_.string_of_implementation_constant f))
        end
  end >>= function
    | Fun _ params body_pe ->
        if List.length params <> List.length arg_cvals then
          error "$ \"CALL #args <> #params, params= \" ^ Boot.pp_core_params params"
        else
          Exception.return $ Global.foldl2 (fun acc (a, _) cval -> subst_sym_pexpr a (PEval cval) acc) body_pe params arg_cvals
    | Proc _ _ _ ->
        error "Core_run.call_function, called on a Proc"
  end






val call_proc: Core.file core_run_annotation -> Core.sym -> list Core.value ->
               Exception.t (Core.expr core_run_annotation) core_run_error
let call_proc file psym cvals =
  let params_body_opt =
    match Map.lookup psym file.stdlib with
      | Just (Proc _ params body) ->
          Just (params, body)
      | _ ->
          match Map.lookup psym file.funs with
            | Just (Proc _ params body) ->
                Just (params, body)
            | _ ->
                Nothing
          end
    end in
  match params_body_opt with
    | Just (params, body) ->
        if List.length params <> List.length cvals then
          error $ "[Core_run.call_proc] wrong number of args applied to `" ^ show psym  ^ "' |args|=" ^
          show (List.length cvals) ^ "expecting: " ^ show (List.length params)

(* TODO[newLem] ^ Boot.pp_core_expr (Esym psym) ^ "'" *)
        else
          Exception.return (Global.foldl2 (fun acc (sym, _) cval -> subst_sym sym (PEval cval) acc) body params cvals)
    | Nothing ->
        Exception.fail (Illformed_program ("calling an unknown procedure: " ^ show psym))
  end




(* evaluation of pure expressions (will crash on ill-typed and/or non pure
   expressions).  Note that this evaluation may be partial; that is, the
   result of eval may be another unevaluated expression rather than a value.
   This is to ensure that the eval function will always terminate (which is
   important for the Coq backend).  To fully evaluate a pure expression,
   it is necessary to call eval repeatedly until is_value returns True. *)

let inline (>>=) = EU.bind
let inline (>>) m f = m >>= fun _ -> f


let rec resolve_concur_sym sym concur_sym_map seen_syms =
  match Map.lookup sym concur_sym_map with
    | Just (Vsymbolic (Symbolic.SYMBsym _ sym')) ->
        if List.elem sym' seen_syms then
          Nothing
        else
          resolve_concur_sym sym' concur_sym_map (sym' :: seen_syms)
    | Just cval ->
        Just cval
    | Nothing ->
        Nothing
  end




val     core_eval: Loc.t -> Mem.mem_state -> Core.file core_run_annotation ->
                   map Symbol.t Core.value -> bool -> Core.pexpr ->
                   EU.t Core.pexpr core_run_error
let rec core_eval loc mem_st file concur_sym_map inside_if = function
  | PEundef ub ->
      Exception.return (Undefined.undef loc [ub])
  | PEerror str pe ->
      Exception.return (Undefined.error loc (str ^ " ==> " ^ stringFromPexpr pe))

(*
  | (PEval (Vsymbolic (Symbolic.SYMBsym _ sym)) as pexpr) ->
      EU.return match resolve_concur_sym sym concur_sym_map [] with
        | Just cval ->
            PEval cval
        | Nothing ->
            let _ = Boot.print_debug 1 ("CORE_EVAL SYM FAILED: " ^ show sym) in
            pexpr
      end
*)
  | (PEval (Vsymbolic symb) as pexpr) ->
      match Core_aux.pexprFromSymbolic concur_sym_map symb with
        | Just pe ->
            EU.return pe
        | Nothing ->
            EU.return pexpr
      end

  | (PEval _ as pexpr) ->
(* TODO:
    match expr with
      | Econst (Mem.MVinteger symb) ->
          EU.return match Symbolic.reduce symb with
            | Symbolic.SYMBtrue ->
                Etrue
            | Symbolic.SYMBfalse ->
                Efalse
            | symb' ->
                Econst (Mem.MVinteger symb')
          end
      | _ ->
          EU.return expr
    end
*)
      EU.return pexpr
  | (PEsym sym as pexpr) ->
      if inside_if then
        EU.return pexpr
      else
        EU.fail $ Unresolved_symbol sym
  | PEimpl iCst ->
      match Map.lookup iCst file.impl with
        | Just (Def _ pe) ->
            EU.return pe
        | _ ->
            EU.fail Unknown_impl
      end
  
  | PEctor ctor pes ->
      EU.mapM (core_eval loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      match (ctor, valueFromPexprs pes') with
        | (Clist, Just [cval1; Vlist cvals]) ->
              EU.return $ PEval (Vlist (cval1 :: cvals))
        | (Ctuple, Just cvals) ->
              EU.return $ PEval (Vtuple cvals)
(*
        | (Carray, Just [cval1; Vlist cvals]) ->
              EU.return $ PEval (Vlist (cval1 :: cvals))
*)
        | (Civmax, Just [Vctype ty]) ->
            match Core_ctype.unatomic ty with
              | (Core_ctype.Basic (AilTypes.Integer ity)) ->
                  EU.return $ PEval (Vinteger (Mem.max_ival ity))
              | _ ->
                  error ("Core_run ivmax" ^
                             Boot.pp_core_expr (Core.Epure (Core.PEval (Vctype ty)) : Core.expr unit))
            end
        | (Civmin, Just [Vctype ty]) ->
            match Core_ctype.unatomic ty with
              | (Core_ctype.Basic (AilTypes.Integer ity)) ->
                  EU.return $ PEval (Vinteger (Mem.min_ival ity))
              | _ ->
                  error ("Core_run ivmin [" ^ Loc.stringFromLocation loc ^ "] ==> " ^
                             Boot.pp_core_expr (Core.Epure (Core.PEval (Vctype ty)) : Core.expr unit))
            end
        | (Civsizeof, Just [Vctype ty]) ->
            EU.return $ PEval (Vinteger (Mem.sizeof_ival ty))
        | (Civalignof, Just [Vctype ty]) ->
            EU.return $ PEval (Vinteger (Mem.alignof_ival ty))
        
        | (_, Just _) ->
            EU.fail $ Illformed_program ("PEctor: one of the operands was ill-typed ==> " ^
                                         Boot.pp_core_expr (Epure (PEctor ctor pes') : Core.expr unit))
        | (_, Nothing) ->
            EU.return $ PEctor ctor pes'
      end

  
  | PEcons pe1 pe2 ->
      core_eval loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      core_eval loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
      match (pe1', pe2') with
        | (PEval cval1, PEval cval2) ->
            match cval2 with
              |  Vlist cvals ->
                  EU.return $ PEval (Vlist (cval1 :: cvals))
              | _ ->
                  EU.fail $ Illformed_program "PEcons: second operand should be a list"
            end
        | _ ->
            EU.return $ PEcons pe1' pe2'
      end
  | PEcase_list pe pe_nil nm_cons ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vlist []) ->
            EU.return pe_nil
        | PEval (Vlist (cval::cvals)) ->
            EU.return $ PEcall nm_cons [PEval cval; PEval (Vlist cvals)]
        | PEval _ ->
            EU.fail $ Illformed_program "PEcase_list: first operand should be a list"
        | pe' ->
            EU.return $ PEcase_list pe' pe_nil nm_cons
      end
  | PEcase_ctype pe pe_void nm_basic nm_array nm_fun nm_ptr nm_atom nm_struct nm_union nm_builtin ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vctype ty) ->
            match ty with
              | Void ->
                  EU.return pe_void
              | ((Basic _) as ty) ->
                  EU.return $ PEcall nm_basic [PEval (Vctype ty)]
              | Array elem_ty (Just n) ->
                  EU.return $ PEcall nm_array [PEval (Vctype elem_ty); PEval (Vinteger (Mem.integer_ival n))]
              | Array _ Nothing ->
                  error "WIP: Core_run.core_eval PEcase_ctype, Array Nothing"
              | Function return_ty qs_tys is_variadic ->
                  (* TODO: qualifiers *)
                  EU.return $ PEcall nm_fun [PEval (Vctype return_ty);
                                             PEval (Vlist $ List.map (fun (_, ty) -> Vctype ty) qs_tys);
                                             PEval (if is_variadic then Vtrue else Vfalse)]
              | Pointer _ ref_ty ->
                  (* TODO: qualifiers *)
                  EU.return $ PEcall nm_ptr [PEval (Vctype ref_ty)]
              | Atomic ty ->
                  EU.return $ PEcall nm_atom [PEval (Vctype ty)]
              | Struct tag ->
                  match Map.lookup tag (tagDefs ()) with
                    | Just ident_tys ->
                        (* TODO: identifiers *)
                        EU.return $ PEcall nm_struct [PEval (Vlist $ List.map (fun (_, ty) -> Vctype ty) ident_tys)]
                    | Nothing ->
                        EU.fail $ Illformed_program ("couldn't find definition of tag: " ^ show tag)
                  end
              | Union tag ->
                  match Map.lookup tag (tagDefs ()) with
                    | Just ident_tys ->
                        (* TODO: identifiers *)
                        EU.return $ PEcall nm_union [PEval (Vlist $ List.map (fun (_, ty) -> Vctype ty) ident_tys)]
                    | Nothing ->
                        EU.fail $ Illformed_program ("couldn't find definition of tag: " ^ show tag)
                  end
              | Builtin str ->
                  error "WIP: Core_run.core_eval PEcase_ctype, Builtin"
            end
        | PEval _ ->
            EU.fail $ Illformed_program "PEcase_ctype: first operand should be a ctype"
        | pe' ->
            EU.return $ PEcase_ctype pe' pe_void nm_basic nm_array nm_fun nm_ptr nm_atom nm_struct nm_union nm_builtin
      end

  | PEarray_shift pe1 ty pe2 ->
      core_eval loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      core_eval loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
      match (pe1', pe2') with
        | (PEval (Vpointer ptr_val), PEval (Vinteger ival)) ->
            EU.return $ PEval (Vpointer (Mem.array_shift_ptrval ptr_val ty ival))
        | (PEval _, PEval _) ->
            EU.fail $ Illformed_program ("PEarray_shift: type error ==> " ^ Boot.pp_core_expr (Epure (PEarray_shift pe1' ty pe2') : Core.expr unit))
        | _ ->
            EU.return $ PEarray_shift pe1' ty pe2'
      end
  
  | PEmember_shift pe tag_sym memb_ident ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vpointer ptr_val) ->
            EU.return $ PEval (Vpointer (Mem.member_shift_ptrval ptr_val tag_sym memb_ident))
        | PEval (Vsymbolic symb) ->
            EU.return $ PEval (Vsymbolic (Symbolic.SYMBmember_shift symb tag_sym memb_ident))
        | (PEval _ as pe') ->
            EU.fail $ Illformed_program ("PEmember_shift: type error ==> " ^ Boot.pp_core_expr (Epure (PEmember_shift pe' tag_sym memb_ident) : Core.expr unit))
        | pe' ->
            EU.return $ PEmember_shift pe' tag_sym memb_ident
      end
(*
KKKKK NOW

  | PEshift pe ty_pes ->
      core_eval file inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vpointer ptr_val as cval) ->
            EU.foldM (fun _acc (ty, pe) ->
              core_eval file inside_if pe >>= fun pe' ->
              match (valueFromPexpr pe', _acc) with
                | (Just (Vinteger ival), Left acc) ->
                    (* TODO: Vunspecified *)
                    EU.return $ Left ((ty, ival) :: acc)
                | (Just (Vinteger _ as cval), Right acc) ->
                    EU.return $ Right ((ty, PEval cval) :: acc)
                | (Just _, _) ->
                    EU.fail $ Illformed_program "PEshift: the expression in the shift path should be integers"
                | (Nothing, Left ivals) ->
                    EU.return $ Right ((ty, pe') :: List.map (fun (ty, ival) -> (ty, PEval (Vinteger ival))) ivals)
                | (Nothing, Right acc) ->
                    EU.return $ Right ((ty, pe') :: acc)
              end
            ) (Left []) ty_pes >>= function
              | Left rev_ty_ivals ->
                  EU.return $ PEval (Vpointer (Mem.shift_ptrval ptr_val (List.reverse rev_ty_ivals)))
              | Right rev_ty_pes' ->
                  EU.return $ PEshift (PEval cval) (List.reverse rev_ty_pes')
            end
        | Just _ ->
            EU.fail $ Illformed_program ("PEshift: first operand should be a pointer")
        | Nothing ->
            EU.return $ PEshift pe' ty_pes
      end
*)

  | PEnot pe ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval Vtrue ->
            EU.return $ PEval Vfalse
        | PEval Vfalse ->
            EU.return $ PEval Vtrue
        | PEval (Vsymbolic symb) ->
            EU.return $ PEval (Vsymbolic (Symbolic.SYMBnot symb))
        | PEval _ ->
            EU.fail $ Illformed_program "PEnot: operand should be a boolean"
        | pe' ->
            EU.return $ PEnot pe'
      end
  
  | PEop binop pe1 pe2 ->
      core_eval loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      core_eval loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
      
      let to_wrapped_ival = function
        | Vunspecified ty ->
            let () = Boot.print_debug 0 "UNSPEC IN CORE_EVAL" in
            Just (Left ty)
        | Vinteger ival ->
            Just (Right ival)
        | _ ->
            Nothing
      end in
      
      match (binop, valueFromPexpr pe1', valueFromPexpr pe2') with
        | (OpEq, Just (Vsymbolic symb1), Just cval2) ->
            EU.return (PEval (Vsymbolic (Symbolic.make_op Symbolic.Eq symb1 (Symbolic.SYMBconst cval2))))
        
        | (OpEq, Just (Vctype ty1), Just (Vctype ty2)) ->
            EU.return $ PEval (if ty1 = ty2 then Vtrue else Vfalse)
        
        | (OpEq, Just cval1, Just cval2) ->
            match (to_wrapped_ival cval1, to_wrapped_ival cval2) with
              | (Just wival1, Just wival2) ->
                  match Mem.eq_ival mem_st Symbolic.Constraints_TODO wival1 wival2 with
                    | Just b ->
                        EU.return (PEval (if b then Vtrue else Vfalse))
                    | Nothing ->
                        (* the current constraints allow both outcomes *)
                        error ("WIP: symbolic integer_value equality ==> " ^ Boot.pp_core_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
                  end
              | _ ->
                  EU.fail $ Illformed_program "PEop OpEq"
            end

        | (OpLt, Just cval1, Just cval2) ->
            match (to_wrapped_ival cval1, to_wrapped_ival cval2) with
              | (Just wival1, Just wival2) ->
                  match Mem.lt_ival Symbolic.Constraints_TODO wival1 wival2 with
                    | Just b ->
                        EU.return (PEval (if b then Vtrue else Vfalse))
                    | Nothing ->
                        (* the current constraints allow both outcomes *)
                        error ("WIP: symbolic integer_value less-than ==> " ^
                               Boot.pp_core_expr ((Epure (PEop binop (PEval cval1) (PEval cval2))) : Core.expr unit))
                  end
            end
        
        | (OpLe, Just cval1, Just cval2) ->
            match (to_wrapped_ival cval1, to_wrapped_ival cval2) with
              | (Just wival1, Just wival2) ->
                  match Mem.le_ival Symbolic.Constraints_TODO wival1 wival2 with
                    | Just b ->
                        EU.return (PEval (if b then Vtrue else Vfalse))
                    | Nothing ->
                        (* the current constraints allow both outcomes *)
                        error ("WIP: symbolic integer_value less_equal-than ==> " ^
                               Boot.pp_core_expr ((Epure (PEop binop (PEval cval1) (PEval cval2))) : Core.expr unit))
                  end
            end
        
        | (OpGe, Just cval1, Just cval2) ->
            match (to_wrapped_ival cval1, to_wrapped_ival cval2) with
              | (Just wival1, Just wival2) ->
                  (* TODO CHECK *)
                  match Mem.le_ival Symbolic.Constraints_TODO wival2 wival1 with
                    | Just b ->
                        EU.return (PEval (if b then Vtrue else Vfalse))
                    | Nothing ->
                        (* the current constraints allow both outcomes *)
                        error ("WIP: symbolic integer_value greater_equal-than ==> " ^
                               Boot.pp_core_expr ((Epure (PEop binop (PEval cval1) (PEval cval2))) : Core.expr unit))
                  end
            end
        
        | (OpGt, Just cval1, Just cval2) ->
            match (to_wrapped_ival cval1, to_wrapped_ival cval2) with
              | (Just wival1, Just wival2) ->
                  (* TODO CHECK *)
                  match Mem.lt_ival Symbolic.Constraints_TODO wival2 wival1 with
                    | Just b ->
                        EU.return (PEval (if b then Vtrue else Vfalse))
                    | Nothing ->
                        (* the current constraints allow both outcomes *)
                        error ("WIP: symbolic integer_value greater-than ==> " ^
                               Boot.pp_core_expr ((Epure (PEop binop (PEval cval1) (PEval cval2))) : Core.expr unit))
                  end
            end
        
(*
        | (OpLe, Just (Vunspecified ty1), Just (Vinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVmin ity2)))) ->
            if ty1 = Core_ctype.Basic (AilTypes.Integer ity2) then
              EU.return (PEval Vtrue)
            else
              error "WIP: unspec ty1 <= ivmin ty2"

        | (OpLe, Just (Vinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVmax ity1))), Just (Vunspecified ty2)) ->
            if ty1 = Core_ctype.Basic (AilTypes.Integer ity2) then
              EU.return (PEval Vtrue)
            else
              error "WIP: ivmax ty1 <= unspec ty2"
*)
(*
        | (OpLe, Just (Vinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVmin ity1))), Just (Vunspecified ty2)) ->
            if Core_ctype.Basic (AilTypes.Integer ity1) = ty2 then
              EU.return (PEval Vtrue)
            else
              error "WIP: ivmin ity1 <= unspec ty2"

        | (OpLe, Just (Vunspecified ty1), Just (Vinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVmax ity2)))) ->
            if ty1 = Core_ctype.Basic (AilTypes.Integer ity2) then
              EU.return (PEval Vtrue)
            else
              error "WIP: unspec ty1 <= ivmax ity1"
*)


        | (_, Just (Vunspecified ty), Just _) ->
            EU.return (PEval (Vunspecified ty))
        | (_, Just _, Just (Vunspecified ty)) ->
            EU.return (PEval (Vunspecified ty))

        | (_, Just (Vinteger ival1), Just (Vinteger ival2)) ->
            let iop = match binop with
              | OpAdd ->
                  Mem_common.IntAdd
              | OpSub ->
                  Mem_common.IntSub
              | OpMul ->
                  Mem_common.IntMul
              | OpDiv ->
                  Mem_common.IntDiv
              | OpMod ->
                  Mem_common.IntMod
              | OpExp ->
                  Mem_common.IntExp
              | _ ->
                  error ("Core_run.core_eval, PEop Vinteger Vinteger: " ^ show binop)
            end in
            EU.return (PEval (Vinteger (Mem.op_ival iop ival1 ival2)))



        | (OpAnd, Just v1, Just v2) ->
            match (v1, v2) with
              | (Vtrue, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vtrue, Vfalse) ->
                  EU.return $ PEval Vfalse
              | (Vfalse, Vtrue) ->
                  EU.return $ PEval Vfalse
              | (Vfalse, Vfalse) ->
                  EU.return $ PEval Vfalse
              | _ ->
                  EU.fail $ Illformed_program ("PEop OpAnd: the two operands should be booleans ==> " ^
                                               Boot.pp_core_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end
        | (OpOr, Just v1, Just v2) ->
            match (v1, v2) with
              | (Vtrue, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vtrue, Vfalse) ->
                  EU.return $ PEval Vtrue
              | (Vfalse, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vfalse, Vfalse) ->
                  EU.return $ PEval Vfalse
              | _ ->
                  EU.fail $ Illformed_program ("PEop OpOr: the two operands should be booleans ==> " ^
                                               Boot.pp_core_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
            end

(* TODO: symbolics *)
        | (_, Just (Vsymbolic symb), Just (Vinteger ival as cval)) ->
            let n = match Mem_aux.integerFromIntegerValue ival with
              | Just n ->
                  n
              | Nothing ->
                  error "Core_run.core_eval PEop: symbolic vs non-trivial ival"
            end in
            let sym_op = match binop with
              | OpAdd ->
                  Symbolic.Add
              | OpSub ->
                  Symbolic.Sub
              | OpMul ->
                  Symbolic.Mul
              | OpDiv ->
                  Symbolic.Div
              | OpMod ->
                  Symbolic.Mod
              | _ ->
                  error "Core_run.core_eval, PEop Vsymbolic Vinteger sym_op match"
            end in
            EU.return (PEval (Vsymbolic (Symbolic.make_op sym_op symb (Symbolic.SYMBconst cval))))

        | (_, Just (Vinteger ival as cval), Just (Vsymbolic symb)) ->
            let n = match Mem_aux.integerFromIntegerValue ival with
              | Just n ->
                  n
              | Nothing ->
                  error "Core_run.core_eval PEop: non-trivial ival vs symbolic"
            end in
            let sym_op = match binop with
              | OpAdd ->
                  Symbolic.Add
              | OpSub ->
                  Symbolic.Sub
              | OpMul ->
                  Symbolic.Mul
              | OpDiv ->
                  Symbolic.Div
              | OpMod ->
                  Symbolic.Mod
              | _ ->
                  error "Core_run.core_eval, PEop Vinteger Vsymbolic sym_op match"
            end in
            EU.return (PEval (Vsymbolic (Symbolic.make_op sym_op symb (Symbolic.SYMBconst cval))))

        | (_, Just (Vsymbolic symb1), Just (Vsymbolic symb2)) ->
            let sym_op = match binop with
              | OpAdd ->
                  Symbolic.Add
              | OpSub ->
                  Symbolic.Sub
              | OpMul ->
                  Symbolic.Mul
              | OpDiv ->
                  Symbolic.Div
              | OpMod ->
                  Symbolic.Mod
              | OpLt ->
                  Symbolic.Lt
              | _ ->
                  error "Core_run.core_eval, PEop Vsymbolic Vsymbolic sym_op match"
            end in
            EU.return (PEval (Vsymbolic (Symbolic.make_op sym_op symb1 symb2)))
        | (_, Just _, Just _) ->
            EU.fail $ Illformed_program ("[" ^ Loc.stringFromLocation loc ^ "] ill-typed PEop: " ^
                                         Boot.pp_core_expr ((Epure (PEop binop pe1' pe2')) : Core.expr unit))
        | _ ->
            EU.return $ PEop binop pe1' pe2'
      end

(*


      | Eop binop pe1 pe2 ->
          core_eval file inside_if pe1 >>= fun pe1' ->
          core_eval file inside_if pe2 >>= fun pe2' ->
          if is_value pe1' && is_value pe2' then
            match (binop, pe1', pe2') with
                
                | (OpEq, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    match Symbolic.try_eq symb1 symb2 with
                      | Left true ->
                          EU.return Etrue
                      | Left false ->
                          EU.return Efalse
                      | Right (symb1', symb2') ->
                          EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Eq symb1' symb2')))
                    end

                | (OpLt, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    match Symbolic.try_lt symb1 symb2 with
                      | Left true ->
                          EU.return Etrue
                      | Left false ->
                          EU.return Efalse
                      | Right (symb1', symb2') ->
                          EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Lt symb1' symb2')))
                    end


(* TODO: check *)
                | (OpAdd, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Add symb1 symb2)))
                | (OpSub, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Sub symb1 symb2)))
                | (OpMul, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Mul symb1 symb2)))
                | (OpDiv, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Div symb1 symb2)))
                | (OpMod, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op Symbolic.Mod symb1 symb2)))


                | (op, Econst (Mem.MVinteger symb1), Econst (Mem.MVinteger symb2)) ->
                    let op = match op with
                      | OpAdd -> Symbolic.Add
                      | OpSub -> Symbolic.Sub
                      | OpMul -> Symbolic.Mul
                      | OpDiv -> Symbolic.Div
                      | OpMod -> Symbolic.Mod
                      | OpExp -> Symbolic.Exp
                      | OpEq  -> Symbolic.Eq
                      | OpLt  -> Symbolic.Lt
                      | OpAnd -> Symbolic.And
                      | OpOr  -> Symbolic.Or
                    end in
                    EU.return (Econst (Mem.MVinteger (Symbolic.make_op op symb1 symb2)))
*)
(*
| PEmemop of Mem.memop * list pexpr
*)
(*
KKK NOW

  | PEmemop memop pes ->
      EU.mapM (core_eval file inside_if) pes >>= fun pes' ->
      match (memop, valueFromPexprs pes') with
        | (Ptreq, Just [Vpointer ptr_val1; Vpointer ptr_val2]) ->
              match Mem.eq_ptrval (* TODO *)Symbolic.Constraints_TODO ptr_val1 ptr_val2 with
                | Just b ->
                    EU.return $ PEval (if b then Vtrue else Vfalse)
                | Nothing ->
                    error "TODO: symbolic case for pointer equality"
              end
        | (IntFromPtr, Just [Vctype ref_ty; Vctype ty; Vpointer ptr_val]) ->
            EU.return $
              PEval (Vinteger (Mem.intcast_ptrval ref_ty ty ptr_val))
        | (PtrFromInt, Just [Vctype ty; Vctype ref_ty; Vinteger ival]) ->
            EU.return $
              PEval (Vpointer (Mem.ptrcast_ival ty ref_ty ival))

        | (PtrValidForDeref, Just [Vpointer ptr_val]) ->
            EU.return $ PEval
              (if Mem.validForDeref_ptrval ptr_val then
                Vtrue
              else
                Vfalse)

        
        | (_, Just _) ->
            error "WIP: Core_run.core_eval PEmemop _"
        
        | (_, Nothing) ->
            EU.return $ PEmemop memop pes'
      end
(*
  | Ptreq
  | Ptrdiff     (* (address, address) -> integer *)
  | PtrLt
*)
*)
  | PEis_unspec pe ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= function
        | PEval (Vunspecified _) ->
            EU.return $ PEval Vtrue
        | PEval _ ->
            EU.return $ PEval Vfalse
        | pe' ->
            EU.return $ PEis_unspec pe'
      end
  
  | PEtuple pes ->
      EU.mapM (core_eval loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      EU.return $ match valueFromPexprs pes' with
        | Just cvals ->
            PEval (Vtuple cvals)
        | Nothing ->
            PEtuple pes'
      end
  | PEarray pes ->
      EU.mapM (core_eval loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      match valueFromPexprs pes' with
        | Just cvals ->
            EU.return $ PEval (Varray cvals)
(*
            maybe (EU.fail $ Illformed_program ("PEarray: found a symbol during evaluation> " ^ Boot.pp_core_expr (Epure (PEarray pes') : expr unit)))
              (fun mem_vals -> EU.return $ PEval (Varray mem_vals)) $
            List.foldr (fun cval acc_opt ->
              match (memValueFromValue cval, acc_opt) with
                | (Just mem_val, Just acc) ->
                    Just (mem_val :: acc)
                | _ ->
                    Nothing
              end) (Just []) cvals
*)
        | Nothing ->
            EU.return $ PEarray pes'
      end
(*
  | PEarray xs ->
      maybe (EU.fail $ Illformed_program "PEarray: found a symbol during evaluation")
            (fun vs -> EU.return $ PEval (Varray vs)) $
        List.foldr (fun xs acc_opt ->
          match (xs, acc_opt) with
            | (Left mem_val, Just acc) ->
                Just (mem_val :: acc)
            | _ ->
                Nothing
          end) (Just []) xs
*)
  | PEcall nm pes ->
      EU.mapM (core_eval loc mem_st file concur_sym_map inside_if) pes >>= fun pes' ->
      match valueFromPexprs pes' with
        | Just cvals ->
            if List.all Core_aux.is_concrete cvals then
              (* We do not immediately call eval on the result of call_function,
                 as that could lead to non-termination. *)
              Exception.bind (call_function file nm cvals)
                EU.return
            else
              let symb_nm = match nm with
                | Sym f -> Symbolic.SYMBfsym f
                | Impl i -> Symbolic.SYMBimpl i
              end in
              EU.return $ PEval (Vsymbolic (Symbolic.make_call symb_nm (List.map symbolify cvals)))
        | Nothing ->
            EU.return $ PEcall nm pes'
      end
  | PElet sym pe1 pe2 ->
      core_eval loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      EU.return $ match valueFromPexpr pe1' with
        | Just cval ->
            subst_sym_pexpr sym (PEval cval) pe2
        | Nothing ->
            PElet sym pe1' pe2
      end
  | PEif pe1 pe2 pe3 ->
      core_eval loc mem_st file concur_sym_map inside_if pe1 >>= fun pe1' ->
      match valueFromPexpr pe1' with
        | Just Vtrue ->
            core_eval loc mem_st file concur_sym_map inside_if pe2
        | Just Vfalse ->
            core_eval loc mem_st file concur_sym_map inside_if pe3

        | Just (Vsymbolic symb) ->
            core_eval loc mem_st file concur_sym_map inside_if pe2 >>= fun pe2' ->
            core_eval loc mem_st file concur_sym_map inside_if pe3 >>= fun pe3' ->
            EU.return $ match (valueFromPexpr pe2', valueFromPexpr pe3') with
              | (Just cval2, Just cval3) ->
                  PEval (Vsymbolic (Symbolic.make_ite symb (symbolify cval2) (symbolify cval3)))
              | _ ->
                  PEif pe1' pe2' pe3'
            end
            

        | Just _ ->
            EU.fail $ Illformed_program "PEif: first operand should be a boolean"
        | Nothing ->
            EU.return $ PEif pe1' pe2 pe3
      end
  | PEis_scalar pe ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_scalar (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_scalar: operand should be a ctype"
        | _ ->
            EU.return $ PEis_scalar pe'
      end
  | PEis_integer pe ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_integer (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_integer: operand should be ctype"
        | _ ->
            EU.return $ PEis_integer pe'
      end
  | PEis_signed pe ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_signed_integer_type (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_signed: operand should be a ctype"
        | Nothing ->
            EU.return $ PEis_signed pe'
      end
  | PEis_unsigned pe ->
      core_eval loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
      match valueFromPexpr pe' with
        | Just (Vctype ty) ->
            EU.return $ PEval (if AilTypesAux.is_unsigned_integer_type (unproj_ctype ty) then Vtrue else Vfalse)
        | Just _ ->
            EU.fail $ Illformed_program "PEis_unsigned: operand should be a ctype"
        | Nothing ->
            EU.return $ PEis_unsigned pe'
end

  | PEstruct tag_sym xs ->
      EU.mapM (fun (ident, pe) -> core_eval loc mem_st file concur_sym_map inside_if pe) xs >>= fun pes' ->
      match valueFromPexprs pes' with
        | Just cvals ->
            let xs' = List.map (fun ((ident, ty), cval) ->
              (ident, fromJust ("Core_run.core_eval, PEstruct ==> " ^ show ident) $ memValueFromValue ty cval)
            ) (List.zip (Core_ctype_aux.get_membersDefs tag_sym) cvals) in
            EU.return $ PEval (Vstruct tag_sym xs')
        | Nothing ->
            EU.return $ PEstruct tag_sym (List.zip (List.map fst xs) pes')
      end
      
  | pe ->
    error (">>> " ^ Boot.pp_core_expr (Epure pe : expr unit))

end



(*
      (* TODO: think about this *)
      | Eshift pe sh_path ->
          match pe with
            | Econst mem_val ->
                match Mem.ptr_from_mem_value mem_val with
                  | Just ptr_val ->
                      (* evaluating the shift_path indices, which must be pure integer expressions *)
                      EU.mapM (fun (ty, sh_pe) ->
                        core_eval file inside_if sh_pe >>= fun sh_pe' ->
                        EU.return (ty, sh_pe')
                      ) sh_path >>= fun sh_path' ->
                      if List.all (fun (_, pe) -> is_value pe) sh_path' then
                        
                        (* TODO: this is partial, and fails on ill-typed paths *)
                        let sh_path' = List.map (fun (ty, Econst mem_val) ->
                          match Mem.symb_from_mem_value mem_val with
                            | Just symb ->
                                (ty, symb)
                            | Nothing ->
                                error $ "Eshift, something wrong inside a path: " ^ Boot.pp_core_expr (Eshift pe sh_path)
                          end
                        ) sh_path' in
                        
                        EU.return $
                          Econst (Mem.mk_pointer (Mem.shift_ptrval ptr_val sh_path'))
                      else
                        EU.return (Eshift pe sh_path')
                  | Nothing ->
                      EU.fail (Illformed_program "Eshift: first operand was a non-pointer memory value")
                end
            | _ ->
                if is_value pe then
                  EU.fail (Illformed_program "Eshift: first operand didn't reduce to an Econst")
                else
                  core_eval file inside_if pe >>= fun pe' ->
                  EU.return (Eshift pe' sh_path)
          end
(*
          core_eval file inside_if pe >>= function
            (* TODO: shouldn't break the abstraction of Mem like that ... *)
            | Econst (Mem.MVpointer ptr_val) ->
                (* evaluating the shift_path indices, which must be pure integer expressions *)
                EU.mapM (fun (ty, pe) ->
                  EU.bind (core_eval file inside_if pe) (fun pe' ->
                  EU.return (ty, pe'))
                ) >>= fun sh_path' ->


                error "WIP: EU.return $ Econst (Mem.mk_pointer (Mem.shift_ptrval ptr_val sh_path))"
(*
(Mem.mk_pointer (
                  match path with
                    | ShiftArray n ->
                        Mem.Pointer_shift ptr_val n
                    | ShiftMember tag_sym ident ->
                        Mem.Pointer_memberof ptr_val tag_sym ident
                  end
                )))
*)
            | pe' ->
                if is_value pe' then
                  EU.fail (Illformed_program "ill-typed Eshift")
                else
                  EU.return (Eshift pe' sh_path)
          end

*)
    
      
      
(*
      | Eif pe1 pe2 pe3 ->
        core_eval file inside_if pe1 >>= function
          | Etrue ->
              core_eval file inside_if pe2
          | Efalse ->
              core_eval file inside_if pe3
          | (Econst (Mem.MVinteger symb) as pe1') ->
              if is_value pe2 then
                if is_value pe3 then
                  match (pe2, pe3) with
                    | (Econst (Mem.MVinteger symb2), Econst (Mem.MVinteger symb3)) ->
                        EU.return (Econst (Mem.MVinteger (Symbolic.make_ite symb symb2 symb3)))
                    | _ ->
                        EU.fail (Illformed_program "ill-typed Eif")
                  end
                else
                  core_eval file inside_if pe2 >>= fun pe2' ->
                  EU.return (Eif pe1' pe2' pe3)
              else
                  core_eval file inside_if pe3 >>= fun pe3' ->
                  EU.return (Eif pe1' pe2 pe3')
          | pe1' ->
              if is_value pe1' then
                EU.fail (Illformed_program "ill-typed Eif")
              else
                EU.return (Eif pe1' pe2 pe3)
        end
*)
      
| e ->
    error (">>> " ^ Boot.pp_core_expr e)
end


*)


val     full_core_eval_aux: Loc.t -> Mem.mem_state -> Core.file core_run_annotation ->
                            map Symbol.t Core.value -> bool -> Core.pexpr ->
                            EU.t Core.value core_run_error
let rec full_core_eval_aux loc mem_st file concur_sym_map inside_if pe =
  core_eval loc mem_st file concur_sym_map inside_if pe >>= fun pe' ->
  match valueFromPexpr pe' with
    | Just cval ->
        EU.return cval
    | Nothing ->
        full_core_eval_aux loc mem_st file concur_sym_map inside_if pe'
  end
val full_core_eval: Loc.t -> Mem.mem_state -> Core.file core_run_annotation ->
                    map Symbol.t Core.value -> bool -> Core.pexpr ->
                    either Errors.t (Undefined.t Core.value)
let full_core_eval loc mem_st file concur_sym_map inside_if pe =
  match full_core_eval_aux loc mem_st file concur_sym_map inside_if pe with
    | Exception.Result z ->
        Right z
    | Exception.Exception err ->
        Left (loc, Errors.Core_run_cause err)
  end



(* DEBUG *)
type exec_location =
  | ELoc_globals
  | ELoc_normal of list Core.sym

let push_exec_loc sym = function
  | ELoc_globals ->
      ELoc_normal [sym]
  | ELoc_normal syms ->
      ELoc_normal (sym :: syms)
end

type thread_state = <|
  arena:  expr core_run_annotation;
(*  arenas:  list (expr core_run_annotation); *)
  stack:  stack core_run_annotation;
  labels: map ksym (list (sym * ctype) * expr core_run_annotation);
  
  current_loc: Loc.t; (* DEBUG *)
  exec_loc: exec_location; (* DEBUG *)
|>


(* TODO: more *)
type io_state = <|
  stdout: Dlist.dlist string;
|>

type core_state = <|
  thread_states: list (thread_id * (maybe thread_id * thread_state)); (* the associated tid is that of the parent thread *)
  io:            io_state;
  handlers:      Map.map handler_event (list name);
|>

(*
let core_state_eq core_st1 core_st2 =
  (* TODO: IO and handlers *)
  core_st1 

instance (Eq core_state)
  let (=) = core_state_eq
  let (<>) = fun x y -> not (core_state_eq x y)
end
*)


let string_of_thread_state th_st =
  "Arena= " ^ Boot.pp_core_expr th_st.arena ^ "\nStack= " ^ string_of_stack th_st.stack ^ "\n"
(*
  List.foldr (fun (n, arena) acc ->
    "Arena[" ^ show n ^ "]= " ^ Boot.pp_core_expr arena
  ) ("Stack= " ^ "TODO" ^ "\n") (numerote th_st.arenas)
*)

let string_of_core_state core_st =
  List.foldr (fun (tid, (parent_tid_opt, th_st)) acc ->
    "Thread " ^ show tid ^ (maybe "" (fun z -> "(spawn of thread " ^ show z ^ ")") parent_tid_opt) ^ "\n" ^
    string_of_thread_state th_st ^
    "-----------------------------\n\n" ^ acc
  ) "" core_st.thread_states


instance (Show core_state)
  let show = string_of_core_state
end




type core_run_state = <|
  tid_supply:    UniqueId.supply thread_id;
  symbol_supply: UniqueId.supply Symbol.t;
  aid_supply:    UniqueId.supply action_id;
  
  (* DEBUG *)
  step_counter: nat;
|>




(* Monad of the core evaluator (State + Exception + Undefined) *)
type core_runM 'a = SEU.t 'a core_run_state core_run_error




val increment_step_counter: core_runM unit
let increment_step_counter =
  SEU.runS (
    State.update (fun run_st ->
      <| run_st with step_counter= run_st.step_counter + 1 |>
    )
  )




(* TODO: this is instanciated to Naive_memory *)
(*
val runMem: forall 'a. Mem.memM 'a -> core_runM 'a
let runMem m =
  SEU.runS (
    State.modify (fun run_st ->
      match SEU.run m run_st.layout_state with
        | Exception.Result (Undefined.Defined z, mem_st') ->
(*            let _ = Boot.output_string ("AFTER2> " ^ show mem_st') in *)
            (z, <| run_st with layout_state= mem_st' |>)

        | Exception.Result (Undefined.Undef ubs, mem_st') ->
            error "Core_run.runMem undef"
        
        | Exception.Result (Undefined.Error str, mem_st') ->
            error ("Core_run.runMem error: " ^ str)
        
        | Exception.Exception err ->
            let str = match err with
              | Mem.MerrUnitialised _ ->
                  "MerrUnitialised"
              | Mem.MerrInternal str ->
                  "(MerrInternal '" ^ str ^ "'"
              | Mem.MerrOther str ->
                  "(MerrOther '" ^ str ^ "'"
            end in
            error ("Core_run.runMem other: " ^ str)
      end
    )
  )
*)
(*
val liftMem: forall 'a. Mem.memM 'a -> core_runM 'a
let liftMem m =
  SEU.runS (
    State.modify (fun run_st ->
      match Mem.runMem m run_st.layout_state with
        | Left err ->
            error "ERROR in memory model layout"
        | Right (z, mem_st') ->
            (z, <| run_st with layout_state= mem_st' |>)
      end
    )
  )
*)

(*
type action_request =
  (* RequestName  of sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest  of set action_id * set action_id * set action_id *
                     action_id * thread_id * Symbol.prefix * Mem.integer_value * Mem.integer_value *
                     (Mem.pointer_value -> core_state)
  
  | CreateRequest of set action_id * set action_id * set action_id *
                     action_id * thread_id * Symbol.prefix * Mem.integer_value * ctype *
                     (Mem.pointer_value -> core_state)
  
  | LoadRequest   of set action_id * set action_id * set action_id * 
                     (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                     action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Symbol.t *
                     (* the argument of the callback is either a concrete value if the memory model
                        is able to give one right away, or is equal to the symbolic value provided by the
                        present LoadRequest *)
                     (Mem.mem_value -> core_state)

  | StoreRequest  of set action_id * set action_id * set action_id *
                     action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Mem.mem_value *
                     core_state

(*
  | LockRequest   of set action_id * set action_id * set action_id *
                     action_id * thread_id * Mem.pointer_value * location_kind *
                     (lock_outcome -> SEU.t thread_state Symbol.counter core_run_error)

  | UnlockRequest of set action_id * set action_id * set action_id * 
                     action_id * thread_id * Mem.pointer_value * location_kind *
                     (SEU.t thread_state Symbol.counter core_run_error)

  | RmwRequest    of set action_id * set action_id * set action_id *
                     action_id * thread_id * Cmm.memory_order * Mem.pointer_value * location_kind * Mem.mem_value *
                     (Mem.mem_value -> SEU.t thread_state Symbol.counter core_run_error)

  | FenceRequest  of set action_id * set action_id * set action_id *
                     action_id * thread_id * Cmm.memory_order *
                     (SEU.t thread_state Symbol.counter core_run_error)
*)
*)


(*
type pointer_request =
(*
  | PtrEqRequest 
  | PtrNeRequest 
*)
  | PtrShiftRequest of ctype * Mem.pointer_value * Symbolic.symbolic (* integer value *) *
                       (Core.expr core_run_annotation -> core_state)
*)








(*
val update_thread_state: thread_id -> thread_state -> core_state -> Exception.t core_state core_run_error
let update_thread_state tid th_st st =
  Exception.bind match List.lookup tid st.thread_states with
    | Just z ->
        Exception.return z
    | Nothing ->
        Exception.fail (Illformed_program "trying to update the state of a non existing thread")
  end (fun (parent_tid_opt, _) ->
    Exception.return <| st with thread_states= assoc_insert tid (parent_tid_opt, th_st) st.thread_states |>
  )
*)

val register_handler: core_state -> core_state
let register_handler st =
  error "WIP: register_handler"

val update_thread_state: thread_id -> thread_state -> core_state -> core_state
let update_thread_state tid th_st st =
  let f (parent_tid_opt, _) = (parent_tid_opt, th_st) in
  <| st with thread_states= assoc_adjust f tid st.thread_states |>


val spawn_thread: maybe thread_id -> thread_state -> core_state -> State.t (thread_id * core_state) core_run_state
let spawn_thread parent_tid_opt th_st st =
  State.modify (fun run_st ->
    let (tid, tid_suppl') = UniqueId.fresh_id run_st.tid_supply in
    ((tid, <| st with thread_states= assoc_insert tid (parent_tid_opt, th_st) st.thread_states |>),
     <| run_st with tid_supply= tid_suppl' |>)
  )


val kill_thread: thread_id -> thread_id -> set action_id -> Core.value -> core_state -> core_state
let kill_thread tid parent_tid aswBefores v st =
  <| st with
       thread_states= assoc_adjust (fun (parent_tid_opt, th_st) ->
         (parent_tid_opt, <| th_st with
            arena= subst_wait tid v th_st.arena;
(*
            arenas= List.map (subst_wait tid v) th_st.arenas; (* NOTE!!!! ==> in fact here arenas must be a singleton (since Epar is not allowed inside Eunseq) *)
*)
            stack= add_to_asw_stack aswBefores (subst_wait_stack tid v th_st.stack) |>)
       ) parent_tid $ assoc_remove tid st.thread_states
  |>


val fresh_symbol: State.t Symbol.t core_run_state
let fresh_symbol =
  State.modify (fun run_st ->
    let (sym, symbol_suppl') = UniqueId.fresh_id run_st.symbol_supply in
    (sym, <| run_st with symbol_supply= symbol_suppl' |>)
  )


val fresh_action_id: State.t action_id core_run_state
let fresh_action_id =
  State.modify (fun run_st ->
    let (aid, aid_suppl') = UniqueId.fresh_id run_st.aid_supply in
    (aid, <| run_st with aid_supply= aid_suppl' |>)
  )




open State.Operators

val     hoist_negatives: forall 'a. expr 'a -> State.t (expr 'a) (list (expr 'a) * core_run_state)
let rec hoist_negatives expr =
  let add_neg neg_e =
    State.modify (fun (negs, run_st) ->
      ((), (neg_e :: negs, run_st))
    ) in
(*
  let flush_negs = 
    State.modify (fun (negs, run_st) ->
      (negs, ([], run_st))
    ) in
*)
  match expr with
    | Epure _ ->
        State.return expr
    | Ememop _ _ ->
        State.return expr
    | Eraise _ ->
        State.return expr
    | Eregister _ _ ->
        State.return expr
    | Eskip ->
        State.return expr
    | Elet sym pe1 e2 ->
        hoist_negatives e2 >>= fun e2' ->
        State.return (Elet sym pe1 e2')
    | Eif pe1 e2 e3 ->
        hoist_negatives e2 >>= fun e2' ->
        hoist_negatives e3 >>= fun e3' ->
        State.return (Eif pe1 e2' e3')
    | Eproc _ _ _ ->
        State.return expr
    | Eaction pact ->
        if is_negative_action pact then
          add_neg expr >> State.return (Epure (PEval Vunit))
        else
          State.return expr
    | Eunseq es ->
        State.mapM hoist_negatives es >>= fun es' ->
        State.return (Eunseq es')
    | Ewseq _as e1 e2 ->
        hoist_negatives e1 >>= fun e1'  ->
        hoist_negatives e2 >>= fun e2'  ->
        State.return (Ewseq _as e1' e2')
    | Esseq _as e1 e2 ->
        error "Core_run.hoist_negatives: found an Esseq"
(*
        hoist_negatives e1 >>= fun e1'  ->
        flush_negs         >>= fun negs ->
        hoist_negatives e2 >>= fun e2'  ->
        let nothings = Global.replicate_list Nothing (List.length negs) in
        match negs with
          | [] ->
              State.return (Esseq _as e1' e2')
          | _ ->
              State.return (
                Esseq (nothings ++ _as) (Eunseq (negs ++ [e1'])) e2'
              )
        end
*)
    | Easeq sym_opt act1 pact2 ->
        error "Core_run.hoist_negatives found an Easeq"
    | Eindet e ->
        hoist_negatives e >>= fun e' ->
        State.return (Eindet e')
    | Ebound i e ->
        hoist_negatives e >>= fun e' ->
        State.return (Ebound i e')
    | Esave ksym sym_tys e ->
        hoist_negatives e >>= fun e' ->
        State.return (Esave ksym sym_tys e')
    | Erun _ _ _ ->
      State.return expr
    | Eret _ ->
        State.return expr
    | End es ->
        State.mapM hoist_negatives es >>= fun es' ->
        State.return (End es')
    | Epar _ ->
        (* TODO: check *)
        State.return expr
    | Ewait _ ->
        State.return expr
    | Eloc loc e ->
        hoist_negatives e >>= fun e' ->
        State.return (Eloc loc e')
  end












open SEU.Operators


(*
val printf_hack: core_state -> list (expr core_run_annotation) -> ND.t core_step
let printf_hack core_st pes =
  let mk_string = function
    | Mem.MVarray vs ->
        let _ = Boot.output_string ("KKK> " ^ string_of_natural (naturalFromNat (List.length vs))) in (* DEBUG *)
        String.toString $ List.map (function
          | Mem.MVinteger (Symbolic.SYMBconst n) ->
              Decode.encode_character_constant n
          | _ ->
              error "printf_hack: one of the element of the format array was invalid"
        end) vs
    | _ ->
        error "printf_hack: the format argument was not an array"
  end in
  match pes with
    | [Econst (Mem.MVpointer ptr1)] ->
        ND.return $ Step_output (
          liftMem (Mem.load ptr1)       >>= fun (Mem.MVpointer ptr_format) ->
          liftMem (Mem.load ptr_format) >>= fun format                      ->
          SEU.return (mk_string format, core_st)
        )
    | _ ->
        error "invalid arguments for printf"
  end
*)

(* TODO: hack *)
(*
type formatting
declare ocaml target_rep type formatting = `Boot_printf.formatting`
val pseudo_printf: string -> list (formatting * Core_ctype.ctype) * (list string -> string)
declare ocaml target_rep function pseudo_printf = `Boot_printf.pseudo_printf`
*)











module E = struct
  let return =
    SEU.return
  let core_evals loc mem_st file concur_sym_map inside_if pes =
    SEU.runEU (EU.mapM (core_eval loc mem_st file concur_sym_map inside_if) pes)
  let core_eval loc mem_st file concur_sym_map inside_if pe =
    SEU.runEU (core_eval loc mem_st file concur_sym_map inside_if pe)
  let fresh_action_id =
    SEU.runS fresh_action_id
  let fresh_symbol =
    SEU.runS fresh_symbol
end


type action_request =
  (* RequestName  of location * sbBefore * ddBefore * aswBefore
                     parameters of request *
                     the new state or a callback *)
  | AllocRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * thread_id * Symbol.prefix * Mem.integer_value * Mem.integer_value *
                    (Mem.pointer_value -> thread_state)
  
  | CreateRequest of Loc.t * set action_id * set action_id * set action_id *
                     action_id * thread_id * Symbol.prefix * Mem.integer_value * ctype *
                     (Mem.pointer_value -> thread_state)
  
  | LoadRequest of Loc.t * set action_id * set action_id * set action_id * 
                   (* the request provide a fresh symbolic name to be used by the concurrency if needed *)
                   action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Symbol.t *
                   (* the argument of the callback is either a concrete value if the memory model
                      is able to give one right away, or is equal to the symbolic value provided by the
                      present LoadRequest *)
                   (Mem.mem_value -> thread_state)

  | StoreRequest of Loc.t * set action_id * set action_id * set action_id *
                    action_id * thread_id * Cmm.memory_order * ctype * Mem.pointer_value * Mem.mem_value *
                    thread_state
  | RMWRequest of Loc.t * set action_id * set action_id * set action_id *
                  action_id * thread_id * Cmm.memory_order * Cmm.memory_order * ctype * Mem.pointer_value *
                  Mem.mem_value * Mem.mem_value * thread_state
  | KillRequest of Loc.t * set action_id * set action_id * set action_id *
                   action_id * thread_id * Mem.pointer_value * thread_state

type core_step =
  | Step_action_request of core_runM action_request
  | Step_memop_request of Mem.memop * list Core.value * thread_id * (Core.value -> thread_state)
  | Step_tau of string * core_runM thread_state
  | Step_eval of string * core_runM thread_state
  | Step_thread_done of thread_id * Core.value
(*  | Step_nd of string * list core_step *)
  | Step_blocked
  | Step_error of string
  | Step_branch of (* DEBUG *) string * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM thread_state * core_runM thread_state
  | Step_done of Core.value
  | Step_spawn_threads of (Core.expr core_run_annotation -> thread_state) * list thread_state (* initial states for the children *)
  | Step_output of (* DEBUG *) string * string * thread_state
(*  | Step_printf of list (formatting * Core_ctype.ctype) * list Core.value * (list string -> string) * (integer -> thread_state) *)
  
    (* format string; arg pointers; callback taking as argument the length of the printed string *)
  | Step_printf2 of list char * list (Core_ctype.ctype * Mem.pointer_value) * (integer -> thread_state)



val core_action_step:
    Mem.mem_state -> Core.file core_run_annotation -> map Symbol.t Core.value -> thread_id -> (maybe thread_id * thread_state) -> Core.paction core_run_annotation -> core_step
let core_action_step mem_st file concur_sym_map current_tid (parent_tid_opt, th_st) (Paction p (Action loc annots act)) =
  let sb_before =
    (* filter out actions from other threads *)
    Set.map snd $ Set.filter (fun (tid, _) -> tid = current_tid) annots.sb_before in
  let dd_before = {(* TODO *)} in
  let asw_before_ =
    if has_sbBefore_on_thread current_tid annots then
      {}
    else
      Set.map snd $ Set.filter (fun (tid, _) ->
        match parent_tid_opt with
          | Just parent_tid ->
              tid = parent_tid
          | _ ->
              false
        end) annots.sb_before in
  
  let asw_before = annots.asw_before union asw_before_ in

  
  match act with
    | Create pe1 pe2 pref ->
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (Vinteger ival), Just (Vctype ty)) ->
              Step_action_request (
                E.fresh_action_id >>= fun create_aid ->
                E.return (
                  CreateRequest loc sb_before dd_before asw_before
                    create_aid current_tid pref ival ty
                    (fun ptr_val -> <| th_st with
                        arena= Epure (PEval (Vpointer ptr_val));
                        stack= add_to_sb_stack {(p, (current_tid, create_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                    |>)
                    )
                  )
          | (Just _, Just _) ->
              Step_error ("found a create() with ill-typed operands [" ^ Boot.pp_prefix pref ^ "]")
          | (Nothing, _) ->
              Step_eval "first operand of a Create" (
                E.core_eval loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Create pe1' pe2 pref)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Create" (
                E.core_eval loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Create pe1 pe2' pref)))
                |>
              )
        end
    | Alloc pe1 pe2 pref ->
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (Vinteger ival1), Just (Vinteger ival2)) ->
              Step_action_request (
                E.fresh_action_id >>= fun alloc_aid ->
                E.return (
                  AllocRequest loc sb_before dd_before asw_before
                    alloc_aid current_tid pref ival1 ival2
                    (fun ptr_val -> <| th_st with
                        arena= Epure (PEval (Vpointer ptr_val));
                        stack= add_to_sb_stack {(p, (current_tid, alloc_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                    |>)
                    )
                  )
          | (Just _, Just _) ->
              Step_error "found a alloc() with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Alloc" (
                E.core_eval loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Alloc pe1' pe2 pref)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Alloc" (
                E.core_eval loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Alloc pe1 pe2' pref)))
                |>
              )
        end
    | Kill pe ->
        match valueFromPexpr pe with
          | Just (Vpointer ptr_val) ->
              Step_action_request (
                E.fresh_action_id >>= fun kill_aid ->
                E.return (
                  KillRequest loc sb_before dd_before asw_before
                    kill_aid current_tid ptr_val
                    <| th_st with
                      arena= Eskip;
                      stack= add_to_sb_stack {(p, (current_tid, kill_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                    |>
                )
              )
          | Just _ ->
              Step_error "found a kill() with an ill-typed operand"
          | Nothing ->
              Step_eval "operand of kill()" (
                E.core_eval loc mem_st file concur_sym_map false pe >>= fun pe' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Kill pe')))
                |>
              )
        end
    | Store pe1 pe2 pe3 mo ->
        match (valueFromPexpr pe1, valueFromPexpr pe2, valueFromPexpr pe3) with
          | (Just (Vctype ty), Just (Vpointer ptr_val), Just cval) ->
              match memValueFromValue (Core_ctype.unatomic ty) cval with
                | Just mem_val ->
                    Step_action_request (
                      E.fresh_action_id >>= fun store_aid ->
                      E.fresh_symbol    >>= fun val_sym   ->
                      E.return (
                        StoreRequest loc sb_before dd_before asw_before
                          store_aid current_tid mo ty ptr_val mem_val
                          <| th_st with
                            arena= Eskip (* Epure (PEval (valueFromMemValue mem_val)) *);
                            stack= add_to_sb_stack {(p, (current_tid, store_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                          |>
                      )
                    )
                | Nothing ->
                    Step_error ((Loc.stringFromLocation loc) ^ "the value of a store() didn't match the lvalue type: " ^
                      Boot.pp_ail_ctype (Core_aux.unproj_ctype ty) ^ " <-> " ^ Boot.pp_core_expr ((Epure (PEval cval)) : Core.expr unit) ^ "")
              end
          | (Just v1, Just v2, Just v3) ->
              Step_error ("found a store() with ill-typed operands: " ^
                           stringFromValue v1 ^ " <-> " ^ stringFromValue v2 ^ " <-> " ^ stringFromValue v3)
          | (Nothing, _, _) ->
              Step_eval "first operand of a Store" (
                E.core_eval loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Store pe1' pe2 pe3 mo)))
                |>
              )
          | (_, Nothing, _) ->
              Step_eval "second operand of a Store" (
                E.core_eval loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Store pe1 pe2' pe3 mo)))
                |>
              )
          | (_, _, Nothing) ->
              Step_eval "third operand of a Store" (
                E.core_eval loc mem_st file concur_sym_map false pe3 >>= fun pe3' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Store pe1 pe2 pe3' mo)))
                |>
              )
        end
    | Load pe1 pe2 mo ->
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vpointer ptr_val)) ->
              Step_action_request (
                E.fresh_action_id >>= fun load_aid ->
                E.fresh_symbol    >>= fun val_sym  ->
                E.return (
                  LoadRequest loc sb_before dd_before asw_before
                    load_aid current_tid mo ty ptr_val val_sym
                    (fun mem_val -> <| th_st with
                        arena= Epure (PEval (valueFromMemValue mem_val));
                        stack= add_to_sb_stack {(p, (current_tid, load_aid))} (* TODO: remove for sequential !!! *) th_st.stack
                    |>)
                )
              )
          | (Just _, Just _) ->
              Step_error "found a load with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Load" (
                E.core_eval loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1' pe2 mo)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Load" (
                E.core_eval loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1 pe2' mo)))
                |>
              )
        end
    | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
        match (valueFromPexpr pe1, valueFromPexpr pe2, valueFromPexpr pe3, valueFromPexpr pe4) with
          | (Just (Vctype ty), Just (Vpointer ptr_val), Just cval_expected, Just cval_desired) ->
              match (memValueFromValue ty cval_expected, memValueFromValue ty cval_desired) with
                | (Just mval_expected, Just mval_desired) ->
                    Step_action_request (
                      E.fresh_action_id >>= fun rmw_aid ->
                      E.return (
                        RMWRequest loc sb_before dd_before asw_before
                          rmw_aid current_tid mo1 mo2 ty ptr_val mval_expected mval_desired
                          <| th_st with
                            arena= Epure (PEval Vtrue); (* TODO *)
                            stack= add_to_sb_stack {(p, (current_tid, rmw_aid))} (* TODO: remove for sequential !!! *) th_st.stack;
                          |>
                      )
                    )


(*
  | RMW of aid * tid * memory_order * location * cvalue * cvalue  (* first val = value read; second val = value written *)
*)

(*
                    Step_action_request (
                      E.fresh_action_id >>= fun rmw_aid ->
                      E.fresh_symbol    >>= fun val_sym ->
                      E.return (
                        StoreRequest loc sb_before dd_before asw_before
                          store_aid current_tid mo ty ptr_val mem_val
                          <| th_st with
                            arena= Eskip (* Epure (PEval (valueFromMemValue mem_val)) *);
                            stack= (* add_to_sb_stack {(p, (current_tid, store_aid))} *) (* TODO: bring back for concurrency !!! *) th_st.stack;
                          |>
                      )
                    )
*)
                | _ ->
                    Step_error ("one of the values of a rmw() didn't match the lvalue type: " ^
                      Boot.pp_ail_ctype (Core_aux.unproj_ctype ty) ^ " <-> " ^
                                Boot.pp_core_expr ((Epure (PEval cval_expected)) : Core.expr unit) ^ " <-> " ^
                                Boot.pp_core_expr ((Epure (PEval cval_desired)) : Core.expr unit))
              end
          | (Just _, Just _, Just _, Just _) ->
              Step_error "found a rmw with ill-typed operands"
          | (Nothing, _, _, _) ->
              Step_eval "first operand of a RMW" (
                E.core_eval loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1' pe2 pe3 pe4 mo1 mo2)))
                |>
              )
          | (_, Nothing, _, _) ->
              Step_eval "second operand of a RMW" (
                E.core_eval loc mem_st file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1 pe2' pe3 pe4 mo1 mo2)))
                |>
              )
          | (_, _, Nothing, _) ->
              Step_eval "third operand of a RMW" (
                E.core_eval loc mem_st file concur_sym_map false pe3 >>= fun pe3' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1 pe2 pe3' pe4 mo1 mo2)))
                |>
              )
          | (_, _, _, Nothing) ->
              Step_eval "fourth operand of a RMW" (
                E.core_eval loc mem_st file concur_sym_map false pe4 >>= fun pe4' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (RMW pe1 pe2 pe3 pe4' mo1 mo2)))
                |>
              )
        end

(*
        match (valueFromPexpr pe1, valueFromPexpr pe2) with
          | (Just (Vctype ty), Just (Vpointer ptr_val)) ->
              Step_action_request (
                E.fresh_action_id >>= fun load_aid ->
                E.fresh_symbol    >>= fun val_sym  ->
                E.return (
                  LoadRequest loc sb_before dd_before asw_before
                    load_aid current_tid mo ty ptr_val val_sym
                    (fun mem_val -> <| th_st with
                        arena= Epure (PEval (valueFromMemValue mem_val));
                        stack= (* add_to_sb_stack {(p, (current_tid, load_aid))} *) th_st.stack
                    |>)
                )
              )
          | (Just _, Just _) ->
              Step_error "found a load with ill-typed operands"
          | (Nothing, _) ->
              Step_eval "first operand of a Load" (
                E.core_eval file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1' pe2 mo)))
                |>
              )
          | (_, Nothing) ->
              Step_eval "second operand of a Load" (
                E.core_eval file concur_sym_map false pe2 >>= fun pe2' ->
                E.return <| th_st with arena=
                  Eaction (Paction p (Action loc annots (Load pe1 pe2' mo)))
                |>
              )
        end
*)
  end



val core_thread_step2: Mem.mem_state -> Core.file core_run_annotation -> map Symbol.t Core.value -> thread_id -> (maybe thread_id * thread_state) -> list core_step
let core_thread_step2 mem_st file concur_sym_map current_tid (parent_tid_opt, th_st) =
  let one z = [z] in
  match (th_st.arena, th_st.stack) with
    | (Eskip, Stack_cons cont sk') ->
        (* ---------------------------------------
           <skip, κ.κs, Λ> --τ--> <κ(unit), ɛ.κs, Λ> *)
        one $ Step_tau "Eskip" (
          E.return <| th_st with arena= apply_continuation cont (Epure (PEval Vunit)); stack= Stack_cons [] sk' |>
        )
    
    | (Elet sym pe1 e2, _) ->
        (*                [| pe1 |] = v
           --------------------------------------------------
           <let α = pe1 in e2, κs, Λ> --τ--> <e2[α\v], κs, Λ> *)
        one match valueFromPexpr pe1 with
          | Just cval ->
              Step_tau "Elet" (
                E.return <| th_st with arena= subst_sym sym (PEval cval) e2 |>
              )
          | Nothing ->
              Step_eval "Elet" (
                E.core_eval th_st.current_loc mem_st file concur_sym_map false pe1 >>= fun pe1' ->
                E.return <| th_st with arena= Elet sym pe1' e2 |>
              )
        end
    
    | (Eif pe1 e2 e3, Stack_cons cont _) ->
        (* [| pe1 |] = v    e' = e2 labels e2
           -----------------------------------------------------------------
                                                   .- <e2, κs>  IF v = true
           <if pe1 then e2 else e3, κs, Λ> --τ--> <
                                                   '- <e3, κs>  IF v = false *)
        match valueFromPexpr pe1 with
          | Just Vtrue ->
              one $ Step_tau "Eif (then)" (
                let labeled_conts =
                  Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e3 in
                E.return <| th_st with arena= e2; labels= Map.(union) labeled_conts th_st.labels |>
              )
          | Just Vfalse ->
              one $ Step_tau "Eif (else)" (
                let labeled_conts =
                  Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e2 in
                E.return <| th_st with arena= e3; labels= Map.(union) labeled_conts th_st.labels |>
              )
          | Just (Vsymbolic symb) ->
              let (constr_then, constr_else) =
                match symb with
                  | Symbolic.SYMBop Symbolic.Eq symb1 symb2 ->
                      (Constraints.assert_eq symb1 symb2, Constraints.assert_neq symb1 symb2)
                  | Symbolic.SYMBop Symbolic.Neq symb1 symb2 ->
                      (Constraints.assert_neq symb1 symb2, Constraints.assert_eq symb1 symb2)
                  | Symbolic.SYMBnot (Symbolic.SYMBop Symbolic.Eq symb1 symb2) ->
                      (Constraints.assert_neq symb1 symb2, Constraints.assert_eq symb1 symb2)
                  | Symbolic.SYMBnot (Symbolic.SYMBop Symbolic.Neq symb1 symb2) ->
                      (Constraints.assert_eq symb1 symb2, Constraints.assert_neq symb1 symb2)
                end in
              one $ Step_branch "Eif (symbolic)" constr_then constr_else
                begin
                  let labeled_conts =
                    Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e3 in
                  E.return <| th_st with arena= e2; labels= Map.(union) labeled_conts th_st.labels |>
                end
                begin
                  let labeled_conts =
                    Map.map (fun (sym_tys, e) -> (sym_tys, apply_continuation cont e)) $ collect_labeled_continuations e2 in
                  E.return <| th_st with arena= e3; labels= Map.(union) labeled_conts th_st.labels |>
                end

          | Just _ ->
              one $ Step_error "the first operand of an Eif didn't evaluated to a boolean"
          | Nothing ->
              one $ Step_eval "Eif" (
                E.core_eval th_st.current_loc mem_st file concur_sym_map true pe1 >>= fun pe1' ->
                E.return <| th_st with arena= Eif pe1' e2 e3 |>
              )
        end
    
    | (Eproc annots nm pes, sk) ->
        one match valueFromPexprs pes with
          | Just cvals ->
              match nm with
                | Sym psym ->
                    Step_tau "Eproc" (
                      SEU.runEU (
                        Exception.bind (call_proc file psym cvals)
                          EU.return
                      ) >>= fun expr ->
                      (* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
                      let a_expr = add_to_sb (Set.map (fun z -> (Pos, z)) annots.sb_before) (* TODO: remove for sequential !!! *) expr in
                      E.return <| th_st with arena= a_expr; stack= push_empty_continuation sk; exec_loc= push_exec_loc psym th_st.exec_loc |>
                    )
                | Impl (StdFunction "printf") ->
                    match cvals with
                      | [Vlist frmt_cvals; Vlist args_cvals] ->
(*
                          (* building an OCaml string for the format *)
                          let frmt_str =
                            String.toString $ List.map (function
                              | Vinteger ival ->
                                  match Mem_aux.integerFromIntegerValue ival with
                                    | Just n ->
                                        Decode.encode_character_constant n
                                    | Nothing ->
                                        error "printf_hack: one of the element of the format array was invalid (1)"
                                  end
                              | z ->
                                  error "printf_hack: one of the element of the format array was invalid (2)"
                            end) (List.reverse chars) in
                          
                          (* get the list of types specified by the format string, and a builder function
                             for the string to be printed *)
                          let (format_tys, mk_str) = pseudo_printf frmt_str in
                          Step_printf format_tys args mk_str (fun n ->
                            <| th_st with arena= Epure (PEval (Vinteger (Mem.integer_ival n))) |>
                          )
*)
                          let frmt_chars = List.map (function
                            | Vinteger ival ->
                                match Mem_aux.integerFromIntegerValue ival with
                                  | Just n ->
                                      Decode.encode_character_constant n
                                  | Nothing ->
                                      error "Core_run, printf one of the element of the format array was invalid (1)"
                                end
                              | z ->
                                  error "Core_run, printf one of the element of the format array was invalid (2)"
                          end) (List.reverse frmt_cvals) in (* TODO: why is this reversed?? *)
                          let args_ptrvals = List.map (function
                            | Vtuple [Vctype ty; Vpointer ptr_val] ->
                                (* TODO: WIP *)
                                (ty, ptr_val)
                            | _ ->
                                error "Core_run, printf the second argument should be a list of (ctype, pointer) pairs"
                          end) args_cvals in
                          Step_printf2 frmt_chars args_ptrvals (fun n ->
                            <| th_st with arena= Epure (PEval (Vinteger (Mem.integer_ival n))) |>
                          )
(*
  | Step_printf2 of list Core.value * list Mem.pointer_value * (integer -> thread_state)
*)

                      | _ ->
                          error "Core_run, printf giving arguments of wrong types"
                    end
                | _ ->
                    error ("WIP: Eproc ==> " ^ Boot.pp_core_expr th_st.arena)
              end
          | Nothing ->
              Step_eval "Eproc" (
                E.core_evals th_st.current_loc mem_st file concur_sym_map false pes >>= fun pes' ->
                E.return <| th_st with arena= Eproc annots nm pes' |>
              )
        end
    | (Eaction pact, _) ->
        one $ core_action_step mem_st file concur_sym_map current_tid (parent_tid_opt, th_st) pact
    | (Ememop memop pes, _) ->
        one match valueFromPexprs pes with
          | Just cvals ->
              Step_memop_request memop cvals current_tid (fun cval ->
                <| th_st with arena= Epure (PEval cval) |>
              )
          | Nothing ->
              Step_eval "Ememop" (
                E.core_evals th_st.current_loc mem_st file concur_sym_map false pes >>= fun pes' ->
                E.return <| th_st with arena= Ememop memop pes' |>
              )
        end

(*
          | (Ptreq, Just cvals) ->
              match Mem.eq_ptrval (* TODO *)Symbolic.Constraints_TODO ptr_val1 ptr_val2 with
                | Just b ->
                    one $ Step_tau "Ememop, Ptreq" (
                      E.return <| th_st with arena= Epure (PEval (if b then Vtrue else Vfalse)) |>
                    )
                | Nothing ->
                    error "TODO: symbolic case for pointer equality"
              end
          | (IntFromPtr, Just [Vctype ref_ty; Vctype ty; Vpointer ptr_val]) ->
              EU.return $
              PEval (Vinteger (Mem.intcast_ptrval ref_ty ty ptr_val))
          | (PtrFromInt, Just [Vctype ty; Vctype ref_ty; Vinteger ival]) ->
              EU.return $
                PEval (Vpointer (Mem.ptrcast_ival ty ref_ty ival))
          | (PtrValidForDeref, Just [Vpointer ptr_val]) ->
              EU.return $ PEval
                (if Mem.validForDeref_ptrval ptr_val then
                  Vtrue
                else
                  Vfalse)
*)
    
    | (Eunseq es, Stack_cons cont sk) ->
        match to_pures es with
          | Just pes ->
              one $ Step_tau "Eunseq pure" (
                E.return <| th_st with arena= Epure (PEtuple pes) |>
              )
          | Nothing ->
              let is_wait = function
                | Ewait _ ->
                    true
                | _ ->
                  false
              end in
              if List.all (fun e -> is_wait e || to_pure e <> Nothing) es then
                one Step_blocked
              else
                let xs = 
                List.map (fun (es1, ej, es2) ->
                  Step_tau "Eunseq" (
                    E.return <| th_st with arena= ej; stack= Stack_cons (Kunseq es1 es2 :: cont) sk |>
                  )
                ) (pickWith (fun e -> to_pure e = Nothing && not (is_wait e)) es) in
                if List.length xs = 0 then
                  error ("BOOM Core_run, Eunseq, empty list ==> " ^ Boot.pp_core_expr (Eunseq es)) (* TODO: debug *)
                else
                  xs
        end
    
    | (Ewseq _as e1 e2, Stack_cons cont sk) ->
        (* TODO: negatives *)
        one match to_pure e1 with
          | Just pe ->
              match valueFromPexpr pe with
                | Just cval ->
                    Step_tau "Ewseq subst" (
                      E.return <| th_st with arena= subst_syms _as (PEval cval) e2 |>
                    )
                | Nothing ->
                    Step_eval "Ewseq" (
                      E.core_eval th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                      E.return <| th_st with arena= Ewseq _as (Epure pe') e2 |>
                    )
              end
          | Nothing ->
              (* focus the execution on the first operand *)
              Step_tau "Ewseq" (
                E.return <| th_st with
                  arena= e1;
                  stack= Stack_cons (Kwseq _as e2 :: cont) sk
                |>
              )
        end
    
    | (Esseq _as e1 e2, Stack_cons cont sk) ->
        (* TODO: negatives *)
        one match to_pure e1 with
          | Just pe ->
              match valueFromPexpr pe with
                | Just cval ->
                    Step_tau "Esseq subst" (
                      E.return <| th_st with arena= subst_syms _as (PEval cval) e2 |>
                    )
                | Nothing ->
                    Step_eval "Esseq" (
                      E.core_eval th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                      E.return <| th_st with arena= Esseq _as (Epure pe') e2 |>
                    )
              end
          | Nothing ->
              (* focus the execution on the first operand *)
              Step_tau "Esseq" (
                E.return <| th_st with
                  arena= e1;
                  stack= Stack_cons (Ksseq _as e2 :: cont) sk
                |>
              )
        end

    
    | (Esave k a_tys e, Stack_cons cont _) ->
        (* TODO: this is partial *)
        one $ Step_tau "Esave" (
          E.return <| th_st with arena= e; labels= Map.insert k (a_tys, apply_continuation cont e) th_st.labels |>
        )
    
    | (Erun annots k sym_vs, Stack_cons cont sk) ->
        one $ Step_tau "Erun" (
          match Map.lookup k th_st.labels with
            | Just cont ->
                SEU.return cont
            | Nothing ->
                match find_labeled_continuation k (apply_continuation cont th_st.arena) with
                  | Nothing ->
                      SEU.fail (Illformed_program ("unknown ksym when running an Erun" ^ show k))
                  | Just cont ->
                      SEU.return cont
                end
          end >>= fun ((sym_tys, e_cont) as cont) ->
          (* TODO: debug *)
(*          let _ = Boot.output_string ("stepping Erun ===> " ^ Boot.pp_core_expr e_cont) in *)
          
          (* we have to create the objects which are visible at the level of the save but not from the run *)
          let (create_as, create_tys) = unzip $ List.filter (fun (a,_) -> not (any (fun (x,_) -> x = a) sym_vs)) sym_tys in
          (* symmetrically, we have to kill the objects which are visible at the level of the run but not from the save.*)
          let kill_es = List.map snd $ List.filter (fun (a,_) -> not (any (fun (x,_) -> x = a) sym_tys)) sym_vs in
          let e =
            Ewseq [] (mk_unseq $ List.map (fun e -> pkill Loc.unknown e) kill_es)
              (Ewseq (List.map (fun z -> Just z) create_as) (mk_unseq $ List.map (fun ty ->
                let pe_ty = PEval (Vctype ty) in
                pcreate Loc.unknown (alignof pe_ty) pe_ty (Symbol.PrefOther "core_run, Erun")
              ) create_tys)
                 (foldl (fun acc (a, v) -> subst_sym a v acc) e_cont sym_vs)) in
          (* TODO: it seems strange that annotate_expr need to know the polarity *)
          let e' = add_to_sb (Set.map (fun z -> (Pos, z)) annots.sb_before) e in (* TODO: remove for sequential !!! *)
          E.return <| th_st with arena= e';
                                 stack= push_empty_continuation sk;
                                 labels= Map.insert k cont th_st.labels
                   |>
      )








    | (Eret pe, Stack_cons _ sk) ->
        one match valueFromPexpr pe with
          | Just cval ->
              match sk with
                | Stack_empty ->
                    (* "return" ending the execution of a thread. *)
                    match parent_tid_opt with
                      | Just parent_tid ->
                          Step_thread_done parent_tid cval
                      | Nothing ->
                          (* we reached the end of the startup thread's execution *)
                          (* TODO: this seems like a silly indirection *)
                          Step_tau "end of main thread" (
                            E.return <| th_st with arena= Epure pe; stack= empty_stack |>
                          )
                    end
                | Stack_cons cont sk' ->
                    (* "return" only ending the execution of a procedure. *)
                    Step_tau "end of procedure" (
                      E.return <| th_st with
                        arena= apply_continuation cont (Epure (PEval cval));
                        stack= push_empty_continuation sk';
(*
(* TODO: need stacked scopes ... *)
                        labels= Map.empty (* TODO: this is too violent, but doing no reset is unsound *)
*)
                      |>
                    )
              end
          | Nothing ->
              Step_eval "Eret" (
                E.core_eval th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                E.return <| th_st with arena= Eret pe' |>
              )
        end
    
    | (End es, _) ->
        (* -------------------------------------------
           <nd(e1, ..., eN), κs, Λ> --τ--> <ej, κs, Λ>    j ∈ {1, ..., N} *)
        List.map (fun e ->
          Step_tau "End" (E.return <| th_st with arena= e |>)
       ) es
    
    | (Epar es, _) ->
        (* TODO: doc *)
        one $ Step_spawn_threads (fun e -> <| th_st with arena= e |>) (
          List.map (fun e -> <|
            arena= e;
            stack= push_empty_continuation empty_stack;
            labels= Map.empty;
            current_loc= th_st.current_loc;
            exec_loc= ELoc_normal []
          |>) es
        )
    | (Ewait _, _) ->
        (* We don't do anything here. When a thread terminated, the driver
           substitute the corresponding wait in parent thread with the returned
           value. *)
        error "Core_run, Ewait"
    
    | (Eloc loc e, _) ->
        one $ Step_tau "Eloc" (
          E.return <| th_st with current_loc= loc; arena= e |>
        )
    
    | (Eraise handl, sk) ->
        error "WIP: Eraise"
    | (Eregister handl nm, sk) ->
        error "WIPL Eregister"
    
    | (Easeq _ _ _, _) ->
        error "Core_run must be called after Core_indet"
    | (Eindet _, _) ->
        error "Core_run must be called after Core_indet"
    | (Ebound _ _, _) ->
        error "Core_run must be called after Core_indet"
    
    | (e, Stack_empty) ->
        (* End of program execution *)
        one match maybe Nothing valueFromPexpr (to_pure e) with
          | Just cval ->
              Step_done cval
          | Nothing ->
              Step_error ("reached empty stack on a non-value arena: " ^ Boot.pp_core_expr e) (* TODO: better error message *)
        end
    
    | (e, Stack_cons cont sk) ->
        match to_pure e with
          | Just pe ->
              one match valueFromPexpr pe with
                | Just cval ->
                    Step_tau "value" (match cont with
                      | [] ->
                          error ("<e, Stack_cons []> with e= " ^ Boot.pp_core_expr e) (* TODO: what case is that? *)
                      | _ ->
                          (* -----------------------------------
                             <v, κ.κs, Λ> --τ--> <κ(v), ɛ.κs, Λ> *)
                          E.return <| th_st with arena= apply_continuation cont (Epure (PEval cval)); stack= push_empty_continuation sk |>
                    end)
                  | Nothing ->
                      (*          [| pe |] = v
                         -----------------------------
                         <pe, κs, Λ> --τ--> <v, κs, Λ> *)
                      Step_eval "pure" (
                        E.core_eval th_st.current_loc mem_st file concur_sym_map false pe >>= fun pe' ->
                        E.return <| th_st with arena= Epure pe' |>
                      )
                end
          | Nothing ->
              error "(Boot.pp_core_expr e)" (* TODO: better error message *)
        end
  end





























































(* BEGIN silly *)
(* Dummy function doing nothing, but required to typecheck *)
val     convert_expr: forall 'a. Core.expr 'a -> Core.expr core_run_annotation
let rec convert_expr expr =
  match expr with
    | Epure pe ->
        Epure pe
    | Ememop memop pes ->
        Ememop memop pes
    | Eraise h ->
        Eraise h
    | Eregister h nm ->
        Eregister h nm
    | Eskip ->
        Eskip
    | Elet sym pe1 e2 ->
        Elet sym pe1 (convert_expr e2)
    | Eif pe1 e2 e3 ->
        Eif pe1 (convert_expr e2) (convert_expr e3)
    | Eproc _ nm pes ->
        Eproc empty_annotation nm pes
    | Eaction pact ->
        Eaction (convert_paction pact)
    | Eunseq es ->
        Eunseq (List.map convert_expr es)
    | Ewseq _as e1 e2 ->
        Ewseq _as (convert_expr e1) (convert_expr e2)
    | Esseq _as e1 e2 ->
        Esseq _as (convert_expr e1) (convert_expr e2)
    | Easeq sym_opt act1 pact2 ->
        Easeq sym_opt (convert_action act1) (convert_paction pact2)
    | Eindet e ->
        Eindet (convert_expr e)
    | Ebound i e ->
        Ebound i (convert_expr e)
    | Esave ksym sym_tys e ->
        Esave ksym sym_tys (convert_expr e)
    | Erun _ ksym sym_pes ->
        Erun empty_annotation ksym sym_pes
    | Eret pe ->
        Eret pe
    | End es ->
        End (List.map convert_expr es)
    | Epar es ->
        Epar (List.map convert_expr es)
    | Ewait tid ->
        Ewait tid
    | Eloc loc e ->
        Eloc loc (convert_expr e)
  end

and convert_paction pact =
  match pact with
    | Paction p act ->
        Paction p (convert_action act)
  end

and convert_action act =
  match act with
    | Action loc _ act_ -> Action loc empty_annotation act_
  end



val convert_file: forall 'a. file 'a -> file core_run_annotation
let convert_file file =
  let convert_fun_map_decl = function
    | Fun bTy params pe ->
        Fun bTy params pe
    | Proc bTy params e ->
        Proc bTy params (convert_expr e)
  end in

 <|
  main=   file.main;
  stdlib= Map.map convert_fun_map_decl file.stdlib;
  impl=   file.impl;
  globs=  List.map (fun (sym, bTy, e) -> (sym, bTy, convert_expr e)) file.globs;
  funs=   Map.map convert_fun_map_decl file.funs;
 |>
(* END silly *)





val initial_io_state: io_state
let initial_io_state = <|
  stdout= Dlist.nil;
|>

val initial_core_state: core_state
let initial_core_state = <|
  thread_states= [];
  io= initial_io_state;
  handlers= Map.empty;
|>


(*
val init: Core.file core_run_annotation -> core_runM core_state
let init file =
  match Map.lookup file.main file.funs with
    | Nothing ->
        SEU.fail (Illformed_program "couldn't find the startup function")
    | Just (_, _, expr) ->
        SEU.return expr
  end >>= fun expr ->
  
  SEU.runS (spawn_thread Nothing <|
    arena= expr;
    stack= push_empty_continuation empty_stack;
    labels= Map.empty
  |> initial_core_state) >>= fun (_, st') ->
  
  SEU.return st'
*)



val initial_core_run_state: core_run_state
let initial_core_run_state = <|
  tid_supply=    UniqueId.new_supply;
  symbol_supply= UniqueId.new_supply;
  aid_supply=    UniqueId.new_supply;
  
  step_counter= 0;
|>
