open Global
open Core
open Core_aux

(* BEGIN: Core continuation ********************************************************************* *)
type _cont 'a =
  | Kunseq of list (expr 'a) * list (expr 'a)
  | Kwseq of list (option sym) * expr 'a
  | Ksseq of list (option sym) * expr 'a

type cont 'a = list (_cont 'a)


(* BEGIN: printing stuff for DEBUG *)
val     sepBy: forall 'a. string -> ('a -> string) -> list 'a -> string
let rec sepBy sep f xs =
  match xs with
    | []     -> ""
    | [x]    -> f x
    | x::xs' -> f x ^ sep ^ sepBy sep f xs'
  end

val string_of_cont: forall 'a. cont 'a -> string
let string_of_cont k =
  let f = function
    | Kunseq [] es2 -> fun x -> "[ " ^ x ^ " || " ^ sepBy " || " Boot.pp_core_expr es2 ^ " ]"
    | Kunseq es1 [] -> fun x -> "[ " ^ sepBy " || " Boot.pp_core_expr es1 ^ " || " ^ x ^ " ]"
    | Kunseq es1 es2 -> fun x -> "[ " ^ sepBy " || " Boot.pp_core_expr es1 ^ " || " ^ x ^ " || " ^ sepBy " || " Boot.pp_core_expr es2 ^ " ]"
    | Kwseq _as e2   -> fun x -> "wseq _as = (" ^ x ^ ") in " ^ Boot.pp_core_expr e2
    | Ksseq _as e2   -> fun x -> "sseq _as = (" ^ x ^ ") in " ^ Boot.pp_core_expr e2
  end in
  List.fold_left (fun acc x -> f x acc) "\x1b[1;32m[]\x1b[0m" k
(* END: printing stuff for DEBUG *)


val apply_cont: forall 'a. cont 'a -> expr 'a -> expr 'a
let apply_cont k e =
  let f _k e =
    match _k with
      | Kwseq _as e2   -> Ewseq _as e e2
      | Ksseq _as e2   -> Esseq _as e e2
      | Kunseq es1 es2 -> Eunseq $ es1 @ e :: es2
    end in
  List.fold_left (fun acc x -> f x acc) e k


(*
val compose_cont: forall 'a. cont 'a -> cont 'a -> cont 'a
let compose_cont k1 k2 = k1 @ k2
*)
(* END: Core continuation ********************************************************************* *)


(* TODO: this is part of the "memory model" but need to be before Effect (...) *)
type mem_value =
  | Muninit
  | Mint of int
  | Mobj of (list Symbol.t * num)


type mem_state = Pmap.map mem_addr mem_value * num


type taction_id = num

(* Fully evaluated description of an action *)
type trace_action =
  | Tcreate of Ail.ctype * mem_addr (* the second argument is the created object *)
  | Talloc of (* TODO: num *) int * mem_addr (* the second argument is the created object *)
  | Tkill of mem_addr
  | Tstore of Ail.ctype * mem_addr * mem_value
  | Tload of Ail.ctype * mem_addr * mem_value (* the last argument is the read value *)

type trace_paction = polarity * trace_action



(* TODO: here I'm annotating all actions instead (this may reduce the number of
         epsilon transitions) *)
(* [annotate b e] add on each sb-minimal action of [e] an annotation meaning
                  that this action is sequenced-after [act]
  
  in the rules comments, this function is noted: <b> e
 *)
val annotate_expr: polarity * taction_id -> expr taction_id -> expr taction_id
let rec annotate_expr p_aid e =
  match e with
  | Elet a e1 e2         -> Elet a e1 (annotate_expr p_aid e2)
  | Eif e1 e2 e3         -> Eif e1 (annotate_expr p_aid e2) (annotate_expr p_aid e3)
  | Eaction (p, (bs, a)) -> Eaction (p, ({snd p_aid} union bs, a))
  | Eunseq es            -> Eunseq (List.map (annotate_expr p_aid) es)
  | Ewseq _as e1 e2      -> Ewseq _as (annotate_expr p_aid e1) (match fst p_aid with Pos -> annotate_expr p_aid e2 | Neg -> e2 end)
  | Esseq _as e1 e2      -> Esseq _as (annotate_expr p_aid e1) (annotate_expr p_aid e2)
  | Esave k a_tys e      -> Esave k a_tys (annotate_expr p_aid e)
  | End es               -> End (List.map (annotate_expr p_aid) es)
  | Eproc bs f pes       -> Eproc ({snd p_aid} union bs) f pes
  | _                    -> e
end


(* TODO: doesn't do what it should *)
val annotate: polarity * taction_id -> list (cont taction_id) -> list (cont taction_id)
let rec _annotate (p, aid) k =
  match k with
    | []                   -> []
    | Kunseq es1 es2 :: k' -> Kunseq es1 es2 :: _annotate (p, aid) k'
    | Kwseq _as e2   :: k' -> Kwseq _as (match p with Pos -> annotate_expr (p, aid) e2 | Neg -> e2 end) :: _annotate (p, aid) k'
    | Ksseq _as e2   :: k' -> Ksseq _as (annotate_expr (p, aid) e2) :: _annotate (p, aid) k'
  end
let annotate aid ks = List.map (_annotate aid) ks
(*
let annotate a ks =
  match ks with
    | []       -> []
    | k :: ks' -> _annotate a k :: ks'
  end
*)



(* this type represents reduction rules and is used for annotating trace element
   (for debug purpose) *)
type dyn_rule =
  | Rule_Pos
  | Rule_Neg
  | Rule_Pure_Hole
  | Rule_Pure
  | Rule_If
  | Rule_Let
  | Rule_Ret
  | Rule_Skip
  | Rule_Proc
  | Rule_Wseq
  | Rule_Wseq_Neg
  | Rule_Sseq
  | Rule_Run
  | Rule_Save
  | Rule_Unseq

(* BEGIN: DEBUG *)
let string_of_rule = function
  | Rule_Pos        -> "pos"
  | Rule_Neg        -> "neg"
  | Rule_Pure_Hole  -> "pure_hole"
  | Rule_Pure       -> "pure"
  | Rule_If         -> "if"
  | Rule_Ret        -> "ret"
  | Rule_Let        -> "let"
  | Rule_Skip       -> "skip"
  | Rule_Proc       -> "proc"
  | Rule_Wseq       -> "wseq"
  | Rule_Wseq_Neg   -> "wseq_neg"
  | Rule_Sseq       -> "sseq"
  | Rule_Run        -> "run"
  | Rule_Save       -> "save"
  | Rule_Unseq      -> "unseq"
end
(* END: DEBUG *)



(* list monad *)
module L = struct
  val return: forall 'a. 'a -> list 'a
  let return x = [x]
  
  val bind: forall 'a 'b. list 'a -> ('a -> list 'b) -> list 'b
  let bind m f = List.fold_right (fun x y -> (f x) @ y) m []
end


(* Exception monad for possibly undefined executions *)
module U = struct
  type t 'a =
    | Defined of 'a
    | Undef of list Undefined.undefined_behaviour
    | Error
  
  val return: forall 'a. 'a -> t 'a
  let return x = Defined x
  
  val (>>=): forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
  let (>>=) m f =
    match m with
      | Defined x -> f x
      | Undef us  -> Undef us (* TODO: we probably want to collect as much undefs as possible, ie. continue that exec ? *)
      | Error     -> Error
  end
  
  let sequence ms = List.fold_right (fun m acc ->
    m   >>= fun x  ->
    acc >>= fun xs ->
    return (x::xs)) ms (return [])
  val mapM: forall 'a 'b. ('a -> t 'b) -> list 'a -> t (list 'b)
  let mapM f xs = sequence (List.map f xs)
  
  
  val undef: forall 'a. list Undefined.undefined_behaviour -> t 'a
  let undef us = Undef us
  
  val error: forall 'a. t 'a
  let error = Error
end



module Effect = struct
  (* the elements of a trace are triple, where:
       - the first element is a description of the reduction rules used for this
         step (this is for a DEBUG feature)
       - the second element is the set of actions sequenced before the action
         that has just been performed
       - the third element is the action that as been performed during that step
     *)
  type trace = list (dyn_rule * option (set taction_id * taction_id))
  
  type execution_mode =
    | Exhaustive
    | Random
  
  type state = <|
    execution_mode: execution_mode;                                             (* TODO: it's a bit silly that this is here, since the setting won't change *)
    mem:            mem_state;                                                  (* the memory layout state                            *)
    current_proc:   option sym;                                                 (* the C function whose body we are reducing (if any) *)
    fun_map:        fun_map taction_id;                                         (* map of functions                                   *)
    cont_map:       map sym (map ksym (list (sym * Ail.ctype) * expr taction_id)); (* maps of labeled continuations (per function)       *)
    tact_counter:   num;                                                        (* counter for the trace actions map                  *)
    tact_map:       Pmap.map taction_id trace_action;
    trace:          trace;                                                      (* the execution trace so far (stored in reversed)    *)
  |>
  
  type t 'a = state -> U.t (list ('a * state))
  
  
  (* monadic operations *)
  val return: forall 'a. 'a -> t 'a
  let return x = fun s -> U.return [(x, s)]
  
  (* TODO: looks fishy *)
  val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
  let bind m f = fun s ->
    match m s with
      | U.Defined zs -> List.fold_right (fun (a, s') acc ->
                          match acc with
                            | U.Defined y -> match f a s' with U.Defined z' -> U.Defined (z' @ y) | U.Undef us -> U.Undef us | U.Error -> U.Error end
                            | U.Undef us  -> U.Undef us
                            | U.Error     -> U.Error
                          end) zs (U.Defined [])
      | U.Undef us -> U.Undef us
      | U.Error    -> U.Error
    end
  
  
  (* running a U computation *)
  val runU: forall 'a. U.t 'a -> t 'a
  let runU m =
    match m with
      | U.Defined x -> return x
      | U.Undef us  -> fun s -> U.undef us
      | U.Error     -> fun s -> U.error
    end
  
  (* MonadPlus operations *)
  val mzero: forall 'a. t 'a
  let mzero = fun s -> U.return []
  
  val mplus: forall 'a. t 'a -> t 'a -> t 'a
  let mplus a b = fun s ->
    match (a s, b s) with
      | (U.Defined x, U.Defined y) -> U.Defined (x @ y)
      (* TODO: ahem, now this isn't very associative *)
      (* TODO2: may be better now *)
      | (U.Undef us1, U.Undef us2) -> U.Undef (us1 @ us2)
      | (U.Undef us, _)            -> U.Undef us
      | (_, U.Undef us)            -> U.Undef us
      | _                          -> U.error
    end
  
  
  (* generic functions (that should be moved out once we have type-classes) *)
  val msum: forall 'a. list (t 'a) -> t 'a
  let msum xs = List.fold_right mplus xs mzero
  
  
  
  (* like msum, but the order matter, no it's not a like msum (ahem) *)
  val     dmsum: forall 'a. list (t 'a) -> t 'a
  let rec dmsum ms =
    fun s ->
      match ms with
        | []     -> U.return []
        | m::ms' -> match m s with
                      | U.Defined [] -> (dmsum ms') s
                      | v            -> v
                    end
      end
  
  
  val     foldlM: forall 'a 'b. ('a -> 'b -> t 'b) -> list 'a -> 'b -> t 'b
  let rec foldlM f l a =
    match l with
      | []    -> return a
      | x::xs -> bind (f x a) (foldlM f xs)
    end
  
  module Operators = struct
    let (>>=) = bind
    let (>>) m f = bind m (fun _ -> f)
  end

  open Operators
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)
  
  let sequence_ ms = List.fold_right (>>) ms (return ())
  val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
  let mapM_ f _as = sequence_ (List.map f _as)
  
  
  val set_current_proc: sym -> t unit
  let set_current_proc pname = fun s ->
    U.return [((), <| s with current_proc= Some pname |>)]
  
  
  val register_funs: fun_map taction_id -> t unit
  let register_funs funs = fun s ->
    U.return [((), <| s with fun_map= funs |>)]
  
  val get_fun_map: t (fun_map taction_id)
  let get_fun_map = fun s ->
    U.return [(s.fun_map, s)]
  
  val get_proc: sym -> t (core_type * list (sym * core_base_type) * expr taction_id)
  let get_proc fname = fun s ->
    U.return [(Pmap.find fname s.fun_map, s)]
  
  val register_conts: map sym (map ksym (list (sym * Ail.ctype) * expr taction_id)) -> t unit
  let register_conts ks = fun s ->
    U.return [((), <| s with cont_map= ks |>)]
  
  val get_cont: ksym -> t (list (sym * Ail.ctype) * expr taction_id)
  let get_cont d = fun s ->
    U.return [(Pmap.find d $ Pmap.find (from_Some s.current_proc) s.cont_map, s)]

(*
  val get_sym: sym -> t (expr taction_id)
  let get_sym _a =
    fun s ->
      if Pmap.mem _a s.sym_map then
        [ (Pmap.find _a s.sym_map, s) ]
      else
        Boot.assert_false "BUG: Core_run.get_sym"
  
  val put_sym: sym -> expr taction_id -> t unit
  let put_sym _a e =
    fun s -> 
      [((), <| s with sym_map= Pmap.add _a e s.sym_map |>)]
*)


(*
      (* TODO: this is disgusting *)
      let e' = match e with
                 | Esym _a' -> match Symbol_table.find _a' s.sym_map with
                                 | None   -> Boot.assert_false "BUG: Core_run.put_sym"
                                 | Some z -> z
                               end
                 | _        -> e
               end
      in [((), <| s with sym_map= Symbol_table.add _a e' s.sym_map |>)]
      *)

val set_execution_mode: execution_mode -> t unit
let set_execution_mode mode = fun s ->
  U.return [((), <| s with execution_mode= mode |>)]

val get_execution_mode: t execution_mode
let get_execution_mode = fun s ->
  U.return [(s.execution_mode, s)]


end

(* -------------------------------------------------------------------------- *)
module E = Effect
open E.Operators


(* ************************************************************************** *)
(* TODO: dummy memory model (concrete with isolated objects, ignoring C types) *)
val initial_state: E.state
let initial_state = <|
  E.execution_mode= E.Exhaustive;
  E.mem=            (Pmap.empty, 0);
  E.current_proc=   None;
  E.fun_map=        Pmap.empty;
  E.cont_map=       Pmap.empty;
  E.tact_counter=   0;
  E.tact_map=       Pmap.empty;
  E.trace=          []
|>

val init: E.t unit
let init = fun _ -> U.return [((), initial_state)]

(* static object allocation *)
val create: list Symbol.t -> Ail.ctype -> E.t mem_addr
let create pref _ = fun (<| E.mem= (m, i) |> as s) ->
  (* DEBUG *)
  Boot.print_debug ("[Core_run.create] @" ^ (string_of_num i)) $
  
  let o = (pref, i) in
  U.return [(o, <| s with E.mem= (Pmap.add o Muninit m, i+1) |>)]

(* TODO: doesn't do anything regarding the size *)
(* dynamic object allocation (malloc) *)
val alloc: list Symbol.t -> int -> E.t mem_addr
let alloc pref _ = fun (<| E.mem= (m, i) |> as s) ->
  let o = (pref, i) in
  U.return [(o, <| s with E.mem= (Pmap.add o Muninit m, i+1) |>)]

(* static/dynamic object deallocation *)
val kill: mem_addr -> E.t unit
let kill o = fun (<| E.mem= (m, i) |> as s) ->
  (* DEBUG *)
  Boot.print_debug ("[Core_run.kill] @" ^ (string_of_num $ snd o))
  U.return [((), <| s with E.mem= (Pmap.remove o m, i) |> )]

val store: Ail.ctype -> mem_addr -> mem_value -> E.t unit
let store _ o v = fun (<| E.mem= (m, i) |> as s) ->
  (* DEBUG *)
  Boot.print_debug ("[Core_run.store] @" ^ (string_of_num $ snd o))
  U.return [((), <| s with E.mem= (Pmap.add o v m, i) |>)]

val load: Ail.ctype -> mem_addr -> E.t mem_value
let load _ o = fun (<| E.mem= (m, _) |> as s) ->
  (* DEBUG *)
  if not (Pmap.mem o m) then
    Boot.print_debug ("[Core_run.load] Not_found: @" ^ (string_of_num $ snd o))
    U.undef [Undefined.Outside_lifetime]
  else
    (* DEBUG *)
    Boot.print_debug ("[Core_run.load] @" ^ (string_of_num $ snd o))
    U.return [(Pmap.find o m, s)]




(* ************************************************************************** *)

(* non-deterministically pick an element of a list with its context within the
   list. (e.g. pick_one [1,2,3] = [ ([],1,[2; 3]); ([1],2,[3]); ([1; 2],3,[]) ])
 *)
(* EXHAUSTIVE MODE *)
let rec _pick_one_exhaustive pred acc = function
  | []    -> []
  | x::xs -> (if pred x then fun z -> (List.rev acc, x, xs) :: z else fun z -> z) $ _pick_one_exhaustive pred (x::acc) xs
end
let pick_one_exhaustive pred l = E.msum $ List.map E.return (_pick_one_exhaustive pred [] l)

(* RANDOM MODE *)
let rec _pick_one_random pred = function
  | [] -> None
  | l  -> let (xs, y, zs) = Boot.pickList l in
          if pred y then
            Some (xs, y, zs)
          else
            match _pick_one_random pred (xs @ zs) with
              | Some (xs', y', zs') ->
                let n  = List.length xs  in
                let n' = List.length xs' in
                if n' < n then
                  let (a, b) = splitAt (n - n' - 1) zs' in
                  Some (xs', y', a @ y :: b)
                else
                  let (a, b) = splitAt n xs' in
                  Some (a @ y :: b, y', zs')
              | None                -> None
            end
end
let pick_one_random pred l = fun s ->
  match _pick_one_random pred l with
    | Some x -> U.return [(x, s)]
    | None   -> U.return []
  end

val pick_one: forall 'a. ('a -> bool) -> list 'a -> E.t (list 'a * 'a * list 'a)
let pick_one pred l =
  E.get_execution_mode >>= function
    | E.Exhaustive -> pick_one_exhaustive pred l
    | E.Random     -> pick_one_random pred l
  end




(* push an element in the trace *)
val push_trace: (dyn_rule * option (set taction_id * trace_action)) -> E.t (option taction_id)
let push_trace (r, tact_opt) =
  Boot.print_debug ("RULE ==> " ^ string_of_rule r) $
    fun (<| E.tact_counter= n; E.tact_map= tact_map; E.trace= t |> as s) ->
      match tact_opt with
        | None            -> U.return [(None,   <| s with E.trace= (r, None) :: t |>)]
        | Some (bs, tact) -> U.return [(Some n, <| s with E.tact_counter= n+1; E.tact_map= Pmap.add n tact tact_map; E.trace= (r, Some (bs, n)) :: t |>)]
     end

(* get the last element of the trace (crash if none). *)
val get_trace: E.t (dyn_rule * option (set taction_id * trace_action))
let get_trace = function
  | <| E.trace= [] |> ->
      Boot.assert_false "[Core_run.get_trace] empty trace"
  | (<| E.tact_map= tact_map; E.trace= (r, tact_opt) :: _ |> as s) ->
      U.return [((r, match tact_opt with Some (bs, n) -> Some (bs, Pmap.find n tact_map) | None -> None end), s)]
end

val get_fulltrace: E.t (Pmap.map taction_id trace_action * E.trace)
let get_fulltrace = fun (<| E.tact_map= tact_map; E.trace= t |> as s) ->
  U.return [((tact_map, t), s)]





(* mutate the rule descriptor of the most recent trace element (used by
   inductive rule after application of their premises) *)
(*
val update_rule: (dyn_rule -> dyn_rule) -> E.t unit
let update_rule f = fun (<| E.trace= t |> as s) ->
  match t with
    | []               -> Boot.outOfHomeomorphism "[Core_run.update_rule] empty trace"
    | (r, bs_a) :: ts  -> [((), <| s with E.trace= (f r, bs_a) :: ts |>)]
  end
*)







(*
val put_syms: list (option sym) -> expr taction_id -> E.t unit
let put_syms _as v =
  match (_as, v) with
    | ([]       , _        ) -> E.return ()
    | ([None], _           ) -> E.return ()
    | ([Some _a], _        ) -> E.put_sym _a v
    | (_        , Etuple vs) -> E.mapM_ (fun (_a_opt, v) -> match _a_opt with Some _a -> E.put_sym _a v| None -> E.return () end) (List.combine _as vs)
    | (_        , Eunseq vs) -> E.mapM_ (fun (_a_opt, v) -> match _a_opt with Some _a -> E.put_sym _a v| None -> E.return () end) (List.combine _as vs)
  end 
*)


(* takes the symbolic names of a function, some pure expressions and produce
   the function body where the arguments have been substituted *)
val call_function: forall 'a. fun_map 'a -> sym -> list (expr 'a) -> expr 'a
let call_function fun_map fname args =
  let (_, params, fbody) = Pmap.find fname fun_map in
  if List.length params <> List.length args then
    Boot.assert_false $ "[Core_run.call_function] wrong number of args applied to `" ^ Boot.pp_core_expr (Esym fname) ^ "'"
  else
    (List.fold_left2 (fun acc (_a, _) arg -> subst_sym _a arg acc) fbody params args)


val call_proc: sym -> list (expr taction_id) -> E.t (expr taction_id)
let call_proc fname args =
  E.get_proc fname >>= fun (_, params, fbody) ->
  if List.length params <> List.length args then
    Boot.assert_false $ "[Core_run.call_proc] wrong number of args applied to `" ^ Boot.pp_core_expr (Esym fname) ^ "'"
  else
    E.set_current_proc fname >>
    E.return (List.fold_left2 (fun acc (_a, _) arg -> subst_sym _a arg acc) fbody params args)




let rec collect_values v =
  match v with
    | Etuple vs -> let vss = List.map collect_values vs in
                   List.concat vss
    | _         -> [v]
  end


(* evaluation of pure epxressions (will crash on ill-typed and/or non pure
   expressions) *)
open U
val     eval: forall 'a. fun_map 'a -> expr 'a -> U.t (expr 'a)
let rec eval fun_map pe =
  let eval = eval fun_map in
  match pe with
    | Eundef u -> U.undef [u]
    | Eerror   -> U.error
    | Eop binop pe1 pe2 ->
        eval pe1 >>= fun v1 ->
        eval pe2 >>= fun v2 ->
        U.return
          match (binop, v1, v2) with
            | (OpAdd, Econst n1,  Econst n2 ) -> Econst (Int.(+) n1 n2)
            | (OpSub, Econst n1,  Econst n2 ) -> Econst (Int.(-) n1 n2)
            | (OpMul, Econst n1,  Econst n2 ) -> Econst (Int.( * ) n1 n2)
            | (OpDiv, Econst n1,  Econst n2 ) -> Econst (Int.(/) n1 n2)
            | (OpMod, Econst n1,  Econst n2 ) -> Econst (Int.(%) n1 n2)
            | (OpEq,  Econst n1,  Econst n2 ) -> if n1 = n2 then Etrue else Efalse
            | (OpEq,  Ectype ty1, Ectype ty2) -> if Ail.ctype_eq ty1 ty2 then Etrue else Efalse
            | (OpLt,  Econst n1,  Econst n2 ) -> if Int.(<) n1 n2 then Etrue else Efalse
            | (OpOr,  Efalse,     Efalse    ) -> Efalse
            | (OpOr,  _,          _         ) -> Etrue
            | (OpAnd, Etrue,      Etrue     ) -> Etrue
            | (OpAnd, _,          _         ) -> Efalse
            | (_,     v1,         v2        ) -> Boot.assert_false $ Boot.pp_core_expr (Eop binop v1 v2)
          end
    | Enot pe ->
        eval pe >>= function
          | Etrue  -> U.return Efalse
          | Efalse -> U.return Etrue
        end
    | Elet _a pe1 pe2 ->
        eval pe1 >>= fun v1 ->
        eval (subst_sym _a v1 pe2)
    | Eif pe1 pe2 pe3 ->
        eval pe1 >>= function
          | Etrue  -> eval pe2
          | Efalse -> eval pe3
        end
    | Ecall f pes -> eval (call_function fun_map f pes)



(* TODO: this may be very counter-intuitive, but we have it as a hack to remove skips comming from negative actions

==> probably need some trick during typing

*)
    | Eunseq pes ->
        U.mapM eval pes >>= fun vs ->
        U.return
          match (* List.filter (fun (Left v) -> v <> Eskip) $ *) vs with
            | []  -> Etuple [] (* HACK: better had a Eunit ctor *)
            | [v] -> v
            | vs  -> Etuple vs
          end

(*
        match List.filter (function Left _ -> false | Right _ -> true end) vs with
        | [] -> match (* List.filter (fun (Left v) -> v <> Eskip) $ *) vs with
                  | []       -> Left (Etuple []) (* HACK: better had a Eunit ctor *)
                  | [Left v] -> Left v
                  | vs       -> Left (Etuple $ List.map (fun (Left v) -> v) vs)
                end
        | vs' -> Right $ List.fold_left (fun acc (Right us) -> us @ acc) [] vs'
      end
*)
    
    | Ewseq _as pe1 pe2 ->
        eval pe1 >>= fun v1 ->
        eval (subst_syms _as v1 pe2)
    
    (* If [pe] is not pure this is wrong, we should crash instead *)
    | _ -> if is_value pe then U.return pe else Boot.assert_false $ "[Core_run.eval] found an impure expression or a symbol: " ^ Boot.pp_core_expr pe
  end


(* TODO: this function will call the implementation of a given action in a
         particular memory model *)
open E.Operators
val perform_action: action_ taction_id -> E.t (trace_action * expr taction_id)
let perform_action act =
  E.get_fun_map >>= fun fun_map ->
  let eval = eval fun_map in
  match act with
    | Create pe pref ->
        E.runU (eval pe) >>= fun (Ectype ty) ->
        create pref ty   >>= fun o           ->
        E.return (Tcreate ty o, Eaddr o)
    | Alloc pe pref ->
        E.runU (eval pe) >>= fun (Econst n) ->
        alloc pref n     >>= fun o          ->
        E.return (Talloc n o, Eaddr o)
    | Kill pe ->
        E.runU (eval pe) >>= fun (Eaddr o) ->
        kill o           >>
        E.return (Tkill o, Eskip)
    | Store pe1 pe2 pe3 ->
        E.runU (eval pe1) >>= fun (Ectype ty) ->
        E.runU (eval pe2) >>= fun (Eaddr o)   ->
        E.runU (eval pe3) >>= function
          | Econst n -> store ty o (Mint n)  >> E.return (Tstore ty o (Mint n), Eskip)
          | Eaddr o' -> store ty o (Mobj o') >> E.return (Tstore ty o (Mobj o'), Eskip)
          | v        -> Boot.assert_false $ "[perform_action, Kstore] " ^ (Boot.pp_core_expr pe3) ^ " ==> " ^ (Boot.pp_core_expr v)
        end
    | Load pe1 pe2 ->
        E.runU (eval pe1) >>= fun (Ectype ty) ->
        E.runU (eval pe2) >>= fun (Eaddr o)   ->
        load ty o >>= function
          | Mint v -> E.return (Tload ty o (Mint v), Econst v)
          | Mobj v -> E.return (Tload ty o (Mobj v), Eaddr v)
          | Munint -> Boot.print_debug "READ AN UNINIT" $
                        E.return (Tload ty o Munint, Econst (Int.neg (Int.int 10)))
        end
end






(* NOTE: the assumption is made that an Eunseq cannot directly be the
         subexpression of an another Eunseq *)
val red2: expr taction_id * list (cont taction_id) -> E.t (expr taction_id * list (cont taction_id))

let rec red2_pos x =
  match x with
    | (Eaction (Pos, (bs, a)), _KS) ->
        perform_action a                    >>= fun (a, v)   ->
        push_trace (Rule_Pos, Some (bs, a)) >>= fun (Some aid) ->
        E.return (v, annotate (Pos, aid) _KS)
    | _ -> E.mzero
  end

and red2_neg x =
  match x with
    | (Eaction (Neg, (bs, a)), _KS) ->
        perform_action a                    >>= fun (a, v)   ->
        push_trace (Rule_Neg, Some (bs, a)) >>= fun (Some aid) ->
        E.return (v, annotate (Neg, aid) _KS)
    | _ -> E.mzero
  end 

and red2_pure x =
  match x with
    | (e, [] :: _KS) ->
        if is_pure e then
          push_trace (Rule_Pure_Hole, None) >>
          E.get_fun_map                     >>= fun fun_map ->
          E.runU (eval fun_map e)           >>= fun v       ->
          E.return (v, _KS)
        else
          E.mzero
    | (e, _K :: _KS) ->
        if is_pure e then
          push_trace (Rule_Pure, None) >>
          E.get_fun_map                >>= fun fun_map ->
          E.runU (eval fun_map e)      >>= fun v       ->
          E.return (apply_cont _K v, [] :: _KS)
        else
          E.mzero
    | _ -> E.mzero
  end

and red2_if x =
  match x with
    | (Eif pe e2 e3, _KS) ->
        E.get_fun_map            >>= fun fun_map ->
        E.runU (eval fun_map pe) >>= function
          | Etrue  -> push_trace (Rule_If, None) >> E.return (e2, _KS)
          | Efalse -> push_trace (Rule_If, None) >> E.return (e3, _KS)
        end
    | _ -> E.mzero
  end

and red2_let x =
  match x with
    | (Elet _a pe1 e2, _KS) ->
        E.get_fun_map               >>= fun fun_map ->
        E.runU (eval fun_map pe1)   >>= fun v1      ->
        push_trace (Rule_Let, None) >> E.return (subst_sym _a v1 e2, _KS)
    | _ -> E.mzero
  end

and red2_ret x =
  match x with
    | (Eret pe, _K :: _KS) ->
          push_trace (Rule_Ret, None) >>
          E.get_fun_map               >>= fun fun_map ->
          E.runU (eval fun_map pe)    >>= fun v ->
          E.return (v, _KS)

(*
        if is_value e then
          eval e                      >>= fun v ->
          push_trace (Rule_Ret, None) >>
(*          E.pop_syms >> *)
          E.return (v, _KS)
        else 
          E.mzero
*)
    | _ -> E.mzero
  end


and red2_skip x =
  match x with
    | (Eskip, [Kwseq _ e2] :: _KS) ->
        push_trace (Rule_Skip, None) >>
        E.return (e2, [] :: _KS)
    | (Eskip, (Kwseq _ e2 :: _KS1) :: _KS2) ->
        push_trace (Rule_Skip, None) >>
        E.return (e2, _KS1 :: _KS2)

    | (Eskip, [Ksseq _ e2] :: _KS) ->
        push_trace (Rule_Skip, None) >>
        E.return (e2, [] :: _KS)
    | (Eskip, (Ksseq _ e2 :: _KS1) :: _KS2) ->
        push_trace (Rule_Skip, None) >>
        E.return (e2, _KS1 :: _KS2)

    | (Eskip, ((Kunseq es1 es2) :: _KS1) :: _KS2) ->
        push_trace (Rule_Skip, None) >>
        E.return
          (match es1 @ es2 with
             | []  -> Etuple []
             | [e] -> e
             | es  -> Eunseq es
           end, _KS1 :: _KS2)


(*    | (Eskip, _K :: _KS) -> push_trace (Rule_Skip, None) >> E.return (apply_cont _K Eskip, _KS) *)
    | _                       -> E.mzero
  end


and red2_proc x =
  match x with
    | (Eproc bs f es, _KS) ->
        push_trace (Rule_Proc, None)      >>
        E.get_fun_map                     >>= fun fun_map ->
        E.runU (U.mapM (eval fun_map) es) >>= fun vs      ->
        call_proc f vs                    >>= fun f_body  ->
(*
Boot.print_debug (Boot.pp_core_expr (Core.Etuple es)) $
Boot.print_debug (Boot.pp_core_expr f_body) $
*)

(* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
        E.return (Set.fold (fun b e -> annotate_expr (Pos, b) e) bs f_body, [] :: _KS)
    | _ -> E.mzero
  end


and red2_wseq x =
  match x with
    | (Ewseq _ (Eaction (Neg, b)) e2, _KS) ->
        E.mzero (* Leaving it to red2_neg_wseq *)
    | (Ewseq _as e1 e2, _KS) ->
        push_trace (Rule_Wseq, None) >>
          if is_pure e1 then
            E.get_fun_map            >>= fun fun_map ->
            E.runU (eval fun_map e1) >>= fun v1      ->
            Boot.print_debug ("IS_PURE: " ^ Boot.pp_core_expr v1) $
            E.return (subst_syms _as v1 e2, _KS)
          else match _KS with
            | _K :: _KS -> E.return (e1, (Kwseq _as e2 :: _K) :: _KS)
            | []        -> E.return (e1, [[Kwseq _as e2]])
          end
    | _ -> E.mzero
  end 

and red2_neg_wseq x =
  match x with
    | (Ewseq _ (Eaction (Neg, b)) e2, _KS) ->
        push_trace (Rule_Wseq_Neg, None) >>
        E.return match e2 with
          | Eunseq e2's -> (Eunseq $ (Eaction (Neg, b)) :: e2's, _KS)
          | _           -> (Eunseq [Eaction (Neg, b); e2], _KS)
        end
    | (Ewseq _as (Eunseq es) e2, _KS) ->
        pick_one (is_negative) es >>= function
               (* TODO: there is a hack here: the symbol corresponding to ej should be dropped from ej, instead of adding a skip dans the first unseq (...) *)
          | (es1, Eaction (Neg, b), es2) ->
              push_trace (Rule_Wseq_Neg, None) >>
              E.return match e2 with
                | Eunseq e2's -> (Ewseq _as (Eunseq $ es1 @ Eskip :: es2) (Eunseq $ Eaction (Neg, b) :: e2's), _KS)
                | _           -> (Ewseq _as (Eunseq $ es1 @ Eskip :: es2) (Eunseq [Eaction (Neg, b); e2]), _KS)
              end
          | _ -> Boot.assert_false "impossible"
        end
    | _ -> E.mzero
end


and red2_sseq x =
  match x with
    | (Esseq _as e1 e2, _KS) ->
        push_trace (Rule_Sseq, None) >>
          if is_pure e1 then
            E.get_fun_map            >>= fun fun_map ->
            E.runU (eval fun_map e1) >>= fun v1      ->
            Boot.print_debug ("IS_PURE: " ^ Boot.pp_core_expr e1) $
            E.return (subst_syms _as v1 e2, _KS)
          else match _KS with
            | _K :: _KS -> E.return (e1, (Ksseq _as e2 :: _K) :: _KS)
            | []        -> E.return (e1, [[Ksseq _as e2]])
          end
    | _ -> E.mzero
  end

(* TODO: check that rule, nothing fancy should be needed, since we don't allow
         save/run inside unseq expressions *)
and red2_unseq x =
  match x with
    | (Eunseq es, _K :: _KS) ->
        pick_one (not -| is_pure) es >>= fun (es1, ej, es2) ->
          Boot.print_debug ("ej = " ^ Boot.pp_core_expr ej) $ 
          push_trace (Rule_Unseq, None) >>
          E.return (ej, (Kunseq es1 es2 :: _K) :: _KS)
    | _ -> E.mzero
  end

and red2_run x =
  match x with
    | (Erun d a_vs, _K :: _KS) ->
        E.get_cont d >>= fun (a_tys, e_cont) ->
        push_trace (Rule_Run, None) >>
        (* we have create the objects which are visible at the level of the save but not from the run *)
        let (create_as, create_tys) = unzip $ List.filter (fun (a,_) -> not (List.exist (fun (x,_) -> x = a) a_vs)) a_tys in
        (* symmetrically, we have to kill the objects which are visible at the level of the run but not from the save.*)
        let kill_es = List.map snd $ List.filter (fun (a,_) -> not (List.exist (fun (x,_) -> x = a) a_tys)) a_vs in

        E.return
          (Ewseq [] (mk_unseq $ List.map (fun e -> pkill e) kill_es)
             (Ewseq (List.map (Some) create_as) (mk_unseq $ List.map (fun ty -> pcreate (Ectype ty) []) create_tys)
                (List.fold_left (fun acc (a, v) -> subst_sym a v acc) e_cont a_vs)),
           [] :: _KS)
    | _ -> E.mzero
  end

and red2_save x =
  match x with
    | (Esave _ _ e, _KS) ->
        push_trace (Rule_Save, None) >>
        E.return (e, _KS)
    | _ -> E.mzero
  end

and red2 e =
  E.dmsum [
    red2_pure e; red2_skip e;
    E.msum [
      red2_pos e; red2_neg e; red2_unseq e;
      red2_if e; red2_let e; red2_ret e;
      red2_proc e;
      red2_wseq e; red2_neg_wseq e;
      red2_sseq e;
      red2_run e; red2_save e
    ]
  ]


val     star_red2: expr taction_id * list (cont taction_id) -> E.t ((expr taction_id * list (cont taction_id)) * (Pmap.map taction_id trace_action * E.trace))
let rec star_red2 x =
  let continue =
    red2 x >>= fun z ->
(* BEGIN: DEBUG *)
    get_trace >>= fun (r, _) ->
    Boot.print_debug (string_of_rule r ^ " ==>\nE= " ^
                     (Boot.pp_core_expr (fst z)) ^ "\nKS= " ^
                     (List.fold_left (fun acc k -> acc ^ string_of_cont k ^ "\n\n") "" $ snd z) ^ "\n----------------------------------\n\n")
(* END: DEBUG *)
   star_red2 z
in
  match x with
    | (e, []) ->
        if is_pure e then
          get_fulltrace           >>= fun (tact_map, t) ->
          E.get_fun_map           >>= fun fun_map       ->
          E.runU (eval fun_map e) >>= fun v             ->
          E.return ((v, []), (tact_map, t))
        else
          continue
    
    | _ -> continue
  end







(* Dummy function doing nothing, but required to typecheck *)
let rec convert_expr e =
  match e with
    | Eskip               -> Eskip
    | Etuple es           -> Etuple (List.map convert_expr es)
    | Econst n            -> Econst n
    | Eaddr o             -> Eaddr o
    | Esym a              -> Esym a
    | Etrue               -> Etrue
    | Efalse              -> Efalse
    | Ectype ty           -> Ectype ty
    | Eundef u            -> Eundef u
    | Eerror              -> Eerror
    | Eop op e1 e2        -> Eop op (convert_expr e1) (convert_expr e2)
    | Enot e              -> Enot (convert_expr e)
    | Elet a e1 e2        -> Elet a (convert_expr e1) (convert_expr e2)
    | Eif e1 e2 e3        -> Eif (convert_expr e1) (convert_expr e2) (convert_expr e3)
    | Ecall f args        -> Ecall f (List.map convert_expr args)
    | Eproc bs f args     -> Eproc {} f (List.map convert_expr args)
    | Eaction a           -> Eaction (convert_paction a)
    | Eunseq es           -> Eunseq (List.map convert_expr es)
    | Ewseq _as e1 e2     -> Ewseq _as (convert_expr e1) (convert_expr e2)
    | Esseq _as e1 e2     -> Esseq _as (convert_expr e1) (convert_expr e2)
    | Easeq a b u         -> Easeq a (convert_action b) (convert_paction u)
    | Eindet e            -> Eindet (convert_expr e)
    | Ebound i e          -> Ebound i (convert_expr e)
    | Esame e1 e2         -> Esame (convert_expr e1) (convert_expr e2)
    | Esave k a_tys e     -> Esave k a_tys (convert_expr e)
    | Erun k a_vs         -> Erun k (List.map (fun (a,v) -> (a, convert_expr v)) a_vs)
    | Eret e              -> Eret (convert_expr e)
  end


and convert_paction (p, a) = (p, convert_action a)
and convert_action (_, a) =
  ({}, match a with
    | Create ty pref -> Create (convert_expr ty) pref
    | Alloc n pref   -> Alloc (convert_expr n) pref
    | Kill e         -> Kill (convert_expr e)
    | Store ty o v   -> Store (convert_expr ty) (convert_expr o) (convert_expr v)
    | Load ty o      -> Load (convert_expr ty) (convert_expr o)
  end)






(* TODO: make sure that labels symbolic names are unique over a whole program, otherwise
         we may jump outside of functions ... *)
(* val     populate_cont_map: sym -> expr taction_id -> E.t unit *)

module St = State
open St.Operators

type collect_conts_state = <|
  bound_syms: set sym;
  conts: map ksym (list (sym * Ail.ctype) * expr taction_id)
|>

(* val     collect_cont: expr taction_id -> St.t (Pmap.map ksym (expr taction_id * list sym)) (Pmap.map ksym (expr taction_id * list sym)) *)

val     collect_conts: expr taction_id -> St.t unit collect_conts_state
let rec collect_conts e =
  let save_cont d k =
    St.update (fun s ->
          <| s with conts= Pmap.add d (* (free_syms e \ s.bound_syms *) k s.conts |>
        ) in
(*
  let save_syms _as =
    St.update (fun s ->
          <| s with bound_syms= s.bound_syms union _as |>
        ) in
*)
  match e with
    (* this is the only place where something actually happens *)
    | Esave d a_tys e ->
        save_cont d (a_tys, e) >>
        collect_conts e
    | Elet a _ e2 ->
(*        save_syms {a} >> *)
        collect_conts e2
    | Eif _ e2 e3 ->
        collect_conts e2 >>
        collect_conts e3
    | Ewseq _as e1 e2 ->
(*        save_syms (set_from_options _as) >> *)
        collect_conts e1 >>
        collect_conts e2
    | Esseq _as e1 e2 ->
(*        save_syms (set_from_options _as) >> *)
        collect_conts e1 >>
        collect_conts e2
    | End es ->
        St.mapM_ collect_conts es
    
    (* by syntactic constraints, we know that under these ctors there can be no labeled
       continuations *)
    | Etuple _ ->
        St.return ()
    | Enull ->
        St.return ()
    | Eskip ->
        St.return ()
    | Econst _ ->
        St.return ()
    | Eaddr _ ->
        St.return ()
    | Esym _ ->
        St.return ()
    | Eop _ _ _ ->
        St.return ()
    | Etrue ->
        St.return ()
    | Efalse ->
        St.return ()
    | Enot _ ->
        St.return ()
    | Ectype _ ->
        St.return ()
    | Ecall _ _ ->
        St.return ()
    | Eproc _ _ _ ->
        St.return ()
    | Esame _ _ ->
        St.return ()
    | Eundef _ ->
        St.return ()
    | Eerror ->
        St.return ()
    | Eaction _ ->
        St.return ()
    | Easeq _ _ _ ->
        St.return ()
    | Erun _ _ ->
        St.return ()
    | Eunseq _ ->
        St.return ()
    | Eret _ ->
        St.return ()
    
    (* these ctors should have been removed by Core_indet *)
    | Eindet _ ->
        Boot.assert_false "Core_run.collect_conts: the ctor `Eindet' should exists at this stage."
    | Ebound _ _ ->
        Boot.assert_false "Core_run.collect_conts: the ctor `Ebound' should exists at this stage."
  end











val     collect_conts': expr taction_id -> map ksym (list (sym * Ail.ctype) * expr taction_id)
let rec collect_conts' e =
  match e with
    | Esave d a_tys e ->
        Pmap.add d (a_tys, e) (collect_conts' e)
    | Elet _ _ e2 ->
        collect_conts' e2
    | Eif _ e2 e3 ->
        Pmap.concat (collect_conts' e2) (collect_conts' e3)
    | Ewseq _as e1 e2 ->
        let ks1 = collect_conts' e1 in
        Pmap.concat (Pmap.map (fun (a_tys, k) -> (a_tys, Ewseq _as k e2)) ks1) (collect_conts' e2)
    | Esseq _as e1 e2 ->
        let ks1 = collect_conts' e1 in
        Pmap.concat (Pmap.map (fun (a_tys, k) -> (a_tys, Esseq _as k e2)) ks1) (collect_conts' e2)
    | End es ->
        List.fold_left (fun acc e -> Pmap.concat (collect_conts' e) acc) Pmap.empty es
    
    (* by syntactic constraints, we know that under these ctors there can be no labeled
       continuations *)
    | Etuple _ ->
        Pmap.empty
    | Enull ->
        Pmap.empty
    | Eskip ->
        Pmap.empty
    | Econst _ ->
        Pmap.empty
    | Eaddr _ ->
        Pmap.empty
    | Esym _ ->
        Pmap.empty
    | Eop _ _ _ ->
        Pmap.empty
    | Etrue ->
        Pmap.empty
    | Efalse ->
        Pmap.empty
    | Enot _ ->
        Pmap.empty
    | Ectype _ ->
        Pmap.empty
    | Ecall _ _ ->
        Pmap.empty
    | Eproc _ _ _ ->
        Pmap.empty
    | Esame _ _ ->
        Pmap.empty
    | Eundef _ ->
        Pmap.empty
    | Eerror ->
        Pmap.empty
    | Eaction _ ->
        Pmap.empty
    | Easeq _ _ _ ->
        Pmap.empty
    | Erun _ _ ->
        Pmap.empty
    | Eunseq _ ->
        Pmap.empty
    | Eret _ ->
        Pmap.empty

    (* these ctors should have been removed by Core_indet *)
    | Eindet _ ->
        Boot.assert_false "Core_run.collect_conts': the ctor `Eindet' should exists at this stage."
    | Ebound _ _ ->
        Boot.assert_false "Core_run.collect_conts': the ctor `Ebound' should exists at this stage."
  end











open E.Operators

val runE: E.execution_mode -> sym -> fun_map taction_id -> E.t (Core.expr taction_id * (Pmap.map taction_id trace_action * E.trace))
let runE execution_mode main funs =
  (* collect the continuations in all functions *)
  let cont_map: map sym (map ksym (list (sym * Ail.ctype) * expr taction_id)) =
    List.fold_left (fun acc (fname, (_, _, fbody)) ->
(*      Pmap.add fname (let (_, s) = St.run_impl (collect_conts fbody) <| bound_syms= {}; conts= Pmap.empty |> in s.conts) acc *)
      Pmap.add fname (collect_conts' fbody) acc
    ) Pmap.empty $ Pmap.bindings funs in
  let (_, _, main_body) = Pmap.find main funs in
  E.set_execution_mode execution_mode    >>
  E.set_current_proc main                >>
  E.register_funs funs                   >>
  E.register_conts cont_map              >>
  star_red2 (main_body, [(* Khole *)[]]) >>= fun ((value, _), (tact_map, trace)) ->
  E.return (value, (tact_map, List.rev trace))


val run: E.execution_mode -> file zero -> Exception.t (list ((Core.expr taction_id) * (Pmap.map taction_id trace_action * E.trace))) Errors.cause
let run execution_mode f =
  let (main, funs) = (f.main, Pmap.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) f.fun_map) in
    match (runE execution_mode main funs) initial_state with
      | U.Defined zs ->
          let traces = List.map fst zs in
          Boot.print_debug ("NUMBER OF TRACES= " ^ (string_of_num $ List.length traces))
          Exception.return traces
          
      | U.Undef us -> Exception.fail (Errors.CORE_UNDEF us)
(*      | E.Error -> E.Error *)
    end
