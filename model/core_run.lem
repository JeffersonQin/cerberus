open import Pervasives Global Core Core_ctype Core_aux
import Set_helpers
import State State_operators
import Exception Errors Undefined
import Cmm_aux_old Memory_order
import AilTypesAux

import Core_run_effect
import Output


module Cmm = Memory_order
module U   = Undefined



(*
TODO: not used anymore

(* Conversions between Core and Cmm_aux_old constants *)
val     to_core_constant: Cmm_aux_old.constant -> Core.constant
let rec to_core_constant c =
  match c with
    | Cmm_aux_old.Cint n      -> Core.Cint n
(*    | Cmm_aux_old.Carray cs   -> Core.Carray $ map to_core_constant cs *)
    | Cmm_aux_old.Cfunction a -> Core.Cfunction a
  end

val     from_core_constant: Core.constant -> Cmm_aux_old.constant
let rec from_core_constant c =
  match c with
    | Core.Cint n      -> Cmm_aux_old.Cint n
(*    | Core.Carray cs   -> Cmm_aux_old.Carray $ map from_core_constant cs *)
    | Core.Cfunction a -> Cmm_aux_old.Cfunction a
  end

*)



(* BEGIN: Core continuation ********************************************************************* *)
type _cont 'a =
  | Kunseq of list (expr 'a) * list (expr 'a)
  | Kpar of list (expr 'a) * list (expr 'a)
  | Kwseq of list (maybe sym) * expr 'a
  | Ksseq of list (maybe sym) * expr 'a

type cont 'a = list (_cont 'a)


(* BEGIN: printing stuff for DEBUG *)

val sepBy: forall 'a. string -> ('a -> string) -> list 'a -> string
let rec ~{coq} sepBy sep f xs =
  match xs with
    | []     -> ""
    | [x]    -> f x
    | x::xs' -> f x ^ sep ^ sepBy sep f xs'
  end

val string_of_cont: forall 'a. cont 'a -> string
let ~{coq} string_of_cont k =
  let f = function
    | Kunseq [] es2 -> fun x -> "[ " ^ x ^ " || " ^ sepBy " || " Boot.pp_core_expr es2 ^ " ]"
    | Kunseq es1 [] -> fun x -> "[ " ^ sepBy " || " Boot.pp_core_expr es1 ^ " || " ^ x ^ " ]"
    | Kunseq es1 es2 -> fun x -> "[ " ^ sepBy " || " Boot.pp_core_expr es1 ^ " || " ^ x ^ " || " ^ sepBy " || " Boot.pp_core_expr es2 ^ " ]"
    
    | Kpar [] es2 -> fun x -> "[ " ^ x ^ " ; " ^ sepBy " ; " Boot.pp_core_expr es2 ^ " ]"
    | Kpar es1 [] -> fun x -> "[ " ^ sepBy " ; " Boot.pp_core_expr es1 ^ " ; " ^ x ^ " ]"
    | Kpar es1 es2 -> fun x -> "[ " ^ sepBy " ; " Boot.pp_core_expr es1 ^ " ; " ^ x ^ " ; " ^ sepBy " ; " Boot.pp_core_expr es2 ^ " ]"
    
    | Kwseq _as e2   -> fun x -> "wseq _as = (" ^ x ^ ") in " ^ Boot.pp_core_expr e2
    | Ksseq _as e2   -> fun x -> "sseq _as = (" ^ x ^ ") in " ^ Boot.pp_core_expr e2
  end in
  foldl (fun acc x -> f x acc) "\x1b[1;32m[]\x1b[0m" k
(* END: printing stuff for DEBUG *)

val apply_cont: forall 'a. cont 'a -> expr 'a -> expr 'a
let apply_cont k e =
  let f _k e =
    match _k with
      | Kwseq _as e2   -> Ewseq _as e e2
      | Ksseq _as e2   -> Esseq _as e e2
      | Kpar es1 es2   -> Epar $ es1 ++ (e :: es2)
      | Kunseq es1 es2 -> Eunseq $ es1 ++ (e :: es2)
    end in
  foldl (fun acc x -> f x acc) e k


(*
val compose_cont: forall 'a. cont 'a -> cont 'a -> cont 'a
let compose_cont k1 k2 = k1 ++ k2
*)
(* END: Core continuation ********************************************************************* *)


(* TODO: this is part of the "memory model" but need to be before Effect (...) *)
(*
type mem_value =
  | Muninit    (* TODO: Kayvan has to check whether we can remove this constructor 
                  and use the empty list in mem_state to denote a created, but 
                  uninitialized variable. *) 
  | Mbase of constant
  | Mobj of (list Symbol.t * nat)
  | Mnull
declare ocaml target_rep type Cmm.cvalue = mem_value
*)

(* Instantiation of Cmm types *)
(* declare ocaml target_rep type Cmm.location = mem_addr *)













(* list monad *)
module L = struct
  val return: forall 'a. 'a -> list 'a
  let return x = [x]
  
  val bind: forall 'a 'b. list 'a -> ('a -> list 'b) -> list 'b
  let bind m f = foldr (fun x y -> (f x) ++ y) [] m
end



module E = Core_run_effect
module Operators = struct
  let inline (>>=)    = E.bind
  let inline (>>) m f = E.bind m (fun _ -> f)
  let inline tid_of   = E.tid_of
end

open Operators


(* TODO: here I'm annotating all actions instead (this may reduce the number of
         epsilon transitions) *)
(* [annotate b e] add on each sb-minimal action of [e] an annotation meaning
                  that this action is sequenced-after [act]
  
  in the rules comments, this function is noted: <b> e
 *)
val annotate_expr: polarity * E.taction_id -> expr E.taction_id -> expr E.taction_id
let rec annotate_expr p_aid e =
  match e with
  | Elet a e1 e2         -> Elet a e1 (annotate_expr p_aid e2)
  | Eif e1 e2 e3         -> Eif e1 (annotate_expr p_aid e2) (annotate_expr p_aid e3)
  | Eaction (Paction p (Action bs a)) -> Eaction (Paction p (Action ({snd p_aid} union bs) a))
  | Eunseq es            -> Eunseq (List.map (annotate_expr p_aid) es)
  | Epar es              -> Epar (List.map (annotate_expr p_aid) es)
  | Ewseq _as e1 e2      -> Ewseq _as (annotate_expr p_aid e1) (match fst p_aid with Pos -> annotate_expr p_aid e2 | Neg -> e2 end)
  | Esseq _as e1 e2      -> Esseq _as (annotate_expr p_aid e1) (annotate_expr p_aid e2)
  | Esave k a_tys e      -> Esave k a_tys (annotate_expr p_aid e)
  | End es               -> End (List.map (annotate_expr p_aid) es)
  | Eproc bs f pes       -> Eproc ({snd p_aid} union bs) f pes
  | Erun bs d a_vs       -> Erun ({snd p_aid} union bs) d a_vs
  | _                    -> e
end



(* TODO: doesn't do what it should *)
val annotate: polarity * E.taction_id -> list (cont E.taction_id) -> list (cont E.taction_id)
let rec _annotate (p, aid) k =
  match k with
    | []                   -> []
    | Kpar es1 es2 :: k' -> Kpar (List.map (annotate_expr (p, aid)) es1) (List.map (annotate_expr (p, aid)) es2) :: _annotate (p, aid) k'
    | Kunseq es1 es2 :: k' -> Kunseq es1 es2 :: _annotate (p, aid) k'
    | Kwseq _as e2   :: k' -> Kwseq _as (match p with Pos -> annotate_expr (p, aid) e2 | Neg -> e2 end) :: _annotate (p, aid) k'
    | Ksseq _as e2   :: k' -> Ksseq _as (annotate_expr (p, aid) e2) :: _annotate (p, aid) k'
  end
let annotate aid ks = List.map (_annotate aid) ks
(*
let annotate a ks =
  match ks with
    | []       -> []
    | k :: ks' -> _annotate a k :: ks'
  end
*)





(* -------------------------------------------------------------------------- *)

(* ************************************************************************** *)
(* TODO: dummy memory model (concrete with isolated objects, ignoring C types) *)
  
(* Reverses the first list, and then appends that list to the second list. *)
val reverse_and_append: forall 'a. list 'a -> list 'a -> list 'a
let rec reverse_and_append left right = 
  match left with 
  | [] -> right
  | h::t -> reverse_and_append t (h::right)
  end

(* Inserts an element in a list. There can be multiple places to insert the element,
   the function returns a list containing all possible resulting lists. 
   The make the function recursive, there is an auxiliary argument (of type list) 
   that will be reversed and appended to the resulting list. *)
val list_insert_aux: forall 'a. 'a -> list 'a -> list 'a -> list (list 'a)
let rec list_insert_aux element aux list = 
  let new_list = reverse_and_append aux (element::list) in
  match list with
  | []   -> [new_list]
  | h::t -> List.append [new_list] (list_insert_aux element (h::aux) t)
  end
  
(* Inserts an element in a list. There can be multiple places to insert the element,
   the function returns a list containing all possible resulting lists. *)
val list_insert: forall 'a. 'a -> list 'a -> list (list 'a)
let list_insert element list = 
  list_insert_aux element [] list

val insert_after: forall 'a. Eq 'a => 'a -> 'a -> list 'a -> list 'a
let rec insert_after e new_e l =
  (* inserts new_e after e in l *)
  match l with
    | [] -> Boot.assert_false "insert_after failed, because it couldn't find the element in the list"
    | h::t -> if h = e then new_e::l else e::(insert_after e new_e t)
  end

(* Returns a taid that has not been used yet *)
val get_new_taid: E.t natural
let get_new_taid = 
  fun (<| E.tact_counter = new_taid |> as st) -> [(U.return new_taid, st)]

(* Adds the trace_action and corresponding Cmm.action to the state *)  
val add_tact: E.taction_id -> E.trace_action -> E.t unit
let add_tact taid tact = 
  fun (<| E.tact_map = tact_map; |> as st) ->
    [(U.return (), <| st with E.tact_counter= taid+1; 
                              E.tact_map= Map.insert taid tact tact_map; |>)]


(* push an element in the trace *)
val push_trace: (E.dyn_rule * maybe (set E.taction_id * E.taction_id)) -> E.t unit
let push_trace (r, tact_opt) =
(* TODO[newLem]  Boot.print_debug ("RULE ==> " ^ string_of_rule r) $ *)
    fun (<| E.trace= t |> as st) ->
       [(U.return (), <| st with E.trace= (r, tact_opt) :: t |>)]


(* get the last element of the trace (crash if none). *)
val get_trace: E.t (E.dyn_rule * maybe (set E.taction_id * E.trace_action))
let get_trace = function
  | <| E.trace= [] |> ->
      Boot.assert_false "[Core_run.get_trace] empty trace"
  | (<| E.tact_map= tact_map; E.trace= (r, tact_opt) :: _ |> as st) ->
      [(U.return (r, match tact_opt with Just (bs, n) ->

(*
        if not $ Map.mem n tact_map then
          Boot.assert_false $ ">>>>>" ^ (string_of_num n)
        else
*)


Just (bs, fromJust $ Map.lookup n tact_map) | Nothing -> Nothing end), st)]
end

val get_fulltrace: E.t (Map.map E.taction_id E.trace_action * E.trace)
let get_fulltrace = fun (<| E.tact_map= tact_map; E.trace= t |> as st) ->
  [(U.return (tact_map, t), st)]





(* static object allocation *)
(* TODO: the array part is some dubious experiment *)
val create: list Symbol.t -> ctype -> E.taction_id -> E.t Memory.mem_addr
let create pref ty taid = fun (<| E.mem_layout= (m, i); |> as st) ->
  (* DEBUG *)
  (* TODO[newLem]  Boot.print_debug ("[Core_run.create] @" ^ (string_of_num i)) $ *)
  let o = (pref, Cmm_aux_old.Lbase i) in
  let init = match ty with
    | Array _ n -> Cmm_aux_old.Marray (replicate_list Cmm_aux_old.Muninit n)
    | _         -> Cmm_aux_old.Muninit
  end in
  [(U.return o, <| st with E.mem_layout= (Map.insert o [(init, taid)] m, i+1); |>)]

(* TODO: doesn't do anything regarding the size *)
(* dynamic object allocation (malloc) *)
val alloc: list Symbol.t -> integer -> E.taction_id -> E.t Memory.mem_addr
let alloc pref _ taid = fun (<| E.mem_layout= (m, i) |> as st) ->
  let o = (pref, Cmm_aux_old.Lbase i) in
  [(U.return o, <| st with E.mem_layout= (Map.insert o [(Cmm_aux_old.Muninit, taid)] m, i+1) |>)]

(* static/dynamic object deallocation *)
val kill: Memory.mem_addr -> E.t unit
let kill o = fun (<| E.mem_layout= (m, i) |> as st) ->
  (* DEBUG *)
(* TODO[newLem] Boot.print_debug ("[Core_run.kill] @" ^ (string_of_num $ snd o)) *)
  [(U.return (), <| st with E.mem_layout= (Map.delete o m, i) |> )]

val store: ctype -> Memory.mem_addr -> Cmm_aux_old.cvalue -> E.taction_id -> E.t unit
let store _ o v taid = fun (<| E.mem_layout= (m, i) |> as st) ->
  (* DEBUG *)
(* TODO[newLem]   Boot.print_debug ("[Core_run.store] @" ^ (string_of_num $ snd o)) $ *)
  let values =
    match Map.lookup o m with
      | Just z  -> z
      | Nothing -> []
    end in
  (* We append the new value to the values already present in the memory *)
  [(U.return (), <| st with E.mem_layout= (Map.insert o ((v, taid)::values) m, i) |>)]

(* Loads a value (and the taction_id of the action that stored that value). When
   the location is atomic, it non-deterministically loads from any of the past 
   values. Otherwise it loads the last value. *)
val load: ctype -> Memory.mem_addr -> E.t (Cmm_aux_old.cvalue * E.taction_id)
let load ty o = fun (<| E.mem_layout= (m, _) |> as st) ->
  match Map.lookup o m with
    | Just values ->
        (* DEBUG *)
        (* TODO[newLem]     Boot.print_debug ("[Core_run.load] @" ^ (string_of_num $ snd o)) $ *)
        (* Returns the last value stored in memory *)
        (* load the last value *)    
        match values with
          | (value, taid)::_ ->
              [(U.return (value, taid), st)]
          | _ ->
              Boot.assert_false "Last value cannot be loaded, because there are no values."
        end
    | Nothing ->
       (* DEBUG *)
       (* TODO[newLem]     Boot.print_debug ("[Core_run.load] Not_found: @" ^ (string_of_num $ snd o)) *)
       [(U.undef [Undefined.Outside_lifetime], st)]
  end

(* ************************************************************************** *)

(* non-deterministically pick an element of a list with its context within the
   list. (e.g. pick_one [1,2,3] = [ ([],1,[2; 3]); ([1],2,[3]); ([1; 2],3,[]) ])
 *)
(* EXHAUSTIVE MODE *)
let rec _pick_one_exhaustive pred acc mylist =
  match mylist with
    | []    -> []
    | x::xs -> (if pred x then fun z -> (reverse acc, x, xs) :: z else fun z -> z) $ _pick_one_exhaustive pred (x::acc) xs
  end
let pick_one_exhaustive pred l = E.msum $ map E.return (_pick_one_exhaustive pred [] l)

(* RANDOM MODE *)
let rec ~{coq} _pick_one_random pred = function
  | [] -> Nothing
  | l  -> let (xs, y, zs) = Boot.pickList l in
          if pred y then
            Just (xs, y, zs)
          else
            match _pick_one_random pred (xs ++ zs) with
              | Just (xs', y', zs') ->
                let n  = List.length xs  in
                let n' = List.length xs' in
                if n' < n then
                  let (a, b) = splitAt (n - n' - 1) zs' in
                  Just (xs', y', a ++ (y :: b))
                else
                  let (a, b) = splitAt n xs' in
                  Just (a ++ (y :: b), y', zs')
              | Nothing ->
                  Nothing
            end
end
let ~{coq} pick_one_random pred l = fun s ->
  match _pick_one_random pred l with
    | Just x  -> [(U.return x, s)]
    | Nothing -> []
  end

val pick_one: forall 'a. ('a -> bool) -> list 'a -> E.t (list 'a * 'a * list 'a)
let ~{coq} pick_one pred l =
  E.get_execution_mode >>= function
    | E.Exhaustive -> pick_one_exhaustive pred l
    | E.Random     -> pick_one_random pred l
  end
let {coq} pick_one = pick_one_exhaustive








(* mutate the rule descriptor of the most recent trace element (used by
   inductive rule after application of their premises) *)
(*
val update_rule: (dyn_rule -> dyn_rule) -> E.t unit
let update_rule f = fun (<| E.trace= t |> as s) ->
  match t with
    | []               -> Boot.outOfHomeomorphism "[Core_run.update_rule] empty trace"
    | (r, bs_a) :: ts  -> [((), <| s with E.trace= (f r, bs_a) :: ts |>)]
  end
*)







(*
val put_syms: list (maybe sym) -> expr E.taction_id -> E.t unit
let put_syms _as v =
  match (_as, v) with
    | ([]       , _        ) -> E.return ()
    | ([Nothing], _        ) -> E.return ()
    | ([Just _a], _        ) -> E.put_sym _a v
    | (_        , Etuple vs) -> E.mapM_ (fun (_a_opt, v) -> match _a_opt with Just _a -> E.put_sym _a v| Nothing -> E.return () end) (List.combine _as vs)
    | (_        , Eunseq vs) -> E.mapM_ (fun (_a_opt, v) -> match _a_opt with Just _a -> E.put_sym _a v| Nothing -> E.return () end) (List.combine _as vs)
  end 
*)


(* takes the symbolic names of a function, some pure expressions and produce
   the function body where the arguments have been substituted *)
val call_function: forall 'a. file 'a -> name -> list (expr 'a) -> expr 'a
let call_function file fname args =
  let (_, params, fbody) =
    match fname with
      | Sym  f ->
(* KKK

          (* TODO: uber hack *)
          let (Symbol _ str_opt) = f in
          if str_opt = Just "exp" then
            e

 *)
          match Map.lookup f file.stdlib with
            | Just z  -> z
            | Nothing -> fromJust $ Map.lookup f file.funs
          end
      | Impl f ->
          match Map.lookup f file.impl with
            | Just (IFun bty fargs fbody) ->
                (TyBase bty, fargs, fbody)
            | _ ->
                Boot.assert_false "[Core_run.call_function] found a Def used as an IFun"
          end
    end in
  if List.length params <> List.length args then
    Boot.assert_false $ "[Core_run.call_function] wrong number of args applied to `" (* TODO[newLem] ^
      Boot.pp_core_expr (match fname with Impl f -> Eimpl f | Sym f -> Esym f end) ^ "'" *)
  else
    (Global.foldl2 (fun acc (_a, _) arg -> subst_sym _a arg acc) fbody params args)


val call_proc: name -> list (expr E.taction_id) -> E.t (expr E.taction_id)
let call_proc pname args =
  match pname with
    | Sym psym ->
        E.get_proc psym >>= fun (_, params, fbody) ->
        if List.length params <> List.length args then
          Boot.assert_false $ "[Core_run.call_proc] wrong number of args applied to `" (* TODO[newLem] ^ Boot.pp_core_expr (Esym psym) ^ "'" *)
        else
          E.set_current_proc psym >>
          E.return (Global.foldl2 (fun acc (_a, _) arg -> subst_sym _a arg acc) fbody params args)
    | Impl (Implementation_.StdFunction "printf") ->
        (* TODO: uber hack *)
        match args with
          | Eaddr o :: args' ->
              (* TODO: the types are obviously a hack *)
              load Core_ctype.Void o >>= fun (Cmm_aux_old.Mbase (Cmm_aux_old.Cstring fmrt), taid) ->
              
              Output.printf load fmrt (List.map (fun (Eaddr o) -> o) args')

(*
              E.mapM (fun (Eaddr o) ->
                load Core_ctype.Void o >>= fun (Cmm_aux_old.Mbase c, taid) ->
                E.return c
              ) args' >>= fun csts ->
              E.return $ Eoutput (Boot.fake_printf str csts)
 *)
          | _ -> Boot.assert_false "[Core_run.call_proc] printf is very hackish for now"
        end

    | _ -> Boot.assert_false "[Core_run.call_proc] impossible case: TODO move to Exception.t"
  end


let rec collect_values v =
  match v with
    | Etuple vs -> let vss = List.map collect_values vs in
                   List.concat vss
    | _         -> [v]
  end


(* evaluation of pure epxressions (will crash on ill-typed and/or non pure
   expressions).  Note that this evaluation may be partial; that is, the
   result of eval may be another unevaluated expression rather than a value.
   This is to ensure that the eval function will always terminate (which is
   important for the Coq backend).  To fully evaluate a pure expression,
   it is necessary to call eval repeatedly until is_value returns True. *)
open U
val     eval: forall 'a. file 'a -> expr 'a -> U.t (expr 'a)
let rec eval file pe =
  let eval = eval file in
  match pe with
    | Eimpl i ->
        match Map.lookup i file.impl with
          | Just (Def _ e) -> U.return e
          | Nothing        -> Boot.assert_false (Boot.pp_core_expr pe) (* U.error (* TODO: check *) *)
          | _ -> Boot.assert_false "[Core_run.eval] impossible case: TODO move to Exception.t"
        end
    | Eundef u ->
        U.undef [u]
    | Eerror ->
        U.error
    | Eop binop pe1 pe2 -> do U
        pe1' <- eval pe1;
        pe2' <- eval pe2; in
          U.return $
            if is_value pe1' && is_value pe2' then
              match (binop, pe1', pe2') with
                | (OpAdd, Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    Econst (Cmm_aux_old.Cint $ n1 + n2)
                | (OpSub, Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    Econst (Cmm_aux_old.Cint $ n1 - n2)
                | (OpMul, Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    Econst (Cmm_aux_old.Cint $ n1 * n2)
                | (OpDiv, Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    Econst (Cmm_aux_old.Cint $ n1 div n2)
                | (OpMod, Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    Econst (Cmm_aux_old.Cint $ n1 mod n2)
                | (OpEq,  Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    if n1 = n2 then Etrue else Efalse
                | (OpEq, Ectype ty1, Ectype ty2) ->
                    if ty1 = ty2 then Etrue else Efalse
                | (OpLt, Econst (Cmm_aux_old.Cint n1), Econst (Cmm_aux_old.Cint n2)) ->
                    if n1 < n2 then Etrue else Efalse
                | (OpOr, Efalse, Efalse) ->
                    Efalse
                | (OpOr, _, _) ->
                    Etrue
                | (OpAnd, Etrue, Etrue ) ->
                    Etrue
                | (OpAnd, _, _) ->
                    Efalse
                | (_, _, _) ->
                    Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Eop binop pe1' pe2')
              end
            else
              Eop binop pe1' pe2'
        end
    | Enot pe -> do U
        pe' <- eval pe; in
          if is_value pe' then
            match pe' with
              | Etrue  -> U.return Efalse
              | Efalse -> U.return Etrue
              | _      -> Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Enot pe')
            end
          else
            U.return (Enot pe')
        end
    | Elet _a pe1 pe2 -> do U
        pe1' <- eval pe1; in
          if is_value pe1' then
            U.return (subst_sym _a pe1' pe2) (* We do not immediately call eval on the result of subst_sym, as that could lead to non-termination. *)
          else
            U.return (Elet _a pe1' pe2)
        end
    | Eif pe1 pe2 pe3 -> do U
        pe1' <- eval pe1; in
          if is_value pe1' then
            match pe1' with
              | Etrue  -> eval pe2
              | Efalse -> eval pe3
              | _      -> Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Eif pe1' pe2 pe3)
            end
          else
            U.return (Eif pe1' pe2 pe3)
        end
    | Ecall f pes -> do U
        pes' <- U.mapM eval pes; in
          if all is_value pes' then
            U.return (call_function file f pes')  (* We do not immediately call eval on the result of call_function, as that could lead to non-termination. *)
          else
            U.return (Ecall f pes')
        end
(* TODO: this may be very counter-intuitive, but we have it as a hack to remove skips comming from negative actions
==> probably need some trick during typing
*)
    | Eunseq pes -> do U
        pes' <- U.mapM eval pes; in
          U.return $
            if all is_value pes' then
              match (* List.filter (fun (Left v) -> v <> Eskip) $ *) pes' with
                | []  -> Etuple [] (* HACK: better had a Eunit ctor *)
                | [v] -> v
                | vs  -> Etuple vs
              end
            else
              Eunseq pes'
          end
(*
        match List.filter (function Left _ -> false | Right _ -> true end) vs with
        | [] -> match (* List.filter (fun (Left v) -> v <> Eskip) $ *) vs with
                  | []       -> Left (Etuple []) (* HACK: better had a Eunit ctor *)
                  | [Left v] -> Left v
                  | vs       -> Left (Etuple $ List.map (fun (Left v) -> v) vs)
                end
        | vs' -> Right $ List.fold_left (fun acc (Right us) -> us ++ acc) [] vs'
      end
*)
    
    | Ewseq _as pe1 pe2 -> do U
        pe1' <- eval pe1; in
          U.return $
            if is_value pe1' then
              (subst_syms _as pe1' pe2) (* We do not immediately call eval on the result of subst_syms, as that could lead to non-termination. *)
            else
              Ewseq _as pe1' pe2
        end
    
(* TODO: temporary *)
  | Eis_scalar pe -> do U
      pe' <- eval pe; in
        if is_value pe' then
          match pe' with
            | Ectype ty ->
                U.return (if AilTypesAux.scalar (unproj_ctype ty) then Etrue else Efalse)
            | _ ->
                Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Eis_scalar pe')
          end
        else
          U.return (Eis_scalar pe')
      end

  | Eis_integer pe -> do U
      pe' <- eval pe; in
        if is_value pe' then
          match pe' with
            | Ectype ty ->
                U.return (if AilTypesAux.integer (unproj_ctype ty) then Etrue else Efalse)
            | _ ->
                Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Eis_integer pe')
          end
        else
          U.return (Eis_integer pe')
      end
  | Eis_signed pe -> do U
      pe' <- eval pe; in
        if is_value pe' then
          match pe' with
            | Ectype ty ->
                U.return (if AilTypesAux.is_signed_integer_type (unproj_ctype ty) then Etrue else Efalse)
            | _ ->
                Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Eis_signed pe')
          end
        else
          U.return (Eis_signed pe')
      end
  | Eis_unsigned pe -> do U
      pe' <- eval pe; in
        if is_value pe' then
          match pe' with
            | Ectype ty ->
                U.return (if AilTypesAux.is_unsigned_integer_type (unproj_ctype ty) then Etrue else Efalse)
            | _ ->
                Boot.assert_false $ "[Core_run.eval] the expression looks ill-typed: " ^ Boot.pp_core_expr (Eis_unsigned pe')
          end
        else
          U.return (Eis_unsigned pe')
      end
    
    (* If [pe] is not pure this is wrong, we should crash instead *)
    | _ ->
        if is_value pe then
          U.return pe
        else
          Boot.assert_false $ "[Core_run.eval] found an impure expression or a symbol: " ^ Boot.pp_core_expr pe
  end


val get_address: forall 'a. expr 'a -> E.t Memory.mem_addr
let get_address = function 
  | Eaddr o -> E.return o
  | _       -> E.runU $ U.undef [Undefined.Lvalue_not_an_object]
  end


(* TODO: this function will call the implementation of a given action in a
         particular memory model *)
open Operators

val perform_create: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id -> list Symbol.t ->
                    E.t (E.taction_id * expr E.taction_id)
let perform_create bs tid_ pe pref = 
  let tid = Cmm_aux_old.canonize_tid tid_ in
  (* perform the create *)
  E.return pe >>= fun ty_ ->
  let ty = match ty_ with
    | Ectype ty -> ty
    | _         -> Boot.assert_false "[Core_run.perform_create] impossible case: TODO move to Exception.t"
  end in
  get_new_taid                          >>= fun new_taid    ->
  create pref ty new_taid               >>= fun o           ->
  (* update the state with the new trace action *)
  add_tact new_taid (E.Tcreate ty o tid)  >>
  E.return (new_taid, Eaddr o)

val perform_alloc: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id -> list Symbol.t ->
                   E.t (E.taction_id * expr E.taction_id)
let perform_alloc bs tid_ pe pref = 
  let tid = Cmm_aux_old.canonize_tid tid_ in
  (* perform the alloc *)
  E.return pe >>= fun n_ ->
  let n = match n_ with
    | Econst (Cmm_aux_old.Cint n) -> n
    | _ -> Boot.assert_false "[Core_run.perform_alloc] impossible case: TODO move to Exception.t"
  end in
  get_new_taid                          >>= fun new_taid          ->
  alloc pref n new_taid                 >>= fun o                 ->
  (* update the state with the new trace action *)
  add_tact new_taid (E.Talloc n o tid)    >>
  E.return (new_taid, Eaddr o)

val perform_kill: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id -> E.t (E.taction_id * expr E.taction_id)
let perform_kill bs tid_ pe = 
  let tid = Cmm_aux_old.canonize_tid tid_ in
  (* perform the kill *)
  E.return pe >>= fun o_ ->
  let o = match o_ with
    | Eaddr o -> o
    | _ -> Boot.assert_false "[Core_run.perform_kill] impossible case: TODO move to Exception.t"
  end in
  kill o                                >>
  (* update the state with the new trace action *)
  get_new_taid                          >>= fun new_taid  ->
  add_tact new_taid (E.Tkill o tid)     >>
  E.return (new_taid, Eunit) (* TODO: Check whether it's correct to return Eunit instead of Enull ty *)

val perform_store: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> 
                   Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_store bs tid_ pe1 pe2 pe3 mo = 
  let tid = Cmm_aux_old.canonize_tid tid_ in
  (* perform the store *)
  E.return pe1 >>= fun ty_ ->
  let ty = match ty_ with
    | Ectype ty -> ty
    | _ -> Boot.assert_false "[Core_run.perform_store] impossible case: TODO move to Exception.t"
  end in

  E.return pe2                                 >>= fun expr        ->
  get_address expr                             >>= fun o           ->
  E.return pe3                                 >>= function
   | Econst c -> E.return (Cmm_aux_old.Mbase c, Eunit)
   | Eaddr o' -> E.return (Cmm_aux_old.Mobj o', Eunit)
   | Enull _  -> E.return (Cmm_aux_old.Mnull,   Eskip)
   | v        -> Boot.assert_false $
                 "[Core_run.perform_action, Kstore] " (* TODO[newLem] ^
                 (Boot.pp_core_expr pe3) ^
                 " ==> " ^ (Boot.pp_core_expr v) *)
   end                                         >>= fun (value, e)  ->
  get_new_taid                                 >>= fun new_taid    ->
  store ty o value new_taid                    >>
  (* update the state with the new trace action *)
  add_tact new_taid (E.Tstore ty o value mo tid) >>
  E.return (new_taid, e)

val perform_load: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id -> expr E.taction_id -> 
                   Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_load bs tid_ pe1 pe2 mo = 
  let tid = Cmm_aux_old.canonize_tid tid_ in
  (* perform the load *)
  E.return pe1 >>= fun ty_ ->
  let ty = match ty_ with
    | Ectype ty -> ty
    | _ -> Boot.assert_false "[Core_run.perform_load] impossible case: TODO move to Exception.t"
  end in
  E.return pe2                                >>= fun expr                ->
  get_address expr                            >>= fun o                   ->
  load ty o                                   >>= fun (value, store_taid) ->
  (* update the state with the new trace action *)   
  get_new_taid                                >>= fun new_taid            ->
  add_tact new_taid (E.Tload ty o value mo tid) >>  
  (* Return *)
  match value with
   | Cmm_aux_old.Mbase v -> E.return (Econst v)
   | Cmm_aux_old.Mobj v  -> E.return (Eaddr v)
   | Cmm_aux_old.Muninit  -> Boot.print_debug "READ AN UNINIT" $
                        E.return (Econst $ Cmm_aux_old.Cint (~ 10))
   | _ -> Boot.assert_false "[Core_run.perform_load] impossible case: TODO move to Exception.t"
  end                                         >>= fun e                   ->
  E.return (new_taid, e)

val perform_compare_exchange: (Cmm_aux_old.cvalue -> Cmm_aux_old.cvalue -> E.t bool) ->
               set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id ->
               expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> Cmm.memory_order ->
               Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_compare_exchange cmp bs tid_ pe_ty pe_o pe_expected pe_desired mo_succes mo_failure = 
  let tid = Cmm_aux_old.canonize_tid tid_ in
  (* We first load (NA) from pe_expected *)
  perform_load bs tid_ pe_ty pe_expected Cmm.NA                       >>= fun (na_load_taid, expected_e) ->
  let expected_v = match expected_e with
   | Econst c -> Cmm_aux_old.Mbase c
   | Eaddr o' -> Cmm_aux_old.Mobj o'
   | Enull _  -> Cmm_aux_old.Mnull
   | _ -> Boot.assert_false "[Core_run.perform_compare_exchange] impossible case: TODO move to Exception.t"
  end in
  (* We (atomically load from the object *)
  E.return pe_ty >>= fun ty_ ->
  let ty = match ty_ with
    | Ectype ty -> ty
    | _ -> Boot.assert_false "[Core_run.perform_compare_exchange] impossible case: TODO move to Exception.t"
  end in
  let atomic_ty = Atomic ty in
  E.return pe_o                                                       >>= get_address >>= fun o          ->
  E.return pe_desired                                                 >>= fun desired_e                  ->
  let desired_v = match desired_e with
   | Econst c -> Cmm_aux_old.Mbase c
   | Eaddr o' -> Cmm_aux_old.Mobj o'
   | Enull _  -> Cmm_aux_old.Mnull
   | _ -> Boot.assert_false "[Core_run.perform_compare_exchange] impossible case: TODO move to Exception.t"
  end in
  (* The new_taid will be the taid of RMW if it succeeds and of the load otherwise *)
  get_new_taid                                                        >>= fun new_taid                   -> 
  load atomic_ty o                                                    >>= fun (actual_v, store_taid)     ->
  (* We decide whether it is a succes or failure *)
  cmp actual_v expected_v                                             >>= fun is_success                  ->
  if is_success then
     (* Success: we store the desired value *)
     store atomic_ty o desired_v new_taid                             >>
     (* We omit an RMW event (for the store and the previous load *)
     let tact = E.Trmw atomic_ty o actual_v desired_v mo_succes tid in
     add_tact new_taid tact                                           >>
     E.return (new_taid, Econst (Cmm_aux_old.Cint 1))
  else
     (* Failure: we omit a load event for the load we just did *)
     add_tact new_taid (E.Tload atomic_ty o actual_v mo_failure tid)    >>  
     (* We store (NA) the actual value back to pe_expected *)
     let actual_e = match actual_v with
      | Cmm_aux_old.Mbase c -> Econst c
      | Cmm_aux_old.Mobj o' -> Eaddr o'
      | Cmm_aux_old.Mnull   -> Enull Core_ctype.Void (* TODO: use the correct type in Enull. *)
      | _ -> Boot.assert_false "[Core_run.perform_compare_exchange] impossible case: TODO move to Exception.t"
     end in
     perform_store {new_taid} tid_ pe_ty pe_expected actual_e  Cmm.NA >>= fun (na_store_aid, _)          ->
     E.return (na_store_aid, Econst (Cmm_aux_old.Cint 0))

val perform_compare_exchange_strong: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id ->
               expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> Cmm.memory_order ->
               Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_compare_exchange_strong bs tid pe1 pe2 pe3 pe4 mo1 mo2 = 
  let cmp v1 v2 = E.return (v1 = v2) in
  perform_compare_exchange cmp bs tid pe1 pe2 pe3 pe4 mo1 mo2
  
val perform_compare_exchange_weak: set E.taction_id -> Cmm_aux_old.tid -> expr E.taction_id ->
               expr E.taction_id -> expr E.taction_id -> expr E.taction_id -> Cmm.memory_order ->
               Cmm.memory_order -> E.t (E.taction_id * expr E.taction_id)
let perform_compare_exchange_weak bs tid pe1 pe2 pe3 pe4 mo1 mo2 = 
  let cmp v1 v2 = fun st ->
  if v1 = v2 then
    [(U.return true, st); (U.return false, st)]
  else
    [(U.return false, st)] in
  perform_compare_exchange cmp bs tid pe1 pe2 pe3 pe4 mo1 mo2



(* NOTE: the assumption is made that an Eunseq cannot directly be the
         subexpression of an another Eunseq *)

let red2_action x =
  match x with
    | (Eaction (Paction p (Action bs a)), tid, _KS) ->
      let continue (aid, v) =
        push_trace (if p = Pos then E.Rule_Pos else E.Rule_Neg, Just (bs, aid)) >> E.return (v, tid, annotate (p, aid) _KS) in
      match a with
        | Create pe pref ->
          if is_value pe then
            perform_create bs tid pe pref >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe) >>= fun pe' ->
            E.return (Eaction (Paction p (Action bs (Create pe' pref))), tid, _KS)
        | Alloc pe pref ->
          if is_value pe then
            perform_alloc bs tid pe pref >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe) >>= fun pe' ->
            E.return (Eaction (Paction p (Action bs (Alloc pe' pref))), tid, _KS)
        | Kill pe ->
          if is_value pe then
            perform_kill bs tid pe >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe) >>= fun pe' ->
            E.return (Eaction (Paction p (Action bs (Kill pe'))), tid, _KS)
        | Store pe1 pe2 pe3 mo ->
          if is_value pe1 && is_value pe2 && is_value pe3 then
            perform_store bs tid pe1 pe2 pe3 mo >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe1) >>= fun pe1' ->
            E.runU (eval file pe2) >>= fun pe2' ->
            E.runU (eval file pe3) >>= fun pe3' ->
            E.return (Eaction (Paction p (Action bs (Store pe1' pe2' pe3' mo))), tid, _KS)
        | Load pe1 pe2 mo ->
          if is_value pe1 && is_value pe2 then
            perform_load bs tid pe1 pe2 mo >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe1) >>= fun pe1' ->
            E.runU (eval file pe2) >>= fun pe2' ->
            E.return (Eaction (Paction p (Action bs (Load pe1' pe2' mo))), tid, _KS)
        | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
          if is_value pe1 && is_value pe2 && is_value pe3 && is_value pe4 then
            perform_compare_exchange_strong bs tid pe1 pe2 pe3 pe4 mo1 mo2 >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe1) >>= fun pe1' ->
            E.runU (eval file pe2) >>= fun pe2' ->
            E.runU (eval file pe3) >>= fun pe3' ->
            E.runU (eval file pe4) >>= fun pe4' ->
            E.return (Eaction (Paction p (Action bs (CompareExchangeStrong pe1' pe2' pe3' pe4' mo1 mo2))), tid, _KS)
        | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
          if is_value pe1 && is_value pe2 && is_value pe3 && is_value pe4 then
            perform_compare_exchange_weak bs tid pe1 pe2 pe3 pe4 mo1 mo2 >>= continue
          else
            E.get_file >>= fun file ->
            E.runU (eval file pe1) >>= fun pe1' ->
            E.runU (eval file pe2) >>= fun pe2' ->
            E.runU (eval file pe3) >>= fun pe3' ->
            E.runU (eval file pe4) >>= fun pe4' ->
            E.return (Eaction (Paction p (Action bs (CompareExchangeWeak pe1' pe2' pe3' pe4' mo1 mo2))), tid, _KS)
      end
    | _ -> E.mzero
  end

let red2_value x =
  match x with
    | (e, tid, [] :: _KS) ->
        if is_value e then
          push_trace (E.Rule_Pure_Hole, Nothing) >> E.return (e, Cmm_aux_old.Tzero, _KS)
        else
          E.mzero
    | (e, tid, _K :: _KS) ->
        if is_value e then
          push_trace (E.Rule_Pure, Nothing) >> E.return (apply_cont _K e, Cmm_aux_old.Tzero, [] :: _KS)
        else
          E.mzero
    | _ -> E.mzero
  end

let red2_pure x =
  match x with
    | (e, tid, _KS) ->
        if is_pure e then
          E.get_file                     >>= fun file ->
          E.runU (eval file e)           >>= fun e'    ->
          E.return (e', tid, _KS)
        else
          E.mzero
  end

let red2_if x =
  match x with
    | (Eif pe e2 e3, tid, _KS) ->
        if is_value pe then
          match pe with
            | Etrue  -> push_trace (E.Rule_If, Nothing) >> E.return (e2, tid, _KS)
            | Efalse -> push_trace (E.Rule_If, Nothing) >> E.return (e3, tid, _KS)
            | _ -> Boot.assert_false "[Core_run.red2_if] impossible case: TODO move to Exception.t"
          end
        else
          E.get_file            >>= fun file ->
          E.runU (eval file pe) >>= fun pe' ->
          E.return (Eif pe' e2 e3, tid, _KS)
      | _ -> E.mzero
  end

let red2_let x =
  match x with
    | (Elet _a pe1 e2, tid, _KS) ->
        if is_value pe1 then
          push_trace (E.Rule_Let, Nothing) >> E.return (subst_sym _a pe1 e2, tid, _KS)
        else
          E.get_file               >>= fun file ->
          E.runU (eval file pe1)   >>= fun pe1'      ->
          E.return (Elet _a pe1' e2, tid, _KS)
    | _ -> E.mzero
  end

let red2_ret x =
  match x with
    | (Eret pe, tid, _K :: _KS) ->
          if is_value pe then
            push_trace (E.Rule_Ret, Nothing) >> E.return (pe, tid, _KS)
          else
            E.get_file               >>= fun file ->
            E.runU (eval file pe)    >>= fun pe'  ->
            E.return (Eret pe', tid, _K :: _KS)


(*
        if is_value e then
          eval e                      >>= fun v ->
          push_trace (E.Rule_Ret, Nothing) >>
(*          E.pop_syms >> *)
          E.return (v, _KS)
        else 
          E.mzero
*)
    | _ -> E.mzero
  end

(*
let red2_shift x =
  match x with
    | (Eshift pe1 pe2, tid, _KS) ->
        KKK
*)

let red2_skip x =
  match x with
    | (Eskip, tid, [Kwseq _ e2] :: _KS) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, [] :: _KS)
    | (Eskip, tid, (Kwseq _ e2 :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, _KS1 :: _KS2)

    | (Eskip, tid, [Ksseq _ e2] :: _KS) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, [] :: _KS)
    | (Eskip, tid, (Ksseq _ e2 :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return (e2, tid, _KS1 :: _KS2)

    | (Eskip, tid, ((Kunseq es1 es2) :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return
          (match es1 ++ es2 with
             | []  -> Etuple []
             | [e] -> e
             | es  -> Eunseq es
           end, tid, _KS1 :: _KS2)

(*
    | (Eskip, ((Kpar es1 es2) :: _KS1) :: _KS2) ->
        push_trace (E.Rule_Skip, Nothing) >>
        E.return
          (match es1 ++ es2 with
             | []  -> Eskip
             | [e] -> e
             | es  -> Epar es
           end, _KS1 :: _KS2)
*)

(*    | (Eskip, _K :: _KS) -> push_trace (E.Rule_Skip, Nothing) >> E.return (apply_cont _K Eskip, _KS) *)
    | _                       -> E.mzero
  end


let red2_proc x =
  match x with
    | (Eproc bs f es, tid, _KS) ->
        if all is_value es then
          push_trace (E.Rule_Proc, Nothing)   >>
(* TODO: HACK here we always annotate the action as being positive, I'm pretty sure this is wrong *)
          call_proc f es                 >>= fun f_body  ->
          E.return (Set_helpers.fold (fun b e -> annotate_expr (Pos, b) e) bs f_body, tid, [] :: _KS)
        else
          E.get_file                     >>= fun file    ->
          E.runU (U.mapM (eval file) es) >>= fun es'     ->
          E.return (Eproc bs f es', tid, _KS)
(*
Boot.print_debug (Boot.pp_core_expr (Core.Etuple es)) $
Boot.print_debug (Boot.pp_core_expr f_body) $
*)

    | _ -> E.mzero
  end


let red2_wseq x =
  match x with
    | (Ewseq _ (Eaction (Paction Neg b)) e2, tid, _KS) ->
        E.mzero (* Leaving it to red2_neg_wseq *)
    | (Ewseq _as e1 e2, tid, _KS) ->
          if is_value e1 then
            Boot.print_debug ("IS_PURE: " ^ Boot.pp_core_expr e1) $
            push_trace (E.Rule_Wseq, Nothing) >> E.return (subst_syms _as e1 e2, Cmm_aux_old.Tseq tid, _KS)
          else if is_pure e1 then
            E.get_file            >>= fun file ->
            E.runU (eval file e1) >>= fun e1'  ->
            E.return (Ewseq _as e1' e2, tid, _KS)
          else
            push_trace (E.Rule_Wseq, Nothing) >>
            match _KS with
            | _K :: _KS -> E.return (e1, Cmm_aux_old.Tseq tid, (Kwseq _as e2 :: _K) :: _KS)
            | []        -> E.return (e1, Cmm_aux_old.Tseq tid, [[Kwseq _as e2]])
          end
    | _ -> E.mzero
  end 

let red2_neg_wseq x =
  match x with
    | (Ewseq _ (Eaction (Paction Neg b)) e2, tid, _KS) ->
        push_trace (E.Rule_Wseq_Neg, Nothing) >>
        E.return match e2 with
          | Eunseq e2's -> (Eunseq $ (Eaction (Paction Neg b)) :: e2's, Cmm_aux_old.Tseq tid, _KS)
          | _           -> (Eunseq [Eaction (Paction Neg b); e2], Cmm_aux_old.Tseq tid, _KS)
        end
    | (Ewseq _as (Eunseq es) e2, tid, _KS) ->
        pick_one (is_negative) es >>= function
               (* TODO: there is a hack here: the symbol corresponding to ej should be dropped from ej, instead of adding a skip dans the first unseq (...) *)
          | (es1, Eaction (Paction Neg b), es2) ->
              push_trace (E.Rule_Wseq_Neg, Nothing) >>
              E.return match e2 with
                | Eunseq e2's -> (Ewseq _as (Eunseq $ es1 ++ (Eskip :: es2)) (Eunseq $ Eaction (Paction Neg b) :: e2's), Cmm_aux_old.Tseq tid, _KS)
                | _           -> (Ewseq _as (Eunseq $ es1 ++ (Eskip :: es2)) (Eunseq [Eaction (Paction Neg b); e2]), Cmm_aux_old.Tseq tid, _KS)
              end
          | _ -> Boot.assert_false "[Core_run.red2_neg_wseq] impossible"
        end
    | _ -> E.mzero
end


let red2_sseq x =
  match x with
    | (Esseq _as e1 e2, tid, _KS) ->
          if is_value e1 then
            Boot.print_debug ("red2_sseq IS_PURE: " ^ Boot.pp_core_expr e1) $
            push_trace (E.Rule_Sseq, Nothing) >> E.return (subst_syms _as e1 e2, Cmm_aux_old.Tseq tid, _KS)
          else if is_pure e1 then
            E.get_file            >>= fun file ->
            E.runU (eval file e1) >>= fun e1'  ->
            E.return (Esseq _as e1' e2, tid, _KS)
          else
            push_trace (E.Rule_Sseq, Nothing) >>
            match _KS with
            | _K :: _KS -> E.return (e1, Cmm_aux_old.Tseq tid, (Ksseq _as e2 :: _K) :: _KS)
            | []        -> E.return (e1, Cmm_aux_old.Tseq tid, [[Ksseq _as e2]])
          end
    | _ -> E.mzero
  end

(* TODO: check that rule, nothing fancy should be needed, since we don't allow
         save/run inside unseq expressions *)
let red2_unseq x =
  match x with
    | (Eunseq es, tid, _K :: _KS) ->
        pick_one (not -| is_pure) es >>= fun (es1, ej, es2) ->
          Boot.print_debug ("ej = " ^ Boot.pp_core_expr ej) $ 
          push_trace (E.Rule_Unseq, Nothing) >>
          E.return (ej, tid, (Kunseq es1 es2 :: _K) :: _KS)
    | _ -> E.mzero
  end

let red2_run x =
  match x with
    | (Erun bs d a_vs, tid, _K :: _KS) ->
        E.get_cont d >>= fun (a_tys, e_cont) ->
        push_trace (E.Rule_Run, Nothing) >>
        (* we have to create the objects which are visible at the level of the save but not from the run *)
        let (create_as, create_tys) = unzip $ List.filter (fun (a,_) -> not (any (fun (x,_) -> x = a) a_vs)) a_tys in
        (* symmetrically, we have to kill the objects which are visible at the level of the run but not from the save.*)
        let kill_es = List.map snd $ List.filter (fun (a,_) -> not (any (fun (x,_) -> x = a) a_tys)) a_vs in
        let e =
          Ewseq [] (mk_unseq $ List.map (fun e -> pkill e) kill_es)
            (Ewseq (List.map (fun z -> Just z) create_as) (mk_unseq $ List.map (fun ty -> pcreate (Ectype ty) []) create_tys)
               (foldl (fun acc (a, v) -> subst_sym a v acc) e_cont a_vs)) in
        (* TODO: it seems strange that annotate_expr need to know the polarity *)
        E.return (Set_helpers.fold (fun b e -> annotate_expr (Pos, b) e) bs e, tid, [] :: _KS)
    | _ -> E.mzero
  end

let red2_save x =
  match x with
    | (Esave _ _ e, tid, _KS) ->
        push_trace (E.Rule_Save, Nothing) >>
        E.return (e, tid, _KS)
    | _ -> E.mzero
  end

let red2_par x =
  match x with
    | (Epar es, tid, _K :: _KS) ->
      if all is_value es then
        push_trace (E.Rule_Par, Nothing) >> E.return (Etuple es, tid, _K :: _KS)
      else if all is_pure es then
        E.get_file                     >>= fun file ->
        E.runU (U.mapM (eval file) es) >>= fun es'  ->
        E.return (Epar es', tid, _K :: _KS)
      else
        push_trace (E.Rule_Par, Nothing) >>
        pick_one (not -| is_pure) es >>= fun (es1, ej, es2) ->
        Boot.print_debug ("ej = " ^ Boot.pp_core_expr ej) $ 
        E.return (ej, Cmm_aux_old.Tpar (List.length es1 + 1) tid, (Kpar es1 es2 :: _K) :: _KS)
    | _ -> E.mzero
  end

let red2_nd x =
  match x with
    | (End es, tid, _KS) ->
        pick_one (fun _ -> true) es >>= fun (_, ej, _) ->
        push_trace (E.Rule_ND, Nothing)  >>
        E.return (ej, tid, _KS)
    | _ -> E.mzero
end


let red2_output x =
  match x with
    | (Eoutput str, tid, _KS) ->
        E.put_stdout str >>
        E.return (Eunit, tid, _KS)
    | _ -> E.mzero
  end


val red2:      expr E.taction_id * Cmm_aux_old.tid * list (cont E.taction_id) ->
          E.t (expr E.taction_id * Cmm_aux_old.tid * list (cont E.taction_id))
let red2 e =
  E.dmsum [
    red2_value e; red2_pure e; red2_skip e;
    E.msum [
      red2_action e; red2_unseq e;
      red2_if e; red2_let e; red2_ret e;
      red2_proc e;
      red2_wseq e; red2_neg_wseq e;
      red2_sseq e;
      red2_run e; red2_save e;
      red2_par e; red2_nd e;
      red2_output e
    ]
  ]

val star_red2:       expr E.taction_id * Cmm_aux_old.tid * list (cont E.taction_id) ->
               E.t (expr E.taction_id * (Map.map E.taction_id E.trace_action * E.trace))
let rec ~{coq} star_red2 x =
  let continue =
    red2 x >>= fun (e, tid, _K) ->
(* BEGIN: DEBUG *)
(* TODO:
    get_trace >>= fun (r, _) ->
 *)
    Boot.print_debug ((* E.string_of_rule r ^ *) " ==>\nE= " ^
                     (Boot.pp_core_expr e) ^ "\nKS= "  ^
                     (foldl (fun acc k -> acc ^ string_of_cont k ^ "\n\n") "" $ _K) ^
                     "\n----------------------------------\n\n")



(* END: DEBUG *)
   star_red2 (e, tid, _K)
in
  match x with
    | (e, tid, []) ->
        if is_value e then
          get_fulltrace        >>= fun (tact_map, t) ->
          E.return (e, (tact_map, reverse t))
        else
          continue
    
    | _ -> continue
  end







(* Dummy function doing nothing, but required to typecheck *)
val     convert_expr: forall 'a. expr 'a -> expr E.taction_id
let rec convert_expr e =
  match e with
    | Eskip               -> Eskip
    | Etuple es           -> Etuple (List.map convert_expr es)
    | Eunit               -> Eunit
    | Enull ty            -> Enull ty
    | Econst c            -> Econst c
    | Eimpl i             -> Eimpl i
    | Eaddr o             -> Eaddr o
    | Esym a              -> Esym a
    | Etrue               -> Etrue
    | Efalse              -> Efalse
    | Ectype ty           -> Ectype ty
    | Eundef u            -> Eundef u
    | Eerror              -> Eerror
    | Eop op e1 e2        -> Eop op (convert_expr e1) (convert_expr e2)
    | Enot e              -> Enot (convert_expr e)
    | Elet a e1 e2        -> Elet a (convert_expr e1) (convert_expr e2)
    | Eif e1 e2 e3        -> Eif (convert_expr e1) (convert_expr e2) (convert_expr e3)
    | Ecall f args        -> Ecall f (List.map convert_expr args)
    | Eproc bs f args     -> Eproc {} f (List.map convert_expr args)
    | Eaction a           -> Eaction (convert_paction a)
    | Eunseq es           -> Eunseq (List.map convert_expr es)
    | Epar es             -> Epar (List.map convert_expr es)
    | End es              -> End (List.map convert_expr es)
    | Ewseq _as e1 e2     -> Ewseq _as (convert_expr e1) (convert_expr e2)
    | Esseq _as e1 e2     -> Esseq _as (convert_expr e1) (convert_expr e2)
    | Easeq a b u         -> Easeq a (convert_action b) (convert_paction u)
    | Eindet e            -> Eindet (convert_expr e)
    | Ebound i e          -> Ebound i (convert_expr e)
    | Esame e1 e2         -> Esame (convert_expr e1) (convert_expr e2)
    | Esave k a_tys e     -> Esave k a_tys (convert_expr e)
    | Erun bs k a_vs      -> Erun {} k (List.map (fun (a,v) -> (a, convert_expr v)) a_vs)
    | Eret e              -> Eret (convert_expr e)
    | Eshift e1 e2        -> Eshift (convert_expr e1) (convert_expr e2)

(* TODO: temporary *)
    | Eis_scalar e   -> Eis_scalar (convert_expr e)
    | Eis_integer e  -> Eis_integer (convert_expr e)
    | Eis_signed e   -> Eis_signed (convert_expr e)
    | Eis_unsigned e -> Eis_unsigned (convert_expr e)
  end

and convert_paction pa =
  match pa with
    | Paction p a -> Paction p (convert_action a)
  end
and convert_action a =
  match a with
    | Action _ a_ -> Action {} (convert_action_ a_)
  end
and convert_action_ a =
  match a with
    | Create ty pref  -> Create (convert_expr ty) pref
    | Alloc n pref    -> Alloc (convert_expr n) pref
    | Kill e          -> Kill (convert_expr e)
    | Store ty o v mo -> Store (convert_expr ty) (convert_expr o) (convert_expr v) mo
    | Load ty o mo    -> Load (convert_expr ty) (convert_expr o) mo
    | CompareExchangeStrong ty obj expected desired mo1 mo2 ->
        CompareExchangeStrong (convert_expr ty) (convert_expr obj) (convert_expr expected) (convert_expr desired) mo1 mo2
    | CompareExchangeWeak ty obj expected desired mo1 mo2 ->
        CompareExchangeWeak (convert_expr ty) (convert_expr obj) (convert_expr expected) (convert_expr desired) mo1 mo2
  end


val convert_file: forall 'a. file 'a -> file E.taction_id
let convert_file file = <|
  main=   file.main;
  stdlib= Map.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) file.stdlib;
  impl=   Map.map (function
            | Def bty e       -> Def bty (convert_expr e)
            | IFun bty args e -> IFun bty args (convert_expr e)
          end) file.impl;
  defs=   List.map (fun (_a, bTy, e) -> (_a, bTy, convert_expr e)) file.defs;
  funs=   Map.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) file.funs
 |>
(* TODO: this version doesn't typecheck (says that 'a should be num), ask the lem people if it is normal *)
(*
<| file with
  impl= Map.map (function
          | Def bty e       -> Def bty (convert_expr e)
          | IFun bty args e -> IFun bty args (convert_expr e)
        end) file.impl;
  funs= Map.map (fun (ty_ret, args, fbody) -> (ty_ret, args, convert_expr fbody)) file.funs
 |>
*)




(* TODO: make sure that labels symbolic names are unique over a whole program, otherwise
         we may jump outside of functions ... *)
(* val     populate_cont_map: sym -> expr E.taction_id -> E.t unit *)

module St = State
open State_operators

type collect_conts_state = <|
  bound_syms: set sym;
  conts: map ksym (list (sym * ctype) * expr E.taction_id)
|>

(* val     collect_cont: expr E.taction_id -> St.t (Map.map ksym (expr E.taction_id * list sym)) (Map.map ksym (expr E.taction_id * list sym)) *)

(*
val     collect_conts: expr E.taction_id -> St.t unit collect_conts_state
let rec collect_conts e =
  let save_cont d k =
    St.update (fun s ->
          <| s with conts= Map.insert d (* (free_syms e \ s.bound_syms *) k s.conts |>
        ) in
(*
  let save_syms _as =
    St.update (fun s ->
          <| s with bound_syms= s.bound_syms union _as |>
        ) in
*)
  match e with
    (* this is the only place where something actually happens *)
    | Esave d a_tys e ->
        save_cont d (a_tys, e) >>
        collect_conts e
    | Elet a _ e2 ->
(*        save_syms {a} >> *)
        collect_conts e2
    | Eif _ e2 e3 ->
        collect_conts e2 >>
        collect_conts e3
    | Ewseq _as e1 e2 ->
(*        save_syms (set_from_options _as) >> *)
        collect_conts e1 >>
        collect_conts e2
    | Esseq _as e1 e2 ->
(*        save_syms (set_from_options _as) >> *)
        collect_conts e1 >>
        collect_conts e2
    | End es ->
        St.mapM_ collect_conts es
    
    (* by syntactic constraints, we know that under these ctors there can be no labeled
       continuations *)
    | Etuple _ ->
        St.return ()
    | Enull _ ->
        St.return ()
    | Eskip ->
        St.return ()
    | Econst _ ->
        St.return ()
    | Eimpl _ ->
        St.return ()
    | Eaddr _ ->
        St.return ()
    | Esym _ ->
        St.return ()
    | Eop _ _ _ ->
        St.return ()
    | Etrue ->
        St.return ()
    | Efalse ->
        St.return ()
    | Enot _ ->
        St.return ()
    | Ectype _ ->
        St.return ()
    | Ecall _ _ ->
        St.return ()
    | Eproc _ _ _ ->
        St.return ()
    | Esame _ _ ->
        St.return ()
    | Eundef _ ->
        St.return ()
    
    (* TODO: assume that there is name clash among threads *)
    | Epar es ->
        St.mapM_ collect_conts es
    
    | Eerror ->
        St.return ()
    | Eaction _ ->
        St.return ()
    | Easeq _ _ _ ->
        St.return ()
    | Erun _ _ _ ->
        St.return ()
    | Eunseq _ ->
        St.return ()
    | Eret _ ->
        St.return ()
    
    (* these ctors should have been removed by Core_indet *)
    | Eindet _ ->
        Boot.assert_false "Core_run.collect_conts: the ctor `Eindet' should exists at this stage."
    | Ebound _ _ ->
        Boot.assert_false "Core_run.collect_conts: the ctor `Ebound' should exists at this stage."

(* TODO: temporary *)
    | Eis_scalar _ ->
        St.return ()
    | Eis_integer _ ->
        St.return ()
    | Eis_signed _ ->
        St.return ()
    | Eis_unsigned _ ->
        St.return ()
  end
*)










val     collect_conts': expr E.taction_id -> map ksym (list (sym * ctype) * expr E.taction_id)
let rec collect_conts' e =
  match e with
    | Esave d a_tys e ->
        Map.insert d (a_tys, e) (collect_conts' e)
    | Elet _ _ e2 ->
        collect_conts' e2
    | Eif _ e2 e3 ->
        (* Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (collect_conts' e2) (collect_conts' e3) *)
        Map.(union) (collect_conts' e2) (collect_conts' e3)
    | Ewseq _as e1 e2 ->
        let ks1 = collect_conts' e1 in
        (* Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (Pmap.map (fun (a_tys, k) -> (a_tys, Ewseq _as k e2)) ks1) (collect_conts' e2) *)
        Map.(union) (Map.map (fun (a_tys, k) -> (a_tys, Ewseq _as k e2)) ks1) (collect_conts' e2)
    | Esseq _as e1 e2 ->
        let ks1 = collect_conts' e1 in
        (* Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (Pmap.map (fun (a_tys, k) -> (a_tys, Esseq _as k e2)) ks1) (collect_conts' e2) *)
        Map.(union) (Map.map (fun (a_tys, k) -> (a_tys, Esseq _as k e2)) ks1) (collect_conts' e2)
    | End es ->
        (* foldl (fun acc e -> Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (collect_conts' e) acc) Pmap.empty es *)
        Map.unions (List.map collect_conts' es)
    
    (* TODO: assume that there is name clash among threads *)
    | Epar es ->
        (* foldl (fun acc e -> Ocaml.Pmap.fold (fun k v acc -> Map.insert k v acc) (collect_conts' e) acc) Pmap.empty es *)
        Map.unions (List.map collect_conts' es)
    
    (* by syntactic constraints, we know that under these ctors there can be no labeled
       continuations *)
    | Etuple _ ->
        Map.empty
    | Eunit ->
        Map.empty
    | Enull _ ->
        Map.empty
    | Eskip ->
        Map.empty
    | Econst _ ->
        Map.empty
    | Eimpl _ ->
        Map.empty
    | Eaddr _ ->
        Map.empty
    | Esym _ ->
        Map.empty
    | Eop _ _ _ ->
        Map.empty
    | Etrue ->
        Map.empty
    | Efalse ->
        Map.empty
    | Enot _ ->
        Map.empty
    | Ectype _ ->
        Map.empty
    | Ecall _ _ ->
        Map.empty
    | Eproc _ _ _ ->
        Map.empty
    | Esame _ _ ->
        Map.empty
    | Eundef _ ->
        Map.empty
    | Eerror ->
        Map.empty
    | Eaction _ ->
        Map.empty
    | Easeq _ _ _ ->
        Map.empty
    | Erun _ _ _ ->
        Map.empty
    | Eunseq _ ->
        Map.empty
    | Eret _ ->
        Map.empty

    (* these ctors should have been removed by Core_indet *)
    | Eindet _ ->
        Boot.assert_false "Core_run.collect_conts': the ctor `Eindet' should exists at this stage."
    | Ebound _ _ ->
        Boot.assert_false "Core_run.collect_conts': the ctor `Ebound' should exists at this stage."
    
    | Eshift _ _ ->
        Map.empty

(* TODO: temporary *)
    | Eis_scalar _ ->
        Map.empty
    | Eis_integer _ ->
        Map.empty
    | Eis_signed _ ->
        Map.empty
    | Eis_unsigned _ ->
        Map.empty
  end




open Operators


val initial_expr_and_state : E.execution_mode -> file zero -> (Core.expr E.taction_id * Cmm_aux_old.tid * list (cont E.taction_id)) * E.state
let initial_expr_and_state execution_mode file =
  let file = convert_file file in
  (* collect the continuations in all functions *)
  let cont_map = Set_helpers.fold
    (fun (fname, (_, _, fbody)) acc -> Map.insert fname (collect_conts' fbody) acc)
    (Map.toSet file.funs)
    Map.empty in
  
  let state = E.initial_state execution_mode file cont_map in
  
  let (_, _, main_body) = fromJust $ Map.lookup file.main file.funs in
  ((main_body, Cmm_aux_old.Tzero, [[]]), state)


val initial_state: E.execution_mode -> file zero -> E.state
let initial_state execution_mode file =
  let file = convert_file file in
  (* collect the continuations in all functions *)
  let cont_map = Set_helpers.fold
    (fun (fname, (_, _, fbody)) acc -> Map.insert fname (collect_conts' fbody) acc)
    (Map.toSet file.funs)
    Map.empty in
  E.initial_state execution_mode file cont_map


(* the double update of the defs bodies is hackish, E.state shouldn't have Core.file as field, just the relevant portion *)
val run_program: E.t (expr E.taction_id * (Map.map E.taction_id E.trace_action * E.trace))
let run_program =
  E.get_file >>= fun <| Core.main= main; Core.defs= defs |> ->
  E.foldlM (fun (_a, bTy, e) substs ->
    let e' = List.foldl (fun z (_a, v) -> Core_aux.subst_sym _a v z) e substs in
    (* run the allocation and initialisation of the global *)
    star_red2 (e', Cmm_aux_old.Tzero, [[]]) >>= fun (v, tr) -> (* TODO: do something with the trace *)
    (* update the rest of the program *)
    E.subst_inAll _a v >>
    E.return ((_a, v) :: substs)
  ) defs [] >>
(*
  E.mapM_ (fun (_a, bTy, e) ->
    (* run the allocation and initialisation of the global *)
    star_red2 (e, Cmm_aux_old.Tzero, [[]]) >>= fun (v, tr) -> (* TODO: do something with the trace *)
    (* update the rest of the program *)
    E.subst_inAll _a v
  ) defs          >>
*)
  E.get_proc main >>= fun (_, _, main_body) ->
  star_red2 (main_body, Cmm_aux_old.Tzero, [[]])


val run: E.execution_mode -> file zero ->
         Exception.t (list (U.t ((Core.expr E.taction_id) * (Map.map E.taction_id E.trace_action * E.trace)) * E.state)) Errors.t
let ~{coq} run execution_mode file =
(*
  let (e, state) = initial_expr_and_state execution_mode file in
  let execs = star_red2 e state in
 *)
  let state = initial_state execution_mode file in
  let execs = run_program state in
  Boot.print_debug ("NUMBER OF TRACES= " ^ (string_of_natural (naturalFromNat $ List.length execs)))
    Exception.return execs
