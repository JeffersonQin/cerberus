open import Pervasives

import Symbol Cabs
open import Utils Core_ctype

open import {hol} `tagsTheory`

(* SEE src/tags.mli for the documentation *)
val tagDefs: unit -> map Symbol.sym tag_definition
val set_tagDefs: map Symbol.sym tag_definition -> unit

declare ocaml target_rep function tagDefs = `Tags.tagDefs`
declare ocaml target_rep function set_tagDefs = `Tags.set_tagDefs`

declare hol target_rep function tagDefs = `tagDefs`
declare hol target_rep function set_tagDefs = `set_tagDefs`

val get_membersDefs: Symbol.sym -> tag_definition
let get_membersDefs tag_sym =
  fromJust "Core_ctype_aux.get_membersDefs" $ Map.lookup tag_sym (tagDefs ())

val get_structDef: Symbol.sym -> list (Cabs.cabs_identifier * ctype)
let get_structDef tag_sym =
  match Map.lookup tag_sym (tagDefs ()) with
    | Just (Core_ctype.StructDef xs) ->
        xs
    | Just _ ->
        error ("Core_type.aux.get_structDef (" ^ show tag_sym ^
               "): found a union definition instead of a struct")
    | Nothing ->
        error ("Core_type.aux.get_structDef (" ^ show tag_sym ^
               "): couldn't find a struct/union definition")
  end

val get_unionDef: Symbol.sym -> (Cabs.cabs_identifier * ctype) * list (Cabs.cabs_identifier * ctype)
let get_unionDef tag_sym =
  match Map.lookup tag_sym (tagDefs ()) with
    | Just (Core_ctype.UnionDef []) ->
        error ("Core_type.aux.get_unionDef (" ^ show tag_sym ^
               "): found an empty union definition")
    | Just (Core_ctype.UnionDef (x::xs)) ->
        (x, xs)
    | Just _ ->
        error ("Core_type.aux.get_unionDef (" ^ show tag_sym ^
               "): found a struct definition instead of a union")
    | Nothing ->
        error ("Core_type.aux.get_unionDef (" ^ show tag_sym ^
               "): couldn't find a struct/union definition")
  end

val reset_tagDefs: unit -> unit
declare ocaml target_rep function reset_tagDefs = `Tags.reset_tagDefs`
