(* Effects for Core_run *)
open import Pervasives Global Core Core_ctype
import Cmm_csem Undefined Boot State_exception

module Cmm = Cmm_csem
module U   = Undefined


(* Fully evaluated description of an action *)
type trace_action =
  | Tcreate of ctype   * Cmm.location * Cmm.tid (* the second argument is the created object *)
  | Talloc  of integer * Cmm.location * Cmm.tid (* TODO: nat *) (* the second argument is the created object *)
  | Tkill   of           Cmm.location * Cmm.tid
  | Tstore  of ctype   * Cmm.location * Cmm.cvalue              * Cmm.memory_order * Cmm.tid
  | Tload   of ctype   * Cmm.location * Cmm.cvalue              * Cmm.memory_order * Cmm.tid (* the argument Cmm.cvalue is the read value *)
  | Trmw    of ctype   * Cmm.location * Cmm.cvalue * Cmm.cvalue * Cmm.memory_order * Cmm.tid

type trace_paction = polarity * trace_action

val tid_of: trace_action -> Cmm.tid
let tid_of = function
  | Tcreate _ _ tid    -> tid
  | Talloc _ _ tid     -> tid
  | Tkill _ tid        -> tid
  | Tstore _ _ _ _ tid -> tid
  | Tload _ _ _ _ tid  -> tid
  | Trmw _ _ _ _ _ tid -> tid
  end 

type taction_id = natural



(* this type represents reduction rules and is used for annotating trace element
   (for debug purpose) *)
type dyn_rule =
  | Rule_Pos
  | Rule_Neg
  | Rule_Pure_Hole
  | Rule_Pure
  | Rule_If
  | Rule_Let
  | Rule_Ret
  | Rule_Skip
  | Rule_Proc
  | Rule_Wseq
  | Rule_Wseq_Neg
  | Rule_Sseq
  | Rule_Run
  | Rule_Save
  | Rule_Unseq
  | Rule_ND
  | Rule_Par

(* BEGIN: DEBUG *)
let string_of_rule = function
  | Rule_Pos        -> "pos"
  | Rule_Neg        -> "neg"
  | Rule_Pure_Hole  -> "pure_hole"
  | Rule_Pure       -> "pure"
  | Rule_If         -> "if"
  | Rule_Ret        -> "ret"
  | Rule_Let        -> "let"
  | Rule_Skip       -> "skip"
  | Rule_Proc       -> "proc"
  | Rule_Wseq       -> "wseq"
  | Rule_Wseq_Neg   -> "wseq_neg"
  | Rule_Sseq       -> "sseq"
  | Rule_Run        -> "run"
  | Rule_Save       -> "save"
  | Rule_Unseq      -> "unseq"
  | Rule_ND         -> "nd"
  | Rule_Par        -> "par"

end
(* END: DEBUG *)



(* the elements of a trace are triple, where:
     - the first element is a description of the reduction rules used for this
       step (this is for a DEBUG feature)
     - the second element is the set of actions sequenced before the action
       that has just been performed
     - the third element is the action that as been performed during that step
   *)
type trace = list (dyn_rule * maybe (set taction_id * taction_id))

type execution_mode =
  | Exhaustive
  | Random

type state = <|
  (* The memory layout state *)
  mem_layout: Memory.memory_state;
  
  (* the execution trace so far (stored in reversed) *)
  trace: trace;
  
  (* The following members are named after their counterparts in Cmm. *)
  cmm_tact_map:   Map.map taction_id Cmm.action;
  lk:             Map.map Cmm.location Cmm.location_kind;
  sb:             set (taction_id * taction_id);
  asw:            set (taction_id * taction_id);
  rf:             set (taction_id * taction_id);
  mo:             Map.map Memory.mem_addr (list taction_id);
  sc:             list taction_id;
  
  
  (* The followings have to do with the state of your implementation, not the
     state of the evaluated Core program *)
  (* TODO: it's a bit silly that this is here, since the setting won't change *)
  execution_mode: execution_mode;
  (* the C function whose body we are reducing (if any) *)
  current_proc:   maybe sym;
  file: file taction_id;
  (* maps of labeled continuations (per function) *)
  cont_map: map sym (map ksym (list (sym * ctype) * expr taction_id));
  (* counter for the trace actions map *)
  tact_counter: natural;
  tact_map: Map.map taction_id trace_action;
|>

type t 'a = state -> list (U.t 'a * state)


(* monadic operations *)
val return: forall 'a. 'a -> t 'a
let return x = fun st -> [(U.return x, st)]


(* TODO: note that now being undef in one execution doesn't makes the thing
         undef *)
val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
let bind ms f = fun st ->
  List.concat $ List.map (function
    | (U.Defined x, st') -> f x st'
    | (U.Undef u,   st') -> [(U.Undef u, st')]
    | (U.Error,     st') -> [(U.Error,   st')]
  end) (ms st)
(*
  (* TODO: looks fishy *)
  val bind: forall 'a 'b. t 'a -> ('a -> t 'b) -> t 'b
  let bind m f = fun s ->
    match m s with
      | U.Defined zs -> foldr (fun (a, s') acc ->
                          match acc with
                            | U.Defined y -> match f a s' with U.Defined z' -> U.Defined (z' ++ y) | U.Undef us -> U.Undef us | U.Error -> U.Error end
                            | U.Undef us  -> U.Undef us
                            | U.Error     -> U.Error
                          end) (U.Defined []) zs
      | U.Undef us -> U.Undef us
      | U.Error    -> U.Error
    end
*)


(* running a U computation *)
val runU: forall 'a. U.t 'a -> t 'a
let runU = function
  | U.Defined x -> return x
  | U.Undef us  -> fun st -> [(U.undef us, st)]
  | U.Error     -> fun st -> [(U.error, st)]
end


(* MonadPlus operations *)
val mzero: forall 'a. t 'a
let mzero = fun _ -> []

val mplus: forall 'a. t 'a -> t 'a -> t 'a
let mplus ma mb = fun st ->
  ma st ++ mb st
(*
    match (a s, b s) with
      | (U.Defined x, U.Defined y) -> U.Defined (x ++ y)
      (* TODO: ahem, now this isn't very associative *)
      (* TODO2: may be better now *)
      | (U.Undef us1, U.Undef us2) -> U.Undef (us1 ++ us2)
      | (U.Undef us, _)            -> U.Undef us
      | (_, U.Undef us)            -> U.Undef us
      | _                          -> U.error
    end
*)


(* generic functions (that should be moved out once we have type-classes) *)
val msum: forall 'a. list (t 'a) -> t 'a
let msum xs = foldr mplus mzero xs



(* like msum, but the order matter, so it's not a like msum (ahem) *)
val     dmsum: forall 'a. list (t 'a) -> t 'a

(*
dmsum :  list (state -> list (U.t 'a * state)) -> (state -> list (U.t 'a * state))
*)
let rec dmsum ms =
  fun st ->
    match ms with
      | []     -> []
      | m::ms' -> match m st with
                    | [] -> (dmsum ms') st
                    | v  -> v
                  end
    end
(*
    fun s ->
      match ms with
        | []     -> U.return []
        | m::ms' -> match m s with
                      | U.Defined [] -> (dmsum ms') s
                      | v            -> v
                    end
      end
*)


val     foldlM: forall 'a 'b. ('a -> 'b -> t 'b) -> list 'a -> 'b -> t 'b
let rec foldlM f l a =
  match l with
    | []    -> return a
    | x::xs -> bind (f x a) (foldlM f xs)
  end

let sequence ms =
  foldr (fun m acc ->
    bind m (fun x ->
      bind acc (fun xs -> return (x::xs))
    )
  ) (return []) ms
let mapM f xs = sequence (List.map f xs)

let sequence_ ms = foldr (fun m f -> bind m (fun _ -> f)) (return ()) ms
val mapM_: forall 'a 'b. ('a -> t 'b) -> list 'a -> t unit
let mapM_ f _as = sequence_ (List.map f _as)


val set_current_proc: sym -> t unit
let set_current_proc pname = fun st ->
  [(U.return (), <| st with current_proc= Just pname |>)]

val get_file: t (file taction_id)
let get_file = fun st ->
  [(U.return st.file, st)]
  
(*
  val get_fun: name -> t (core_type * list (sym * core_base_type) * expr taction_id)
  let get_fun fname = fun s ->
    match fname with
      | Sym  f -> U.return [(Map.find f s.funs, s)]
      | Impl f ->
          match Map.find f s.impl_map with
            | IFun bty fargs fbody -> U.return [((TyBase bty, fargs, fbody), s)]
            | _ -> Boot.assert_false "[Core_run.get_fun] found a Def used as  IFun"
          end
  end
*)

val get_proc: sym -> t (core_type * list (sym * core_base_type) * expr taction_id)
let get_proc psym = fun st ->
  match Map.lookup psym st.file.funs with
    | Just z  -> [(U.return z, st)]
    | Nothing -> Boot.assert_false "HIP: get_proc failure" (* "[Core_run.get_proc] " ^ Boot.pp_core_expr (Esym psym) *)
  end

val register_conts: map sym (map ksym (list (sym * ctype) * expr taction_id)) -> t unit
let register_conts ks = fun st ->
  [(U.return (), <| st with cont_map= ks |>)]


let rec map_from_list xs =
  match xs with
    | [] -> Map.empty
    | (a,b) :: xs' -> Map.insert a b (map_from_list xs')
  end

val get_cont: ksym -> t (list (sym * ctype) * expr taction_id)
let get_cont d = fun st ->
  [(U.return (fromJust $ Map.lookup d (fromJust $ Map.lookup (fromJust st.current_proc) st.cont_map)), st)]


(*
  val get_sym: sym -> t (expr taction_id)
  let get_sym _a =
    fun s ->
      if Map.mem _a s.sym_map then
        [ (Map.find _a s.sym_map, s) ]
      else
        Boot.assert_false "BUG: Core_run.get_sym"
  
  val put_sym: sym -> expr taction_id -> t unit
  let put_sym _a e =
    fun s -> 
      [((), <| s with sym_map= Map.insert _a e s.sym_map |>)]
*)


(*
      (* TODO: this is disgusting *)
      let e' = match e with
                 | Esym _a' -> match Symbol_table.find _a' s.sym_map with
                                 | Nothing -> Boot.assert_false "BUG: Core_run.put_sym"
                                 | Just z  -> z
                               end
                 | _        -> e
               end
      in [((), <| s with sym_map= Symbol_table.add _a e' s.sym_map |>)]
      *)

val set_execution_mode: execution_mode -> t unit
let set_execution_mode mode = fun st ->
  [(U.return (), <| st with execution_mode= mode |>)]

val get_execution_mode: t execution_mode
let get_execution_mode = fun st ->
  [(U.return st.execution_mode, st)]


val register_sequencing: set taction_id -> taction_id -> Cmm.tid -> t unit
let register_sequencing bs aid tid = fun st ->
  let (sb_, asw_) = Set_helpers.fold (fun b (sb_acc, asw_acc) ->
    if tid = tid_of (fromJust $ Map.lookup b st.tact_map) then
      (Set.insert (b, aid) sb_acc, asw_acc)
    else
      if Set.any (fun z -> tid_of (fromJust $ Map.lookup z st.tact_map) = tid) $ Map.domain st.tact_map then
        (sb_acc, asw_acc)
      else
        (sb_acc, Set.insert (b, aid) asw_acc)

(*
      if Set.any (fun z -> false && tid_of (Map.find z st.tact_map) = tid && accessible z aid $ Set.to_list st.sb) $ Map.domain st.tact_map then
        (sb_acc, asw_acc)
      else
        (sb_acc, Set.insert (b, aid) asw_acc)
*)
  ) bs (st.sb, st.asw) in
  
  [(U.return (), <| st with sb= sb_; asw= asw_ |>)]





val get_location_kind: state -> Cmm.location -> Cmm.location_kind
let get_location_kind s x = 
  (* We use Non_Atomic as the default location_kind. Some locations are not used
     in the execution (i.e. there are no actions at that location) and then it does
     not matter which location_kind we specify. But some actions might be used, but 
     not present in s.E.lk (for example if it has been created with an alloc rather 
     than a create). In this case the default location_kind does matter. *)
   match Map.lookup x s.lk with
     | Just z  -> z
     | Nothing -> Cmm.Non_Atomic
   end






val initial_state: file taction_id -> state
let initial_state file = <|
  execution_mode= Exhaustive;
  mem_layout=     (Map.empty, 0);
  current_proc=   Nothing;
  file=           file;
  cont_map=       Map.empty;
  tact_counter=   0;
  tact_map=       Map.empty;
  trace=          [];
  cmm_tact_map=   Map.empty;
  lk=             Map.empty;
  sb=             {};
  asw=            {};
  rf=             {};
  mo=             Map.empty;
  sc=             [];
|>









(* Interaction with the memory layout state *)
val is_atomic_location: Memory.mem_addr -> t bool
let is_atomic_location o = fun st ->
  [(U.return (get_location_kind st o = Cmm.Atomic), st)] (* Boot.assert_false "HIP: is_atomic_location" *)
(*
  let foo = State_exception.eval 
  fun st -> [(U.return (get_location_kind st o = Cmm.Atomic), st)]
 *)

val is_nonatomic_location: Memory.mem_addr -> t bool
let is_nonatomic_location o = fun st ->
  [(U.return (get_location_kind st o = Cmm.Non_Atomic), st)] (* Boot.assert_false "HIP: is_nonatomic_location" *)
  (* fun st ->  *)
