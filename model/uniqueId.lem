open import Pervasives Enum
import State

type t 'a = 'a
type supply 'a = t 'a

declare hol target_rep type t = ``
declare hol target_rep type supply = ``

val new_supply: forall 'a. Enum 'a => supply 'a
let new_supply =
  toEnum 0

val new_supply_from: forall 'a. Enum 'a => nat -> supply 'a
let new_supply_from n =
  toEnum n


val fresh_id: forall 'a. NumSucc 'a => supply 'a -> t 'a * supply 'a
let fresh_id supl =
  (supl, succ supl)

val latest_id: forall 'a. supply 'a -> t 'a
let latest_id supl =
  supl



(* Splitable id supply (from https://gist.github.com/t0yv0/1092323) *)
type lin =
  | Lin of integer * integer

val idLin: lin
let idLin =
  Lin 1 0

val runLin: lin -> integer -> integer
let runLin (Lin a b) x =
  a * x + b

val nextLin: lin -> lin
let nextLin (Lin a b) =
  Lin a (a + b)

val evenLin: lin -> lin
let evenLin (Lin a b) =
  Lin (2 * a) b

val oddLin: lin -> lin
let oddLin z =
  nextLin (evenLin z)

type splitable_id =
  | Splitable of integer
type splitable_gen =
  | Gen of lin

val initial: splitable_gen
let initial =
  Gen idLin

val split: splitable_gen -> splitable_gen * splitable_gen
let spit (Gen x) =
  (Gen (evenLin x), Gen (oddLin x))

val gen: splitable_gen -> splitable_id * splitable_gen
let gen (Gen x) =
  (Splitable (runLin x 0), Gen (nextLin x))

(*

type Fresh a = State Gen a

fresh :: Fresh Id
fresh = do (id, gen') <- gets gen
           modify (const gen')
           return id
           
parallel :: Fresh a -> Fresh b -> Fresh (a, b)
parallel a b = do (g0, g1) <- gets split
                  let (g2, g3) = split g0
                      (x, _)   = runState a g2
                      (y, _)   = runState b g3
                  modify (const g1)
                  return (x, y)
*)
