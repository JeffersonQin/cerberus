open import Pervasives Utils
open import UniqueId Symbol

import Pp

import Core 
module C = Core

module A = struct
  include import AilSyntax
  include import AilTypes
end
import GenTypes GenTypesAux

(* Ail typing *)
import GenTyping ErrorMonad

(* Elaboration *)
open import Translation Translation_aux
import Translation_effect
module TranslateEff = Translation_effect

(* Core evaluation *)
import Core_run Core_run_aux Driver
import Nondeterminism
module ND = Nondeterminism


val runND_proxy:
  Driver.driverM Driver.driver_result -> Driver.driver_state ->
  list (ND.nd_status Driver.driver_result Driver.driver_error * list string * Driver.driver_state)


declare ocaml target_rep function runND_proxy = `Smt2.runND Exhaustive Ocaml_mem.cs_module`

val empty_sigma: forall 'a. A.sigma 'a
let empty_sigma = <|
  A.declarations= [];
  A.object_definitions= [];
  A.function_definitions= [];
  A.static_assertions= [];
  A.tag_definitions= [];
|>


import Exception Errors
module Eff = Exception
let inline (>>=) = Eff.bind


val evalConstantExpressionAux:
  Loc.t -> (map string Symbol.sym) * C.fun_map unit * C.impl ->
  A.sigma unit ->
  UniqueId.supply Symbol.sym ->
  (GenTypes.genTypeCategory -> Eff.exceptM unit Errors.error) ->
  maybe AilTypes.ctype -> A.expression unit -> Eff.exceptM C.value Errors.error

let evalConstantExpressionAux loc (*TODO*)(ailnames, stdlib_fun_map, impl) sigm symbol_suppl typing_guard ty_opt expr =
  let toAilTau: A.expression unit -> ErrorMonad.errorM (A.expression GenTypes.genTypeCategory) =
    GenTyping.annotate_expression sigm [] (*TODO: check*)GenTyping.CTXother in
  
  let toCore (a_e: A.expression GenTypes.genTypeCategory) : TranslateEff.elabM (Core.expr unit) =
    (* STD ยง6.6#4 *)
    (* NOTE: this constraint requires the evaluated constant to be within the range of expression's type *)
    let stdlib = Translation_aux.mk_translation_stdlib (ailnames, stdlib_fun_map) in
    let ty = match ty_opt with
      | Just ty ->
          ty
      | Nothing ->
          (* TODO/NOTE: this should correspond to constants from array sizes and such *)
          Translation_aux.ctype_of a_e
    end in
    let oTy = force_core_object_type_of_ctype (Core_aux.proj_ctype ty) in
    TranslateEff.bind (translate_expression stdlib (Map.empty: C.core_tag_definitions) a_e) (fun core_e                       ->
    TranslateEff.bind (TranslateEff.wrapped_fresh_symbol (C.BTy_loaded oTy))                (fun (_, e_sym_pat  , e_sym_pe  ) ->
    TranslateEff.bind (TranslateEff.wrapped_fresh_symbol (C.BTy_object oTy))                (fun (_, obj_sym_pat, obj_sym_pe) ->
    TranslateEff.return begin
      Core_aux.mk_wseq_e e_sym_pat core_e begin
        Core_aux.mk_pure_e begin
          Core_aux.mk_case_pe e_sym_pe
            [ ( Core_aux.mk_specified_pat obj_sym_pat
              , Core_aux.mk_if_pe
                  (stdlib.mkcall_is_representable obj_sym_pe ty)
                  (Caux.mk_specified_pe obj_sym_pe)
                  (Core_aux.mk_error_pe "ยง6.6#4 failed" obj_sym_pe) )
            ; ( Core_aux.mk_unspecified_pat (Core_aux.mk_empty_pat C.BTy_ctype)
                (* TODO: this should be dead code? *)
              , obj_sym_pe (* TODO: check with P *) ) ]
        end
      end
    end))) in
  
  (* typechecks the expression *)
  match ErrorMonad.runErrorMonad (toAilTau expr) with
    | Left (loc, err) ->
        error "TODO: integer expression was illtyped"
    | Right a_expr ->
        (* applies the provided typing guard *)
        typing_guard (GenTypes.genTypeCategoryOf a_expr) >>= fun () ->
        
        (* elaborate the typed expression into Core *)
        let (core_expr, translate_final_st) = TranslateEff.runStateM (toCore a_expr) (TranslateEff.init symbol_suppl) in
        
        let dr_st =
          (* this just builds the shell of the driver state *)
          let dummy_core_file = Core_run_aux.convert_file
            <| C.main= Nothing
             ; C.stdlib= stdlib_fun_map
             ; C.impl= impl
             ; C.globs= []
             ; C.funs= Map.empty
             ; C.tagDefs= Map.empty |> in
          let init_dr_st = Driver.initial_driver_state translate_final_st.TranslateEff.symbol_supply dummy_core_file in
          (* spawning a thread with the Core expression we just generated as it's arena *)
          let ((tid, core_st), run_st) = State.run (
            Core_run.spawn_thread Nothing <|
              Core_run.arena=  Core_run_aux.convert_expr core_expr;
              Core_run.stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
              Core_run.labels= Map.empty;
              Core_run.labels2= Map.empty;
              Core_run.current_loc= loc;
              Core_run.current_uid= Nothing;
              Core_run.exec_loc= Core_run.ELoc_normal []; (* TODO: maybe create a new variant *)
            |> init_dr_st.Driver.core_state
          ) init_dr_st.Driver.core_run_state in
          (* now we can build the actual driver's initial state *)
          <| init_dr_st with
           Driver.core_state= core_st;
           Driver.core_run_state= run_st |> in
        
        (* run the evaluator *)
        let driver_action =
          ND.bind (Driver.driver false) (fun () ->
            ND.bind ND.get (fun dr_st' ->
              ND.return (Driver.finalize "wipFrontend" dr_st')
            )
          ) in
        let () = Core_ctype_aux.set_tagDefs (Translation.translate_tag_definitions sigm.A.tag_definitions) in
        let execs = runND_proxy driver_action dr_st in
        let () = Core_ctype_aux.reset_tagDefs () in
        match execs with
          | [(ND.Active dres, _, _ )] ->
              Eff.return dres.Driver.dres_core_value
          | [(ND.Killed (ND.Undef ub_loc ubs), _, _)] ->
              Eff.fail (ub_loc, Errors.Desugar_cause (Errors.Desugar_constantExpression_UB ubs))
          | [(ND.Killed (ND.Error loc "ยง6.6#4 failed"), _, _)] ->
              Eff.fail (loc, Errors.Desugar_cause (Errors.Desugar_ConstraintViolation "ยง6.6#4"))
          | _ ->
              error "TODO error: the driver found less/more than one active execution"
        end
  end


val evalIntegerConstantExpression:
  Loc.t -> string -> (map string Symbol.sym) * C.fun_map unit * C.impl -> A.sigma unit ->
  UniqueId.supply Symbol.sym -> maybe AilTypes.ctype -> A.expression unit -> Eff.exceptM integer Errors.error

let evalIntegerConstantExpression loc std_str core_env sigm symbol_suppl ty_opt expr =
  let typing_guard gtc =
    let do_fail = Eff.fail (loc, Errors.Desugar_cause (Errors.Desugar_constantExpression_notInteger std_str)) in
    match gtc with
      | GenTypes.GenLValueType _ _ _ ->
          do_fail
      | GenTypes.GenRValueType gTy ->
          (* TODO: check ty_opt and gTy ? *)
          if GenTypesAux.is_integer gTy then
            Eff.return ()
          else
            do_fail
    end in
  
  evalConstantExpressionAux loc core_env sigm symbol_suppl typing_guard ty_opt expr >>= function
    | C.Vloaded (C.LVspecified (C.OVinteger ival)) ->
        match Mem.eval_integer_value ival with
          | Just n ->
              Eff.return n
          | Nothing ->
              error "TODO error: the memory model failed to concretise the integer value (was impl dependent?)"
        end
    | cval ->
        let () = Debug.print_debug 1 [] (fun () ->
          "cval: " ^ Pp.stringFromCore_value cval
        ) in
        (* given that typing guard has passed the evaluator must evaluate to an integer value *)
        Eff.fail (loc, Errors.Desugar_cause Errors.Desugar_impossible)
  end
