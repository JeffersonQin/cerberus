open Global

type ordering = Before | After | NoOrdering

module L = struct
  (* monadic operations *)
  val return: forall 'a. 'a -> list 'a
  let return x = [x]
  
  val bind: forall 'a 'b. list 'a -> ('a -> list 'b) -> list 'b
  let bind m f = List.fold_right (fun x y -> (f x) @ y) m []
  
  
  (* MonadPlus operations *)
  val mzero: forall 'a. list 'a
  let mzero = []
  
  val mplus: forall 'a. list 'a -> list 'a -> list 'a
  let mplus = (@)
  
  
  (* generic functions (that should be moved out once we have type-classes) *)
  val msum: forall 'a. list (list 'a) -> list 'a
  let msum = List.concat
  
  module Operators = struct
    let (>>=) = bind
    let (>>) m f = bind m (fun _ -> f)
  end
  
  open Operators
  
  let sequence ms = List.fold_right (fun m acc -> m   >>= fun x  ->
                                                  acc >>= fun xs ->
                                                  return (x::xs))
                                    ms (return [])
  let mapM f xs = sequence (List.map f xs)

end

(* -------------------------------------------------------------------------- *)
open L.Operators


(* TODO: rename *)
type expr =
  | Eskip
  | Econst of int
  | Eaddr of Core.mem_addr
  | Esym of Core.sym
  | Eop of Core.binop * expr * expr
  | Etrue
  | Efalse
  | Enot of expr
  | Ectype of Core.ctype
  | Elet of Core.sym * expr * expr
  | Eif of expr * expr * expr
  | Ecall of Core.name * list expr
  | Esame of expr * expr
  | Eundef of Undefined.undefined_behaviour
  | Eerror
  | Eaction of paction
  | Eunseq of list (expr)
  | Ewseq of list (option Core.sym) * expr * expr
  | Esseq of list (option Core.sym) * expr * expr
  | Easeq of option Core.sym * action * paction
  | Eindet of expr
  | Ebound of num * expr
  | Esave of Core.ksym * list (Core.sym * Core.ctype) * expr
  | Erun of Core.ksym * list (Core.sym * expr)
  | Eshift of Core.sym * expr
  
  | Ebefore of expr
  | Eafter of expr
  
  (* A [Eindet e] becomes a [End es] *)
  | End of list expr


and action =
  | Create of expr * list Symbol.t
  | Alloc of expr * list Symbol.t
  | Kill of expr
  | Store of expr * expr * expr
  | Load of expr * expr
and paction = Core.polarity * action







val     import_expr: Core.expr zero -> expr
let rec import_expr e =
  match e with
  | Core.Eskip               -> Eskip
  | Core.Econst n            -> Econst n
  | Core.Eaddr o             -> Eaddr o
  | Core.Esym a              -> Esym a
  | Core.Eop binop e1 e2     -> Eop binop (import_expr e1) (import_expr e2)
  | Core.Etrue               -> Etrue
  | Core.Efalse              -> Efalse
  | Core.Enot e              -> Enot (import_expr e)
  | Core.Ectype ty           -> Ectype ty
  | Core.Elet a e1 e2        -> Elet a (import_expr e1) (import_expr e2)
  | Core.Eif e1 e2 e3        -> Eif (import_expr e1) (import_expr e2) (import_expr e3)
  | Core.Ecall f args        -> Ecall f (List.map import_expr args)
  | Core.Esame e1 e2         -> Esame (import_expr e1) (import_expr e2)
  | Core.Eundef u            -> Eundef u
  | Core.Eerror              -> Eerror
  | Core.Eaction pact        -> Eaction (import_paction pact)
  | Core.Eunseq es           -> Eunseq (List.map import_expr es)
  | Core.Ewseq _as e1 e2     -> Ewseq _as (import_expr e1) (import_expr e2)
  | Core.Esseq _as e1 e2     -> Esseq _as (import_expr e1) (import_expr e2)
  | Core.Easeq a act pact    -> Easeq a (import_action act) (import_paction pact)
  | Core.Eindet e            -> Eindet (import_expr e)
  | Core.Ebound i e          -> Ebound i (import_expr e)
  | Core.Esave k a_tys e     -> Esave k a_tys (import_expr e)
  | Core.Erun _ k a_vs       -> Erun k (List.map (fun (a, v) -> (a, import_expr v)) a_vs)
  | Core.Eshift a e          -> Eshift a (import_expr e)
  end

and import_action (_, act) =
  match act with
    | Core.Create e_ty pref   -> Create (import_expr e_ty) pref
    | Core.Alloc e_n pref     -> Alloc (import_expr e_n) pref
    | Core.Kill e_o           -> Kill (import_expr e_o)
    | Core.Store e_ty e_o e_n -> Store (import_expr e_ty) (import_expr e_o) (import_expr e_n)
    | Core.Load e_ty e_o      -> Load (import_expr e_ty) (import_expr e_o)
  end
and import_paction (p, act) = (p, import_action act)


val     export_expr: expr -> Core.expr zero
let rec export_expr e =
  match e with
  | Eskip               -> Core.Eskip
  | Econst n            -> Core.Econst n
  | Eaddr o             -> Core.Eaddr o
  | Esym a              -> Core.Esym a
  | Eop binop e1 e2     -> Core.Eop binop (export_expr e1) (export_expr e)
  | Etrue               -> Core.Etrue
  | Efalse              -> Core.Efalse
  | Enot e              -> Core.Enot (export_expr e)
  | Ectype ty           -> Core.Ectype ty
  | Elet a e1 e2        -> Core.Elet a (export_expr e1) (export_expr e2)
  | Eif e1 e2 e3        -> Core.Eif (export_expr e1) (export_expr e2) (export_expr e3)
  | Ecall f args        -> Core.Ecall f (List.map export_expr args)
  | Esame e1 e2         -> Core.Esame (export_expr e1) (export_expr e2)
  | Eundef u            -> Core.Eundef u
  | Eerror              -> Core.Eerror
  | Eaction pact        -> Core.Eaction (export_paction pact)
  | Eunseq es           -> Core.Eunseq (List.map export_expr es)
  | Ewseq _as e1 e2     -> Core.Ewseq _as (export_expr e1) (export_expr e2)
  | Esseq _as e1 e2     -> Core.Esseq _as (export_expr e1) (export_expr e2)
  | Easeq a act pact    -> Core.Easeq a (export_action act) (export_paction pact)
  | Eindet e            -> Core.Eindet (export_expr e)
  | Ebound i e          -> Core.Ebound i (export_expr e)
  | Esave k a_tys e     -> Core.Esave k a_tys (export_expr e)
  | Erun k a_vs         -> Core.Erun {} k (List.map (fun (a,v) -> (a, export_expr v)) a_vs)
  | Eshift a e          -> Core.Eshift a (export_expr e)
  end

and export_action act =
  ({},
  match act with
    | Create e_ty pref   -> Core.Create (export_expr e_ty) pref
    | Alloc e_n pref     -> Core.Alloc (export_expr e_n) pref
    | Kill e_o           -> Core.Kill (export_expr e_o)
    | Store e_ty e_o e_n -> Core.Store (export_expr e_ty) (export_expr e_o) (export_expr e_n)
    | Load e_ty e_o      -> Core.Load (export_expr e_ty) (export_expr e_o)
  end)
and export_paction (p, act) = (p, export_action act)




(* TODO: duplicate from Core_run *)
val pick_one: forall 'a. list 'a -> list (list 'a * 'a * list 'a)
let rec _pick_one acc = function
  | []    -> []
  | x::xs -> (List.rev acc, x, xs) :: _pick_one (x::acc) xs
end
let pick_one l = L.msum $ List.map L.return (_pick_one [] l)


val     one: expr -> list (ordering * expr)
let rec one e =
  match e with
    | Eaction pact -> L.mplus (L.return (Before, Ebefore $ Eaction pact))
                              (L.return (After, Eafter   $ Eaction pact))
    
    | Ewseq _as (Eindet e1) e2 -> L.return (After, Ewseq _as (Eindet e1)  (Eafter e2))
    | Ewseq _as e1 (Eindet e2) -> L.return (After, Ewseq _as (Ebefore e1) (Eindet e2))
    
    | Ewseq _as e1 e2 -> one e1 >>= fun (d, e1') ->
                     match d with
                       | Before -> one e2 >>= fun (d', e2') -> L.return (d', Ewseq _as e1' e2')
		       | After  -> L.return (d, Ewseq _as e1' (Eafter e2))
                     end
    
    | Eunseq es -> (L.mapM one es >>= L.return -| unzip) >>= fun (ds, es') ->
                   L.return ((if all (fun x -> x = Before) ds then Before else After), Eunseq es')



(* Nothing to do | No direction *)
  | Eskip        -> L.return (NoOrdering, e)
  | Econst n     -> L.return (NoOrdering, e)
  | Eaddr x      -> L.return (NoOrdering, e)
  | Esym a       -> L.return (NoOrdering, e)
  | Eop op e1 e2 -> L.return (NoOrdering, e)
  | Etrue        -> L.return (NoOrdering, e)
  | Efalse       -> L.return (NoOrdering, e)
  | Enot e       -> L.return (NoOrdering, e)
  | Ectype ty    -> L.return (NoOrdering, e)
  | Elet a e1 e2 -> L.return (NoOrdering, e)
  | Eif e1 e2 e3 -> L.return (NoOrdering, e)
  | Ecall f args -> L.return (NoOrdering, e)
  | Esame e1 e2  -> L.return (NoOrdering, e)
  | Eundef _     -> L.return (NoOrdering, e)
  | Eerror       -> L.return (NoOrdering, e)


(*
  | Ewseq _as e1 e2
  | Esseq _as e1 e2
  | Easeq _a act pact
  | Eindet e
*)


(* [one] is only called a particular Ebound and on that run ignore the inner Ebounds *)
  | Ebound i e -> one e >>= fun (d, e') -> L.return (d, Ebound i e')

(*
  (* [one] is called of core expression corresponding to C expression so
           there is no control operator *)
  | Esave k e
  | Erun k
*)
  
(* (* this ctor can't already exist *)
  | Ebefore e 
  | Eafter e
  | End es
*)
  end

(*
one (Eatom a) = return (B, Ebefore (Eatom a)) `mplus` return (A, Eafter (Katom a))

one (Eseq Kindet e2) = return (A, Eseq Eindet (Eafter e2)) -- CHECK returned Dir
one (Eseq e1 Eindet) = return (B, Eseq (Ebefore e1) Eindet) -- CHECK returned Dir

one (Eseq e1 e2) = do
  (d, e1') <- one e1
  case d of
    B -> one e2 >>= \(d', e2') -> return (d', Eseq e1' e2') -- TODO: not sure about the returned dir
    A -> return (d, Eseq e1' (Eafter e2))

one (Eunseq es) = do
  (ds, es') <- mapM one es >>= return . unzip
  return (if all (==B) ds then B else A, Eunseq es')
*)




(*
let rec b_action_one e =
  match e with
    | Eaction (p, act) -> L.return (Before, Ebefore $ Eaction (p, act))
    | _                -> L.mzero
  end

and a_action_one e =
  match e with
    | Eaction (p, act) -> L.return (After, Eafter $ Eaction (p, act))
    | _                -> L.mzero
  end

and wseq_l_one e =
  match e with
    | Ewseq _as e1 e2 -> one e1 >>= fun (ord, e1') ->
                         L.return $ match ord with
                           | Before -> (Before, Ewseq _as e1' e2         )
                           | After  -> (After,  Ewseq _as e1' (Eafter e2))
                         end
    | _ -> L.mzero
  end

and wseq_r_one e =
  match e with
    | Ewseq _as e1 e2 -> one e2 >>= fun (ord, e2') ->
                         L.return $ match ord with
                           | Before -> (Before, Ewseq _as (Ebefore e1) e2 )
                           | After  -> (After,  Ewseq _as e1           e2')
                         end
    | _ -> L.mzero
  end

and unseq_one e =
  match e with
    | Eunseq es -> pick_one es            >>= fun (es1, ej, es2) ->
                   one ej                 >>= fun (ord, ej')     ->
                   L.return (ord, Eunseq (es1 @ ej' :: es2))
    | _ -> L.mzero
  end

and one e = L.msum [
  b_action_one e; a_action_one e;
  wseq_l_one e; wseq_r_one e;
 ]
*)

val determinate_expr: Core.expr zero -> list expr
let determinate_expr e =
  [import_expr e] (* TODO *)




let rec hack x =
  match x with
  | Core.Etuple es             -> Core.Etuple es
  | Core.Eskip                 -> Core.Eskip
  | Core.Econst n              -> Core.Econst n
  | Core.Eaddr x               -> Core.Eaddr x
  | Core.Esym _a               -> Core.Esym _a
  | Core.Eop op e1 e2          -> Core.Eop op e1 e2
  | Core.Etrue                 -> Core.Etrue
  | Core.Efalse                -> Core.Efalse
  | Core.Enot e                -> Core.Enot e
  | Core.Ectype ty             -> Core.Ectype ty
  | Core.Elet _a e1 e2         -> Core.Elet _a e1 (hack e2)
  | Core.Eif e1 e2 e3          -> Core.Eif e1 (hack e2) (hack e3)
  | Core.Ecall f args          -> Core.Ecall f args
  | Core.Esame e1 e2           -> Core.Esame e1 e2
  | Core.Eundef u              -> Core.Eundef u
  | Core.Eerror                -> Core.Eerror
  | Core.Eaction pact          -> Core.Eaction pact
  | Core.Eunseq es             -> Core.Eunseq (List.map hack es)
  | Core.Ewseq _as e1 e2       -> Core.Ewseq _as (hack e1) (hack e2)
  | Core.Esseq _as e1 e2       -> Core.Esseq _as (hack e1) (hack e2)
  (* HACKKKKKKKK *)
  | Core.Easeq _a_opt act pact ->

      Core.Ewseq [_a_opt] (Core.Eaction (Core.Pos, act))
                          (Core.Ewseq [] (Core.Eaction pact) (Core.Esym match _a_opt with Some x -> x end))



  | Core.Eindet e              -> hack e
  | Core.Ebound i e            -> hack e
  | Core.Esave d a_tys e       -> Core.Esave d a_tys (hack e)
  | Core.Erun bs d a_vs        -> Core.Erun bs d a_vs
  | Core.Eret e                -> Core.Eret (hack e)
  | Core.End es                -> Core.End es
  | Core.Eshift a e            -> Core.Eshift a e
  | _ -> x
end




(* TODO: hack *)
(*  *)
val order: Core.file zero -> Exception.t (list (num * Core.file zero)) (Errors.cause)
let order (f: Core.file zero) =
(*  let fbodies' = List.map (fun (_, (_, _, e)) -> determinate_expr e) $ Pmap.bindings f.Core.fun_map in *)
  
  
  
  Exception.return [(1, <| f with Core.funs= Pmap.map (fun (ty, args, body) -> (ty, args, hack body)) f.Core.funs |>)]

(*


  Exception.return <| f with fun_map= f.fun_map |>
  Exception.return (numerote $ List.map export_expr (one (import_expr e))) (* (numerote $ List.map export_expr $ one (import_expr e)) (* [(1, e); (2, e)] *) *)
  (* Boot.outOfHomeomorphism "hello" *)


*)

