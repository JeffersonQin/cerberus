open import Core

val     sequentialise_expr: typed_expr unit -> typed_expr unit
let rec sequentialise_expr expr =
  match expr with
    | Epure _ ->
        expr
    | Ememop _ _ ->
        expr
    | Eaction _ ->
        expr
    | Ecase pe cases ->
        (* TODO: the typing should maybe forbid unseqs inside cases anyway? *)
        Ecase pe (List.map (fun (pat, e) -> (pat, sequentialise_expr e)) cases)
    | Elet sym pe1 e2 ->
        Elet sym pe1 (sequentialise_expr e2)
    | Eif pe1 e2 e3 ->
        Eif pe1 (sequentialise_expr e2) (sequentialise_expr e3)
    | Eskip ->
        expr
    | Eproc _ _ _ ->
        expr
    | Ereturn _ ->
        expr
    | Eunseq es ->
        expr
(*
        E.replicateM (List.length es) E.fresh_symbol >>= fun syms ->
        
        E.return expr
*)
(*
        E.mapM sequentialise_expr es >>= fun es' ->
        E.return (
          Caux.mk_wseq (Epure (C.PEtuple (List.map (fun sym -> C.PEsym sym) syms)))
            (Global.map2 (fun sym e -> ([Just sym], e)) syms es')
        )
*)
    | Ewseq (CaseBase Nothing) (Eunseq es) e2 ->
        List.foldr (fun e acc ->
          Ewseq (CaseBase Nothing) (sequentialise_expr e) acc
        ) (sequentialise_expr e2) es
    | Ewseq (CaseCtor Ctuple pats) (Eunseq es) e2 ->
        List.foldr (fun (pat, e) acc ->
          Ewseq pat (sequentialise_expr e) acc
        ) (sequentialise_expr e2) (List.zip pats es)
    | Ewseq pat e1 e2 ->
        Ewseq pat (sequentialise_expr e1) (sequentialise_expr e2)
    | Esseq (CaseBase Nothing) (Eunseq es) e2 ->
        List.foldr (fun e acc ->
          Esseq (CaseBase Nothing) (sequentialise_expr e) acc
        ) (sequentialise_expr e2) es
    | Esseq (CaseCtor Ctuple pats) (Eunseq es) e2 ->
        List.foldr (fun (pat, e) acc ->
          Esseq pat (sequentialise_expr e) acc
        ) (sequentialise_expr e2) (List.zip pats es)
    | Esseq pat e1 e2 ->
        Esseq pat (sequentialise_expr e1) (sequentialise_expr e2)
    | Easeq _ _ _ ->
        expr
    | Eindet i e ->
        Eindet i (sequentialise_expr e)
    | Ebound i e ->
        Ebound i (sequentialise_expr e)
    | End es ->
        End (List.map sequentialise_expr es)
    | Esave ksym sym_tys e ->
        Esave ksym sym_tys (sequentialise_expr e)
    | Erun _ _ _ ->
        expr
    | Epar es ->
        Epar (List.map sequentialise_expr es)
    | Ewait _ ->
        expr
    | Eloc loc e ->
        Eloc loc (sequentialise_expr e)
  end


val sequentialise_file: typed_file unit -> typed_file unit
let sequentialise_file file =
  <| file with funs= Map.map (function
       | Proc bTy params e ->
           Proc bTy params (sequentialise_expr e)
       | Fun bTy params pe ->
           Fun bTy params pe
     end) file.funs |>



(*
  main   : Symbol.sym;
  stdlib : generic_fun_map 'bty 'a;
  impl   : generic_impl 'bty;
  globs  : list (Symbol.sym * core_base_type * generic_expr 'a 'bty Symbol.sym);
  funs   : generic_fun_map 'bty 'a;
*)
