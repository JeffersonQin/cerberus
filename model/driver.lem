open import Pervasives

import Core Core_ctype Boot UniqueId Decode Output
import Core_aux 
module Caux = Core_aux


open import Utils Show Errors
import Cmm_op Cmm_csem Cthread

import Core_eval Core_run


import Translation_aux
import Enum State_exception_undefined Exception Undefined Nondeterminism Dlist


import AilSyntax AilTypes

import Translation_aux

module Mem = struct
  include import Mem Mem_aux
end

import Pp
(* import Driver_effect *)

module Cmm = Cmm_csem

(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism

open import {hol} `ppTheory`


import Global



(* DEBUG *)
val stringFromCore_core_state: forall 'a. Core_run.core_state -> string
declare ocaml target_rep function stringFromCore_core_state = `String_core_run.string_of_core_state`


type driver_error =
  | DErr_core_run of core_run_cause
  | DErr_memory of Mem_common.mem_error
  | DErr_concurrency of string
  | DErr_other of string

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.sym;
  
  core_file:         Core.file Core_run.core_run_annotation;
  core_state:        Core_run.core_state;       (* state of the core program *)
  core_run_state:    Core_run.core_run_state;   (* state of the core evaluator *)
  layout_state:      Mem.mem_state;         (* state of memory layout model *)
  concurrency_state: Cmm_op.symState;       (* state of the concurrency memory model *)
  
  symbolic_assoc: map Symbol.sym Core.object_value;
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  trace: list string;
  dr_step_counter: nat;
|>

let driver_state_eq dr_st1 dr_st2 =
     dr_st1.core_state = dr_st2.core_state
  && dr_st1.layout_state = dr_st2.layout_state
(*  && dr_st1.concurrency_state = dr_st2.concurrency_state *) (* TODO *)

instance (Eq driver_state)
  let (=) = driver_state_eq
  let (<>) = fun x y -> not (driver_state_eq x y)
end


type driverM 'a = ND.ndM 'a driver_error Mem.mem_iv_constraint driver_state


val aid_to_string: Cmm.action -> string
let aid_to_string a =
  show (Cmm.aid_of a)



(* open ND.Operators *)
let inline (>>=)      = ND.bind
let inline (>>) m1 m2 = ND.bind m1 (fun _ -> m2)



(*
val liftMem: forall 'a. Mem.memM 'a -> driver_state -> driverM ('a * driver_state)
let liftMem m dr_st =
  ND.msum "liftMem" $ map (function
    | Left mem_err ->
        (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other mem_err)
    | Right (z, layout_st') ->
        ND.return (z, <| dr_st with layout_state= layout_st' |>)
  end) (Mem.runMem m dr_st.layout_state)
*)
val liftMem: forall 'a. Mem.memM 'a -> driverM 'a
let liftMem m =
  ND.liftND (fun dr_st -> dr_st.layout_state)
    (fun dr_st mem_st -> <| dr_st with layout_state= mem_st |>)
    (fun mem_err -> DErr_memory mem_err)
    m

val liftConc: forall 'a. Cmm_op.ndM 'a -> driverM 'a
let liftConc =
  ND.liftND (fun _ -> ())
    (fun dr_st () -> dr_st)
    (fun str -> DErr_concurrency str)


let add_to_concur_sym_map sym oval concur_sym_map =
  match oval with
    | _ ->
        let () = Debug.print_debug 4 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ADDING TO ASSOC ==> " ^ show sym ^ " := " ^ Pp.stringFromCore_value (Core.Vobject oval)) in
        Map.insert sym oval concur_sym_map
  end

val     print_eval_conv_aux: driver_state -> Core.pexpr -> Mem.memM (either Errors.error (Undefined.t Core.value))
let rec print_eval_conv_aux dr_st pe =
  match Core_eval.eval_pexpr_aux2 (Loc.other "Driver.print_eval_conv_aux") dr_st.core_run_state.Core_run.env (Just dr_st.layout_state) dr_st.core_file pe with
  | Exception.Result (Undefined.Defined (Right cval)) ->
      ND.return (Right (Undefined.Defined cval))
  | Exception.Result (Undefined.Defined (Left (Core.Pexpr [] () (Core.PEconstrained xs)))) ->
      ND.msum "printf_eval_conv" begin
        List.map (fun (cs, pe) ->
            ( "printf_eval_conv_pe_constrained"
            , ND.addConstraints "printf_eval_conv" cs >> print_eval_conv_aux dr_st pe
            )) xs
        end
  | Exception.Result (Undefined.Defined _) ->
      error "print_eval_conv: should be a value or PEconstrained"
  | Exception.Result (Undefined.Undef loc undef) ->
      ND.return (Right (Undefined.Undef loc undef))
  | Exception.Result (Undefined.Error loc err) ->
      ND.return (Right (Undefined.Error loc err))
  | Exception.Exception err ->
      ND.return (Left (Loc.other "Driver.print_eval_conv_aux", Errors.CORE_RUN err))
end

val printf_eval_conv: driver_state -> Core_ctype.ctype -> Mem.mem_value -> Mem.memM (either Errors.error (Undefined.t Core.value))
let printf_eval_conv dr_st cty mval =
  let () = Debug.print_debug 4 [] (fun () -> "printf_eval_conv") in
  let (_, cval) = Core_aux.valueFromMemValue mval in
  print_eval_conv_aux dr_st $
    Translation_aux.mk_stdcall dr_st.core_file.Core.stdlib "conv_loaded_int"
    [ Caux.mk_ctype_pe cty; Core.Pexpr [] () (Core.PEval cval)]

(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driverM unit
let rec stepConcurrency n =
  let () = Debug.print_debug 10 [Debug.DB_driver] (fun () -> "Driver.stepConcurrency") in (* DEBUG *)
  if n = 0 then
    ND.return ()
  else begin
    ND.get >>= fun dr_st ->
    let conc_result = Cmm_op.symStep dr_st.concurrency_state in
    liftConc conc_result >>= function
      | Cmm_op.ConcurrencyTau performed_act concur_st' ->
          ND.log ("ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act)) >> (* DEBUG *)
          ND.print_debug 4 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act) ^ "\n") >> (* DEBUG *)
          ND.update (fun dr_st -> <| dr_st with concurrency_state= concur_st' |>)
      
      (* TODO: the variables names seems completely messed up here *)
      | Cmm_op.ReadsFrom (new_concrete_mval: Mem.mem_value) (previous_symbolic_mval: Mem.mem_value) performed_act concur_st' ->
          error "WIP: Driver.stepConcurrency, ReadsFrom"
(*
          ND.log ("ReadsFrom with aid: " ^ show (Cmm.aid_of performed_act) ^ " with concrete: " ^ (* DEBUG *)
                  Pp.pretty_stringFromMem_mem_value new_concrete_mval ^ " and previous: " ^       (* DEBUG *)
                  Pp.pretty_stringFromMem_mem_value previous_symbolic_mval) >>                    (* DEBUG *)
          ND.print_debug 2 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ReadsFrom with aid: " ^ aid_to_string performed_act ^ "\n") >>       (* DEBUG *)
          ND.print_debug 2 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "CONCRETE MVAL = " ^ Pp.stringFromCore_value        (* DEBUG *)
            (Core.Vobject (snd $ Core_aux.objectValueFromMemValue new_concrete_mval))) >>         (* DEBUG *)
          
          let new_concrete_cst =
            let other = Symbolic.SYMBconst (snd $ Core_aux.objectValueFromMemValue new_concrete_mval) in
            Mem.case_mem_value new_concrete_mval
              (fun _ -> other)
              (fun _ sym -> Symbolic.SYMBsym Symbolic.SYMBint sym)
              (fun _ _ -> other)
              (fun _ _ -> other)
              (fun _ _ -> other)
              (fun _ -> other)
              (fun _ _ -> other)
              (fun _ _ _ -> other) in
          
          let previous_sym =
            let fail = error "[Driver] previous_symbolic_mval was not a concurrency read" in
            Mem.case_mem_value new_concrete_mval
              (fun _ -> fail)
              (fun _ sym -> sym)
              (fun _ _ -> fail)
              (fun _ _ -> fail)
              (fun _ _ -> fail)
              (fun _ -> fail)
              (fun _ _ -> fail)
              (fun _ _ _ -> fail) in
          let previous_symb = Symbolic.SYMBsym Symbolic.SYMBint previous_sym in
          
          ND.log ("ADDING READ CONSTRAINT: EQ " ^ Pp.pretty_stringFromMem_mem_value previous_symbolic_mval ^ " <--> " ^ (* DEBUG *)
                  Pp.pretty_stringFromMem_mem_value new_concrete_mval) >>                                               (* DEBUG *)
          ND.add_constraint (Constraints.assert_eq previous_symb new_concrete_cst) >>
          ND.print_debug 2 [Debug.DB_driver; Debug.DB_concurrency]
            (fun () -> "ReadsFrom: " ^ show previous_sym ^ " = " ^ Pp.pretty_stringFromMem_mem_value new_concrete_mval) >> (* DEBUG *)
          ND.return <| dr_st with
            concurrency_state= concur_st';
            core_state= (* resolve_read previous_sym new_concrete_cst *) dr_st.core_state;
            symbolic_assoc= add_to_concur_sym_map previous_sym (snd (Core_aux.objectValueFromMemValue new_concrete_mval)) dr_st.symbolic_assoc;
          |>
*)
    end
  end >>
  stepConcurrency (n-1)

val liftCore_run: forall 'a. Core_run.core_runM 'a -> driverM 'a
let liftCore_run m =
  ND.get >>= fun dr_st ->
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (res, run_st') ->
        ND.update (fun dr_st -> <| dr_st with core_run_state= run_st' |>) >>
        match res with
          | U.Defined z ->
              ND.return z
          | U.Undef loc ubs ->
              ND.kill (ND.Undef loc ubs)
          | U.Error loc str ->
              ND.kill (ND.Error loc str)
        end
    | Exception.Exception err ->
        ND.kill (ND.Other (DErr_core_run err))
  end

(*
val runCore: forall 'a. core_runM 'a -> driver_state -> driverM ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)
    
    | Exception.Result (U.Undef loc ubs, _) ->
        ND.kill (ND.Undef loc ubs)
    
    | Exception.Result (U.Error loc str, _) ->
        ND.kill (ND.Error loc str)
    
    | Exception.Exception err ->
        ND.kill (ND.Other (DErr_core_run err))
  end
*)


(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: Cmm_op.symState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.Cmm_op.symPre.Cmm.actions - List.length concur_st.Cmm_op.symCommitted


(*
let symbolicFromIntegerValue ((Defacto_memory_types2.IV _ ival_) as ival) =
  match ival_ with
  | Defacto_memory_types2.IVconcurRead _ sym ->
      Symbolic.SYMBsym Symbolic.SYMBint sym
  | _ ->
      Symbolic.SYMBconst (Core.OVinteger ival)
  end
*)


(* For a given thread, perform all possible step that are not action requests *)
val     drive_core_thread: Cthread.thread_id -> driverM unit
let rec drive_core_thread tid =
  ND.get >>= fun dr_st ->
  let th_info = match List.lookup tid dr_st.core_state.Core_run.thread_states with
    | Just z ->
        z (* (tid, z) *)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  ND.mk_step "drive_core_thread" $ List.map (function
    | Core_run.Step_constrained debug_str xs ->
        ( "Step_constrained(" ^ debug_str ^ ")"
        , (* DEBUG *) ND.print_debug 4 [Debug.DB_driver_step] (fun () -> ">> STEP_CONSTRAINED, |xs| = " ^ show (List.length xs)) >>
          ND.msum "step_constrained" (
            List.map (fun (cs, step_m) ->
              ( Pp.stringFromMem_iv_mem_constraint cs
              , let () = Debug.print_debug 4 [] (fun () ->
                  "ADDING CONSTRAINTS (driver) ===> " ^ Pp.stringFromMem_iv_mem_constraint cs
                ) in
                ND.addConstraints ("driver: " ^ debug_str) cs >>
                liftCore_run step_m >>= fun th_st' ->
                ND.update (fun dr_st -> <| dr_st with
                  core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
                  dr_step_counter= dr_st.dr_step_counter + 1
                |>) >>
                drive_core_thread tid )
            ) xs
          ) )
    
    | Core_run.Step_action_request str _ ->
        ( str
        , ND.return () )
    | Core_run.Step_memop_request _ _ _ _ ->
        ( "Step_memop_request"
        , ND.return () )
    | Core_run.Step_tau debug_str step_m ->
        ( "Step_tau(" ^ debug_str ^ ")"
        , let () = Debug.print_debug 4 [] (fun () -> "Step_tau(" ^ debug_str ^ ")") in
          let () = Boot.begin_timing ("tau: " ^ debug_str) in (* DEBUG, PROFILING *)
          let pre_th_st = (* DEBUG *)
            snd $ fromJust "Driver.drive_core_thread" (List.lookup tid dr_st.core_state.Core_run.thread_states) in
          begin
            if debug_str <> "Eloc" then
            (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "tau(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
            (* DEBUG *)                   Pp.stringFromCore_expr pre_th_st.Core_run.arena ^ ";\nstack= " ^
            (* DEBUG *)                   Pp.stringFromCore_stack pre_th_st.Core_run.stack)
            else
              ND.return ()
          end >>
          (* case where the Core program does a non pure but non memory-related
             step (typically ordering related stuff) *)
          liftCore_run step_m >>= fun th_st' ->
          let () = Boot.end_timing () in (* DEBUG, PROFILING *)
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>
          drive_core_thread tid )
    | Core_run.Step_eval debug_str step_m ->
        ( "Step_eval(" ^ debug_str ^ ")"
        , let () = Debug.print_debug 4 [] (fun () -> "Step_eval(" ^ debug_str ^ ")") in
          let () = Boot.begin_timing ("eval: " ^ debug_str) in (* DEBUG, PROFILING *)
          let pre_th_st = (* DEBUG *)
            snd $ fromJust "Driver.drive_core_thread" (List.lookup tid dr_st.core_state.Core_run.thread_states) in
          (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "eval(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
          (* DEBUG *)                   Pp.stringFromCore_expr pre_th_st.Core_run.arena ^ ";\nstack= " ^
          (* DEBUG *)                   Pp.stringFromCore_stack pre_th_st.Core_run.stack) >>
          (* case where the Core program does a pure step *)
          liftCore_run step_m >>= fun th_st' ->
          let () = Boot.end_timing () in (* DEBUG, PROFILING *)
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>
          drive_core_thread tid )
    
    | Core_run.Step_thread_done parent_tid cval ->
        ( "Step_thread_done"
        , (* DEBUG *) ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "thread " ^ show tid ^ " is done") >>
          let actions_of_current_thread: set Cmm.action =
            Set.filter (fun act -> Cmm.tid_of act = tid) $ dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions in
          let last_actions_of_current_thread: set Cmm.action =
            Set.filter (fun act ->
              not (Set.any (fun (act', _) -> act = act') dr_st.concurrency_state.Cmm_op.symPre.Cmm.sb)
            ) actions_of_current_thread in
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.kill_thread tid parent_tid (Set.map Cmm.aid_of last_actions_of_current_thread) cval dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1;
          |>) >>
          drive_core_thread parent_tid )
    
    | Core_run.Step_blocked ->
        ("Step_blocked", ND.return ())
    | Core_run.Step_error debug_str ->
        error ("WIP: Step_error --> " ^ debug_str)
    (* NOTE: it clears the stack and add the value to the arena *)
    | Core_run.Step_done cval ->
        ( "Step_done"
        , ND.update (fun dr_st ->
            let core_st' = Core_run.update_thread_state tid
              <| Core_run_aux.arena= Core.Expr [] (Core.Epure (Core_aux.mk_value_pe cval));
                 Core_run_aux.stack= Core.Stack_empty;
                (* Dummy locations *)
                 Core_run_aux.exec_loc= Core_run_aux.ELoc_globals;
                 Core_run_aux.current_loc= Loc.unknown;
                 Core_run_aux.current_uid= Nothing;
              |> dr_st.core_state
            in
            <| dr_st with
              core_state= core_st';
              dr_step_counter= dr_st.dr_step_counter + 1;
            |>))

    | Core_run.Step_spawn_threads mk_th_st th_sts ->
        ( "Step_spawn_threads"
        , ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "Step_spawn_threads") >>
          let ((th_tids, core_st'), run_st') = State.run (
            State.foldlM (fun (th_tids_, core_st_) th_st ->
              State.bind (Core_run.spawn_thread (Just tid) th_st core_st_)
                (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
            ) ([], dr_st.core_state) th_sts
          ) dr_st.core_run_state in
          ND.update (fun dr_st -> <| dr_st with
            core_run_state= run_st';
            core_state= Core_run.update_thread_state tid
                          (mk_th_st (Core.Expr [] (Core.Eunseq $ List.reverse (List.map (fun z -> Core.Expr [] (Core.Ewait z)) th_tids))))
                          core_st';
          |>) >>
          ND.mapM_ drive_core_thread th_tids >>
          drive_core_thread tid )
    
    | Core_run.Step_snprintf s_ptrval n_ival frmt_chars args_ty_ptrvals mk_th_st ->
        ( "Step_snprintf"
        , liftMem (Output.snprintf (printf_eval_conv dr_st) s_ptrval n_ival frmt_chars args_ty_ptrvals) >>= function
            | Left err ->
                error "TODO(msg): a snprintf() got an error"
            | Right (Undefined.Defined n) ->
                ND.update (fun dr_st ->
                  let core_st' = Core_run.update_thread_state tid (mk_th_st n) dr_st.core_state in
                  <| dr_st with
                    core_state= core_st';
                    dr_step_counter= dr_st.dr_step_counter + 1;
                  |>
                ) >>
                drive_core_thread tid
            | Right (Undefined.Error loc str) ->
                ND.kill (ND.Error loc str)
            | Right (Undefined.Undef loc ubs) ->
                ND.kill (ND.Undef loc ubs)
          end )
    
    | Core_run.Step_sprintf s_ptrval frmt_chars args_ty_ptrvals mk_th_st ->
        ( "Step_sprintf"
        , liftMem (Output.sprintf (printf_eval_conv dr_st) s_ptrval frmt_chars args_ty_ptrvals) >>= function
            | Left err ->
                error "TODO(msg): a sprintf() got an error"
            | Right (Undefined.Defined n) ->
                ND.update (fun dr_st ->
                  let core_st' = Core_run.update_thread_state tid (mk_th_st n) dr_st.core_state in
                  <| dr_st with
                    core_state= core_st';
                    dr_step_counter= dr_st.dr_step_counter + 1;
                  |>
                ) >>
                drive_core_thread tid
            | Right (Undefined.Error loc str) ->
                ND.kill (ND.Error loc str)
            | Right (Undefined.Undef loc ubs) ->
                ND.kill (ND.Undef loc ubs)
          end )
    
    | Core_run.Step_printf2 frmt_chars args_ty_ptrvals mk_th_st ->
        ( "Step_printf2"
        , ND.print_debug 6 [Debug.DB_driver_step] (fun () -> "Step_printf2") >>
          (*let eval_conv (*ty1*) ty2 mval =
            let () = Debug.print_debug 1 [] (fun () -> "XX 24") in
            Core_eval.eval_pexpr Loc.unknown (Just dr_st.layout_state) dr_st.core_file (*dr_st.symbolic_assoc*) $
              (* Core.PEcall (Core.Sym conv_sym) *)
              Translation_aux.mk_stdcall dr_st.core_file.Core.stdlib "conv_loaded_int"
                [ Caux.mk_ctype_pe ty2
                ; let (_, cval) = Core_aux.valueFromMemValue mval in
                  Core.Pexpr [] () (Core.PEval cval) ] in *)
          liftMem (Output.printf (printf_eval_conv dr_st) frmt_chars args_ty_ptrvals) >>= fun out_chars_ ->
          match out_chars_ with
            | Left err ->
                error "TODO(msg): a printf() got an error"
            | Right (Undefined.Defined out_chars) ->
                ND.update (fun dr_st ->
                  let core_st' = Core_run.update_thread_state tid (mk_th_st (integerFromNat (List.length out_chars))) dr_st.core_state in
                  <| dr_st with
                    core_state= <| core_st' with
                      Core_run.io= <| dr_st.core_state.Core_run.io with Core_run.stdout=
                            Dlist.append (Dlist.singleton (String.toString out_chars)) dr_st.core_state.Core_run.io.Core_run.stdout
                          |>
                    |>;
                    dr_step_counter= dr_st.dr_step_counter + 1;
                  |>
                ) >>
                drive_core_thread tid
          | Right (Undefined.Error loc str) ->
              ND.kill (ND.Error loc str)
          | Right (Undefined.Undef loc ubs) ->
              ND.kill (ND.Undef loc ubs)
        end )

    | Core_run.Step_bound step_m ->
        ( "Step_bound"
        , liftCore_run step_m >>= fun th_st' ->
          ND.update (fun dr_st -> <| dr_st with
            core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
            dr_step_counter= dr_st.dr_step_counter + 1
          |>) >>
          drive_core_thread tid )

  end) (Core_run.core_thread_step2 dr_st.layout_state dr_st.core_file dr_st.symbolic_assoc tid th_info)
















(* perform drive_core_thread for all the core threads *)
val     drive_core_threads: unit -> driverM unit
let rec drive_core_threads () =
  ND.get >>= fun dr_st ->
  ND.mapM_ (fun (tid, _) ->
    ND.print_debug 9 [Debug.DB_driver] (fun () -> "BEFORE drive_core_thread, in drive_core_threads") >>
    drive_core_thread tid
  ) dr_st.core_state.Core_run.thread_states




let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with Cmm.asw=
      Set.filter (fun (a,c) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.Cmm.sb

&& Relation.inRel b c preEx.Cmm.asw

) preEx.Cmm.actions
        )
      ) preEx.Cmm.asw


|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with Cmm_op.symPre= repair dr_st.concurrency_state.Cmm_op.symPre |>
  |>



val update_core_state: Core_run.core_state -> driver_state -> driver_state
let update_core_state core_st dr_st =
  <| dr_st with core_state= core_st |>

val update_core_run_state: Core_run.core_run_state -> driver_state -> driver_state
let update_core_run_state run_st dr_st =
  <| dr_st with core_run_state= run_st |>




(* ========================================================================== *)


val action_request_concurrency: Core_run.action_request -> driverM unit
let action_request_concurrency = function
  | Core_run.AllocRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST ALLOC") in (* DEBUG *)
      (* TODO: hack, hack, hack *)
      ND.log ("ALLOC REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      liftMem (Mem.allocate_dynamic tid pref align_ival size_ival) >>= fun ptrval ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state) dr_st
      )
  
  | Core_run.CreateRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty init_opt mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST CREATE") in (* DEBUG *)
      (* TODO: hack, hack, hack *)
      ND.log ("CREATE REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      liftMem (Mem.allocate_static tid pref align_ival lvalue_ty init_opt) >>= fun ptrval ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state) dr_st
      )
  
  | Core_run.StoreRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty is_locking ptr_val mem_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "CONCUR REQUEST STORE") in (* DEBUG *)
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Store aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.log ("STORE REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
          trace= "store" :: dr_st.trace
        |>
      )
  
  | Core_run.LoadRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val sym mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "CONCUR REQUEST LOAD") in (* DEBUG *)
(*      let mval = Mem.symbolic_mval (Symbolic.SYMBsym Symbolic.SYMBint sym) in *)
      let ity = match lvalue_ty with
        | Core_ctype.Basic (AilTypes.Integer ity) ->
            ity
        | _ ->
            AilTypes.Signed (AilTypes.Int_) (* TODO DUMMY *)
      end in
      let mval = Mem.integer_value_mval ity (Mem.concurRead_ival ity sym) in
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Load aid tid mo ptr_val mval;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.log ("LOAD REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid (mk_th_st' mval) dr_st.core_state;
          concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
          trace= "store" :: dr_st.trace
        |>
      )
  
  | Core_run.FenceRequest loc sb_edges dd_edges asw_edges aid tid mo th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "CONCUR REQUEST FENCE") in (* DEBUG *)
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Fence aid tid mo;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Nothing;
      |> in
      ND.log ("FENCE REQUEST (aid: " ^ show aid ^ ")") >> (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
          trace=             "fence" :: dr_st.trace
        |>
      )
  
  | Core_run.RMWRequest loc sb_edges dd_edges asw_edges aid tid mo1 mo2 lvalue_ty ptr_val mval_expected mval_actual th_st' ->
(*
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.RMW aid tid mo ptr_val mval;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.return <| dr_st with
        core_state= update_thread_state tid (mk_th_st' mval) dr_st.core_state;
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "rmw" :: dr_st.trace
      |>
*)
      error "WIP: Driver ==> RMWRequest"

  | Core_run.KillRequest loc sb_edges dd_edges asw_edges aid tid is_dynamic ptr_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST KILL") in (* DEBUG *)
      ND.update (fun dr_st ->
        <| dr_st with
          core_state= Core_run.update_thread_state tid th_st' dr_st.core_state;
          (* TODO: the kill ... *)
        |>
      )
end




(* This version only uses the memory layout model (note that is deterministic) *)
val action_request_sequential: Core_run.action_request -> driverM unit
let action_request_sequential = function
  | Core_run.AllocRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST ALLOC") in (* DEBUG *)
      liftMem (Mem.allocate_dynamic tid pref align_ival size_ival) >>= fun ptrval ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state) dr_st
      )
  
  | Core_run.CreateRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty init_opt mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST CREATE") in (* DEBUG *)
      liftMem (Mem.allocate_static tid pref align_ival lvalue_ty init_opt) >>= fun ptrval ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' ptrval) dr_st.core_state) dr_st
      )
  
  | Core_run.LoadRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val _ mk_th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST LOAD") in (* DEBUG *)
      liftMem (Mem.load loc lvalue_ty ptr_val) >>= fun (fp, mval) ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid (mk_th_st' mval) dr_st.core_state) dr_st
      )
  
  | Core_run.StoreRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty is_locking ptr_val mem_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST STORE") in (* DEBUG *)
      (* TODO: need to make memory layout detect unsequenced races (use to make
         the concurency to the check even in the sequential mode) *)
      liftMem (Mem.store loc lvalue_ty is_locking ptr_val mem_val) >>= fun fp ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      )
  
  | Core_run.RMWRequest loc sb_edges dd_edges asw_edges aid tid mo1 mo2 lvalue_ty ptr_val mval_expected mval_actual th_st' ->
      error "WIP: Driver.seq ==> RMWRequest"
  
  | Core_run.FenceRequest loc sb_edges dd_edges asw_edges aid tid mo th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST FENCE") in (* DEBUG *)
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      )
  
  | Core_run.KillRequest loc sb_edges dd_edges asw_edges aid tid is_dynamic ptr_val th_st' ->
      let () = Debug.print_debug_located 3 [Debug.DB_driver] loc (fun () -> "REQUEST KILL") in (* DEBUG *)
      liftMem (Mem.kill loc is_dynamic ptr_val) >>
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      )
end




val perform_action_request: bool -> Core_run.core_runM Core_run.action_request -> driverM unit
let perform_action_request with_concurrency request_m =
  (* DEBUG *) ND.print_debug 9 [Debug.DB_driver] (fun () -> "Step_action_request") >>
  liftCore_run request_m >>= fun request ->
  
  let execution_mode_is_random = match Global.current_execution_mode () with
    | Nothing   -> false
    | Just mode -> mode = Global.Random
  end in
  
  begin
    if with_concurrency then
      action_request_concurrency request >>
      if execution_mode_is_random then
        ND.get >>= fun dr_st ->
        let total = number_of_uncommitted dr_st.concurrency_state in
        let choices = Enum.enumFromTo 0 total in
        
        (* DEBUG *)
        let _ = if choices = [] then error "BOOM" else () in
        
        ND.pick "driver 1" choices >>= fun n ->
        ND.warns_if_no_active_ex (stepConcurrency n)
      else
        ND.return ()
    else
      action_request_sequential request
  end 


val     driver: bool -> driverM unit
let rec driver with_concurrency =
  let process_core_step2 = function
  | Core_run.Step_action_request _ request_m ->
      perform_action_request with_concurrency request_m >>
      driver with_concurrency
  | Core_run.Step_memop_request memop cvals tid mk_th_st ->
      match (memop, cvals) with
        | (Mem_common.Ptrdiff, [Core.Vctype ty; Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.diff_ptrval ty ptr_val1 ptr_val2) >>= fun ival ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger ival)))
        
        | (Mem_common.IntFromPtr, [Core.Vctype ref_ty; Core.Vctype (Core_ctype.Basic (AilTypes.Integer ity)); Core.Vobject (Core.OVpointer ptr_val)]) ->
            liftMem (Mem.intcast_ptrval ref_ty ity ptr_val) >>= fun ival ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger ival)))
        
        | (Mem_common.PtrFromInt, [Core.Vctype ty; Core.Vctype ref_ty; Core.Vobject (Core.OVinteger ival)]) ->
            liftMem (Mem.ptrcast_ival ty ref_ty ival) >>= fun ptrval ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer ptrval)))
        
        | (Mem_common.PtrValidForDeref, [Core.Vobject (Core.OVpointer ptr_val)]) ->
            (* NOTE: this is pure *)
            ND.return (mk_th_st (if Mem.validForDeref_ptrval ptr_val then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrEq, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            ND.print_debug 2 [Debug.DB_driver] (fun () -> "PtrEq") >> (* DEBUG *)
            liftMem (Mem.eq_ptrval ptr_val1 ptr_val2) >>= fun is_eq ->
            ND.return (mk_th_st (if is_eq then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrNe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.ne_ptrval ptr_val1 ptr_val2) >>= fun is_ne ->
            ND.return (mk_th_st (if is_ne then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrLt, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.lt_ptrval ptr_val1 ptr_val2) >>= fun is_lt ->
            ND.return (mk_th_st (if is_lt then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrGt, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.gt_ptrval ptr_val1 ptr_val2) >>= fun is_gt ->
            ND.return (mk_th_st (if is_gt then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrLe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.le_ptrval ptr_val1 ptr_val2) >>= fun is_le ->
            ND.return (mk_th_st (if is_le then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.PtrGe, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2)]) ->
            liftMem (Mem.ge_ptrval ptr_val1 ptr_val2) >>= fun is_ge ->
            ND.return (mk_th_st (if is_ge then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.Memcpy, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2);
                               Core.Vobject (Core.OVinteger size_ival)]) ->
            liftMem (Mem.memcpy ptr_val1 ptr_val2 size_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))
        
        | (Mem_common.Memcmp, [Core.Vobject (Core.OVpointer ptr_val1); Core.Vobject (Core.OVpointer ptr_val2);
                               Core.Vobject (Core.OVinteger size_ival)]) ->
            liftMem (Mem.memcmp ptr_val1 ptr_val2 size_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVinteger res)))
        
        | (Mem_common.PtrWellAligned, [Core.Vctype ref_ty; Core.Vobject (Core.OVpointer ptrval)]) ->
            liftMem (Mem.isWellAligned_ptrval ref_ty ptrval) >>= fun b ->
            ND.return (mk_th_st (if b then Core.Vtrue else Core.Vfalse))
        
        | (Mem_common.Realloc, [Core.Vobject (Core.OVinteger align_ival); Core.Vobject (Core.OVpointer old_ptr);
                               Core.Vobject (Core.OVinteger size_ival)]) ->
            liftMem (Mem.realloc tid align_ival old_ptr size_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

        | (Mem_common.PtrArrayShift, [Core.Vobject (Core.OVpointer ptrval); Core.Vctype ty; Core.Vobject (Core.OVinteger n_ival)]) ->
            liftMem (Mem.eff_array_shift_ptrval ptrval ty n_ival) >>= fun res ->
            ND.return (mk_th_st (Core.Vobject (Core.OVpointer res)))

        | _ ->
            error ("WIP memop request: " ^ show memop ^ " ==> " ^ Pp.stringFromCore_value (Core.Vtuple cvals) )
      end >>= fun th_st' ->
      ND.update (fun dr_st ->
        update_core_state (Core_run.update_thread_state tid th_st' dr_st.core_state) dr_st
      ) >>
      driver with_concurrency

  | Core_run.Step_tau debug_str _ ->
      error ("FOUND A TAU: '" ^ debug_str ^ "'")
  | Core_run.Step_eval debug_str _ ->
      error ("FOUND AN EVAL: '" ^ debug_str ^ "'")

(*
  | Step_thread_done of thread_id * Core.value
  | Step_blocked
  | Step_error of string
  | Step_branch of (* DEBUG *) string * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM thread_state * core_runM thread_state
*)
  | Core_run.Step_done cval ->
      ND.print_debug 3 [Debug.DB_driver] (fun () -> "driver.process_core_step ==> Step_done with value: " ^ Pp.stringFromCore_value cval) >> (* DEBUG *)
      ND.return ()
(*
  | Step_spawn_threads of list thread_state (* initial states for the children *)
*)
  | _ ->
      error "Driver.driver, wrong Step_"
  end in

(*  ND.collapse $ *) (* TODO: need to write lots of Eq instances for this to work ... *)
  drive_core_threads () >>
  ND.get >>= fun post_core_dr_st ->
  
    (* TODO: hackish *)
    let non_blocked_th_sts = List.filter (fun (tid, th_info) ->
      List.any (fun step -> step <> Core_run.Step_blocked) $ Core_run.core_thread_step2 post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.symbolic_assoc tid th_info
    ) post_core_dr_st.core_state.Core_run.thread_states in
  
  (if Global.current_execution_mode () = Just Global.Random then
    (* HACK The problem is that some threads are blocked (they wait
       for other threads to finish. If we randomly pick that thread to
       execute, there will not be any steps to execute, and the whole
       execution comes to a halt. To properly solve this, we need to
       implement back tracking. Since we haven't, we temporarily
       switch to exhaustive mode and also compute the steps of the
       other threads. *)
    
    ND.print_debug 6 [Debug.DB_driver] (fun () -> "FIRST: " ^ show (List.length post_core_dr_st.core_state.Core_run.thread_states) ^ " vs " ^ show (List.length non_blocked_th_sts)) >>
    ND.bindExhaustive (ND.pick "driver 2" (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts)
                      (fun (tid, th_info) ->
(* OLD                       ND.return $ core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state) *)
                       ND.pick "driver 3" $ Core_run.core_thread_step2 post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.symbolic_assoc tid th_info)
    

   else
    ND.print_debug 6 [Debug.DB_driver] (fun () -> "SECOND") >>
(*
     ND.pick (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts >>= fun th_info ->
     ND.return (core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state)
*)
    ND.pick "driver 4" non_blocked_th_sts >>= fun (tid, th_info) ->
    ND.pick "driver 5" (Core_run.core_thread_step2 post_core_dr_st.layout_state post_core_dr_st.core_file post_core_dr_st.symbolic_assoc tid th_info)
  ) >>=
      process_core_step2 (*post_core_dr_st*)







val     hack: list (map Symbol.sym Core.value) -> Mem.mem_state -> Core.file Core_run.core_run_annotation -> map Symbol.sym Core.object_value -> Core.pexpr -> Core.value
let rec hack env mem_st core_file concur_sym_map pexpr =
  let () = Debug.print_debug 1 [] (fun () -> "XX 25") in
  match Core_eval.step_eval_pexpr 0 (Loc.other "Driver.hack") env (Just mem_st) core_file false pexpr with
    | Exception.Result (Undefined.Defined pexpr') ->
        match Core_aux.valueFromPexpr pexpr' with
          | Just cval ->
              cval
          | Nothing ->
              hack env mem_st core_file concur_sym_map pexpr'
        end
    | _ ->
        error ("Driver.hack, UNDEF/ERROR:" ^ Pp.stringFromCore_pexpr pexpr)
(*
    | _ ->
        (* TODO: this is wrong *)
        expr
*)
end

(*

let finalize_constraints mem_st core_file concur_sym_map (Constraints.Constraints symbs) =
  Constraints.Constraints $ List.map (function
    | Symbolic.SYMBop op symb1 symb2 ->
        error "WIP Driver.finalize_constraints"
*)
(*

(*
        let Just symb1' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb1))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
        let Just symb2' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb2))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
*)
        match (hack mem_st core_file concur_sym_map (Core.PEval (Core.Vobject (Core.OVsymbolic symb1))),
               hack mem_st core_file concur_sym_map (Core.PEval (Core.Vobject (Core.OVsymbolic symb2)))) with
          | (Core.Vobject (Core.OVsymbolic symb1'), Core.Vobject (Core.OVsymbolic symb2')) ->
   let _ = Boot.print_debug 2 ("finalize_constr ==> " ^ stringFromSymbolic symb1 ^ " <-> " ^ stringFromSymbolic symb2) in
              Symbolic.SYMBop op symb1' symb2'
          | (Core.Vobject (Core.OVsymbolic symb1'), Core.Vobject oval2') ->
              Symbolic.SYMBop op symb1' (Symbolic.SYMBconst oval2')
          | (cval1, cval2) ->
              error ("Driver.finalize_constraints ==> " ^ stringFromValue cval1 ^ " <-> " ^ stringFromValue cval2)
        end
    | symb ->
        symb
  end) symbs
*)


type driver_result = <|
  dres_blocked: bool;
  dres_concurrency_state: Cmm_op.symState;
  dres_driver_steps: nat;
  dres_core_value: Core.value;
  dres_stdout: string;
|>


val finalize: string -> driver_state -> driver_result (* (string * (bool * Cmm_op.symState * Core.value) * (nat * nat)) *)
let finalize debug_str dr_st =
  match dr_st.core_state.Core_run.thread_states with
    | [(tid, (_, th_st))] ->
        let cval = hack dr_st.core_run_state.Core_run.env dr_st.layout_state dr_st.core_file dr_st.symbolic_assoc
            match Core_aux.to_pure th_st.Core_run.arena with
(*
              | Just (Core.PEval (Core.Vinteger ival)) ->
                  let Just symb = Mem_aux.symbolicFromIntegerValue ival in
                  Core_aux.unsymbolify symb
*)
              | Just pe ->
                  pe
              | Nothing ->
                  error ("Driver.finalize: the arena wasn't pure ==> " ^ Pp.stringFromCore_expr th_st.Core_run.arena)
            end in
        <|
          dres_blocked= dr_st.blocked;
          dres_concurrency_state= dr_st.concurrency_state;
          dres_driver_steps= dr_st.dr_step_counter;
          dres_core_value= cval;
          dres_stdout= List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.Core_run.io.Core_run.stdout);
        |>
    | xs ->
        let () = Debug.print_debug 3 [Debug.DB_driver] (fun () -> "ERROR (end of the Driver)\n" ^ stringFromCore_core_state dr_st.core_state) in (* DEBUG *)
        error ("BOOM finalize [" ^ debug_str ^ "]")
  end








(* TODO: it is problematic for proofy backend that this function may diverge *)
(* TODO: HACK *)
let initial_driver_state sym_supply file =
(*
  let mk_dr_st core_st run_st = <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    concurrency_state= initialExeState emptyPreEx;
    
    (* TODO: uber hack *)
    sequential_state= Map.empty;
    blocked= false;
    trace= [];
  |> in
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          error "failed to build initial driver state"
    end in
  mk_dr_st core_st run_st
*)
  <|
    symbol_supply=     sym_supply;
    core_file=         file;
    core_state=        Core_run.initial_core_state;
    core_run_state=    Core_run.initial_core_run_state (Caux.collect_labeled_continuations_NEW file);
    layout_state=      Mem.initial_mem_state;
    concurrency_state= Cmm_op.symInitialState Cmm_op.symInitialPre;


  symbolic_assoc= Map.empty;
    (* TODO: uber hack *)
(*    sequential_state= Map.empty; *)
    blocked= false;
    trace= [];
    
    dr_step_counter= 0;
  |>




val spawn_thread: maybe Cthread.thread_id -> Core_run.thread_state -> driverM Cthread.thread_id
let driver_spawn_thread parent_tid_opt th_st =
  ND.get >>= fun dr_st ->
  let ((tid, core_st'), run_st') = State.run (
    Core_run.spawn_thread parent_tid_opt th_st dr_st.core_state
  ) dr_st.core_run_state in
  ND.update (fun dr_st -> <| dr_st with
    core_state= core_st';
    core_run_state= run_st';
  |>) >>
  ND.return tid
let inline spawn_thread = driver_spawn_thread

val update_thread_state: Cthread.thread_id -> Core_run.thread_state -> driverM unit
let driver_update_thread_state tid th_st =
  ND.update (fun dr_st ->
    <| dr_st with core_state= Core_run.update_thread_state tid th_st dr_st.core_state |>
  )
let inline update_thread_state = driver_update_thread_state

val get_thread_states: driverM (list (Cthread.thread_id * (maybe Cthread.thread_id * Core_run.thread_state)))
let get_thread_states =
  ND.get >>= fun dr_st ->
  ND.return dr_st.core_state.Core_run.thread_states


val driver_globals: bool -> UniqueId.supply Symbol.sym -> Core.file Core_run.core_run_annotation -> driverM Cthread.thread_id
let driver_globals with_concurrency sym_supply file =
  (* spawning a thread for the initialisation of globals, and later the execution of main *)
  spawn_thread Nothing <|
    (* NOTE: the Eskip is just a placeholder, the thread is given its actual state later *)
    Core_run.arena=  Core.Expr [] Core.Eskip;
    Core_run.stack=  Core_aux.push_empty_continuation Nothing Core_aux.empty_stack;
    Core_run.current_loc= Loc.unknown;
    Core_run.current_uid= Nothing;
    Core_run.exec_loc= Core_run.ELoc_globals;
  |> >>= fun tid0 ->
  
  ND.read (fun dr_st ->
    dr_st.core_file.Core.globs
  ) >>= fun globs ->
  
  ND.mapM_ (fun (glob_sym, glob_bTy, expr) ->
    let () = Debug.print_debug 6 [Debug.DB_driver] (fun () ->      (* DEBUG *)
      "Starting the evaluation of global `" ^ show glob_sym ^ "'"  (* DEBUG *)
    ) in                                                           (* DEBUG *)
    (* setting up the initialisation of the current global in thread 0 *)
    update_thread_state tid0 <|
      (* the previously evaluated globals are substituted in the body of the
         global we are about to evaluate *)
      Core_run.arena= expr;
      Core_run.stack= Core_aux.push_empty_continuation Nothing Core_aux.empty_stack;
(*      Core_run.labels= Map.empty; *)
      Core_run.current_loc= Loc.other ("global(" ^ show glob_sym ^ ")"); (* TODO: preserve locations in Core.globs *)
      Core_run.current_uid= Nothing;
      Core_run.exec_loc= Core_run.ELoc_globals;
    |> >>= fun () ->
    
    (* evaluation of the initialisation *)
    driver with_concurrency >>= fun () ->
    
    get_thread_states >>= function
      | [(_, (_, th_st))] ->
          (* TODO: technically the arena should always be a value at this point *)
          match Core_aux.to_pure th_st.Core_run.arena with
            | Just pe ->
                match Core_aux.valueFromPexpr pe with
                  | Nothing ->
                      error "WIP: driver_globals"
                  | Just cval ->
                      ND.update (fun dr_st ->
                        <| dr_st with
                          core_run_state=
                            <| dr_st.core_run_state with Core_run.env= Core_aux.update_env (Core.Pattern [] (Core.CaseBase (Just (glob_sym), glob_bTy))) cval dr_st.core_run_state.Core_run.env |>
                        |>
                     )
                end
            | Nothing ->
                error "TODO(msg): Driver.driver_globals, the end of the evaluation of a glob didn't produce a value"
          end
      | _ ->
          error "ERROR (in Driver, global init didn't evaluate to value)"
    end
  ) globs >>
  ND.return tid0



val pp_exeState: Cmm_op.symState -> string
declare ocaml target_rep function pp_exeState = `Pp_cmm.pp_execState`

(*
let rec process_integer_value_base sym_assoc = function
  | (IVconcurRead _ sym as ival_) ->
      match Map.lookup sym sym_assoc with
        | Just (Core.OVinteger (IV _ ival_)) ->
            process_integer_value_base sym_assoc ival_
        | Nothing ->
            ival_
      end
  | IVop iop ivals_ ->
      IVop iop (List.map (process_integer_value_base sym_assoc) ivals_)
  | ival_ ->
      (* WIP *)
      ival_
end


(* TODO: move somewhere else, and do it nicer *)
let rec process_objet_value sym_assoc = function
  | (Core.Vobject (Core.OVinteger (IV prov ival_)) as cval) ->
      let ival_' =
        Defacto_memory_aux2.lifted_simplify_integer_value_base (process_integer_value_base sym_assoc ival_) in
      Core.Vobject (Core.OVinteger (IV prov ival_'))
  | (Core.Vloaded (Core.LVspecified (Core.OVinteger (IV prov ival_))) as cval) ->
      let ival_' =
        Defacto_memory_aux2.lifted_simplify_integer_value_base (process_integer_value_base sym_assoc ival_) in
      Core.Vloaded (Core.LVspecified (Core.OVinteger (IV prov ival_')))
(*
  | (Core.Vobject (Core.OVinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVconcurRead _ sym))) as cval) ->
      match Map.lookup sym sym_assoc with
        | Just oval ->
            process_objet_value sym_assoc (Core.Vobject oval)
        | Nothing ->
            cval
      end
  | (Core.Vspecified (Core.OVinteger (Defacto_memory_types.IV _ (Defacto_memory_types.IVconcurRead _ sym))) as cval) ->
      match Map.lookup sym sym_assoc with
        | Just oval ->
            process_objet_value sym_assoc (Core.Vspecified oval)
        | Nothing ->
            cval
      end
*)
  | cval ->
      cval
end
*)



val drive: bool -> bool -> UniqueId.supply Symbol.sym -> Core.file Core_run.core_run_annotation -> list string ->
           driverM driver_result
let drive (with_concurrency: bool) (use_experimental_unseq: bool) sym_supply file (arg_strs: list string) =
  (* Setting the read-only tag definitions (used by the memory model) *)
(*
TODO: this should be removable, since we already set it in Translation
  let () = Core_ctype_aux.set_tagDefs file.Core.tagDefs in
*)
  (* first we execute the body of global definitions and remove their symbols
     from the rest of the program *)
  driver_globals with_concurrency sym_supply file >>= fun tid0 (*, post_globals_dr_st) *) ->
  ND.get >>= fun post_globals_dr_st ->
  
  (* we need a startup function to have been declared *)
  match post_globals_dr_st.core_file.Core.main with
    | Just sym ->
        ND.return sym
    | Nothing ->
        ND.kill (ND.Other (DErr_other "no startup function was declared"))
  end >>= fun main_sym ->
  
  (* setting the arena of thread 0 to the body of the main function *)
  match Map.lookup main_sym post_globals_dr_st.core_file.Core.funs with
    | Nothing ->
        ND.kill (ND.Other (DErr_other "couldn't find the startup function"))
    
    | Just decl ->
        match decl with
          | Core.Fun  _ params pe ->
              ND.return (params, Core.Expr [] (Core.Epure pe))
          | Core.ProcDecl _ _ _ ->
              ND.kill (ND.Other (DErr_other "the startup function has no definition"))
          | Core.Proc _ _ params e ->
              ND.return (params, e)
        end >>= fun (params, expr) ->
        
        match params with
          | [(argc_sym, _); (argv_sym, _)] ->
              (* memory_values to be stored in memory objects pointed to by
                 the element of main.argv  *)
              let args_mem_val_tys =
                List.map (fun arg_str ->
                  let mem_vals =
                    List.map (fun c ->
                      (* TODO: fixing impl choice here (ASCII) *)
                      Mem.integer_mval AilTypes.Char $ Decode.decode_character_constant (String.toString [c])
                    ) (String.toCharList arg_str) in
                  (* NOTE: adding a null termination to the char array *)
                  (
                    Mem.array_mval $ mem_vals ++ [Mem.integer_mval AilTypes.Char 0],
                    Core_ctype.Array Core_ctype.char (Just $ (integerFromNat $ List.length mem_vals) + 1)
                  )
                ) arg_strs in
              
              (* memory value to be stored in the memory object pointed to by main.argc *)
              let argc_mem_val = Mem.integer_mval (AilTypes.Signed AilTypes.Int_) (integerFromNat $ List.length args_mem_val_tys) in
              
              (* allocating and initialising an object for main.argc *)
              liftMem (
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource [main_sym; argc_sym])
                            (Mem.alignof_ival Core_ctype.signed_int) Core_ctype.signed_int Nothing) (fun ptr_val ->
                  Mem.bind (Mem.store (Loc.other "argc init") Core_ctype.signed_int false ptr_val argc_mem_val) (fun _ ->
                    Mem.return ptr_val
                  )
                )
              ) >>= fun argc_ptr_val ->
              
              (* allocating and initialising the objects pointed to by the elements of argv *)
              ND.foldlM (fun ptr_vals (arg_mem_val, arg_ty) ->
                liftMem (
                  Mem.bind (Mem.allocate_static tid0 (Symbol.PrefOther "argv refs") (Mem.alignof_ival arg_ty) arg_ty Nothing) (fun ptr_val ->
                    Mem.bind (Mem.store (Loc.other "argv refs init") arg_ty false ptr_val arg_mem_val) (fun _ ->
                      Mem.return (ptr_val :: ptr_vals)
                    )
                  )
                )
              ) [] args_mem_val_tys >>= fun ptr_vals_rev ->
              
              (* allocating and initialising an object for main.argv *)
              (* NOTE: the element argv[argc] is required to be a null pointer
                 by the STD, hence argv has one more element than the number
                 of supplied arguments *)
              let argv_array_elem_ty = Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char in
              let argv_array_ty = Core_ctype.Array argv_array_elem_ty (Just (1 + (integerFromNat $ List.length ptr_vals_rev))) in
              let argv_array_mem_val = Mem.array_mval $
                List.map (Mem.pointer_mval Core_ctype.char) (List.reverse ptr_vals_rev ++ [Mem.null_ptrval Core_ctype.char]) in
              liftMem (
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource [main_sym; argv_sym(*TODO: change the sym?*)])
                            (Mem.alignof_ival argv_array_ty) argv_array_ty Nothing) (fun array_ptr_val ->
                Mem.bind (Mem.store (Loc.other "argv array init") argv_array_ty false array_ptr_val argv_array_mem_val) (fun _ ->
                
                (* NOTE: because of argument promotions, the char *argv[] is turned into a char **argv
                   so two objects are allocated: an array and a pointer to that array (which is what argv designate) *)
                let argv_ty = Core_ctype.Pointer AilTypes.no_qualifiers (Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char) in
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource [main_sym; argv_sym])
                            (Mem.alignof_ival argv_ty) argv_ty Nothing) (fun argv_ptr_val ->
                Mem.bind (Mem.store (Loc.other "argv init") argv_ty false argv_ptr_val
                            (Mem.pointer_mval (Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char) array_ptr_val)) ( fun _ ->

                Mem.return argv_ptr_val
                ))))
              ) >>= fun argv_ptr_val ->
              
              ND.return $
                Core_aux.subst_pattern_val
                  (Caux.mk_tuple_pat [ Caux.mk_sym_pat argc_sym (Core.BTy_object Core.OTy_pointer)
                                     ; Caux.mk_sym_pat argv_sym (Core.BTy_object Core.OTy_pointer) ])
                  (Core.Vtuple [Core.Vobject (Core.OVpointer argc_ptr_val); Core.Vobject (Core.OVpointer argv_ptr_val)])
(*                  (Core.Etuple [Core.Econst $ Mem.mk_pointer argc_ptr_val; Core.Econst $ Mem.mk_pointer argv_ptr_val]) *)
                  expr
          | _ ->
              ND.return expr
        end >>= fun expr ->
        update_thread_state tid0 <|
          Core_run.arena=  expr;
          Core_run.stack= Core_aux.push_empty_continuation (Just main_sym) Core_aux.empty_stack;
          Core_run.current_loc= Loc.other "Driver.drive";
          Core_run.current_uid= Nothing;
          Core_run.exec_loc= Core_run.ELoc_normal [main_sym];
        |> >>
        driver with_concurrency >>
        
        if with_concurrency then
          error "CONCURRENCY IS BROKEN"
(*
          let dr_st' = repair_pre_execution dr_st' in
          let n     = number_of_uncommitted dr_st'.concurrency_state in
          ND.log ("Calling concurrency " ^ show n ^ " times\n") >> (* DEBUG *)
          ND.apply_to_constraints (finalize_constraints dr_st'.layout_state dr_st'.core_file dr_st'.symbolic_assoc) (stepConcurrency n dr_st') >>= fun dr_st' ->
          (* TODO: tmp *)
          ND.log ("UNCOMMITED ==> " ^ show (number_of_uncommitted dr_st'.concurrency_state)) >> (* DEBUG *)
            (* TODO: the current function should return a Core.value inside an
               undef/error monad. Not a Core.pexpr like we currently do *)
            match dr_st'.concurrency_state.Cmm_op.symUndefinedness with
              | [] ->
                  let (str, (is_blocked, conc_st, cval), steps) = finalize "drive (with concur)" dr_st' in
                  ND.print_debug 2 [Debug.DB_driver] (fun () -> "FINAL VALUE IS " ^ Pp.stringFromCore_value cval) >>
                  ND.print_debug 2 [Debug.DB_driver] (fun () -> "BEGIN SYMBOLIC ASSOC") >>
                  let _ = Map.mapi (fun sym oval ->
                    Debug.print_debug 2 [Debug.DB_driver] (fun () -> show sym ^ " == " ^ Pp.stringFromCore_value (Core.Vobject oval))
                  ) dr_st'.symbolic_assoc in
                  
                  let cval = process_objet_value dr_st'.symbolic_assoc cval in
                  ND.print_debug 2 [Debug.DB_driver] (fun () -> "CLEANED FINAL VALUE IS " ^ Pp.stringFromCore_value cval) >>
                  
                  
                  ND.return (str, (is_blocked, conc_st, Core.Pexpr [] () (Core.PEval cval)), steps)
              | (Cmm.DataRaces _)::_ ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe U.UB005_data_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.UnsequencedRaces _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe U.UB035_unsequenced_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.IndeterminateReads _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe (U.DUMMY "Driver.drive -- Cmm.IndeterminateReads")),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.BadMutexes _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe (U.DUMMY "Driver.drive -- Cmm.BadMutexes")),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | Cmm.NotInSublanguage::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st'.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Caux.mk_undef_pe (U.DUMMY "Driver.drive -- Cmm.NotInSublanguage")),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
            end
*)
        else
          ND.get >>= fun dr_st' ->
          ND.return (finalize "drive (without concur)" dr_st')
end
