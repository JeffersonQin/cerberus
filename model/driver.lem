open import Pervasives

import Core Core_ctype Boot UniqueId Decode
open import Show Core_run Core_run_aux ExecutableOpsem Cmm_master

import Enum State_exception_undefined Exception Undefined Nondeterminism Dlist

import Map_extra (* DEBUG *)

import Naive_memory

module Mem = Naive_memory


(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism

(* BEGIN HACK *)

(*
type sequential_state =
  map Mem.pointer_value (maybe Mem.mem_value)


(* TODO: DEBUG *)
let string_of_sequential_state xs =
  "state{" ^ 
  List.foldl (fun acc (ptr_val, mem_val_opt) ->
    Mem.string_of_pointer_value ptr_val ^ " := " ^
    match mem_val_opt with
      | Just mem_val ->
          Mem.string_of_mem_value mem_val
      | Nothing ->
          "uninitialized"
    end
  ) "" (Map_extra.toList xs)
  ^ "}"
*)


(* END HACK *)



type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  concurrency_state: exeState; (* state of the concurrency memory model *)
  
(* sequential_state: sequential_state; *)
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  trace: list string;
|>





(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. (* SetType 'a => *) core_runM 'a -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)
    
    | Exception.Result (U.Undef ubs, _) ->
        ND.kill (ND.Undef ubs)
    
    | Exception.Result (U.Error str, _) ->
        ND.kill (ND.Error str)
    
    | Exception.Exception err ->
        ND.kill (ND.Other $ "WIP Driver.runCore: runtime error ==> " ^ show err)
  end


open ND.Operators




(* TODO: debug *)
val pp_core_state: forall 'a. core_state -> string
declare ocaml target_rep function pp_core_state = `Pp_core_run.string_of_core_state`






(* perform all possible step that are not action requests *)
val     drive_core_thread: Thread.thread_id -> driver_state -> ND.t driver_state
let rec drive_core_thread tid dr_st =
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        (tid, z)
    | _ ->
        Boot.assert_false "drive_core_thread, wrong tid"
  end in
  
(*  ND.log $ "DRIVE_CORE_THREAD (" ^ string_of_natural (naturalFromNat tid) ^ "):\n" ^ pp_core_state dr_st.core_state ^ "\n" >> *)
  core_thread_step dr_st.core_file th_info dr_st.core_state >>= function
    | Step_tau "end of thread" _ step_m ->
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        ND.return <| dr_st' with core_state= core_st' |>
    
    | Step_tau debug_str _ step_m ->
(*        let _ = Boot.output_string ("Found a tau ===> " ^ debug_str) in *)
        (* case where the Core program does a non pure but non memory-related
           step (typically ordering related stuff) *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | Step_eval debug_str _ step_m ->
        let _ = Boot.output_string ("Step_val: " ^ debug_str) in
        (* case where the Core program does a pure step *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | _ ->
        ND.return dr_st
  end

val     drive_core: driver_state -> ND.t driver_state
let rec drive_core dr_st =
  ND.foldM (fun acc (tid, _) ->
    ND.tryM (drive_core_thread tid acc)
      ND.return
      (fun () -> ND.return acc)
  ) dr_st dr_st.core_state.thread_states




let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with asw=
      Set.filter (fun (a,_) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.sb) preEx.actions
        )
      ) preEx.asw

|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with preEx= repair dr_st.concurrency_state.preEx |>
  |>



val update_core_state: core_state -> driver_state -> driver_state
let update_core_state core_st dr_st =
  <| dr_st with core_state= core_st |>

val update_core_run_state: core_run_state -> driver_state -> driver_state
let update_core_run_state run_st dr_st =
  <| dr_st with core_run_state= run_st |>




(* ========================================================================== *)

(*
val     driver_sequential: driver_state -> ND.t (bool * Cmm_master.pre_execution * Core.expr core_run_annotation)
*)
val     driver_sequential: driver_state -> ND.t driver_state
let rec driver_sequential _dr_st =
(*  let _ = Boot.output_string (pp_core_state _dr_st.core_state) in *)
  drive_core _dr_st >>= fun dr_st ->
  let dr_st = <| dr_st with trace= "drive_core" :: dr_st.trace |> in (* DEBUG *)
  
  let process_core_step = function
(*
    | Step_pointer_request ptr_request ->
        match ptr_request with
          | PtrShiftRequest ty ptr_val n mk_core_st' ->
              
        end
    
*)
    | Step_action_request debug_str tid request_m ->
        let _ = Boot.output_string ("Step_action_request[" ^ debug_str ^ "]") in
        
        (* case where the Core program performs a memory action *)
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let dr_st_with_request =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  let dr_st'' = update_core_state core_st' dr_st' in
                  
                  let _ = Boot.output_string ("AllocRequest on: " ^ show ptr_val ^  (* DEBUG *)
                          ", giving " ^ show dr_st''.core_run_state.layout_state) in (* DEBUG *)
                  
                  dr_st''
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  let _ = Boot.output_string ("StoreRequest on: " ^ show ptr_val ^ " := " ^ show mem_val) in
                  let dr_st'' = <| dr_st' with
                    core_state= core_st';
                    core_run_state= <| dr_st'.core_run_state with
                      layout_state=
  (* TODO: hack hack hack *)
  let (Exception.Result (Undefined.Defined _, z)) = SEU.run (Mem.store ty ptr_val mem_val) dr_st'.core_run_state.layout_state in
  z




                    |>
(*                    sequential_state= Map.insert ptr_val (Just mem_val) dr_st'.sequential_state *)
                  |> in
                  let _ = Boot.output_string ("StoreRequest on: " ^ show ptr_val ^
                          ", from " ^ show dr_st'.core_run_state.layout_state ^
                          ", to " ^ show dr_st''.core_run_state.layout_state) in
                  dr_st''
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val _ mk_core_st' ->
                  let dr_st'' = <| dr_st' with
                    core_state=
                      match Mem.runMem (Mem.load ty ptr_val) dr_st'.core_run_state.layout_state with
                        | Left _ ->
                            Boot.assert_false $ "Error while loading: " ^ show ptr_val
                        | Right (mem_val, _) ->
                            mk_core_st' mem_val
                      end

(*
                      let mem_val = match Map.lookup ptr_val dr_st'.core_run_state.layout_state.Mem.mem_writes with
                        | Just (Just z) ->
                            z
                        | _ ->
                            Boot.assert_false $
                              "reading from uninitialised object: " ^
                              show ptr_val
                      end in
                      mk_core_st' mem_val
*)
                  |> in
                  let _ = Boot.output_string ("LoadRequest on: " ^ show ptr_val ^
                          ", with " ^ show dr_st'.core_run_state.layout_state) in
                  dr_st''
            end in
            driver_sequential dr_st_with_request
    
    | Step_tau debug_str _ step_m ->
        let _ = Boot.output_string ("Step_tau[" ^ debug_str ^ "]") in
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        driver_sequential <| dr_st' with core_state= core_st' |>
    
    | Step_output step_m ->
        let _ = Boot.output_string "Step_output" in
        runCore step_m dr_st >>= fun ((str, core_st'), dr_st') ->
        driver_sequential <| dr_st' with core_state= <| core_st' with io= <| core_st'.io with stdout= Dlist.append (Dlist.singleton str) core_st'.io.stdout |> |> |>
    
    | Step_done _ ->
        let _ = Boot.output_string "Step_done" in
        ND.return dr_st
  end in
  
  ND.pick dr_st.core_state.thread_states >>= fun th_info ->
  core_thread_step dr_st.core_file th_info dr_st.core_state >>=
    process_core_step


val finalize: driver_state -> (string * (bool * Cmm_master.pre_execution * Core.expr core_run_annotation))
let finalize dr_st =
  match dr_st.core_state.thread_states with
    | [(_, (_, th_st))] ->
        (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout), (dr_st.blocked, dr_st.concurrency_state.preEx, th_st.arena))
    | xs ->
        Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st.core_state
  end








(* TODO: it is problematic for proofy backend that this function may diverge *)
(* TODO: HACK *)
let initial_driver_state file =
(*
  let mk_dr_st core_st run_st = <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    concurrency_state= initialExeState emptyPreEx;
    
    (* TODO: uber hack *)
    sequential_state= Map.empty;
    blocked= false;
    trace= [];
  |> in
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          Boot.assert_false "failed to build initial driver state"
    end in
  mk_dr_st core_st run_st
*)
  <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    concurrency_state= initialExeState emptyPreEx;
    
    (* TODO: uber hack *)
(*    sequential_state= Map.empty; *)
    blocked= false;
    trace= [];
  |>







val driver_globals_sequential: Core.file core_run_annotation -> ND.t (Thread.thread_id * driver_state)
let driver_globals_sequential file =
  let dr_st = initial_driver_state file in
  
  (* spawning a thread for the initialisation of globals, and later the execution of main *)
  let ((tid0, core_st), run_st) = State.run (
    (* NOTE: the Eskip is just a placeholder, the thread is given its actual state later *)
    spawn_thread Nothing <|
          arena=  Core.Eskip;
          stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
          labels= Map.empty
    |> dr_st.core_state
  ) dr_st.core_run_state in
  
  (* updating the driver state with the new thread *)
  let dr_st = <| dr_st with
    core_state= core_st;
    core_run_state= run_st
  |> in
  
  ND.foldM (fun (to_subst, dr_st) (sym, cTy, e) ->
    let _ = Boot.output_string ("eval GLOB: " ^ show sym) in
    
    (* setting up the initialisation of the current global in thread 0 *)
    let dr_st = <| dr_st with
      core_state=
        update_thread_state tid0 <|
          arena=  List.foldl (fun acc (sym', v) ->
                    if sym <> sym' then Core_aux.subst_sym sym' v acc else acc
                  ) e to_subst;
          stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
          labels= Map.empty
        |> dr_st.core_state
    |> in
    
    (* evaluation of the initialisation *)
    driver_sequential dr_st >>= fun dr_st' ->
    
    ND.return $
      match dr_st'.core_state.thread_states with
        | [(_, (_, th_st))] ->
            ((sym, th_st.arena) :: to_subst,
             <| dr_st' with core_file=
                  <| dr_st'.core_file with
                       Core.funs=  Core_aux.subst_sym_fun_map sym th_st.arena dr_st'.core_file.Core.funs;
                  |>
             |>)
        | xs ->
            Boot.assert_false "ERROR (in Driver, global init didn't evaluate to value)"
      end
  ) ([], dr_st) dr_st.core_file.Core.globs >>= fun (_, dr_st') ->
  
  ND.return (tid0, dr_st')


let drive file (arg_strs: list string) =
  (* first we execute the body of global definitions and remove their symbols
     from the rest of the program *)
  driver_globals_sequential file >>= fun (tid0, dr_st) ->
  
  (* setting the arena of thread 0 to the body of the main function *)
  match Map.lookup dr_st.core_file.Core.main dr_st.core_file.Core.funs with
    | Nothing ->
        ND.kill (ND.Other "couldn't find the startup function")
    | Just (_, params, expr) ->
        match params with
          | [(argc_sym, _); (argv_sym, _)] ->
              (* memomy_values to be stored in memory objects pointed to by
                 the element of main.argv  *)
              let args_mem_val_tys =
                List.map (fun arg_str ->
                  let mem_vals =
                    List.map (fun c ->
                      (* TODO: fixing impl choice here (ASCII) *)
                      Mem.mk_integer $ Decode.decode_character_constant (String.toString [c])
                    ) (String.toCharList arg_str) in
                  (* NOTE: adding a null termination to the char array *)
                  (
                    Mem.mk_array (mem_vals ++ [Mem.mk_integer 0]),
                    Core_ctype.Array Core_ctype.char (Just $ (integerFromNat $ List.length mem_vals) + 1)
                  )
                ) arg_strs in
              
              (* memory value to be stored in the memory object pointed to by main.argc *)
              let argc_mem_val = Mem.mk_integer (integerFromNat $ List.length args_mem_val_tys) in
              
              (* allocating and initialising an object for main.argc *)
              runCore (
                SEU.bind (runMem (Mem.allocate_object tid0 [dr_st.core_file.Core.main; argc_sym] Core_ctype.signed_int)) (fun ptr_val ->
                SEU.bind (runMem (Mem.store Core_ctype.signed_int ptr_val argc_mem_val)) (fun _ ->
                SEU.return ptr_val))
              ) dr_st >>= fun (argc_ptr_val, dr_st) ->
              
              (* allocating and initialising the objects pointed to by the elements of argv *)
              ND.foldM (fun (ptr_vals, dr_st) (arg_mem_val, arg_ty) ->
                runCore (
                  SEU.bind (runMem (Mem.allocate_object tid0 [] arg_ty)) (fun ptr_val ->
                  SEU.bind (runMem (Mem.store arg_ty ptr_val arg_mem_val)) (fun _ ->
                  SEU.return (ptr_val :: ptr_vals)))
                ) dr_st
              ) ([], dr_st) args_mem_val_tys >>= fun (ptr_vals_rev, dr_st) ->
              
              (* allocating and initialising an object for main.argv *)
              let argv_ty =
                Core_ctype.Array (Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char)
                                 (Just (integerFromNat $ List.length ptr_vals_rev)) in
              runCore (
                SEU.bind (runMem (Mem.allocate_object tid0 [dr_st.core_file.Core.main; argv_sym] argv_ty)) (fun ptr_val ->
                SEU.bind (runMem (Mem.store argv_ty ptr_val (Mem.mk_array $ List.map Mem.mk_pointer (List.reverse ptr_vals_rev)))) (fun _ ->
                SEU.return ptr_val))
              ) dr_st >>= fun (argv_ptr_val, dr_st) ->
              
              ND.return $
                Core_aux.subst_syms [Just argc_sym; Just argv_sym]
                  (Core.Etuple [Core.Econst $ Mem.mk_pointer argc_ptr_val; Core.Econst $ Mem.mk_pointer argv_ptr_val])
                  expr
          | _ ->
              ND.return expr
        end >>= fun expr ->
        driver_sequential <| dr_st with
          core_state= update_thread_state tid0 <|
                        arena=  expr;
                        stack= Core_aux.push_empty_continuation Core_aux.empty_stack; (* TODO: this is probably unecessary *)
                        labels= Map.empty
                      |> dr_st.core_state
        |> >>= fun dr_st' ->
        ND.return (finalize dr_st')
  end
