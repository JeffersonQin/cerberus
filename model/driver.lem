open import Pervasives

import Core Core_ctype Boot UniqueId
open import Core_run Core_run_aux ExecutableOpsem Cmm_master

import Enum State_exception_undefined Exception Undefined Nondeterminism


(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism


type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  concurrency_state: exeState; (* state of the concurrency memory model *)
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  trace: list string;
|>


(* TODO: HACK *)
let initial_driver_state file =
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          Boot.assert_false "failed to build initial driver state"
    end in
  <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        core_st;
    core_run_state=    run_st;
    concurrency_state= initialExeState emptyPreEx;
    
    blocked= false;
    trace= [];
  |>



(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. SetType 'a => SEU.t 'a core_run_state core_run_error -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)
    
    | Exception.Result (U.Undef ubs, _) ->
        ND.kill (ND.Undef ubs)
    
    | Exception.Result (U.Error, _) ->
        ND.kill ND.Error
    
    | Exception.Exception err ->
        ND.kill (ND.Other $ "WIP Driver.runCore: runtime error ==> " ^ string_of_core_run_error err)
  end


open ND.Operators




let rec resolve_read_expr write_sym v expr =
  let f = resolve_read_expr write_sym v in
  match expr with
    | Core.Eunit ->
        Core.Eunit
    | Core.Etrue ->
        Core.Etrue
    | Core.Efalse ->
        Core.Efalse
    | Core.Econst (Mem.MV_integer symb) ->
        if Symbolic.symbol write_sym = symb then
          Core.Econst v
        else
          Core.Econst (Mem.MV_integer symb)
    | Core.Econst mem_val ->
        Core.Econst mem_val
    | Core.Elist pes ->
        Core.Elist $ List.map f pes
    | Core.Ectype ty ->
        Core.Ectype ty
    | Core.Esym sym ->
        Core.Esym sym
    | Core.Eimpl i ->
        Core.Eimpl i
    | Core.Etuple pes ->
        Core.Etuple $ List.map f pes
    | Core.Enot pe ->
        Core.Enot $ f pe
    | Core.Eop bop pe1 pe2 ->
        Core.Eop bop (f pe1) (f pe2)
    | Core.Ecall nm pes ->
        Core.Ecall nm $ List.map f pes
    | Core.Eoutput str ->
        Core.Eoutput str
    | Core.Eundef ub ->
        Core.Eundef ub
    | Core.Eerror ->
        Core.Eerror
    | Core.Eskip ->
        Core.Eskip
    | Core.Elet sym pe1 e2 ->
        Core.Elet sym (f pe1) (f e2)
    | Core.Eif pe1 e2 e3 ->
        Core.Eif (f pe1) (f e2) (f e3)
    | Core.Eproc annots nm pes ->
        Core.Eproc annots nm $ List.map f pes
    | Core.Eaction pact ->
        Core.Eaction $ resolve_read_paction write_sym v pact
    | Core.Eunseq es ->
        Core.Eunseq $ List.map f es
    | Core.Ewseq _as e1 e2 ->
        Core.Ewseq _as (f e1) (f e2)
    | Core.Esseq _as e1 e2 ->
        Core.Esseq _as (f e1) (f e2)
    | Core.Easeq sym_opt act1 pact2 ->
        Core.Easeq sym_opt (resolve_read_action write_sym v act1) (resolve_read_paction write_sym v pact2)
    | Core.Eindet e ->
        Core.Eindet (f e)
    | Core.Ebound n e ->
        Core.Ebound n (f e)
    | Core.Esave ksym sym_tys e ->
        Core.Esave ksym sym_tys (f e)
    | Core.Erun annots ksym sym_es ->
        Core.Erun annots ksym $ List.map (fun (sym, e) -> (sym, f e)) sym_es
    | Core.Eret pe ->
        Core.Eret $ f pe
    | Core.End es ->
        Core.End $ List.map f es
    | Core.Epar es ->
        Core.Epar $ List.map f es
    | Core.Ewait tid ->
        Core.Ewait tid
    | Core.Eis_scalar pe ->
        Core.Eis_scalar $ f pe
    | Core.Eis_integer pe ->
        Core.Eis_integer $ f pe
    | Core.Eis_signed pe ->
        Core.Eis_signed $ f pe
    | Core.Eis_unsigned pe ->
        Core.Eis_unsigned $ f pe
  end

and resolve_read_paction write_sym v (Core.Paction p act) =
  Core.Paction p (resolve_read_action write_sym v act)

and resolve_read_action write_sym v (Core.Action annots act_) =
  let f = resolve_read_expr write_sym v in
  
  Core.Action annots $ match act_ with
  | Core.Create pe1 pe2 pref ->
      Core.Create (f pe1) (f pe2) pref
  | Core.Alloc pe1 pe2 pref ->
      Core.Alloc (f pe1) (f pe2) pref
  | Core.Kill pe ->
      Core.Kill (f pe)
  | Core.Store pe1 pe2 pe3 mo ->
      Core.Store (f pe1) (f pe2) (f pe3) mo
  | Core.Load pe1 pe2 mo ->
      Core.Load (f pe1) (f pe2) mo
  | Core.CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeStrong (f pe1) (f pe2) (f pe3) (f pe4) mo1 mo2
  | Core.CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeWeak (f pe1) (f pe2) (f pe3) (f pe4) mo1 mo2
  end




let rec resolve_read_continuation write_sym v cont =
  List.map (function
    | Core.Kunseq es1 es2 ->
        Core.Kunseq (List.map (resolve_read_expr write_sym v) es1) (List.map (resolve_read_expr write_sym v) es2)
    | Core.Kwseq _as e2 ->
        Core.Kwseq _as (resolve_read_expr write_sym v e2)
    | Core.Ksseq _as e2 ->
        Core.Ksseq _as (resolve_read_expr write_sym v e2)
  end) cont



let rec resolve_read_stack write_sym v = function
  | Core.Stack_empty ->
      Core.Stack_empty
  | Core.Stack_cons cont sk ->
      Core.Stack_cons (resolve_read_continuation write_sym v cont) (resolve_read_stack write_sym v sk)
end



val resolve_read: Symbol.t -> Mem.mem_value -> core_state -> core_state
let resolve_read write_sym v core_st =
(*  let _ = Boot.output_string $ "RESOLVING: " ^ Boot.pp_core_expr ((Core.Etuple [Core.Esym write_sym; Core.Econst v]) : Core.expr unit) ^ "\n" in *)
  <| core_st with
       thread_states= List.map (fun (tid, (parent_tid_opt, th_st)) ->
                       (tid, (parent_tid_opt, <| th_st with arena= resolve_read_expr write_sym v th_st.arena;
                                                            stack= resolve_read_stack write_sym v th_st.stack; |>))
                     ) core_st.thread_states
  |>


val resolve_read_pre_execution: Symbol.t -> Mem.mem_value -> pre_execution -> pre_execution
let resolve_read_pre_execution write_sym v preEx =
  let f = function
    | Mem.MV_pointer ptr_val ->
        Mem.MV_pointer ptr_val
    | Mem.MV_integer symb ->
        if Symbolic.symbol write_sym = symb then
          v
        else
          Mem.MV_integer symb
  end in

  let resolve_read_action = function
(*
    | Lock aid tid loc lk ->
        Lock aid tid loc lk
    | Unlock aid tid loc ->
        Unlock aid tid loc
*)
    | Load aid tid mo loc rv ->
        Load aid tid mo loc (f rv)
    | Store aid tid mo loc sv ->
        Store aid tid mo loc (f sv)
(*
    | RMW aid tid mo loc v1 v2 ->
        RMW aid tid mo loc v1 v2
    | Fence aid tid mo ->
        Fence aid tid mo
    | Blocked_rmw aid tid loc ->
        Blocked_rmw aid tid loc
*)
    | Alloc aid tid loc ->
        Alloc aid tid loc
    | Dealloc aid tid loc ->
        Dealloc aid tid loc
  end in

  <| preEx with
       actions= Set.map resolve_read_action preEx.actions;
       sb=      Set.map (fun (a,b) -> (resolve_read_action a, resolve_read_action b)) preEx.sb;
       asw=     Set.map (fun (a,b) -> (resolve_read_action a, resolve_read_action b)) preEx.asw;
       dd=      Set.map (fun (a,b) -> (resolve_read_action a, resolve_read_action b)) preEx.dd;
 |>





(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driver_state -> ND.t driver_state
let rec stepConcurrency n dr_st =
  match n with
    | 0 ->
        ND.return dr_st
    | _ ->
        (let concur_steps = Set_extra.toList $ exeOpsemStep dr_st.concurrency_state initialEqualityCvalue in
        if List.null concur_steps then
          ND.return <| dr_st with blocked= true |>
        else
          ND.pick concur_steps >>= function
            | ConcurrencyTau performed_act concur_st' ->
                ND.return  <| dr_st with concurrency_state= concur_st' |>
            
            | ReadsFrom v w performed_act concur_st' ->
                ND.log ("READSFROM " ^ string_of_natural (naturalFromNat (aid_of performed_act)) ^ "\n") >>
                (* TODO: v is the new concrete value, w is the symbolic value from the read *)
                let Mem.MV_integer v_symb = v in

                match w with
                  | Mem.MV_integer (Symbolic.Symbolic_symbol write_sym) -> 
                      ND.add_constraint (Constraints.Assert_eq (Symbolic.symbol write_sym) v_symb) >>
                      ND.return  <| dr_st with core_state=        resolve_read write_sym v dr_st.core_state;
                                              concurrency_state= concur_st'  |>
                  | Mem.MV_integer (Symbolic.Symbolic_constant n) ->
                      ND.add_constraint (Constraints.Assert_eq (Symbolic.constant n) v_symb) >>
                      ND.return   <| dr_st with concurrency_state= concur_st' |> 
                end
                

          end) >>= fun dr_st' ->
        
        stepConcurrency (n-1) dr_st'
  end



(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: exeState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.preEx.actions - Set.size concur_st.committed



(* TODO: debug *)
val pp_core_state: forall 'a. core_state -> string
declare ocaml target_rep function pp_core_state = `Boot_pprint.pp_core_state`






(* perform all possible step that are not action requests *)
val     drive_core_thread: Thread.thread_id -> driver_state -> ND.t driver_state
let rec drive_core_thread tid dr_st =
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        (tid, z)
    | _ ->
        Boot.assert_false "drive_core_thread, wrong tid"
  end in
  
(*  ND.log $ "DRIVE_CORE_THREAD (" ^ string_of_natural (naturalFromNat tid) ^ "):\n" ^ pp_core_state dr_st.core_state ^ "\n" >> *)
  core_thread_step dr_st.core_file th_info dr_st.core_state >>= function
    | Step_tau "end of thread" _ step_m ->
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        ND.return <| dr_st' with core_state= core_st' |>
    
    | Step_tau debug_str _ step_m ->
(*        let _ = Boot.output_string ("Found a tau ===> " ^ debug_str) in *)
        (* case where the Core program does a non pure but non memory-related
           step (typically ordering related stuff) *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | Step_eval _ _ step_m ->
        (* case where the Core program does a pure step *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | _ ->
        ND.return dr_st
  end

val     drive_core: driver_state -> ND.t driver_state
let rec drive_core dr_st =
  ND.foldM (fun acc (tid, _) ->
    ND.tryM (drive_core_thread tid acc)
      ND.return
      (fun () -> ND.return acc)
  ) dr_st dr_st.core_state.thread_states




let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with asw=
      Set.filter (fun (a,_) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.sb) preEx.actions
        )
      ) preEx.asw

|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with preEx= repair dr_st.concurrency_state.preEx |>
  |>





val     driver_notinterleaved: driver_state -> ND.t (bool * Cmm_master.pre_execution * Core.expr core_run_annotation)
let rec driver_notinterleaved _dr_st =
(*  ND.log (pp_core_state _dr_st.core_state) >> *)


  drive_core _dr_st >>= fun dr_st ->
  let dr_st = <| dr_st with trace= "drive_core" :: dr_st.trace |> in (* DEBUG *)
  
  let process_core_step = function
    | Step_action_request debug_str tid request_m ->
        (* case where the Core program performs a memory action *)
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            (* debug *)
            let act = match request with
              | AllocRequest _ _ _ _ _ _ _ _ ->
                  "alloc"
              | StoreRequest _ _ _ _ _ _ _ _ _ _ ->
                  "store"
              | LoadRequest _ _ _ _ _ _ _ _ _ _ ->
                  "load"
            end in
            
(*            let _ = Boot.output_string ("REQUESTED: " ^ act) in *)

            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step;
                                        trace= act :: dr_st.trace |> in (* DEBUG *)
            driver_notinterleaved dr_st'
    
    | Step_tau debug_str _ step_m ->
        ND.log $ "Found a tau ===> " ^ debug_str ^ "\n" >>
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        driver_notinterleaved <| dr_st' with core_state= core_st' |>
    
    | Step_done v ->
        
        let dr_st = repair_pre_execution dr_st in 
        let n = (number_of_uncommitted dr_st.concurrency_state) in
        ND.log $ "CALLING CONCURRENCY> " ^ string_of_natural (naturalFromNat n) ^ " times\n" >>
        stepConcurrency n dr_st >>= fun dr_st' ->
        ND.return $
          match dr_st'.core_state.thread_states with
            | [(_, (_, th_st))] ->
                (dr_st'.blocked, dr_st'.concurrency_state.preEx, th_st.arena)
            | xs ->
                Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
          end
  end in
  
  ND.pick dr_st.core_state.thread_states >>= fun th_info ->
  core_thread_step dr_st.core_file th_info dr_st.core_state >>=
    process_core_step


(* ========================================================================== *)


val     driver_notweak: driver_state -> ND.t (bool * Cmm_master.pre_execution * Core.expr core_run_annotation)
let rec driver_notweak _dr_st =
(*  let _ = Boot.output_string (pp_core_state _dr_st.core_state) in *)


  drive_core _dr_st >>= fun dr_st ->
  let dr_st = <| dr_st with trace= "drive_core" :: dr_st.trace |> in (* DEBUG *)
  
  let process_core_step = function
    | Step_action_request debug_str tid request_m ->
        (* case where the Core program performs a memory action *)
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
(*                  ND.log "CREATE\n" >> *)
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (* ND.log "STORE\n" >> *)
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (* ND.log "LOAD\n" >> *)
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            (* debug *)
            let act = match request with
              | AllocRequest _ _ _ _ _ _ _ _ ->
                  "alloc"
              | StoreRequest _ _ _ _ _ _ _ _ _ _ ->
                  "store"
              | LoadRequest _ _ _ _ _ _ _ _ _ _ ->
                  "load"
            end in

(*            let _ = Boot.output_string ("REQUESTED: " ^ act) in *)
            
            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step;
                                        trace= act :: dr_st.trace |> in (* DEBUG *)

            let dr_st' = repair_pre_execution dr_st' in 
            let n = (number_of_uncommitted dr_st'.concurrency_state) in
(*            let _ = Boot.output_string ("CALLING CONCURRENCY> " ^ string_of_natural (naturalFromNat n) ^ " times") in *)
            ND.log $ "CALLING CONCURRENCY> " ^ string_of_natural (naturalFromNat n) ^ " times\n" >>
            stepConcurrency n dr_st' >>= fun dr_st'' ->

            driver_notweak dr_st''
    
    | Step_tau debug_str _ step_m ->
(*        ND.log $ "Found a tau ===> " ^ debug_str ^ "\n" >> *)
(*        let _ = Boot.output_string ("Found a tau ===> " ^ debug_str) in *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        driver_notweak <| dr_st' with core_state= core_st' |>
    
    | Step_done v ->
        
        let dr_st = repair_pre_execution dr_st in 
        let n = (number_of_uncommitted dr_st.concurrency_state) in
        ND.log $ "CALLING CONCURRENCY> " ^ string_of_natural (naturalFromNat n) ^ " times\n" >>
        stepConcurrency n dr_st >>= fun dr_st' ->
        ND.return $
          match dr_st'.core_state.thread_states with
            | [(_, (_, th_st))] ->
                (dr_st'.blocked, dr_st'.concurrency_state.preEx, th_st.arena)
            | xs ->
                Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
          end
  end in
  
  ND.pick dr_st.core_state.thread_states >>= fun th_info ->
  core_thread_step dr_st.core_file th_info dr_st.core_state >>=
    process_core_step

