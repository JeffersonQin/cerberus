open import Pervasives

import Core Core_ctype Boot UniqueId
open import Core_run2 Core_run2_aux ExecutableOpsem Cmm_master

import Enum State_exception_undefined Exception Undefined Nondeterminism


(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism


type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  concurrency_state: exeState; (* state of the concurrency memory model *)
|>


(* TODO: HACK *)
let initial_driver_state file =
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          Boot.assert_false "failed to build initial driver state"
    end in
  <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        core_st;
    core_run_state=    run_st;
    concurrency_state= initialExeState emptyPreEx;
  |>



(*
(* Reinventing the wheel and breaking abstraction for now *)
type driverM 'a = driver_state -> ND.t (Exception.t (Undefined.t 'a * driver_state) driver_error)


val return: forall 'a. 'a -> driverM 'a
let return z =
  fun dr_st -> ND.return (Exception.return (U.return z, dr_st))


val bind: forall 'a 'b. driverM 'a -> ('a -> driverM 'b) -> driverM 'b
let bind m f =
  Boot.assert_false "WIP Driver.bind"

(*
let bind m f =
  fun dr_st ->
    ND.bind (m dr_st) function
      | (Exception.Result (U.Defined z), dr_st') ->
          f z dr_st'
(*
      | z ->
          ND.return z
*)
    end
*)


let inline (>>=) = bind
*)


(*
val runCore: forall 'a. SEU.t 'a core_run_state core_run_error -> driverM 'a
let runCore m =
  Boot.assert_false "WIP"
*)
(*
  fun dr_st ->
    match SEU.run m dr_st.core_run_state with
      | Exception.Result (Undefined.Defined z, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.return z
      | Exception.Result (Undefined.Undef ubs, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.undef ubs
      | Exception.Result (Undefined.Error, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.error
      | Exception.Exception err ->
          SEU.fail (DERR_core_run err)
    end
*)






(*
type preExStep = 
  <| action       : action;
     sbBefore     : set aid;
     ddBefore     : set aid;
     aswBefore    : set aid;
     locationKind : maybe location_kind;
  |>

val updatePreEx: exeState -> preExStep -> exeState


val exeOpsemStep: exeState -> equalityCvalue -> S.t exeStep

*)



(*
val get: driverM driver_state
let get =
  Boot.assert_false "WIP"
*)


(*
val runND: forall 'a. ND.t 'a -> driverM 'a
let runND m =
  fun dr_st ->
    ND.bind m (fun z -> ND.return $ Exception.return (U.return z, dr_st))
*)













(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. SetType 'a => SEU.t 'a core_run_state core_run_error -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)

    | Exception.Result(_, _) ->
        Boot.assert_false "WIP Driver.runCore: semantic error"

    | Exception.Exception err ->
        Boot.assert_false ("WIP Driver.runCore: runtime error ==> " ^ string_of_core_run_error err)
  end


open ND.Operators


(*
val     nTimes: forall 'a. nat -> 'a -> ('a -> ND.t 'a) -> ND.t 'a
let rec nTimes n a m =
  match n with
    | 0 ->
        ND.return a
    | n ->
        m a >>= fun a' -> nTimes (n-1) a' m
  end
*)


(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driver_state -> ND.t driver_state
let rec stepConcurrency n dr_st =
  match n with
    | 0 ->
        ND.return dr_st
    | _ ->
        (let concur_steps = exeOpsemStep dr_st.concurrency_state initialEqualityCvalue in
        if Set.null concur_steps then
          ND.return dr_st
        else
          ND.pick (Set_extra.toList concur_steps) >>= function
            | ConcurrencyTau performed_act concur_st' ->
                ND.return  <| dr_st with concurrency_state= concur_st' |>
            
            | ReadsFrom v w performed_act concur_st' ->
                (* TODO: v is the new concrete value, w is the symbolic value from the write *)
                ND.return  <| dr_st with concurrency_state= concur_st' |>
          end) >>= fun dr_st' ->
        
        stepConcurrency (n-1) dr_st'
  end

(*
            nTimes n dr_st' (fun dr_st ->
              (* Calling the concurrency model *)
              let concur_steps = exeOpsemStep dr_st.concurrency_state initialEqualityCvalue in
              if Set.null concur_steps then
                ND.return dr_st
              else
                ND.pick (Set_extra.toList concur_steps) >>= function
                  | ConcurrencyTau performed_act concur_st' ->
                      ND.return  <| dr_st with concurrency_state= concur_st' |>
                  
                  | ReadsFrom v w performed_act concur_st' ->
                      (* TODO: v is the new concrete value, w is the symbolic value from the write *)
                      ND.return  <| dr_st with concurrency_state= concur_st' |>
                end
            )
*)




val driver_step: driver_state -> ND.t driver_state
let driver_step dr_st =
  (* Calling the Core evaluator for 1 step *)
  core_steps dr_st.core_file dr_st.core_state >>= function
      (* case where the Core program performs a memory action *)
    | Step_action_request debug_str tid request_m ->
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step; |> in
            
            (* non deterministically pick how many time we step the concurrency model this turn *)
            let number_uncommitted = Set.size dr_st'.concurrency_state.preEx.actions - Set.size dr_st'.concurrency_state.committed in
            ND.pick (Enum.enumFromTo 0 number_uncommitted) >>= fun n ->
            
            stepConcurrency n dr_st'
  
    (* case where the Core program does a non pure but non memory-related
       step (typically ordering related stuff) *)
  | Step_tau debug_str tid step_m ->
      runCore step_m dr_st >>= fun (core_st', dr_st') ->
      ND.return <| dr_st' with core_state= core_st' |>
  
    (* case where the Core program does a pure step *)
  | Step_eval debug_str tid step_m ->
      runCore step_m dr_st >>= fun (core_st', dr_st') ->
      ND.return <| dr_st' with core_state= core_st' |>
  
    (* case where the Core program is done *)
  | Step_done v ->
      Boot.assert_false ("DONE: " ^ Boot.pp_core_expr v)
      
      (* TODO: needs to finish the Concurrency execution *)
  end
