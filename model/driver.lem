open import Pervasives

import Core Core_ctype Boot UniqueId
open import Core_run2 Core_run2_aux ExecutableOpsem Cmm_master

import Enum State_exception_undefined Exception Undefined Nondeterminism


(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism


type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  concurrency_state: exeState; (* state of the concurrency memory model *)
  
  (* DEBUG *)
  trace: list string;
|>


(* TODO: HACK *)
let initial_driver_state file =
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          Boot.assert_false "failed to build initial driver state"
    end in
  <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        core_st;
    core_run_state=    run_st;
    concurrency_state= initialExeState emptyPreEx;
    
    trace= [];
  |>



(*
(* Reinventing the wheel and breaking abstraction for now *)
type driverM 'a = driver_state -> ND.t (Exception.t (Undefined.t 'a * driver_state) driver_error)


val return: forall 'a. 'a -> driverM 'a
let return z =
  fun dr_st -> ND.return (Exception.return (U.return z, dr_st))


val bind: forall 'a 'b. driverM 'a -> ('a -> driverM 'b) -> driverM 'b
let bind m f =
  Boot.assert_false "WIP Driver.bind"

(*
let bind m f =
  fun dr_st ->
    ND.bind (m dr_st) function
      | (Exception.Result (U.Defined z), dr_st') ->
          f z dr_st'
(*
      | z ->
          ND.return z
*)
    end
*)


let inline (>>=) = bind
*)


(*
val runCore: forall 'a. SEU.t 'a core_run_state core_run_error -> driverM 'a
let runCore m =
  Boot.assert_false "WIP"
*)
(*
  fun dr_st ->
    match SEU.run m dr_st.core_run_state with
      | Exception.Result (Undefined.Defined z, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.return z
      | Exception.Result (Undefined.Undef ubs, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.undef ubs
      | Exception.Result (Undefined.Error, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.error
      | Exception.Exception err ->
          SEU.fail (DERR_core_run err)
    end
*)






(*
type preExStep = 
  <| action       : action;
     sbBefore     : set aid;
     ddBefore     : set aid;
     aswBefore    : set aid;
     locationKind : maybe location_kind;
  |>

val updatePreEx: exeState -> preExStep -> exeState


val exeOpsemStep: exeState -> equalityCvalue -> S.t exeStep

*)



(*
val get: driverM driver_state
let get =
  Boot.assert_false "WIP"
*)


(*
val runND: forall 'a. ND.t 'a -> driverM 'a
let runND m =
  fun dr_st ->
    ND.bind m (fun z -> ND.return $ Exception.return (U.return z, dr_st))
*)













(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. SetType 'a => SEU.t 'a core_run_state core_run_error -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)

    | Exception.Result(_, _) ->
        Boot.assert_false "WIP Driver.runCore: semantic error"

    | Exception.Exception err ->
        Boot.assert_false ("WIP Driver.runCore: runtime error ==> " ^ string_of_core_run_error err)
  end


open ND.Operators


(*
val     nTimes: forall 'a. nat -> 'a -> ('a -> ND.t 'a) -> ND.t 'a
let rec nTimes n a m =
  match n with
    | 0 ->
        ND.return a
    | n ->
        m a >>= fun a' -> nTimes (n-1) a' m
  end
*)



(* TODO: hack *)
let rec resolve_read_expr write_sym v expr =
  let f = resolve_read_expr write_sym v in
  match expr with
    | Core.Eunit ->
        Core.Eunit
    | Core.Etrue ->
        Core.Etrue
    | Core.Efalse ->
        Core.Efalse
    | Core.Econst (Mem.MV_integer symb) ->
        if Symbolic.symbol write_sym = symb then
          Core.Econst v
        else
          Core.Econst (Mem.MV_integer symb)
    | Core.Econst mem_val ->
        Core.Econst mem_val
    | Core.Elist pes ->
        Core.Elist $ List.map f pes
    | Core.Ectype ty ->
        Core.Ectype ty
    | Core.Esym sym ->
        Core.Esym sym
    | Core.Eimpl i ->
        Core.Eimpl i
    | Core.Etuple pes ->
        Core.Etuple $ List.map f pes
    | Core.Enot pe ->
        Core.Enot $ f pe
    | Core.Eop bop pe1 pe2 ->
        Core.Eop bop (f pe1) (f pe2)
    | Core.Ecall nm pes ->
        Core.Ecall nm $ List.map f pes
    | Core.Eoutput str ->
        Core.Eoutput str
    | Core.Eundef ub ->
        Core.Eundef ub
    | Core.Eerror ->
        Core.Eerror
    | Core.Eskip ->
        Core.Eskip
    | Core.Elet sym pe1 e2 ->
        Core.Elet sym (f pe1) (f e2)
    | Core.Eif pe1 e2 e3 ->
        Core.Eif (f pe1) (f e2) (f e3)
    | Core.Eproc annots nm pes ->
        Core.Eproc annots nm $ List.map f pes
    | Core.Eaction pact ->
        Core.Eaction $ resolve_read_paction write_sym v pact
    | Core.Eunseq es ->
        Core.Eunseq $ List.map f es
    | Core.Ewseq _as e1 e2 ->
        Core.Ewseq _as (f e1) (f e2)
    | Core.Esseq _as e1 e2 ->
        Core.Esseq _as (f e1) (f e2)
    | Core.Easeq sym_opt act1 pact2 ->
        Core.Easeq sym_opt (resolve_read_action write_sym v act1) (resolve_read_paction write_sym v pact2)
    | Core.Eindet e ->
        Core.Eindet (f e)
    | Core.Ebound n e ->
        Core.Ebound n (f e)
    | Core.Esave ksym sym_tys e ->
        Core.Esave ksym sym_tys (f e)
    | Core.Erun annots ksym sym_es ->
        Core.Erun annots ksym $ List.map (fun (sym, e) -> (sym, f e)) sym_es
    | Core.Eret pe ->
        Core.Eret $ f pe
    | Core.End es ->
        Core.End $ List.map f es
    | Core.Epar es ->
        Core.Epar $ List.map f es
    | Core.Ewait tid ->
        Core.Ewait tid
    | Core.Eis_scalar pe ->
        Core.Eis_scalar $ f pe
    | Core.Eis_integer pe ->
        Core.Eis_integer $ f pe
    | Core.Eis_signed pe ->
        Core.Eis_signed $ f pe
    | Core.Eis_unsigned pe ->
        Core.Eis_unsigned $ f pe
  end

and resolve_read_paction write_sym v (Core.Paction p act) =
  Core.Paction p (resolve_read_action write_sym v act)

and resolve_read_action write_sym v (Core.Action annots act_) =
  let f = resolve_read_expr write_sym v in
  
  Core.Action annots $ match act_ with
  | Core.Create pe1 pe2 pref ->
      Core.Create (f pe1) (f pe2) pref
  | Core.Alloc pe1 pe2 pref ->
      Core.Alloc (f pe1) (f pe2) pref
  | Core.Kill pe ->
      Core.Kill (f pe)
  | Core.Store pe1 pe2 pe3 mo ->
      Core.Store (f pe1) (f pe2) (f pe3) mo
  | Core.Load pe1 pe2 mo ->
      Core.Load (f pe1) (f pe2) mo
  | Core.CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeStrong (f pe1) (f pe2) (f pe3) (f pe4) mo1 mo2
  | Core.CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeWeak (f pe1) (f pe2) (f pe3) (f pe4) mo1 mo2
  end




(* TODO: hack *)
let rec resolve_read_continuation write_sym v cont =
  List.map (function
    | Core.Kunseq es1 es2 ->
        Core.Kunseq (List.map (resolve_read_expr write_sym v) es1) (List.map (resolve_read_expr write_sym v) es2)
    | Core.Kwseq _as e2 ->
        Core.Kwseq _as (resolve_read_expr write_sym v e2)
    | Core.Ksseq _as e2 ->
        Core.Ksseq _as (resolve_read_expr write_sym v e2)
  end) cont



(* TODO: hack *)
let rec resolve_read_stack write_sym v = function
  | Core.Stack_empty ->
      Core.Stack_empty
  | Core.Stack_cons cont sk ->
      Core.Stack_cons (resolve_read_continuation write_sym v cont) (resolve_read_stack write_sym v sk)
end



(* TODO: hack *)
val resolve_read: Symbol.t -> Mem.mem_value -> core_state -> core_state
let resolve_read write_sym v core_st =
  let _ = Boot.output_string $ "RESOLVING: " ^ Boot.pp_core_expr ((Core.Etuple [Core.Esym write_sym; Core.Econst v]) : Core.expr unit) ^ "\n" in
  <| core_st with
       thread_states= List.map (fun (tid, (parent_tid_opt, th_st)) ->
                       (tid, (parent_tid_opt, <| th_st with arena= resolve_read_expr write_sym v th_st.arena;
                                                            stack= resolve_read_stack write_sym v th_st.stack; |>))
                     ) core_st.thread_states
  |>



(*
type thread_state = <|
  arena:        expr core_run_annotation;
  stack:        stack core_run_annotation;
|>


(* TODO: more *)
type io_state = <|
  stdout: string;
|>

type core_state = <|
  thread_states: list (thread_id * (maybe thread_id * thread_state)); (* the associated tid is that of the parent thread *)
  io:            io_state;
|>
*)



(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driver_state -> ND.t driver_state
let rec stepConcurrency n dr_st =
  match n with
    | 0 ->
        ND.return dr_st
    | _ ->
        (let concur_steps = Set_extra.toList $ exeOpsemStep dr_st.concurrency_state initialEqualityCvalue in
        if List.null concur_steps then
          ND.return dr_st
        else
          ND.pick concur_steps >>= function
            | ConcurrencyTau performed_act concur_st' ->
                ND.return  <| dr_st with concurrency_state= concur_st' |>
            
            | ReadsFrom v w performed_act concur_st' ->
                let _ = Boot.output_string "READSFROM\n" in
                (* TODO: v is the new concrete value, w is the symbolic value from the write *)
                let Mem.MV_integer (Symbolic.Symbolic_symbol write_sym) = w in
                ND.return  <| dr_st with core_state=        resolve_read write_sym v dr_st.core_state;
                                         concurrency_state= concur_st' |>
          end) >>= fun dr_st' ->
        
        stepConcurrency (n-1) dr_st'
  end

(*
            nTimes n dr_st' (fun dr_st ->
              (* Calling the concurrency model *)
              let concur_steps = exeOpsemStep dr_st.concurrency_state initialEqualityCvalue in
              if Set.null concur_steps then
                ND.return dr_st
              else
                ND.pick (Set_extra.toList concur_steps) >>= function
                  | ConcurrencyTau performed_act concur_st' ->
                      ND.return  <| dr_st with concurrency_state= concur_st' |>
                  
                  | ReadsFrom v w performed_act concur_st' ->
                      (* TODO: v is the new concrete value, w is the symbolic value from the write *)
                      ND.return  <| dr_st with concurrency_state= concur_st' |>
                end
            )
*)



(*
val driver_step: driver_state -> ND.t driver_state
let driver_step dr_st =
  (* Calling the Core evaluator for 1 step *)
  core_steps dr_st.core_file dr_st.core_state >>= function
      (* case where the Core program performs a memory action *)
    | Step_action_request debug_str tid request_m ->
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step; |> in
            
            (* non deterministically pick how many time we step the concurrency model this turn *)
            let number_uncommitted = Set.size dr_st'.concurrency_state.preEx.actions - Set.size dr_st'.concurrency_state.committed in
            ND.pick (Enum.enumFromTo 0 number_uncommitted) >>= fun n ->
            
            stepConcurrency n dr_st'
  
    (* case where the Core program does a non pure but non memory-related
       step (typically ordering related stuff) *)
  | Step_tau debug_str tid step_m ->
      runCore step_m dr_st >>= fun (core_st', dr_st') ->
      ND.return <| dr_st' with core_state= core_st' |>
  
    (* case where the Core program does a pure step *)
  | Step_eval debug_str tid step_m ->
      runCore step_m dr_st >>= fun (core_st', dr_st') ->
      ND.return <| dr_st' with core_state= core_st' |>
  
    (* case where the Core program is done *)
  | Step_done v ->
      Boot.assert_false ("DONE: " ^ Boot.pp_core_expr v)
      
      (* TODO: needs to finish the Concurrency execution *)
  end
*)

(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: exeState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.preEx.actions - Set.size concur_st.committed



(* TODO: debug *)
val pp_core_state: forall 'a. core_state -> string
declare ocaml target_rep function pp_core_state = `Boot_pprint.pp_core_state`






(*
  ND.tryM (core_steps dr_st.core_file dr_st.core_state)
    process_core_step



core_thread_step file (current_tid, (parent_tid_opt, th_st)) st
*)




(* perform all possible step that are not action requests *)
val     drive_core_thread: Thread.thread_id -> driver_state -> ND.t driver_state
let rec drive_core_thread tid dr_st =
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        (tid, z)
    | _ ->
        Boot.assert_false "drive_core_thread, wrong tid"
  end in
  
  let _ = Boot.output_string $ "DRIVE_CORE_THREAD (" ^ string_of_natural tid ^ "):\n" ^ pp_core_state dr_st.core_state ^ "\n" in
  core_thread_step dr_st.core_file th_info dr_st.core_state >>= function
    | Step_tau "end of thread" _ step_m ->
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        ND.return <| dr_st' with core_state= core_st' |>
    
    | Step_tau _ _ step_m ->
        (* case where the Core program does a non pure but non memory-related
           step (typically ordering related stuff) *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | Step_eval _ _ step_m ->
        (* case where the Core program does a pure step *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | _ ->
        ND.return dr_st
  end

val     drive_core: driver_state -> ND.t driver_state
let rec drive_core dr_st =
  ND.foldM (fun acc (tid, _) ->
    ND.tryM (drive_core_thread tid acc)
      ND.return
      (fun () -> ND.return acc)
  ) dr_st dr_st.core_state.thread_states













val     driver: driver_state -> ND.t (Core.expr core_run_annotation)
let rec driver _dr_st =
  let _ = Boot.output_string (pp_core_state _dr_st.core_state) in


  drive_core _dr_st >>= fun dr_st ->
  let dr_st = <| dr_st with trace= "drive_core" :: dr_st.trace |> in (* DEBUG *)
  
  let process_core_step = function
    | Step_action_request debug_str tid request_m ->
        (* case where the Core program performs a memory action *)
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  let _ = Boot.output_string "CREATE\n" in
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  let _ = Boot.output_string "STORE\n" in
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  let _ = Boot.output_string "LOAD\n" in
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            (* debug *)
            let act = match request with
              | AllocRequest _ _ _ _ _ _ _ _ ->
                  "alloc"
              | StoreRequest _ _ _ _ _ _ _ _ _ _ ->
                  "store"
              | LoadRequest _ _ _ _ _ _ _ _ _ _ ->
                  "load"
            end in
            
            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step;
                                        trace= act :: dr_st.trace |> in (* DEBUG *)
            driver dr_st'
(*
            (* non deterministically pick how many time we step the concurrency model this turn *)
            ND.pick (Enum.enumFromTo 0 (number_of_uncommitted dr_st'.concurrency_state)) >>= fun n ->
            
(*            stepConcurrency n dr_st' >>= driver *)
            stepConcurrency n dr_st' >>= fun dr_st'' ->
              driver <| dr_st'' with trace= ("concur(" ^ string_of_natural (naturalFromNat n) ^ ")") :: dr_st''.trace |>
*)

    | Step_tau debug_str _ step_m ->
        let _ = Boot.output_string $ "Found a tau ===> " ^ debug_str ^ "\n" in
        (* TODO: why is this needed ?????? *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        driver <| dr_st' with core_state= core_st' |>




    
    | Step_done v ->
(*
        ND.return $
          List.foldl (fun acc x -> x ^ "\n" ^ acc) "" dr_st.trace
*)
      stepConcurrency (number_of_uncommitted dr_st.concurrency_state) dr_st >>= fun dr_st' -> 
      (* TODO: this is pretty disgusting *)
      ND.return $
        match dr_st'.core_state.thread_states with
          | [(_, (_, th_st))] ->
              th_st.arena
          | xs ->
              Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
        end



(*
        let _ = Boot.output_string "DONE" in
        ND.return v
*)
  end in
  
  ND.pick dr_st.core_state.thread_states >>= fun th_info ->
  core_thread_step dr_st.core_file th_info dr_st.core_state >>=
    process_core_step
(*  core_steps dr_st.core_file dr_st.core_state >>= *)
(*
  ND.tryM (core_steps dr_st.core_file dr_st.core_state)
    process_core_step
    (fun () ->
      stepConcurrency (number_of_uncommitted dr_st.concurrency_state) dr_st >>= fun dr_st' -> 
      (* TODO: this is pretty disgusting *)
      ND.return $
        match dr_st'.core_state.thread_states with
          | [(_, (_, th_st))] ->
              th_st.arena
          | xs ->
              Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
        end
    )
*)






























(* ========================================== *)

(*

val     _driver: driver_state -> ND.t (Core.expr core_run_annotation)
let rec _driver dr_st =
(*  let _ = Boot.output_string (pp_core_state dr_st.core_state) in *)

  let process_core_step = function
      (* case where the Core program performs a memory action *)
    | Step_action_request debug_str tid request_m ->
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step; |> in
            
            (* non deterministically pick how many time we step the concurrency model this turn *)
            ND.pick (Enum.enumFromTo 0 (number_of_uncommitted dr_st'.concurrency_state)) >>= fun n ->
            
            stepConcurrency n dr_st' >>= _driver
  
    (* case where the Core program does a non pure but non memory-related
       step (typically ordering related stuff) *)
  | Step_tau debug_str tid step_m ->
      runCore step_m dr_st >>= fun (core_st', dr_st') ->
      _driver <| dr_st' with core_state= core_st' |>
  
    (* case where the Core program does a pure step *)
  | Step_eval debug_str tid step_m ->
      runCore step_m dr_st >>= fun (core_st', dr_st') ->
      _driver <| dr_st' with core_state= core_st' |>


(*  
    (* case where the Core program is done *)
  | Step_done v ->
      ND.return v
      (* TODO: needs to finish the Concurrency execution *)
*)
  end in
  

(*
  match core_steps dr_st.core_file dr_st.core_state with
    | [] ->
        stepConcurrency (number_of_uncommitted dr_st.concurrency_state) dr_st >>= fun dr_st' -> 
        (* TODO: this is pretty disgusting *)
        ND.return $
          match dr_st'.core_state.thread_states with
            | [(_, (_, th_st))] ->
                th_st.arena
            | xs ->
                Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
          end
    | xs ->
        xs >>= process_core_step
  end
*)
  ND.tryM (core_steps dr_st.core_file dr_st.core_state)
    process_core_step
    (fun () ->
      stepConcurrency (number_of_uncommitted dr_st.concurrency_state) dr_st >>= fun dr_st' -> 
      (* TODO: this is pretty disgusting *)
      ND.return $
        match dr_st'.core_state.thread_states with
          | [(_, (_, th_st))] ->
              th_st.arena
          | xs ->
              Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
        end
    )

*)
