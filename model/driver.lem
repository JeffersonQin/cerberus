open import Pervasives

import Core Core_ctype Boot UniqueId
open import Core_run2 Core_run2_aux ExecutableOpsem Cmm_master

import Enum State_exception_undefined Exception Undefined Nondeterminism


(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism


type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  concurrency_state: exeState; (* state of the concurrency memory model *)
  
  (* DEBUG *)
  trace: list string;
|>


(* TODO: HACK *)
let initial_driver_state file =
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          Boot.assert_false "failed to build initial driver state"
    end in
  <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        core_st;
    core_run_state=    run_st;
    concurrency_state= initialExeState emptyPreEx;
    
    trace= [];
  |>



(*
(* Reinventing the wheel and breaking abstraction for now *)
type driverM 'a = driver_state -> ND.t (Exception.t (Undefined.t 'a * driver_state) driver_error)


val return: forall 'a. 'a -> driverM 'a
let return z =
  fun dr_st -> ND.return (Exception.return (U.return z, dr_st))


val bind: forall 'a 'b. driverM 'a -> ('a -> driverM 'b) -> driverM 'b
let bind m f =
  Boot.assert_false "WIP Driver.bind"

(*
let bind m f =
  fun dr_st ->
    ND.bind (m dr_st) function
      | (Exception.Result (U.Defined z), dr_st') ->
          f z dr_st'
(*
      | z ->
          ND.return z
*)
    end
*)


let inline (>>=) = bind
*)


(*
val runCore: forall 'a. SEU.t 'a core_run_state core_run_error -> driverM 'a
let runCore m =
  Boot.assert_false "WIP"
*)
(*
  fun dr_st ->
    match SEU.run m dr_st.core_run_state with
      | Exception.Result (Undefined.Defined z, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.return z
      | Exception.Result (Undefined.Undef ubs, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.undef ubs
      | Exception.Result (Undefined.Error, run_st') ->
          SEU.put <| dr_st with core_run_state= run_st' |> >>
          SEU.error
      | Exception.Exception err ->
          SEU.fail (DERR_core_run err)
    end
*)






(*
type preExStep = 
  <| action       : action;
     sbBefore     : set aid;
     ddBefore     : set aid;
     aswBefore    : set aid;
     locationKind : maybe location_kind;
  |>

val updatePreEx: exeState -> preExStep -> exeState


val exeOpsemStep: exeState -> equalityCvalue -> S.t exeStep

*)



(*
val get: driverM driver_state
let get =
  Boot.assert_false "WIP"
*)


(*
val runND: forall 'a. ND.t 'a -> driverM 'a
let runND m =
  fun dr_st ->
    ND.bind m (fun z -> ND.return $ Exception.return (U.return z, dr_st))
*)













(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. SetType 'a => SEU.t 'a core_run_state core_run_error -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)

    | Exception.Result(_, _) ->
        Boot.assert_false "WIP Driver.runCore: semantic error"

    | Exception.Exception err ->
        Boot.assert_false ("WIP Driver.runCore: runtime error ==> " ^ string_of_core_run_error err)
  end


open ND.Operators




(* TODO: hack *)
let rec resolve_read_expr write_sym v expr =
  let f = resolve_read_expr write_sym v in
  match expr with
    | Core.Eunit ->
        Core.Eunit
    | Core.Etrue ->
        Core.Etrue
    | Core.Efalse ->
        Core.Efalse
    | Core.Econst (Mem.MV_integer symb) ->
        if Symbolic.symbol write_sym = symb then
          Core.Econst v
        else
          Core.Econst (Mem.MV_integer symb)
    | Core.Econst mem_val ->
        Core.Econst mem_val
    | Core.Elist pes ->
        Core.Elist $ List.map f pes
    | Core.Ectype ty ->
        Core.Ectype ty
    | Core.Esym sym ->
        Core.Esym sym
    | Core.Eimpl i ->
        Core.Eimpl i
    | Core.Etuple pes ->
        Core.Etuple $ List.map f pes
    | Core.Enot pe ->
        Core.Enot $ f pe
    | Core.Eop bop pe1 pe2 ->
        Core.Eop bop (f pe1) (f pe2)
    | Core.Ecall nm pes ->
        Core.Ecall nm $ List.map f pes
    | Core.Eoutput str ->
        Core.Eoutput str
    | Core.Eundef ub ->
        Core.Eundef ub
    | Core.Eerror ->
        Core.Eerror
    | Core.Eskip ->
        Core.Eskip
    | Core.Elet sym pe1 e2 ->
        Core.Elet sym (f pe1) (f e2)
    | Core.Eif pe1 e2 e3 ->
        Core.Eif (f pe1) (f e2) (f e3)
    | Core.Eproc annots nm pes ->
        Core.Eproc annots nm $ List.map f pes
    | Core.Eaction pact ->
        Core.Eaction $ resolve_read_paction write_sym v pact
    | Core.Eunseq es ->
        Core.Eunseq $ List.map f es
    | Core.Ewseq _as e1 e2 ->
        Core.Ewseq _as (f e1) (f e2)
    | Core.Esseq _as e1 e2 ->
        Core.Esseq _as (f e1) (f e2)
    | Core.Easeq sym_opt act1 pact2 ->
        Core.Easeq sym_opt (resolve_read_action write_sym v act1) (resolve_read_paction write_sym v pact2)
    | Core.Eindet e ->
        Core.Eindet (f e)
    | Core.Ebound n e ->
        Core.Ebound n (f e)
    | Core.Esave ksym sym_tys e ->
        Core.Esave ksym sym_tys (f e)
    | Core.Erun annots ksym sym_es ->
        Core.Erun annots ksym $ List.map (fun (sym, e) -> (sym, f e)) sym_es
    | Core.Eret pe ->
        Core.Eret $ f pe
    | Core.End es ->
        Core.End $ List.map f es
    | Core.Epar es ->
        Core.Epar $ List.map f es
    | Core.Ewait tid ->
        Core.Ewait tid
    | Core.Eis_scalar pe ->
        Core.Eis_scalar $ f pe
    | Core.Eis_integer pe ->
        Core.Eis_integer $ f pe
    | Core.Eis_signed pe ->
        Core.Eis_signed $ f pe
    | Core.Eis_unsigned pe ->
        Core.Eis_unsigned $ f pe
  end

and resolve_read_paction write_sym v (Core.Paction p act) =
  Core.Paction p (resolve_read_action write_sym v act)

and resolve_read_action write_sym v (Core.Action annots act_) =
  let f = resolve_read_expr write_sym v in
  
  Core.Action annots $ match act_ with
  | Core.Create pe1 pe2 pref ->
      Core.Create (f pe1) (f pe2) pref
  | Core.Alloc pe1 pe2 pref ->
      Core.Alloc (f pe1) (f pe2) pref
  | Core.Kill pe ->
      Core.Kill (f pe)
  | Core.Store pe1 pe2 pe3 mo ->
      Core.Store (f pe1) (f pe2) (f pe3) mo
  | Core.Load pe1 pe2 mo ->
      Core.Load (f pe1) (f pe2) mo
  | Core.CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeStrong (f pe1) (f pe2) (f pe3) (f pe4) mo1 mo2
  | Core.CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeWeak (f pe1) (f pe2) (f pe3) (f pe4) mo1 mo2
  end




(* TODO: hack *)
let rec resolve_read_continuation write_sym v cont =
  List.map (function
    | Core.Kunseq es1 es2 ->
        Core.Kunseq (List.map (resolve_read_expr write_sym v) es1) (List.map (resolve_read_expr write_sym v) es2)
    | Core.Kwseq _as e2 ->
        Core.Kwseq _as (resolve_read_expr write_sym v e2)
    | Core.Ksseq _as e2 ->
        Core.Ksseq _as (resolve_read_expr write_sym v e2)
  end) cont



(* TODO: hack *)
let rec resolve_read_stack write_sym v = function
  | Core.Stack_empty ->
      Core.Stack_empty
  | Core.Stack_cons cont sk ->
      Core.Stack_cons (resolve_read_continuation write_sym v cont) (resolve_read_stack write_sym v sk)
end



(* TODO: hack *)
val resolve_read: Symbol.t -> Mem.mem_value -> core_state -> core_state
let resolve_read write_sym v core_st =
  let _ = Boot.output_string $ "RESOLVING: " ^ Boot.pp_core_expr ((Core.Etuple [Core.Esym write_sym; Core.Econst v]) : Core.expr unit) ^ "\n" in
  <| core_st with
       thread_states= List.map (fun (tid, (parent_tid_opt, th_st)) ->
                       (tid, (parent_tid_opt, <| th_st with arena= resolve_read_expr write_sym v th_st.arena;
                                                            stack= resolve_read_stack write_sym v th_st.stack; |>))
                     ) core_st.thread_states
  |>


val resolve_read_pre_execution: Symbol.t -> Mem.mem_value -> pre_execution -> pre_execution
let resolve_read_pre_execution write_sym v preEx =
  let f = function
    | Mem.MV_pointer ptr_val ->
        Mem.MV_pointer ptr_val
    | Mem.MV_integer symb ->
        if Symbolic.symbol write_sym = symb then
          v
        else
          Mem.MV_integer symb
  end in

  let resolve_read_action = function
(*
    | Lock aid tid loc lk ->
        Lock aid tid loc lk
    | Unlock aid tid loc ->
        Unlock aid tid loc
*)
    | Load aid tid mo loc rv ->
        Load aid tid mo loc (f rv)
    | Store aid tid mo loc sv ->
        Store aid tid mo loc (f sv)
(*
    | RMW aid tid mo loc v1 v2 ->
        RMW aid tid mo loc v1 v2
    | Fence aid tid mo ->
        Fence aid tid mo
    | Blocked_rmw aid tid loc ->
        Blocked_rmw aid tid loc
*)
    | Alloc aid tid loc ->
        Alloc aid tid loc
    | Dealloc aid tid loc ->
        Dealloc aid tid loc
  end in

  <| preEx with
       actions= Set.map resolve_read_action preEx.actions;
       sb=      Set.map (fun (a,b) -> (resolve_read_action a, resolve_read_action b)) preEx.sb;
       asw=     Set.map (fun (a,b) -> (resolve_read_action a, resolve_read_action b)) preEx.asw;
       dd=      Set.map (fun (a,b) -> (resolve_read_action a, resolve_read_action b)) preEx.dd;
 |>





(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driver_state -> ND.t driver_state
let rec stepConcurrency n dr_st =
  match n with
    | 0 ->
        ND.return dr_st
    | _ ->
        (let concur_steps = Set_extra.toList $ exeOpsemStep dr_st.concurrency_state initialEqualityCvalue in
        if List.null concur_steps then
          ND.return dr_st
        else
          ND.pick concur_steps >>= function
            | ConcurrencyTau performed_act concur_st' ->
                ND.return  <| dr_st with concurrency_state= concur_st' |>
            
            | ReadsFrom v w performed_act concur_st' ->
                let _ = Boot.output_string "READSFROM\n" in
                (* TODO: v is the new concrete value, w is the symbolic value from the write *)
                let Mem.MV_integer (Symbolic.Symbolic_symbol write_sym) = w in
                
                (* TODO: ignoring pointer for now *)
                let Mem.MV_integer v_symb = v in
                ND.add_equation (Symbolic.eq (Symbolic.symbol write_sym) v_symb) >>
                
                ND.return  <| dr_st with core_state=        resolve_read write_sym v dr_st.core_state;
                                         concurrency_state= <| concur_st' with preEx= resolve_read_pre_execution write_sym v concur_st'.preEx |> |>
          end) >>= fun dr_st' ->
        
        stepConcurrency (n-1) dr_st'
  end



(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: exeState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.preEx.actions - Set.size concur_st.committed



(* TODO: debug *)
val pp_core_state: forall 'a. core_state -> string
declare ocaml target_rep function pp_core_state = `Boot_pprint.pp_core_state`






(* perform all possible step that are not action requests *)
val     drive_core_thread: Thread.thread_id -> driver_state -> ND.t driver_state
let rec drive_core_thread tid dr_st =
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        (tid, z)
    | _ ->
        Boot.assert_false "drive_core_thread, wrong tid"
  end in
  
  let _ = Boot.output_string $ "DRIVE_CORE_THREAD (" ^ string_of_natural tid ^ "):\n" ^ pp_core_state dr_st.core_state ^ "\n" in
  core_thread_step dr_st.core_file th_info dr_st.core_state >>= function
    | Step_tau "end of thread" _ step_m ->
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        ND.return <| dr_st' with core_state= core_st' |>
    
    | Step_tau _ _ step_m ->
        (* case where the Core program does a non pure but non memory-related
           step (typically ordering related stuff) *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | Step_eval _ _ step_m ->
        (* case where the Core program does a pure step *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        drive_core_thread tid <| dr_st' with core_state= core_st' |>
    
    | _ ->
        ND.return dr_st
  end

val     drive_core: driver_state -> ND.t driver_state
let rec drive_core dr_st =
  ND.foldM (fun acc (tid, _) ->
    ND.tryM (drive_core_thread tid acc)
      ND.return
      (fun () -> ND.return acc)
  ) dr_st dr_st.core_state.thread_states



(*
type pre_execution =
  <|  actions : set (action);
      threads : set (tid);
      lk      : location -> location_kind;
      sb      : set (action * action) ;
      asw     : set (action * action) ;
      dd      : set (action * action) ;
  |>
*)
let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with asw=
      Set.filter (fun (a,_) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.sb) preEx.actions
        )
      ) preEx.asw
(*      let sb_asw_star = Relation.transitiveClosure $ Relation.relComp preEx.sb preEx.asw in *)
|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with preEx= repair dr_st.concurrency_state.preEx |>
  |>





val     driver: driver_state -> ND.t (Cmm_master.pre_execution * Core.expr core_run_annotation)
let rec driver _dr_st =
  let _ = Boot.output_string (pp_core_state _dr_st.core_state) in


  drive_core _dr_st >>= fun dr_st ->
  let dr_st = <| dr_st with trace= "drive_core" :: dr_st.trace |> in (* DEBUG *)
  
  let process_core_step = function
    | Step_action_request debug_str tid request_m ->
        (* case where the Core program performs a memory action *)
        runCore request_m dr_st >>= fun (request, dr_st') ->
          let (preEx_step, core_st') =
            match request with
              | AllocRequest sb_edges dd_edges asw_edges aid tid ty ptr_val core_st' ->
                  let _ = Boot.output_string "CREATE\n" in
                  (<| action=       Alloc aid tid ptr_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else  Non_Atomic); |>,
                   core_st')
              
              | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  let _ = Boot.output_string "STORE\n" in
                  (<| action=       Store aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
              
              | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
                  let _ = Boot.output_string "LOAD\n" in
                  (<| action=       Load aid tid mo ptr_val mem_val;
                      sbBefore=     sb_edges;
                      ddBefore=     dd_edges;
                      aswBefore=    asw_edges;
                      locationKind= Just (if Core_ctype.is_atomic ty then Atomic else Non_Atomic); |>,
                   core_st')
            end in
            
            (* debug *)
            let act = match request with
              | AllocRequest _ _ _ _ _ _ _ _ ->
                  "alloc"
              | StoreRequest _ _ _ _ _ _ _ _ _ _ ->
                  "store"
              | LoadRequest _ _ _ _ _ _ _ _ _ _ ->
                  "load"
            end in
            
            let dr_st' = <| dr_st' with core_state=        core_st';
                                        concurrency_state= updatePreEx dr_st.concurrency_state preEx_step;
                                        trace= act :: dr_st.trace |> in (* DEBUG *)
            driver dr_st'
    
    | Step_tau debug_str _ step_m ->
        let _ = Boot.output_string $ "Found a tau ===> " ^ debug_str ^ "\n" in
        (* TODO: why is this needed ?????? *)
        runCore step_m dr_st >>= fun (core_st', dr_st') ->
        driver <| dr_st' with core_state= core_st' |>
    
    | Step_done v ->
        
        let dr_st = repair_pre_execution dr_st in 
        stepConcurrency (number_of_uncommitted dr_st.concurrency_state) dr_st >>= fun dr_st' ->
        (* TODO: this is pretty disgusting *)
        ND.return $
          match dr_st'.core_state.thread_states with
            | [(_, (_, th_st))] ->
                (dr_st'.concurrency_state.preEx, th_st.arena)
            | xs ->
                Boot.assert_false $ "ERROR (end of the Driver)\n" ^ pp_core_state dr_st'.core_state
          end
  end in
  
  ND.pick dr_st.core_state.thread_states >>= fun th_info ->
  core_thread_step dr_st.core_file th_info dr_st.core_state >>=
    process_core_step
