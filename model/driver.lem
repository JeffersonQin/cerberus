open import Pervasives

import Core Core_ctype Boot UniqueId Decode
open import Global Show Core_run Core_run_aux
import Cmm_op Cmm_csem

import Enum State_exception_undefined Exception Undefined Nondeterminism Dlist

import Map_extra (* DEBUG *)

import Mem Mem_aux

import Driver_effect
(* module E = Driver_effect *)

module Cmm = Cmm_csem

(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism



val stringFromPointerValue: Mem.pointer_value -> string
declare ocaml target_rep function stringFromPointerValue = `String_mem.string_of_pointer_value`


val stringFromMemValue: Mem.mem_value -> string
declare ocaml target_rep function stringFromMemValue = `String_mem.string_of_mem_value`

(* TODO: debug *)
val pp_core_state: forall 'a. core_state -> string
declare ocaml target_rep function pp_core_state = `String_core_run.string_of_core_state`









type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  layout_state:      Mem.mem_state;    (* state of memory layout model *)
  concurrency_state: Cmm_op.symState; (* state of the concurrency memory model *)
  
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  trace: list string;
  dr_step_counter: nat;
|>





val aid_to_string: Cmm.action -> string
let aid_to_string a =
  show (Cmm.aid_of a)



open ND.Operators

(* BEGIN reads resolving ======================================================================== *)
val     resolve_read_pexpr: Symbol.t -> Symbolic.symbolic -> Core.pexpr -> Core.pexpr
let rec resolve_read_pexpr write_sym symb_v pexpr =
  let fpe = resolve_read_pexpr write_sym symb_v in
  match pexpr with
    | Core.PEundef _ ->
        pexpr
    | Core.PEerror _ ->
        pexpr
    | Core.PEval (Core.Vsymbolic symb) ->
        Core.PEval (Core.Vsymbolic $ Symbolic.subst_sym write_sym symb_v symb)
    | Core.PEval _ ->
        pexpr
    | Core.PEsym _ ->
        pexpr
    | Core.PEimpl _ ->
        pexpr
    | Core.PEcons pe1 pe2 ->
        Core.PEcons (fpe pe1) (fpe pe2)
    | Core.PEcase_list pe1 pe2 nm ->
        Core.PEcase_list (fpe pe1) (fpe pe2) nm
    | Core.PEcase_ctype pe1 pe2 nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8 ->
        Core.PEcase_ctype (fpe pe1) (fpe pe2) nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8
    | Core.PEarray_shift pe1 ty pe2 ->
        Core.PEarray_shift (fpe pe1) ty (fpe pe2)
    | Core.PEmember_shift pe tag_sym memb_ident ->
        Core.PEmember_shift (fpe pe) tag_sym memb_ident
    | Core.PEnot pe ->
        Core.PEnot (fpe pe)
    | Core.PEop bop pe1 pe2 ->
        Core.PEop bop (fpe pe1) (fpe pe2)
    | Core.PEmemop memop pes ->
        Core.PEmemop memop (List.map fpe pes)
    | Core.PEtuple pes ->
        Core.PEtuple (List.map fpe pes)
    | Core.PEarray pes ->
        Core.PEarray (List.map fpe pes)
    | Core.PEstruct sym xs ->
        Core.PEstruct sym (List.map (fun (ident, pe) -> (ident, fpe pe)) xs)
    | Core.PEcall nm pes ->
        Core.PEcall nm (List.map fpe pes)
    | Core.PElet sym pe1 pe2 ->
        Core.PElet sym (fpe pe1) (fpe pe2)
    | Core.PEif pe1 pe2 pe3 ->
        Core.PEif (fpe pe1) (fpe pe2) (fpe pe3)
    | Core.PEis_scalar pe ->
        Core.PEis_scalar (fpe pe)
    | Core.PEis_integer pe ->
        Core.PEis_integer (fpe pe)
    | Core.PEis_signed pe ->
        Core.PEis_signed (fpe pe)
    | Core.PEis_unsigned pe ->
        Core.PEis_unsigned (fpe pe)
  end


let rec resolve_read_expr write_sym symb_v expr =
  let fe  = resolve_read_expr write_sym symb_v in
  let fpe = resolve_read_pexpr write_sym symb_v in
  match expr with
    | Core.Epure pe ->
        Core.Epure (fpe pe)
    | Core.Ememop memop pes ->
        Core.Ememop memop (List.map fpe pes)
    | Core.Eraise _ ->
        expr
    | Core.Eregister _ _ ->
        expr
    | Core.Eskip ->
        expr
    | Core.Elet sym pe1 e2 ->
        Core.Elet sym (fpe pe1) (fe e2)
    | Core.Eif pe1 e2 e3 ->
        Core.Eif (fpe pe1) (fe e2) (fe e3)
    | Core.Eproc annot nm pes ->
        Core.Eproc annot nm (List.map fpe pes)
    | Core.Eaction pact ->
        Core.Eaction (resolve_read_paction write_sym symb_v pact)
    | Core.Eunseq es ->
        Core.Eunseq (List.map fe es)
    | Core.Ewseq _as e1 e2 ->
        Core.Ewseq _as (fe e1) (fe e2)
    | Core.Esseq _as e1 e2 ->
        Core.Esseq _as (fe e1) (fe e2)
    | Core.Easeq sym_opt act1 pact2 ->
        Core.Easeq sym_opt (resolve_read_action write_sym symb_v act1) (resolve_read_paction write_sym symb_v pact2)
    | Core.Eindet e ->
        Core.Eindet (fe e)
    | Core.Ebound i e ->
        Core.Ebound i (fe e)
    | Core.Esave ksym sym_tys e ->
        Core.Esave ksym sym_tys (fe e)
    | Core.Erun annot ksym sym_pes ->
        Core.Erun annot ksym (List.map (fun (sym, pe) -> (sym, fpe pe)) sym_pes)
    | Core.Eret pe ->
        Core.Eret (fpe pe)
    | Core.End es ->
        Core.End (List.map fe es)
    | Core.Epar es ->
        Core.Epar (List.map fe es)
    | Core.Ewait _ ->
        expr
  end

and resolve_read_paction write_sym symb_v (Core.Paction p act) =
  Core.Paction p (resolve_read_action write_sym symb_v act)

and resolve_read_action write_sym symb_v (Core.Action annots act_) =
  let fpe = resolve_read_pexpr write_sym symb_v in
  
  Core.Action annots $ match act_ with
  | Core.Create pe1 pe2 pref ->
      Core.Create (fpe pe1) (fpe pe2) pref
  | Core.Alloc pe1 pe2 pref ->
      Core.Alloc (fpe pe1) (fpe pe2) pref
  | Core.Kill pe ->
      Core.Kill (fpe pe)
  | Core.Store pe1 pe2 pe3 mo ->
      Core.Store (fpe pe1) (fpe pe2) (fpe pe3) mo
  | Core.Load pe1 pe2 mo ->
      Core.Load (fpe pe1) (fpe pe2) mo
  | Core.CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeStrong (fpe pe1) (fpe pe2) (fpe pe3) (fpe pe4) mo1 mo2
  | Core.CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeWeak (fpe pe1) (fpe pe2) (fpe pe3) (fpe pe4) mo1 mo2
  end




let rec resolve_read_continuation write_sym symb_v cont =
  List.map (function
    | Core.Kunseq es1 es2 ->
        Core.Kunseq (List.map (resolve_read_expr write_sym symb_v) es1) (List.map (resolve_read_expr write_sym symb_v) es2)
    | Core.Kwseq _as e2 ->
        Core.Kwseq _as (resolve_read_expr write_sym symb_v e2)
    | Core.Ksseq _as e2 ->
        Core.Ksseq _as (resolve_read_expr write_sym symb_v e2)
  end) cont



let rec resolve_read_stack write_sym symb_v = function
  | Core.Stack_empty ->
      Core.Stack_empty
  | Core.Stack_cons cont sk ->
      Core.Stack_cons (resolve_read_continuation write_sym symb_v cont) (resolve_read_stack write_sym symb_v sk)
end


val resolve_read: Symbol.t -> Symbolic.symbolic -> core_state -> core_state
let resolve_read write_sym symb_v core_st =
  (* let _ = Boot.output_string $ "RESOLVING: " ^ Boot.pp_core_expr ((Core.Etuple [Core.Esym write_sym; Core.Econst v]) : Core.expr unit) ^ "\n" in *)
  <| core_st with
       thread_states= List.map (fun (tid, (parent_tid_opt, th_st)) ->
                       (tid, (parent_tid_opt, <| th_st with arena= resolve_read_expr write_sym symb_v th_st.arena;
                                                            stack= resolve_read_stack write_sym symb_v th_st.stack; |>))
                     ) core_st.thread_states
  |>



(* END reads resolving ========================================================================= *)


(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driver_state -> ND.t driver_state
let rec stepConcurrency n dr_st =
  if n = 0 then
    ND.return dr_st
  else begin
    Cmm_op.symStep dr_st.concurrency_state >>=  function
      | Cmm_op.ConcurrencyTau performed_act concur_st' ->
(*          ND.log ("ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act) ^ "\n")           >> (* DEBUG *) *)
          ND.print_debug 4 ("ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act) ^ "\n") >> (* DEBUG *)
          ND.return  <| dr_st with concurrency_state= concur_st' |>
      
      (* TODO: the variables names seems completely messed up here *)
      | Cmm_op.ReadsFrom w mval performed_act concur_st' ->
(*          ND.log ("Performed action " ^ aid_to_string performed_act ^ "\n")           >> (* DEBUG *) *)
          ND.print_debug 4 ("ReadsFrom with aid: " ^ aid_to_string performed_act ^ "\n") >> (* DEBUG *)
          (* TODO: w is the new concrete value, mval is the symbolic value from the read *)
          match Mem_aux.symbolicFromMemValue mval with
            | Nothing ->
                error ("stepConcurency fail: " ^ stringFromMemValue mval)
            | Just mval_symb ->
                let (_, ival) = fromJust $ Mem_aux.integerValueFromMemValue w in
                Mem.case_integer_value ival
                  (fun n ->
                    ND.add_constraint (Constraints.assert_eq (Symbolic.SYMBconst n) mval_symb) >>
                    
                    match mval_symb with
                      | Symbolic.SYMBsym _ r_sym ->
                          ND.print_debug 5 ("ReadsFrom: " ^ show r_sym ^ " = " ^ show n) >>
                          ND.return <| dr_st with
                            concurrency_state= concur_st';
                            core_state= resolve_read r_sym (Symbolic.SYMBconst n) dr_st.core_state;
                          |> 
                      | _ ->
                        error "stepConcurrency, ReadsFrom, not a symbol"
                    end
                    
(*
                    ND.return   <| dr_st with concurrency_state= concur_st' |> 
*)
                  )
              (fun () -> error "WIP[Driver.stepConcurrency]: complex ival, ReadsFrom")
          end
    end
  end >>= stepConcurrency (n-1)



val liftMem: forall 'a. Mem.memM 'a -> driver_state -> ND.t ('a * driver_state)
let liftMem m dr_st =
  ND.msum $ map (function
    | Left mem_err ->
        (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (liftMem) ==> " ^ show mem_err))
    | Right (z, layout_st') ->
        ND.return (z, <| dr_st with layout_state= layout_st' |>)
  end) (Mem.runMem m dr_st.layout_state)










  

(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. (* SetType 'a => *) core_runM 'a -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)
    
    | Exception.Result (U.Undef ubs, _) ->
        ND.kill (ND.Undef ubs)
    
    | Exception.Result (U.Error str, _) ->
        ND.kill (ND.Error str)
    
    | Exception.Exception err ->
        ND.kill (ND.Other $ "WIP Driver.runCore: runtime error ==> " ^ show err)
  end

(*
val runCore2: forall 'a. core_runM 'a -> driver_state -> (EU.t 'a core_run_error * driver_state)
let runCore2 m dr_st =
  let (ret, run_st') = SEU.run m dr_st.core_run_state in
  (ret, <| dr_st with core_run_state= run_st' |>)
*)





(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: Cmm_op.symState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.Cmm_op.symPre.Cmm.actions - List.length concur_st.Cmm_op.symCommitted






(*
val drive_to_requests: Thread.thread_id -> core_state -> ND.t action_request
let drive_to_requests tid core_st = 
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        (tid, z)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  match core_thread_step dr_st.core_file th_info dr_st.core_state with
(*
  | Step_action_request of (* DEBUG *) string * thread_id * core_runM action_request
*)
  | Step_tau dedug_str tid step_m ->
      error "runCore"
(*
  | Step_thread_done of thread_id * core_runM core_state
  | Step_eval of (* DEBUG *) string * thread_id * core_runM core_state
  | Step_nd of string * list core_step
*)
  | Step_blocked ->
      error "ND.return core_st"
(*
  | Step_branch of (* DEBUG *) string * thread_id * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM core_state * core_runM core_state
  | Step_done of Core.value
  | Step_spawn_threads of thread_id * thread_state * list thread_state
*)

(*
    | Step_nd debug_str steps ->
        ND.foldM (fun core_st_acc step ->
          drive_to_requests tid core_st_acc
        ) dr_st.core_state steps
*)
  end
*)


(* For a given thread, perform all possible step that are not action requests *)
val     drive_core_thread: Thread.thread_id -> driver_state -> ND.t driver_state
let rec drive_core_thread tid dr_st =
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        z (* (tid, z) *)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  ND.msum $ List.map (function
    | Step2_action_request _ ->
        (* DEBUG *) ND.print_debug 5 (">> ACTION_REQUEST") >>
        ND.return dr_st
    | Step2_memop_request _ _ _ _ ->
        ND.return dr_st
    | Step2_tau debug_str step_m ->
        (* DEBUG *) ND.print_debug 5 ("tau: " ^ debug_str) >>
        (* case where the Core program does a non pure but non memory-related
           step (typically ordering related stuff) *)
        runCore step_m dr_st >>= fun (th_st', dr_st') ->
        drive_core_thread tid <| dr_st' with
          core_state= update_thread_state tid th_st' dr_st'.core_state;
          dr_step_counter= dr_st'.dr_step_counter + 1
        |>
    | Step2_eval debug_str step_m ->
        (* DEBUG *) ND.print_debug 5 ("eval: " ^ debug_str) >>
        (* case where the Core program does a pure step *)
        runCore step_m dr_st >>= fun (th_st', dr_st') ->
        drive_core_thread tid <| dr_st' with
          core_state= update_thread_state tid th_st' dr_st'.core_state;
          dr_step_counter= dr_st'.dr_step_counter + 1
        |>
    
    | Step2_thread_done parent_tid cval ->
        (* DEBUG *) ND.print_debug 5 ("thread " ^ show tid ^ " is done") >>
        (* case where the current (non startup) thread execution ended. *)
        ND.return <| dr_st with
          core_state= kill_thread tid parent_tid cval dr_st.core_state;
          dr_step_counter= dr_st.dr_step_counter + 1
        |> >>=
          drive_core_thread parent_tid
    
    | Step2_blocked ->
        error "WIP: Step2_blocked"
    | Step2_error debug_str ->
        error ("WIP: Step2_error --> " ^ debug_str)
    | Step2_branch debug_Str mk_constr_then mk_constr_else step_then step_else ->
        error "WIP: Step2_branch"
    | Step2_done cval ->
        ND.return dr_st
    | Step2_spawn_threads th_st ->
        error "WIP: Step2_spawn_threads"
  end) (core_thread_step2 dr_st.core_file tid th_info)

(*
  match core_thread_step dr_st.core_file th_info dr_st.core_state with

(*
    | Step_nd debug_str step_ms ->
(*        runCore2  *)
        ND.print_debug 9 ("drive_core_thread (" ^ show tid ^ ") ==> Step_nd " ^ debug_str) >> (* DEBUG *)
        ND.foldM (fun acc step_m ->
          runCore step_m acc >>= fun (core_st', dr_st') ->
          let acc' = <| dr_st' with core_state= core_st'; dr_step_counter= dr_st'.dr_step_counter + 1 |> in
          ND.tryM (drive_core_thread tid acc')
            (fun () -> ND.return acc')
        ) dr_st step_ms
*)
        

    | Step_spawn_threads parent_tid parent_th_st th_sts ->
        let ((th_tids, core_st'), run_st') = State.run (
          State.foldM (fun (th_tids_, core_st_) th_st ->
            State.bind (spawn_thread (Just parent_tid) th_st core_st_)
              (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
          ) ([], dr_st.core_state) th_sts
        ) dr_st.core_run_state in
        
        let dr_st' = <| dr_st with
          core_run_state= run_st';
          core_state= update_thread_state parent_tid <| parent_th_st with
                        arena= Core.Eunseq $ List.reverse (List.map (fun z -> Core.Ewait z) th_tids)
                      |> core_st';
        |> in
        
        ND.foldM (fun acc tid ->
          drive_core_thread tid acc
        ) dr_st' th_tids >>= fun dr_st'' ->
        
        drive_core_thread parent_tid dr_st''

(*    
  | Step_branch of (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_step * core_step
*)        

    | Step_branch debug_str parent_tid mk_then_constrs mk_else_constrs step_then_m step_else_m ->
        ND.mplus
          begin
            ND.add_constraint mk_then_constrs >>
            runCore step_then_m dr_st >>= fun (core_st', dr_st') ->
            drive_core_thread tid <| dr_st' with core_state= core_st'; dr_step_counter= dr_st'.dr_step_counter + 1 |>
          end
          begin
            ND.add_constraint mk_else_constrs >>
            runCore step_else_m dr_st >>= fun (core_st', dr_st') ->
            drive_core_thread tid <| dr_st' with core_state= core_st'; dr_step_counter= dr_st'.dr_step_counter + 1 |>
          end
  end
*)


(* perform drive_core_thread for all the core threads *)
val     drive_core_threads: driver_state -> ND.t driver_state
let rec drive_core_threads dr_st =
  ND.foldM (fun acc (tid, _) ->
(*
    ND.tryM (drive_core_thread tid acc)
      ND.return
      (fun () -> ND.return acc)
*)
    drive_core_thread tid acc
  ) dr_st dr_st.core_state.thread_states




let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with Cmm.asw=
      Set.filter (fun (a,c) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.Cmm.sb

&& Relation.inRel b c preEx.Cmm.asw

) preEx.Cmm.actions
        )
      ) preEx.Cmm.asw


|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with Cmm_op.symPre= repair dr_st.concurrency_state.Cmm_op.symPre |>
  |>



val update_core_state: core_state -> driver_state -> driver_state
let update_core_state core_st dr_st =
  <| dr_st with core_state= core_st |>

val update_core_run_state: core_run_state -> driver_state -> driver_state
let update_core_run_state run_st dr_st =
  <| dr_st with core_run_state= run_st |>




(* ========================================================================== *)


val action_request_concurrency: driver_state -> action_request -> ND.t driver_state
let action_request_concurrency dr_st = function
  | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
      ND.print_debug 4 ("StoreRequest on: " ^ stringFromPointerValue ptr_val ^ " := " ^ stringFromMemValue mem_val) >>
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Store aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      let dr_st' = update_core_state core_st' dr_st in
      
      ND.return <| dr_st' with
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "store" :: dr_st.trace
      |>

  | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val sym mk_core_st' ->
(*          let (sym, dr_st) = fresh_symbol dr_st in *)
      ND.print_debug 4 ("LoadRequest on: " ^ stringFromPointerValue ptr_val) >>
      (* ND.log "LOAD\n" >> *)
      
      let mem_val = Mem.symbolic_mval (Symbolic.SYMBsym Symbolic.SYMBint sym) in
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Load aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      let dr_st' = update_core_state (mk_core_st' mem_val) dr_st in
      
      ND.return <| dr_st' with
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "load" :: dr_st.trace
      |>
  
  | AllocRequest _ _ _ _ tid pref align_ival size_ival mk_core_st' ->
      (* TODO: hack, hack, hack *)
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (alloc concur) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   mk_core_st' ptr_val;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_dynamic tid pref align_ival size_ival) dr_st.layout_state)
  
  | CreateRequest _ _ _ _ tid pref align_ival lvalue_ty mk_core_st' ->
      (* TODO: hack, hack, hack *)
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (create concur) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   mk_core_st' ptr_val;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_static tid pref align_ival lvalue_ty) dr_st.layout_state)
end




(* This version only uses the memory layout model (note that is deterministic) *)
val action_request_sequential: driver_state -> action_request2 -> ND.t driver_state
let action_request_sequential dr_st = function
  | AllocRequest2 sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (alloc seq) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' ptr_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_dynamic tid pref align_ival size_ival) dr_st.layout_state)
  
  | CreateRequest2 sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty mk_th_st' ->
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (create seq) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' ptr_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_static tid pref align_ival lvalue_ty) dr_st.layout_state)
  
  | LoadRequest2 sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val _ mk_th_st' ->
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (load seq) ==> " ^ show mem_err))
        | Right (mem_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' mem_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.load lvalue_ty ptr_val) dr_st.layout_state)
  
  | StoreRequest2 sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val mem_val th_st' ->
      (* TODO: need to make memory layout detect unsequenced races (use to make
         the concurency to the check even in the sequential mode) *)
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (store seq) ==> " ^ show mem_err))

        | Right ((), layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid th_st' dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.store lvalue_ty ptr_val mem_val) dr_st.layout_state)
(* TODO: KillRequest2 *)
end








val     driver: bool -> driver_state -> ND.t driver_state
let rec driver with_concurrency dr_st =
  let process_core_step2 dr_st = function
  | Step2_action_request request_m ->
      (* DEBUG *) ND.print_debug 9 "Step2_action_request" >>
      runCore request_m dr_st >>= fun (request, dr_st') ->
      
      let execution_mode_is_random = match ND.current_execution_mode () with
        | Nothing   -> false
        | Just mode -> mode = ND.Random
      end in
      
      begin
        if with_concurrency then
          error "action_request_concurrency dr_st' request" >>= fun dr_st'' ->
          if execution_mode_is_random then
            let total = number_of_uncommitted dr_st''.concurrency_state in
            let choices = Enum.enumFromTo 0 total in
            
            (* DEBUG *)
            let _ = if choices = [] then error "BOOM" else () in
            
            ND.pick choices >>= fun n ->
            ND.warns_if_no_active_ex (stepConcurrency n dr_st'')
          else
            ND.return dr_st''
        else
          action_request_sequential dr_st' request
      end >>= fun dr_final ->
      driver with_concurrency dr_final
  | Step2_memop_request memop cvals tid mk_th_st ->
      let cval = match (memop, cvals) with
        | (Mem_common.Ptrdiff, [Core.Vpointer ptr_val1; Core.Vpointer ptr_val2]) ->
            Core.Vinteger (Mem.diff_ptrval ptr_val1 ptr_val2)
        | (Mem_common.IntFromPtr, [Core.Vctype ref_ty; Core.Vctype (Core_ctype.Basic (AilTypes.Integer ity)); Core.Vpointer ptr_val]) ->
            Core.Vinteger (Mem.intcast_ptrval ref_ty ity ptr_val)
        | (Mem_common.PtrFromInt, [Core.Vctype ty; Core.Vctype ref_ty; Core.Vinteger ival]) ->
            Core.Vpointer (Mem.ptrcast_ival ty ref_ty ival)

(*
  | PtrFromInt  (* (ctype, ctype, integer) -> address *) (* first type is that of integer, second on is type of reference *)
  | PtrValidForDeref (* address -> boolean *)
*)


(*
        | (Mem_common.Ptrdiff, _) ->
            error ("memop request: ptrdiff operand error ==> " ^
                   Boot.pp_core_expr ((Core.Epure (Core.PEval (Core.Vtuple cvals))): Core.expr unit))
*)
        | _ ->
            error ("WIP memop request: " ^ show memop ^ " ==> " ^
                   Boot.pp_core_expr ((Core.Epure (Core.PEval (Core.Vtuple cvals))): Core.expr unit))
      end in
      ND.return <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st.core_state |>
  | Step2_tau debug_str _ ->
      error ("FOUND A TAU: '" ^ debug_str ^ "'")
  | Step2_eval debug_str _ ->
      error ("FOUND AN EVAL: '" ^ debug_str ^ "'")

(*
  | Step2_thread_done of thread_id * Core.value
  | Step2_blocked
  | Step2_error of string
  | Step2_branch of (* DEBUG *) string * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM thread_state * core_runM thread_state
*)
  | Step2_done cval ->
      ND.print_debug 3 ("driver.process_core_step ==> Step_done with value: " ^ Boot.pp_core_expr (Core.Epure (Core.PEval cval) : Core.expr unit)) >> (* DEBUG *)
      ND.return dr_st
(*
  | Step2_spawn_threads of list thread_state (* initial states for the children *)
*)
  end in
  let process_core_step dr_st = function
    | Step_action_request debug_str tid request_m ->
        ND.print_debug 9 ("Step_action_request[" ^ debug_str ^ "]") >>
        runCore request_m dr_st >>= fun (request, dr_st') ->
        
        let execution_mode_is_random =
          match ND.current_execution_mode () with
          | Nothing   -> false
          | Just mode -> mode = ND.Random
          end in
        
        begin
          if with_concurrency then
            action_request_concurrency dr_st' request >>= fun dr_st'' ->
            if execution_mode_is_random then
              let total = number_of_uncommitted dr_st''.concurrency_state in
              let choices = Enum.enumFromTo 0 total in
              
              (* DEBUG *)
              let _ = if choices = [] then error "BOOM" else () in
              
              ND.pick choices >>= fun n ->
              ND.warns_if_no_active_ex (stepConcurrency n dr_st'')
            else
              ND.return dr_st''
          else
            error "action_request_sequential dr_st' request"
        end >>= fun dr_final ->
        driver with_concurrency dr_final



    | Step_done cval ->
        ND.print_debug 3 ("driver.process_core_step ==> Step_done with value: " ^ Boot.pp_core_expr (Core.Epure (Core.PEval cval) : Core.expr unit)) >> (* DEBUG *)
       ND.return dr_st


(*
    | Step_blocked ->
        driver with_concurrency dr_st
*)


    (* DEBUG *)
    | step ->
        match step with
          | Step_action_request debug_str tid _ ->
              error ("Step_action_request[" ^ debug_str ^ "] by thread " ^ show tid)
          | Step_tau debug_str tid _ ->
              error ("Step_tau[" ^ debug_str ^ "] by thread " ^ show tid)
          | Step_thread_done _ _ ->
              error "Step_thread_done"
          | Step_eval debug_str tid _ ->
              error ("Step_eval[" ^ debug_str ^ "] by thread " ^ show tid)
          | Step_nd debug_str _ ->
              error ("Step_nd[" ^ debug_str ^ "]")
          | Step_blocked ->
              error "Step_blocked"
          | Step_branch _ _ _ _ _ _ ->
              error "Step_branch"
          | Step_done _ ->
              error "Step_done"
          | Step_spawn_threads _ _ _ ->
              error "Step_spawn_threads"
        end


  end in
  
  drive_core_threads dr_st >>= fun post_core_dr_st ->
  
    (* TODO: hackish *)
    let non_blocked_th_sts = List.filter (fun (tid, th_info) ->
      List.any (fun step -> step <> Step2_blocked) $ core_thread_step2 post_core_dr_st.core_file tid th_info
    ) post_core_dr_st.core_state.thread_states in
  
  (if ND.current_execution_mode () = Just ND.Random then
    (* HACK The problem is that some threads are blocked (they wait
       for other threads to finish. If we randomly pick that thread to
       execute, there will not be any steps to execute, and the whole
       execution comes to a halt. To properly solve this, we need to
       implement back tracking. Since we haven't, we temporarily
       switch to exhaustive mode and also compute the steps of the
       other threads. *)
    
    ND.print_debug 5 ("FIRST: " ^ show (List.length post_core_dr_st.core_state.thread_states) ^ " vs " ^ show (List.length non_blocked_th_sts)) >>
    ND.bindExhaustive (ND.pick (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts)
                      (fun (tid, th_info) ->
(* OLD                       ND.return $ core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state) *)
                       ND.pick $ core_thread_step2 post_core_dr_st.core_file tid th_info)
    

   else
    ND.print_debug 5 "SECOND" >>
(*
     ND.pick (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts >>= fun th_info ->
     ND.return (core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state)
*)
    ND.pick non_blocked_th_sts >>= fun (tid, th_info) ->
    ND.pick (core_thread_step2 post_core_dr_st.core_file tid th_info)
  ) >>=
      process_core_step2 post_core_dr_st







val     hack: Core.file core_run_annotation -> Core.pexpr -> Core.value
let rec hack core_file pexpr =
  match core_eval core_file false pexpr with
    | Exception.Result (Undefined.Defined pexpr') ->
        match Core_aux.valueFromPexpr pexpr' with
          | Just cval ->
              cval
          | Nothing ->
              hack core_file pexpr'
        end
    | _ ->
        error ("Driver.hack, UNDEF/ERROR:" ^ Boot.pp_core_expr (Core.Epure pexpr : Core.expr unit))
(*
    | _ ->
        (* TODO: this is wrong *)
        expr
*)
end


let finalize_constraints core_file (Constraints.Constraints symbs) =
  Constraints.Constraints $ List.map (function
    | Symbolic.SYMBop op symb1 symb2 ->
(*
        let Just symb1' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb1))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
        let Just symb2' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb2))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
*)
        let Core.Vsymbolic symb1' = hack core_file (Core.PEval (Core.Vsymbolic symb1)) in
        let Core.Vsymbolic symb2' = hack core_file (Core.PEval (Core.Vsymbolic symb2)) in
        Symbolic.SYMBop op symb1' symb2'
    | symb ->
        symb
  end) symbs




val finalize: string -> driver_state -> (string * (bool * Cmm_op.symState * Core.value) * (nat * nat))
let finalize debug_str dr_st =
  match dr_st.core_state.thread_states with
    | [(tid, (_, th_st))] ->
        let v = hack dr_st.core_file
            match Core_aux.to_pure th_st.arena with
(*
              | Just (Core.PEval (Core.Vinteger ival)) ->
                  let Just symb = Mem_aux.symbolicFromIntegerValue ival in
                  Core_aux.unsymbolify symb
*)
              | Just pe ->
                  pe
              | Nothing ->
                  error ("Driver.finalize: the arena wasn't pure ==> " ^ Boot.pp_core_expr th_st.arena)
            end in
        (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout), (dr_st.blocked, dr_st.concurrency_state, v),
         (dr_st.dr_step_counter, dr_st.core_run_state.step_counter))
    | xs ->
        let () = Boot.print_debug 1 ("ERROR (end of the Driver)\n" ^ pp_core_state dr_st.core_state) in
        error ("BOOM finalize [" ^ debug_str ^ "]")
  end








(* TODO: it is problematic for proofy backend that this function may diverge *)
(* TODO: HACK *)
let initial_driver_state sym_supply file =
(*
  let mk_dr_st core_st run_st = <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    concurrency_state= initialExeState emptyPreEx;
    
    (* TODO: uber hack *)
    sequential_state= Map.empty;
    blocked= false;
    trace= [];
  |> in
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          error "failed to build initial driver state"
    end in
  mk_dr_st core_st run_st
*)
  <|
    symbol_supply=     sym_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    layout_state=  Mem.initial_mem_stateWithTagDefinitions file.Core.tagDefinitions;
    concurrency_state= Cmm_op.symInitialState Cmm_op.symInitialPre;

    
    (* TODO: uber hack *)
(*    sequential_state= Map.empty; *)
    blocked= false;
    trace= [];
    
    dr_step_counter= 0;
  |>







val driver_globals: bool -> UniqueId.supply Symbol.t -> Core.file core_run_annotation -> ND.t (Thread.thread_id * driver_state)
let driver_globals with_concurrency sym_supply file =
  let dr_st = initial_driver_state sym_supply file in
  
  (* spawning a thread for the initialisation of globals, and later the execution of main *)
  let ((tid0, core_st), run_st) = State.run (
    (* NOTE: the Eskip is just a placeholder, the thread is given its actual state later *)
    spawn_thread Nothing <|
          arena=  Core.Eskip;
          stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
          labels= Map.empty
    |> dr_st.core_state
  ) dr_st.core_run_state in
  
  (* updating the driver state with the new thread *)
  let dr_st = <| dr_st with
    core_state= core_st;
    core_run_state= run_st
  |> in
  
  ND.foldM (fun (to_subst, dr_st) (sym, cTy, e) ->
    let _ = Boot.print_debug 6 ("eval GLOB: " ^ show sym) in
    
    (* setting up the initialisation of the current global in thread 0 *)
    let dr_st = <| dr_st with
      core_state=
        update_thread_state tid0 <|
          arena=  List.foldl (fun acc (sym', pe) ->
                    if sym <> sym' then Core_aux.subst_sym sym' pe acc else acc
                  ) e to_subst;
          stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
          labels= Map.empty
        |> dr_st.core_state
    |> in
    
    (* evaluation of the initialisation *)
    driver with_concurrency dr_st >>= fun dr_st' ->
    
    ND.return $
      match dr_st'.core_state.thread_states with
        | [(_, (_, th_st))] ->
            (* TODO: technically the arena should always be a value at this point *)
            match Core_aux.to_pure th_st.arena with
              | Just pe ->
                  ((sym, pe) :: to_subst,
                   <| dr_st' with core_file=
                     <| dr_st'.core_file with
                       Core.funs=  Core_aux.subst_sym_fun_map sym pe dr_st'.core_file.Core.funs;
                     |>
                   |>)
              | Nothing ->
                  error "TODO(msg): Driver.driver_globals, the end of the evaluation of a glob didn't produce a value"
            end
            
        | xs ->
            error "ERROR (in Driver, global init didn't evaluate to value)"
      end
  ) ([], dr_st) dr_st.core_file.Core.globs >>= fun (_, dr_st') ->
  
  ND.return (tid0, dr_st')



val pp_exeState: Cmm_op.symState -> string
declare ocaml target_rep function pp_exeState = `Pp_cmm.pp_execState`



val drive: bool -> UniqueId.supply Symbol.t -> Core.file core_run_annotation -> list string ->
           ND.t (string * (bool * Cmm_op.symState * Core.pexpr) * (nat * nat))
let drive (with_concurrency: bool) sym_supply file (arg_strs: list string) =
  (* first we execute the body of global definitions and remove their symbols
     from the rest of the program *)
  driver_globals with_concurrency sym_supply file >>= fun (tid0, dr_st) ->
  
  (* setting the arena of thread 0 to the body of the main function *)
  match Map.lookup dr_st.core_file.Core.main dr_st.core_file.Core.funs with
    | Nothing ->
        ND.kill (ND.Other "couldn't find the startup function")
    
    | Just decl ->
        let (params, expr) = match decl with
          | Core.Fun  _ params pe ->
              (params, Core.Eret pe)
          | Core.Proc _ params e ->
              (params, e)
        end in
        
        match params with
          | [(argc_sym, _); (argv_sym, _)] ->
              (* memomy_values to be stored in memory objects pointed to by
                 the element of main.argv  *)
              let args_mem_val_tys =
                List.map (fun arg_str ->
                  let mem_vals =
                    List.map (fun c ->
                      (* TODO: fixing impl choice here (ASCII) *)
                      Mem_aux.integer_mval AilTypes.Char $ Decode.decode_character_constant (String.toString [c])
                    ) (String.toCharList arg_str) in
                  (* NOTE: adding a null termination to the char array *)
                  (
                    Mem.array_mval $ mem_vals ++ [Mem_aux.integer_mval AilTypes.Char 0],
                    Core_ctype.Array Core_ctype.char (Just $ (integerFromNat $ List.length mem_vals) + 1)
                  )
                ) arg_strs in
              
              (* memory value to be stored in the memory object pointed to by main.argc *)
              let argc_mem_val = Mem_aux.integer_mval (AilTypes.Signed AilTypes.Int_) (integerFromNat $ List.length args_mem_val_tys) in
              
              (* allocating and initialising an object for main.argc *)
              liftMem (
                Mem.bind (Mem.allocate_static tid0 [dr_st.core_file.Core.main; argc_sym] (Mem.alignof_ival Core_ctype.signed_int) Core_ctype.signed_int) (fun ptr_val ->
                  Mem.bind (Mem.store Core_ctype.signed_int ptr_val argc_mem_val) (fun _ ->
                    Mem.return ptr_val
                  )
                )
              ) dr_st >>= fun (argc_ptr_val, dr_st) ->
              
              (* allocating and initialising the objects pointed to by the elements of argv *)
              ND.foldM (fun (ptr_vals, dr_st) (arg_mem_val, arg_ty) ->
                liftMem (
                  Mem.bind (Mem.allocate_static tid0 [] (Mem.alignof_ival arg_ty) arg_ty) (fun ptr_val ->
                    Mem.bind (Mem.store arg_ty ptr_val arg_mem_val) (fun () ->
                      Mem.return (ptr_val :: ptr_vals)
                    )
                  )
                ) dr_st
              ) ([], dr_st) args_mem_val_tys >>= fun (ptr_vals_rev, dr_st) ->
              
              (* allocating and initialising an object for main.argv *)
              let argv_elem_ty = Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char in
              let argv_ty = Core_ctype.Array argv_elem_ty (Just (integerFromNat $ List.length ptr_vals_rev)) in
              liftMem (
                Mem.bind (Mem.allocate_static tid0 [dr_st.core_file.Core.main; argv_sym] (Mem.alignof_ival argv_ty) argv_ty) (fun ptr_val ->
                  Mem.bind (Mem.store argv_ty ptr_val (Mem.array_mval $ List.map (Mem.pointer_mval argv_elem_ty) (List.reverse ptr_vals_rev))) (fun () ->
                    Mem.return ptr_val
                  )
                )
              ) dr_st >>= fun (argv_ptr_val, dr_st) ->
              
              ND.return $
                Core_aux.subst_syms [Just argc_sym; Just argv_sym]
                  (Core.PEval $ Core.Vtuple [Core.Vpointer argc_ptr_val; Core.Vpointer argv_ptr_val])
(*                  (Core.Etuple [Core.Econst $ Mem.mk_pointer argc_ptr_val; Core.Econst $ Mem.mk_pointer argv_ptr_val]) *)
                  expr
          | _ ->
              ND.return expr
        end >>= fun expr ->
        driver with_concurrency <| dr_st with
          core_state= update_thread_state tid0 <|
                        arena=  expr;
                        stack= Core_aux.push_empty_continuation Core_aux.empty_stack; (* TODO: this is probably unecessary *)
                        labels= Map.empty
                      |> dr_st.core_state
        |> >>= fun dr_st' ->
        
        if with_concurrency then
          let dr_st' = repair_pre_execution dr_st' in
          let n     = number_of_uncommitted dr_st'.concurrency_state in
          ND.log ("pre_ex: " ^ show dr_st'.concurrency_state.Cmm_op.symPre ^ "\n") >>
          ND.log ("Calling concurrency " ^ show n ^ " times\n") >>
          ND.apply_to_constraints (finalize_constraints dr_st'.core_file) (stepConcurrency n dr_st') >>= fun dr_st' ->
          ND.log ("with: " ^ show dr_st'.concurrency_state.Cmm_op.symWit ^ "\n") >>
          
          (* TODO: tmp *)
          ND.log (pp_exeState dr_st'.concurrency_state) >>
          
            (* TODO: the current function should return a Core.value inside an
               undef/error monad. Not a Core.pexpr like we currently do *)
            match dr_st'.concurrency_state.Cmm_op.symUndefinedness with
              | [] ->
                  let (str, (is_blocked, conc_st, cval), steps) = finalize "drive (with concur)" dr_st' in
(*                  ND.log ("Result: " ^ show (Core.Epure (Core.PEval cval)) ^ (if dr_st'.blocked then ", BLOCKED" else "") ^ "\n") >> *)
                  ND.return (str, (is_blocked, conc_st, Core.PEval cval), steps)
              | (Cmm.DataRaces _)::_ ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.Data_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.UnsequencedRaces _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.Unsequenced_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.IndeterminateReads _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.DUMMY),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.BadMutexes _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.DUMMY),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | Cmm.NotInSublanguage::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.DUMMY),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
            end
        else
          ND.return $
            (fun (str, (is_blocked, conc_st, cval), steps) -> (str, (is_blocked, conc_st, Core.PEval cval), steps)) (finalize "drive (without concur)" dr_st')
end
