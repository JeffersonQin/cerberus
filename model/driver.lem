open import Pervasives

import Core Core_ctype Boot UniqueId Decode
open import Global Show Core_run Core_run_aux
import Cmm_op Cmm_csem

import Translation_aux
import Enum State_exception_undefined Exception Undefined Nondeterminism Dlist


module Mem = struct
  include import Mem Mem_aux
end

import Driver_effect

module Cmm = Cmm_csem

(* The indirection is required because of a bug in Lem *)
module U = Undefined


module SEU = State_exception_undefined
module ND  = Nondeterminism



val stringFromPointerValue: Mem.pointer_value -> string
declare ocaml target_rep function stringFromPointerValue = `String_mem.string_of_pointer_value`

val stringFromMemValue: Mem.mem_value -> string
declare ocaml target_rep function stringFromMemValue = `String_mem.string_of_mem_value`

val stringPrettyFromMemValue: Mem.mem_value -> string
declare ocaml target_rep function stringPrettyFromMemValue = `String_mem.string_pretty_of_mem_value`

(* TODO: debug *)
val pp_core_state: forall 'a. core_state -> string
declare ocaml target_rep function pp_core_state = `String_core_run.string_of_core_state`









type driver_error = 
  | DERR_core_run of core_run_error

type driver_state = <|
  symbol_supply:     UniqueId.supply Symbol.t;
  
  core_file:         Core.file core_run_annotation;
  core_state:        core_state;       (* state of the core program *)
  core_run_state:    core_run_state;   (* state of the core evaluator *)
  layout_state:      Mem.mem_state;    (* state of memory layout model *)
  concurrency_state: Cmm_op.symState; (* state of the concurrency memory model *)
  
  symbolic_assoc: map Symbol.t Core.value;
  
  blocked: bool; (* concurrency model ended by blocking *)
  (* DEBUG *)
  trace: list string;
  dr_step_counter: nat;
|>

let driver_state_eq dr_st1 dr_st2 =
     dr_st1.core_state = dr_st2.core_state
  && dr_st1.layout_state = dr_st2.layout_state
(*  && dr_st1.concurrency_state = dr_st2.concurrency_state *) (* TODO *)

instance (Eq driver_state)
  let (=) = driver_state_eq
  let (<>) = fun x y -> not (driver_state_eq x y)
end



val aid_to_string: Cmm.action -> string
let aid_to_string a =
  show (Cmm.aid_of a)



open ND.Operators



val liftMem: forall 'a. Mem.memM 'a -> driver_state -> ND.t ('a * driver_state)
let liftMem m dr_st =
  ND.msum "liftMem" $ map (function
    | Left mem_err ->
        (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (liftMem) ==> " ^ show mem_err))
    | Right (z, layout_st') ->
        ND.return (z, <| dr_st with layout_state= layout_st' |>)
  end) (Mem.runMem m dr_st.layout_state)


(* BEGIN reads resolving ======================================================================== *)
val     resolve_read_pexpr: Symbol.t -> Symbolic.symbolic Core.value Mem.pointer_value -> Core.pexpr -> Core.pexpr
let rec resolve_read_pexpr write_sym symb_v pexpr =
  let fpe = resolve_read_pexpr write_sym symb_v in
  match pexpr with
    | Core.PEundef _ ->
        pexpr
    | Core.PEerror str pe ->
        Core.PEerror str (fpe pe)
    | Core.PEval (Core.Vsymbolic symb) ->
        Core.PEval (Core.Vsymbolic $ Symbolic.subst_sym write_sym symb_v symb)
    | Core.PEval _ ->
        pexpr
    | Core.PEsym _ ->
        pexpr
    | Core.PEimpl _ ->
        pexpr
    | Core.PEctor ctor (pes) ->
        Core.PEctor ctor (List.map fpe pes)
    | Core.PEcons pe1 pe2 ->
        Core.PEcons (fpe pe1) (fpe pe2)
    | Core.PEcase_list pe1 pe2 nm ->
        Core.PEcase_list (fpe pe1) (fpe pe2) nm
    | Core.PEcase_ctype pe1 pe2 nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8 ->
        Core.PEcase_ctype (fpe pe1) (fpe pe2) nm1 nm2 nm3 nm4 nm5 nm6 nm7 nm8
    | Core.PEarray_shift pe1 ty pe2 ->
        Core.PEarray_shift (fpe pe1) ty (fpe pe2)
    | Core.PEmember_shift pe tag_sym memb_ident ->
        Core.PEmember_shift (fpe pe) tag_sym memb_ident
    | Core.PEnot pe ->
        Core.PEnot (fpe pe)
    | Core.PEop bop pe1 pe2 ->
        Core.PEop bop (fpe pe1) (fpe pe2)
    | Core.PEmemop memop pes ->
        Core.PEmemop memop (List.map fpe pes)
    | Core.PEtuple pes ->
        Core.PEtuple (List.map fpe pes)
    | Core.PEarray pes ->
        Core.PEarray (List.map fpe pes)
    | Core.PEstruct sym xs ->
        Core.PEstruct sym (List.map (fun (ident, pe) -> (ident, fpe pe)) xs)
    | Core.PEcall nm pes ->
        Core.PEcall nm (List.map fpe pes)
    | Core.PElet sym pe1 pe2 ->
        Core.PElet sym (fpe pe1) (fpe pe2)
    | Core.PEif pe1 pe2 pe3 ->
        Core.PEif (fpe pe1) (fpe pe2) (fpe pe3)
    | Core.PEis_scalar pe ->
        Core.PEis_scalar (fpe pe)
    | Core.PEis_integer pe ->
        Core.PEis_integer (fpe pe)
    | Core.PEis_signed pe ->
        Core.PEis_signed (fpe pe)
    | Core.PEis_unsigned pe ->
        Core.PEis_unsigned (fpe pe)
  end


let rec resolve_read_expr write_sym symb_v expr =
  let fe  = resolve_read_expr write_sym symb_v in
  let fpe = resolve_read_pexpr write_sym symb_v in
  match expr with
    | Core.Epure pe ->
        Core.Epure (fpe pe)
    | Core.Ememop memop pes ->
        Core.Ememop memop (List.map fpe pes)
    | Core.Eraise _ ->
        expr
    | Core.Eregister _ _ ->
        expr
    | Core.Eskip ->
        expr
    | Core.Elet sym pe1 e2 ->
        Core.Elet sym (fpe pe1) (fe e2)
    | Core.Eif pe1 e2 e3 ->
        Core.Eif (fpe pe1) (fe e2) (fe e3)
    | Core.Eproc annot nm pes ->
        Core.Eproc annot nm (List.map fpe pes)
    | Core.Eaction pact ->
        Core.Eaction (resolve_read_paction write_sym symb_v pact)
    | Core.Eunseq es ->
        Core.Eunseq (List.map fe es)
    | Core.Ewseq _as e1 e2 ->
        Core.Ewseq _as (fe e1) (fe e2)
    | Core.Esseq _as e1 e2 ->
        Core.Esseq _as (fe e1) (fe e2)
    | Core.Easeq sym_opt act1 pact2 ->
        Core.Easeq sym_opt (resolve_read_action write_sym symb_v act1) (resolve_read_paction write_sym symb_v pact2)
    | Core.Eindet e ->
        Core.Eindet (fe e)
    | Core.Ebound i e ->
        Core.Ebound i (fe e)
    | Core.Esave ksym sym_tys e ->
        Core.Esave ksym sym_tys (fe e)
    | Core.Erun annot ksym sym_pes ->
        Core.Erun annot ksym (List.map (fun (sym, pe) -> (sym, fpe pe)) sym_pes)
    | Core.Eret pe ->
        Core.Eret (fpe pe)
    | Core.End es ->
        Core.End (List.map fe es)
    | Core.Epar es ->
        Core.Epar (List.map fe es)
    | Core.Ewait _ ->
        expr
  end

and resolve_read_paction write_sym symb_v (Core.Paction p act) =
  Core.Paction p (resolve_read_action write_sym symb_v act)

and resolve_read_action write_sym symb_v (Core.Action loc annots act_) =
  let fpe = resolve_read_pexpr write_sym symb_v in
  
  Core.Action loc annots $ match act_ with
  | Core.Create pe1 pe2 pref ->
      Core.Create (fpe pe1) (fpe pe2) pref
  | Core.Alloc pe1 pe2 pref ->
      Core.Alloc (fpe pe1) (fpe pe2) pref
  | Core.Kill pe ->
      Core.Kill (fpe pe)
  | Core.Store pe1 pe2 pe3 mo ->
      Core.Store (fpe pe1) (fpe pe2) (fpe pe3) mo
  | Core.Load pe1 pe2 mo ->
      Core.Load (fpe pe1) (fpe pe2) mo
  | Core.RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.RMW (fpe pe1) (fpe pe2) (fpe pe3) (fpe pe4) mo1 mo2
(*
  | Core.CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeStrong (fpe pe1) (fpe pe2) (fpe pe3) (fpe pe4) mo1 mo2
  | Core.CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
      Core.CompareExchangeWeak (fpe pe1) (fpe pe2) (fpe pe3) (fpe pe4) mo1 mo2
*)
  end




let rec resolve_read_continuation write_sym symb_v cont =
  List.map (function
    | Core.Kunseq es1 es2 ->
        Core.Kunseq (List.map (resolve_read_expr write_sym symb_v) es1) (List.map (resolve_read_expr write_sym symb_v) es2)
    | Core.Kwseq _as e2 ->
        Core.Kwseq _as (resolve_read_expr write_sym symb_v e2)
    | Core.Ksseq _as e2 ->
        Core.Ksseq _as (resolve_read_expr write_sym symb_v e2)
  end) cont



let rec resolve_read_stack write_sym symb_v = function
  | Core.Stack_empty ->
      Core.Stack_empty
  | Core.Stack_cons cont sk ->
      Core.Stack_cons (resolve_read_continuation write_sym symb_v cont) (resolve_read_stack write_sym symb_v sk)
end


val resolve_read: Symbol.t -> Symbolic.symbolic Core.value Mem.pointer_value -> core_state -> core_state
let resolve_read write_sym symb_v core_st =
  (* let _ = Boot.output_string $ "RESOLVING: " ^ Boot.pp_core_expr ((Core.Etuple [Core.Esym write_sym; Core.Econst v]) : Core.expr unit) ^ "\n" in *)
  <| core_st with
       thread_states= List.map (fun (tid, (parent_tid_opt, th_st)) ->
                       (tid, (parent_tid_opt, <| th_st with arena= resolve_read_expr write_sym symb_v th_st.arena;
                                                            stack= resolve_read_stack write_sym symb_v th_st.stack; |>))
                     ) core_st.thread_states
  |>



(* END reads resolving ========================================================================= *)


let add_to_concur_sym_map sym cval concur_sym_map =
  match cval with
    | Core.Vsymbolic (Symbolic.SYMBsym _ sym') ->
        match Map.lookup sym' concur_sym_map with
        | Just cval' ->
            let _ = Boot.print_debug 2 ("ADDING TO ASSOC ==> " ^ show sym ^ " := " ^ stringFromValue cval') in
            Map.insert sym cval' concur_sym_map
          | Nothing ->
              let _ = Boot.print_debug 2 ("ADDING TO ASSOC ==> " ^ show sym ^ " := " ^ stringFromValue cval) in
              Map.insert sym cval concur_sym_map
        end
    | _ ->
        let _ = Boot.print_debug 2 ("ADDING TO ASSOC ==> " ^ show sym ^ " := " ^ stringFromValue cval) in
        Map.insert sym cval concur_sym_map
  end




(* Perform a given number of successive steps of the concurrency model *)
val     stepConcurrency: nat -> driver_state -> ND.t driver_state
let rec stepConcurrency n dr_st =
  if n = 0 then
    ND.return dr_st
  else begin
    Cmm_op.symStep dr_st.concurrency_state >>=  function
      | Cmm_op.ConcurrencyTau performed_act concur_st' ->
(*          ND.log ("ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act) ^ "\n")           >> (* DEBUG *) *)
          ND.print_debug 4 ("ConcurrencyTau with aid: " ^ show (Cmm.aid_of performed_act) ^ "\n") >> (* DEBUG *)
          ND.return  <| dr_st with concurrency_state= concur_st' |>
      
      (* TODO: the variables names seems completely messed up here *)
      | Cmm_op.ReadsFrom (new_concrete_mval: Mem.mem_value) (previous_symbolic_mval: Mem.mem_value) performed_act concur_st' ->
          ND.print_debug 2 ("ReadsFrom with aid: " ^ aid_to_string performed_act ^ "\n") >> (* DEBUG *)
          
          let new_concrete_cst = Symbolic.SYMBconst (Core_aux.valueFromMemValue new_concrete_mval) in
          let (Symbolic.SYMBsym _ previous_sym as previous_symb) = fromJust "stepConcurrency" $
            maybe Nothing (fun z -> Just (Symbolic.map_const Core_aux.valueFromMemValue z)) (Mem.symbolicFromMemValue previous_symbolic_mval) in
          
          ND.add_constraint (Constraints.assert_eq previous_symb new_concrete_cst) >>
          
          ND.print_debug 2 ("ReadsFrom: " ^ show previous_sym ^ " = " ^ stringFromMemValue new_concrete_mval) >>
          ND.return <| dr_st with
            concurrency_state= concur_st';
            core_state= (* resolve_read previous_sym new_concrete_cst *) dr_st.core_state;
            symbolic_assoc= add_to_concur_sym_map previous_sym (Core_aux.valueFromMemValue new_concrete_mval) dr_st.symbolic_assoc;
          |>

(*
          match maybe Nothing (fun z -> Just (Symbolic.map_const Core_aux.valueFromMemValue z)) (Mem.symbolicFromMemValue mval) with
            | Nothing ->
                error ("stepConcurency fail: " ^ stringFromMemValue mval)
            | Just mval_symb ->
                let w_cst = Symbolic.SYMBconst (Core_aux.valueFromMemValue w) in
                ND.add_constraint (Constraints.assert_eq w_cst mval_symb) >>
                
                match mval_symb with
                  | Symbolic.SYMBsym _ r_sym ->
                      ND.print_debug 1 ("ReadsFrom: " ^ show r_sym ^ " = " ^ stringFromMemValue w) >>
                      ND.return <| dr_st with
(*                                  symbolic_assoc= Map.insert r_sym n dr_st.symbolic_assoc; *)
                        concurrency_state= concur_st';
                        core_state= resolve_read r_sym w_cst dr_st.core_state;
                      |> 
                  | _ ->
                      error "stepConcurrency, ReadsFrom, not a symbol"
                end
*)




(*
                match Mem.integerValueFromMemValue w with
                  | Just (_, ival) ->
                      Mem.case_integer_value ival
                        (fun n ->
                          ND.add_constraint (Constraints.assert_eq (Symbolic.SYMBconst n) mval_symb) >>
                          
                          match mval_symb with
                            | Symbolic.SYMBsym _ r_sym ->
                                ND.print_debug 1 ("ReadsFrom: " ^ show r_sym ^ " = " ^ show n) >>
                                ND.return <| dr_st with
(*                                  symbolic_assoc= Map.insert r_sym n dr_st.symbolic_assoc; *)
                                  concurrency_state= concur_st';
                                  core_state= resolve_read r_sym (Symbolic.SYMBconst n) dr_st.core_state;
                                |> 
                            | _ ->
                                error "stepConcurrency, ReadsFrom, not a symbol"
                          end
                    
(*
                    ND.return   <| dr_st with concurrency_state= concur_st' |> 
*)
                        )
                        (fun () -> error "WIP[Driver.stepConcurrency]: complex ival, ReadsFrom")
                  | Nothing ->
(*                      let w_symb = fromJust "Driver.stepConcurrency" (Mem.symbolicFromMemValue w) in *)
                      let w_symb = Symbolic.map_const (Core_aux.valueFromMemValue (fromJust "Driver.stepConcurrency" (Mem.symbolicFromMemValue w))) in
                          ND.add_constraint (Constraints.assert_eq w_symb mval_symb) >>
                          
                          match mval_symb with
                            | Symbolic.SYMBsym _ r_sym ->
                                ND.print_debug 1 ("ReadsFrom: " ^ show r_sym ^ " = " ^ show w_symb) >>
                                ND.return <| dr_st with
                                  concurrency_state= concur_st';
                                  core_state= resolve_read r_sym w_symb dr_st.core_state;
                                |> 
                            | _ ->
                                error "stepConcurrency, ReadsFrom, not a symbol"
                          end
                end
*)

    end
  end >>= stepConcurrency (n-1)













  

(* NOTE: can't use the Set-based monad from Ky because I would need to define
         a compare function for the type core_step ... *)



val runCore: forall 'a. (* SetType 'a => *) core_runM 'a -> driver_state -> ND.t ('a * driver_state)
let runCore m dr_st =
  match SEU.run m dr_st.core_run_state with
    | Exception.Result (U.Defined z, run_st') ->
        ND.return (z, <| dr_st with core_run_state= run_st' |>)
    
    | Exception.Result (U.Undef ubs, _) ->
        ND.kill (ND.Undef ubs)
    
    | Exception.Result (U.Error str, _) ->
        ND.kill (ND.Error str)
    
    | Exception.Exception err ->
        ND.kill (ND.Other $ "WIP Driver.runCore: runtime error ==> " ^ show err)
  end

(*
val runCore2: forall 'a. core_runM 'a -> driver_state -> (EU.t 'a core_run_error * driver_state)
let runCore2 m dr_st =
  let (ret, run_st') = SEU.run m dr_st.core_run_state in
  (ret, <| dr_st with core_run_state= run_st' |>)
*)





(* Returns the number of uncommitted action in the concurency memory model state *)
val number_of_uncommitted: Cmm_op.symState -> nat
let number_of_uncommitted concur_st =
  Set.size concur_st.Cmm_op.symPre.Cmm.actions - List.length concur_st.Cmm_op.symCommitted






(*
val drive_to_requests: Thread.thread_id -> core_state -> ND.t action_request
let drive_to_requests tid core_st = 
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        (tid, z)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  match core_thread_step dr_st.core_file th_info dr_st.core_state with
(*
  | Step_action_request of (* DEBUG *) string * thread_id * core_runM action_request
*)
  | Step_tau dedug_str tid step_m ->
      error "runCore"
(*
  | Step_thread_done of thread_id * core_runM core_state
  | Step_eval of (* DEBUG *) string * thread_id * core_runM core_state
  | Step_nd of string * list core_step
*)
  | Step_blocked ->
      error "ND.return core_st"
(*
  | Step_branch of (* DEBUG *) string * thread_id * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM core_state * core_runM core_state
  | Step_done of Core.value
  | Step_spawn_threads of thread_id * thread_state * list thread_state
*)

(*
    | Step_nd debug_str steps ->
        ND.foldM (fun core_st_acc step ->
          drive_to_requests tid core_st_acc
        ) dr_st.core_state steps
*)
  end
*)


val     load_string: Mem.pointer_value -> list char -> Mem.memM (list char)
let rec load_string ptr_val acc =
  let ty = Core_ctype.Pointer AilTypes.no_qualifiers (Core_ctype.char) in
  let ptr_val' = Mem.array_shift_ptrval ptr_val Core_ctype.char (Mem.integer_ival 1) in
  Mem.bind (Mem.load ty ptr_val) (fun mval ->
    Mem.case_mem_value mval
      (fun _ -> error "Driver.load_string, Symbolic")
      (fun _ -> error "Driver.load_string, found a ctype")
      (fun ity ival ->
        Mem.case_integer_value ival
          (fun n -> if n = 0 then
            Mem.return (List.reverse acc)
          else
            load_string ptr_val' ((Decode.encode_character_constant n) :: acc))
          (fun () -> error "WIP: Driver.load_string, non constant ival")
      )
      (fun _ _ -> error "Driver.load_string, found a float")
      (fun _ ptr_val -> error ("Driver.load_string, found a pointer ==> " ^ stringFromPointerValue ptr_val))
      (fun _ -> error "Driver.load_string, found an array")
      (fun _ _ -> error "Driver.load_string, found a struct")
      (fun _ _ -> error "Driver.load_string, found a union")
  )

(* TODO: hack *)
val printf_loader: driver_state -> list Core_ctype.ctype -> list Core.value -> (list string -> string) -> ND.t (string * driver_state)
let printf_loader dr_st ty args mk_str =
  ND.foldM (fun (acc, dr_st') (ty, Core.Vpointer ptr_val) ->
    match ty with
      (* TODO: this is yucky *)
      | Core_ctype.Pointer _ (Core_ctype.Basic (AilTypes.Integer (AilTypes.Char))) ->
          liftMem (Mem.load ty ptr_val) dr_st' >>= fun (mval, dr_st'') ->
          match Mem_aux.pointerValueFromMemValue mval with
            | Just (_, ptr_val) ->
                liftMem (load_string (Mem.array_shift_ptrval ptr_val Core_ctype.char (Mem.integer_ival 0)) [])
                  dr_st' >>= fun (chars, dr_st'') ->
                ND.return (String.toString chars :: acc, dr_st'')
            | Nothing ->
                error "WIP[error message], Driver.printf_loader, char*"
          end
      | _ ->
          liftMem (Mem.load ty ptr_val) dr_st' >>= fun (mval, dr_st'') ->
          if AilTypesAux.is_integer (Core_aux.unproj_ctype ty) then
            let pe_conv =
              Translation_aux.mk_stdcall dr_st''.core_file.Core.stdlib "conv_int"
                [Core.PEval (Core.Vctype ty); Core.PEval (Core_aux.valueFromMemValue mval)] in
            match Core_run.full_core_eval dr_st''.core_file dr_st''.symbolic_assoc false pe_conv with
              | Exception.Result (Undefined.Defined cval) ->
                  ND.return (stringPrettyFromMemValue (fromJust "Driver.printf_loader" $ Core_aux.memValueFromValue ty cval) :: acc, dr_st'')
              | _ ->
                  error "WIP[error] printf_loader"
            end
          else
            ND.return (stringPrettyFromMemValue mval :: acc, dr_st'')

(*
val     core_eval: Core.file core_run_annotation -> bool -> Core.pexpr ->
                   EU.t Core.pexpr core_run_error
*)

          
    end
  ) ([], dr_st) (List.zip ty args) >>= fun (strs, dr_st') ->
  ND.return (mk_str strs, dr_st')

(*
  ND.foldM (fun (mem_st', acc) (ty, Core.Vpointer ptr_val) ->
    match ty with
      (* TODO: this is yucky *)
      | Core_ctype.Pointer _ (Core_ctype.Basic (AilTypes.Integer (AilTypes.Char))) ->
          load_string mem_st' ptr_val >>= fun (mem_st'', chars) ->
          ND.return (mem_st'', String.toString chars :: acc)
      | _ ->
          ND.msum $ map (function
            | Left err ->
                error "WIP: printf_loader, memory error"
            | Right (mval, mem_st'') ->
                ND.return (mem_st'', stringPrettyFromMemValue mval :: acc)
          end) (Mem.runMem (Mem.load ty ptr_val) mem_st')
    end
  ) (mem_st, []) (List.zip ty args) >>= fun (mem_st', strs) ->
  ND.return (mem_st', mk_str strs)
*)

(* For a given thread, perform all possible step that are not action requests *)
val     drive_core_thread: Thread.thread_id -> driver_state -> ND.t driver_state
let rec drive_core_thread tid dr_st =
  let th_info = match List.lookup tid dr_st.core_state.thread_states with
    | Just z ->
        z (* (tid, z) *)
    | _ ->
        error "drive_core_thread, wrong tid"
  end in
  ND.msum "drive_core_thread" $ List.map (function
    | Step_action_request _ ->
        (* DEBUG *) ND.print_debug 6 (">> ACTION_REQUEST") >>
        ND.return dr_st
    | Step_memop_request _ _ _ _ ->
        ND.return dr_st
    | Step_tau debug_str step_m ->
        let () = Boot.begin_timing ("tau: " ^ debug_str) in (* DEBUG, PROFILING *)
        let pre_arena = (* DEBUG *)
          (snd $ fromJust "Driver.drive_core_thread" (List.lookup tid dr_st.core_state.thread_states)).arena in
        (* DEBUG *) ND.print_debug 6 ("tau(tid_" ^ show tid ^ "): " ^ debug_str ^ " with arena= " ^
        (* DEBUG *)                   Boot.pp_core_expr pre_arena) >>
        (* case where the Core program does a non pure but non memory-related
           step (typically ordering related stuff) *)
        runCore step_m dr_st >>= fun (th_st', dr_st') ->
        let () = Boot.end_timing () in (* DEBUG, PROFILING *)
        drive_core_thread tid <| dr_st' with
          core_state= update_thread_state tid th_st' dr_st'.core_state;
          dr_step_counter= dr_st'.dr_step_counter + 1
        |>
    | Step_eval debug_str step_m ->
        let () = Boot.begin_timing ("eval: " ^ debug_str) in (* DEBUG, PROFILING *)
        (* DEBUG *) ND.print_debug 6 ("eval(tid_" ^ show tid ^ "): " ^ debug_str) >>
        (* case where the Core program does a pure step *)
        runCore step_m dr_st >>= fun (th_st', dr_st') ->
        let () = Boot.end_timing () in (* DEBUG, PROFILING *)
        drive_core_thread tid <| dr_st' with
          core_state= update_thread_state tid th_st' dr_st'.core_state;
          dr_step_counter= dr_st'.dr_step_counter + 1
        |>
    
    | Step_thread_done parent_tid cval ->
        (* DEBUG *) ND.print_debug 6 ("thread " ^ show tid ^ " is done") >>
        (* case where the current (non startup) thread execution ended. *)
        
(*
        let actions_of_current_threads =
          Set.map Cmm.aid_of (
            Set.filter (fun act -> Cmm.tid_of act = tid) $ dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions
          ) in
*)
        let actions_of_current_thread: set Cmm.action =
          Set.filter (fun act -> Cmm.tid_of act = tid) $ dr_st.concurrency_state.Cmm_op.symPre.Cmm.actions in
        let last_actions_of_current_thread: set Cmm.action =
          Set.filter (fun act ->
            not (Set.any (fun (act', _) -> act = act') dr_st.concurrency_state.Cmm_op.symPre.Cmm.sb)
          ) actions_of_current_thread in

        
        (* DEBUG *)
(*
        let concur_st' =
          <| dr_st.concurrency_state with
            Cmm_op.symPre= <| dr_st.concurrency_state.Cmm_op.symPre with
              Cmm.asw= Set.map (fun act -> (act, act)) last_actions_of_current_thread union dr_st.concurrency_state.Cmm_op.symPre.Cmm.asw
            |>
          |> in
*)
        ND.return <| dr_st with
          core_state= kill_thread tid parent_tid (Set.map Cmm.aid_of last_actions_of_current_thread) cval dr_st.core_state;
          dr_step_counter= dr_st.dr_step_counter + 1;
(*          concurrency_state= concur_st'; *)
        |> >>=
          drive_core_thread parent_tid
    
    | Step_blocked ->
        (* error "WIP: Step_blocked" *) ND.return dr_st
    | Step_error debug_str ->
        error ("WIP: Step_error --> " ^ debug_str)
    | Step_branch debug_str mk_constr_then mk_constr_else step_then step_else ->
        ND.print_debug 6 ("Step_branch(" ^ debug_str ^ ")") >>
        ND.mplus
          begin
            ND.add_constraint mk_constr_then >>
            runCore step_then dr_st >>= fun (th_st', dr_st') ->
            drive_core_thread tid <| dr_st' with
              core_state= update_thread_state tid th_st' dr_st'.core_state;
              dr_step_counter= dr_st'.dr_step_counter + 1
            |>
          end
          begin
            ND.add_constraint mk_constr_else >>
            runCore step_else dr_st >>= fun (th_st', dr_st') ->
            drive_core_thread tid <| dr_st' with
              core_state= update_thread_state tid th_st' dr_st'.core_state;
              dr_step_counter= dr_st'.dr_step_counter + 1
            |>
          end


    | Step_done cval ->
        ND.return dr_st
    | Step_spawn_threads mk_th_st th_sts ->
        ND.print_debug 6 "Step_spawn_threads" >>
        let ((th_tids, core_st'), run_st') = State.run (
          State.foldM (fun (th_tids_, core_st_) th_st ->
            State.bind (spawn_thread (Just tid) th_st core_st_)
              (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
          ) ([], dr_st.core_state) th_sts
        ) dr_st.core_run_state in
        
        let dr_st' = <| dr_st with
          core_run_state= run_st';
          core_state= update_thread_state tid
                        (mk_th_st (Core.Eunseq $ List.reverse (List.map (fun z -> Core.Ewait z) th_tids)))
                        core_st';
        |> in
        
        ND.foldM (fun acc tid ->
          drive_core_thread tid acc
        ) dr_st' th_tids >>= fun dr_st'' ->
        
        drive_core_thread tid dr_st''


    | Step_output debug_str str th_st' ->
        ND.print_debug 6 ("Step_output [" ^ debug_str ^ "] ==> " ^ str) >>
        let core_st' = update_thread_state tid th_st' dr_st.core_state in
        drive_core_thread tid <| dr_st with
          core_state= <| core_st' with
            io= <| dr_st.core_state.io with stdout= Dlist.append (Dlist.singleton str) dr_st.core_state.io.stdout |>
          |>;
          dr_step_counter= dr_st.dr_step_counter + 1;
        |>
    | Step_printf tys args mk_str mk_th_st ->
        ND.print_debug 6 ("Step_printf") >>
        printf_loader dr_st tys args mk_str >>= fun (str, dr_st') ->
        let core_st' = update_thread_state tid (mk_th_st (integerFromNat (String.stringLength str))) dr_st'.core_state in
        drive_core_thread tid <| dr_st' with
          core_state= <| core_st' with
            io= <| dr_st'.core_state.io with stdout= Dlist.append (Dlist.singleton str) dr_st'.core_state.io.stdout |>
          |>;
          dr_step_counter= dr_st'.dr_step_counter + 1;
        |>
        
  end) (core_thread_step2 dr_st.core_file dr_st.symbolic_assoc tid th_info)

(*
  match core_thread_step dr_st.core_file th_info dr_st.core_state with

(*
    | Step_nd debug_str step_ms ->
(*        runCore2  *)
        ND.print_debug 9 ("drive_core_thread (" ^ show tid ^ ") ==> Step_nd " ^ debug_str) >> (* DEBUG *)
        ND.foldM (fun acc step_m ->
          runCore step_m acc >>= fun (core_st', dr_st') ->
          let acc' = <| dr_st' with core_state= core_st'; dr_step_counter= dr_st'.dr_step_counter + 1 |> in
          ND.tryM (drive_core_thread tid acc')
            (fun () -> ND.return acc')
        ) dr_st step_ms
*)
        

    | Step_spawn_threads parent_tid parent_th_st th_sts ->
        let ((th_tids, core_st'), run_st') = State.run (
          State.foldM (fun (th_tids_, core_st_) th_st ->
            State.bind (spawn_thread (Just parent_tid) th_st core_st_)
              (fun (tid, core_st_') -> State.return (tid :: th_tids_, core_st_'))
          ) ([], dr_st.core_state) th_sts
        ) dr_st.core_run_state in
        
        let dr_st' = <| dr_st with
          core_run_state= run_st';
          core_state= update_thread_state parent_tid <| parent_th_st with
                        arena= Core.Eunseq $ List.reverse (List.map (fun z -> Core.Ewait z) th_tids)
                      |> core_st';
        |> in
        
        ND.foldM (fun acc tid ->
          drive_core_thread tid acc
        ) dr_st' th_tids >>= fun dr_st'' ->
        
        drive_core_thread parent_tid dr_st''

(*    
  | Step_branch of (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_step * core_step
*)        

    | Step_branch debug_str parent_tid mk_then_constrs mk_else_constrs step_then_m step_else_m ->
        ND.mplus
          begin
            ND.add_constraint mk_then_constrs >>
            runCore step_then_m dr_st >>= fun (core_st', dr_st') ->
            drive_core_thread tid <| dr_st' with core_state= core_st'; dr_step_counter= dr_st'.dr_step_counter + 1 |>
          end
          begin
            ND.add_constraint mk_else_constrs >>
            runCore step_else_m dr_st >>= fun (core_st', dr_st') ->
            drive_core_thread tid <| dr_st' with core_state= core_st'; dr_step_counter= dr_st'.dr_step_counter + 1 |>
          end
  end
*)


(* perform drive_core_thread for all the core threads *)
val     drive_core_threads: driver_state -> ND.t driver_state
let rec drive_core_threads dr_st =
  ND.foldM (fun acc (tid, _) ->
(*
    ND.tryM (drive_core_thread tid acc)
      ND.return
      (fun () -> ND.return acc)
*)
    ND.print_debug 9 "BEFORE drive_core_thread, in drive_core_threads" >>
    drive_core_thread tid acc
  ) dr_st dr_st.core_state.thread_states




let repair_pre_execution dr_st =
  let repair preEx =
    <| preEx with Cmm.asw=
      Set.filter (fun (a,c) ->
        not (
          Set.any (fun b -> a <> b && Relation.inRel a b preEx.Cmm.sb

&& Relation.inRel b c preEx.Cmm.asw

) preEx.Cmm.actions
        )
      ) preEx.Cmm.asw


|>
  in
  <| dr_st with concurrency_state=
    <| dr_st.concurrency_state with Cmm_op.symPre= repair dr_st.concurrency_state.Cmm_op.symPre |>
  |>



val update_core_state: core_state -> driver_state -> driver_state
let update_core_state core_st dr_st =
  <| dr_st with core_state= core_st |>

val update_core_run_state: core_run_state -> driver_state -> driver_state
let update_core_run_state run_st dr_st =
  <| dr_st with core_run_state= run_st |>




(* ========================================================================== *)


val action_request_concurrency: driver_state -> action_request -> ND.t driver_state
let action_request_concurrency dr_st = function
  | AllocRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST ALLOC" in
      (* TODO: hack, hack, hack *)
      ND.msum "action_request_concurrency, Alloc" $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (alloc seq) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' ptr_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_dynamic tid pref align_ival size_ival) dr_st.layout_state)
  
  | CreateRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty mk_th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST CREATE" in
      (* TODO: hack, hack, hack *)
      ND.msum "action_request_concurrency, Create" $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (create seq) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' ptr_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_static tid pref align_ival lvalue_ty) dr_st.layout_state)
  
  | StoreRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val mem_val th_st' ->
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Store aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.return <| dr_st with
        core_state=   update_thread_state tid th_st' dr_st.core_state;
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "store" :: dr_st.trace
      |>
  
  | LoadRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val sym mk_th_st' ->
      let mval = Mem.symbolic_mval (Symbolic.SYMBsym Symbolic.SYMBint sym) in
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Load aid tid mo ptr_val mval;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic lvalue_ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      
      ND.return <| dr_st with
        core_state= update_thread_state tid (mk_th_st' mval) dr_st.core_state;
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "store" :: dr_st.trace
      |>
  
  | KillRequest loc sb_edges dd_edges asw_edges aid tid ptr_val th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST KILL" in
      ND.return <| dr_st with
        core_state= update_thread_state tid th_st' dr_st.core_state;
        (* TODO: the kill ... *)
      |>

  | _ ->
      error "WIP: Driver.action_request_concurrency"
(*
  | StoreRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val mem_val core_st' ->
      ND.print_debug 4 ("StoreRequest on: " ^ stringFromPointerValue ptr_val ^ " := " ^ stringFromMemValue mem_val) >>
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Store aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      let dr_st' = update_core_state core_st' dr_st in
      
      ND.return <| dr_st' with
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "store" :: dr_st.trace
      |>

  | LoadRequest sb_edges dd_edges asw_edges aid tid mo ty ptr_val sym mk_core_st' ->
(*          let (sym, dr_st) = fresh_symbol dr_st in *)
      ND.print_debug 4 ("LoadRequest on: " ^ stringFromPointerValue ptr_val) >>
      (* ND.log "LOAD\n" >> *)
      
      let mem_val = Mem.symbolic_mval (Symbolic.SYMBsym Symbolic.SYMBint sym) in
      let preEx_step = <|
          Cmm_op.newAction=    Cmm.Load aid tid mo ptr_val mem_val;
          Cmm_op.sbBefore=     sb_edges;
          Cmm_op.ddBefore=     dd_edges;
          Cmm_op.aswBefore=    asw_edges;
          Cmm_op.locationKind= Just (if Core_ctype.is_atomic ty then Cmm.Atomic else Cmm.Non_Atomic);
      |> in
      let dr_st' = update_core_state (mk_core_st' mem_val) dr_st in
      
      ND.return <| dr_st' with
        concurrency_state= Cmm_op.symUpdatePreEx dr_st.concurrency_state preEx_step;
        trace= "load" :: dr_st.trace
      |>
  
  | AllocRequest _ _ _ _ tid pref align_ival size_ival mk_core_st' ->
      (* TODO: hack, hack, hack *)
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (alloc concur) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   mk_core_st' ptr_val;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_dynamic tid pref align_ival size_ival) dr_st.layout_state)
  
  | CreateRequest _ _ _ _ tid pref align_ival lvalue_ty mk_core_st' ->
      (* TODO: hack, hack, hack *)
      ND.msum $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (create concur) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   mk_core_st' ptr_val;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_static tid pref align_ival lvalue_ty) dr_st.layout_state)
*)
end




(* This version only uses the memory layout model (note that is deterministic) *)
val action_request_sequential: driver_state -> action_request -> ND.t driver_state
let action_request_sequential dr_st = function
  | AllocRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival size_ival mk_th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST ALLOC" in
      ND.msum "action_request_sequential, Alloc" $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (alloc seq) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' ptr_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_dynamic tid pref align_ival size_ival) dr_st.layout_state)
  
  | CreateRequest loc sb_edges dd_edges asw_edges aid tid pref align_ival lvalue_ty mk_th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST CREATE" in
      ND.msum "action_request_sequential, Create" $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (create seq) ==> " ^ show mem_err))
        | Right (ptr_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' ptr_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.allocate_static tid pref align_ival lvalue_ty) dr_st.layout_state)
  
  | LoadRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val _ mk_th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST LOAD" in
      ND.msum "action_request_sequential, Load" $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (load seq) ==> " ^ show mem_err))
        | Right (mem_val, layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid (mk_th_st' mem_val) dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.load lvalue_ty ptr_val) dr_st.layout_state)
  
  | StoreRequest loc sb_edges dd_edges asw_edges aid tid mo lvalue_ty ptr_val mem_val th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST STORE" in
      (* TODO: need to make memory layout detect unsequenced races (use to make
         the concurency to the check even in the sequential mode) *)
      ND.msum "action_request_sequential, Store" $ map (function
        | Left mem_err ->
            (* TODO: map memory error to something sensible ... *)
            ND.kill (ND.Other ("memory layout error (store seq) ==> " ^ show mem_err))

        | Right ((), layout_st') ->
            ND.return <| dr_st with
              core_state=   update_thread_state tid th_st' dr_st.core_state;
              layout_state= layout_st'
            |>
      end) (Mem.runMem (Mem.store lvalue_ty ptr_val mem_val) dr_st.layout_state)
  
  | RMWRequest loc sb_edges dd_edges asw_edges aid tid mo1 mo2 lvalue_ty ptr_val mval_expected mval_actual th_st' ->
      error "WIP: Driver.seq ==> RMWRequest"

  | KillRequest loc sb_edges dd_edges asw_edges aid tid ptr_val th_st' ->
      let _ = Boot.print_debug_located 3 loc "REQUEST KILL" in
      ND.return <| dr_st with
        core_state= update_thread_state tid th_st' dr_st.core_state;
        (* TODO: the kill ... *)
      |>
end








val     driver: bool -> driver_state -> ND.t driver_state
let rec driver with_concurrency dr_st =
  let process_core_step2 dr_st = function
  | Step_action_request request_m ->
      (* DEBUG *) ND.print_debug 9 "Step_action_request" >>
      runCore request_m dr_st >>= fun (request, dr_st') ->
      
      let execution_mode_is_random = match ND.current_execution_mode () with
        | Nothing   -> false
        | Just mode -> mode = ND.Random
      end in
      
      begin
        if with_concurrency then
          action_request_concurrency dr_st' request >>= fun dr_st'' ->
          if execution_mode_is_random then
            let total = number_of_uncommitted dr_st''.concurrency_state in
            let choices = Enum.enumFromTo 0 total in
            
            (* DEBUG *)
            let _ = if choices = [] then error "BOOM" else () in
            
            ND.pick "driver 1" choices >>= fun n ->
            ND.warns_if_no_active_ex (stepConcurrency n dr_st'')
          else
            ND.return dr_st''
        else
          action_request_sequential dr_st' request
      end >>= fun dr_final ->
      driver with_concurrency dr_final
  | Step_memop_request memop cvals tid mk_th_st ->
      match (memop, cvals) with
        | (Mem_common.Ptrdiff, [Core.Vpointer ptr_val1; Core.Vpointer ptr_val2]) ->
            let cval = Core.Vinteger (Mem.diff_ptrval ptr_val1 ptr_val2) in
            driver with_concurrency <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st.core_state |>
        | (Mem_common.IntFromPtr, [Core.Vctype ref_ty; Core.Vctype (Core_ctype.Basic (AilTypes.Integer ity)); Core.Vpointer ptr_val]) ->
            let cval = Core.Vinteger (Mem.intcast_ptrval ref_ty ity ptr_val) in
            driver with_concurrency <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st.core_state |>
        | (Mem_common.PtrFromInt, [Core.Vctype ty; Core.Vctype ref_ty; Core.Vinteger ival]) ->
            let cval = Core.Vpointer (Mem.ptrcast_ival ty ref_ty ival) in
            driver with_concurrency <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st.core_state |>
        | (Mem_common.PtrValidForDeref, [Core.Vpointer ptr_val]) ->
            let cval = if Mem.validForDeref_ptrval ptr_val then Core.Vtrue else Core.Vfalse in
            driver with_concurrency <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st.core_state |>

(*
        | (Mem_common.Ptrdiff, _) ->
            error ("memop request: ptrdiff operand error ==> " ^
                   Boot.pp_core_expr ((Core.Epure (Core.PEval (Core.Vtuple cvals))): Core.expr unit))
*)

        | (Mem_common.PtrEq, [Core.Vpointer ptr_val1; Core.Vpointer ptr_val2]) ->
            liftMem (Mem.eq_ptrval Symbolic.Constraints_TODO ptr_val1 ptr_val2) dr_st >>= fun (is_eq, dr_st') ->
            let cval = if is_eq then Core.Vtrue else Core.Vfalse in
            driver with_concurrency <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st'.core_state |>
        
        | (Mem_common.PtrEq, [Core.Vsymbolic symb1; Core.Vpointer ptr_val2]) ->
            let cval = Core.Vsymbolic (Symbolic.SYMBop Symbolic.Eq symb1 (Symbolic.SYMBptrval ptr_val2)) in
            driver with_concurrency <| dr_st with core_state= update_thread_state tid (mk_th_st cval) dr_st.core_state |>
        
        | _ ->
            error ("WIP memop request: " ^ show memop ^ " ==> " ^
                   Boot.pp_core_expr ((Core.Epure (Core.PEval (Core.Vtuple cvals))): Core.expr unit))
      end
  | Step_tau debug_str _ ->
      error ("FOUND A TAU: '" ^ debug_str ^ "'")
  | Step_eval debug_str _ ->
      error ("FOUND AN EVAL: '" ^ debug_str ^ "'")

(*
  | Step_thread_done of thread_id * Core.value
  | Step_blocked
  | Step_error of string
  | Step_branch of (* DEBUG *) string * (Constraints.t -> Constraints.t) * (Constraints.t -> Constraints.t) * core_runM thread_state * core_runM thread_state
*)
  | Step_done cval ->
      ND.print_debug 3 ("driver.process_core_step ==> Step_done with value: " ^ Boot.pp_core_expr (Core.Epure (Core.PEval cval) : Core.expr unit)) >> (* DEBUG *)
      ND.return dr_st
(*
  | Step_spawn_threads of list thread_state (* initial states for the children *)
*)
  | _ ->
      error "Driver.driver, wrong Step_"
  end in
(*
  let process_core_step dr_st = function
    | Step_action_request debug_str tid request_m ->
        ND.print_debug 9 ("Step_action_request[" ^ debug_str ^ "]") >>
        runCore request_m dr_st >>= fun (request, dr_st') ->
        
        let execution_mode_is_random =
          match ND.current_execution_mode () with
          | Nothing   -> false
          | Just mode -> mode = ND.Random
          end in
        
        begin
          if with_concurrency then
            action_request_concurrency dr_st' request >>= fun dr_st'' ->
            if execution_mode_is_random then
              let total = number_of_uncommitted dr_st''.concurrency_state in
              let choices = Enum.enumFromTo 0 total in
              
              (* DEBUG *)
              let _ = if choices = [] then error "BOOM" else () in
              
              ND.pick choices >>= fun n ->
              ND.warns_if_no_active_ex (stepConcurrency n dr_st'')
            else
              ND.return dr_st''
          else
            error "action_request_sequential dr_st' request"
        end >>= fun dr_final ->
        driver with_concurrency dr_final



    | Step_done cval ->
        ND.print_debug 3 ("driver.process_core_step ==> Step_done with value: " ^ Boot.pp_core_expr (Core.Epure (Core.PEval cval) : Core.expr unit)) >> (* DEBUG *)
       ND.return dr_st


(*
    | Step_blocked ->
        driver with_concurrency dr_st
*)


    (* DEBUG *)
    | step ->
        match step with
          | Step_action_request debug_str tid _ ->
              error ("Step_action_request[" ^ debug_str ^ "] by thread " ^ show tid)
          | Step_tau debug_str tid _ ->
              error ("Step_tau[" ^ debug_str ^ "] by thread " ^ show tid)
          | Step_thread_done _ _ ->
              error "Step_thread_done"
          | Step_eval debug_str tid _ ->
              error ("Step_eval[" ^ debug_str ^ "] by thread " ^ show tid)
          | Step_nd debug_str _ ->
              error ("Step_nd[" ^ debug_str ^ "]")
          | Step_blocked ->
              error "Step_blocked"
          | Step_branch _ _ _ _ _ _ ->
              error "Step_branch"
          | Step_done _ ->
              error "Step_done"
          | Step_spawn_threads _ _ _ ->
              error "Step_spawn_threads"
        end


  end in
*)
(*  ND.collapse $ *) (* TODO: need to write lots of Eq instances for this to work ... *)
  drive_core_threads dr_st >>= fun post_core_dr_st ->
  
    (* TODO: hackish *)
    let non_blocked_th_sts = List.filter (fun (tid, th_info) ->
      List.any (fun step -> step <> Step_blocked) $ core_thread_step2 post_core_dr_st.core_file post_core_dr_st.symbolic_assoc tid th_info
    ) post_core_dr_st.core_state.thread_states in
  
  (if ND.current_execution_mode () = Just ND.Random then
    (* HACK The problem is that some threads are blocked (they wait
       for other threads to finish. If we randomly pick that thread to
       execute, there will not be any steps to execute, and the whole
       execution comes to a halt. To properly solve this, we need to
       implement back tracking. Since we haven't, we temporarily
       switch to exhaustive mode and also compute the steps of the
       other threads. *)
    
    ND.print_debug 6 ("FIRST: " ^ show (List.length post_core_dr_st.core_state.thread_states) ^ " vs " ^ show (List.length non_blocked_th_sts)) >>
    ND.bindExhaustive (ND.pick "driver 2" (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts)
                      (fun (tid, th_info) ->
(* OLD                       ND.return $ core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state) *)
                       ND.pick "driver 3" $ core_thread_step2 post_core_dr_st.core_file post_core_dr_st.symbolic_assoc tid th_info)
    

   else
    ND.print_debug 6 "SECOND" >>
(*
     ND.pick (* post_core_dr_st.core_state.thread_states *) non_blocked_th_sts >>= fun th_info ->
     ND.return (core_thread_step post_core_dr_st.core_file th_info post_core_dr_st.core_state)
*)
    ND.pick "driver 4" non_blocked_th_sts >>= fun (tid, th_info) ->
    ND.pick "driver 5" (core_thread_step2 post_core_dr_st.core_file post_core_dr_st.symbolic_assoc tid th_info)
  ) >>=
      process_core_step2 post_core_dr_st







val     hack: Core.file core_run_annotation -> map Symbol.t Core.value -> Core.pexpr -> Core.value
let rec hack core_file concur_sym_map pexpr =
  match core_eval core_file concur_sym_map false pexpr with
    | Exception.Result (Undefined.Defined pexpr') ->
        match Core_aux.valueFromPexpr pexpr' with
          | Just cval ->
              cval
          | Nothing ->
              hack core_file concur_sym_map pexpr'
        end
    | _ ->
        error ("Driver.hack, UNDEF/ERROR:" ^ Boot.pp_core_expr (Core.Epure pexpr : Core.expr unit))
(*
    | _ ->
        (* TODO: this is wrong *)
        expr
*)
end


let finalize_constraints core_file concur_sym_map (Constraints.Constraints symbs) =
  Constraints.Constraints $ List.map (function
    | Symbolic.SYMBop op symb1 symb2 ->
(*
        let Just symb1' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb1))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
        let Just symb2' = match hack core_file (Core.PEval (Core.Vinteger (Mem.symbolic_ival symb2))) with
                            | Core.Vinteger ival ->
                                Mem_aux.symbolicFromIntegerValue ival
                          end in
*)
        match (hack core_file concur_sym_map (Core.PEval (Core.Vsymbolic symb1)), hack core_file concur_sym_map (Core.PEval (Core.Vsymbolic symb2))) with
          | (Core.Vsymbolic symb1', Core.Vsymbolic symb2') ->
              Symbolic.SYMBop op symb1' symb2'
          | (Core.Vsymbolic symb1', cval2') ->
              Symbolic.SYMBop op symb1' (Symbolic.SYMBconst cval2')
          | (cval1, cval2) ->
              error ("Driver.finalize_constraints ==> " ^ stringFromValue cval1 ^ " <-> " ^ stringFromValue cval2)
        end
    | symb ->
        symb
  end) symbs




val finalize: string -> driver_state -> (string * (bool * Cmm_op.symState * Core.value) * (nat * nat))
let finalize debug_str dr_st =
  match dr_st.core_state.thread_states with
    | [(tid, (_, th_st))] ->
        let v = hack dr_st.core_file dr_st.symbolic_assoc
            match Core_aux.to_pure th_st.arena with
(*
              | Just (Core.PEval (Core.Vinteger ival)) ->
                  let Just symb = Mem_aux.symbolicFromIntegerValue ival in
                  Core_aux.unsymbolify symb
*)
              | Just pe ->
                  pe
              | Nothing ->
                  error ("Driver.finalize: the arena wasn't pure ==> " ^ Boot.pp_core_expr th_st.arena)
            end in
        (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout), (dr_st.blocked, dr_st.concurrency_state, v),
         (dr_st.dr_step_counter, dr_st.core_run_state.step_counter))
    | xs ->
        let () = Boot.print_debug 3 ("ERROR (end of the Driver)\n" ^ pp_core_state dr_st.core_state) in
        error ("BOOM finalize [" ^ debug_str ^ "]")
  end








(* TODO: it is problematic for proofy backend that this function may diverge *)
(* TODO: HACK *)
let initial_driver_state sym_supply file =
(*
  let mk_dr_st core_st run_st = <|
    symbol_supply=     UniqueId.new_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    concurrency_state= initialExeState emptyPreEx;
    
    (* TODO: uber hack *)
    sequential_state= Map.empty;
    blocked= false;
    trace= [];
  |> in
  let (core_st, run_st) =
    match SEU.run (init file) initial_core_run_state with
      | Exception.Result (U.Defined core_st, run_st) ->
          (core_st, run_st)
      | _ ->
          error "failed to build initial driver state"
    end in
  mk_dr_st core_st run_st
*)
  <|
    symbol_supply=     sym_supply;
    core_file=         file;
    core_state=        initial_core_state;
    core_run_state=    initial_core_run_state;
    layout_state=      Mem.initial_mem_state;
    concurrency_state= Cmm_op.symInitialState Cmm_op.symInitialPre;


  symbolic_assoc= Map.empty;
    (* TODO: uber hack *)
(*    sequential_state= Map.empty; *)
    blocked= false;
    trace= [];
    
    dr_step_counter= 0;
  |>







val driver_globals: bool -> UniqueId.supply Symbol.t -> Core.file core_run_annotation -> ND.t (Thread.thread_id * driver_state)
let driver_globals with_concurrency sym_supply file =
  let dr_st = initial_driver_state sym_supply file in
  
  (* spawning a thread for the initialisation of globals, and later the execution of main *)
  let ((tid0, core_st), run_st) = State.run (
    (* NOTE: the Eskip is just a placeholder, the thread is given its actual state later *)
    spawn_thread Nothing <|
          arena=  Core.Eskip;
          stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
          labels= Map.empty;
          exec_loc= ELoc_globals;
    |> dr_st.core_state
  ) dr_st.core_run_state in
  
  (* updating the driver state with the new thread *)
  let dr_st = <| dr_st with
    core_state= core_st;
    core_run_state= run_st
  |> in
  
  ND.foldM (fun (to_subst, dr_st) (sym, cTy, e) ->
    let _ = Boot.print_debug 6 ("eval GLOB: " ^ show sym) in
    
    (* setting up the initialisation of the current global in thread 0 *)
    let dr_st = <| dr_st with
      core_state=
        update_thread_state tid0 <|
          arena=  List.foldl (fun acc (sym', pe) ->
                    if sym <> sym' then Core_aux.subst_sym sym' pe acc else acc
                  ) e to_subst;
          stack=  Core_aux.push_empty_continuation Core_aux.empty_stack;
          labels= Map.empty;
          exec_loc= ELoc_globals;
        |> dr_st.core_state
    |> in
    
    (* evaluation of the initialisation *)
    driver with_concurrency dr_st >>= fun dr_st' ->
    
    ND.return $
      match dr_st'.core_state.thread_states with
        | [(_, (_, th_st))] ->
            (* TODO: technically the arena should always be a value at this point *)
            match Core_aux.to_pure th_st.arena with
              | Just pe ->
                  ((sym, pe) :: to_subst,
                   <| dr_st' with core_file=
                     <| dr_st'.core_file with
                       Core.funs=  Core_aux.subst_sym_fun_map sym pe dr_st'.core_file.Core.funs;
                     |>
                   |>)
              | Nothing ->
                  error "TODO(msg): Driver.driver_globals, the end of the evaluation of a glob didn't produce a value"
            end
            
        | xs ->
            error "ERROR (in Driver, global init didn't evaluate to value)"
      end
  ) ([], dr_st) dr_st.core_file.Core.globs >>= fun (_, dr_st') ->
  
  ND.return (tid0, dr_st')



val pp_exeState: Cmm_op.symState -> string
declare ocaml target_rep function pp_exeState = `Pp_cmm.pp_execState`



val drive: bool -> UniqueId.supply Symbol.t -> Core.file core_run_annotation -> list string ->
           ND.t (string * (bool * Cmm_op.symState * Core.pexpr) * (nat * nat))
let drive (with_concurrency: bool) sym_supply file (arg_strs: list string) =
  (* first we execute the body of global definitions and remove their symbols
     from the rest of the program *)
  driver_globals with_concurrency sym_supply file >>= fun (tid0, dr_st) ->
  
  (* setting the arena of thread 0 to the body of the main function *)
  match Map.lookup dr_st.core_file.Core.main dr_st.core_file.Core.funs with
    | Nothing ->
        ND.kill (ND.Other "couldn't find the startup function")
    
    | Just decl ->
        let (params, expr) = match decl with
          | Core.Fun  _ params pe ->
              (params, Core.Eret pe)
          | Core.Proc _ params e ->
              (params, e)
        end in
        
        match params with
          | [(argc_sym, _); (argv_sym, _)] ->
              (* memomy_values to be stored in memory objects pointed to by
                 the element of main.argv  *)
              let args_mem_val_tys =
                List.map (fun arg_str ->
                  let mem_vals =
                    List.map (fun c ->
                      (* TODO: fixing impl choice here (ASCII) *)
                      Mem.integer_mval AilTypes.Char $ Decode.decode_character_constant (String.toString [c])
                    ) (String.toCharList arg_str) in
                  (* NOTE: adding a null termination to the char array *)
                  (
                    Mem.array_mval $ mem_vals ++ [Mem.integer_mval AilTypes.Char 0],
                    Core_ctype.Array Core_ctype.char (Just $ (integerFromNat $ List.length mem_vals) + 1)
                  )
                ) arg_strs in
              
              (* memory value to be stored in the memory object pointed to by main.argc *)
              let argc_mem_val = Mem.integer_mval (AilTypes.Signed AilTypes.Int_) (integerFromNat $ List.length args_mem_val_tys) in
              
              (* allocating and initialising an object for main.argc *)
              liftMem (
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource [dr_st.core_file.Core.main; argc_sym]) (Mem.alignof_ival Core_ctype.signed_int) Core_ctype.signed_int) (fun ptr_val ->
                  Mem.bind (Mem.store Core_ctype.signed_int ptr_val argc_mem_val) (fun _ ->
                    Mem.return ptr_val
                  )
                )
              ) dr_st >>= fun (argc_ptr_val, dr_st) ->
              
              (* allocating and initialising the objects pointed to by the elements of argv *)
              ND.foldM (fun (ptr_vals, dr_st) (arg_mem_val, arg_ty) ->
                liftMem (
                  Mem.bind (Mem.allocate_static tid0 (Symbol.PrefOther "argv refs") (Mem.alignof_ival arg_ty) arg_ty) (fun ptr_val ->
                    Mem.bind (Mem.store arg_ty ptr_val arg_mem_val) (fun () ->
                      Mem.return (ptr_val :: ptr_vals)
                    )
                  )
                ) dr_st
              ) ([], dr_st) args_mem_val_tys >>= fun (ptr_vals_rev, dr_st) ->
              
              (* allocating and initialising an object for main.argv *)
              let argv_elem_ty = Core_ctype.Pointer AilTypes.no_qualifiers Core_ctype.char in
              let argv_ty = Core_ctype.Array argv_elem_ty (Just (integerFromNat $ List.length ptr_vals_rev)) in
              liftMem (
                Mem.bind (Mem.allocate_static tid0 (Symbol.PrefSource [dr_st.core_file.Core.main; argv_sym]) (Mem.alignof_ival argv_ty) argv_ty) (fun ptr_val ->
                  Mem.bind (Mem.store argv_ty ptr_val (Mem.array_mval $ List.map (Mem.pointer_mval argv_elem_ty) (List.reverse ptr_vals_rev))) (fun () ->
                    Mem.return ptr_val
                  )
                )
              ) dr_st >>= fun (argv_ptr_val, dr_st) ->
              
              ND.return $
                Core_aux.subst_syms [Just argc_sym; Just argv_sym]
                  (Core.PEval $ Core.Vtuple [Core.Vpointer argc_ptr_val; Core.Vpointer argv_ptr_val])
(*                  (Core.Etuple [Core.Econst $ Mem.mk_pointer argc_ptr_val; Core.Econst $ Mem.mk_pointer argv_ptr_val]) *)
                  expr
          | _ ->
              ND.return expr
        end >>= fun expr ->
        driver with_concurrency <| dr_st with
          core_state= update_thread_state tid0 <|
                        arena=  expr;
                        stack= Core_aux.push_empty_continuation Core_aux.empty_stack; (* TODO: this is probably unecessary *)
                        labels= Map.empty;
                        exec_loc= ELoc_normal [dr_st.core_file.Core.main];
                      |> dr_st.core_state
        |> >>= fun dr_st' ->
        
        if with_concurrency then
          let dr_st' = repair_pre_execution dr_st' in
          let n     = number_of_uncommitted dr_st'.concurrency_state in
          ND.log ("pre_ex: " ^ show dr_st'.concurrency_state.Cmm_op.symPre ^ "\n") >>
          ND.log ("Calling concurrency " ^ show n ^ " times\n") >>
          ND.apply_to_constraints (finalize_constraints dr_st'.core_file dr_st'.symbolic_assoc) (stepConcurrency n dr_st') >>= fun dr_st' ->
          ND.log ("with: " ^ show dr_st'.concurrency_state.Cmm_op.symWit ^ "\n") >>
          
          (* TODO: tmp *)
          ND.print_debug 2 ("UNCOMMITED ==> " ^ show (number_of_uncommitted dr_st'.concurrency_state)) >>
          ND.log (pp_exeState dr_st'.concurrency_state) >>
          
            (* TODO: the current function should return a Core.value inside an
               undef/error monad. Not a Core.pexpr like we currently do *)
            match dr_st'.concurrency_state.Cmm_op.symUndefinedness with
              | [] ->
                  let (str, (is_blocked, conc_st, cval), steps) = finalize "drive (with concur)" dr_st' in
(*                  ND.log ("Result: " ^ show (Core.Epure (Core.PEval cval)) ^ (if dr_st'.blocked then ", BLOCKED" else "") ^ "\n") >> *)
                  ND.return (str, (is_blocked, conc_st, Core.PEval cval), steps)
              | (Cmm.DataRaces _)::_ ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.Data_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.UnsequencedRaces _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.Unsequenced_race),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.IndeterminateReads _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.DUMMY),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | (Cmm.BadMutexes _)::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.DUMMY),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
              | Cmm.NotInSublanguage::_  ->
                  ND.return (List.foldr String.stringAppend "" (Dlist.toList dr_st.core_state.io.stdout),
                             (dr_st'.blocked, dr_st'.concurrency_state, Core.PEundef U.DUMMY),
                             (dr_st'.dr_step_counter, dr_st'.core_run_state.step_counter))
            end
        else
          ND.return $
            (fun (str, (is_blocked, conc_st, cval), steps) -> (str, (is_blocked, conc_st, Core.PEval cval), steps)) (finalize "drive (without concur)" dr_st')
end
