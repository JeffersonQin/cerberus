open import Pervasives Global
import Symbol AilTypes Implementation_ Undefined Memory_order
import New_memory

open import Core_ctype

module Cmm = Memory_order



(* -- Syntax ---------------------------------------------------------------- *)
type core_base_type =
  | BTy_integer (* TODO: should have and "Object" type for C arrays/struct ? *)
  | BTy_boolean
  | BTy_pointer
  | BTy_ctype
  | BTy_cfunction
  | BTy_unit
  | BTy_list of core_base_type
  | BTy_tuple of list core_base_type
  | BTy_any

(* Types discriminate between pure (TyBase) and effectful
   expressions (TyEffect) *)
type core_type =
  | TyBase   of core_base_type
  | TyEffect of core_base_type


(* Symbolic names *)
type sym = Symbol.t

(* Continuation names *)
type ksym = Symbol.t

(* Binary operators *)
type binop =
  (* arithmetic operators *)
  | OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpMod
  (* relational operators *)
  | OpEq
  | OpLt
  (* logical connectives *)
  | OpAnd
  | OpOr


(* Polarity for actions *)
type polarity =
  | Pos
  | Neg

type name =
  | Sym of sym
  | Impl of Implementation_.implementation_constant
declare {coq} rename type name = name_ (* workaround for Lem issue #87 *)


(*
type constant =
  | Cint of integer
(*  | Carray of list constant *)
(*  | Cstruct *)
  | Cfunction of sym
 *)


type constant =
  | ConstInt of integer
(*
  | Carray of list constant
  | Cfunction of Symbol.t
  | Cstring of list char (* TODO: temporary hack *)
*)


type expr 'a =
(*
  (* TODO: made obsolete by Epointer, but keep for now for Core_run.lem *)
  | Enull of Core_ctype.ctype
  | Eaddr of Memory.mem_addr
*)
  (* pure expressions *)
  | Eunit
  | Etrue
  | Efalse
  | Econst of New_memory.mem_value
(* these are folded into New_memory.mem_value
  | Epointer of New_memory.pointer_value
  | Epointer_byte of nat * nat * New_memory.pointer_value
  | Econcat_bytes of list (expr 'a) (* non empty list please *)
*)
  | Elist of list (expr 'a) (* This is for variadic functions *)
  | Ectype of ctype
  | Esym of sym
  | Eimpl of Implementation_.implementation_constant
  | Etuple of list (expr 'a)
  | Enot of expr 'a
  | Eop of binop * expr 'a * expr 'a
  | Ecall of name * list (expr 'a)
  
  
  (* I/O operations *)
  | Eoutput of string
  
  (* undefined behaviour and late static error / failed assert *)
  | Eundef of Undefined.undefined_behaviour
  | Eerror
  
  (* potentialy effectful *)
  | Eskip
  | Elet of sym * expr 'a * expr 'a
  | Eif of expr 'a * expr 'a * expr 'a
  | Eproc of set 'a * name * list (expr 'a) (* Exactely like Ecall except that the body is impure *) (* TODO: discuss whether this is proper *)
(*  | Esame of expr 'a * expr 'a *)
  | Eaction of paction 'a
  
  (* sequencing operators *)
  | Eunseq of list (expr 'a)

  | Ewseq of list (maybe sym) * expr 'a * expr 'a
  | Esseq of list (maybe sym) * expr 'a * expr 'a
  | Easeq of maybe sym * action 'a * paction 'a (* this ctor doesn't exist at runtine *)
  
  (* indeterminately-sequenced expressions and boundary *) 
  | Eindet of expr 'a (* TODO: add unique indices *) (* this ctor doesn't exist at runtine *)
  | Ebound of natural * expr 'a (* this ctor doesn't exist at runtine *)
  
  (* Continuation operators *)
  (* TODO: may have to add the possibility of storing a number instead of a ctype (for dynamically allocated objects) *)
  | Esave of ksym * list (sym * ctype) * expr 'a
  | Erun of set 'a * ksym * list (sym * expr 'a)
    (* TODO: need more for VLAs *)
  
  | Eret of expr 'a
  
  (* Non deterministic choice (resulting from indet expressions) *)
  (* TODO: this only exists for the second stage of dynamics (after core_indet) *)
  | End of list (expr 'a)
  
  (* Parallel composition *)
  | Epar of list (expr 'a)
  
(*  | Eshift of expr 'a * expr 'a (* Shift (obj: Address) (index: Integer) *) *)



(* TODO: this is a temporary, because I don't want to add pattern matching in Core, and those functions need it *)
  | Eis_scalar of expr 'a
  | Eis_integer of expr 'a
  | Eis_signed of expr 'a
  | Eis_unsigned of expr 'a






(* the qualification prefixes are for pprint *)
and action_ 'a =
  | Create of expr 'a * list Symbol.t
  | Alloc of expr 'a * list Symbol.t
  | Kill of expr 'a
  | Store of expr 'a * expr 'a * expr 'a * Cmm.memory_order
  | Load of expr 'a * expr 'a * Cmm.memory_order
  | CompareExchangeStrong of expr 'a * expr 'a * expr 'a * expr 'a * Cmm.memory_order * Cmm.memory_order
  | CompareExchangeWeak of expr 'a * expr 'a * expr 'a * expr 'a * Cmm.memory_order * Cmm.memory_order

and action 'a  = Action of set 'a * action_ 'a
and paction 'a = Paction of polarity * action 'a









type impl_decl 'a =
  | Def  of core_base_type * expr 'a
  | IFun of core_base_type * list (sym * core_base_type) * expr 'a
type impl 'a = map Implementation_.implementation_constant (impl_decl 'a)

type fun_map 'a = map sym (core_type * list (sym * core_base_type) * expr 'a)

(* a Core file is just a set of named functions *)
type file 'a = <|
  main   : sym;
  stdlib : fun_map 'a;
  impl   : impl 'a;
  defs   : list (sym * core_base_type * expr 'a);
  funs   : fun_map 'a;
|>
declare {coq} rename type impl = impl_ (* workaround for Lem issue #74 *)









(* runtime stuff *)

type _continuation 'a =
  | Kunseq of list (expr 'a) * list (expr 'a)
  | Kpar   of list (expr 'a) * list (expr 'a)
  | Kwseq  of list (maybe sym) * expr 'a
  | Ksseq  of list (maybe sym) * expr 'a

type continuation 'a = list (_continuation 'a)


type labeled_continuation 'a = list (sym * ctype) * expr 'a


type stack 'a = list (continuation 'a)
