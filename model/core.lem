(* generated by Ott 0.25 from: core.ott *)
open import Pervasives


open import Pervasives String_extra Global
import Symbol AilTypes Implementation_ Undefined Loc Cmm_csem
import Mem

open import Thread Core_ctype

module Cmm = Cmm_csem


type core_object_type =  (* Core object types *)
 | OTy_integer
 | OTy_floating
 | OTy_pointer
 | OTy_cfunction
 | OTy_array of core_object_type
 | OTy_struct of Symbol.t
 | OTy_union of Symbol.t


type core_base_type =  (* Core base types *)
 | BTy_unit (* unit *)
 | BTy_boolean (* boolean *)
 | BTy_ctype (* C type *)
 | BTy_list of core_base_type (* list *)
 | BTy_tuple of list core_base_type (* tuple *)
 | BTy_object of core_object_type (* C object value *)
 | BTy_loaded of core_object_type (* C object value or unspecified value *)


type core_type =  (* Core types *)
 | TyBase of core_base_type (* pure base type *)
 | TyEffect of core_base_type (* effectful base type *)


type binop = 
 | OpAdd
 | OpSub
 | OpMul
 | OpDiv
 | OpRem_t
 | OpRem_f
 | OpExp
 | OpEq
 | OpGt
 | OpLt
 | OpGe
 | OpLe
 | OpAnd
 | OpOr

 
 instance (Eq binop)
   let (=)  = unsafe_structural_equality
   let (<>) = unsafe_structural_inequality
 end
 
 instance (Show binop)
   let show op = 
     match op with
     | OpAdd -> "OpAdd"
     | OpSub -> "OpSub"
     | OpMul -> "OpMul"
     | OpDiv -> "OpDiv"
     | OpRem_t -> "OpRem_t"
     | OpRem_f -> "OpRem_f"
     | OpExp -> "OpExp"
     | OpEq  -> "OpEq"
     | OpGt  -> "OpGt"
     | OpLt  -> "OpLt"
     | OpGe  -> "OpGe"
     | OpLe  -> "OpLe"
     | OpAnd -> "OpAnd"
     | OpOr  -> "OpOr"
     end
 end


type polarity =  (* Polarity for actions *)
 | Pos
 | Neg


type generic_name 'sym = 
 | Sym of 'sym (* core identifier *)
 | Impl of Implementation_.implementation_constant (* implementation-defined constant *)


type generic_object_value 'sym = 
 | OVinteger of Mem.integer_value (* integer constant *)
 | OVfloating of Mem.floating_value (* floating-point constant *)
 | OVpointer of Mem.pointer_value (* TODO: CHECK  null pointer constant *)
 | OVcfunction of (generic_name 'sym) (* C function pointer *)
 | OVarray of list (generic_object_value 'sym) (* C array value *)
 | OVstruct of Symbol.t * list (Cabs.cabs_identifier * Mem.mem_value) (* C struct value *)
 | OVunion of Symbol.t * Cabs.cabs_identifier * Mem.mem_value (* C union value *)


type generic_value 'sym = 
 | Vconstrained of list (list Mem.mem_constraint * (generic_value 'sym))
 | Vobject of (generic_object_value 'sym)
 | Vloaded of (generic_object_value 'sym)
 | Vunspecified of ctype
 | Vunit
 | Vtrue
 | Vfalse
 | Vctype of ctype
 | Vlist of core_base_type * list (generic_value 'sym)
 | Vtuple of list (generic_value 'sym)


type generic_ctor 'ty = 
 | Cnil of 'ty (* empty list *)
 | Ccons (* cons *)
 | Ctuple (* tuple *)
 | Carray (* C array *)
 | Civmax (* max integer value *)
 | Civmin (* min integer value *)
 | Civsizeof (* sizeof value *)
 | Civalignof (* alignof value *)
 | Cloaded (* non-unspecified loaded value *)
 | Cunspecified (* unspecified value *)


type generic_pattern 'ty 'sym = 
 | CaseBase of maybe 'sym
 | CaseCtor of (generic_ctor 'ty) * list (generic_pattern 'ty 'sym)

type sym = Symbol.t
type ksym = Symbol.t


type pexpr_ 'ty 'sym = 
 | PEundef of Undefined.undefined_behaviour (* undefined behaviour *)
 | PEerror of string * (generic_pexpr 'ty 'sym) (* static error dependent on implementation-defined constant *)
 | PEval of (generic_value 'sym) (* value *)
 | PEconstrained of list (list Mem.mem_constraint * (generic_pexpr 'ty 'sym)) (* constrained value *)
 | PEsym of 'sym (* core identifier *)
 | PEimpl of Implementation_.implementation_constant (* implementation-defined constant *)
 | PEctor of (generic_ctor 'ty) * list (generic_pexpr 'ty 'sym) (* constructor application *)
 | PEcase of (generic_pexpr 'ty 'sym) * list ((generic_pattern 'ty 'sym) * (generic_pexpr 'ty 'sym)) (* pattern matching *)
 | PEarray_shift of (generic_pexpr 'ty 'sym) * ctype * (generic_pexpr 'ty 'sym) (* pointer array shift *)
 | PEmember_shift of (generic_pexpr 'ty 'sym) * Symbol.t * Cabs.cabs_identifier (* pointer struct/union member shift *)
 | PEnot of (generic_pexpr 'ty 'sym) (* not *)
 | PEop of binop * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) (* binop *)
 | PEmemop of Mem.pure_memop * list (generic_pexpr 'ty 'sym) (* memory operation *)
 | PEstruct of Symbol.t * list (Cabs.cabs_identifier * (generic_pexpr 'ty 'sym)) (* C struct expression *)
 | PEcall of (generic_name 'sym) * list (generic_pexpr 'ty 'sym) (* pure Core function call *)
 | PElet of (generic_pattern 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) (* Core let *)
 | PEif of (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) (* Core if *)
 | PEis_scalar of (generic_pexpr 'ty 'sym)
 | PEis_integer of (generic_pexpr 'ty 'sym)
 | PEis_signed of (generic_pexpr 'ty 'sym)
 | PEis_unsigned of (generic_pexpr 'ty 'sym)

and generic_pexpr 'ty 'sym = 
 | Pexpr of 'ty * (pexpr_ 'ty 'sym)


type generic_action_ 'ty 'sym = 
 | Create of (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * Symbol.prefix
 | Alloc of (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * Symbol.prefix
 | Kill of (generic_pexpr 'ty 'sym)
 | Store of (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * Cmm.memory_order
 | Load of (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * Cmm.memory_order
 | RMW of (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_pexpr 'ty 'sym) * Cmm.memory_order * Cmm.memory_order


type generic_action 'a 'ty 'sym = 
 | Action of Loc.t * 'a * (generic_action_ 'ty 'sym)


type generic_paction 'a 'ty 'sym = 
 | Paction of polarity * (generic_action 'a 'ty 'sym)


type generic_expr 'a 'ty 'sym = 
 | Epure of (generic_pexpr 'ty 'sym)
 | Ememop of Mem.pure_memop * list (generic_pexpr 'ty 'sym)
 | Eskip
 | Elet of (generic_pattern 'ty 'sym) * (generic_pexpr 'ty 'sym) * (generic_expr 'a 'ty 'sym)
 | Eif of (generic_pexpr 'ty 'sym) * (generic_expr 'a 'ty 'sym) * (generic_expr 'a 'ty 'sym)
 | Ecase of (generic_pexpr 'ty 'sym) * list ((generic_pattern 'ty 'sym) * (generic_expr 'a 'ty 'sym))
 | Eproc of 'a * (generic_pexpr 'ty 'sym) * list (generic_pexpr 'ty 'sym)
 | Eaction of (generic_paction 'a 'ty 'sym)
 | Eunseq of list (generic_expr 'a 'ty 'sym)
 | Ewseq of (generic_pattern 'ty 'sym) * (generic_expr 'a 'ty 'sym) * (generic_expr 'a 'ty 'sym)
 | Esseq of (generic_pattern 'ty 'sym) * (generic_expr 'a 'ty 'sym) * (generic_expr 'a 'ty 'sym)
 | Easeq of maybe (Symbol.t * core_base_type) * (generic_action 'a 'ty 'sym) * (generic_paction 'a 'ty 'sym)
 | Eindet of (generic_expr 'a 'ty 'sym)
 | Ebound of nat * (generic_expr 'a 'ty 'sym)
 | Esave of Symbol.t * list (Symbol.t * ctype) * (generic_expr 'a 'ty 'sym)
 | Erun of 'a * Symbol.t * list (Symbol.t * (generic_pexpr 'ty 'sym))
 | Ereturn of (generic_pexpr 'ty 'sym)
 | End of list (generic_expr 'a 'ty 'sym)
 | Epar of list (generic_expr 'a 'ty 'sym)
 | Ewait of Thread.thread_id
 | Eloc of Loc.t * (generic_expr 'a 'ty 'sym)


 
 type name         = generic_name Symbol.t
 type object_value = generic_object_value Symbol.t
 type value        = generic_value Symbol.t
 type ctor         = generic_ctor Symbol.t
 type pattern      = generic_pattern core_base_type Symbol.t
 type pexpr        = generic_pexpr core_base_type Symbol.t
 type expr 'a      = generic_expr 'a core_base_type Symbol.t
 type paction 'a   = generic_paction 'a core_base_type Symbol.t
 
 
 
 
 
 
 
 (* TODO: don't we need any impl proc? *)
 type impl_decl =
   | Def of core_base_type * pexpr
   | IFun of core_base_type * list (Symbol.t * core_base_type) * pexpr
 type impl = map Implementation_.implementation_constant impl_decl
 (*
 type impl_decl =
   | IConst  core_base_type * value
   | IFun core_base_type * list (sym * core_base_type) * pexpr
 type impl = map Impl_types.impl_name impl_decl
 *)
 
 
 type fun_map_decl 'a =
   | Fun of core_base_type * list (Symbol.t * core_base_type) * pexpr
   | Proc of core_base_type * list (Symbol.t * core_base_type) * expr 'a
 
 type fun_map 'a = map Symbol.t (fun_map_decl 'a)
 
 
 (* a Core file is just a set named functions *)
 type file 'a = <|
   main   : Symbol.t;
   stdlib : fun_map 'a;
   impl   : impl;
   globs  : list (Symbol.t * core_type * expr 'a);
   funs   : fun_map 'a;
 |>
 declare {coq} rename type impl = impl_ (* workaround for Lem issue #74 *)
 
 
 
 
 
 
 
 
 
 (* runtime stuff *)
 
 type continuation_element 'a =
   | Kunseq of list (expr 'a) * list (expr 'a)
   | Kwseq  of pattern * expr 'a
   | Ksseq  of pattern * expr 'a
 (*  | Ktry   list (string * expr 'a) *)
 
 
 type continuation 'a = list (continuation_element 'a)
 
 
 type labeled_continuation 'a = list (Symbol.t * ctype) * expr 'a
 
 
 type stack 'a =
   | Stack_empty
   | Stack_cons of continuation 'a * stack 'a
 
 
 
 
 
 
 (* basic class instanciations *)
 instance (SetType polarity)
   let setElemCompare = defaultCompare
 end



