open import Pervasives String_extra Global
import Symbol AilTypes Implementation_ Undefined Loc Cmm_csem
import Mem

open import Thread Core_ctype

module Cmm = Cmm_csem

(*
(TODO C signals)
type handler_event =
  string (* TODO: fixed ctors? *)
*)

(* Object types (those that may be memory read/stored, hence matching C object types) *)
type core_object_type =
  | OTy_integer
  | OTy_floating
  | OTy_pointer
  | OTy_cfunction
  | OTy_array of core_object_type
  | OTy_struct of Symbol.t
  | OTy_union of Symbol.t

type core_base_type =
  | BTy_unit
  | BTy_boolean
  | BTy_ctype
  | BTy_list of core_base_type
  | BTy_tuple of list core_base_type
  | BTy_object of core_object_type
  | BTy_loaded of core_object_type (* NOTE: same as BTy_object, but has just been loaded from memory so the value may be unspecified *)

(* Types discriminate between pure (TyBase) and effectful
   expressions (TyEffect) *)
type core_type =
  | TyBase   of core_base_type
  | TyEffect of core_base_type


(* Symbolic names *)
type sym = Symbol.t

(* Continuation names *)
type ksym = Symbol.t

(* Binary operators *)
type binop =
  (* arithmetic operators *)
  | OpAdd
  | OpSub
  | OpMul
  | OpDiv
  | OpRem_t (* this the % of C ===> rem_t(x,y) = x - ((truncate(x/y) * y) *)
  | OpRem_f (* rem_t(x,y) = x - ((foor(x/y) * y) *)
  | OpExp
  (* relational operators *)
  | OpEq
  | OpGt
  | OpLt
  | OpGe
  | OpLe
  (* logical connectives *)
  | OpAnd
  | OpOr

instance (Eq binop)
  let (=)  = unsafe_structural_equality
  let (<>) = unsafe_structural_inequality
end

instance (Show binop)
  let show op = 
    match op with
    | OpAdd -> "OpAdd"
    | OpSub -> "OpSub"
    | OpMul -> "OpMul"
    | OpDiv -> "OpDiv"
    | OpRem_t -> "OpRem_t"
    | OpRem_f -> "OpRem_f"
    | OpExp -> "OpExp"
    | OpEq  -> "OpEq"
    | OpGt  -> "OpGt"
    | OpLt  -> "OpLt"
    | OpGe  -> "OpGe"
    | OpLe  -> "OpLe"
    | OpAnd -> "OpAnd"
    | OpOr  -> "OpOr"
    end
end


(* Polarity for actions *)
type polarity =
  | Pos
  | Neg

type generic_name 'sym =
  | Sym of 'sym
  | Impl of Implementation_.implementation_constant

(*
declare {coq} rename type name = name_ (* workaround for Lem issue #87 *)

let nameEquality n1 n2 =
  match (n1, n2) with
  | (Sym s1, Sym s2)   -> s1 = s2
  | (Sym _, _)         -> false
  | (Impl i1, Impl i2) -> i1 = i2
  | (Impl _, _)        -> false
  end

instance (Eq name)
  let (=)  = nameEquality
  let (<>) = fun n1 n2 -> not (nameEquality n1 n2)
end

instance (Show name)
  let show n =
    match n with
    | Sym sym -> "Sym (" ^ show sym ^ ")"
    | Impl i  -> "Impl (?)" (* TODO *)
    end
end
*)



(* Object values (inhabitants of object types, hence values that can be read/stored) *)
type generic_object_value 'sym =
  | OVsymbolic of Symbolic.symbolic (generic_object_value 'sym) Mem.pointer_value (* symbolicity coming from the concurrency *)
  | OVinteger of Mem.integer_value
  | OVfloating of Mem.floating_value
  | OVpointer of Mem.pointer_value
  | OVcfunction of generic_name 'sym
  | OVarray of list (generic_object_value 'sym) (* Mem.mem_value *)
  | OVstruct of Symbol.t * list (Cabs.cabs_identifier * Mem.mem_value)
  | OVunion of Symbol.t * Cabs.cabs_identifier * Mem.mem_value


type generic_value 'sym =
  | Vconstrained of list (list Mem.mem_constraint * generic_value 'sym)
  | Vobject of generic_object_value 'sym
  | Vloaded of generic_object_value 'sym
  | Vunspecified of ctype
  | Vunit
  | Vtrue | Vfalse
  | Vctype of ctype
  | Vlist of core_base_type * list (generic_value 'sym)
  | Vtuple of list (generic_value 'sym)


type generic_ctor 'ty =
  | Cnil of 'ty (* : [bTy] *)
  | Ccons        (* : bTy -> [bTy] -> [bTy] *)
  | Ctuple       (* : bTy1 -> ... -> bTyN -> (bTy1, ..., bTyN) *)
  | Carray       (* : bTy -> ... -> bTy -> array bTy *)
  | Civmax       (* : ctype -> integer *)
  | Civmin       (* : ctype -> integer *)
  | Civsizeof    (* : ctype -> integer *)
  | Civalignof   (* : ctype -> integer *)
  | Cloaded      (* : objTy -> loaded objTy *)
  | Cunspecified (* : ctype -> loaded (integer|floating|pointer|array|struct|union) *)


(*
type pattern =
    list (maybe (sym * core_base_type))
*)

type generic_pattern 'ty 'sym =
  | CaseBase of maybe 'sym
  | CaseCtor of generic_ctor 'ty * list (generic_pattern 'ty 'sym)


(* pure Core expressions *)
type pexpr_ 'ty 'sym =
  (* undefined behaviour and late static error / failed assert *)
  | PEundef of Undefined.undefined_behaviour
  | PEerror of string * generic_pexpr 'ty 'sym (* the expression is for debug purpose *)

  (* values *)
  | PEval of generic_value 'sym
  | PEconstrained of list (list Mem.mem_constraint * generic_pexpr 'ty 'sym)
  
  (* names *)
  | PEsym of 'sym
  | PEimpl of Implementation_.implementation_constant
  
  (* data (de|con)structors *)
  | PEctor of generic_ctor 'ty * list (generic_pexpr 'ty 'sym)
  | PEcase of generic_pexpr 'ty 'sym * list (generic_pattern 'ty 'sym * generic_pexpr 'ty 'sym)
  
  (* operators on pointer values *)
  | PEarray_shift of generic_pexpr 'ty 'sym * ctype * generic_pexpr 'ty 'sym
  | PEmember_shift of generic_pexpr 'ty 'sym * Symbol.t * Cabs.cabs_identifier
  
  (* operators on integers *)
  | PEnot of generic_pexpr 'ty 'sym
  | PEop of binop * generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym
  
  (* pure operations provide by the memory layout model *)
  | PEmemop of Mem.pure_memop * list (generic_pexpr 'ty 'sym)
  (* these two are annoying *)
  | PEstruct of Symbol.t * list (Cabs.cabs_identifier * generic_pexpr 'ty 'sym)

  (* call to a pure function *)
  | PEcall of generic_name 'sym * list (generic_pexpr 'ty 'sym)
  
  | PElet of generic_pattern 'ty 'sym * generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym
  | PEif of generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym
  
(*  | PEvla of ctype * pexpr *)


  (* TODO: this is a temporary, because I don't want to add pattern matching in Core, and those functions need it *)
  | PEis_scalar of generic_pexpr 'ty 'sym
  | PEis_integer of generic_pexpr 'ty 'sym
  | PEis_signed of generic_pexpr 'ty 'sym
  | PEis_unsigned of generic_pexpr 'ty 'sym

and generic_pexpr 'ty 'sym =
  Pexpr of 'ty * pexpr_ 'ty 'sym

type generic_expr 'a 'ty 'sym =
  (* pure expression *)
  | Epure of generic_pexpr 'ty 'sym
  (* operations (that either require sequencing or are ND) provide by the memory layout model *)
  | Ememop of Mem.memop * list (generic_pexpr 'ty 'sym)
(*
(TODO C signals)
  (* these two are to deal with C signals *)
  | Eraise of handler_event
  | Eregister of handler_event * name
*)
  (* potentially effectful *)
  | Eskip
  | Elet of generic_pattern 'ty 'sym * generic_pexpr 'ty 'sym * generic_expr 'a 'ty 'sym
  | Eif of generic_pexpr 'ty 'sym * generic_expr 'a 'ty 'sym * generic_expr 'a 'ty 'sym
  | Ecase of generic_pexpr 'ty 'sym * list (generic_pattern 'ty 'sym * generic_expr 'a 'ty 'sym)
  | Eproc of 'a * generic_pexpr 'ty 'sym * list (generic_pexpr 'ty 'sym)
  | Eaction of generic_paction 'a 'ty 'sym
  (* sequencing operators *)
  | Eunseq of list (generic_expr 'a 'ty 'sym)
  | Ewseq of generic_pattern 'ty 'sym * generic_expr 'a 'ty 'sym * generic_expr 'a 'ty 'sym
  | Esseq of generic_pattern 'ty 'sym * generic_expr 'a 'ty 'sym * generic_expr 'a 'ty 'sym
  | Easeq of maybe (Symbol.t * core_base_type) * generic_action 'a 'ty 'sym * generic_paction 'a 'ty 'sym (* this ctor doesn't exist at runtine *)
  (* indeterminately-sequenced expressions and boundary *) 
  | Eindet of generic_expr 'a 'ty 'sym (* TODO: add unique indices *) (* this ctor doesn't exist at runtine *)
  | Ebound of nat * generic_expr 'a 'ty 'sym (* this ctor doesn't exist at runtine *)
  (* Continuation operators *)
  (* TODO: may have to add the possibility of storing a number instead of a ctype (for dynamically allocated objects) *)
  | Esave of ksym * list (Symbol.t * ctype) * generic_expr 'a 'ty 'sym
  | Erun of 'a * ksym * list (Symbol.t * generic_pexpr 'ty 'sym)
  | Ereturn of generic_pexpr 'ty 'sym
  (* Non deterministic choice (resulting from indet expressions) *)
  (* TODO: this only exists for the second stage of dynamics (after core_indet) *)
  | End of list (generic_expr 'a 'ty 'sym)
  (* Thread operators *)
  (* TODO: this ctor is kind of redundant once we add Espawn, since we have Eunseq ... *)
  | Epar of list (generic_expr 'a 'ty 'sym) (* Parallel composition: for cppmem-style composition *)
  | Ewait of Thread.thread_id (* TODO: this will need to have a Core type annotation to allow typecheck ... *)
  | Eloc of Loc.t * generic_expr 'a 'ty 'sym

(* the qualification prefixes are for pprint *)
and generic_action_ 'ty 'sym =
  | Create of generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym * Symbol.prefix (* the expr arguments are: alignment requirement, effective type *)
  | Alloc of generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym * Symbol.prefix  (* the expr arguments are: alignment requirement, space size *)
  | Kill of generic_pexpr 'ty 'sym
  | Store of generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym * Cmm.memory_order
  | Load of generic_pexpr 'ty 'sym * generic_pexpr 'ty 'sym * Cmm.memory_order
  | RMW of generic_pexpr 'ty 'sym(* ctype *) * generic_pexpr 'ty 'sym(* object_ptr *) * generic_pexpr 'ty 'sym(* expected_val *) * generic_pexpr 'ty 'sym(* desired_val *) * Cmm.memory_order * Cmm.memory_order

(*
  | CompareExchangeStrong of pexpr * pexpr * pexpr * pexpr * Cmm.memory_order * Cmm.memory_order
  | CompareExchangeWeak of pexpr * pexpr * pexpr * pexpr * Cmm.memory_order * Cmm.memory_order
*)
  
  (* TODO: it annoying (maybe wrong) that these are actions *)
(*  | Ptr of pointer_action * list pexpr *)

and generic_action 'a 'ty 'sym = Action of Loc.t * 'a * generic_action_ 'ty 'sym
and generic_paction 'a 'ty 'sym = Paction of polarity * generic_action 'a 'ty 'sym

type name         = generic_name Symbol.t
type object_value = generic_object_value Symbol.t
type value        = generic_value Symbol.t
type ctor         = generic_ctor Symbol.t
type pattern      = generic_pattern core_base_type Symbol.t
type pexpr        = generic_pexpr core_base_type Symbol.t
type expr 'a      = generic_expr 'a core_base_type Symbol.t
type paction 'a   = generic_paction 'a core_base_type Symbol.t







(* TODO: don't we need any impl proc? *)
type impl_decl =
  | Def  of core_base_type * pexpr
  | IFun of core_base_type * list (Symbol.t * core_base_type) * pexpr
type impl = map Implementation_.implementation_constant impl_decl
(*
type impl_decl =
  | IConst  of core_base_type * value
  | IFun of core_base_type * list (sym * core_base_type) * pexpr
type impl = map Impl_types.impl_name impl_decl
*)


type fun_map_decl 'a =
  | Fun  of core_base_type * list (Symbol.t * core_base_type) * pexpr
  | Proc of core_base_type * list (Symbol.t * core_base_type) * expr 'a

type fun_map 'a = map Symbol.t (fun_map_decl 'a)


(* a Core file is just a set of named functions *)
type file 'a = <|
  main   : Symbol.t;
  stdlib : fun_map 'a;
  impl   : impl;
  globs  : list (Symbol.t * core_type * expr 'a);
  funs   : fun_map 'a;
|>
declare {coq} rename type impl = impl_ (* workaround for Lem issue #74 *)









(* runtime stuff *)

type continuation_element 'a =
  | Kunseq of list (expr 'a) * list (expr 'a)
  | Kwseq  of pattern * expr 'a
  | Ksseq  of pattern * expr 'a
(*  | Ktry   of list (string * expr 'a) *)


type continuation 'a = list (continuation_element 'a)


type labeled_continuation 'a = list (Symbol.t * ctype) * expr 'a


type stack 'a =
  | Stack_empty
  | Stack_cons of continuation 'a * stack 'a






(* basic class instanciations *)
instance (SetType polarity)
  let setElemCompare = defaultCompare
end
